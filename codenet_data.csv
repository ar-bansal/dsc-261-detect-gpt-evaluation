problem_id,statement,language,code,human_generated
p00001,"List of Top 3 Hills
There is a data which provides heights (in meter) of mountains. The data is only for ten mountains.
Write a program which prints heights of the top three mountains in descending order.
Input
Height of mountain 1
Height of mountain 2
Height of mountain 3
 .
 .
Height of mountain 10
Constraints
0 ≤ height of mountain (integer) ≤ 10,000
Output
Height of the 1st mountain
Height of the 2nd mountain
Height of the 3rd mountain
Sample Input 1
1819
2003
876
2840
1723
1673
3776
2848
1592
922
Output for the Sample Input 1
3776
2848
2840
Sample Input 2
100
200
300
400
500
600
700
800
900
900
Output for the Sample Input 2
900
900
800",C,"#include <stdio.h>

int main() {
    int heights[10];
    int i, j;
    
    for (i = 0; i < 10; i++) {
        scanf(""%d"", &heights[i]);
    }
    
    for (i = 0; i < 10; i++) {
        for (j = i + 1; j < 10; j++) {
            if (heights[i] < heights[j]) {
                int temp = heights[i];
                heights[i] = heights[j];
                heights[j] = temp;
            }
        }
    }
    
    printf(""%d\n"", heights[0]);
    printf(""%d\n"", heights[1]);
    printf(""%d\n"", heights[2]);
    
    return 0;
}
",0
p00001,"List of Top 3 Hills
There is a data which provides heights (in meter) of mountains. The data is only for ten mountains.
Write a program which prints heights of the top three mountains in descending order.
Input
Height of mountain 1
Height of mountain 2
Height of mountain 3
 .
 .
Height of mountain 10
Constraints
0 ≤ height of mountain (integer) ≤ 10,000
Output
Height of the 1st mountain
Height of the 2nd mountain
Height of the 3rd mountain
Sample Input 1
1819
2003
876
2840
1723
1673
3776
2848
1592
922
Output for the Sample Input 1
3776
2848
2840
Sample Input 2
100
200
300
400
500
600
700
800
900
900
Output for the Sample Input 2
900
900
800",C,"#include <stdio.h>
int main(void)
{
	int a[10];
	int i;
	int MAX[3];
	for(i = 0; i < 10; i++)
	{
		scanf(""%d"", &a[i]);
	}
	for(i = 0; i < 3; i++)
	{
		MAX[i] = 0;
	}
	for(i = 0; i < 10; i++)
	{
		if(MAX[0] < a[i])
		{
			MAX[0] = a[i];
		}
	}
	for(i = 0; i < 10; i++)
	{
		if(MAX[1] < a[i])
		{
			if(a[i] < MAX[0])
			{
				MAX[1] = a[i];
			}
		}
	}
	for(i = 0; i < 10; i++)
	{
		if(MAX[2] < a[i])
		{
			if(a[i] < MAX[1])
			{
				MAX[2] = a[i];
			}
		}
	}
	for(i = 0; i < 3; i++)
	{
		printf(""%d\n"", MAX[i]);
	}
	return 0;
}",1
p00001,"List of Top 3 Hills
There is a data which provides heights (in meter) of mountains. The data is only for ten mountains.
Write a program which prints heights of the top three mountains in descending order.
Input
Height of mountain 1
Height of mountain 2
Height of mountain 3
 .
 .
Height of mountain 10
Constraints
0 ≤ height of mountain (integer) ≤ 10,000
Output
Height of the 1st mountain
Height of the 2nd mountain
Height of the 3rd mountain
Sample Input 1
1819
2003
876
2840
1723
1673
3776
2848
1592
922
Output for the Sample Input 1
3776
2848
2840
Sample Input 2
100
200
300
400
500
600
700
800
900
900
Output for the Sample Input 2
900
900
800",Java,"import java.util.*;

public class Main {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        Integer[] heights = new Integer[10];
        
        for (int i = 0; i < 10; i++) {
            heights[i] = sc.nextInt();
        }
        
        Arrays.sort(heights, Collections.reverseOrder());
        
        System.out.println(heights[0]);
        System.out.println(heights[1]);
        System.out.println(heights[2]);
        
        sc.close();
    }
}
",0
p00001,"List of Top 3 Hills
There is a data which provides heights (in meter) of mountains. The data is only for ten mountains.
Write a program which prints heights of the top three mountains in descending order.
Input
Height of mountain 1
Height of mountain 2
Height of mountain 3
 .
 .
Height of mountain 10
Constraints
0 ≤ height of mountain (integer) ≤ 10,000
Output
Height of the 1st mountain
Height of the 2nd mountain
Height of the 3rd mountain
Sample Input 1
1819
2003
876
2840
1723
1673
3776
2848
1592
922
Output for the Sample Input 1
3776
2848
2840
Sample Input 2
100
200
300
400
500
600
700
800
900
900
Output for the Sample Input 2
900
900
800",Java,"public class Main{
	public static void main(String[] a) throws Exception {
		int[] heights = new int[10];
		for (int i = 0; i < 10; i++) {
			BufferedReader height = new BufferedReader(new InputStreamReader(System.in));	
			heights[i] = Integer.parseInt(height.readLine());
			System.out.println(heights[i]);
		}
		Arrays.sort(heights);
		System.out.println(heights[0]);
		System.out.println(heights[1]);
		System.out.println(heights[2]);
	}
}",1
p00001,"List of Top 3 Hills
There is a data which provides heights (in meter) of mountains. The data is only for ten mountains.
Write a program which prints heights of the top three mountains in descending order.
Input
Height of mountain 1
Height of mountain 2
Height of mountain 3
 .
 .
Height of mountain 10
Constraints
0 ≤ height of mountain (integer) ≤ 10,000
Output
Height of the 1st mountain
Height of the 2nd mountain
Height of the 3rd mountain
Sample Input 1
1819
2003
876
2840
1723
1673
3776
2848
1592
922
Output for the Sample Input 1
3776
2848
2840
Sample Input 2
100
200
300
400
500
600
700
800
900
900
Output for the Sample Input 2
900
900
800",Python,"heights = []
for _ in range(10):
    heights.append(int(input()))

heights.sort(reverse=True)

for i in range(3):
    print(heights[i])
",0
p00001,"List of Top 3 Hills
There is a data which provides heights (in meter) of mountains. The data is only for ten mountains.
Write a program which prints heights of the top three mountains in descending order.
Input
Height of mountain 1
Height of mountain 2
Height of mountain 3
 .
 .
Height of mountain 10
Constraints
0 ≤ height of mountain (integer) ≤ 10,000
Output
Height of the 1st mountain
Height of the 2nd mountain
Height of the 3rd mountain
Sample Input 1
1819
2003
876
2840
1723
1673
3776
2848
1592
922
Output for the Sample Input 1
3776
2848
2840
Sample Input 2
100
200
300
400
500
600
700
800
900
900
Output for the Sample Input 2
900
900
800",Python,"import sys
e = sys.stdin.readlines()
e = [int(i) for i in e]
for i in range(3):
    m = max(e)
    e.remove(m)
    print (m)
",1
p00003,"Is it a Right Triangle?
Write a program which judges wheather given length of three side form a right triangle. Print ""
YES
"" if the given sides (integers) form a right triangle, ""
NO
"" if not so.
Input
Input consists of several data sets. In the first line, the number of data set,
N
is given. Then,
N
lines follow, each line corresponds to a data set. A data set consists of three integers separated by a single space.
Constraints
1 ≤ length of the side ≤ 1,000
N
≤ 1,000
Output
For each data set, print ""
YES
"" or ""
NO
"".
Sample Input
3
4 3 5
4 3 6
8 8 8
Output for the Sample Input
YES
NO
NO",C,"#include <stdio.h>

int main() {
    int n;
    scanf(""%d"", &n);
    
    while (n--) {
        int a, b, c;
        scanf(""%d %d %d"", &a, &b, &c);
        
        int aa = a * a;
        int bb = b * b;
        int cc = c * c;
        
        if (aa + bb == cc || aa + cc == bb || bb + cc == aa) {
            printf(""YES\n"");
        } else {
            printf(""NO\n"");
        }
    }
    
    return 0;
}
",0
p00003,"Is it a Right Triangle?
Write a program which judges wheather given length of three side form a right triangle. Print ""
YES
"" if the given sides (integers) form a right triangle, ""
NO
"" if not so.
Input
Input consists of several data sets. In the first line, the number of data set,
N
is given. Then,
N
lines follow, each line corresponds to a data set. A data set consists of three integers separated by a single space.
Constraints
1 ≤ length of the side ≤ 1,000
N
≤ 1,000
Output
For each data set, print ""
YES
"" or ""
NO
"".
Sample Input
3
4 3 5
4 3 6
8 8 8
Output for the Sample Input
YES
NO
NO",C,"#include<stdio.h>

int main()
{
int N, i, a, b, c, max;

scanf(""%d"", &N);

for(i=0; i<N; i++){
scanf(""%d %d %d"", &a, &b, &c);

if(a<=b && b<=c){
max = c;
if(c*c==a*a+b*b){
puts(""YES"");
}else{
puts(""NO"");
}
}
else if(a<=c && c<=b){
max = b;
if(b*b==a*a+c*c){
puts(""YES"");
}else{
puts(""NO"");
}
}
else if(b<=c && c<=a){
max = a;
if(a*a==b*b+c*c){
puts(""YES"");
}else{
puts(""NO"");
}
}
else if(b<=a && a<=c){
max = c;
if(c*c==a*a+b*b){
puts(""YES"");
}else{
puts(""NO"");
}
}
else if(c<=a && a<=b){
max = b;
if(b*b==a*a+c*c){
puts(""YES"");
}else{
puts(""NO"");
}
}
else if(c<=b && b<=a){
max = a;
if(a*a==b*b+c*c){
puts(""YES"");
}else{
puts(""NO"");
}
}

}

return 0;
}",1
p00003,"Is it a Right Triangle?
Write a program which judges wheather given length of three side form a right triangle. Print ""
YES
"" if the given sides (integers) form a right triangle, ""
NO
"" if not so.
Input
Input consists of several data sets. In the first line, the number of data set,
N
is given. Then,
N
lines follow, each line corresponds to a data set. A data set consists of three integers separated by a single space.
Constraints
1 ≤ length of the side ≤ 1,000
N
≤ 1,000
Output
For each data set, print ""
YES
"" or ""
NO
"".
Sample Input
3
4 3 5
4 3 6
8 8 8
Output for the Sample Input
YES
NO
NO",Java,"import java.util.Scanner;
import java.util.Arrays;

public class Main {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int n = sc.nextInt();
        
        for (int i = 0; i < n; i++) {
            int[] sides = new int[3];
            sides[0] = sc.nextInt();
            sides[1] = sc.nextInt();
            sides[2] = sc.nextInt();
            
            Arrays.sort(sides);
            
            if (sides[0] * sides[0] + sides[1] * sides[1] == sides[2] * sides[2]) {
                System.out.println(""YES"");
            } else {
                System.out.println(""NO"");
            }
        }
        
        sc.close();
    }
}
",0
p00003,"Is it a Right Triangle?
Write a program which judges wheather given length of three side form a right triangle. Print ""
YES
"" if the given sides (integers) form a right triangle, ""
NO
"" if not so.
Input
Input consists of several data sets. In the first line, the number of data set,
N
is given. Then,
N
lines follow, each line corresponds to a data set. A data set consists of three integers separated by a single space.
Constraints
1 ≤ length of the side ≤ 1,000
N
≤ 1,000
Output
For each data set, print ""
YES
"" or ""
NO
"".
Sample Input
3
4 3 5
4 3 6
8 8 8
Output for the Sample Input
YES
NO
NO",Java,"import java.util.Scanner;
public class Main{

	public static void main(String[] args) {
		// TODO ?????????????????????????????????????????????
		Scanner kb=new Scanner(System.in);
int size=kb.nextInt();
int a[][]=new int[size][3];
int x,y,z;
for(int i=0;i<size;i++){
	a[i][0]=kb.nextInt();
	a[i][1]=kb.nextInt();
	a[i][2]=kb.nextInt();
}
for(int i=0;i<size;i++){
x=a[i][0];
y=a[i][1];
z=a[i][2];
if(x*x+y*y==z*z||y*y+z*z==x*x||z*z+x*x==y*y){
	System.out.println(""YES"");
}else{
	System.out.println(""NO"");
}
}
	}

}",1
p00003,"Is it a Right Triangle?
Write a program which judges wheather given length of three side form a right triangle. Print ""
YES
"" if the given sides (integers) form a right triangle, ""
NO
"" if not so.
Input
Input consists of several data sets. In the first line, the number of data set,
N
is given. Then,
N
lines follow, each line corresponds to a data set. A data set consists of three integers separated by a single space.
Constraints
1 ≤ length of the side ≤ 1,000
N
≤ 1,000
Output
For each data set, print ""
YES
"" or ""
NO
"".
Sample Input
3
4 3 5
4 3 6
8 8 8
Output for the Sample Input
YES
NO
NO",Python,"n = int(input())
for _ in range(n):
    sides = list(map(int, input().split()))
    sides.sort()
    if sides[0]**2 + sides[1]**2 == sides[2]**2:
        print(""YES"")
    else:
        print(""NO"")
",0
p00003,"Is it a Right Triangle?
Write a program which judges wheather given length of three side form a right triangle. Print ""
YES
"" if the given sides (integers) form a right triangle, ""
NO
"" if not so.
Input
Input consists of several data sets. In the first line, the number of data set,
N
is given. Then,
N
lines follow, each line corresponds to a data set. A data set consists of three integers separated by a single space.
Constraints
1 ≤ length of the side ≤ 1,000
N
≤ 1,000
Output
For each data set, print ""
YES
"" or ""
NO
"".
Sample Input
3
4 3 5
4 3 6
8 8 8
Output for the Sample Input
YES
NO
NO",Python,"N = int(input())
for i in range(N):
    triangle = sorted([int(n) for n in input().split()])
    if triangle[0]**2 + triangle[1]**2 == triangle[2]**2:
        print('YES')
    else:
        print('NO')

",1
p00004,"Simultaneous Equation
Write a program which solve a simultaneous equation:
ax + by = c
dx + ey = f
The program should print
x
and
y
for given
a
,
b
,
c
,
d
,
e
and
f
(-1,000 ≤
a, b, c, d, e, f
≤ 1,000). You can suppose that given equation has a unique solution.
Input
The input consists of several data sets, 1 line for each data set. In a data set, there will be
a, b, c, d, e, f
separated by a single space. The input terminates with EOF.
Output
For each data set, print
x
and
y
separated by a single space. Print the solution to three places of decimals. Round off the solution to three decimal places.
Sample Input 1
1 2 3 4 5 6
2 -1 -2 -1 -1 -5
Output for the Sample Input 1
-1.000 2.000
1.000 4.000
Sample Input 2
2 -1 -3 1 -1 -3
2 -1 -3 -9 9 27
Output for the Sample Input 2
0.000 3.000
0.000 3.000",C,"#include <stdio.h>

int main() {
    double a, b, c, d, e, f;
    
    while (scanf(""%lf %lf %lf %lf %lf %lf"", &a, &b, &c, &d, &e, &f) != EOF) {
        double x, y;
        double det = a * e - b * d;
        
        x = (c * e - b * f) / det;
        y = (a * f - c * d) / det;
        
        printf(""%.3f %.3f\n"", x, y);
    }
    
    return 0;
}
",0
p00004,"Simultaneous Equation
Write a program which solve a simultaneous equation:
ax + by = c
dx + ey = f
The program should print
x
and
y
for given
a
,
b
,
c
,
d
,
e
and
f
(-1,000 ≤
a, b, c, d, e, f
≤ 1,000). You can suppose that given equation has a unique solution.
Input
The input consists of several data sets, 1 line for each data set. In a data set, there will be
a, b, c, d, e, f
separated by a single space. The input terminates with EOF.
Output
For each data set, print
x
and
y
separated by a single space. Print the solution to three places of decimals. Round off the solution to three decimal places.
Sample Input 1
1 2 3 4 5 6
2 -1 -2 -1 -1 -5
Output for the Sample Input 1
-1.000 2.000
1.000 4.000
Sample Input 2
2 -1 -3 1 -1 -3
2 -1 -3 -9 9 27
Output for the Sample Input 2
0.000 3.000
0.000 3.000",C,"#include <stdio.h>

int main( void )
{
    int a,b,c,d,e,f;
    float x,y;
    
    while(scanf(""%d %d %d %d %d %d"",&a,&b,&c,&d,&e,&f)!=-1){    
        y = (float)( c*d -a*f ) / (b*d-a*e); 
        x = (float)( c*e -b*f ) / (a*e-b*d);
        if(-0.0005<x && x<=0 ){
            x = 0;
        }
        if(-0.0005<y && y<=0 ){
            y = 0;
        }
        printf( ""%.3lf %.3f\n"",x,y); 
    }
    return 0;
}",1
p00004,"Simultaneous Equation
Write a program which solve a simultaneous equation:
ax + by = c
dx + ey = f
The program should print
x
and
y
for given
a
,
b
,
c
,
d
,
e
and
f
(-1,000 ≤
a, b, c, d, e, f
≤ 1,000). You can suppose that given equation has a unique solution.
Input
The input consists of several data sets, 1 line for each data set. In a data set, there will be
a, b, c, d, e, f
separated by a single space. The input terminates with EOF.
Output
For each data set, print
x
and
y
separated by a single space. Print the solution to three places of decimals. Round off the solution to three decimal places.
Sample Input 1
1 2 3 4 5 6
2 -1 -2 -1 -1 -5
Output for the Sample Input 1
-1.000 2.000
1.000 4.000
Sample Input 2
2 -1 -3 1 -1 -3
2 -1 -3 -9 9 27
Output for the Sample Input 2
0.000 3.000
0.000 3.000",Java,"import java.util.Scanner;

public class Main {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        
        while (sc.hasNext()) {
            double a = sc.nextDouble();
            double b = sc.nextDouble();
            double c = sc.nextDouble();
            double d = sc.nextDouble();
            double e = sc.nextDouble();
            double f = sc.nextDouble();
            
            double det = a * e - b * d;
            double x = (c * e - b * f) / det;
            double y = (a * f - c * d) / det;
            
            System.out.printf(""%.3f %.3f%n"", x, y);
        }
        
        sc.close();
    }
}
",0
p00004,"Simultaneous Equation
Write a program which solve a simultaneous equation:
ax + by = c
dx + ey = f
The program should print
x
and
y
for given
a
,
b
,
c
,
d
,
e
and
f
(-1,000 ≤
a, b, c, d, e, f
≤ 1,000). You can suppose that given equation has a unique solution.
Input
The input consists of several data sets, 1 line for each data set. In a data set, there will be
a, b, c, d, e, f
separated by a single space. The input terminates with EOF.
Output
For each data set, print
x
and
y
separated by a single space. Print the solution to three places of decimals. Round off the solution to three decimal places.
Sample Input 1
1 2 3 4 5 6
2 -1 -2 -1 -1 -5
Output for the Sample Input 1
-1.000 2.000
1.000 4.000
Sample Input 2
2 -1 -3 1 -1 -3
2 -1 -3 -9 9 27
Output for the Sample Input 2
0.000 3.000
0.000 3.000",Java,"import java.io.*;

class Main {
	public static void main(String args[]) {
		try {
			BufferedReader reader = new BufferedReader(new InputStreamReader(System.in));
			String t[], s;
			double a[] = new double[6];
			while((s = reader.readLine())  != null) {
				t = s.split("" "");
				for(int i = 0;i < a.length;i++) {
					a[i] = Double.parseDouble(t[i]);
				}
				double z = a[0]*a[4]-a[1]*a[3];
				double x = (a[4]*a[2]-a[1]*a[5])/z;
				double y = (-a[3]*a[2]+a[0]*a[5])/z;

				if(x == -0.0)
					x = 0.0;
				if(y == -0.0)
					y = 0.0;
				System.out.printf(""%4.3f %4.3f\n"", x, y);

			}

		}
		catch(IOException e) {
			System.out.println(e);
		}
	}
}",1
p00004,"Simultaneous Equation
Write a program which solve a simultaneous equation:
ax + by = c
dx + ey = f
The program should print
x
and
y
for given
a
,
b
,
c
,
d
,
e
and
f
(-1,000 ≤
a, b, c, d, e, f
≤ 1,000). You can suppose that given equation has a unique solution.
Input
The input consists of several data sets, 1 line for each data set. In a data set, there will be
a, b, c, d, e, f
separated by a single space. The input terminates with EOF.
Output
For each data set, print
x
and
y
separated by a single space. Print the solution to three places of decimals. Round off the solution to three decimal places.
Sample Input 1
1 2 3 4 5 6
2 -1 -2 -1 -1 -5
Output for the Sample Input 1
-1.000 2.000
1.000 4.000
Sample Input 2
2 -1 -3 1 -1 -3
2 -1 -3 -9 9 27
Output for the Sample Input 2
0.000 3.000
0.000 3.000",Python,"import sys

for line in sys.stdin:
    a, b, c, d, e, f = map(float, line.split())
    
    # Using Cramer's rule
    # ax + by = c
    # dx + ey = f
    
    det = a * e - b * d
    
    if det != 0:
        x = (c * e - b * f) / det
        y = (a * f - c * d) / det
    else:
        # This shouldn't happen as per problem statement (unique solution)
        x = 0
        y = 0
    
    print(f""{x:.3f} {y:.3f}"")
",0
p00004,"Simultaneous Equation
Write a program which solve a simultaneous equation:
ax + by = c
dx + ey = f
The program should print
x
and
y
for given
a
,
b
,
c
,
d
,
e
and
f
(-1,000 ≤
a, b, c, d, e, f
≤ 1,000). You can suppose that given equation has a unique solution.
Input
The input consists of several data sets, 1 line for each data set. In a data set, there will be
a, b, c, d, e, f
separated by a single space. The input terminates with EOF.
Output
For each data set, print
x
and
y
separated by a single space. Print the solution to three places of decimals. Round off the solution to three decimal places.
Sample Input 1
1 2 3 4 5 6
2 -1 -2 -1 -1 -5
Output for the Sample Input 1
-1.000 2.000
1.000 4.000
Sample Input 2
2 -1 -3 1 -1 -3
2 -1 -3 -9 9 27
Output for the Sample Input 2
0.000 3.000
0.000 3.000",Python,"import sys
for line in sys.stdin:
    a,b,c,d,e,f = map(float, line.split())
    print((c*e-b*f)/(a*e-b*d), (a*f-c*d)/(a*e-b*d))",1
p00005,"GCD and LCM
Write a program which computes the greatest common divisor (GCD) and the least common multiple (LCM) of given
a
and
b
.
Input
Input consists of several data sets. Each data set contains
a
and
b
separated by a single space in a line. The input terminates with EOF.
Constraints
0 <
a, b
≤ 2,000,000,000
LCM(
a, b
) ≤ 2,000,000,000
The number of data sets ≤ 50
Output
For each data set, print GCD and LCM separated by a single space in a line.
Sample Input
8 6
50000000 30000000
Output for the Sample Input
2 24
10000000 150000000",C,"#include <stdio.h>

long long gcd(long long a, long long b) {
    while (b != 0) {
        long long temp = b;
        b = a % b;
        a = temp;
    }
    return a;
}

int main() {
    long long a, b;
    while (scanf(""%lld %lld"", &a, &b) != EOF) {
        long long g = gcd(a, b);
        long long lcm = (a / g) * b;
        printf(""%lld %lld\n"", g, lcm);
    }
    return 0;
}
",0
p00005,"GCD and LCM
Write a program which computes the greatest common divisor (GCD) and the least common multiple (LCM) of given
a
and
b
.
Input
Input consists of several data sets. Each data set contains
a
and
b
separated by a single space in a line. The input terminates with EOF.
Constraints
0 <
a, b
≤ 2,000,000,000
LCM(
a, b
) ≤ 2,000,000,000
The number of data sets ≤ 50
Output
For each data set, print GCD and LCM separated by a single space in a line.
Sample Input
8 6
50000000 30000000
Output for the Sample Input
2 24
10000000 150000000",C,"#include<stdio.h>

int main(void){
    int a,b,c,tmp,tmp_a,tmp_b;
    while(scanf(""%d%d"", &a, &b)!=EOF){
        c = 1;
        if(b > a){tmp = a; a = b; b = tmp;}
        tmp_a = a;
        tmp_b = b;
        for(int i=2; i<=tmp_b; i++){
            while(tmp_b%i==0 && tmp_a%i==0){
                c = c*i;
                tmp_b = tmp_b / i;
                tmp_a = tmp_a / i;
            }
        }
        printf(""%d %d\n"", c, tmp_a*tmp_b*c);
    }
    return 0;
}

",1
p00005,"GCD and LCM
Write a program which computes the greatest common divisor (GCD) and the least common multiple (LCM) of given
a
and
b
.
Input
Input consists of several data sets. Each data set contains
a
and
b
separated by a single space in a line. The input terminates with EOF.
Constraints
0 <
a, b
≤ 2,000,000,000
LCM(
a, b
) ≤ 2,000,000,000
The number of data sets ≤ 50
Output
For each data set, print GCD and LCM separated by a single space in a line.
Sample Input
8 6
50000000 30000000
Output for the Sample Input
2 24
10000000 150000000",Java,"import java.util.Scanner;

public class Main {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        
        while (sc.hasNext()) {
            long a = sc.nextLong();
            long b = sc.nextLong();
            
            long gcd = gcd(a, b);
            long lcm = (a / gcd) * b;
            
            System.out.println(gcd + "" "" + lcm);
        }
        
        sc.close();
    }
    
    static long gcd(long a, long b) {
        while (b != 0) {
            long temp = b;
            b = a % b;
            a = temp;
        }
        return a;
    }
}
",0
p00005,"GCD and LCM
Write a program which computes the greatest common divisor (GCD) and the least common multiple (LCM) of given
a
and
b
.
Input
Input consists of several data sets. Each data set contains
a
and
b
separated by a single space in a line. The input terminates with EOF.
Constraints
0 <
a, b
≤ 2,000,000,000
LCM(
a, b
) ≤ 2,000,000,000
The number of data sets ≤ 50
Output
For each data set, print GCD and LCM separated by a single space in a line.
Sample Input
8 6
50000000 30000000
Output for the Sample Input
2 24
10000000 150000000",Java,"import java.io.*;

public class Main{
	/*
	public static long findGcd(long f1, long f2){
		long gcd = 1;
		long max, min;
		if(f1 > f2){max = f1; min = f2;}
		else{max = f2; min = f1;}
		for(long i=1; i<=(long)(Math.sqrt(min)+1); i++){
			if(min % i == 0){
				long tmp = min / i;
				if((max % tmp) == 0){
					gcd = tmp;
					break;
				}
			}
		}
		return gcd;
	}
	*/
	static long findGcd(long x, long y){
        for(long i=1; i<=x; i++){
            if(y*i%x==0){
                return y*i;
            }
        }
        return 0;
    }
	
	public static long findlcm(long f1, long f2){
		long lcm = 0;
		long max, min;
		if(f1 > f2){max = f1; min = f2;}
		else{max = f2; min = f1;}
		long i=1;
		while(lcm == 0){
			if((max * i)%min == 0){
				lcm = max * i;
			}
			i++;
		}
		return lcm;
	}
	
	public static void main(String[] argv) throws NumberFormatException, IOException{
		BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
		String line;
		while((line = br.readLine()) != null){
			String[] lineArray = line.split("" "");
			long[] factor = {Long.parseLong(lineArray[0]), Long.parseLong(lineArray[1])};
			long gcd = findGcd(factor[0], factor[1]);
			long lcm = findlcm(factor[0], factor[1]);
			System.out.println(gcd + "" "" + lcm);
		}
	}
}",1
p00005,"GCD and LCM
Write a program which computes the greatest common divisor (GCD) and the least common multiple (LCM) of given
a
and
b
.
Input
Input consists of several data sets. Each data set contains
a
and
b
separated by a single space in a line. The input terminates with EOF.
Constraints
0 <
a, b
≤ 2,000,000,000
LCM(
a, b
) ≤ 2,000,000,000
The number of data sets ≤ 50
Output
For each data set, print GCD and LCM separated by a single space in a line.
Sample Input
8 6
50000000 30000000
Output for the Sample Input
2 24
10000000 150000000",Python,"import sys
import math

for line in sys.stdin:
    a, b = map(int, line.split())
    gcd = math.gcd(a, b)
    lcm = (a * b) // gcd
    print(gcd, lcm)
",0
p00005,"GCD and LCM
Write a program which computes the greatest common divisor (GCD) and the least common multiple (LCM) of given
a
and
b
.
Input
Input consists of several data sets. Each data set contains
a
and
b
separated by a single space in a line. The input terminates with EOF.
Constraints
0 <
a, b
≤ 2,000,000,000
LCM(
a, b
) ≤ 2,000,000,000
The number of data sets ≤ 50
Output
For each data set, print GCD and LCM separated by a single space in a line.
Sample Input
8 6
50000000 30000000
Output for the Sample Input
2 24
10000000 150000000",Python,"import math

try:
 while 1:
  a,b=map(int,input().split())
  print(math.gcd(a,b),a*b// math.gcd(a, b))
except:
   pass
 ",1
p00006,"Reverse Sequence
Write a program which reverses a given string
str
.
Input
str
(the size of
str
≤ 20) is given in a line.
Output
Print the reversed
str
in a line.
Sample Input
w32nimda
Output for the Sample Input
admin23w",C,"#include <stdio.h>
#include <string.h>

int main() {
    char str[21];
    scanf(""%s"", str);
    int len = strlen(str);
    for (int i = len - 1; i >= 0; i--) {
        printf(""%c"", str[i]);
    }
    printf(""\n"");
    return 0;
}
",0
p00006,"Reverse Sequence
Write a program which reverses a given string
str
.
Input
str
(the size of
str
≤ 20) is given in a line.
Output
Print the reversed
str
in a line.
Sample Input
w32nimda
Output for the Sample Input
admin23w",C,"#include<stdio,h>
#include<string.h>
int main(){
char a[20];
int l,i;
scanf(""%s"",a);
l=strlen(a);
for(i=l-1;i>=0;i--)
printf(""%c"",a[i]);
return 0;
}",1
p00006,"Reverse Sequence
Write a program which reverses a given string
str
.
Input
str
(the size of
str
≤ 20) is given in a line.
Output
Print the reversed
str
in a line.
Sample Input
w32nimda
Output for the Sample Input
admin23w",Java,"import java.util.Scanner;

public class Main {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        String str = sc.next();
        StringBuilder sb = new StringBuilder(str);
        System.out.println(sb.reverse().toString());
        sc.close();
    }
}
",0
p00006,"Reverse Sequence
Write a program which reverses a given string
str
.
Input
str
(the size of
str
≤ 20) is given in a line.
Output
Print the reversed
str
in a line.
Sample Input
w32nimda
Output for the Sample Input
admin23w",Java,"import java.util.*;

class Main {
    public static void main (String [] args) {

        Scanner sc = new Scanner(System.in);

        char [] str = sc.next().toCharArray();
        for(int x = str.length-1; x >= 0; x--) {
            System.out.print(str[x]);
        }

        System.out.print(""\n"");
    }
}",1
p00006,"Reverse Sequence
Write a program which reverses a given string
str
.
Input
str
(the size of
str
≤ 20) is given in a line.
Output
Print the reversed
str
in a line.
Sample Input
w32nimda
Output for the Sample Input
admin23w",Python,"s = input()
print(s[::-1])
",0
p00006,"Reverse Sequence
Write a program which reverses a given string
str
.
Input
str
(the size of
str
≤ 20) is given in a line.
Output
Print the reversed
str
in a line.
Sample Input
w32nimda
Output for the Sample Input
admin23w",Python,"print(input()[::-1])
",1
p00007,"Debt Hell
Your friend who lives in undisclosed country is involved in debt. He is borrowing 100,000-yen from a loan shark. The loan shark adds 5% interest of the debt and rounds it to the nearest 1,000 above week by week.
Write a program which computes the amount of the debt in
n
weeks.
Input
An integer
n
(0 ≤
n
≤ 100) is given in a line.
Output
Print the amout of the debt in a line.
Sample Input
5
Output for the Sample Input
130000",C,"#include <stdio.h>

int main() {
    int n;
    scanf(""%d"", &n);
    
    int debt = 100000;
    
    for (int i = 0; i < n; i++) {
        debt = debt * 105 / 100;
        if (debt % 1000 != 0) {
            debt = (debt / 1000 + 1) * 1000;
        }
    }
    
    printf(""%d\n"", debt);
    
    return 0;
}
",0
p00007,"Debt Hell
Your friend who lives in undisclosed country is involved in debt. He is borrowing 100,000-yen from a loan shark. The loan shark adds 5% interest of the debt and rounds it to the nearest 1,000 above week by week.
Write a program which computes the amount of the debt in
n
weeks.
Input
An integer
n
(0 ≤
n
≤ 100) is given in a line.
Output
Print the amout of the debt in a line.
Sample Input
5
Output for the Sample Input
130000",C,"main(){
    int n,a=100000; scanf(""%d"",&n);
    while(n--){
        a*=1.05;
        if(a%1000>0) a=(a/1000+1)*1000;
        else        a=a/1000*1000;
    }
    printf(""%d\n"",a);
    exit(0);
}",1
p00007,"Debt Hell
Your friend who lives in undisclosed country is involved in debt. He is borrowing 100,000-yen from a loan shark. The loan shark adds 5% interest of the debt and rounds it to the nearest 1,000 above week by week.
Write a program which computes the amount of the debt in
n
weeks.
Input
An integer
n
(0 ≤
n
≤ 100) is given in a line.
Output
Print the amout of the debt in a line.
Sample Input
5
Output for the Sample Input
130000",Java,"import java.util.Scanner;

public class Main {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int n = sc.nextInt();
        
        long debt = 100000;
        
        for (int i = 0; i < n; i++) {
            debt = (long) Math.ceil(debt * 1.05 / 1000.0) * 1000;
        }
        
        System.out.println(debt);
        sc.close();
    }
}
",0
p00007,"Debt Hell
Your friend who lives in undisclosed country is involved in debt. He is borrowing 100,000-yen from a loan shark. The loan shark adds 5% interest of the debt and rounds it to the nearest 1,000 above week by week.
Write a program which computes the amount of the debt in
n
weeks.
Input
An integer
n
(0 ≤
n
≤ 100) is given in a line.
Output
Print the amout of the debt in a line.
Sample Input
5
Output for the Sample Input
130000",Java,"import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;

public class Main {
	public static void main(String[] args) throws IOException{
		BufferedReader br = new BufferedReader(new InputStreamReader(System.in));

		double sum = 100000;   //????????????10??????
		int ??? = 0;			//?????????????????±???

		??? = Integer.parseInt(br.readLine());

		for(int i = 0; i < ???; i++){
			sum = sum * 1.05;
			sum = sum / 1000;
			sum = Math.ceil(sum) * 1000;
		}

		System.out.println(sum);
	}
}",1
p00007,"Debt Hell
Your friend who lives in undisclosed country is involved in debt. He is borrowing 100,000-yen from a loan shark. The loan shark adds 5% interest of the debt and rounds it to the nearest 1,000 above week by week.
Write a program which computes the amount of the debt in
n
weeks.
Input
An integer
n
(0 ≤
n
≤ 100) is given in a line.
Output
Print the amout of the debt in a line.
Sample Input
5
Output for the Sample Input
130000",Python,"import math

n = int(input())
debt = 100000

for _ in range(n):
    debt = debt * 1.05
    debt = math.ceil(debt / 1000) * 1000

print(int(debt))
",0
p00007,"Debt Hell
Your friend who lives in undisclosed country is involved in debt. He is borrowing 100,000-yen from a loan shark. The loan shark adds 5% interest of the debt and rounds it to the nearest 1,000 above week by week.
Write a program which computes the amount of the debt in
n
weeks.
Input
An integer
n
(0 ≤
n
≤ 100) is given in a line.
Output
Print the amout of the debt in a line.
Sample Input
5
Output for the Sample Input
130000",Python,"x = 100000
for i in range(int(input())):
    x*=1.05
    x+=999
    x=x//1000*1000
print(x)",1
p00009,"Prime Number
Write a program which reads an integer
n
and prints the number of prime numbers which are less than or equal to
n
. A prime number is a natural number which has exactly two distinct natural number divisors: 1 and itself. For example, the first four prime numbers are: 2, 3, 5 and 7.
Input
Input consists of several datasets. Each dataset has an integer
n
(1 ≤
n
≤ 999,999) in a line.
The number of datasets is less than or equal to 30.
Output
For each dataset, prints the number of prime numbers.
Sample Input
10
3
11
Output for the Sample Input
4
2
5",C,"#include <stdio.h>
#include <string.h>
#include <math.h>

#define MAX 1000000

int is_prime[MAX];

void sieve() {
    memset(is_prime, 1, sizeof(is_prime));
    is_prime[0] = is_prime[1] = 0;
    
    for (int i = 2; i * i < MAX; i++) {
        if (is_prime[i]) {
            for (int j = i * i; j < MAX; j += i) {
                is_prime[j] = 0;
            }
        }
    }
}

int main() {
    sieve();
    
    int prime_count[MAX];
    prime_count[0] = 0;
    for (int i = 1; i < MAX; i++) {
        prime_count[i] = prime_count[i-1] + is_prime[i];
    }
    
    int n;
    while (scanf(""%d"", &n) != EOF) {
        printf(""%d\n"", prime_count[n]);
    }
    
    return 0;
}
",0
p00009,"Prime Number
Write a program which reads an integer
n
and prints the number of prime numbers which are less than or equal to
n
. A prime number is a natural number which has exactly two distinct natural number divisors: 1 and itself. For example, the first four prime numbers are: 2, 3, 5 and 7.
Input
Input consists of several datasets. Each dataset has an integer
n
(1 ≤
n
≤ 999,999) in a line.
The number of datasets is less than or equal to 30.
Output
For each dataset, prints the number of prime numbers.
Sample Input
10
3
11
Output for the Sample Input
4
2
5",C,"#include <stdio.h>
#include <math.h>
 
#define MAX 1000000
 
char Prime[MAX];
 
void PrimeSearch_Eratos( void ) //エラトステネスの篩
{
    int i = 0, j = 0;
 
    for( i = 0 ; i < MAX ; i ++ ) Prime[i] = 1;
 
    Prime[0] = 0;
    Prime[1] = 0;
 
    for( i = 2 ; i <= sqrt( ( double )MAX ) + 1 ; i ++ ) //doubleにキャストしないと
    {                                                   //オーバーロードがなんたら
        if( !Prime[i] ) continue;                       //（　゜д゜）ポカン
 
        for( j = i * 2 ; j <= MAX ; j += i )
        {
            Prime[j] = 0;
        }
    }
 
    return ;
}
 
int main( void )
{
    int n = 0;
 
    PrimeSearch_Eratos();
 
    while( scanf( ""%d"", &n ) != EOF )
    {
        int i = 0;
        int Count = 0;
 
        for( i = 0 ; i <= n ; i ++ )
        {
            if( Prime[i] ) Count ++;
        }
 
        printf( ""%d\n"", Count );
    }
 
    return 0;
}",1
p00009,"Prime Number
Write a program which reads an integer
n
and prints the number of prime numbers which are less than or equal to
n
. A prime number is a natural number which has exactly two distinct natural number divisors: 1 and itself. For example, the first four prime numbers are: 2, 3, 5 and 7.
Input
Input consists of several datasets. Each dataset has an integer
n
(1 ≤
n
≤ 999,999) in a line.
The number of datasets is less than or equal to 30.
Output
For each dataset, prints the number of prime numbers.
Sample Input
10
3
11
Output for the Sample Input
4
2
5",Java,"import java.util.Scanner;

public class Main {
    private static final int MAX = 1000000;
    private static boolean[] isPrime;
    private static int[] primeCount;
    
    static {
        isPrime = new boolean[MAX + 1];
        primeCount = new int[MAX + 1];
        
        // Sieve of Eratosthenes
        for (int i = 2; i <= MAX; i++) {
            isPrime[i] = true;
        }
        
        for (int i = 2; i * i <= MAX; i++) {
            if (isPrime[i]) {
                for (int j = i * i; j <= MAX; j += i) {
                    isPrime[j] = false;
                }
            }
        }
        
        // Precompute prime counts
        int count = 0;
        for (int i = 0; i <= MAX; i++) {
            if (i >= 2 && isPrime[i]) {
                count++;
            }
            primeCount[i] = count;
        }
    }
    
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        
        while (sc.hasNextInt()) {
            int n = sc.nextInt();
            System.out.println(primeCount[n]);
        }
        
        sc.close();
    }
}
",0
p00009,"Prime Number
Write a program which reads an integer
n
and prints the number of prime numbers which are less than or equal to
n
. A prime number is a natural number which has exactly two distinct natural number divisors: 1 and itself. For example, the first four prime numbers are: 2, 3, 5 and 7.
Input
Input consists of several datasets. Each dataset has an integer
n
(1 ≤
n
≤ 999,999) in a line.
The number of datasets is less than or equal to 30.
Output
For each dataset, prints the number of prime numbers.
Sample Input
10
3
11
Output for the Sample Input
4
2
5",Java,"import java.util.*;
import java.io.*;

public class Main {
	public static void main(String[] args) throws Exception {
		BufferedReader in = new BufferedReader(new InputStreamReader(System.in));
		String line = in.readLine();
		while (line != null) {
			StringTokenizer tk = new StringTokenizer(line);
			int n = Integer.parseInt(tk.nextToken());
			Queue<Integer> queue = new LinkedList<Integer>();
			for(int i = 2; i <= n; i++) {
				queue.add(i);
			}
			int p = queue.remove();
			queue.add(p);
			do {
				while (queue.element() != p) {
					int temp = queue.remove();
					if (temp % p != 0) {
						queue.add(temp);
					}
				}
				queue.add(queue.remove());
				p = queue.remove();
				queue.add(p);
			} while (p != 2);
			
			int length = 0;
			while (!queue.isEmpty()){
				length ++;
				queue.remove();
			}
			System.out.println(length);
			line = in.readLine();
		}
	}
}",1
p00009,"Prime Number
Write a program which reads an integer
n
and prints the number of prime numbers which are less than or equal to
n
. A prime number is a natural number which has exactly two distinct natural number divisors: 1 and itself. For example, the first four prime numbers are: 2, 3, 5 and 7.
Input
Input consists of several datasets. Each dataset has an integer
n
(1 ≤
n
≤ 999,999) in a line.
The number of datasets is less than or equal to 30.
Output
For each dataset, prints the number of prime numbers.
Sample Input
10
3
11
Output for the Sample Input
4
2
5",Python,"def sieve_of_eratosthenes(limit):
    if limit < 2:
        return []
    is_prime = [True] * (limit + 1)
    is_prime[0] = is_prime[1] = False
    
    for i in range(2, int(limit**0.5) + 1):
        if is_prime[i]:
            for j in range(i*i, limit + 1, i):
                is_prime[j] = False
    
    return is_prime

max_n = 999999
is_prime = sieve_of_eratosthenes(max_n)
prime_count = [0] * (max_n + 1)

count = 0
for i in range(max_n + 1):
    if is_prime[i]:
        count += 1
    prime_count[i] = count

import sys
for line in sys.stdin:
    n = int(line.strip())
    print(prime_count[n])
",0
p00009,"Prime Number
Write a program which reads an integer
n
and prints the number of prime numbers which are less than or equal to
n
. A prime number is a natural number which has exactly two distinct natural number divisors: 1 and itself. For example, the first four prime numbers are: 2, 3, 5 and 7.
Input
Input consists of several datasets. Each dataset has an integer
n
(1 ≤
n
≤ 999,999) in a line.
The number of datasets is less than or equal to 30.
Output
For each dataset, prints the number of prime numbers.
Sample Input
10
3
11
Output for the Sample Input
4
2
5",Python,"import math
import sys

lst=[0 for _ in xrange(999999+1)]

def is_prime(num):
  if num%2==0:
      return 0
  for x in range(3, int(num**0.5)+1,2):
    if num % x==0:
        return 0
  return 1

lst[1]=0
lst[2]=1
for idx in range(3, len(lst)):
  lst[idx] = is_prime(idx) + lst[idx-1]

for line in sys.stdin:
  print lst[int(line)]",1
p00010,"Circumscribed Circle of A Triangle.
Write a program which prints the central coordinate $(p_x, p_y)$ and the radius $r$ of a circumscribed circle of a triangle which is constructed by three points $(x_1, y_1)$, $(x_2, y_2)$ and $(x_3, y_3)$ on the plane surface.
Input
Input consists of several datasets. In the first line, the number of datasets $n$ is given. Each dataset consists of:
$x_1$ $y_1$ $x_2$ $y_2$ $x_3$ $y_3$
in a line. All the input are real numbers.
Output
For each dataset, print $p_x$, $p_y$ and $r$ separated by a space in a line. Print the solution to three places of decimals. Round off the solution to three decimal places.
Constraints
$-100 \leq x_1, y_1, x_2, y_2, x_3, y_3 \leq 100$
$ n \leq 20$
Sample Input
1
0.0 0.0 2.0 0.0 2.0 2.0
Output for the Sample Input
1.000 1.000 1.414",C,"#include <stdio.h>
#include <math.h>

int main() {
    int n;
    scanf(""%d"", &n);
    
    while (n--) {
        double x1, y1, x2, y2, x3, y3;
        scanf(""%lf %lf %lf %lf %lf %lf"", &x1, &y1, &x2, &y2, &x3, &y3);
        
        double a = 2 * (x2 - x1);
        double b = 2 * (y2 - y1);
        double c = x2 * x2 - x1 * x1 + y2 * y2 - y1 * y1;
        
        double d = 2 * (x3 - x1);
        double e = 2 * (y3 - y1);
        double f = x3 * x3 - x1 * x1 + y3 * y3 - y1 * y1;
        
        double px = (c * e - b * f) / (a * e - b * d);
        double py = (a * f - c * d) / (a * e - b * d);
        
        double r = sqrt((px - x1) * (px - x1) + (py - y1) * (py - y1));
        
        printf(""%.3f %.3f %.3f\n"", px, py, r);
    }
    
    return 0;
}
",0
p00010,"Circumscribed Circle of A Triangle.
Write a program which prints the central coordinate $(p_x, p_y)$ and the radius $r$ of a circumscribed circle of a triangle which is constructed by three points $(x_1, y_1)$, $(x_2, y_2)$ and $(x_3, y_3)$ on the plane surface.
Input
Input consists of several datasets. In the first line, the number of datasets $n$ is given. Each dataset consists of:
$x_1$ $y_1$ $x_2$ $y_2$ $x_3$ $y_3$
in a line. All the input are real numbers.
Output
For each dataset, print $p_x$, $p_y$ and $r$ separated by a space in a line. Print the solution to three places of decimals. Round off the solution to three decimal places.
Constraints
$-100 \leq x_1, y_1, x_2, y_2, x_3, y_3 \leq 100$
$ n \leq 20$
Sample Input
1
0.0 0.0 2.0 0.0 2.0 2.0
Output for the Sample Input
1.000 1.000 1.414",C,"#include <stdio.h>
#include <math.h>

int main(int argc, const char * argv[])
{

    double x1, y1, x2, y2, x3, y3;
    double midx1, midx2, midy1, midy2;
    double circlex, circley;
    double slant1, slant2;
    double slice1, slice2;
    double radius;
    int i;
    int input;
    
    scanf(""%d"", &input);
    for (i = 0; i < input; i++) {
        scanf(""%lf %lf %lf %lf %lf %lf"", &x1, &y1, &x2, &y2, &x3, &y3);
        midx1 = (x1 + x2) / 2;
        midy1 = (y1 + y2) / 2;
        midx2 = (x1 + x3) / 2;
        midy2 = (y1 + y3) / 2;
        slant1 = - (x2 - x1) / (y2 - y1);
        slant2 = - (x3 - x1) / (y3 - y1);
        slice1 = midy1 - slant1 * midx1;
        slice2 = midy2 - slant2 * midx2;
        circlex = (slice2 - slice1) / (slant1 - slant2);
        circley = slant1 * circlex + slice1;
        
        if (x2 == x1) {
            circley = midy1;
            circlex = (circley - slice2) / slant2;
        }
        else if (y2 == y1) {
            circlex = midx1;
            circley = slant2 * circlex + slice2;
        }
        if(x3 == x1) {
            circley = midy2;
            circlex = (circley - slice1) / slant1;
        }
        else if (y3 == y1) {
            circlex = midx2;
            circley = slant1 * circlex + slice1;
        }
        if (x2 == x1 && y3 == y1) {
            circley = midy1;
            circlex = midx2;
        }
        else if (x3 == x1 && y2 == y1){
            circley = midy2;
            circlex = midx1;
        }
        radius = sqrt((circlex - x1) * (circlex - x1) + (circley - y1) * (circley - y1));
        printf(""%0.3f %0.3f %0.3f\n"", circlex, circley, radius);
    }
    return 0;
}",1
p00010,"Circumscribed Circle of A Triangle.
Write a program which prints the central coordinate $(p_x, p_y)$ and the radius $r$ of a circumscribed circle of a triangle which is constructed by three points $(x_1, y_1)$, $(x_2, y_2)$ and $(x_3, y_3)$ on the plane surface.
Input
Input consists of several datasets. In the first line, the number of datasets $n$ is given. Each dataset consists of:
$x_1$ $y_1$ $x_2$ $y_2$ $x_3$ $y_3$
in a line. All the input are real numbers.
Output
For each dataset, print $p_x$, $p_y$ and $r$ separated by a space in a line. Print the solution to three places of decimals. Round off the solution to three decimal places.
Constraints
$-100 \leq x_1, y_1, x_2, y_2, x_3, y_3 \leq 100$
$ n \leq 20$
Sample Input
1
0.0 0.0 2.0 0.0 2.0 2.0
Output for the Sample Input
1.000 1.000 1.414",Java,"import java.util.Scanner;

public class Main {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int n = sc.nextInt();
        
        for (int i = 0; i < n; i++) {
            double x1 = sc.nextDouble();
            double y1 = sc.nextDouble();
            double x2 = sc.nextDouble();
            double y2 = sc.nextDouble();
            double x3 = sc.nextDouble();
            double y3 = sc.nextDouble();
            
            double a = 2 * (x2 - x1);
            double b = 2 * (y2 - y1);
            double c = x1 * x1 - x2 * x2 + y1 * y1 - y2 * y2;
            
            double d = 2 * (x3 - x1);
            double e = 2 * (y3 - y1);
            double f = x1 * x1 - x3 * x3 + y1 * y1 - y3 * y3;
            
            double px = (b * f - e * c) / (b * d - e * a);
            double py = (d * c - a * f) / (b * d - e * a);
            
            double r = Math.sqrt((x1 - px) * (x1 - px) + (y1 - py) * (y1 - py));
            
            System.out.printf(""%.3f %.3f %.3f\n"", px, py, r);
        }
        
        sc.close();
    }
}
",0
p00010,"Circumscribed Circle of A Triangle.
Write a program which prints the central coordinate $(p_x, p_y)$ and the radius $r$ of a circumscribed circle of a triangle which is constructed by three points $(x_1, y_1)$, $(x_2, y_2)$ and $(x_3, y_3)$ on the plane surface.
Input
Input consists of several datasets. In the first line, the number of datasets $n$ is given. Each dataset consists of:
$x_1$ $y_1$ $x_2$ $y_2$ $x_3$ $y_3$
in a line. All the input are real numbers.
Output
For each dataset, print $p_x$, $p_y$ and $r$ separated by a space in a line. Print the solution to three places of decimals. Round off the solution to three decimal places.
Constraints
$-100 \leq x_1, y_1, x_2, y_2, x_3, y_3 \leq 100$
$ n \leq 20$
Sample Input
1
0.0 0.0 2.0 0.0 2.0 2.0
Output for the Sample Input
1.000 1.000 1.414",Java,"import java.util.Scanner;
public class Main {
	public static void main(String[] args) {
		Scanner s=new Scanner(System.in);
		int n;
		double x1,x2,x3,y1,y2,y3,xp,yp,r,a1,a2,b1,b2,c1,c2,a,b;
		n=s.nextInt();
		for(int i=0;i<n;i++){
			x1=s.nextDouble();
			y1=s.nextDouble();
			x2=s.nextDouble();
			y2=s.nextDouble();
			x3=s.nextDouble();
			y3=s.nextDouble();
			
			a1=2*(x1-x2);//a
			b1=2*(y1-y2);//b
			//c
			c1=(x1*x1)-(x2*x2)+(y1*y1)-(y2*y2);
			a2=2*(x2-x3);//d
			b2=2*(y2-y3);//e
			c2=(x2*x2)-(x3*x3)+(y2*y2)-(y3*y3);
			
			if(c1*b2-b1*c2==0 ||a1*b2-a2*b1==0)xp=0;
			else
			xp=(c1*b2-b1*c2)/(a1*b2-a2*b1);
			if(c1*a2-c2*a1==0 ||a2*b1-a1*b2==0)yp=0;
			else
			yp=(c1*a2-c2*a1)/(a2*b1-a1*b2);
			
			a=xp-x1;
			a=a*a;
			b=yp-y1;
			b=b*b;
			r=Math.sqrt(a+b);
			if(r==0)
				r=0;
			System.out.printf(""%.3f %.3f %.3f\n"",xp,yp,r);
		}//for
	}
}",1
p00010,"Circumscribed Circle of A Triangle.
Write a program which prints the central coordinate $(p_x, p_y)$ and the radius $r$ of a circumscribed circle of a triangle which is constructed by three points $(x_1, y_1)$, $(x_2, y_2)$ and $(x_3, y_3)$ on the plane surface.
Input
Input consists of several datasets. In the first line, the number of datasets $n$ is given. Each dataset consists of:
$x_1$ $y_1$ $x_2$ $y_2$ $x_3$ $y_3$
in a line. All the input are real numbers.
Output
For each dataset, print $p_x$, $p_y$ and $r$ separated by a space in a line. Print the solution to three places of decimals. Round off the solution to three decimal places.
Constraints
$-100 \leq x_1, y_1, x_2, y_2, x_3, y_3 \leq 100$
$ n \leq 20$
Sample Input
1
0.0 0.0 2.0 0.0 2.0 2.0
Output for the Sample Input
1.000 1.000 1.414",Python,"import math

def circumcircle(x1, y1, x2, y2, x3, y3):
    # Calculate D (denominator)
    D = 2 * (x1 * (y2 - y3) + x2 * (y3 - y1) + x3 * (y1 - y2))
    
    # Calculate center coordinates
    ux = ((x1**2 + y1**2) * (y2 - y3) + (x2**2 + y2**2) * (y3 - y1) + (x3**2 + y3**2) * (y1 - y2)) / D
    uy = ((x1**2 + y1**2) * (x3 - x2) + (x2**2 + y2**2) * (x1 - x3) + (x3**2 + y3**2) * (x2 - x1)) / D
    
    # Calculate radius
    r = math.sqrt((x1 - ux)**2 + (y1 - uy)**2)
    
    return ux, uy, r

n = int(input())
for _ in range(n):
    coords = list(map(float, input().split()))
    x1, y1, x2, y2, x3, y3 = coords
    px, py, r = circumcircle(x1, y1, x2, y2, x3, y3)
    print(f""{px:.3f} {py:.3f} {r:.3f}"")
",0
p00010,"Circumscribed Circle of A Triangle.
Write a program which prints the central coordinate $(p_x, p_y)$ and the radius $r$ of a circumscribed circle of a triangle which is constructed by three points $(x_1, y_1)$, $(x_2, y_2)$ and $(x_3, y_3)$ on the plane surface.
Input
Input consists of several datasets. In the first line, the number of datasets $n$ is given. Each dataset consists of:
$x_1$ $y_1$ $x_2$ $y_2$ $x_3$ $y_3$
in a line. All the input are real numbers.
Output
For each dataset, print $p_x$, $p_y$ and $r$ separated by a space in a line. Print the solution to three places of decimals. Round off the solution to three decimal places.
Constraints
$-100 \leq x_1, y_1, x_2, y_2, x_3, y_3 \leq 100$
$ n \leq 20$
Sample Input
1
0.0 0.0 2.0 0.0 2.0 2.0
Output for the Sample Input
1.000 1.000 1.414",Python,"# coding: utf-8

import math

n = int(raw_input())

for i in range(n):
	data = map(float, raw_input().split())
	x1 = data[0]
	y1 = data[1]
	x2 = data[2]
	y2 = data[3]
	x3 = data[4]
	y3 = data[5]

	k = 0.5 * ( (x3-x2)*(x3-x1) + (y3-y2)*(y3-y1) ) / ( (x2-x1)*(y3-y1) + (y2-y1)*(x3-x1) )

	x = 0.5 * (x1 + x2) - k * (y2 - y1)
	y = 0.5 * (y1 + y2) + k * (x2 - x1)

	r = math.sqrt( (x-x1)**2 + (y-y1)**2 )

	print(""{:.3f} {:.3f} {:.3f}"".format(x,y,r))",1
p00011,"Drawing Lots
Let's play Amidakuji.
In the following example, there are five vertical lines and four horizontal lines. The horizontal lines can intersect (jump across) the vertical lines.
In the starting points (top of the figure), numbers are assigned to vertical lines in ascending order from left to right. At the first step, 2 and 4 are swaped by the first horizontal line which connects second and fourth vertical lines (we call this operation (2, 4)). Likewise, we perform (3, 5), (1, 2) and (3, 4), then obtain ""4 1 2 5 3"" in the bottom.
Your task is to write a program which reads the number of vertical lines
w
and configurations of horizontal lines and prints the final state of the Amidakuji. In the starting pints, numbers 1, 2, 3, ...,
w
are assigne to the vertical lines from left to right.
Input
w
n
a
1
,
b
1
a
2
,
b
2
.
.
a
n
,
b
n
w
(
w
≤ 30) is the number of vertical lines.
n
(
n
≤ 30) is the number of horizontal lines. A pair of two integers
a
i
and
b
i
delimited by a comma represents the
i
-th horizontal line.
Output
The number which should be under the 1st (leftmost) vertical line
The number which should be under the 2nd vertical line
:
The number which should be under the
w
-th vertical line
Sample Input
5
4
2,4
3,5
1,2
3,4
Output for the Sample Input
4
1
2
5
3",C,"#include <stdio.h>

int main() {
    int w, n;
    int lines[31];
    
    scanf(""%d"", &w);
    scanf(""%d"", &n);
    
    // Initialize vertical lines with numbers 1 to w
    for (int i = 1; i <= w; i++) {
        lines[i] = i;
    }
    
    // Process each horizontal line
    for (int i = 0; i < n; i++) {
        int a, b;
        scanf(""%d,%d"", &a, &b);
        
        // Swap the values at positions a and b
        int temp = lines[a];
        lines[a] = lines[b];
        lines[b] = temp;
    }
    
    // Print the final state
    for (int i = 1; i <= w; i++) {
        printf(""%d\n"", lines[i]);
    }
    
    return 0;
}
",0
p00011,"Drawing Lots
Let's play Amidakuji.
In the following example, there are five vertical lines and four horizontal lines. The horizontal lines can intersect (jump across) the vertical lines.
In the starting points (top of the figure), numbers are assigned to vertical lines in ascending order from left to right. At the first step, 2 and 4 are swaped by the first horizontal line which connects second and fourth vertical lines (we call this operation (2, 4)). Likewise, we perform (3, 5), (1, 2) and (3, 4), then obtain ""4 1 2 5 3"" in the bottom.
Your task is to write a program which reads the number of vertical lines
w
and configurations of horizontal lines and prints the final state of the Amidakuji. In the starting pints, numbers 1, 2, 3, ...,
w
are assigne to the vertical lines from left to right.
Input
w
n
a
1
,
b
1
a
2
,
b
2
.
.
a
n
,
b
n
w
(
w
≤ 30) is the number of vertical lines.
n
(
n
≤ 30) is the number of horizontal lines. A pair of two integers
a
i
and
b
i
delimited by a comma represents the
i
-th horizontal line.
Output
The number which should be under the 1st (leftmost) vertical line
The number which should be under the 2nd vertical line
:
The number which should be under the
w
-th vertical line
Sample Input
5
4
2,4
3,5
1,2
3,4
Output for the Sample Input
4
1
2
5
3",C,"#include <stdio.h>

void swap(int *a, int *b){
  int t=*a;*a=*b;*b=t;
}

int main(void){
  int w,n,i,l[31];
  scanf(""%d\n"",&w);
  scanf(""%d\n"",&n);
  for(i=1;i<=w;i++){
    l[i]=i;
  }
  for(i=0;i<n;i++) {
    int a,b;
    scanf(""%d,%d\n"",&a,&b);
    swap(&l[a],&l[b]);
  }
  for(i=1;i<=w;i++){
    printf(""%d\n"", l[i]);
  }

  return 0;
}",1
p00011,"Drawing Lots
Let's play Amidakuji.
In the following example, there are five vertical lines and four horizontal lines. The horizontal lines can intersect (jump across) the vertical lines.
In the starting points (top of the figure), numbers are assigned to vertical lines in ascending order from left to right. At the first step, 2 and 4 are swaped by the first horizontal line which connects second and fourth vertical lines (we call this operation (2, 4)). Likewise, we perform (3, 5), (1, 2) and (3, 4), then obtain ""4 1 2 5 3"" in the bottom.
Your task is to write a program which reads the number of vertical lines
w
and configurations of horizontal lines and prints the final state of the Amidakuji. In the starting pints, numbers 1, 2, 3, ...,
w
are assigne to the vertical lines from left to right.
Input
w
n
a
1
,
b
1
a
2
,
b
2
.
.
a
n
,
b
n
w
(
w
≤ 30) is the number of vertical lines.
n
(
n
≤ 30) is the number of horizontal lines. A pair of two integers
a
i
and
b
i
delimited by a comma represents the
i
-th horizontal line.
Output
The number which should be under the 1st (leftmost) vertical line
The number which should be under the 2nd vertical line
:
The number which should be under the
w
-th vertical line
Sample Input
5
4
2,4
3,5
1,2
3,4
Output for the Sample Input
4
1
2
5
3",Java,"import java.util.Scanner;

public class Main {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System);
        
        int w = sc.nextInt();
        int n = sc.nextInt();
        sc.nextLine();
        
        int[] lines = new int[w + 1];
        for (int i = 1; i <= w; i++) {
            lines[i] = i;
        }
        
        for (int i = 0; i < n; i++) {
            String line = sc.nextLine();
            String[] parts = line.split("","");
            int a = Integer.parseInt(parts[0]);
            int b = Integer.parseInt(parts[1]);
            
            int temp = lines[a];
            lines[a] = lines[b];
            lines[b] = temp;
        }
        
        for (int i = 1; i <= w; i++) {
            System.out.println(lines[i]);
        }
        
        sc.close();
    }
}
",0
p00011,"Drawing Lots
Let's play Amidakuji.
In the following example, there are five vertical lines and four horizontal lines. The horizontal lines can intersect (jump across) the vertical lines.
In the starting points (top of the figure), numbers are assigned to vertical lines in ascending order from left to right. At the first step, 2 and 4 are swaped by the first horizontal line which connects second and fourth vertical lines (we call this operation (2, 4)). Likewise, we perform (3, 5), (1, 2) and (3, 4), then obtain ""4 1 2 5 3"" in the bottom.
Your task is to write a program which reads the number of vertical lines
w
and configurations of horizontal lines and prints the final state of the Amidakuji. In the starting pints, numbers 1, 2, 3, ...,
w
are assigne to the vertical lines from left to right.
Input
w
n
a
1
,
b
1
a
2
,
b
2
.
.
a
n
,
b
n
w
(
w
≤ 30) is the number of vertical lines.
n
(
n
≤ 30) is the number of horizontal lines. A pair of two integers
a
i
and
b
i
delimited by a comma represents the
i
-th horizontal line.
Output
The number which should be under the 1st (leftmost) vertical line
The number which should be under the 2nd vertical line
:
The number which should be under the
w
-th vertical line
Sample Input
5
4
2,4
3,5
1,2
3,4
Output for the Sample Input
4
1
2
5
3",Java,"import java.util.Scanner;

public class AOJ3_3{
	public static void main(String[] args){
		Scanner sc = new Scanner(System.in);
		int w = sc.nextInt();
		int n = sc.nextInt();
		int[] values = new int[w];
		for(int i=0;i<values.length;i++){
			values[i] = i + 1;
		}
		for(int i = 0;i<n;i++){
			String str = sc.next();
			String[] ab = str.split("","");
			int a = Integer.parseInt(ab[0]) -1;
			int b = Integer.parseInt(ab[1]) -1;
			int temp = values[a];
			values[a] = values[b];
			values[b] = temp;
		}
		for(int i = 0;i<w;i++){
			System.out.println(values[i]);
		}
	}
}",1
p00011,"Drawing Lots
Let's play Amidakuji.
In the following example, there are five vertical lines and four horizontal lines. The horizontal lines can intersect (jump across) the vertical lines.
In the starting points (top of the figure), numbers are assigned to vertical lines in ascending order from left to right. At the first step, 2 and 4 are swaped by the first horizontal line which connects second and fourth vertical lines (we call this operation (2, 4)). Likewise, we perform (3, 5), (1, 2) and (3, 4), then obtain ""4 1 2 5 3"" in the bottom.
Your task is to write a program which reads the number of vertical lines
w
and configurations of horizontal lines and prints the final state of the Amidakuji. In the starting pints, numbers 1, 2, 3, ...,
w
are assigne to the vertical lines from left to right.
Input
w
n
a
1
,
b
1
a
2
,
b
2
.
.
a
n
,
b
n
w
(
w
≤ 30) is the number of vertical lines.
n
(
n
≤ 30) is the number of horizontal lines. A pair of two integers
a
i
and
b
i
delimited by a comma represents the
i
-th horizontal line.
Output
The number which should be under the 1st (leftmost) vertical line
The number which should be under the 2nd vertical line
:
The number which should be under the
w
-th vertical line
Sample Input
5
4
2,4
3,5
1,2
3,4
Output for the Sample Input
4
1
2
5
3",Python,"w = int(input())
n = int(input())

# Initialize positions: position[i] = number at position i (0-indexed)
positions = list(range(1, w + 1))

# Process each horizontal line
for _ in range(n):
    line = input().strip()
    a, b = map(int, line.split(','))
    # Swap the numbers at positions a-1 and b-1 (converting to 0-indexed)
    positions[a-1], positions[b-1] = positions[b-1], positions[a-1]

# Output the final positions
for num in positions:
    print(num)
",0
p00011,"Drawing Lots
Let's play Amidakuji.
In the following example, there are five vertical lines and four horizontal lines. The horizontal lines can intersect (jump across) the vertical lines.
In the starting points (top of the figure), numbers are assigned to vertical lines in ascending order from left to right. At the first step, 2 and 4 are swaped by the first horizontal line which connects second and fourth vertical lines (we call this operation (2, 4)). Likewise, we perform (3, 5), (1, 2) and (3, 4), then obtain ""4 1 2 5 3"" in the bottom.
Your task is to write a program which reads the number of vertical lines
w
and configurations of horizontal lines and prints the final state of the Amidakuji. In the starting pints, numbers 1, 2, 3, ...,
w
are assigne to the vertical lines from left to right.
Input
w
n
a
1
,
b
1
a
2
,
b
2
.
.
a
n
,
b
n
w
(
w
≤ 30) is the number of vertical lines.
n
(
n
≤ 30) is the number of horizontal lines. A pair of two integers
a
i
and
b
i
delimited by a comma represents the
i
-th horizontal line.
Output
The number which should be under the 1st (leftmost) vertical line
The number which should be under the 2nd vertical line
:
The number which should be under the
w
-th vertical line
Sample Input
5
4
2,4
3,5
1,2
3,4
Output for the Sample Input
4
1
2
5
3",Python,"# -*- coding: utf-8 -*-


def solve(w, n):
    l = [i for i in range(1, w+1)]
    for _ in range(n):
        a, b = map(int, input().split(','))
        l[a], l[b] = l[b], l[a]

    print(*l, sep='\n')

if __name__ == '__main__':
    w = int(input())
    n = int(input())
    solve(w, n)",1
p00013,"Switching Railroad Cars
This figure shows railway tracks for reshuffling cars. The rail tracks end in the bottom and the top-left rail track is used for the entrace and the top-right rail track is used for the exit. Ten cars, which have numbers from 1 to 10 respectively, use the rail tracks.
We can simulate the movement (comings and goings) of the cars as follow:
An entry of a car is represented by its number.
An exit of a car is represented by 0
For example, a sequence
1
6
0
8
10
demonstrates that car 1 and car 6 enter to the rail tracks in this order, car 6 exits from the rail tracks, and then car 8 and car 10 enter.
Write a program which simulates comings and goings of the cars which are represented by the sequence of car numbers. The program should read the sequence of car numbers and 0, and print numbers of cars which exit from the rail tracks in order. At the first, there are no cars on the rail tracks. You can assume that 0 will not be given when there is no car on the rail tracks.
Input
car number
car number or 0
car number or 0
  .
  .
  .
car number or 0
The number of input lines is less than or equal to 100.
Output
For each 0, print the car number.
Sample Input
1
6
0
8
10
0
0
0
Output for the Sample Input
6
10
8
1",C,"#include <stdio.h>

int main() {
    int stack[100];
    int top = -1;
    int input;
    
    while (scanf(""%d"", &input) != EOF) {
        if (input == 0) {
            printf(""%d\n"", stack[top]);
            top--;
        } else {
            top++;
            stack[top] = input;
        }
    }
    
    return 0;
}
",0
p00013,"Switching Railroad Cars
This figure shows railway tracks for reshuffling cars. The rail tracks end in the bottom and the top-left rail track is used for the entrace and the top-right rail track is used for the exit. Ten cars, which have numbers from 1 to 10 respectively, use the rail tracks.
We can simulate the movement (comings and goings) of the cars as follow:
An entry of a car is represented by its number.
An exit of a car is represented by 0
For example, a sequence
1
6
0
8
10
demonstrates that car 1 and car 6 enter to the rail tracks in this order, car 6 exits from the rail tracks, and then car 8 and car 10 enter.
Write a program which simulates comings and goings of the cars which are represented by the sequence of car numbers. The program should read the sequence of car numbers and 0, and print numbers of cars which exit from the rail tracks in order. At the first, there are no cars on the rail tracks. You can assume that 0 will not be given when there is no car on the rail tracks.
Input
car number
car number or 0
car number or 0
  .
  .
  .
car number or 0
The number of input lines is less than or equal to 100.
Output
For each 0, print the car number.
Sample Input
1
6
0
8
10
0
0
0
Output for the Sample Input
6
10
8
1",C,"#include <stdio.h>

int main() {
	int i = 0, k = 0, n, car[100] = {0}, out[100] = {0};
	while(scanf(""%d"", &n)!= EOF) {
		if(n == 0) {
			i--;
			out[k] = car[i];
			k++;
		} else {
			car[i] = n;
			i++;
		}
	}
	for(i = 0; i < k; i++) printf(""%d\n"", out[i]);
	return 0;
}",1
p00013,"Switching Railroad Cars
This figure shows railway tracks for reshuffling cars. The rail tracks end in the bottom and the top-left rail track is used for the entrace and the top-right rail track is used for the exit. Ten cars, which have numbers from 1 to 10 respectively, use the rail tracks.
We can simulate the movement (comings and goings) of the cars as follow:
An entry of a car is represented by its number.
An exit of a car is represented by 0
For example, a sequence
1
6
0
8
10
demonstrates that car 1 and car 6 enter to the rail tracks in this order, car 6 exits from the rail tracks, and then car 8 and car 10 enter.
Write a program which simulates comings and goings of the cars which are represented by the sequence of car numbers. The program should read the sequence of car numbers and 0, and print numbers of cars which exit from the rail tracks in order. At the first, there are no cars on the rail tracks. You can assume that 0 will not be given when there is no car on the rail tracks.
Input
car number
car number or 0
car number or 0
  .
  .
  .
car number or 0
The number of input lines is less than or equal to 100.
Output
For each 0, print the car number.
Sample Input
1
6
0
8
10
0
0
0
Output for the Sample Input
6
10
8
1",Java,"import java.util.Scanner;
import java.util.Stack;

public class Main {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        Stack<Integer> stack = new Stack<>();
        
        while (sc.hasNext()) {
            int num = sc.nextInt();
            if (num == 0) {
                System.out.println(stack.pop());
            } else {
                stack.push(num);
            }
        }
        
        sc.close();
    }
}
",0
p00013,"Switching Railroad Cars
This figure shows railway tracks for reshuffling cars. The rail tracks end in the bottom and the top-left rail track is used for the entrace and the top-right rail track is used for the exit. Ten cars, which have numbers from 1 to 10 respectively, use the rail tracks.
We can simulate the movement (comings and goings) of the cars as follow:
An entry of a car is represented by its number.
An exit of a car is represented by 0
For example, a sequence
1
6
0
8
10
demonstrates that car 1 and car 6 enter to the rail tracks in this order, car 6 exits from the rail tracks, and then car 8 and car 10 enter.
Write a program which simulates comings and goings of the cars which are represented by the sequence of car numbers. The program should read the sequence of car numbers and 0, and print numbers of cars which exit from the rail tracks in order. At the first, there are no cars on the rail tracks. You can assume that 0 will not be given when there is no car on the rail tracks.
Input
car number
car number or 0
car number or 0
  .
  .
  .
car number or 0
The number of input lines is less than or equal to 100.
Output
For each 0, print the car number.
Sample Input
1
6
0
8
10
0
0
0
Output for the Sample Input
6
10
8
1",Java,"import java.util.*;
 
public class Main {
    public static void main(String[] args){
        Scanner sc = new Scanner(System.in);
        Stack<Integer> stack = new Stack<Integer>();
        while(sc.hasNextInt()){
            int a=sc.nextInt();
            if(a==0){
                System.out.println(stack.pop());
            }else{
                stack.push(a);
            }
        }
    }
}",1
p00013,"Switching Railroad Cars
This figure shows railway tracks for reshuffling cars. The rail tracks end in the bottom and the top-left rail track is used for the entrace and the top-right rail track is used for the exit. Ten cars, which have numbers from 1 to 10 respectively, use the rail tracks.
We can simulate the movement (comings and goings) of the cars as follow:
An entry of a car is represented by its number.
An exit of a car is represented by 0
For example, a sequence
1
6
0
8
10
demonstrates that car 1 and car 6 enter to the rail tracks in this order, car 6 exits from the rail tracks, and then car 8 and car 10 enter.
Write a program which simulates comings and goings of the cars which are represented by the sequence of car numbers. The program should read the sequence of car numbers and 0, and print numbers of cars which exit from the rail tracks in order. At the first, there are no cars on the rail tracks. You can assume that 0 will not be given when there is no car on the rail tracks.
Input
car number
car number or 0
car number or 0
  .
  .
  .
car number or 0
The number of input lines is less than or equal to 100.
Output
For each 0, print the car number.
Sample Input
1
6
0
8
10
0
0
0
Output for the Sample Input
6
10
8
1",Python,"import sys

stack = []
for line in sys.stdin:
    num = int(line.strip())
    if num == 0:
        print(stack.pop())
    else:
        stack.append(num)
",0
p00013,"Switching Railroad Cars
This figure shows railway tracks for reshuffling cars. The rail tracks end in the bottom and the top-left rail track is used for the entrace and the top-right rail track is used for the exit. Ten cars, which have numbers from 1 to 10 respectively, use the rail tracks.
We can simulate the movement (comings and goings) of the cars as follow:
An entry of a car is represented by its number.
An exit of a car is represented by 0
For example, a sequence
1
6
0
8
10
demonstrates that car 1 and car 6 enter to the rail tracks in this order, car 6 exits from the rail tracks, and then car 8 and car 10 enter.
Write a program which simulates comings and goings of the cars which are represented by the sequence of car numbers. The program should read the sequence of car numbers and 0, and print numbers of cars which exit from the rail tracks in order. At the first, there are no cars on the rail tracks. You can assume that 0 will not be given when there is no car on the rail tracks.
Input
car number
car number or 0
car number or 0
  .
  .
  .
car number or 0
The number of input lines is less than or equal to 100.
Output
For each 0, print the car number.
Sample Input
1
6
0
8
10
0
0
0
Output for the Sample Input
6
10
8
1",Python,"a = []
while True:
    s = int(input())
    if s != 0:
        a.append(s)
    else:
        print(a.pop())
    if len(a) == 0:
        break",1
p00014,"Integral
Write a program which computes the area of a shape represented by the following three lines:
$y = x^2$
$y = 0$
$x = 600$
It is clear that the area is $72000000$, if you use an integral you learn in high school. On the other hand, we can obtain an approximative area of the shape by adding up areas of many rectangles in the shape as shown in the following figure:
$f(x) = x^2$
The approximative area $s$ where the width of the rectangles is $d$ is:
area of rectangle where its width is $d$ and height is $f(d)$ $+$
area of rectangle where its width is $d$ and height is $f(2d)$ $+$
area of rectangle where its width is $d$ and height is $f(3d)$ $+$
...
area of rectangle where its width is $d$ and height is $f(600 - d)$
The more we decrease $d$, the higer-precision value which is close to $72000000$ we could obtain. Your program should read the integer $d$ which is a divisor of $600$, and print the area $s$.
Input
The input consists of several datasets. Each dataset consists of an integer $d$ in a line. The number of datasets is less than or equal to 20.
Output
For each dataset, print the area $s$ in a line.
Sample Input
20
10
Output for the Sample Input
68440000
70210000",C,"#include <stdio.h>

int main() {
    int d;
    while (scanf(""%d"", &d) != EOF) {
        long long area = 0;
        for (int x = d; x <= 600 - d; x += d) {
            area += (long long)d * x * x;
        }
        printf(""%lld\n"", area);
    }
    return 0;
}
",0
p00014,"Integral
Write a program which computes the area of a shape represented by the following three lines:
$y = x^2$
$y = 0$
$x = 600$
It is clear that the area is $72000000$, if you use an integral you learn in high school. On the other hand, we can obtain an approximative area of the shape by adding up areas of many rectangles in the shape as shown in the following figure:
$f(x) = x^2$
The approximative area $s$ where the width of the rectangles is $d$ is:
area of rectangle where its width is $d$ and height is $f(d)$ $+$
area of rectangle where its width is $d$ and height is $f(2d)$ $+$
area of rectangle where its width is $d$ and height is $f(3d)$ $+$
...
area of rectangle where its width is $d$ and height is $f(600 - d)$
The more we decrease $d$, the higer-precision value which is close to $72000000$ we could obtain. Your program should read the integer $d$ which is a divisor of $600$, and print the area $s$.
Input
The input consists of several datasets. Each dataset consists of an integer $d$ in a line. The number of datasets is less than or equal to 20.
Output
For each dataset, print the area $s$ in a line.
Sample Input
20
10
Output for the Sample Input
68440000
70210000",C,"#include <stdio.h>

int main()
{
    int n, i;
    long long int sum;
    
    while(scanf(""%d"", &n) != EOF){
    	sum = 0;
        for (i = n; i <= 600 - n; i += n){
            sum += i * i;
        }
        sum *= n;
        printf(""%lld\n"", sum);
    }
    return 0;
}",1
p00014,"Integral
Write a program which computes the area of a shape represented by the following three lines:
$y = x^2$
$y = 0$
$x = 600$
It is clear that the area is $72000000$, if you use an integral you learn in high school. On the other hand, we can obtain an approximative area of the shape by adding up areas of many rectangles in the shape as shown in the following figure:
$f(x) = x^2$
The approximative area $s$ where the width of the rectangles is $d$ is:
area of rectangle where its width is $d$ and height is $f(d)$ $+$
area of rectangle where its width is $d$ and height is $f(2d)$ $+$
area of rectangle where its width is $d$ and height is $f(3d)$ $+$
...
area of rectangle where its width is $d$ and height is $f(600 - d)$
The more we decrease $d$, the higer-precision value which is close to $72000000$ we could obtain. Your program should read the integer $d$ which is a divisor of $600$, and print the area $s$.
Input
The input consists of several datasets. Each dataset consists of an integer $d$ in a line. The number of datasets is less than or equal to 20.
Output
For each dataset, print the area $s$ in a line.
Sample Input
20
10
Output for the Sample Input
68440000
70210000",Java,"import java.util.Scanner;

public class Main {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        
        while (sc.hasNext()) {
            int d = sc.nextInt();
            long area = 0;
            
            for (int x = d; x < 600; x += d) {
                area += (long) d * x * x;
            }
            
            System.out.println(area);
        }
        
        sc.close();
    }
}
",0
p00014,"Integral
Write a program which computes the area of a shape represented by the following three lines:
$y = x^2$
$y = 0$
$x = 600$
It is clear that the area is $72000000$, if you use an integral you learn in high school. On the other hand, we can obtain an approximative area of the shape by adding up areas of many rectangles in the shape as shown in the following figure:
$f(x) = x^2$
The approximative area $s$ where the width of the rectangles is $d$ is:
area of rectangle where its width is $d$ and height is $f(d)$ $+$
area of rectangle where its width is $d$ and height is $f(2d)$ $+$
area of rectangle where its width is $d$ and height is $f(3d)$ $+$
...
area of rectangle where its width is $d$ and height is $f(600 - d)$
The more we decrease $d$, the higer-precision value which is close to $72000000$ we could obtain. Your program should read the integer $d$ which is a divisor of $600$, and print the area $s$.
Input
The input consists of several datasets. Each dataset consists of an integer $d$ in a line. The number of datasets is less than or equal to 20.
Output
For each dataset, print the area $s$ in a line.
Sample Input
20
10
Output for the Sample Input
68440000
70210000",Java,"/**
 * 
 * AOJ No. 0014 Integral
 * 
 * @author 	yuichirw <y.iky917@gmail.com+>
 * @see		http://rose.u-aizu.ac.jp/onlinejudge/ProblemSet/description.jsp?id=0014&lang=jp
 */

import java.util.*;
public class Main {
	
	static Scanner sc = new Scanner(System.in);
	static int d;
	
	static boolean read() {
		if(!sc.hasNextInt()) return false;
		d = sc.nextInt();
		return true;
	}
	
	static int solve() {
		int ans,n;
		ans = 0; n = 600 / d;
		for(int x = d; x < 600; x += d) {
			ans += d * ((x * x));
		}
		return ans;
	}
	
	
	public static void main(String[] args) {
		while(read()) {
			System.out.println(solve());
		}
	}

}",1
p00014,"Integral
Write a program which computes the area of a shape represented by the following three lines:
$y = x^2$
$y = 0$
$x = 600$
It is clear that the area is $72000000$, if you use an integral you learn in high school. On the other hand, we can obtain an approximative area of the shape by adding up areas of many rectangles in the shape as shown in the following figure:
$f(x) = x^2$
The approximative area $s$ where the width of the rectangles is $d$ is:
area of rectangle where its width is $d$ and height is $f(d)$ $+$
area of rectangle where its width is $d$ and height is $f(2d)$ $+$
area of rectangle where its width is $d$ and height is $f(3d)$ $+$
...
area of rectangle where its width is $d$ and height is $f(600 - d)$
The more we decrease $d$, the higer-precision value which is close to $72000000$ we could obtain. Your program should read the integer $d$ which is a divisor of $600$, and print the area $s$.
Input
The input consists of several datasets. Each dataset consists of an integer $d$ in a line. The number of datasets is less than or equal to 20.
Output
For each dataset, print the area $s$ in a line.
Sample Input
20
10
Output for the Sample Input
68440000
70210000",Python,"import sys

for line in sys.stdin:
    d = int(line.strip())
    s = 0
    x = d
    while x <= 600 - d:
        s += d * (x * x)
        x += d
    print(s)
",0
p00014,"Integral
Write a program which computes the area of a shape represented by the following three lines:
$y = x^2$
$y = 0$
$x = 600$
It is clear that the area is $72000000$, if you use an integral you learn in high school. On the other hand, we can obtain an approximative area of the shape by adding up areas of many rectangles in the shape as shown in the following figure:
$f(x) = x^2$
The approximative area $s$ where the width of the rectangles is $d$ is:
area of rectangle where its width is $d$ and height is $f(d)$ $+$
area of rectangle where its width is $d$ and height is $f(2d)$ $+$
area of rectangle where its width is $d$ and height is $f(3d)$ $+$
...
area of rectangle where its width is $d$ and height is $f(600 - d)$
The more we decrease $d$, the higer-precision value which is close to $72000000$ we could obtain. Your program should read the integer $d$ which is a divisor of $600$, and print the area $s$.
Input
The input consists of several datasets. Each dataset consists of an integer $d$ in a line. The number of datasets is less than or equal to 20.
Output
For each dataset, print the area $s$ in a line.
Sample Input
20
10
Output for the Sample Input
68440000
70210000",Python,"#!/usr/bin/env python
#-*- coding:utf-8 -*-

import sys
import math

def rectArea(h, w):
    return h * w


for d in sys.stdin:
    area = 0
    d = int(d)
    for i in range(0, 600, d):
        area += rectArea(i*i, d)

    print(area)",1
p00015,"National Budget
A country has a budget of more than 81 trillion yen. We want to process such data, but conventional integer type which uses signed 32 bit can represent up to 2,147,483,647.
Your task is to write a program which reads two integers (more than or equal to zero), and prints a sum of these integers.
If given integers or the sum have more than 80 digits, print ""overflow"".
Input
Input consists of several datasets. In the first line, the number of datasets
N
(1 ≤
N
≤ 50) is given. Each dataset consists of 2 lines:
The first integer
The second integer
The integer has at most 100 digits.
Output
For each dataset, print the sum of given integers in a line.
Sample Input
6
1000
800
9999999999999999999999999999999999999999
1
99999999999999999999999999999999999999999999999999999999999999999999999999999999
1
99999999999999999999999999999999999999999999999999999999999999999999999999999999
0
100000000000000000000000000000000000000000000000000000000000000000000000000000000
1
100000000000000000000000000000000000000000000000000000000000000000000000000000000
100000000000000000000000000000000000000000000000000000000000000000000000000000000
Output for the Sample Input
1800
10000000000000000000000000000000000000000
overflow
99999999999999999999999999999999999999999999999999999999999999999999999999999999
overflow
overflow",C,"#include <stdio.h>
#include <string.h>
#include <ctype.h>

void reverseString(char *str) {
    int len = strlen(str);
    for (int i = 0; i < len / 2; i++) {
        char temp = str[i];
        str[i] = str[len - 1 - i];
        str[len - 1 - i] = temp;
    }
}

int main() {
    int N;
    scanf(""%d"", &N);
    
    while (N--) {
        char num1[105], num2[105], result[105];
        scanf(""%s %s"", num1, num2);
        
        int len1 = strlen(num1);
        int len2 = strlen(num2);
        
        // Check if input has more than 80 digits
        if (len1 > 80 || len2 > 80) {
            printf(""overflow\n"");
            continue;
        }
        
        // Reverse the strings for easier addition
        reverseString(num1);
        reverseString(num2);
        
        int maxLen = (len1 > len2) ? len1 : len2;
        int carry = 0;
        int resultLen = 0;
        
        for (int i = 0; i < maxLen || carry; i++) {
            int digit1 = (i < len1) ? (num1[i] - '0') : 0;
            int digit2 = (i < len2) ? (num2[i] - '0') : 0;
            
            int sum = digit1 + digit2 + carry;
            result[resultLen++] = (sum % 10) + '0';
            carry = sum / 10;
        }
        
        result[resultLen] = '\0';
        
        // Check if result has more than 80 digits
        if (resultLen > 80) {
            printf(""overflow\n"");
            continue;
        }
        
        // Reverse result back
        reverseString(result);
        
        printf(""%s\n"", result);
    }
    
    return 0;
}
",0
p00015,"National Budget
A country has a budget of more than 81 trillion yen. We want to process such data, but conventional integer type which uses signed 32 bit can represent up to 2,147,483,647.
Your task is to write a program which reads two integers (more than or equal to zero), and prints a sum of these integers.
If given integers or the sum have more than 80 digits, print ""overflow"".
Input
Input consists of several datasets. In the first line, the number of datasets
N
(1 ≤
N
≤ 50) is given. Each dataset consists of 2 lines:
The first integer
The second integer
The integer has at most 100 digits.
Output
For each dataset, print the sum of given integers in a line.
Sample Input
6
1000
800
9999999999999999999999999999999999999999
1
99999999999999999999999999999999999999999999999999999999999999999999999999999999
1
99999999999999999999999999999999999999999999999999999999999999999999999999999999
0
100000000000000000000000000000000000000000000000000000000000000000000000000000000
1
100000000000000000000000000000000000000000000000000000000000000000000000000000000
100000000000000000000000000000000000000000000000000000000000000000000000000000000
Output for the Sample Input
1800
10000000000000000000000000000000000000000
overflow
99999999999999999999999999999999999999999999999999999999999999999999999999999999
overflow
overflow",C,"#include <stdio.h>

int main(void)
{
	__int64 a, b, sum;
	int keta;
	int n;
	int i;
	
	scanf(""%d"", &n);
	for (i = 0; i < n; i++){
		scanf(""%I64u"", &a);
		scanf(""%I64u"", &b);
		sum = a + b;
		
		keta = 1;
		while (sum / 10 > 0){
			keta++;
			sum /= 10;
		}
		
		if (keta > 80){
			printf(""overflow\n"");
		}
		else {
			sum = a + b;
			printf(""%I64u\n"", sum);
		}
	}
	return (0);
}",1
p00015,"National Budget
A country has a budget of more than 81 trillion yen. We want to process such data, but conventional integer type which uses signed 32 bit can represent up to 2,147,483,647.
Your task is to write a program which reads two integers (more than or equal to zero), and prints a sum of these integers.
If given integers or the sum have more than 80 digits, print ""overflow"".
Input
Input consists of several datasets. In the first line, the number of datasets
N
(1 ≤
N
≤ 50) is given. Each dataset consists of 2 lines:
The first integer
The second integer
The integer has at most 100 digits.
Output
For each dataset, print the sum of given integers in a line.
Sample Input
6
1000
800
9999999999999999999999999999999999999999
1
99999999999999999999999999999999999999999999999999999999999999999999999999999999
1
99999999999999999999999999999999999999999999999999999999999999999999999999999999
0
100000000000000000000000000000000000000000000000000000000000000000000000000000000
1
100000000000000000000000000000000000000000000000000000000000000000000000000000000
100000000000000000000000000000000000000000000000000000000000000000000000000000000
Output for the Sample Input
1800
10000000000000000000000000000000000000000
overflow
99999999999999999999999999999999999999999999999999999999999999999999999999999999
overflow
overflow",Java,"import java.util.*;
import java.math.BigInteger;

public class Main {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int n = sc.nextInt();
        sc.nextLine();
        
        for (int i = 0; i < n; i++) {
            String a = sc.nextLine().trim();
            String b = sc.nextLine().trim();
            
            if (a.length() > 80 || b.length() > 80) {
                System.out.println(""overflow"");
                continue;
            }
            
            BigInteger num1 = new BigInteger(a);
            BigInteger num2 = new BigInteger(b);
            BigInteger sum = num1.add(num2);
            
            String result = sum.toString();
            if (result.length() > 80) {
                System.out.println(""overflow"");
            } else {
                System.out.println(result);
            }
        }
        
        sc.close();
    }
}
",0
p00015,"National Budget
A country has a budget of more than 81 trillion yen. We want to process such data, but conventional integer type which uses signed 32 bit can represent up to 2,147,483,647.
Your task is to write a program which reads two integers (more than or equal to zero), and prints a sum of these integers.
If given integers or the sum have more than 80 digits, print ""overflow"".
Input
Input consists of several datasets. In the first line, the number of datasets
N
(1 ≤
N
≤ 50) is given. Each dataset consists of 2 lines:
The first integer
The second integer
The integer has at most 100 digits.
Output
For each dataset, print the sum of given integers in a line.
Sample Input
6
1000
800
9999999999999999999999999999999999999999
1
99999999999999999999999999999999999999999999999999999999999999999999999999999999
1
99999999999999999999999999999999999999999999999999999999999999999999999999999999
0
100000000000000000000000000000000000000000000000000000000000000000000000000000000
1
100000000000000000000000000000000000000000000000000000000000000000000000000000000
100000000000000000000000000000000000000000000000000000000000000000000000000000000
Output for the Sample Input
1800
10000000000000000000000000000000000000000
overflow
99999999999999999999999999999999999999999999999999999999999999999999999999999999
overflow
overflow",Java,"import java.math.BigInteger;
import java.util.Scanner;

public class Main {

	public static void main(String[] args) {

		Scanner sc = new Scanner(System.in);

		while (sc.hasNext()) {
			String s1 = sc.next();
			String s2 = sc.next();
			if (s1.length() > 80 || s2.length() > 80)
				System.out.println(""overflow"");
			BigInteger b = new BigInteger(s1).add(new BigInteger(s2));
			System.out.println(b.toString().length() > 80 ? ""overflow"" : b);
		}

	}

}",1
p00015,"National Budget
A country has a budget of more than 81 trillion yen. We want to process such data, but conventional integer type which uses signed 32 bit can represent up to 2,147,483,647.
Your task is to write a program which reads two integers (more than or equal to zero), and prints a sum of these integers.
If given integers or the sum have more than 80 digits, print ""overflow"".
Input
Input consists of several datasets. In the first line, the number of datasets
N
(1 ≤
N
≤ 50) is given. Each dataset consists of 2 lines:
The first integer
The second integer
The integer has at most 100 digits.
Output
For each dataset, print the sum of given integers in a line.
Sample Input
6
1000
800
9999999999999999999999999999999999999999
1
99999999999999999999999999999999999999999999999999999999999999999999999999999999
1
99999999999999999999999999999999999999999999999999999999999999999999999999999999
0
100000000000000000000000000000000000000000000000000000000000000000000000000000000
1
100000000000000000000000000000000000000000000000000000000000000000000000000000000
100000000000000000000000000000000000000000000000000000000000000000000000000000000
Output for the Sample Input
1800
10000000000000000000000000000000000000000
overflow
99999999999999999999999999999999999999999999999999999999999999999999999999999999
overflow
overflow",Python,"N = int(input())
for _ in range(N):
    a = input().strip()
    b = input().strip()
    
    # Check if input integers have more than 80 digits
    if len(a) > 80 or len(b) > 80:
        print(""overflow"")
        continue
    
    # Convert to integers and calculate sum
    num_a = int(a)
    num_b = int(b)
    result = num_a + num_b
    
    # Check if sum has more than 80 digits
    if len(str(result)) > 80:
        print(""overflow"")
    else:
        print(result)
",0
p00015,"National Budget
A country has a budget of more than 81 trillion yen. We want to process such data, but conventional integer type which uses signed 32 bit can represent up to 2,147,483,647.
Your task is to write a program which reads two integers (more than or equal to zero), and prints a sum of these integers.
If given integers or the sum have more than 80 digits, print ""overflow"".
Input
Input consists of several datasets. In the first line, the number of datasets
N
(1 ≤
N
≤ 50) is given. Each dataset consists of 2 lines:
The first integer
The second integer
The integer has at most 100 digits.
Output
For each dataset, print the sum of given integers in a line.
Sample Input
6
1000
800
9999999999999999999999999999999999999999
1
99999999999999999999999999999999999999999999999999999999999999999999999999999999
1
99999999999999999999999999999999999999999999999999999999999999999999999999999999
0
100000000000000000000000000000000000000000000000000000000000000000000000000000000
1
100000000000000000000000000000000000000000000000000000000000000000000000000000000
100000000000000000000000000000000000000000000000000000000000000000000000000000000
Output for the Sample Input
1800
10000000000000000000000000000000000000000
overflow
99999999999999999999999999999999999999999999999999999999999999999999999999999999
overflow
overflow",Python,"n = input()

for i in range(n):
    a = input(),
    b = input()
    c = a + b
    if len(a) > 80 or len(b) > 80 or len(c) > 80 :
        print 'overflow'
    else:
        print a + b",1
p00016,"Treasure Hunt
When a boy was cleaning up after his grand father passing, he found an old paper:
In addition, other side of the paper says that ""go ahead a number of steps equivalent to the first integer, and turn clockwise by degrees equivalent to the second integer"".
His grand mother says that Sanbonmatsu was standing at the center of town. However, now buildings are crammed side by side and people can not walk along exactly what the paper says in. Your task is to write a program which hunts for the treature on the paper.
For simplicity, 1 step is equivalent to 1 meter. Input consists of several pairs of two integers
d
(the first integer) and
t
(the second integer) separated by a comma. Input ends with ""0, 0"". Your program should print the coordinate (
x
,
y
) of the end point. There is the treature where x meters to the east and y meters to the north from the center of town.
You can assume that
d
≤ 100 and -180 ≤
t
≤ 180.
Input
A sequence of pairs of integers
d
and
t
which end with ""
0,0
"".
Output
Print the integer portion of
x
and
y
in a line respectively.
Sample Input
56,65
97,54
64,-4
55,76
42,-27
43,80
87,-86
55,-6
89,34
95,5
0,0
Output for the Sample Input
171
-302",C,"#include <stdio.h>
#include <math.h>

int main() {
    int d, t;
    double x = 0.0, y = 0.0;
    double angle = 90.0; // Start facing north (90 degrees from east)
    
    while(1) {
        scanf(""%d,%d"", &d, &t);
        if(d == 0 && t == 0) break;
        
        // Move d steps in current direction
        double rad = angle * M_PI / 180.0;
        x += d * cos(rad);
        y += d * sin(rad);
        
        // Turn clockwise by t degrees (subtract from angle)
        angle -= t;
    }
    
    printf(""%d\n%d\n"", (int)x, (int)y);
    
    return 0;
}
",0
p00016,"Treasure Hunt
When a boy was cleaning up after his grand father passing, he found an old paper:
In addition, other side of the paper says that ""go ahead a number of steps equivalent to the first integer, and turn clockwise by degrees equivalent to the second integer"".
His grand mother says that Sanbonmatsu was standing at the center of town. However, now buildings are crammed side by side and people can not walk along exactly what the paper says in. Your task is to write a program which hunts for the treature on the paper.
For simplicity, 1 step is equivalent to 1 meter. Input consists of several pairs of two integers
d
(the first integer) and
t
(the second integer) separated by a comma. Input ends with ""0, 0"". Your program should print the coordinate (
x
,
y
) of the end point. There is the treature where x meters to the east and y meters to the north from the center of town.
You can assume that
d
≤ 100 and -180 ≤
t
≤ 180.
Input
A sequence of pairs of integers
d
and
t
which end with ""
0,0
"".
Output
Print the integer portion of
x
and
y
in a line respectively.
Sample Input
56,65
97,54
64,-4
55,76
42,-27
43,80
87,-86
55,-6
89,34
95,5
0,0
Output for the Sample Input
171
-302",C,"/*
AizuOnline A0016
Tresure hunt
*/
#include <stdio.h>
#include <math.h>
#include <float.h>

double x,y;
int len,arg;
double PAI=3.14159265;

main()
{
  x=0.0; y=0.0;
  int argsum = 90; 

  while(EOF != scanf(""%d,%d"",&len,&arg) && (len || arg))
    {
      x += cos(((double)argsum)*(PAI/180))*(double)len;
      y += sin(((double)argsum)*(PAI/180))*(double)len;

      //printf(""%d:%d %d %d %d\n"",(int)x,(int)y,argsum,len,arg);
      argsum -= arg;
    }
  printf(""%d\n%d\n"",(int)x,(int)y);
return(0);
}",1
p00016,"Treasure Hunt
When a boy was cleaning up after his grand father passing, he found an old paper:
In addition, other side of the paper says that ""go ahead a number of steps equivalent to the first integer, and turn clockwise by degrees equivalent to the second integer"".
His grand mother says that Sanbonmatsu was standing at the center of town. However, now buildings are crammed side by side and people can not walk along exactly what the paper says in. Your task is to write a program which hunts for the treature on the paper.
For simplicity, 1 step is equivalent to 1 meter. Input consists of several pairs of two integers
d
(the first integer) and
t
(the second integer) separated by a comma. Input ends with ""0, 0"". Your program should print the coordinate (
x
,
y
) of the end point. There is the treature where x meters to the east and y meters to the north from the center of town.
You can assume that
d
≤ 100 and -180 ≤
t
≤ 180.
Input
A sequence of pairs of integers
d
and
t
which end with ""
0,0
"".
Output
Print the integer portion of
x
and
y
in a line respectively.
Sample Input
56,65
97,54
64,-4
55,76
42,-27
43,80
87,-86
55,-6
89,34
95,5
0,0
Output for the Sample Input
171
-302",Java,"import java.util.*;

public class Main {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        
        double x = 0;
        double y = 0;
        double angle = 90; // Starting facing north (90 degrees from east)
        
        while (true) {
            String line = sc.nextLine();
            String[] parts = line.split("","");
            int d = Integer.parseInt(parts[0].trim());
            int t = Integer.parseInt(parts[1].trim());
            
            if (d == 0 && t == 0) {
                break;
            }
            
            // Move d steps in current direction
            double radians = Math.toRadians(angle);
            x += d * Math.cos(radians);
            y += d * Math.sin(radians);
            
            // Turn clockwise by t degrees (subtract because clockwise is negative rotation)
            angle -= t;
        }
        
        System.out.println((int)x);
        System.out.println((int)y);
    }
}
",0
p00016,"Treasure Hunt
When a boy was cleaning up after his grand father passing, he found an old paper:
In addition, other side of the paper says that ""go ahead a number of steps equivalent to the first integer, and turn clockwise by degrees equivalent to the second integer"".
His grand mother says that Sanbonmatsu was standing at the center of town. However, now buildings are crammed side by side and people can not walk along exactly what the paper says in. Your task is to write a program which hunts for the treature on the paper.
For simplicity, 1 step is equivalent to 1 meter. Input consists of several pairs of two integers
d
(the first integer) and
t
(the second integer) separated by a comma. Input ends with ""0, 0"". Your program should print the coordinate (
x
,
y
) of the end point. There is the treature where x meters to the east and y meters to the north from the center of town.
You can assume that
d
≤ 100 and -180 ≤
t
≤ 180.
Input
A sequence of pairs of integers
d
and
t
which end with ""
0,0
"".
Output
Print the integer portion of
x
and
y
in a line respectively.
Sample Input
56,65
97,54
64,-4
55,76
42,-27
43,80
87,-86
55,-6
89,34
95,5
0,0
Output for the Sample Input
171
-302",Java,"import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;


public class Main {
	public static void main(String[] aegs){
		BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
		int a = 0,c=0;
		String t = """";
		double counta =0,countb = 0;
		double rad = 90.0;
		double PI = Math.PI;
		
		while(true){
		
			try {
				t = br.readLine();
			} catch (IOException e) {
				// TODO 自動生成された catch ブロック
				e.printStackTrace();
			}
			
			
			String[] tt = t.split("","",0);
			a = Integer.parseInt(tt[0]);
			c = Integer.parseInt(tt[1]);
			if(a == 0 && c == 0){
				break;
			}
			
			
			counta +=  (a * Math.sin(rad*PI/180d));
			countb +=  (a * Math.cos(rad*PI/180d));
			rad = rad - c;
			
		}
		System.out.println((int)countb);
		System.out.println((int)counta);
		
	}


}",1
p00016,"Treasure Hunt
When a boy was cleaning up after his grand father passing, he found an old paper:
In addition, other side of the paper says that ""go ahead a number of steps equivalent to the first integer, and turn clockwise by degrees equivalent to the second integer"".
His grand mother says that Sanbonmatsu was standing at the center of town. However, now buildings are crammed side by side and people can not walk along exactly what the paper says in. Your task is to write a program which hunts for the treature on the paper.
For simplicity, 1 step is equivalent to 1 meter. Input consists of several pairs of two integers
d
(the first integer) and
t
(the second integer) separated by a comma. Input ends with ""0, 0"". Your program should print the coordinate (
x
,
y
) of the end point. There is the treature where x meters to the east and y meters to the north from the center of town.
You can assume that
d
≤ 100 and -180 ≤
t
≤ 180.
Input
A sequence of pairs of integers
d
and
t
which end with ""
0,0
"".
Output
Print the integer portion of
x
and
y
in a line respectively.
Sample Input
56,65
97,54
64,-4
55,76
42,-27
43,80
87,-86
55,-6
89,34
95,5
0,0
Output for the Sample Input
171
-302",Python,"import math

x = 0.0
y = 0.0
angle = 90.0  # Starting direction: north (90 degrees from east)

while True:
    line = input().strip()
    d, t = map(int, line.split(','))
    
    if d == 0 and t == 0:
        break
    
    # Move d steps in current direction
    x += d * math.cos(math.radians(angle))
    y += d * math.sin(math.radians(angle))
    
    # Turn clockwise by t degrees (subtract because clockwise is negative)
    angle -= t

print(int(x))
print(int(y))
",0
p00016,"Treasure Hunt
When a boy was cleaning up after his grand father passing, he found an old paper:
In addition, other side of the paper says that ""go ahead a number of steps equivalent to the first integer, and turn clockwise by degrees equivalent to the second integer"".
His grand mother says that Sanbonmatsu was standing at the center of town. However, now buildings are crammed side by side and people can not walk along exactly what the paper says in. Your task is to write a program which hunts for the treature on the paper.
For simplicity, 1 step is equivalent to 1 meter. Input consists of several pairs of two integers
d
(the first integer) and
t
(the second integer) separated by a comma. Input ends with ""0, 0"". Your program should print the coordinate (
x
,
y
) of the end point. There is the treature where x meters to the east and y meters to the north from the center of town.
You can assume that
d
≤ 100 and -180 ≤
t
≤ 180.
Input
A sequence of pairs of integers
d
and
t
which end with ""
0,0
"".
Output
Print the integer portion of
x
and
y
in a line respectively.
Sample Input
56,65
97,54
64,-4
55,76
42,-27
43,80
87,-86
55,-6
89,34
95,5
0,0
Output for the Sample Input
171
-302",Python,"import turtle
k = turtle.Turtle()
k.speed(0)
k.left(90)
while True:
    x = map(int,raw_input().split("",""))
    if x[0] == 0 and x[1] == 0:
        break
    else:
        k.fd(x[0])
        k.right(x[1])
        continue
print int(k.xcor())
print int(k.ycor())",1
p00018,"Sorting Five Numbers
Write a program which reads five numbers and sorts them in descending order.
Input
Input consists of five numbers
a
,
b
,
c
,
d
and
e
(-100000 ≤
a
,
b
,
c
,
d
,
e
≤ 100000). The five numbers are separeted by a space.
Output
Print the ordered numbers in a line. Adjacent numbers should be separated by a space.
Sample Input
3 6 9 7 5
Output for the Sample Input
9 7 6 5 3",C,"#include <stdio.h>

int main() {
    int arr[5];
    int i, j, temp;
    
    for(i = 0; i < 5; i++) {
        scanf(""%d"", &arr[i]);
    }
    
    for(i = 0; i < 4; i++) {
        for(j = i + 1; j < 5; j++) {
            if(arr[i] < arr[j]) {
                temp = arr[i];
                arr[i] = arr[j];
                arr[j] = temp;
            }
        }
    }
    
    for(i = 0; i < 5; i++) {
        if(i > 0) printf("" "");
        printf(""%d"", arr[i]);
    }
    printf(""\n"");
    
    return 0;
}
",0
p00018,"Sorting Five Numbers
Write a program which reads five numbers and sorts them in descending order.
Input
Input consists of five numbers
a
,
b
,
c
,
d
and
e
(-100000 ≤
a
,
b
,
c
,
d
,
e
≤ 100000). The five numbers are separeted by a space.
Output
Print the ordered numbers in a line. Adjacent numbers should be separated by a space.
Sample Input
3 6 9 7 5
Output for the Sample Input
9 7 6 5 3",C,"#include<stdio.h>
int main(void)
{
    int a[5],i,j,k;
    int x=0;

    for(i=0;i<5;i++){
        scanf(""%d"",&a[i]);
        for(j=0;j<5;j++){
            if(a[i]>a[j]){
                x=a[i];
                a[i]=a[j];
                a[j]=x;
            }
        }
    }
    for(k=0;k<5;k++){
        printf(""%d "",a[k]);
    }
    return 0;
}",1
p00018,"Sorting Five Numbers
Write a program which reads five numbers and sorts them in descending order.
Input
Input consists of five numbers
a
,
b
,
c
,
d
and
e
(-100000 ≤
a
,
b
,
c
,
d
,
e
≤ 100000). The five numbers are separeted by a space.
Output
Print the ordered numbers in a line. Adjacent numbers should be separated by a space.
Sample Input
3 6 9 7 5
Output for the Sample Input
9 7 6 5 3",Java,"import java.util.*;

public class Main {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int[] arr = new int[5];
        for (int i = 0; i < 5; i++) {
            arr[i] = sc.nextInt();
        }
        Arrays.sort(arr);
        for (int i = 4; i >= 0; i--) {
            if (i == 4) {
                System.out.print(arr[i]);
            } else {
                System.out.print("" "" + arr[i]);
            }
        }
        System.out.println();
        sc.close();
    }
}
",0
p00018,"Sorting Five Numbers
Write a program which reads five numbers and sorts them in descending order.
Input
Input consists of five numbers
a
,
b
,
c
,
d
and
e
(-100000 ≤
a
,
b
,
c
,
d
,
e
≤ 100000). The five numbers are separeted by a space.
Output
Print the ordered numbers in a line. Adjacent numbers should be separated by a space.
Sample Input
3 6 9 7 5
Output for the Sample Input
9 7 6 5 3",Java,"import java.util.*;

class Int implements Comparable<Int>{
	public int i;
	Int(int i){this.i = i;}
	public int compareTo (Int I){return I.i - this.i;}
}

public class Main {
	
	public static void main(String[] args) {

		//input
		Scanner sc = new Scanner(System.in).useDelimiter(System.getProperty(""line.separator""));
		String[] s = sc.next().split(""\\s"");
		Int[] ar = new Int[5];
		for(int i=0;i<5;i++){ar[i] = new Int(Integer.parseInt(s[i]));}
		
		//calculation
		Arrays.sort(ar);
		
		//output
		for(int i=0;i<5;i++){
			System.out.print(ar[i].i);
			if(i < 4){System.out.print("" "");}
		}
		System.out.println();
	}
}",1
p00018,"Sorting Five Numbers
Write a program which reads five numbers and sorts them in descending order.
Input
Input consists of five numbers
a
,
b
,
c
,
d
and
e
(-100000 ≤
a
,
b
,
c
,
d
,
e
≤ 100000). The five numbers are separeted by a space.
Output
Print the ordered numbers in a line. Adjacent numbers should be separated by a space.
Sample Input
3 6 9 7 5
Output for the Sample Input
9 7 6 5 3",Python,"numbers = list(map(int, input().split()))
numbers.sort(reverse=True)
print(' '.join(map(str, numbers)))
",0
p00018,"Sorting Five Numbers
Write a program which reads five numbers and sorts them in descending order.
Input
Input consists of five numbers
a
,
b
,
c
,
d
and
e
(-100000 ≤
a
,
b
,
c
,
d
,
e
≤ 100000). The five numbers are separeted by a space.
Output
Print the ordered numbers in a line. Adjacent numbers should be separated by a space.
Sample Input
3 6 9 7 5
Output for the Sample Input
9 7 6 5 3",Python,"a = map(int, raw_input().split())
a.sort()
a.reverse()
print "" "".join(map(str, a))",1
p00019,"Factorial
Write a program which reads an integer
n
and prints the factorial of
n
. You can assume that
n
≤ 20.
Input
An integer
n
(1 ≤
n
≤ 20) in a line.
Output
Print the factorial of
n
in a line.
Sample Input
5
Output for the Sample Input
120",C,"#include <stdio.h>

int main() {
    int n;
    long long factorial = 1;
    
    scanf(""%d"", &n);
    
    for (int i = 1; i <= n; i++) {
        factorial *= i;
    }
    
    printf(""%lld\n"", factorial);
    
    return 0;
}
",0
p00019,"Factorial
Write a program which reads an integer
n
and prints the factorial of
n
. You can assume that
n
≤ 20.
Input
An integer
n
(1 ≤
n
≤ 20) in a line.
Output
Print the factorial of
n
in a line.
Sample Input
5
Output for the Sample Input
120",C,"#include<stdio.h>

int main(void)
{
int i,j;

scanf(""%d"",&i);
j=1;
for(;i>0;i--){
j*=i;
}
printf(""%d\n"",j);
return 0;
}",1
p00019,"Factorial
Write a program which reads an integer
n
and prints the factorial of
n
. You can assume that
n
≤ 20.
Input
An integer
n
(1 ≤
n
≤ 20) in a line.
Output
Print the factorial of
n
in a line.
Sample Input
5
Output for the Sample Input
120",Java,"import java.util.Scanner;

public class Main {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int n = sc.nextInt();
        long factorial = 1;
        for (int i = 2; i <= n; i++) {
            factorial *= i;
        }
        System.out.println(factorial);
        sc.close();
    }
}
",0
p00019,"Factorial
Write a program which reads an integer
n
and prints the factorial of
n
. You can assume that
n
≤ 20.
Input
An integer
n
(1 ≤
n
≤ 20) in a line.
Output
Print the factorial of
n
in a line.
Sample Input
5
Output for the Sample Input
120",Java,"import java.util.*;
import java.math.*;

public class Main{
    public static void main(String[] args){
	Scanner in = new Scanner(System.in);
	int a = in.nextInt();
	long b = 1;

	for(int i = 1 ; i <= a ; i++){
	    b = b*i;
	}
	System.out.println(b);
    }
}",1
p00019,"Factorial
Write a program which reads an integer
n
and prints the factorial of
n
. You can assume that
n
≤ 20.
Input
An integer
n
(1 ≤
n
≤ 20) in a line.
Output
Print the factorial of
n
in a line.
Sample Input
5
Output for the Sample Input
120",Python,"n = int(input())
result = 1
for i in range(1, n + 1):
    result *= i
print(result)
",0
p00019,"Factorial
Write a program which reads an integer
n
and prints the factorial of
n
. You can assume that
n
≤ 20.
Input
An integer
n
(1 ≤
n
≤ 20) in a line.
Output
Print the factorial of
n
in a line.
Sample Input
5
Output for the Sample Input
120",Python,"s=int(input())
ans=1
for i in range(1,s+1):
    ans *= i

print(ans)",1
p00020,"Capitalize
Write a program which replace all the lower-case letters of a given text with the corresponding captital letters.
Input
A text including lower-case letters, periods, and space is given in a line. The number of characters in the text is less than or equal to 200.
Output
Print the converted text.
Sample Input
this is a pen.
Output for the Sample Input
THIS IS A PEN.",C,"#include <stdio.h>
#include <ctype.h>

int main() {
    char c;
    while ((c = getchar()) != EOF) {
        putchar(toupper(c));
    }
    return 0;
}
",0
p00020,"Capitalize
Write a program which replace all the lower-case letters of a given text with the corresponding captital letters.
Input
A text including lower-case letters, periods, and space is given in a line. The number of characters in the text is less than or equal to 200.
Output
Print the converted text.
Sample Input
this is a pen.
Output for the Sample Input
THIS IS A PEN.",C,"#include <stdio.h>

int main(void)
{
  char ch[81];
  int i;

  gets(ch);
  for(i = 0; ch[i] != '\0'; ++i)
    {
      if('a' <= ch[i] && ch[i] <= 'z')
	{
	  ch[i] -= 32;
	}
    }
  puts(ch);
  return 0;
}",1
p00020,"Capitalize
Write a program which replace all the lower-case letters of a given text with the corresponding captital letters.
Input
A text including lower-case letters, periods, and space is given in a line. The number of characters in the text is less than or equal to 200.
Output
Print the converted text.
Sample Input
this is a pen.
Output for the Sample Input
THIS IS A PEN.",Java,"import java.util.Scanner;

public class Main {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        String text = sc.nextLine();
        System.out.println(text.toUpperCase());
        sc.close();
    }
}
",0
p00020,"Capitalize
Write a program which replace all the lower-case letters of a given text with the corresponding captital letters.
Input
A text including lower-case letters, periods, and space is given in a line. The number of characters in the text is less than or equal to 200.
Output
Print the converted text.
Sample Input
this is a pen.
Output for the Sample Input
THIS IS A PEN.",Java,"import java.util.Scanner;

public class Main {

    public static void main(String[] args) {
        Scanner s = new Scanner(System.in);

        String input = s.nextLine();
        System.out.println(input.toUpperCase());
    }

}",1
p00020,"Capitalize
Write a program which replace all the lower-case letters of a given text with the corresponding captital letters.
Input
A text including lower-case letters, periods, and space is given in a line. The number of characters in the text is less than or equal to 200.
Output
Print the converted text.
Sample Input
this is a pen.
Output for the Sample Input
THIS IS A PEN.",Python,"print(input().upper())
",0
p00020,"Capitalize
Write a program which replace all the lower-case letters of a given text with the corresponding captital letters.
Input
A text including lower-case letters, periods, and space is given in a line. The number of characters in the text is less than or equal to 200.
Output
Print the converted text.
Sample Input
this is a pen.
Output for the Sample Input
THIS IS A PEN.",Python,print(input().upper()),1
p00021,"Parallelism
There are four points: $A(x_1, y_1)$, $B(x_2, y_2)$, $C(x_3, y_3)$, and $D(x_4, y_4)$. Write a program which determines whether the line $AB$ and the line $CD$ are parallel. If those two lines are parallel, your program should prints ""
YES
"" and if not prints ""
NO
"".
Input
Input consists of several datasets. In the first line, you are given the number of datasets $n$ ($n \leq 100$). There will be $n$ lines where each line correspondgs to each dataset. Each dataset consists of eight real numbers:
$x_1$ $y_1$ $x_2$ $y_2$ $x_3$ $y_3$ $x_4$ $y_4$
You can assume that $-100 \leq x_1, y_1, x_2, y_2, x_3, y_3, x_4, y_4 \leq 100$.
Each value is a real number with at most 5 digits after the decimal point.
Output
For each dataset, print ""
YES
"" or ""
NO
"" in a line.
Sample Input
2
0.0 0.0 1.0 1.0 1.0 0.0 2.0 1.0
3.0 2.0 9.0 6.0 13.0 5.0 7.0 9.0
Output for the Sample Input
YES
NO",C,"#include <stdio.h>
#include <math.h>

int main() {
    int n;
    double x1, y1, x2, y2, x3, y3, x4, y4;
    double dx1, dy1, dx2, dy2;
    double cross;
    
    scanf(""%d"", &n);
    
    while (n--) {
        scanf(""%lf %lf %lf %lf %lf %lf %lf %lf"", 
              &x1, &y1, &x2, &y2, &x3, &y3, &x4, &y4);
        
        dx1 = x2 - x1;
        dy1 = y2 - y1;
        dx2 = x4 - x3;
        dy2 = y4 - y3;
        
        cross = dx1 * dy2 - dy1 * dx2;
        
        if (fabs(cross) < 1e-9) {
            printf(""YES\n"");
        } else {
            printf(""NO\n"");
        }
    }
    
    return 0;
}
",0
p00021,"Parallelism
There are four points: $A(x_1, y_1)$, $B(x_2, y_2)$, $C(x_3, y_3)$, and $D(x_4, y_4)$. Write a program which determines whether the line $AB$ and the line $CD$ are parallel. If those two lines are parallel, your program should prints ""
YES
"" and if not prints ""
NO
"".
Input
Input consists of several datasets. In the first line, you are given the number of datasets $n$ ($n \leq 100$). There will be $n$ lines where each line correspondgs to each dataset. Each dataset consists of eight real numbers:
$x_1$ $y_1$ $x_2$ $y_2$ $x_3$ $y_3$ $x_4$ $y_4$
You can assume that $-100 \leq x_1, y_1, x_2, y_2, x_3, y_3, x_4, y_4 \leq 100$.
Each value is a real number with at most 5 digits after the decimal point.
Output
For each dataset, print ""
YES
"" or ""
NO
"" in a line.
Sample Input
2
0.0 0.0 1.0 1.0 1.0 0.0 2.0 1.0
3.0 2.0 9.0 6.0 13.0 5.0 7.0 9.0
Output for the Sample Input
YES
NO",C,"#include <stdio.h>
#include <math.h>

const double eps = 1e-10;

int n;
double x1, x2, x3, x4;
double y1, y2, y3, y4;

//増加率を見る方法
int solve1() {
    double r1 = (y2-y1)/(x2-x1);
    double r2 = (y4-y3)/(x4-x3);
    return (fabs(r1-r2) < eps);
}

int main() {
    scanf(""%d"", &n);
    for(int i=0; i<n; ++i) {
        scanf(""%lf %lf %lf %lf %lf %lf %lf %lf"", &x1, &y1, &x2, &y2, &x3, &y3, &x4, &y4);

        if(solve1()) {
            printf(""YES\n"");
        } else {
            printf(""NO\n"");
        }
    }
}
",1
p00021,"Parallelism
There are four points: $A(x_1, y_1)$, $B(x_2, y_2)$, $C(x_3, y_3)$, and $D(x_4, y_4)$. Write a program which determines whether the line $AB$ and the line $CD$ are parallel. If those two lines are parallel, your program should prints ""
YES
"" and if not prints ""
NO
"".
Input
Input consists of several datasets. In the first line, you are given the number of datasets $n$ ($n \leq 100$). There will be $n$ lines where each line correspondgs to each dataset. Each dataset consists of eight real numbers:
$x_1$ $y_1$ $x_2$ $y_2$ $x_3$ $y_3$ $x_4$ $y_4$
You can assume that $-100 \leq x_1, y_1, x_2, y_2, x_3, y_3, x_4, y_4 \leq 100$.
Each value is a real number with at most 5 digits after the decimal point.
Output
For each dataset, print ""
YES
"" or ""
NO
"" in a line.
Sample Input
2
0.0 0.0 1.0 1.0 1.0 0.0 2.0 1.0
3.0 2.0 9.0 6.0 13.0 5.0 7.0 9.0
Output for the Sample Input
YES
NO",Java,"import java.util.Scanner;

public class Main {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int n = sc.nextInt();
        
        for (int i = 0; i < n; i++) {
            double x1 = sc.nextDouble();
            double y1 = sc.nextDouble();
            double x2 = sc.nextDouble();
            double y2 = sc.nextDouble();
            double x3 = sc.nextDouble();
            double y3 = sc.nextDouble();
            double x4 = sc.nextDouble();
            double y4 = sc.nextDouble();
            
            double dx1 = x2 - x1;
            double dy1 = y2 - y1;
            double dx2 = x4 - x3;
            double dy2 = y4 - y3;
            
            double cross = dx1 * dy2 - dy1 * dx2;
            
            if (Math.abs(cross) < 1e-9) {
                System.out.println(""YES"");
            } else {
                System.out.println(""NO"");
            }
        }
        
        sc.close();
    }
}
",0
p00021,"Parallelism
There are four points: $A(x_1, y_1)$, $B(x_2, y_2)$, $C(x_3, y_3)$, and $D(x_4, y_4)$. Write a program which determines whether the line $AB$ and the line $CD$ are parallel. If those two lines are parallel, your program should prints ""
YES
"" and if not prints ""
NO
"".
Input
Input consists of several datasets. In the first line, you are given the number of datasets $n$ ($n \leq 100$). There will be $n$ lines where each line correspondgs to each dataset. Each dataset consists of eight real numbers:
$x_1$ $y_1$ $x_2$ $y_2$ $x_3$ $y_3$ $x_4$ $y_4$
You can assume that $-100 \leq x_1, y_1, x_2, y_2, x_3, y_3, x_4, y_4 \leq 100$.
Each value is a real number with at most 5 digits after the decimal point.
Output
For each dataset, print ""
YES
"" or ""
NO
"" in a line.
Sample Input
2
0.0 0.0 1.0 1.0 1.0 0.0 2.0 1.0
3.0 2.0 9.0 6.0 13.0 5.0 7.0 9.0
Output for the Sample Input
YES
NO",Java,"import java.util.*;
import static java.util.Arrays.*;
import static java.lang.Math.*;

// AOJ 0021
public class Main {

	static Scanner sc = new Scanner(System.in);
	static int N;
	static final double EPS = 1e-8;
	public static void main(String[] args) {
		N = sc.nextInt();
		double[] x = new double[4], y = new double[4];
		for (int i = 0; i < N; i++) {
			for (int j = 0; j < 4; j++) {
				x[j] = sc.nextDouble();
				y[j] = sc.nextDouble();
			}
			
			Complex 
				p1 = new Complex(x[0], y[0]),
				p2 = new Complex(x[1], y[1]),
				p3 = new Complex(x[2], y[2]),
				p4 = new Complex(x[3], y[3]);
			
			if (!isCross(p1, p2, p3, p4)) {
				System.out.println(""YES"");
			} else {
				System.out.println(""No"");
			}
		}
	}
	
	static boolean isCross(Complex p1, Complex p2, Complex p3, Complex p4) {
		double det = p1.sub(p2).crossProduct(p3.sub(p4));
		if (Math.abs(det) < Complex.EPS) {
			return false;
		} else {
			return true;
		}
	}
}

class Complex {
	static final double EPS = 1e-10;
	
	double re, im;
	
	Complex (double r, double i) {
		re = r; im = i;
	}

	double arg() {
		return Math.atan2(im, re);
	}
	
	double abs2() {
		return re * re + im * im;
	}
	
	double abs() {
		return Math.sqrt(abs2());
	}
	
	double innerProdut(Complex o) {
		return re * o.re + im * o.im;
	}
	
	double crossProduct(Complex o) {
		return re * o.im - im * o.re;
	}
	
	static Complex polar(double theta, double r) {
		return new Complex(r * Math.cos(theta), r * Math.sin(theta));
	}
	
	Complex conj() {
		return new Complex(re, -im);
	}
	
	Complex add(Complex o) {
		return new Complex(re + o.re, im + o.im);
	}

	Complex sub(Complex o) {
		return new Complex(re - o.re, im - o.im);
	}
	
	Complex mul(Complex o) {
		return new Complex(re * o.re - im * o.im, re * o.im + im * o.re);
	}
	
	Complex div(Complex o) {
		return new Complex((re * o.re + im * o.im) / o.abs2(), (im * o.re - re * o.im) / o.abs2());
	}
}",1
p00021,"Parallelism
There are four points: $A(x_1, y_1)$, $B(x_2, y_2)$, $C(x_3, y_3)$, and $D(x_4, y_4)$. Write a program which determines whether the line $AB$ and the line $CD$ are parallel. If those two lines are parallel, your program should prints ""
YES
"" and if not prints ""
NO
"".
Input
Input consists of several datasets. In the first line, you are given the number of datasets $n$ ($n \leq 100$). There will be $n$ lines where each line correspondgs to each dataset. Each dataset consists of eight real numbers:
$x_1$ $y_1$ $x_2$ $y_2$ $x_3$ $y_3$ $x_4$ $y_4$
You can assume that $-100 \leq x_1, y_1, x_2, y_2, x_3, y_3, x_4, y_4 \leq 100$.
Each value is a real number with at most 5 digits after the decimal point.
Output
For each dataset, print ""
YES
"" or ""
NO
"" in a line.
Sample Input
2
0.0 0.0 1.0 1.0 1.0 0.0 2.0 1.0
3.0 2.0 9.0 6.0 13.0 5.0 7.0 9.0
Output for the Sample Input
YES
NO",Python,"n = int(input())
for _ in range(n):
    coords = list(map(float, input().split()))
    x1, y1, x2, y2, x3, y3, x4, y4 = coords
    
    # Direction vectors
    dx1 = x2 - x1
    dy1 = y2 - y1
    dx2 = x4 - x3
    dy2 = y4 - y3
    
    # Two lines are parallel if their direction vectors are parallel
    # This means the cross product should be zero
    cross = dx1 * dy2 - dy1 * dx2
    
    if abs(cross) < 1e-9:
        print(""YES"")
    else:
        print(""NO"")
",0
p00021,"Parallelism
There are four points: $A(x_1, y_1)$, $B(x_2, y_2)$, $C(x_3, y_3)$, and $D(x_4, y_4)$. Write a program which determines whether the line $AB$ and the line $CD$ are parallel. If those two lines are parallel, your program should prints ""
YES
"" and if not prints ""
NO
"".
Input
Input consists of several datasets. In the first line, you are given the number of datasets $n$ ($n \leq 100$). There will be $n$ lines where each line correspondgs to each dataset. Each dataset consists of eight real numbers:
$x_1$ $y_1$ $x_2$ $y_2$ $x_3$ $y_3$ $x_4$ $y_4$
You can assume that $-100 \leq x_1, y_1, x_2, y_2, x_3, y_3, x_4, y_4 \leq 100$.
Each value is a real number with at most 5 digits after the decimal point.
Output
For each dataset, print ""
YES
"" or ""
NO
"" in a line.
Sample Input
2
0.0 0.0 1.0 1.0 1.0 0.0 2.0 1.0
3.0 2.0 9.0 6.0 13.0 5.0 7.0 9.0
Output for the Sample Input
YES
NO",Python,"ans = []
n = input()
for i in range(n):
    x1,y1,x2,y2,x3,y3,x4,y4 = map(float,raw_input().split())
    if ((y2-y1)/(x2-x1) == (y4-y3)/(x4-x3)):
        ans.append('YES')
    else:
        ans.append('NO')
for i in ans:
    print i",1
p00023,"Circles Intersection
You are given circle $A$ with radius $r_a$ and with central coordinate $(x_a, y_a)$ and circle $B$ with radius $r_b$ and with central coordinate $(x_b, y_b)$.
Write a program which prints:
""2"" if $B$ is in $A$,
""-2"" if $A$ is in $B$,
""1"" if circumference of $A$ and $B$ intersect, and
""0"" if $A$ and $B$ do not overlap.
You may assume that $A$ and $B$ are not identical.
Input
The input consists of multiple datasets. The first line consists of an integer $N$ ($N \leq 50$), the number of datasets. There will be $N$ lines where each line represents each dataset. Each data set consists of real numbers:
$x_a$ $y_a$ $r_a$ $x_b$ $y_b$ $r_b$
Output
For each dataset, print 2, -2, 1, or 0 in a line.
Sample Input
2
0.0 0.0 5.0 0.0 0.0 4.0
0.0 0.0 2.0 4.1 0.0 2.0
Output for the Sample Input
2
0",C,"#include <stdio.h>
#include <math.h>

int main() {
    int n;
    scanf(""%d"", &n);
    
    while (n--) {
        double xa, ya, ra, xb, yb, rb;
        scanf(""%lf %lf %lf %lf %lf %lf"", &xa, &ya, &ra, &xb, &yb, &rb);
        
        double dist = sqrt((xa - xb) * (xa - xb) + (ya - yb) * (ya - yb));
        
        if (dist + rb < ra + 1e-9) {
            printf(""2\n"");
        } else if (dist + ra < rb + 1e-9) {
            printf(""-2\n"");
        } else if (dist < ra + rb + 1e-9 && dist + 1e-9 > fabs(ra - rb)) {
            printf(""1\n"");
        } else {
            printf(""0\n"");
        }
    }
    
    return 0;
}
",0
p00023,"Circles Intersection
You are given circle $A$ with radius $r_a$ and with central coordinate $(x_a, y_a)$ and circle $B$ with radius $r_b$ and with central coordinate $(x_b, y_b)$.
Write a program which prints:
""2"" if $B$ is in $A$,
""-2"" if $A$ is in $B$,
""1"" if circumference of $A$ and $B$ intersect, and
""0"" if $A$ and $B$ do not overlap.
You may assume that $A$ and $B$ are not identical.
Input
The input consists of multiple datasets. The first line consists of an integer $N$ ($N \leq 50$), the number of datasets. There will be $N$ lines where each line represents each dataset. Each data set consists of real numbers:
$x_a$ $y_a$ $r_a$ $x_b$ $y_b$ $r_b$
Output
For each dataset, print 2, -2, 1, or 0 in a line.
Sample Input
2
0.0 0.0 5.0 0.0 0.0 4.0
0.0 0.0 2.0 4.1 0.0 2.0
Output for the Sample Input
2
0",C,"#include <stdio.h>
#include <math.h>

typedef struct
{
    double x;
    double y;
    double r;
}circle;

int main(void)
{
    int datasets;
    scanf(""%d"", &datasets);

    while (datasets--) {
        circle a, b;
        scanf("" %lf %lf %lf"", &(a.x), &(a.y), &(a.r));
        scanf("" %lf %lf %lf"", &(b.x), &(b.y), &(b.r));

        double bigr, smallr;
        if (a.r >=  b.r) {
            bigr = a.r;
            smallr = b.r;
        } else {
            bigr = b.r;
            smallr = a.r;
        }

        double dist = pow(a.x - b.x, 2) + pow(a.y - b.y, 2);
        dist = sqrt(dist);

        int judge;
        if (dist > bigr + smallr) {
            judge = 0;
        } else if (dist > bigr - smallr) {
            judge = 1;
        } else {
            if (bigr == a.r) {
                judge = 2;
            } else {
                judge = -2;
            }
        }

        printf(""%d\n"", judge);
    }

    return 0;
}",1
p00023,"Circles Intersection
You are given circle $A$ with radius $r_a$ and with central coordinate $(x_a, y_a)$ and circle $B$ with radius $r_b$ and with central coordinate $(x_b, y_b)$.
Write a program which prints:
""2"" if $B$ is in $A$,
""-2"" if $A$ is in $B$,
""1"" if circumference of $A$ and $B$ intersect, and
""0"" if $A$ and $B$ do not overlap.
You may assume that $A$ and $B$ are not identical.
Input
The input consists of multiple datasets. The first line consists of an integer $N$ ($N \leq 50$), the number of datasets. There will be $N$ lines where each line represents each dataset. Each data set consists of real numbers:
$x_a$ $y_a$ $r_a$ $x_b$ $y_b$ $r_b$
Output
For each dataset, print 2, -2, 1, or 0 in a line.
Sample Input
2
0.0 0.0 5.0 0.0 0.0 4.0
0.0 0.0 2.0 4.1 0.0 2.0
Output for the Sample Input
2
0",Java,"import java.util.Scanner;

public class Main {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int n = sc.nextInt();
        
        for (int i = 0; i < n; i++) {
            double xa = sc.nextDouble();
            double ya = sc.nextDouble();
            double ra = sc.nextDouble();
            double xb = sc.nextDouble();
            double yb = sc.nextDouble();
            double rb = sc.nextDouble();
            
            double dist = Math.sqrt((xa - xb) * (xa - xb) + (ya - yb) * (ya - yb));
            
            if (dist + rb < ra || Math.abs(dist + rb - ra) < 1e-9) {
                System.out.println(2);
            } else if (dist + ra < rb || Math.abs(dist + ra - rb) < 1e-9) {
                System.out.println(-2);
            } else if (dist < ra + rb && dist > Math.abs(ra - rb)) {
                System.out.println(1);
            } else {
                System.out.println(0);
            }
        }
        
        sc.close();
    }
}
",0
p00023,"Circles Intersection
You are given circle $A$ with radius $r_a$ and with central coordinate $(x_a, y_a)$ and circle $B$ with radius $r_b$ and with central coordinate $(x_b, y_b)$.
Write a program which prints:
""2"" if $B$ is in $A$,
""-2"" if $A$ is in $B$,
""1"" if circumference of $A$ and $B$ intersect, and
""0"" if $A$ and $B$ do not overlap.
You may assume that $A$ and $B$ are not identical.
Input
The input consists of multiple datasets. The first line consists of an integer $N$ ($N \leq 50$), the number of datasets. There will be $N$ lines where each line represents each dataset. Each data set consists of real numbers:
$x_a$ $y_a$ $r_a$ $x_b$ $y_b$ $r_b$
Output
For each dataset, print 2, -2, 1, or 0 in a line.
Sample Input
2
0.0 0.0 5.0 0.0 0.0 4.0
0.0 0.0 2.0 4.1 0.0 2.0
Output for the Sample Input
2
0",Java,"import java.util.Scanner;

class Main {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int n = sc.nextInt();
        while (n-- > 0) {
            Circle a = new Circle(sc.nextDouble(), sc.nextDouble(), sc.nextDouble());
            Circle b = new Circle(sc.nextDouble(), sc.nextDouble(), sc.nextDouble());
            double dx = b.x - a.x;
            double dy = b.y - a.y;
            double r = a.r + b.r;
            double d = Math.sqrt(dx * dx + dy * dy);
            if (d > r) {
                System.out.println(0);
            } else {
                if (a.r < b.r && d + a.r < b.r) {
                    System.out.println(-2);
                } else if (a.r > b.r && d + b.r < a.r) {
                    System.out.println(2);
                } else {
                    System.out.println(1);
                }
            }
        }
    }

    static class Circle {
        double x;
        double y;
        double r;

        Circle(double x, double y, double r) {
            this.x = x;
            this.y = y;
            this.r = r;
        }
    }
}


",1
p00023,"Circles Intersection
You are given circle $A$ with radius $r_a$ and with central coordinate $(x_a, y_a)$ and circle $B$ with radius $r_b$ and with central coordinate $(x_b, y_b)$.
Write a program which prints:
""2"" if $B$ is in $A$,
""-2"" if $A$ is in $B$,
""1"" if circumference of $A$ and $B$ intersect, and
""0"" if $A$ and $B$ do not overlap.
You may assume that $A$ and $B$ are not identical.
Input
The input consists of multiple datasets. The first line consists of an integer $N$ ($N \leq 50$), the number of datasets. There will be $N$ lines where each line represents each dataset. Each data set consists of real numbers:
$x_a$ $y_a$ $r_a$ $x_b$ $y_b$ $r_b$
Output
For each dataset, print 2, -2, 1, or 0 in a line.
Sample Input
2
0.0 0.0 5.0 0.0 0.0 4.0
0.0 0.0 2.0 4.1 0.0 2.0
Output for the Sample Input
2
0",Python,"import math

n = int(input())
for _ in range(n):
    xa, ya, ra, xb, yb, rb = map(float, input().split())
    
    # Calculate distance between centers
    d = math.sqrt((xa - xb)**2 + (ya - yb)**2)
    
    # Check if B is in A
    if d + rb <= ra:
        print(2)
    # Check if A is in B
    elif d + ra <= rb:
        print(-2)
    # Check if circles intersect
    elif d < ra + rb:
        print(1)
    # Circles do not overlap
    else:
        print(0)
",0
p00023,"Circles Intersection
You are given circle $A$ with radius $r_a$ and with central coordinate $(x_a, y_a)$ and circle $B$ with radius $r_b$ and with central coordinate $(x_b, y_b)$.
Write a program which prints:
""2"" if $B$ is in $A$,
""-2"" if $A$ is in $B$,
""1"" if circumference of $A$ and $B$ intersect, and
""0"" if $A$ and $B$ do not overlap.
You may assume that $A$ and $B$ are not identical.
Input
The input consists of multiple datasets. The first line consists of an integer $N$ ($N \leq 50$), the number of datasets. There will be $N$ lines where each line represents each dataset. Each data set consists of real numbers:
$x_a$ $y_a$ $r_a$ $x_b$ $y_b$ $r_b$
Output
For each dataset, print 2, -2, 1, or 0 in a line.
Sample Input
2
0.0 0.0 5.0 0.0 0.0 4.0
0.0 0.0 2.0 4.1 0.0 2.0
Output for the Sample Input
2
0",Python,"for a,b,r,c,d,s in[map(float,raw_input().split())for i in range(input())]:
	d=(a-c)**2+(b-d)**2
	if d>(r+s)**2:print 0
	elif d+min(r,s)>max(r,s):print 1
	elif r>s:print 2
	else:print -2",1
p00024,"Physical Experiments
Ignoring the air resistance, velocity of a freely falling object $v$ after $t$ seconds and its drop $y$ in $t$ seconds are represented by the following formulas:
$ v = 9.8 t $
$ y = 4.9 t^2 $
A person is trying to drop down a glass ball and check whether it will crack. Your task is to write a program to help this experiment.
You are given the  minimum velocity to crack the ball. Your program should print the lowest possible floor of a building to crack the ball. The height of the $N$ floor of the building is defined by $5 \times N - 5$.
Input
The input consists of multiple datasets. Each dataset, a line, consists of the minimum velocity
v
(0 <
v
< 200) to crack the ball. The value is given by a decimal fraction, with at most 4 digits after the decimal point. The input ends with EOF. The number of datasets is less than or equal to 50.
Output
For each dataset, print the lowest possible floor where the ball cracks.
Sample Input
25.4
25.4
Output for the Sample Input
8
8",C,"#include <stdio.h>
#include <math.h>

int main() {
    double v;
    while (scanf(""%lf"", &v) != EOF) {
        double t = v / 9.8;
        double y = 4.9 * t * t;
        int floor = (int)ceil((y + 5) / 5);
        printf(""%d\n"", floor);
    }
    return 0;
}
",0
p00024,"Physical Experiments
Ignoring the air resistance, velocity of a freely falling object $v$ after $t$ seconds and its drop $y$ in $t$ seconds are represented by the following formulas:
$ v = 9.8 t $
$ y = 4.9 t^2 $
A person is trying to drop down a glass ball and check whether it will crack. Your task is to write a program to help this experiment.
You are given the  minimum velocity to crack the ball. Your program should print the lowest possible floor of a building to crack the ball. The height of the $N$ floor of the building is defined by $5 \times N - 5$.
Input
The input consists of multiple datasets. Each dataset, a line, consists of the minimum velocity
v
(0 <
v
< 200) to crack the ball. The value is given by a decimal fraction, with at most 4 digits after the decimal point. The input ends with EOF. The number of datasets is less than or equal to 50.
Output
For each dataset, print the lowest possible floor where the ball cracks.
Sample Input
25.4
25.4
Output for the Sample Input
8
8",C,"#include <stdio.h>
#include <math.h>

int main(){
	float v,t,y;
	while(scanf(""%f"",&v) != EOF){
		t = v / 9.8;
		y = t * t * 4.9;
		printf(""%d\n"",(int)ceilf(y / 5.0) + 1);
	}
	return 0;
}",1
p00024,"Physical Experiments
Ignoring the air resistance, velocity of a freely falling object $v$ after $t$ seconds and its drop $y$ in $t$ seconds are represented by the following formulas:
$ v = 9.8 t $
$ y = 4.9 t^2 $
A person is trying to drop down a glass ball and check whether it will crack. Your task is to write a program to help this experiment.
You are given the  minimum velocity to crack the ball. Your program should print the lowest possible floor of a building to crack the ball. The height of the $N$ floor of the building is defined by $5 \times N - 5$.
Input
The input consists of multiple datasets. Each dataset, a line, consists of the minimum velocity
v
(0 <
v
< 200) to crack the ball. The value is given by a decimal fraction, with at most 4 digits after the decimal point. The input ends with EOF. The number of datasets is less than or equal to 50.
Output
For each dataset, print the lowest possible floor where the ball cracks.
Sample Input
25.4
25.4
Output for the Sample Input
8
8",Java,"import java.util.Scanner;

public class Main {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        
        while (sc.hasNext()) {
            double v = sc.nextDouble();
            
            // From v = 9.8t, we get t = v / 9.8
            double t = v / 9.8;
            
            // Drop distance y = 4.9 * t^2
            double y = 4.9 * t * t;
            
            // Height of floor N is 5*N - 5
            // We need to find smallest N such that 5*N - 5 >= y
            // 5*N >= y + 5
            // N >= (y + 5) / 5
            
            int floor = (int) Math.ceil((y + 5) / 5.0);
            
            System.out.println(floor);
        }
        
        sc.close();
    }
}
",0
p00024,"Physical Experiments
Ignoring the air resistance, velocity of a freely falling object $v$ after $t$ seconds and its drop $y$ in $t$ seconds are represented by the following formulas:
$ v = 9.8 t $
$ y = 4.9 t^2 $
A person is trying to drop down a glass ball and check whether it will crack. Your task is to write a program to help this experiment.
You are given the  minimum velocity to crack the ball. Your program should print the lowest possible floor of a building to crack the ball. The height of the $N$ floor of the building is defined by $5 \times N - 5$.
Input
The input consists of multiple datasets. Each dataset, a line, consists of the minimum velocity
v
(0 <
v
< 200) to crack the ball. The value is given by a decimal fraction, with at most 4 digits after the decimal point. The input ends with EOF. The number of datasets is less than or equal to 50.
Output
For each dataset, print the lowest possible floor where the ball cracks.
Sample Input
25.4
25.4
Output for the Sample Input
8
8",Java,"import java.util.*;

public class Main {
	Scanner sc = new Scanner(System.in);
	void doIt() {
		while(true){
			try{
				double v = sc.nextDouble();
				double t = v / 9.8;
				double y = 4.9 * t * t;
				int ans = (int) y / 5;
				double cnt = y % 5;
				if(cnt > 0){
					ans++;
					System.out.println(ans);
				}else{
					System.out.println(ans);
				}
			}catch(Exception g){
				System.exit(0);
			}
		}
	}
    public static void main(String[] args) {
    	new Main().doIt();
    }
}",1
p00024,"Physical Experiments
Ignoring the air resistance, velocity of a freely falling object $v$ after $t$ seconds and its drop $y$ in $t$ seconds are represented by the following formulas:
$ v = 9.8 t $
$ y = 4.9 t^2 $
A person is trying to drop down a glass ball and check whether it will crack. Your task is to write a program to help this experiment.
You are given the  minimum velocity to crack the ball. Your program should print the lowest possible floor of a building to crack the ball. The height of the $N$ floor of the building is defined by $5 \times N - 5$.
Input
The input consists of multiple datasets. Each dataset, a line, consists of the minimum velocity
v
(0 <
v
< 200) to crack the ball. The value is given by a decimal fraction, with at most 4 digits after the decimal point. The input ends with EOF. The number of datasets is less than or equal to 50.
Output
For each dataset, print the lowest possible floor where the ball cracks.
Sample Input
25.4
25.4
Output for the Sample Input
8
8",Python,"import sys
import math

for line in sys.stdin:
    v = float(line.strip())
    
    # From v = 9.8 * t, we get t = v / 9.8
    t = v / 9.8
    
    # From y = 4.9 * t^2
    y = 4.9 * t * t
    
    # Height of floor N is 5*N - 5
    # We need 5*N - 5 >= y
    # 5*N >= y + 5
    # N >= (y + 5) / 5
    
    N = math.ceil((y + 5) / 5)
    
    print(N)
",0
p00024,"Physical Experiments
Ignoring the air resistance, velocity of a freely falling object $v$ after $t$ seconds and its drop $y$ in $t$ seconds are represented by the following formulas:
$ v = 9.8 t $
$ y = 4.9 t^2 $
A person is trying to drop down a glass ball and check whether it will crack. Your task is to write a program to help this experiment.
You are given the  minimum velocity to crack the ball. Your program should print the lowest possible floor of a building to crack the ball. The height of the $N$ floor of the building is defined by $5 \times N - 5$.
Input
The input consists of multiple datasets. Each dataset, a line, consists of the minimum velocity
v
(0 <
v
< 200) to crack the ball. The value is given by a decimal fraction, with at most 4 digits after the decimal point. The input ends with EOF. The number of datasets is less than or equal to 50.
Output
For each dataset, print the lowest possible floor where the ball cracks.
Sample Input
25.4
25.4
Output for the Sample Input
8
8",Python,"import sys
import math
v=[]
for line in sys.stdin:
    v.append(float(line))
for i in range(len(v)):
    print math.ceil(v[i]**2/98+1),",1
p00025,"Hit and Blow
Let's play Hit and Blow game.
A
imagines four numbers and
B
guesses the numbers. After
B
picks out four numbers,
A
answers:
The number of numbers which have the same place with numbers
A
imagined (Hit)
The number of numbers included (but different place) in the numbers
A
imagined (Blow)
For example, if
A
imagined numbers:
9 1 8 2
and
B
chose:
4 1 5 9
A
should say 1 Hit and 1 Blow.
Write a program which reads four numbers
A
imagined and four numbers
B
chose and prints the number of Hit and Blow respectively. You may assume that the four numbers are all different and within from 0 to 9.
Input
The input consists of multiple datasets. Each dataset set consists of:
a
1
a
2
a
3
a
4
b
1
b
2
b
3
b
4
, where
a
i
(0 ≤
a
i
≤ 9) is
i
-th number
A
imagined and
b
i
(0 ≤
b
i
≤ 9) is
i
-th number
B
chose.
The input ends with EOF. The number of datasets is less than or equal to 50.
Output
For each dataset, print the number of Hit and Blow in a line. These two numbers should be separated by a space.
Sample Input
9 1 8 2
4 1 5 9
4 6 8 2
4 6 3 2
Output for the Sample Input
1 1
3 0",C,"#include <stdio.h>

int main() {
    int a[4], b[4];
    
    while(scanf(""%d %d %d %d"", &a[0], &a[1], &a[2], &a[3]) != EOF) {
        scanf(""%d %d %d %d"", &b[0], &b[1], &b[2], &b[3]);
        
        int hit = 0, blow = 0;
        
        // Count hits
        for(int i = 0; i < 4; i++) {
            if(a[i] == b[i]) {
                hit++;
            }
        }
        
        // Count blows
        for(int i = 0; i < 4; i++) {
            for(int j = 0; j < 4; j++) {
                if(i != j && a[i] == b[j]) {
                    blow++;
                }
            }
        }
        
        printf(""%d %d\n"", hit, blow);
    }
    
    return 0;
}
",0
p00025,"Hit and Blow
Let's play Hit and Blow game.
A
imagines four numbers and
B
guesses the numbers. After
B
picks out four numbers,
A
answers:
The number of numbers which have the same place with numbers
A
imagined (Hit)
The number of numbers included (but different place) in the numbers
A
imagined (Blow)
For example, if
A
imagined numbers:
9 1 8 2
and
B
chose:
4 1 5 9
A
should say 1 Hit and 1 Blow.
Write a program which reads four numbers
A
imagined and four numbers
B
chose and prints the number of Hit and Blow respectively. You may assume that the four numbers are all different and within from 0 to 9.
Input
The input consists of multiple datasets. Each dataset set consists of:
a
1
a
2
a
3
a
4
b
1
b
2
b
3
b
4
, where
a
i
(0 ≤
a
i
≤ 9) is
i
-th number
A
imagined and
b
i
(0 ≤
b
i
≤ 9) is
i
-th number
B
chose.
The input ends with EOF. The number of datasets is less than or equal to 50.
Output
For each dataset, print the number of Hit and Blow in a line. These two numbers should be separated by a space.
Sample Input
9 1 8 2
4 1 5 9
4 6 8 2
4 6 3 2
Output for the Sample Input
1 1
3 0",C,"#include <stdio.h>

int main(){
	int A[4], B[4];
	int a, b;
	int hit, blow;

	while( scanf(""%d%d%d%d"",&A[0],&A[1],&A[2],&A[3]) != EOF ){
		scanf(""%d%d%d%d"",&B[0],&B[1],&B[2],&B[3]);

		hit=blow=0;

		for( a=0; a<4; a++ ){
			for( b=0; b<4; b++ ){
				if( A[a] == B[b] ){
					(a==b)? hit++ : blow++;
				}
			}
		}

		printf(""%d %d\n"", hit, blow);
	}

	return 0;
}
	",1
p00025,"Hit and Blow
Let's play Hit and Blow game.
A
imagines four numbers and
B
guesses the numbers. After
B
picks out four numbers,
A
answers:
The number of numbers which have the same place with numbers
A
imagined (Hit)
The number of numbers included (but different place) in the numbers
A
imagined (Blow)
For example, if
A
imagined numbers:
9 1 8 2
and
B
chose:
4 1 5 9
A
should say 1 Hit and 1 Blow.
Write a program which reads four numbers
A
imagined and four numbers
B
chose and prints the number of Hit and Blow respectively. You may assume that the four numbers are all different and within from 0 to 9.
Input
The input consists of multiple datasets. Each dataset set consists of:
a
1
a
2
a
3
a
4
b
1
b
2
b
3
b
4
, where
a
i
(0 ≤
a
i
≤ 9) is
i
-th number
A
imagined and
b
i
(0 ≤
b
i
≤ 9) is
i
-th number
B
chose.
The input ends with EOF. The number of datasets is less than or equal to 50.
Output
For each dataset, print the number of Hit and Blow in a line. These two numbers should be separated by a space.
Sample Input
9 1 8 2
4 1 5 9
4 6 8 2
4 6 3 2
Output for the Sample Input
1 1
3 0",Java,"import java.util.Scanner;

public class Main {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        
        while (sc.hasNext()) {
            int[] a = new int[4];
            int[] b = new int[4];
            
            for (int i = 0; i < 4; i++) {
                a[i] = sc.nextInt();
            }
            for (int i = 0; i < 4; i++) {
                b[i] = sc.nextInt();
            }
            
            int hit = 0;
            int blow = 0;
            
            for (int i = 0; i < 4; i++) {
                if (a[i] == b[i]) {
                    hit++;
                } else {
                    for (int j = 0; j < 4; j++) {
                        if (i != j && a[i] == b[j]) {
                            blow++;
                            break;
                        }
                    }
                }
            }
            
            System.out.println(hit + "" "" + blow);
        }
        
        sc.close();
    }
}
",0
p00025,"Hit and Blow
Let's play Hit and Blow game.
A
imagines four numbers and
B
guesses the numbers. After
B
picks out four numbers,
A
answers:
The number of numbers which have the same place with numbers
A
imagined (Hit)
The number of numbers included (but different place) in the numbers
A
imagined (Blow)
For example, if
A
imagined numbers:
9 1 8 2
and
B
chose:
4 1 5 9
A
should say 1 Hit and 1 Blow.
Write a program which reads four numbers
A
imagined and four numbers
B
chose and prints the number of Hit and Blow respectively. You may assume that the four numbers are all different and within from 0 to 9.
Input
The input consists of multiple datasets. Each dataset set consists of:
a
1
a
2
a
3
a
4
b
1
b
2
b
3
b
4
, where
a
i
(0 ≤
a
i
≤ 9) is
i
-th number
A
imagined and
b
i
(0 ≤
b
i
≤ 9) is
i
-th number
B
chose.
The input ends with EOF. The number of datasets is less than or equal to 50.
Output
For each dataset, print the number of Hit and Blow in a line. These two numbers should be separated by a space.
Sample Input
9 1 8 2
4 1 5 9
4 6 8 2
4 6 3 2
Output for the Sample Input
1 1
3 0",Java,"import java.util.*;

public class Main {

	private void doit() {
		Scanner sc = new Scanner(System.in);
		while(sc.hasNext()){
			int [] a = new int[4];
			int [] b = new int[4];
			for(int i = 0; i < 4; i++){
				a[i] = sc.nextInt();
			}
			for(int i =0; i < 4; i++){
				b[i] = sc.nextInt();
			}
			int hit=0;
			int blow = 0;
			for(int i =0; i < 4; i++){
				for(int j =i; j < 4; j++){
					if(a[i] == b[j]){
						if(i == j)
							hit++;
						else{
							blow++;
						}
					}
				}
			}
			System.out.println(hit + "" "" + blow);
		}
	}

	public static void main(String[] args) {
		Main obj = new Main();
		obj.doit();
	}
}",1
p00025,"Hit and Blow
Let's play Hit and Blow game.
A
imagines four numbers and
B
guesses the numbers. After
B
picks out four numbers,
A
answers:
The number of numbers which have the same place with numbers
A
imagined (Hit)
The number of numbers included (but different place) in the numbers
A
imagined (Blow)
For example, if
A
imagined numbers:
9 1 8 2
and
B
chose:
4 1 5 9
A
should say 1 Hit and 1 Blow.
Write a program which reads four numbers
A
imagined and four numbers
B
chose and prints the number of Hit and Blow respectively. You may assume that the four numbers are all different and within from 0 to 9.
Input
The input consists of multiple datasets. Each dataset set consists of:
a
1
a
2
a
3
a
4
b
1
b
2
b
3
b
4
, where
a
i
(0 ≤
a
i
≤ 9) is
i
-th number
A
imagined and
b
i
(0 ≤
b
i
≤ 9) is
i
-th number
B
chose.
The input ends with EOF. The number of datasets is less than or equal to 50.
Output
For each dataset, print the number of Hit and Blow in a line. These two numbers should be separated by a space.
Sample Input
9 1 8 2
4 1 5 9
4 6 8 2
4 6 3 2
Output for the Sample Input
1 1
3 0",Python,"import sys

for line in sys.stdin:
    numbers = list(map(int, line.split()))
    if len(numbers) < 8:
        continue
    
    a = numbers[:4]
    b = numbers[4:8]
    
    hit = 0
    blow = 0
    
    for i in range(4):
        if a[i] == b[i]:
            hit += 1
        elif b[i] in a:
            blow += 1
    
    print(hit, blow)
",0
p00025,"Hit and Blow
Let's play Hit and Blow game.
A
imagines four numbers and
B
guesses the numbers. After
B
picks out four numbers,
A
answers:
The number of numbers which have the same place with numbers
A
imagined (Hit)
The number of numbers included (but different place) in the numbers
A
imagined (Blow)
For example, if
A
imagined numbers:
9 1 8 2
and
B
chose:
4 1 5 9
A
should say 1 Hit and 1 Blow.
Write a program which reads four numbers
A
imagined and four numbers
B
chose and prints the number of Hit and Blow respectively. You may assume that the four numbers are all different and within from 0 to 9.
Input
The input consists of multiple datasets. Each dataset set consists of:
a
1
a
2
a
3
a
4
b
1
b
2
b
3
b
4
, where
a
i
(0 ≤
a
i
≤ 9) is
i
-th number
A
imagined and
b
i
(0 ≤
b
i
≤ 9) is
i
-th number
B
chose.
The input ends with EOF. The number of datasets is less than or equal to 50.
Output
For each dataset, print the number of Hit and Blow in a line. These two numbers should be separated by a space.
Sample Input
9 1 8 2
4 1 5 9
4 6 8 2
4 6 3 2
Output for the Sample Input
1 1
3 0",Python,"import sys
for i in sys.stdin:
    arrA,arrB = [],[]
    s = i.split()
    for i in s:
        arrA.append(int(i))
    s = input().split()
    for i in s:
        arrB.append(int(i))
    h,b = 0,0
    for i in range(len(arrA)):
        if arrA[i] == arrB[i]:
            h += 1
        else:
            if arrB.count(arrA[i]) > 0:
                b += 1
    print(h,b)",1
p00026,"Dropping Ink
As shown in the following figure, there is a paper consisting of a grid structure where each cell is indicated by (
x
,
y
) coordinate system.
We are going to put drops of ink on the paper. A drop comes in three different sizes: Large, Medium, and Small. From the point of fall, the ink sinks into surrounding cells as shown in the figure depending on its size. In the figure, a star denotes the point of fall and a circle denotes the surrounding cells.
Originally, the paper is white that means for each cell the value of density is 0. The value of density is increased by 1 when the ink sinks into the corresponding cells.

For example, if we put a drop of Small ink at (1, 2) and a drop of Medium ink at (3, 2), the ink will sink as shown in the following figure (left side):
In the figure, density values of empty cells are 0. The ink sinking into out of the paper should be ignored as shown in the figure (top side). We can put several drops of ink at the same point.
Your task is to write a program which reads a sequence of points of fall (
x
,
y
) with its size (Small = 1, Medium = 2, Large = 3), and prints the number of cells whose density value is 0. The program must also print the maximum value of density.
You may assume that the paper always consists of 10 × 10, and 0 ≤
x
< 10, 0 ≤
y
< 10.
Input
x
1
,
y
1
,
s
1
x
2
,
y
2
,
s
2
:
  :
(
x
i
,
y
i
) represents the position of the
i
-th drop and
s
i
denotes its size. The number of drops is less than or equal to 50.
Output
Print the number of cells whose density value is 0 in first line.
Print the maximum value of density in the second line.
Sample Input
2,5,3
3,6,1
3,4,2
4,5,2
3,6,3
2,4,1
Output for the Sample Input
77
5",C,"#include <stdio.h>
#include <string.h>

int main() {
    int grid[10][10];
    memset(grid, 0, sizeof(grid));
    
    int x, y, s;
    while (scanf(""%d,%d,%d"", &x, &y, &s) == 3) {
        // Small (s=1): only center point
        if (s == 1) {
            grid[y][x]++;
        }
        // Medium (s=2): center + adjacent (up, down, left, right)
        else if (s == 2) {
            grid[y][x]++;
            if (y > 0) grid[y-1][x]++;
            if (y < 9) grid[y+1][x]++;
            if (x > 0) grid[y][x-1]++;
            if (x < 9) grid[y][x+1]++;
        }
        // Large (s=3): center + all 8 surrounding cells + distance 2 in 4 directions
        else if (s == 3) {
            grid[y][x]++;
            // 8 surrounding cells
            if (y > 0) grid[y-1][x]++;
            if (y < 9) grid[y+1][x]++;
            if (x > 0) grid[y][x-1]++;
            if (x < 9) grid[y][x+1]++;
            if (y > 0 && x > 0) grid[y-1][x-1]++;
            if (y > 0 && x < 9) grid[y-1][x+1]++;
            if (y < 9 && x > 0) grid[y+1][x-1]++;
            if (y < 9 && x < 9) grid[y+1][x+1]++;
            // distance 2 in 4 directions
            if (y > 1) grid[y-2][x]++;
            if (y < 8) grid[y+2][x]++;
            if (x > 1) grid[y][x-2]++;
            if (x < 8) grid[y][x+2]++;
        }
    }
    
    int zero_count = 0;
    int max_density = 0;
    
    for (int i = 0; i < 10; i++) {
        for (int j = 0; j < 10; j++) {
            if (grid[i][j] == 0) {
                zero_count++;
            }
            if (grid[i][j] > max_density) {
                max_density = grid[i][j];
            }
        }
    }
    
    printf(""%d\n"", zero_count);
    printf(""%d\n"", max_density);
    
    return 0;
}
",0
p00026,"Dropping Ink
As shown in the following figure, there is a paper consisting of a grid structure where each cell is indicated by (
x
,
y
) coordinate system.
We are going to put drops of ink on the paper. A drop comes in three different sizes: Large, Medium, and Small. From the point of fall, the ink sinks into surrounding cells as shown in the figure depending on its size. In the figure, a star denotes the point of fall and a circle denotes the surrounding cells.
Originally, the paper is white that means for each cell the value of density is 0. The value of density is increased by 1 when the ink sinks into the corresponding cells.

For example, if we put a drop of Small ink at (1, 2) and a drop of Medium ink at (3, 2), the ink will sink as shown in the following figure (left side):
In the figure, density values of empty cells are 0. The ink sinking into out of the paper should be ignored as shown in the figure (top side). We can put several drops of ink at the same point.
Your task is to write a program which reads a sequence of points of fall (
x
,
y
) with its size (Small = 1, Medium = 2, Large = 3), and prints the number of cells whose density value is 0. The program must also print the maximum value of density.
You may assume that the paper always consists of 10 × 10, and 0 ≤
x
< 10, 0 ≤
y
< 10.
Input
x
1
,
y
1
,
s
1
x
2
,
y
2
,
s
2
:
  :
(
x
i
,
y
i
) represents the position of the
i
-th drop and
s
i
denotes its size. The number of drops is less than or equal to 50.
Output
Print the number of cells whose density value is 0 in first line.
Print the maximum value of density in the second line.
Sample Input
2,5,3
3,6,1
3,4,2
4,5,2
3,6,3
2,4,1
Output for the Sample Input
77
5",C,"#include <stdio.h>

void fact(int ,int, int);
void count(void);

int a[10][10],i,j;

int main(){
  int x,y,size;

  for(i = 0 ; i < 10 ; i++){
    for(j = 0 ; j < 10 ; j++){
      a[i][j] = 0;
    }
  }
  while(scanf(""%d,%d,%d"",&x,&y,&size) != 3){
    fact(x,y,size);
  }
  count();
  return 0;
}
void fact(int x, int y, int size){
  int size1[2] = {1,-1};
  int size2[2] = {2,-2};

  a[y][x] += 1;
  if(size == 1){
    for(i = 0 ; i < 2 ; i++){
      if(x+size1[i] >= 0 || x+size1[i] <= 10)
	a[y][x+size1[i]] += 1;
      if(y+size1[i] >= 0 || y+size1[i] <= 10)
	a[y+size1[i]][x] += 1;
    }
  }
  if(size == 2){
    for(i = 0 ; i < 2 ; i++){
      for(j = 0 ; j < 2 ; j++){
	if(x+size1[i] >= 0 || x+size1[i] <= 10 || y+size1[i] >= 0 || y+size1[i] <= 10)
	  a[y+size1[i]][x+size1[j]] += 1;
      }
    }
    for(i = 0 ; i < 2 ; i++){
      if(x+size1[i] >= 0 || x+size1[i] <= 10)
	a[y][x+size1[i]] += 1;
      if(y+size1[i] >= 0 || y+size1[i] <= 10)
	a[y+size1[i]][x] += 1;
    }
  }
  if(size == 3){
    for(i = 0 ; i < 2 ; i++){
      for(j = 0 ; j < 2 ; j++){
	if(x+size1[i] >= 0 || x+size1[i] <= 10 || y+size1[i] >= 0 || y+size1[i] <= 10)
	  a[y+size1[i]][x+size1[j]] += 1;
      }
    }
    for(i = 0 ; i < 2 ; i++){
      if(x+size1[i] >= 0 || x+size1[i] <= 10)
	a[y][x+size1[i]] += 1;
      if(y+size1[i] >= 0 || y+size1[i] <= 10)
	a[y+size1[i]][x] += 1;
    }
    for(i = 0 ; i < 2 ; i++){
      if(x+size2[i] >= 0 || x+size2[i] <= 10)
	a[y][x+size2[i]] += 1;
      if(y+size2[i] >= 0 || y+size2[i] <= 10)
	a[y+size2[i]][x] += 1;
    }
  }
}
void count(void){
  int sum = 0,x = 0;

  for(i = 0 ; i < 10 ; i++){
    for(j = 0 ; j < 10 ; j++){
      if(a[i][j] == 0)
	sum++;
      else if(x < a[i][j])
	x++;
    }
  }
  printf(""%d\n%d\n"",sum,x);
}",1
p00026,"Dropping Ink
As shown in the following figure, there is a paper consisting of a grid structure where each cell is indicated by (
x
,
y
) coordinate system.
We are going to put drops of ink on the paper. A drop comes in three different sizes: Large, Medium, and Small. From the point of fall, the ink sinks into surrounding cells as shown in the figure depending on its size. In the figure, a star denotes the point of fall and a circle denotes the surrounding cells.
Originally, the paper is white that means for each cell the value of density is 0. The value of density is increased by 1 when the ink sinks into the corresponding cells.

For example, if we put a drop of Small ink at (1, 2) and a drop of Medium ink at (3, 2), the ink will sink as shown in the following figure (left side):
In the figure, density values of empty cells are 0. The ink sinking into out of the paper should be ignored as shown in the figure (top side). We can put several drops of ink at the same point.
Your task is to write a program which reads a sequence of points of fall (
x
,
y
) with its size (Small = 1, Medium = 2, Large = 3), and prints the number of cells whose density value is 0. The program must also print the maximum value of density.
You may assume that the paper always consists of 10 × 10, and 0 ≤
x
< 10, 0 ≤
y
< 10.
Input
x
1
,
y
1
,
s
1
x
2
,
y
2
,
s
2
:
  :
(
x
i
,
y
i
) represents the position of the
i
-th drop and
s
i
denotes its size. The number of drops is less than or equal to 50.
Output
Print the number of cells whose density value is 0 in first line.
Print the maximum value of density in the second line.
Sample Input
2,5,3
3,6,1
3,4,2
4,5,2
3,6,3
2,4,1
Output for the Sample Input
77
5",Java,"import java.util.Scanner;

public class Main {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int[][] paper = new int[10][10];
        
        while (sc.hasNext()) {
            String line = sc.nextLine();
            String[] parts = line.split("","");
            int x = Integer.parseInt(parts[0]);
            int y = Integer.parseInt(parts[1]);
            int size = Integer.parseInt(parts[2]);
            
            dropInk(paper, x, y, size);
        }
        
        int zeroCells = 0;
        int maxDensity = 0;
        
        for (int i = 0; i < 10; i++) {
            for (int j = 0; j < 10; j++) {
                if (paper[i][j] == 0) {
                    zeroCells++;
                }
                maxDensity = Math.max(maxDensity, paper[i][j]);
            }
        }
        
        System.out.println(zeroCells);
        System.out.println(maxDensity);
        
        sc.close();
    }
    
    static void dropInk(int[][] paper, int x, int y, int size) {
        if (size == 1) {
            // Small: only center
            if (isValid(x, y)) {
                paper[y][x]++;
            }
        } else if (size == 2) {
            // Medium: cross pattern with radius 1
            int[][] offsets = {
                {0, 0},
                {-1, 0}, {1, 0}, {0, -1}, {0, 1}
            };
            for (int[] offset : offsets) {
                int nx = x + offset[0];
                int ny = y + offset[1];
                if (isValid(nx, ny)) {
                    paper[ny][nx]++;
                }
            }
        } else if (size == 3) {
            // Large: diamond pattern with radius 2
            int[][] offsets = {
                {0, 0},
                {-1, 0}, {1, 0}, {0, -1}, {0, 1},
                {-2, 0}, {2, 0}, {0, -2}, {0, 2},
                {-1, -1}, {-1, 1}, {1, -1}, {1, 1}
            };
            for (int[] offset : offsets) {
                int nx = x + offset[0];
                int ny = y + offset[1];
                if (isValid(nx, ny)) {
                    paper[ny][nx]++;
                }
            }
        }
    }
    
    static boolean isValid(int x, int y) {
        return x >= 0 && x < 10 && y >= 0 && y < 10;
    }
}
",0
p00026,"Dropping Ink
As shown in the following figure, there is a paper consisting of a grid structure where each cell is indicated by (
x
,
y
) coordinate system.
We are going to put drops of ink on the paper. A drop comes in three different sizes: Large, Medium, and Small. From the point of fall, the ink sinks into surrounding cells as shown in the figure depending on its size. In the figure, a star denotes the point of fall and a circle denotes the surrounding cells.
Originally, the paper is white that means for each cell the value of density is 0. The value of density is increased by 1 when the ink sinks into the corresponding cells.

For example, if we put a drop of Small ink at (1, 2) and a drop of Medium ink at (3, 2), the ink will sink as shown in the following figure (left side):
In the figure, density values of empty cells are 0. The ink sinking into out of the paper should be ignored as shown in the figure (top side). We can put several drops of ink at the same point.
Your task is to write a program which reads a sequence of points of fall (
x
,
y
) with its size (Small = 1, Medium = 2, Large = 3), and prints the number of cells whose density value is 0. The program must also print the maximum value of density.
You may assume that the paper always consists of 10 × 10, and 0 ≤
x
< 10, 0 ≤
y
< 10.
Input
x
1
,
y
1
,
s
1
x
2
,
y
2
,
s
2
:
  :
(
x
i
,
y
i
) represents the position of the
i
-th drop and
s
i
denotes its size. The number of drops is less than or equal to 50.
Output
Print the number of cells whose density value is 0 in first line.
Print the maximum value of density in the second line.
Sample Input
2,5,3
3,6,1
3,4,2
4,5,2
3,6,3
2,4,1
Output for the Sample Input
77
5",Java,"import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.Arrays;

public class Main {
	public static void main(String[] args) {
		BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
		int[] area = new int[10 * 10];

		String str;

		try {
			while ((str = br.readLine()) != null) {
				String strArray[] = str.split("","");
				int x = Integer.parseInt(strArray[0]);
				int y = Integer.parseInt(strArray[1]);
				int size = Integer.parseInt(strArray[2]);

				int point = y * 10 + x;

				switch (size) {
				case 3:
					if (x < 8)
						area[point + 2]++;
					if (x > 1)
						area[point - 2]++;
					if (y < 8)
						area[point + 20]++;
					if (y > 1)
						area[point - 20]++;
				case 2:
					// 左上
					if (x > 0 && y > 0)
						area[point - 11]++;
					// 右上
					if (x < 9 && y > 0)
						area[point - 9]++;
					// 左下
					if (y < 9 && x > 0)
						area[point + 9]++;
					// 右下
					if (y < 9 && x < 9)
						area[point + 11]++;
				case 1:
					if (x < 9)
						area[point + 1]++;
					if (x > 0)
						area[point - 1]++;
					if (y < 9)
						area[point + 10]++;
					if (y > 1)
						area[point - 10]++;
					area[point]++;
				}
			}
		} catch (NumberFormatException e) {
			// TODO 自動生成された catch ブロック
			e.printStackTrace();
		} catch (IOException e) {
			// TODO 自動生成された catch ブロック
			e.printStackTrace();
		}

		Arrays.sort(area);
		int blank = 0;
		for (int i = 0; i < 100; i++) {
			if (area[i] != 0) {
				blank = i;
				break;
			}
		}

		// System.out.println(Arrays.binarySearch(area, 1));
		System.out.println(blank);
		System.out.println(area[99]);
	}
}",1
p00026,"Dropping Ink
As shown in the following figure, there is a paper consisting of a grid structure where each cell is indicated by (
x
,
y
) coordinate system.
We are going to put drops of ink on the paper. A drop comes in three different sizes: Large, Medium, and Small. From the point of fall, the ink sinks into surrounding cells as shown in the figure depending on its size. In the figure, a star denotes the point of fall and a circle denotes the surrounding cells.
Originally, the paper is white that means for each cell the value of density is 0. The value of density is increased by 1 when the ink sinks into the corresponding cells.

For example, if we put a drop of Small ink at (1, 2) and a drop of Medium ink at (3, 2), the ink will sink as shown in the following figure (left side):
In the figure, density values of empty cells are 0. The ink sinking into out of the paper should be ignored as shown in the figure (top side). We can put several drops of ink at the same point.
Your task is to write a program which reads a sequence of points of fall (
x
,
y
) with its size (Small = 1, Medium = 2, Large = 3), and prints the number of cells whose density value is 0. The program must also print the maximum value of density.
You may assume that the paper always consists of 10 × 10, and 0 ≤
x
< 10, 0 ≤
y
< 10.
Input
x
1
,
y
1
,
s
1
x
2
,
y
2
,
s
2
:
  :
(
x
i
,
y
i
) represents the position of the
i
-th drop and
s
i
denotes its size. The number of drops is less than or equal to 50.
Output
Print the number of cells whose density value is 0 in first line.
Print the maximum value of density in the second line.
Sample Input
2,5,3
3,6,1
3,4,2
4,5,2
3,6,3
2,4,1
Output for the Sample Input
77
5",Python,"import sys

# Initialize 10x10 grid
grid = [[0 for _ in range(10)] for _ in range(10)]

# Define ink patterns for each size relative to drop point
# Size 1 (Small): just the center and 4 adjacent cells (cross pattern)
patterns = {
    1: [(0, 0), (0, 1), (0, -1), (1, 0), (-1, 0)],
    2: [(0, 0), (0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (1, -1), (-1, 1), (-1, -1), (0, 2), (0, -2), (2, 0), (-2, 0)],
    3: [(0, 0), (0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (1, -1), (-1, 1), (-1, -1), 
        (0, 2), (0, -2), (2, 0), (-2, 0), (1, 2), (1, -2), (-1, 2), (-1, -2), (2, 1), (2, -1), (-2, 1), (-2, -1),
        (0, 3), (0, -3), (3, 0), (-3, 0)]
}

# Read input and process drops
for line in sys.stdin:
    line = line.strip()
    if not line:
        continue
    parts = line.split(',')
    x = int(parts[0])
    y = int(parts[1])
    size = int(parts[2])
    
    # Apply ink pattern
    for dx, dy in patterns[size]:
        nx, ny = x + dx, y + dy
        if 0 <= nx < 10 and 0 <= ny < 10:
            grid[ny][nx] += 1

# Count cells with density 0 and find maximum density
zero_count = 0
max_density = 0

for row in grid:
    for cell in row:
        if cell == 0:
            zero_count += 1
        max_density = max(max_density, cell)

print(zero_count)
print(max_density)
",0
p00026,"Dropping Ink
As shown in the following figure, there is a paper consisting of a grid structure where each cell is indicated by (
x
,
y
) coordinate system.
We are going to put drops of ink on the paper. A drop comes in three different sizes: Large, Medium, and Small. From the point of fall, the ink sinks into surrounding cells as shown in the figure depending on its size. In the figure, a star denotes the point of fall and a circle denotes the surrounding cells.
Originally, the paper is white that means for each cell the value of density is 0. The value of density is increased by 1 when the ink sinks into the corresponding cells.

For example, if we put a drop of Small ink at (1, 2) and a drop of Medium ink at (3, 2), the ink will sink as shown in the following figure (left side):
In the figure, density values of empty cells are 0. The ink sinking into out of the paper should be ignored as shown in the figure (top side). We can put several drops of ink at the same point.
Your task is to write a program which reads a sequence of points of fall (
x
,
y
) with its size (Small = 1, Medium = 2, Large = 3), and prints the number of cells whose density value is 0. The program must also print the maximum value of density.
You may assume that the paper always consists of 10 × 10, and 0 ≤
x
< 10, 0 ≤
y
< 10.
Input
x
1
,
y
1
,
s
1
x
2
,
y
2
,
s
2
:
  :
(
x
i
,
y
i
) represents the position of the
i
-th drop and
s
i
denotes its size. The number of drops is less than or equal to 50.
Output
Print the number of cells whose density value is 0 in first line.
Print the maximum value of density in the second line.
Sample Input
2,5,3
3,6,1
3,4,2
4,5,2
3,6,3
2,4,1
Output for the Sample Input
77
5",Python,"class Cloth(object):
    cell = None
    x = 0
    y = 0
    def __init__(self, x, y):
        self.cell = list([list([0 for i in range(y)]) for i in range(x)])
        self.x = x
        self.y = y
    def check(self, x, y):
        try:
            self.cell[x][y] += 0
            return True
        except IndexError:
            return False
    def point(self, x, y):
        try:
            self.cell[x][y] += 1
        except IndexError:
            pass
    def small(self, x, y):
        if not self.check(x, y):
            return
        self.point(x, y + 1)
        self.point(x - 1, y)
        self.point(x, y)
        self.point(x + 1, y)
        self.point(x, y - 1)
    def medium(self, x, y):
        if not self.check(x, y):
            return
        self.small(x, y)
        self.point(x + 1, y + 1)
        self.point(x - 1, y + 1)
        self.point(x + 1, y - 1)
        self.point(x - 1, y - 1)
    def large(self, x, y):
        if not self.check(x, y):
            return
        self.medium(x, y)
        self.point(x, y + 2)
        self.point(x - 2, y)
        self.point(x + 2, y)
        self.point(x, y - 2)
cloth = Cloth(10, 10)
while True:
    try:
        (x, y, s) = map(lambda x:int(x)-1, raw_input().split(','))
        if s == 0:
            cloth.small(x, y)
        elif s == 1:
            cloth.medium(x, y)
        elif s == 2:
            cloth.large(x, y)
    except EOFError:
        break
print reduce(lambda x,y:x+y,map(lambda x:x.count(0),cloth.cell))
print max(map(max,cloth.cell))",1
p00027,"What day is today?
Your task is to write a program which reads a date (from 2004/1/1 to 2004/12/31) and prints the day of the date. Jan. 1, 2004, is Thursday. Note that 2004 is a leap year and we have Feb. 29.
Input
The input is a sequence of datasets. The end of the input is indicated by a line containing one zero. Each dataset consists of two integers
m
and
d
separated by a single space in a line. These integers respectively represent the month and the day.
The number of datasets is less than or equal to 50.
Output
For each dataset, print the day (please see the following words) in a line.
Monday
Tuesday
Wednesday
Thursday
Friday
Saturday
Sunday
Sample Input
1 1
2 29
0 0
Output for the Sample Input
Thursday
Sunday",C,"#include <stdio.h>

int main() {
    int days_in_month[] = {0, 31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};
    char *day_names[] = {""Thursday"", ""Friday"", ""Saturday"", ""Sunday"", ""Monday"", ""Tuesday"", ""Wednesday""};
    
    int m, d;
    while(1) {
        scanf(""%d %d"", &m, &d);
        if(m == 0 && d == 0) break;
        
        int total_days = 0;
        for(int i = 1; i < m; i++) {
            total_days += days_in_month[i];
        }
        total_days += d - 1;
        
        int day_index = total_days % 7;
        printf(""%s\n"", day_names[day_index]);
    }
    
    return 0;
}
",0
p00027,"What day is today?
Your task is to write a program which reads a date (from 2004/1/1 to 2004/12/31) and prints the day of the date. Jan. 1, 2004, is Thursday. Note that 2004 is a leap year and we have Feb. 29.
Input
The input is a sequence of datasets. The end of the input is indicated by a line containing one zero. Each dataset consists of two integers
m
and
d
separated by a single space in a line. These integers respectively represent the month and the day.
The number of datasets is less than or equal to 50.
Output
For each dataset, print the day (please see the following words) in a line.
Monday
Tuesday
Wednesday
Thursday
Friday
Saturday
Sunday
Sample Input
1 1
2 29
0 0
Output for the Sample Input
Thursday
Sunday",C,"#include <stdio.h>
 
int dayOfWeek(int year, int month, int day)
{
    if (month == 1 || month == 2) {
        year--;
        month += 12;
    }
    return (year + year / 4 - year / 100 + year / 400
        + (13 * month + 8) / 5 + day) % 7;
}
 
int main()
{
    int m, d;
    char *day[7] = {
        ""Sunday"", ""Monday"", ""Tuesday"", ""Wednesday"", ""Thursday"", ""Friday"", ""Saturday""
    };
     
    while (1) {
        scanf(""%d%d"", &m, &d);
        if (m == 0 || d == 0) break;
        puts(day[dayOfWeek(2004, m, d)]);
    }
    return 0;
}

",1
p00027,"What day is today?
Your task is to write a program which reads a date (from 2004/1/1 to 2004/12/31) and prints the day of the date. Jan. 1, 2004, is Thursday. Note that 2004 is a leap year and we have Feb. 29.
Input
The input is a sequence of datasets. The end of the input is indicated by a line containing one zero. Each dataset consists of two integers
m
and
d
separated by a single space in a line. These integers respectively represent the month and the day.
The number of datasets is less than or equal to 50.
Output
For each dataset, print the day (please see the following words) in a line.
Monday
Tuesday
Wednesday
Thursday
Friday
Saturday
Sunday
Sample Input
1 1
2 29
0 0
Output for the Sample Input
Thursday
Sunday",Java,"import java.util.Scanner;

public class Main {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        
        int[] daysInMonth = {0, 31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};
        String[] days = {""Thursday"", ""Friday"", ""Saturday"", ""Sunday"", ""Monday"", ""Tuesday"", ""Wednesday""};
        
        while (true) {
            int m = sc.nextInt();
            int d = sc.nextInt();
            
            if (m == 0 && d == 0) {
                break;
            }
            
            int totalDays = 0;
            for (int i = 1; i < m; i++) {
                totalDays += daysInMonth[i];
            }
            totalDays += d - 1;
            
            System.out.println(days[totalDays % 7]);
        }
        
        sc.close();
    }
}
",0
p00027,"What day is today?
Your task is to write a program which reads a date (from 2004/1/1 to 2004/12/31) and prints the day of the date. Jan. 1, 2004, is Thursday. Note that 2004 is a leap year and we have Feb. 29.
Input
The input is a sequence of datasets. The end of the input is indicated by a line containing one zero. Each dataset consists of two integers
m
and
d
separated by a single space in a line. These integers respectively represent the month and the day.
The number of datasets is less than or equal to 50.
Output
For each dataset, print the day (please see the following words) in a line.
Monday
Tuesday
Wednesday
Thursday
Friday
Saturday
Sunday
Sample Input
1 1
2 29
0 0
Output for the Sample Input
Thursday
Sunday",Java,"import java.util.*;
import java.lang.*;
import java.math.*;

public class Main {
	Scanner sc = new Scanner(System.in);
	void run(){
		int[] map={31,29,31,30,31,30,31,31,30,31,30,31};
		int[] dp = new int [12];
		String[] str ={
				""Monday"",
				""Tuesday"",
				""Wednesday"",
				""Thursday"",
				""Friday"",
				""Monday"",
				""Sunday"",
		};
		dp[0] = 2;
		for(int i=1; i <12;i++){
			dp[i] = (dp[i-1] + map[i-1] +2)%7;
		}
		for(;;){
			int m = sc.nextInt();
			int n = sc.nextInt();
			if((m|n)==0){
				break;
			}
			System.out.println(str[(dp[m-1]+n)%7]);
		}
	}
	public static void main(String[] args){
		Main m = new Main();
		m.run();
	}
}",1
p00027,"What day is today?
Your task is to write a program which reads a date (from 2004/1/1 to 2004/12/31) and prints the day of the date. Jan. 1, 2004, is Thursday. Note that 2004 is a leap year and we have Feb. 29.
Input
The input is a sequence of datasets. The end of the input is indicated by a line containing one zero. Each dataset consists of two integers
m
and
d
separated by a single space in a line. These integers respectively represent the month and the day.
The number of datasets is less than or equal to 50.
Output
For each dataset, print the day (please see the following words) in a line.
Monday
Tuesday
Wednesday
Thursday
Friday
Saturday
Sunday
Sample Input
1 1
2 29
0 0
Output for the Sample Input
Thursday
Sunday",Python,"days_of_week = [""Thursday"", ""Friday"", ""Saturday"", ""Sunday"", ""Monday"", ""Tuesday"", ""Wednesday""]
days_in_month = [0, 31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]

while True:
    line = input().split()
    m, d = int(line[0]), int(line[1])
    
    if m == 0 and d == 0:
        break
    
    total_days = 0
    for i in range(1, m):
        total_days += days_in_month[i]
    total_days += d - 1
    
    day_index = total_days % 7
    print(days_of_week[day_index])
",0
p00027,"What day is today?
Your task is to write a program which reads a date (from 2004/1/1 to 2004/12/31) and prints the day of the date. Jan. 1, 2004, is Thursday. Note that 2004 is a leap year and we have Feb. 29.
Input
The input is a sequence of datasets. The end of the input is indicated by a line containing one zero. Each dataset consists of two integers
m
and
d
separated by a single space in a line. These integers respectively represent the month and the day.
The number of datasets is less than or equal to 50.
Output
For each dataset, print the day (please see the following words) in a line.
Monday
Tuesday
Wednesday
Thursday
Friday
Saturday
Sunday
Sample Input
1 1
2 29
0 0
Output for the Sample Input
Thursday
Sunday",Python,"month, day = map(int, raw_input().split())
days = [31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]
youbi = [""Sunday"", ""Monday"", ""Tuesday"",
         ""Wednesday"", ""Thursday"", ""Friday"", ""Saturday""]
while month != 0:
    Days = 0
    for i in range(month - 1):
        Days += days[i]
    Days += day
    print youbi[Days % 7]
    month, day = map(int, raw_input().split())",1
p00028,"Mode Value
Your task is to write a program which reads a sequence of integers and prints mode values of the sequence.
The mode value is the element which occurs most frequently.
Input
A sequence of integers
a
i
(1 ≤
a
i
≤ 100). The number of integers is less than or equals to 100.
Output
Print the mode values. If there are several mode values, print them in ascending order.
Sample Input
5
6
3
5
8
7
5
3
9
7
3
4
Output for the Sample Input
3
5
For example, 3 and 5 respectively occur three times, 7 occurs two times, and others occur only one. So, the mode values are 3 and 5.",C,"#include <stdio.h>

int main() {
    int count[101] = {0};
    int num;
    int maxCount = 0;
    
    while (scanf(""%d"", &num) != EOF) {
        count[num]++;
        if (count[num] > maxCount) {
            maxCount = count[num];
        }
    }
    
    for (int i = 1; i <= 100; i++) {
        if (count[i] == maxCount) {
            printf(""%d\n"", i);
        }
    }
    
    return 0;
}
",0
p00028,"Mode Value
Your task is to write a program which reads a sequence of integers and prints mode values of the sequence.
The mode value is the element which occurs most frequently.
Input
A sequence of integers
a
i
(1 ≤
a
i
≤ 100). The number of integers is less than or equals to 100.
Output
Print the mode values. If there are several mode values, print them in ascending order.
Sample Input
5
6
3
5
8
7
5
3
9
7
3
4
Output for the Sample Input
3
5
For example, 3 and 5 respectively occur three times, 7 occurs two times, and others occur only one. So, the mode values are 3 and 5.",C,"#include <stdio.h>
#include <string.h>

int main()
{
  int countArray[101], number, mx_number = 0;
  memset(countArray, 0, sizeof countArray);

  while(scanf(""%d"", &number)!=EOF){
    ++countArray[number];
  }

  for(number = 100; number > 0; --number)
    if(countArray[number] > countArray[mx_number])
      mx_number = number;

  for(number = 1; number <= mx_number; ++number)
    if(countArray[number] == countArray[mx_number])
      printf(""%d\n"", number);

  return 0;
}",1
p00028,"Mode Value
Your task is to write a program which reads a sequence of integers and prints mode values of the sequence.
The mode value is the element which occurs most frequently.
Input
A sequence of integers
a
i
(1 ≤
a
i
≤ 100). The number of integers is less than or equals to 100.
Output
Print the mode values. If there are several mode values, print them in ascending order.
Sample Input
5
6
3
5
8
7
5
3
9
7
3
4
Output for the Sample Input
3
5
For example, 3 and 5 respectively occur three times, 7 occurs two times, and others occur only one. So, the mode values are 3 and 5.",Java,"import java.util.*;

public class Main {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        Map<Integer, Integer> count = new HashMap<>();
        
        while (sc.hasNextInt()) {
            int num = sc.nextInt();
            count.put(num, count.getOrDefault(num, 0) + 1);
        }
        
        int maxCount = 0;
        for (int c : count.values()) {
            maxCount = Math.max(maxCount, c);
        }
        
        List<Integer> modes = new ArrayList<>();
        for (Map.Entry<Integer, Integer> entry : count.entrySet()) {
            if (entry.getValue() == maxCount) {
                modes.add(entry.getKey());
            }
        }
        
        Collections.sort(modes);
        
        for (int mode : modes) {
            System.out.println(mode);
        }
        
        sc.close();
    }
}
",0
p00028,"Mode Value
Your task is to write a program which reads a sequence of integers and prints mode values of the sequence.
The mode value is the element which occurs most frequently.
Input
A sequence of integers
a
i
(1 ≤
a
i
≤ 100). The number of integers is less than or equals to 100.
Output
Print the mode values. If there are several mode values, print them in ascending order.
Sample Input
5
6
3
5
8
7
5
3
9
7
3
4
Output for the Sample Input
3
5
For example, 3 and 5 respectively occur three times, 7 occurs two times, and others occur only one. So, the mode values are 3 and 5.",Java,"import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.ArrayList;
import java.util.Collections;

public class Main {

	public static void main(String[] args) {
		// TODO 自動生成されたメソッド・スタブ
		
		BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
		String tmp = null;
		int cup = 0;
		int mun = 0;
		int ter = 0;
		String[] rrr;
		int st = 0,sr = 0;
		int mon = 0;
		ArrayList<Integer> al = new ArrayList<Integer>();
		
		while(true){
			
			try {
				tmp = br.readLine();
			} catch (IOException e) {
				// TODO 自動生成された catch ブロック
				e.printStackTrace();
			}
			
			if(tmp == null){
				break;
			}
			
			if(tmp.equals("""")){
				break;
			}
			
			al.add(Integer.parseInt(tmp));
		}
		
		//System.out.println(al.toString());
		Collections.sort(al);
		//System.out.println(al.toString());
		ArrayList<Integer> al2 = new ArrayList<Integer>();
		ArrayList<Integer> al3 = new ArrayList<Integer>();
		int tmpr = 0;
		
		for(int i=0;i<al.size();i++){
			if(tmpr ==0){
				al2.add(al.get(i));
			}
			if(al2.get(tmpr) < al.get(i)){
				tmpr++;
				al2.add(al.get(i));
			}
		}
		int aaa = 0;
		for(int i=0;i<al2.size();i++){
			tmpr = 0;
			for(int j=0;j<al.size();j++){
				if(al.get(j) == al2.get(i)){
					tmpr++;
				}
				al3.add(tmpr);
				if(aaa < tmpr){
					aaa = tmpr;
				}
			}
		}
		
		for(int i=0;i<al3.size();i++){
			if(aaa == al3.get(i)){
				System.out.println(al2.get(i));
			}
		}
		
		
		
	}

}",1
p00028,"Mode Value
Your task is to write a program which reads a sequence of integers and prints mode values of the sequence.
The mode value is the element which occurs most frequently.
Input
A sequence of integers
a
i
(1 ≤
a
i
≤ 100). The number of integers is less than or equals to 100.
Output
Print the mode values. If there are several mode values, print them in ascending order.
Sample Input
5
6
3
5
8
7
5
3
9
7
3
4
Output for the Sample Input
3
5
For example, 3 and 5 respectively occur three times, 7 occurs two times, and others occur only one. So, the mode values are 3 and 5.",Python,"import sys
from collections import Counter

numbers = []
for line in sys.stdin:
    numbers.append(int(line.strip()))

counter = Counter(numbers)
max_count = max(counter.values())
mode_values = sorted([num for num, count in counter.items() if count == max_count])

for val in mode_values:
    print(val)
",0
p00028,"Mode Value
Your task is to write a program which reads a sequence of integers and prints mode values of the sequence.
The mode value is the element which occurs most frequently.
Input
A sequence of integers
a
i
(1 ≤
a
i
≤ 100). The number of integers is less than or equals to 100.
Output
Print the mode values. If there are several mode values, print them in ascending order.
Sample Input
5
6
3
5
8
7
5
3
9
7
3
4
Output for the Sample Input
3
5
For example, 3 and 5 respectively occur three times, 7 occurs two times, and others occur only one. So, the mode values are 3 and 5.",Python,"num = [[0,i+1] for i in range(100)]
while True:
    try:
        num[int(input())-1][0] += 1
    except:
        num.sort(reverse = True)
        ans = []
        for i in range(100):
            if num[i][0] == num[0][0]:
                ans.append(num[i][1])
            else:
                ans.sort()
                for z in ans:
                    print(z)
                break
        break
",1
p00029,"English Sentence
Your task is to write a program which reads a text and prints two words. The first one is the word which is arise most frequently in the text. The second one is the word which has the maximum number of letters.
The text includes only alphabetical characters and spaces. A word is a sequence of letters which is separated by the spaces.
Input
A text is given in a line. You can assume the following conditions:
The number of letters in the text is less than or equal to 1000.
The number of letters in a word is less than or equal to 32.
There is only one word which is arise most frequently in given text.
There is only one word which has the maximum number of letters in given text.
Output
The two words separated by a space.
Sample Input
Thank you for your mail and your lectures
Output for the Sample Input
your lectures",C,"#include <stdio.h>
#include <string.h>
#include <ctype.h>

int main() {
    char text[1001];
    char words[100][33];
    int count[100] = {0};
    int wordCount = 0;
    
    fgets(text, sizeof(text), stdin);
    
    // Remove newline if present
    int len = strlen(text);
    if (len > 0 && text[len-1] == '\n') {
        text[len-1] = '\0';
    }
    
    // Parse words
    char *token = strtok(text, "" "");
    while (token != NULL) {
        int found = -1;
        for (int i = 0; i < wordCount; i++) {
            if (strcmp(words[i], token) == 0) {
                found = i;
                break;
            }
        }
        
        if (found != -1) {
            count[found]++;
        } else {
            strcpy(words[wordCount], token);
            count[wordCount] = 1;
            wordCount++;
        }
        
        token = strtok(NULL, "" "");
    }
    
    // Find most frequent word
    int maxCount = 0;
    int maxCountIndex = 0;
    for (int i = 0; i < wordCount; i++) {
        if (count[i] > maxCount) {
            maxCount = count[i];
            maxCountIndex = i;
        }
    }
    
    // Find longest word
    int maxLen = 0;
    int maxLenIndex = 0;
    for (int i = 0; i < wordCount; i++) {
        int len = strlen(words[i]);
        if (len > maxLen) {
            maxLen = len;
            maxLenIndex = i;
        }
    }
    
    printf(""%s %s\n"", words[maxCountIndex], words[maxLenIndex]);
    
    return 0;
}
",0
p00029,"English Sentence
Your task is to write a program which reads a text and prints two words. The first one is the word which is arise most frequently in the text. The second one is the word which has the maximum number of letters.
The text includes only alphabetical characters and spaces. A word is a sequence of letters which is separated by the spaces.
Input
A text is given in a line. You can assume the following conditions:
The number of letters in the text is less than or equal to 1000.
The number of letters in a word is less than or equal to 32.
There is only one word which is arise most frequently in given text.
There is only one word which has the maximum number of letters in given text.
Output
The two words separated by a space.
Sample Input
Thank you for your mail and your lectures
Output for the Sample Input
your lectures",C,"#include <stdio.h>
#include <string.h>

int main(void){
	int i=0,j,c,max=0,ans1=100,ans2=100,count=0;
	char s[1000][33]={0};
	char ch;
	
	while(1){
		scanf(""%c"",&ch);
		if(ch=='\n')break;
		if(ch==' '){
			count++;
			i=0;
		}
		s[count][i]=ch;
		if(max<1+i){
			max=i+1;
			ans2=count;
		}
		if(ch!=' ')i++;
	}
	max=0;
	for(i=0;i<count;i++){
		for(j=i+1,c=0;j<count;j++){
			if(strcmp(s[i],s[j])==0){
				c++;
			}
			if(max<c){
				max=c;
				ans1=i;
			}
		}
	}
	
	printf(""%s %s\n"",s[ans1],s[ans2]);
	return 0;
}",1
p00029,"English Sentence
Your task is to write a program which reads a text and prints two words. The first one is the word which is arise most frequently in the text. The second one is the word which has the maximum number of letters.
The text includes only alphabetical characters and spaces. A word is a sequence of letters which is separated by the spaces.
Input
A text is given in a line. You can assume the following conditions:
The number of letters in the text is less than or equal to 1000.
The number of letters in a word is less than or equal to 32.
There is only one word which is arise most frequently in given text.
There is only one word which has the maximum number of letters in given text.
Output
The two words separated by a space.
Sample Input
Thank you for your mail and your lectures
Output for the Sample Input
your lectures",Java,"import java.util.*;

public class Main {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        String line = sc.nextLine();
        String[] words = line.split("" "");
        
        Map<String, Integer> frequency = new HashMap<>();
        for (String word : words) {
            frequency.put(word, frequency.getOrDefault(word, 0) + 1);
        }
        
        String mostFrequent = """";
        int maxFreq = 0;
        for (Map.Entry<String, Integer> entry : frequency.entrySet()) {
            if (entry.getValue() > maxFreq) {
                maxFreq = entry.getValue();
                mostFrequent = entry.getKey();
            }
        }
        
        String longest = """";
        int maxLen = 0;
        for (String word : words) {
            if (word.length() > maxLen) {
                maxLen = word.length();
                longest = word;
            }
        }
        
        System.out.println(mostFrequent + "" "" + longest);
    }
}
",0
p00029,"English Sentence
Your task is to write a program which reads a text and prints two words. The first one is the word which is arise most frequently in the text. The second one is the word which has the maximum number of letters.
The text includes only alphabetical characters and spaces. A word is a sequence of letters which is separated by the spaces.
Input
A text is given in a line. You can assume the following conditions:
The number of letters in the text is less than or equal to 1000.
The number of letters in a word is less than or equal to 32.
There is only one word which is arise most frequently in given text.
There is only one word which has the maximum number of letters in given text.
Output
The two words separated by a space.
Sample Input
Thank you for your mail and your lectures
Output for the Sample Input
your lectures",Java,"import java.util.HashMap;
import java.util.Scanner;

class Main{
	public static void main(String[] args){
		Scanner sc = new Scanner(System.in);
		HashMap<String, Integer> map = new HashMap<String, Integer>();

		String[] st = sc.nextLine().split("" "");
		
		for(int i = 0; i < st.length; i++)
			if(map.containsKey(st[i]))
				map.put(st[i], map.get(st[i])+1);
			else
				map.put(st[i], 1);
		
		String max = st[0];
		int count = 0;
		for(int i = 0; i < st.length-1; i++){
			if(map.get(st[i]) < map.get(st[i+1]))max = st[i+1];
		    if(st[i].length() < st[i+1].length())count = i+1;
		}
			System.out.println(max + "" "" + st[count]);
			
			sc.close();
	}
}",1
p00029,"English Sentence
Your task is to write a program which reads a text and prints two words. The first one is the word which is arise most frequently in the text. The second one is the word which has the maximum number of letters.
The text includes only alphabetical characters and spaces. A word is a sequence of letters which is separated by the spaces.
Input
A text is given in a line. You can assume the following conditions:
The number of letters in the text is less than or equal to 1000.
The number of letters in a word is less than or equal to 32.
There is only one word which is arise most frequently in given text.
There is only one word which has the maximum number of letters in given text.
Output
The two words separated by a space.
Sample Input
Thank you for your mail and your lectures
Output for the Sample Input
your lectures",Python,"text = input().split()
word_count = {}
for word in text:
    word_count[word] = word_count.get(word, 0) + 1

most_frequent = max(word_count, key=word_count.get)
longest = max(text, key=len)

print(most_frequent, longest)
",0
p00029,"English Sentence
Your task is to write a program which reads a text and prints two words. The first one is the word which is arise most frequently in the text. The second one is the word which has the maximum number of letters.
The text includes only alphabetical characters and spaces. A word is a sequence of letters which is separated by the spaces.
Input
A text is given in a line. You can assume the following conditions:
The number of letters in the text is less than or equal to 1000.
The number of letters in a word is less than or equal to 32.
There is only one word which is arise most frequently in given text.
There is only one word which has the maximum number of letters in given text.
Output
The two words separated by a space.
Sample Input
Thank you for your mail and your lectures
Output for the Sample Input
your lectures",Python,"def solve():
    text = input()
    longest, length = '', 0
    dic = {}
    for word in text.split():
        if word in dic.keys():
            dic[word] += 1
        else:
            dic[word] = 1
        
        if length < len(word):
            longest = word
            length = len(word)
    
    target, cnt = '', 0
    for k, v in dic.items():
        if v > cnt:
            target = k
            cnt = v
    print(target, longest)

if __name__ == ""__main__"":
    solve()

",1
p00030,"整数の和
0 から 9 の数字から異なる
n
個の数を取り出して合計が
s
となる組み合わせの数を出力するプログラムを作成してください。
n
個の数はおのおの 0 から 9 までとし、１つの組み合わせに同じ数字は使えません。たとえば、
n
が 3 で
s
が 6 のとき、3 個の数字の合計が 6 になる組み合わせは、
1 + 2 + 3 = 6
0 + 1 + 5 = 6
0 + 2 + 4 = 6
の 3 通りとなります。
Input
複数のデータセットが与えられます。各データセットに
n
(1 ≤
n
≤ 9) と
s
(0 ≤
s
≤ 100) が１つのスペースで区切られて１行に与えられます。
n
と
s
が共に 0 のとき入力の最後とします（この場合は処理せずにプログラムを終了する）。
データセットの数は 50 を超えません。
Output
各データセットに対して、
n
個の整数の和が
s
になる組み合わせの数を１行に出力して下さい。
Sample Input
3 6
3 1
0 0
Output for the Sample Input
3
0",C,"#include <stdio.h>

int count_combinations(int pos, int n, int s, int used) {
    if (n == 0) {
        return (s == 0) ? 1 : 0;
    }
    if (pos > 9 || s < 0) {
        return 0;
    }
    
    int result = 0;
    // Don't use current digit
    result += count_combinations(pos + 1, n, s, used);
    // Use current digit
    result += count_combinations(pos + 1, n - 1, s - pos, used);
    
    return result;
}

int main() {
    int n, s;
    
    while (1) {
        scanf(""%d %d"", &n, &s);
        if (n == 0 && s == 0) {
            break;
        }
        
        int result = count_combinations(0, n, s, 0);
        printf(""%d\n"", result);
    }
    
    return 0;
}
",0
p00030,"整数の和
0 から 9 の数字から異なる
n
個の数を取り出して合計が
s
となる組み合わせの数を出力するプログラムを作成してください。
n
個の数はおのおの 0 から 9 までとし、１つの組み合わせに同じ数字は使えません。たとえば、
n
が 3 で
s
が 6 のとき、3 個の数字の合計が 6 になる組み合わせは、
1 + 2 + 3 = 6
0 + 1 + 5 = 6
0 + 2 + 4 = 6
の 3 通りとなります。
Input
複数のデータセットが与えられます。各データセットに
n
(1 ≤
n
≤ 9) と
s
(0 ≤
s
≤ 100) が１つのスペースで区切られて１行に与えられます。
n
と
s
が共に 0 のとき入力の最後とします（この場合は処理せずにプログラムを終了する）。
データセットの数は 50 を超えません。
Output
各データセットに対して、
n
個の整数の和が
s
になる組み合わせの数を１行に出力して下さい。
Sample Input
3 6
3 1
0 0
Output for the Sample Input
3
0",C,"#include <stdio.h>
#include <string.h>


int val[10];
int s;

int getWay(int x, int n, int sum)
{
	int ret = 0;
	int i;
	
	if (n == 0){
		if (sum == s){
			return (1);
		}
		return (0);
	}
	
	for (i = x; i < 10; i++){
		if (val[i] == 0 && sum + i <= s){
			val[i] = 1;
			ret += getWay(i, n - 1, i + sum);
			val[i] = 0;
		}
	}
	
	return (ret);
}

int main(void)
{
	while (1){
		int n;
		
		scanf(""%d%d"", &n, &s);
		memset(val, 0, sizeof(val));
		
		if (n == 0 && s == 0){
			break;
		}
		
		printf(""%d\n"", getWay(0, n, 0));
	}
	
	return (0);
}",1
p00030,"整数の和
0 から 9 の数字から異なる
n
個の数を取り出して合計が
s
となる組み合わせの数を出力するプログラムを作成してください。
n
個の数はおのおの 0 から 9 までとし、１つの組み合わせに同じ数字は使えません。たとえば、
n
が 3 で
s
が 6 のとき、3 個の数字の合計が 6 になる組み合わせは、
1 + 2 + 3 = 6
0 + 1 + 5 = 6
0 + 2 + 4 = 6
の 3 通りとなります。
Input
複数のデータセットが与えられます。各データセットに
n
(1 ≤
n
≤ 9) と
s
(0 ≤
s
≤ 100) が１つのスペースで区切られて１行に与えられます。
n
と
s
が共に 0 のとき入力の最後とします（この場合は処理せずにプログラムを終了する）。
データセットの数は 50 を超えません。
Output
各データセットに対して、
n
個の整数の和が
s
になる組み合わせの数を１行に出力して下さい。
Sample Input
3 6
3 1
0 0
Output for the Sample Input
3
0",Java,"import java.util.Scanner;

public class Main {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        
        while (true) {
            int n = sc.nextInt();
            int s = sc.nextInt();
            
            if (n == 0 && s == 0) {
                break;
            }
            
            int count = countCombinations(n, s, 0, 0);
            System.out.println(count);
        }
        
        sc.close();
    }
    
    private static int countCombinations(int n, int s, int start, int depth) {
        if (depth == n) {
            return s == 0 ? 1 : 0;
        }
        
        if (start > 9) {
            return 0;
        }
        
        int count = 0;
        for (int i = start; i <= 9; i++) {
            count += countCombinations(n, s - i, i + 1, depth + 1);
        }
        
        return count;
    }
}
",0
p00030,"整数の和
0 から 9 の数字から異なる
n
個の数を取り出して合計が
s
となる組み合わせの数を出力するプログラムを作成してください。
n
個の数はおのおの 0 から 9 までとし、１つの組み合わせに同じ数字は使えません。たとえば、
n
が 3 で
s
が 6 のとき、3 個の数字の合計が 6 になる組み合わせは、
1 + 2 + 3 = 6
0 + 1 + 5 = 6
0 + 2 + 4 = 6
の 3 通りとなります。
Input
複数のデータセットが与えられます。各データセットに
n
(1 ≤
n
≤ 9) と
s
(0 ≤
s
≤ 100) が１つのスペースで区切られて１行に与えられます。
n
と
s
が共に 0 のとき入力の最後とします（この場合は処理せずにプログラムを終了する）。
データセットの数は 50 を超えません。
Output
各データセットに対して、
n
個の整数の和が
s
になる組み合わせの数を１行に出力して下さい。
Sample Input
3 6
3 1
0 0
Output for the Sample Input
3
0",Java,"

import java.io.BufferedReader;
import java.io.InputStreamReader;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashMap;

public class Main {
    public static void main(String args[]){
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        try{
            String line;
            
            while((line=br.readLine())!=null){
                if(line.equals(""""))break;
                String[] splited = line.split("" "");
                int n = Integer.parseInt(splited[0]);
                s = Integer.parseInt(splited[1]);
                if(n==0&&s==0)break;if(n>=10)System.out.println(""0"");
                    combis(1,n);
                    System.out.println(count);
                count=0;
            }         
        }catch(Exception e){e.printStackTrace();}
        
    }
    static int[] com = new int[10];
    static int count = 0,s=0;
    static void combis(int st,int r){
        if(st<=r){
            for(int i=(st==1)? 0:com[st-1]+1;i<=9-r+st;i++){
                com[st]=i;
                combis(st+1,r);
            }
        }else{
            //System.out.println(Arrays.toString(com));
            int sum=0; for(int i=1;i<=r;i++) sum+=com[i];
            if(sum==s)count++;
        }
        
        }
    static int _10Cn(int n){
            int _n=1,d=1;
            for(int i=1; i<=n;i++){
                _n*=11-i; d*=i;
            }
            return _n/d;
        }
}",1
p00030,"整数の和
0 から 9 の数字から異なる
n
個の数を取り出して合計が
s
となる組み合わせの数を出力するプログラムを作成してください。
n
個の数はおのおの 0 から 9 までとし、１つの組み合わせに同じ数字は使えません。たとえば、
n
が 3 で
s
が 6 のとき、3 個の数字の合計が 6 になる組み合わせは、
1 + 2 + 3 = 6
0 + 1 + 5 = 6
0 + 2 + 4 = 6
の 3 通りとなります。
Input
複数のデータセットが与えられます。各データセットに
n
(1 ≤
n
≤ 9) と
s
(0 ≤
s
≤ 100) が１つのスペースで区切られて１行に与えられます。
n
と
s
が共に 0 のとき入力の最後とします（この場合は処理せずにプログラムを終了する）。
データセットの数は 50 を超えません。
Output
各データセットに対して、
n
個の整数の和が
s
になる組み合わせの数を１行に出力して下さい。
Sample Input
3 6
3 1
0 0
Output for the Sample Input
3
0",Python,"from itertools import combinations

while True:
    n, s = map(int, input().split())
    if n == 0 and s == 0:
        break
    
    count = 0
    for combo in combinations(range(10), n):
        if sum(combo) == s:
            count += 1
    
    print(count)
",0
p00030,"整数の和
0 から 9 の数字から異なる
n
個の数を取り出して合計が
s
となる組み合わせの数を出力するプログラムを作成してください。
n
個の数はおのおの 0 から 9 までとし、１つの組み合わせに同じ数字は使えません。たとえば、
n
が 3 で
s
が 6 のとき、3 個の数字の合計が 6 になる組み合わせは、
1 + 2 + 3 = 6
0 + 1 + 5 = 6
0 + 2 + 4 = 6
の 3 通りとなります。
Input
複数のデータセットが与えられます。各データセットに
n
(1 ≤
n
≤ 9) と
s
(0 ≤
s
≤ 100) が１つのスペースで区切られて１行に与えられます。
n
と
s
が共に 0 のとき入力の最後とします（この場合は処理せずにプログラムを終了する）。
データセットの数は 50 を超えません。
Output
各データセットに対して、
n
個の整数の和が
s
になる組み合わせの数を１行に出力して下さい。
Sample Input
3 6
3 1
0 0
Output for the Sample Input
3
0",Python,"import sys
sys.setrecursionlimit(10000)

def solve(i,wa,use):
    global ct,s,n
    if wa==s and use==n:
        ct+=1
        return
    if use>=n or i==10 or wa>s:
        return
    solve(i+1,wa,use)
    solve(i+1,wa+i,use+1)

while 1:
    n,s=map(int,raw_input().split())
    if n==0 and s==0:
        break
    ct=0
    wa=0
    solve(0,0,0)
    print ct",1
p00031,"Weight
祖母が天秤を使っています。天秤は、二つの皿の両方に同じ目方のものを載せると釣合い、そうでない場合には、重い方に傾きます。10 個の分銅の重さは、軽い順に 1g, 2g, 4g, 8g, 16g, 32g, 64g, 128g, 256g, 512g です。
祖母は、「1kg くらいまでグラム単位で量れるのよ。」と言います。「じゃあ、試しに、ここにあるジュースの重さを量ってよ」と言ってみると、祖母は左の皿にジュースを、右の皿に 8g と64g と128g の分銅を載せて釣合わせてから、「分銅の目方の合計は 200g だから、ジュースの目方は 200g ね。どう、正しいでしょう？」と答えました。
左の皿に載せる品物の重さを与えるので、天秤で与えられた重みの品物と釣合わせるときに、右の皿に載せる分銅を軽い順に出力するプログラムを作成して下さい。ただし、量るべき品物の重さは、すべての分銅の重さの合計 (=1023g) 以下とします。
Input
複数のデータセットが与えられます。各データセットに、左の皿に載せる品物の重さが１行に与えられます。入力の最後まで処理して下さい。データセットの数は 50 を超えません。
Output
各データセットに対して、右の皿に載せる分銅（昇順）を１つの空白で区切って、１行に出力して下さい。
Sample Input
5
7
127
Output for the Sample Input
1 4
1 2 4
1 2 4 8 16 32 64
Hint
分銅の重さは 2 の
n
乗 (
n
= 0, 1, .... 9 )g です。",C,"#include <stdio.h>

int main() {
    int weight;
    int weights[] = {1, 2, 4, 8, 16, 32, 64, 128, 256, 512};
    
    while(scanf(""%d"", &weight) != EOF) {
        int first = 1;
        for(int i = 0; i < 10; i++) {
            if(weight & (1 << i)) {
                if(!first) {
                    printf("" "");
                }
                printf(""%d"", weights[i]);
                first = 0;
            }
        }
        printf(""\n"");
    }
    
    return 0;
}
",0
p00031,"Weight
祖母が天秤を使っています。天秤は、二つの皿の両方に同じ目方のものを載せると釣合い、そうでない場合には、重い方に傾きます。10 個の分銅の重さは、軽い順に 1g, 2g, 4g, 8g, 16g, 32g, 64g, 128g, 256g, 512g です。
祖母は、「1kg くらいまでグラム単位で量れるのよ。」と言います。「じゃあ、試しに、ここにあるジュースの重さを量ってよ」と言ってみると、祖母は左の皿にジュースを、右の皿に 8g と64g と128g の分銅を載せて釣合わせてから、「分銅の目方の合計は 200g だから、ジュースの目方は 200g ね。どう、正しいでしょう？」と答えました。
左の皿に載せる品物の重さを与えるので、天秤で与えられた重みの品物と釣合わせるときに、右の皿に載せる分銅を軽い順に出力するプログラムを作成して下さい。ただし、量るべき品物の重さは、すべての分銅の重さの合計 (=1023g) 以下とします。
Input
複数のデータセットが与えられます。各データセットに、左の皿に載せる品物の重さが１行に与えられます。入力の最後まで処理して下さい。データセットの数は 50 を超えません。
Output
各データセットに対して、右の皿に載せる分銅（昇順）を１つの空白で区切って、１行に出力して下さい。
Sample Input
5
7
127
Output for the Sample Input
1 4
1 2 4
1 2 4 8 16 32 64
Hint
分銅の重さは 2 の
n
乗 (
n
= 0, 1, .... 9 )g です。",C,"/*
AizuOnline A0031
Weight
*/
#include <stdio.h>


main()
{
  int weight;
  int fundou;
  int flag;
  
  while(EOF !=scanf(""%d"",&weight))
    {
      flag = 0;
      for(fundou=1;fundou <= 512;fundou <<= 1)
      { if(weight & fundou)
        {
          if(flag)
            printf("" "");
          printf(""%d"",fundou);
          flag = 1;
        }
      }
        printf(""\n"");
    }

return(0);
}",1
p00031,"Weight
祖母が天秤を使っています。天秤は、二つの皿の両方に同じ目方のものを載せると釣合い、そうでない場合には、重い方に傾きます。10 個の分銅の重さは、軽い順に 1g, 2g, 4g, 8g, 16g, 32g, 64g, 128g, 256g, 512g です。
祖母は、「1kg くらいまでグラム単位で量れるのよ。」と言います。「じゃあ、試しに、ここにあるジュースの重さを量ってよ」と言ってみると、祖母は左の皿にジュースを、右の皿に 8g と64g と128g の分銅を載せて釣合わせてから、「分銅の目方の合計は 200g だから、ジュースの目方は 200g ね。どう、正しいでしょう？」と答えました。
左の皿に載せる品物の重さを与えるので、天秤で与えられた重みの品物と釣合わせるときに、右の皿に載せる分銅を軽い順に出力するプログラムを作成して下さい。ただし、量るべき品物の重さは、すべての分銅の重さの合計 (=1023g) 以下とします。
Input
複数のデータセットが与えられます。各データセットに、左の皿に載せる品物の重さが１行に与えられます。入力の最後まで処理して下さい。データセットの数は 50 を超えません。
Output
各データセットに対して、右の皿に載せる分銅（昇順）を１つの空白で区切って、１行に出力して下さい。
Sample Input
5
7
127
Output for the Sample Input
1 4
1 2 4
1 2 4 8 16 32 64
Hint
分銅の重さは 2 の
n
乗 (
n
= 0, 1, .... 9 )g です。",Java,"import java.util.Scanner;
import java.util.ArrayList;

public class Main {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        
        while (sc.hasNext()) {
            int weight = sc.nextInt();
            ArrayList<Integer> weights = new ArrayList<>();
            
            int[] powers = {1, 2, 4, 8, 16, 32, 64, 128, 256, 512};
            
            for (int i = 0; i < powers.length; i++) {
                if ((weight & (1 << i)) != 0) {
                    weights.add(powers[i]);
                }
            }
            
            for (int i = 0; i < weights.size(); i++) {
                if (i > 0) System.out.print("" "");
                System.out.print(weights.get(i));
            }
            System.out.println();
        }
        
        sc.close();
    }
}
",0
p00031,"Weight
祖母が天秤を使っています。天秤は、二つの皿の両方に同じ目方のものを載せると釣合い、そうでない場合には、重い方に傾きます。10 個の分銅の重さは、軽い順に 1g, 2g, 4g, 8g, 16g, 32g, 64g, 128g, 256g, 512g です。
祖母は、「1kg くらいまでグラム単位で量れるのよ。」と言います。「じゃあ、試しに、ここにあるジュースの重さを量ってよ」と言ってみると、祖母は左の皿にジュースを、右の皿に 8g と64g と128g の分銅を載せて釣合わせてから、「分銅の目方の合計は 200g だから、ジュースの目方は 200g ね。どう、正しいでしょう？」と答えました。
左の皿に載せる品物の重さを与えるので、天秤で与えられた重みの品物と釣合わせるときに、右の皿に載せる分銅を軽い順に出力するプログラムを作成して下さい。ただし、量るべき品物の重さは、すべての分銅の重さの合計 (=1023g) 以下とします。
Input
複数のデータセットが与えられます。各データセットに、左の皿に載せる品物の重さが１行に与えられます。入力の最後まで処理して下さい。データセットの数は 50 を超えません。
Output
各データセットに対して、右の皿に載せる分銅（昇順）を１つの空白で区切って、１行に出力して下さい。
Sample Input
5
7
127
Output for the Sample Input
1 4
1 2 4
1 2 4 8 16 32 64
Hint
分銅の重さは 2 の
n
乗 (
n
= 0, 1, .... 9 )g です。",Java,"import java.util.*;

class Main{
        public static void main(String[] args){
                Scanner sc = new Scanner(System.in);
                while(sc.hasNext()){
                        String b = Integer.toString(sc.nextInt(), 2); 
                        String s = """"; 
                        for(int i = 0; i < b.length(); i++){
                                if(b.charAt(b.length()-1-i) == '1'){
                                        if(!s.equals("""")){
                                                s += "" "";
                                        }   
                                        s += (int)Math.pow(2,i);
                                }   
                        }   
                        System.out.println(s);
                }   
                sc.close();
        }   
}",1
p00031,"Weight
祖母が天秤を使っています。天秤は、二つの皿の両方に同じ目方のものを載せると釣合い、そうでない場合には、重い方に傾きます。10 個の分銅の重さは、軽い順に 1g, 2g, 4g, 8g, 16g, 32g, 64g, 128g, 256g, 512g です。
祖母は、「1kg くらいまでグラム単位で量れるのよ。」と言います。「じゃあ、試しに、ここにあるジュースの重さを量ってよ」と言ってみると、祖母は左の皿にジュースを、右の皿に 8g と64g と128g の分銅を載せて釣合わせてから、「分銅の目方の合計は 200g だから、ジュースの目方は 200g ね。どう、正しいでしょう？」と答えました。
左の皿に載せる品物の重さを与えるので、天秤で与えられた重みの品物と釣合わせるときに、右の皿に載せる分銅を軽い順に出力するプログラムを作成して下さい。ただし、量るべき品物の重さは、すべての分銅の重さの合計 (=1023g) 以下とします。
Input
複数のデータセットが与えられます。各データセットに、左の皿に載せる品物の重さが１行に与えられます。入力の最後まで処理して下さい。データセットの数は 50 を超えません。
Output
各データセットに対して、右の皿に載せる分銅（昇順）を１つの空白で区切って、１行に出力して下さい。
Sample Input
5
7
127
Output for the Sample Input
1 4
1 2 4
1 2 4 8 16 32 64
Hint
分銅の重さは 2 の
n
乗 (
n
= 0, 1, .... 9 )g です。",Python,"import sys

for line in sys.stdin:
    weight = int(line.strip())
    weights = []
    power = 0
    
    while weight > 0:
        if weight & 1:
            weights.append(2 ** power)
        weight >>= 1
        power += 1
    
    print(' '.join(map(str, weights)))
",0
p00031,"Weight
祖母が天秤を使っています。天秤は、二つの皿の両方に同じ目方のものを載せると釣合い、そうでない場合には、重い方に傾きます。10 個の分銅の重さは、軽い順に 1g, 2g, 4g, 8g, 16g, 32g, 64g, 128g, 256g, 512g です。
祖母は、「1kg くらいまでグラム単位で量れるのよ。」と言います。「じゃあ、試しに、ここにあるジュースの重さを量ってよ」と言ってみると、祖母は左の皿にジュースを、右の皿に 8g と64g と128g の分銅を載せて釣合わせてから、「分銅の目方の合計は 200g だから、ジュースの目方は 200g ね。どう、正しいでしょう？」と答えました。
左の皿に載せる品物の重さを与えるので、天秤で与えられた重みの品物と釣合わせるときに、右の皿に載せる分銅を軽い順に出力するプログラムを作成して下さい。ただし、量るべき品物の重さは、すべての分銅の重さの合計 (=1023g) 以下とします。
Input
複数のデータセットが与えられます。各データセットに、左の皿に載せる品物の重さが１行に与えられます。入力の最後まで処理して下さい。データセットの数は 50 を超えません。
Output
各データセットに対して、右の皿に載せる分銅（昇順）を１つの空白で区切って、１行に出力して下さい。
Sample Input
5
7
127
Output for the Sample Input
1 4
1 2 4
1 2 4 8 16 32 64
Hint
分銅の重さは 2 の
n
乗 (
n
= 0, 1, .... 9 )g です。",Python,"#encoding=utf-8
import itertools as iter
import sys
for i in sys.stdin:
    omori = [1, 2, 4, 8, 16, 32, 64, 128, 256, 512]
    x = int(i)
    for i in xrange(1,11):
        for element in iter.combinations(omori,i):
             if sum(element) == x:
                 for k in xrange(len(element)):
                     print element[k],
                 print """"",1
p00032,"プラスティック板
機械に辺・対角線の長さのデータを入力し、プラスティック板の型抜きをしている工場があります。この工場では、サイズは様々ですが、平行四辺形の型のみを切り出しています。あなたは、切り出される平行四辺形のうち、長方形とひし形の製造個数を数えるように上司から命じられました。
「機械に入力するデータ」を読み込んで、長方形とひし形の製造個数を出力するプログラムを作成してください。
Input
入力は以下の形式で与えられます。
a
1
,
b
1
,
c
1
a
2
,
b
2
,
c
2
:
機械に入力するデータが複数行に与えられます。
i
行目に
i
番目の平行四辺形の隣り合う２辺の長さを表す整数
a
i
,
b
i
と対角線の長さを表す整数
c
i
がカンマ区切りで与えられます (1 ≤
a
i
, b
i
, c
i
≤ 1000,
a
i
+ b
i
>
c
i
)。データの数は 100 件を超えません。
Output
１行目に長方形の製造個数、２行目ひし形の製造個数を出力します。
Sample Input
3,4,5
5,5,8
4,4,4
5,4,3
Output for the Sample Input
1
2",C,"#include <stdio.h>
#include <string.h>

int main() {
    char line[256];
    int rectangles = 0;
    int rhombuses = 0;
    
    while (fgets(line, sizeof(line), stdin)) {
        int a, b, c;
        if (sscanf(line, ""%d,%d,%d"", &a, &b, &c) == 3) {
            // Check if it's a rectangle: a^2 + b^2 = c^2
            if (a * a + b * b == c * c) {
                rectangles++;
            }
            // Check if it's a rhombus: a = b
            else if (a == b) {
                rhombuses++;
            }
        }
    }
    
    printf(""%d\n"", rectangles);
    printf(""%d\n"", rhombuses);
    
    return 0;
}
",0
p00032,"プラスティック板
機械に辺・対角線の長さのデータを入力し、プラスティック板の型抜きをしている工場があります。この工場では、サイズは様々ですが、平行四辺形の型のみを切り出しています。あなたは、切り出される平行四辺形のうち、長方形とひし形の製造個数を数えるように上司から命じられました。
「機械に入力するデータ」を読み込んで、長方形とひし形の製造個数を出力するプログラムを作成してください。
Input
入力は以下の形式で与えられます。
a
1
,
b
1
,
c
1
a
2
,
b
2
,
c
2
:
機械に入力するデータが複数行に与えられます。
i
行目に
i
番目の平行四辺形の隣り合う２辺の長さを表す整数
a
i
,
b
i
と対角線の長さを表す整数
c
i
がカンマ区切りで与えられます (1 ≤
a
i
, b
i
, c
i
≤ 1000,
a
i
+ b
i
>
c
i
)。データの数は 100 件を超えません。
Output
１行目に長方形の製造個数、２行目ひし形の製造個数を出力します。
Sample Input
3,4,5
5,5,8
4,4,4
5,4,3
Output for the Sample Input
1
2",C,"#include <stdio.h>

int main(void)
{
	int tyou=0, hisi=0;
	int a, b, c;
	
	while(scanf(""%d,%d,%d"", &a, &b, &c)!=EOF) {
		if(c*c==a*a+b*b) tyou++;
		if(a==b) hisi++;
	}
	
	printf(""%d\n%d\n"", tyou, hisi);
	
	return 0;
}
",1
p00032,"プラスティック板
機械に辺・対角線の長さのデータを入力し、プラスティック板の型抜きをしている工場があります。この工場では、サイズは様々ですが、平行四辺形の型のみを切り出しています。あなたは、切り出される平行四辺形のうち、長方形とひし形の製造個数を数えるように上司から命じられました。
「機械に入力するデータ」を読み込んで、長方形とひし形の製造個数を出力するプログラムを作成してください。
Input
入力は以下の形式で与えられます。
a
1
,
b
1
,
c
1
a
2
,
b
2
,
c
2
:
機械に入力するデータが複数行に与えられます。
i
行目に
i
番目の平行四辺形の隣り合う２辺の長さを表す整数
a
i
,
b
i
と対角線の長さを表す整数
c
i
がカンマ区切りで与えられます (1 ≤
a
i
, b
i
, c
i
≤ 1000,
a
i
+ b
i
>
c
i
)。データの数は 100 件を超えません。
Output
１行目に長方形の製造個数、２行目ひし形の製造個数を出力します。
Sample Input
3,4,5
5,5,8
4,4,4
5,4,3
Output for the Sample Input
1
2",Java,"import java.util.*;

public class Main {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int rectangles = 0;
        int rhombuses = 0;
        
        while (sc.hasNextLine()) {
            String line = sc.nextLine().trim();
            if (line.isEmpty()) break;
            
            String[] parts = line.split("","");
            int a = Integer.parseInt(parts[0]);
            int b = Integer.parseInt(parts[1]);
            int c = Integer.parseInt(parts[2]);
            
            // Check if rectangle: a^2 + b^2 = c^2 (diagonal satisfies Pythagorean theorem)
            if (a * a + b * b == c * c) {
                rectangles++;
            }
            // Check if rhombus: all sides equal (a == b)
            else if (a == b) {
                rhombuses++;
            }
        }
        
        System.out.println(rectangles);
        System.out.println(rhombuses);
        sc.close();
    }
}
",0
p00032,"プラスティック板
機械に辺・対角線の長さのデータを入力し、プラスティック板の型抜きをしている工場があります。この工場では、サイズは様々ですが、平行四辺形の型のみを切り出しています。あなたは、切り出される平行四辺形のうち、長方形とひし形の製造個数を数えるように上司から命じられました。
「機械に入力するデータ」を読み込んで、長方形とひし形の製造個数を出力するプログラムを作成してください。
Input
入力は以下の形式で与えられます。
a
1
,
b
1
,
c
1
a
2
,
b
2
,
c
2
:
機械に入力するデータが複数行に与えられます。
i
行目に
i
番目の平行四辺形の隣り合う２辺の長さを表す整数
a
i
,
b
i
と対角線の長さを表す整数
c
i
がカンマ区切りで与えられます (1 ≤
a
i
, b
i
, c
i
≤ 1000,
a
i
+ b
i
>
c
i
)。データの数は 100 件を超えません。
Output
１行目に長方形の製造個数、２行目ひし形の製造個数を出力します。
Sample Input
3,4,5
5,5,8
4,4,4
5,4,3
Output for the Sample Input
1
2",Java,"import java.util.Scanner;

class Main {

	public static void main(String[] args) {

		Scanner sc = null;
		try {
			sc = new Scanner(System.in);
			int countRectangle = 0;
			int countRhombus = 0;
			while (sc.hasNextLine()) {
				String[] input = sc.nextLine().split("","");
				int[] x = new int[3];
				for (int i = 0; i < 3; i++)
					x[i] = Integer.parseInt(input[i]);
				if (x[0] * x[0] + x[1] * x[1] == x[2] * x[2])
					countRectangle++;
				else if (x[0] == x[1])
					countRhombus++;
			}
			System.out.println(countRectangle);
			System.out.println(countRhombus);
		} finally {
			sc.close();
		}
	}
}",1
p00032,"プラスティック板
機械に辺・対角線の長さのデータを入力し、プラスティック板の型抜きをしている工場があります。この工場では、サイズは様々ですが、平行四辺形の型のみを切り出しています。あなたは、切り出される平行四辺形のうち、長方形とひし形の製造個数を数えるように上司から命じられました。
「機械に入力するデータ」を読み込んで、長方形とひし形の製造個数を出力するプログラムを作成してください。
Input
入力は以下の形式で与えられます。
a
1
,
b
1
,
c
1
a
2
,
b
2
,
c
2
:
機械に入力するデータが複数行に与えられます。
i
行目に
i
番目の平行四辺形の隣り合う２辺の長さを表す整数
a
i
,
b
i
と対角線の長さを表す整数
c
i
がカンマ区切りで与えられます (1 ≤
a
i
, b
i
, c
i
≤ 1000,
a
i
+ b
i
>
c
i
)。データの数は 100 件を超えません。
Output
１行目に長方形の製造個数、２行目ひし形の製造個数を出力します。
Sample Input
3,4,5
5,5,8
4,4,4
5,4,3
Output for the Sample Input
1
2",Python,"import sys
import math

rectangle_count = 0
rhombus_count = 0

for line in sys.stdin:
    line = line.strip()
    if not line:
        continue
    
    parts = line.split(',')
    a, b, c = int(parts[0]), int(parts[1]), int(parts[2])
    
    # Check if it's a rectangle
    # In a rectangle, the diagonal satisfies: c^2 = a^2 + b^2
    if a * a + b * b == c * c:
        rectangle_count += 1
    
    # Check if it's a rhombus
    # In a rhombus, all sides are equal: a == b
    if a == b:
        rhombus_count += 1

print(rectangle_count)
print(rhombus_count)
",0
p00032,"プラスティック板
機械に辺・対角線の長さのデータを入力し、プラスティック板の型抜きをしている工場があります。この工場では、サイズは様々ですが、平行四辺形の型のみを切り出しています。あなたは、切り出される平行四辺形のうち、長方形とひし形の製造個数を数えるように上司から命じられました。
「機械に入力するデータ」を読み込んで、長方形とひし形の製造個数を出力するプログラムを作成してください。
Input
入力は以下の形式で与えられます。
a
1
,
b
1
,
c
1
a
2
,
b
2
,
c
2
:
機械に入力するデータが複数行に与えられます。
i
行目に
i
番目の平行四辺形の隣り合う２辺の長さを表す整数
a
i
,
b
i
と対角線の長さを表す整数
c
i
がカンマ区切りで与えられます (1 ≤
a
i
, b
i
, c
i
≤ 1000,
a
i
+ b
i
>
c
i
)。データの数は 100 件を超えません。
Output
１行目に長方形の製造個数、２行目ひし形の製造個数を出力します。
Sample Input
3,4,5
5,5,8
4,4,4
5,4,3
Output for the Sample Input
1
2",Python,"import math
num1=0                                          #長方形の数                                                 
num2=0                                          #ひし形の数
while True:
    try:
        a,b,c=list(map(int, input().split("","")))
    except:
        break
    
    if pow(a,2)+pow(b,2)==pow(c,2):
        num1+=1
    elif a==b and a+b>c:
        num2+=1

print(num1)
print(num2)

",1
p00033,"玉
図のように二股に分かれている容器があります。1 から 10 までの番号が付けられた10 個の玉を容器の開口部 A から落とし、左の筒 B か右の筒 C に玉を入れます。板 D は支点 E を中心に左右に回転できるので、板 D を動かすことで筒 B と筒 C のどちらに入れるか決めることができます。
開口部 A から落とす玉の並びを与えます。それらを順番に筒 B 又は筒 Cに入れていきます。このとき、筒 B と筒 C のおのおのが両方とも番号の小さい玉の上に大きい玉を並べられる場合は YES、並べられない場合は NO と出力するプログラムを作成してください。ただし、容器の中で玉の順序を入れ替えることはできないものとします。また、続けて同じ筒に入れることができるものとし、筒 B, C ともに 10 個の玉がすべて入るだけの余裕があるものとします。
Input
複数のデータセットが与えられます。１行目にデータセット数
N
が与えられます。つづいて、
N
行のデータセットが与えられます。各データセットに 10 個の番号が左から順番に空白区切りで与えられます。
Output
各データセットに対して、
YES
または
NO
を１行に出力して下さい。
Sample Input
2
3 1 4 2 5 6 7 8 9 10
10 9 8 7 6 5 4 3 2 1
Output for the Sample Input
YES
NO",C,"#include <stdio.h>
#include <stdbool.h>

bool canArrange(int balls[10]) {
    // Try all possible combinations of putting balls in B or C
    // Use bitmask: 0 = put in B, 1 = put in C
    for (int mask = 0; mask < (1 << 10); mask++) {
        int b[10], c[10];
        int bCount = 0, cCount = 0;
        bool valid = true;
        
        // Distribute balls according to mask
        for (int i = 0; i < 10; i++) {
            if ((mask & (1 << i)) == 0) {
                // Put in B
                if (bCount > 0 && b[bCount - 1] > balls[i]) {
                    valid = false;
                    break;
                }
                b[bCount++] = balls[i];
            } else {
                // Put in C
                if (cCount > 0 && c[cCount - 1] > balls[i]) {
                    valid = false;
                    break;
                }
                c[cCount++] = balls[i];
            }
        }
        
        if (valid) {
            return true;
        }
    }
    
    return false;
}

int main() {
    int n;
    scanf(""%d"", &n);
    
    for (int i = 0; i < n; i++) {
        int balls[10];
        for (int j = 0; j < 10; j++) {
            scanf(""%d"", &balls[j]);
        }
        
        if (canArrange(balls)) {
            printf(""YES\n"");
        } else {
            printf(""NO\n"");
        }
    }
    
    return 0;
}
",0
p00033,"玉
図のように二股に分かれている容器があります。1 から 10 までの番号が付けられた10 個の玉を容器の開口部 A から落とし、左の筒 B か右の筒 C に玉を入れます。板 D は支点 E を中心に左右に回転できるので、板 D を動かすことで筒 B と筒 C のどちらに入れるか決めることができます。
開口部 A から落とす玉の並びを与えます。それらを順番に筒 B 又は筒 Cに入れていきます。このとき、筒 B と筒 C のおのおのが両方とも番号の小さい玉の上に大きい玉を並べられる場合は YES、並べられない場合は NO と出力するプログラムを作成してください。ただし、容器の中で玉の順序を入れ替えることはできないものとします。また、続けて同じ筒に入れることができるものとし、筒 B, C ともに 10 個の玉がすべて入るだけの余裕があるものとします。
Input
複数のデータセットが与えられます。１行目にデータセット数
N
が与えられます。つづいて、
N
行のデータセットが与えられます。各データセットに 10 個の番号が左から順番に空白区切りで与えられます。
Output
各データセットに対して、
YES
または
NO
を１行に出力して下さい。
Sample Input
2
3 1 4 2 5 6 7 8 9 10
10 9 8 7 6 5 4 3 2 1
Output for the Sample Input
YES
NO",C,"#include<stdio.h>

int main(){

	int i,j,n,a[10],b,c,nflag;

	scanf(""%d"",&n);

	for(i=0;i<n;i++){
		nflag=0;
		for(j=0;j<9;j++) scanf(""%d "",&a[j]);
		scanf(""%d"",&a[9]);

		b=a[0];
		c=0;
		for(j=1;j<10;j++){
			if(b<a[j]) b=a[j];
			else if(c<a[j]) c=a[j];
			else{
				printf(""NO\n"");
				nflag=1;
				break;
			}
		}
		if(nflag) continue;
		printf(""YES\n"");

	}



	return 0;

}",1
p00033,"玉
図のように二股に分かれている容器があります。1 から 10 までの番号が付けられた10 個の玉を容器の開口部 A から落とし、左の筒 B か右の筒 C に玉を入れます。板 D は支点 E を中心に左右に回転できるので、板 D を動かすことで筒 B と筒 C のどちらに入れるか決めることができます。
開口部 A から落とす玉の並びを与えます。それらを順番に筒 B 又は筒 Cに入れていきます。このとき、筒 B と筒 C のおのおのが両方とも番号の小さい玉の上に大きい玉を並べられる場合は YES、並べられない場合は NO と出力するプログラムを作成してください。ただし、容器の中で玉の順序を入れ替えることはできないものとします。また、続けて同じ筒に入れることができるものとし、筒 B, C ともに 10 個の玉がすべて入るだけの余裕があるものとします。
Input
複数のデータセットが与えられます。１行目にデータセット数
N
が与えられます。つづいて、
N
行のデータセットが与えられます。各データセットに 10 個の番号が左から順番に空白区切りで与えられます。
Output
各データセットに対して、
YES
または
NO
を１行に出力して下さい。
Sample Input
2
3 1 4 2 5 6 7 8 9 10
10 9 8 7 6 5 4 3 2 1
Output for the Sample Input
YES
NO",Java,"import java.util.*;

public class Main {
    static int[] balls;
    
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int n = sc.nextInt();
        
        for (int i = 0; i < n; i++) {
            balls = new int[10];
            for (int j = 0; j < 10; j++) {
                balls[j] = sc.nextInt();
            }
            
            if (canArrange(0, new ArrayList<>(), new ArrayList<>())) {
                System.out.println(""YES"");
            } else {
                System.out.println(""NO"");
            }
        }
        sc.close();
    }
    
    static boolean canArrange(int index, List<Integer> b, List<Integer> c) {
        if (index == 10) {
            return true;
        }
        
        int current = balls[index];
        
        // Try to put in B
        boolean canPutInB = true;
        if (!b.isEmpty() && b.get(b.size() - 1) > current) {
            canPutInB = false;
        }
        
        if (canPutInB) {
            b.add(current);
            if (canArrange(index + 1, b, c)) {
                return true;
            }
            b.remove(b.size() - 1);
        }
        
        // Try to put in C
        boolean canPutInC = true;
        if (!c.isEmpty() && c.get(c.size() - 1) > current) {
            canPutInC = false;
        }
        
        if (canPutInC) {
            c.add(current);
            if (canArrange(index + 1, b, c)) {
                return true;
            }
            c.remove(c.size() - 1);
        }
        
        return false;
    }
}
",0
p00033,"玉
図のように二股に分かれている容器があります。1 から 10 までの番号が付けられた10 個の玉を容器の開口部 A から落とし、左の筒 B か右の筒 C に玉を入れます。板 D は支点 E を中心に左右に回転できるので、板 D を動かすことで筒 B と筒 C のどちらに入れるか決めることができます。
開口部 A から落とす玉の並びを与えます。それらを順番に筒 B 又は筒 Cに入れていきます。このとき、筒 B と筒 C のおのおのが両方とも番号の小さい玉の上に大きい玉を並べられる場合は YES、並べられない場合は NO と出力するプログラムを作成してください。ただし、容器の中で玉の順序を入れ替えることはできないものとします。また、続けて同じ筒に入れることができるものとし、筒 B, C ともに 10 個の玉がすべて入るだけの余裕があるものとします。
Input
複数のデータセットが与えられます。１行目にデータセット数
N
が与えられます。つづいて、
N
行のデータセットが与えられます。各データセットに 10 個の番号が左から順番に空白区切りで与えられます。
Output
各データセットに対して、
YES
または
NO
を１行に出力して下さい。
Sample Input
2
3 1 4 2 5 6 7 8 9 10
10 9 8 7 6 5 4 3 2 1
Output for the Sample Input
YES
NO",Java,"
import java.util.Scanner;

public class Main {

	private static final int N = 12;
	int[] a = new int[N];
	int small = 0;
	int big = 0;
	
	private int s=0;     //数?的个数
	
	public static void main(String[] args) {
		Main m = new Main();
		m.Sort();
	}
	
	
	private void Sort(){	

		Scanner sc = new Scanner(System.in);
		s = sc.nextInt();
		
		while(s!= 0){	
			
			for (int i = 1; i <= 10; i++) {
				a[i] = sc.nextInt();
			}
			
			/*for (int m = 1; m <= 10; m++) {
				System.out.print(a[m]+ "" "");
			}*/
			
			if (a[1] > a[2]) {
				big = a[1];
				small = a[2];
			}else {
				big = a[2];
				small = a[1];
			}
			//System.out.println(big);
			
			for (int j = 3; j <= 10; j++) {
				if (a[j] > big) {
					big = a[j];
				}
				if (a[j] < big && a[j] > small) {
					small = a[j];
				}
				if (a[j] < small) {
					System.out.printf(""%s\n"",""NO"");
					break;
				}
				if (j == 10) {
					System.out.printf(""%s\n"",""YES"");
					continue;
				}
			}
			//System.out.println(s);
			s--;
				
		}
		sc.close();
	}
}",1
p00033,"玉
図のように二股に分かれている容器があります。1 から 10 までの番号が付けられた10 個の玉を容器の開口部 A から落とし、左の筒 B か右の筒 C に玉を入れます。板 D は支点 E を中心に左右に回転できるので、板 D を動かすことで筒 B と筒 C のどちらに入れるか決めることができます。
開口部 A から落とす玉の並びを与えます。それらを順番に筒 B 又は筒 Cに入れていきます。このとき、筒 B と筒 C のおのおのが両方とも番号の小さい玉の上に大きい玉を並べられる場合は YES、並べられない場合は NO と出力するプログラムを作成してください。ただし、容器の中で玉の順序を入れ替えることはできないものとします。また、続けて同じ筒に入れることができるものとし、筒 B, C ともに 10 個の玉がすべて入るだけの余裕があるものとします。
Input
複数のデータセットが与えられます。１行目にデータセット数
N
が与えられます。つづいて、
N
行のデータセットが与えられます。各データセットに 10 個の番号が左から順番に空白区切りで与えられます。
Output
各データセットに対して、
YES
または
NO
を１行に出力して下さい。
Sample Input
2
3 1 4 2 5 6 7 8 9 10
10 9 8 7 6 5 4 3 2 1
Output for the Sample Input
YES
NO",Python,"def can_sort(sequence):
    def is_valid(b_stack, c_stack, index):
        if index == 10:
            return True
        
        ball = sequence[index]
        
        # Try putting in B
        can_put_b = len(b_stack) == 0 or b_stack[-1] < ball
        if can_put_b:
            b_stack.append(ball)
            if is_valid(b_stack, c_stack, index + 1):
                return True
            b_stack.pop()
        
        # Try putting in C
        can_put_c = len(c_stack) == 0 or c_stack[-1] < ball
        if can_put_c:
            c_stack.append(ball)
            if is_valid(b_stack, c_stack, index + 1):
                return True
            c_stack.pop()
        
        return False
    
    return is_valid([], [], 0)

n = int(input())
for _ in range(n):
    sequence = list(map(int, input().split()))
    if can_sort(sequence):
        print(""YES"")
    else:
        print(""NO"")
",0
p00033,"玉
図のように二股に分かれている容器があります。1 から 10 までの番号が付けられた10 個の玉を容器の開口部 A から落とし、左の筒 B か右の筒 C に玉を入れます。板 D は支点 E を中心に左右に回転できるので、板 D を動かすことで筒 B と筒 C のどちらに入れるか決めることができます。
開口部 A から落とす玉の並びを与えます。それらを順番に筒 B 又は筒 Cに入れていきます。このとき、筒 B と筒 C のおのおのが両方とも番号の小さい玉の上に大きい玉を並べられる場合は YES、並べられない場合は NO と出力するプログラムを作成してください。ただし、容器の中で玉の順序を入れ替えることはできないものとします。また、続けて同じ筒に入れることができるものとし、筒 B, C ともに 10 個の玉がすべて入るだけの余裕があるものとします。
Input
複数のデータセットが与えられます。１行目にデータセット数
N
が与えられます。つづいて、
N
行のデータセットが与えられます。各データセットに 10 個の番号が左から順番に空白区切りで与えられます。
Output
各データセットに対して、
YES
または
NO
を１行に出力して下さい。
Sample Input
2
3 1 4 2 5 6 7 8 9 10
10 9 8 7 6 5 4 3 2 1
Output for the Sample Input
YES
NO",Python,"for data in range(input()):
    dataset=map(int,raw_input().split("" ""))
    B,C=0,0
    B=dataset.pop(0)
    while len(dataset)!=0:
        ball = dataset.pop(0)
        if ball-B<0 or ball-C<0:
            if ball-B<0 and ball-C<0:
                print ""NO""
                break
            elif ball-B<0:
                C=ball
            else:
                B=ball
        else:
            if ball-B<ball-C:
                B=ball
            else:
                C=ball
    if(len(dataset)==0):
        print ""YES""",1
p00034,"鉄道路線
複線（上りと下りが別の線路になっていてどこででもすれ違える）の鉄道路線があります。この路線には終端駅を含めて11 の駅があり、それぞれの駅と駅の間は図で示す区間番号で呼ばれています。
この路線の両方の終端駅から列車が同時に出発して、途中で停まらずに走ります。各区間の長さと2 本の列車の速度を読み込んで、それぞれの場合について列車がすれ違う区間の番号を出力するプログラムを作成してください。ただし、ちょうど駅のところですれ違う場合は、両側の区間番号のうち小さいほうの数字を出力します。また、列車の長さ、駅の長さは無視できるものとします。
Input
複数のデータセットが与えられる。各データセットは以下のような形式で与えられる。
l
1
,
l
2
,
l
3
,
l
4
,
l
5
,
l
6
,
l
7
,
l
8
,
l
9
,
l
10
,
v
1
,
v
2
l
i
(1 ≤
l
i
≤ 2,000) は区間
i
の長さ(km)を表す整数である。
v
1
は区間 1 側の終端駅を出発した列車の速度(km/h)、
v
2
は区間 10 側の終端駅を出発した列車の速度(km/h)を表す整数である (1 ≤
v
1
,
v
2
≤ 2,000)。
データセットの数は 50 を超えない。
Output
データセットごとに、列車がすれちがう区間の番号を１行に出力する。
Sample Input
1,1,1,1,1,1,1,1,1,1,40,60
1,1,1,1,1,3,3,3,3,3,50,50
10,10,10,10,10,10,10,10,10,10,50,49
Output for the Sample Input
4
7
6",C,"#include <stdio.h>
#include <string.h>

int main() {
    char line[256];
    
    while (fgets(line, sizeof(line), stdin)) {
        int l[10];
        int v1, v2;
        
        sscanf(line, ""%d,%d,%d,%d,%d,%d,%d,%d,%d,%d,%d,%d"",
               &l[0], &l[1], &l[2], &l[3], &l[4],
               &l[5], &l[6], &l[7], &l[8], &l[9],
               &v1, &v2);
        
        // Calculate total distance
        int total = 0;
        for (int i = 0; i < 10; i++) {
            total += l[i];
        }
        
        // Calculate cumulative distances from left
        int cum[11];
        cum[0] = 0;
        for (int i = 0; i < 10; i++) {
            cum[i + 1] = cum[i] + l[i];
        }
        
        // Find meeting point
        // Train 1 travels distance d1 = v1 * t
        // Train 2 travels distance d2 = v2 * t
        // d1 + d2 = total
        // v1 * t + v2 * t = total
        // t = total / (v1 + v2)
        // d1 = v1 * total / (v1 + v2)
        
        double d1 = (double)v1 * total / (v1 + v2);
        
        // Find which section this is in
        for (int i = 0; i < 10; i++) {
            if (d1 <= cum[i + 1]) {
                printf(""%d\n"", i + 1);
                break;
            }
        }
    }
    
    return 0;
}
",0
p00034,"鉄道路線
複線（上りと下りが別の線路になっていてどこででもすれ違える）の鉄道路線があります。この路線には終端駅を含めて11 の駅があり、それぞれの駅と駅の間は図で示す区間番号で呼ばれています。
この路線の両方の終端駅から列車が同時に出発して、途中で停まらずに走ります。各区間の長さと2 本の列車の速度を読み込んで、それぞれの場合について列車がすれ違う区間の番号を出力するプログラムを作成してください。ただし、ちょうど駅のところですれ違う場合は、両側の区間番号のうち小さいほうの数字を出力します。また、列車の長さ、駅の長さは無視できるものとします。
Input
複数のデータセットが与えられる。各データセットは以下のような形式で与えられる。
l
1
,
l
2
,
l
3
,
l
4
,
l
5
,
l
6
,
l
7
,
l
8
,
l
9
,
l
10
,
v
1
,
v
2
l
i
(1 ≤
l
i
≤ 2,000) は区間
i
の長さ(km)を表す整数である。
v
1
は区間 1 側の終端駅を出発した列車の速度(km/h)、
v
2
は区間 10 側の終端駅を出発した列車の速度(km/h)を表す整数である (1 ≤
v
1
,
v
2
≤ 2,000)。
データセットの数は 50 を超えない。
Output
データセットごとに、列車がすれちがう区間の番号を１行に出力する。
Sample Input
1,1,1,1,1,1,1,1,1,1,40,60
1,1,1,1,1,3,3,3,3,3,50,50
10,10,10,10,10,10,10,10,10,10,50,49
Output for the Sample Input
4
7
6",C,"#include<stdio.h>
main(){
  int i,ans;
  double l[10],km,k,v[2];
  while(scanf(""%lf,%lf,%lf,%lf,%lf,%lf,%lf,%lf,%lf,%lf,%lf,%lf"",&l[0],&l[1],&l[2],&l[3],&l[4],&l[5],&l[6],&l[7],&l[8],&l[9],&v[0],&v[1])!=EOF){
    km=l[0]+l[1]+l[2]+l[3]+l[4]+l[5]+l[6]+l[7]+l[8]+l[9];
    k=km*v[0]/(v[0]+v[1]);
    for(i=0;i>=0;i++){
      k-=l[i];
      if(k<=0){
	ans=i+1;
	i=-2;
      }
    }
    printf(""%d\n"",ans);
  }
  return 0;
}",1
p00034,"鉄道路線
複線（上りと下りが別の線路になっていてどこででもすれ違える）の鉄道路線があります。この路線には終端駅を含めて11 の駅があり、それぞれの駅と駅の間は図で示す区間番号で呼ばれています。
この路線の両方の終端駅から列車が同時に出発して、途中で停まらずに走ります。各区間の長さと2 本の列車の速度を読み込んで、それぞれの場合について列車がすれ違う区間の番号を出力するプログラムを作成してください。ただし、ちょうど駅のところですれ違う場合は、両側の区間番号のうち小さいほうの数字を出力します。また、列車の長さ、駅の長さは無視できるものとします。
Input
複数のデータセットが与えられる。各データセットは以下のような形式で与えられる。
l
1
,
l
2
,
l
3
,
l
4
,
l
5
,
l
6
,
l
7
,
l
8
,
l
9
,
l
10
,
v
1
,
v
2
l
i
(1 ≤
l
i
≤ 2,000) は区間
i
の長さ(km)を表す整数である。
v
1
は区間 1 側の終端駅を出発した列車の速度(km/h)、
v
2
は区間 10 側の終端駅を出発した列車の速度(km/h)を表す整数である (1 ≤
v
1
,
v
2
≤ 2,000)。
データセットの数は 50 を超えない。
Output
データセットごとに、列車がすれちがう区間の番号を１行に出力する。
Sample Input
1,1,1,1,1,1,1,1,1,1,40,60
1,1,1,1,1,3,3,3,3,3,50,50
10,10,10,10,10,10,10,10,10,10,50,49
Output for the Sample Input
4
7
6",Java,"import java.util.*;
import java.io.*;

public class Main {
    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        String line;
        
        while ((line = br.readLine()) != null) {
            line = line.trim();
            if (line.isEmpty()) break;
            
            String[] parts = line.split("","");
            int[] lengths = new int[10];
            for (int i = 0; i < 10; i++) {
                lengths[i] = Integer.parseInt(parts[i].trim());
            }
            int v1 = Integer.parseInt(parts[10].trim());
            int v2 = Integer.parseInt(parts[11].trim());
            
            // Calculate cumulative distances from station 0
            int[] cumDist = new int[11];
            cumDist[0] = 0;
            for (int i = 0; i < 10; i++) {
                cumDist[i + 1] = cumDist[i] + lengths[i];
            }
            int totalDistance = cumDist[10];
            
            // They meet when: distance1 + distance2 = totalDistance
            // time is same for both: t = distance1 / v1 = distance2 / v2
            // distance1 = v1 * t, distance2 = v2 * t
            // v1 * t + v2 * t = totalDistance
            // t = totalDistance / (v1 + v2)
            // distance1 = v1 * totalDistance / (v1 + v2)
            
            double meetDistance = (double) v1 * totalDistance / (v1 + v2);
            
            // Find which section this distance falls into
            int section = 1;
            for (int i = 1; i <= 10; i++) {
                if (meetDistance <= cumDist[i]) {
                    section = i;
                    break;
                }
            }
            
            System.out.println(section);
        }
    }
}
",0
p00034,"鉄道路線
複線（上りと下りが別の線路になっていてどこででもすれ違える）の鉄道路線があります。この路線には終端駅を含めて11 の駅があり、それぞれの駅と駅の間は図で示す区間番号で呼ばれています。
この路線の両方の終端駅から列車が同時に出発して、途中で停まらずに走ります。各区間の長さと2 本の列車の速度を読み込んで、それぞれの場合について列車がすれ違う区間の番号を出力するプログラムを作成してください。ただし、ちょうど駅のところですれ違う場合は、両側の区間番号のうち小さいほうの数字を出力します。また、列車の長さ、駅の長さは無視できるものとします。
Input
複数のデータセットが与えられる。各データセットは以下のような形式で与えられる。
l
1
,
l
2
,
l
3
,
l
4
,
l
5
,
l
6
,
l
7
,
l
8
,
l
9
,
l
10
,
v
1
,
v
2
l
i
(1 ≤
l
i
≤ 2,000) は区間
i
の長さ(km)を表す整数である。
v
1
は区間 1 側の終端駅を出発した列車の速度(km/h)、
v
2
は区間 10 側の終端駅を出発した列車の速度(km/h)を表す整数である (1 ≤
v
1
,
v
2
≤ 2,000)。
データセットの数は 50 を超えない。
Output
データセットごとに、列車がすれちがう区間の番号を１行に出力する。
Sample Input
1,1,1,1,1,1,1,1,1,1,40,60
1,1,1,1,1,3,3,3,3,3,50,50
10,10,10,10,10,10,10,10,10,10,50,49
Output for the Sample Input
4
7
6",Java,"import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;

public class Main {
	public static void main(String[] args) throws IOException {
		BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
		String line = null;
		int[] l = new int[10];
		int[] v = new int[2];

		while ((line = br.readLine()) != null) {
			String[] data = line.trim().split("","");
			int distance = 0;
			for (int i = 0; i < 10; i++) {
				l[i] = Integer.parseInt(data[i]);
				distance += l[i];
			}
			for (int i = 0; i < 2; i++)
				v[i] = Integer.parseInt(data[i + 10]);
			double see = distance * ((double) v[0] / (v[1] + v[0]));

			for (int i = 0; i < 10; i++) {
				if (see - l[i] > 0) {
					see -= l[i];
				} else {
					System.out.println(i + 1);
					break;
				}
			}
		}
	}
}",1
p00034,"鉄道路線
複線（上りと下りが別の線路になっていてどこででもすれ違える）の鉄道路線があります。この路線には終端駅を含めて11 の駅があり、それぞれの駅と駅の間は図で示す区間番号で呼ばれています。
この路線の両方の終端駅から列車が同時に出発して、途中で停まらずに走ります。各区間の長さと2 本の列車の速度を読み込んで、それぞれの場合について列車がすれ違う区間の番号を出力するプログラムを作成してください。ただし、ちょうど駅のところですれ違う場合は、両側の区間番号のうち小さいほうの数字を出力します。また、列車の長さ、駅の長さは無視できるものとします。
Input
複数のデータセットが与えられる。各データセットは以下のような形式で与えられる。
l
1
,
l
2
,
l
3
,
l
4
,
l
5
,
l
6
,
l
7
,
l
8
,
l
9
,
l
10
,
v
1
,
v
2
l
i
(1 ≤
l
i
≤ 2,000) は区間
i
の長さ(km)を表す整数である。
v
1
は区間 1 側の終端駅を出発した列車の速度(km/h)、
v
2
は区間 10 側の終端駅を出発した列車の速度(km/h)を表す整数である (1 ≤
v
1
,
v
2
≤ 2,000)。
データセットの数は 50 を超えない。
Output
データセットごとに、列車がすれちがう区間の番号を１行に出力する。
Sample Input
1,1,1,1,1,1,1,1,1,1,40,60
1,1,1,1,1,3,3,3,3,3,50,50
10,10,10,10,10,10,10,10,10,10,50,49
Output for the Sample Input
4
7
6",Python,"import sys

for line in sys.stdin:
    parts = line.strip().split(',')
    lengths = list(map(int, parts[:10]))
    v1, v2 = int(parts[10]), int(parts[11])
    
    total_length = sum(lengths)
    
    # Time when trains meet
    t_meet = total_length / (v1 + v2)
    
    # Distance traveled by train from section 1 side
    d1 = v1 * t_meet
    
    # Find which section this distance falls into
    cumulative = 0
    for i in range(10):
        cumulative += lengths[i]
        if d1 <= cumulative:
            print(i + 1)
            break
",0
p00034,"鉄道路線
複線（上りと下りが別の線路になっていてどこででもすれ違える）の鉄道路線があります。この路線には終端駅を含めて11 の駅があり、それぞれの駅と駅の間は図で示す区間番号で呼ばれています。
この路線の両方の終端駅から列車が同時に出発して、途中で停まらずに走ります。各区間の長さと2 本の列車の速度を読み込んで、それぞれの場合について列車がすれ違う区間の番号を出力するプログラムを作成してください。ただし、ちょうど駅のところですれ違う場合は、両側の区間番号のうち小さいほうの数字を出力します。また、列車の長さ、駅の長さは無視できるものとします。
Input
複数のデータセットが与えられる。各データセットは以下のような形式で与えられる。
l
1
,
l
2
,
l
3
,
l
4
,
l
5
,
l
6
,
l
7
,
l
8
,
l
9
,
l
10
,
v
1
,
v
2
l
i
(1 ≤
l
i
≤ 2,000) は区間
i
の長さ(km)を表す整数である。
v
1
は区間 1 側の終端駅を出発した列車の速度(km/h)、
v
2
は区間 10 側の終端駅を出発した列車の速度(km/h)を表す整数である (1 ≤
v
1
,
v
2
≤ 2,000)。
データセットの数は 50 を超えない。
Output
データセットごとに、列車がすれちがう区間の番号を１行に出力する。
Sample Input
1,1,1,1,1,1,1,1,1,1,40,60
1,1,1,1,1,3,3,3,3,3,50,50
10,10,10,10,10,10,10,10,10,10,50,49
Output for the Sample Input
4
7
6",Python,"while True:
    try:
        l1,l2,l3,l4,l5,l6,l7,l8,l9,l10,v1,v2=map(int,input().split("",""))
        kyo=0
        for i in l1,l2,l3,l4,l5,l6,l7,l8,l9,l10:
            kyo +=i
        v=v1+v2
        x=kyo/v
        ans=v1*x
        flag=0
        for j in l1,l2,l3,l4,l5,l6,l7,l8,l9,l10:
            if ans>0:
                ans -=j
                flag +=1
            elif ans==0:
                print(flag)
                break
            elif ans<0:
                print(flag)
                break
    except:break

",1
p00035,"凸？
平面上の異なる 4 点　$A (x_a, y_a)$, $B (x_b, y_b)$, $C (x_c, y_c)$, $D(x_d, y_d)$ の座標を読み込んで、それら 4 点を頂点とした四角形 $ABCD$ に凹みがなければ YES、凹みがあれば NO と出力するプログラムを作成してください。
凹みのある四角形とは図 1 のような四角形です。
Input
複数のデータセットが与えられます。各データセットの形式は以下のとおりです。
$x_a$,$y_a$,$x_b$,$y_b$,$x_c$,$y_c$,$x_d$,$y_d$
$x_a$, $y_a$, $x_b$, $y_b$, $x_c$, $y_c$, $x_d$, $y_d$ はそれぞれ -100 以上 100 以下であり、実数で与えられます。
1 直線上に 3 つ以上点が並ぶことはないものとします。また、入力順に点を結んでいけば、四角形になる順番に点の座標が入力されるものとします。（つまり、図 2 のような形になる順番で点が与えられることはありません。)
データセットの数は 100 を超えません。
Output
各データセットごとに、YES または NO を１行に出力します。
Sample Input
0.0,0.0,1.0,0.0,1.0,1.0,0.0,1.0
0.0,0.0,3.0,0.0,1.0,1.0,1.0,3.0
Output for the Sample Input
YES
NO",C,"#include <stdio.h>

double cross(double ax, double ay, double bx, double by, double cx, double cy) {
    return (bx - ax) * (cy - ay) - (by - ay) * (cx - ax);
}

int main() {
    double xa, ya, xb, yb, xc, yc, xd, yd;
    
    while (scanf(""%lf,%lf,%lf,%lf,%lf,%lf,%lf,%lf"", 
                 &xa, &ya, &xb, &yb, &xc, &yc, &xd, &yd) == 8) {
        
        double c1 = cross(xa, ya, xb, yb, xc, yc);
        double c2 = cross(xb, yb, xc, yc, xd, yd);
        double c3 = cross(xc, yc, xd, yd, xa, ya);
        double c4 = cross(xd, yd, xa, ya, xb, yb);
        
        if ((c1 > 0 && c2 > 0 && c3 > 0 && c4 > 0) ||
            (c1 < 0 && c2 < 0 && c3 < 0 && c4 < 0)) {
            printf(""YES\n"");
        } else {
            printf(""NO\n"");
        }
    }
    
    return 0;
}
",0
p00035,"凸？
平面上の異なる 4 点　$A (x_a, y_a)$, $B (x_b, y_b)$, $C (x_c, y_c)$, $D(x_d, y_d)$ の座標を読み込んで、それら 4 点を頂点とした四角形 $ABCD$ に凹みがなければ YES、凹みがあれば NO と出力するプログラムを作成してください。
凹みのある四角形とは図 1 のような四角形です。
Input
複数のデータセットが与えられます。各データセットの形式は以下のとおりです。
$x_a$,$y_a$,$x_b$,$y_b$,$x_c$,$y_c$,$x_d$,$y_d$
$x_a$, $y_a$, $x_b$, $y_b$, $x_c$, $y_c$, $x_d$, $y_d$ はそれぞれ -100 以上 100 以下であり、実数で与えられます。
1 直線上に 3 つ以上点が並ぶことはないものとします。また、入力順に点を結んでいけば、四角形になる順番に点の座標が入力されるものとします。（つまり、図 2 のような形になる順番で点が与えられることはありません。)
データセットの数は 100 を超えません。
Output
各データセットごとに、YES または NO を１行に出力します。
Sample Input
0.0,0.0,1.0,0.0,1.0,1.0,0.0,1.0
0.0,0.0,3.0,0.0,1.0,1.0,1.0,3.0
Output for the Sample Input
YES
NO",C,"#include <stdio.h>

double gaiseki(double x0,double y0,double x1,double y1,double x2,double y2){
return(x0-x1)*(y0-y1)-(x0-x2)*(y0-y2);
}
int main(){
double x0,y0,x1,y1,x2,y2,x3,y3;
while (scanf(""%lf,%lf,%lf,%lf,%lf,%lf,%lf,%lf"",&x0,&y0,&x1,&y1,&x2,&y2,&x3,&y3)!=EOF){
if (gaiseki(x0,y0,x1,y1,x3,y3)>=0&&gaiseki(x1,y1,x2,y2,x3,y3)>=0&&gaiseki(x2,y2,x0,y0,x3,y3)>=0){
printf(""YES\n"");
}else{
printf(""NO\n"");
}
}
return 0;
}",1
p00035,"凸？
平面上の異なる 4 点　$A (x_a, y_a)$, $B (x_b, y_b)$, $C (x_c, y_c)$, $D(x_d, y_d)$ の座標を読み込んで、それら 4 点を頂点とした四角形 $ABCD$ に凹みがなければ YES、凹みがあれば NO と出力するプログラムを作成してください。
凹みのある四角形とは図 1 のような四角形です。
Input
複数のデータセットが与えられます。各データセットの形式は以下のとおりです。
$x_a$,$y_a$,$x_b$,$y_b$,$x_c$,$y_c$,$x_d$,$y_d$
$x_a$, $y_a$, $x_b$, $y_b$, $x_c$, $y_c$, $x_d$, $y_d$ はそれぞれ -100 以上 100 以下であり、実数で与えられます。
1 直線上に 3 つ以上点が並ぶことはないものとします。また、入力順に点を結んでいけば、四角形になる順番に点の座標が入力されるものとします。（つまり、図 2 のような形になる順番で点が与えられることはありません。)
データセットの数は 100 を超えません。
Output
各データセットごとに、YES または NO を１行に出力します。
Sample Input
0.0,0.0,1.0,0.0,1.0,1.0,0.0,1.0
0.0,0.0,3.0,0.0,1.0,1.0,1.0,3.0
Output for the Sample Input
YES
NO",Java,"import java.util.Scanner;

public class Main {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        
        while (sc.hasNext()) {
            String line = sc.nextLine();
            String[] parts = line.split("","");
            
            double xa = Double.parseDouble(parts[0]);
            double ya = Double.parseDouble(parts[1]);
            double xb = Double.parseDouble(parts[2]);
            double yb = Double.parseDouble(parts[3]);
            double xc = Double.parseDouble(parts[4]);
            double yc = Double.parseDouble(parts[5]);
            double xd = Double.parseDouble(parts[6]);
            double yd = Double.parseDouble(parts[7]);
            
            double cross1 = crossProduct(xa, ya, xb, yb, xc, yc);
            double cross2 = crossProduct(xb, yb, xc, yc, xd, yd);
            double cross3 = crossProduct(xc, yc, xd, yd, xa, ya);
            double cross4 = crossProduct(xd, yd, xa, ya, xb, yb);
            
            boolean allPositive = cross1 > 0 && cross2 > 0 && cross3 > 0 && cross4 > 0;
            boolean allNegative = cross1 < 0 && cross2 < 0 && cross3 < 0 && cross4 < 0;
            
            if (allPositive || allNegative) {
                System.out.println(""YES"");
            } else {
                System.out.println(""NO"");
            }
        }
        
        sc.close();
    }
    
    private static double crossProduct(double x1, double y1, double x2, double y2, double x3, double y3) {
        double v1x = x2 - x1;
        double v1y = y2 - y1;
        double v2x = x3 - x2;
        double v2y = y3 - y2;
        return v1x * v2y - v1y * v2x;
    }
}
",0
p00035,"凸？
平面上の異なる 4 点　$A (x_a, y_a)$, $B (x_b, y_b)$, $C (x_c, y_c)$, $D(x_d, y_d)$ の座標を読み込んで、それら 4 点を頂点とした四角形 $ABCD$ に凹みがなければ YES、凹みがあれば NO と出力するプログラムを作成してください。
凹みのある四角形とは図 1 のような四角形です。
Input
複数のデータセットが与えられます。各データセットの形式は以下のとおりです。
$x_a$,$y_a$,$x_b$,$y_b$,$x_c$,$y_c$,$x_d$,$y_d$
$x_a$, $y_a$, $x_b$, $y_b$, $x_c$, $y_c$, $x_d$, $y_d$ はそれぞれ -100 以上 100 以下であり、実数で与えられます。
1 直線上に 3 つ以上点が並ぶことはないものとします。また、入力順に点を結んでいけば、四角形になる順番に点の座標が入力されるものとします。（つまり、図 2 のような形になる順番で点が与えられることはありません。)
データセットの数は 100 を超えません。
Output
各データセットごとに、YES または NO を１行に出力します。
Sample Input
0.0,0.0,1.0,0.0,1.0,1.0,0.0,1.0
0.0,0.0,3.0,0.0,1.0,1.0,1.0,3.0
Output for the Sample Input
YES
NO",Java,"import java.util.*;class Main{public static void main(String[]z){double[]b=new double[8];for(Scanner s=new Scanner(System.in);s.hasNext();System.out.println((f(b[0],b[1],b[4],b[5],b[6],b[7])>0&&f(b[4],b[5],b[0],b[1],b[2],b[3])>0&&f(b[2],b[3],b[6],b[7],b[0],b[1])>0&&f(b[6],b[7],b[2],b[3],b[4],b[5])>0)||(f(b[0],b[1],b[4],b[5],b[6],b[7])<0&&f(b[4],b[5],b[0],b[1],b[2],b[3])<0&&f(b[2],b[3],b[6],b[7],b[0],b[1])<0&&f(b[6],b[7],b[2],b[3],b[4],b[5])<0)?""YES"":""NO"")){z=s.next().split("","");for(int i=0;i<8;++i)b[i]=new Double(z[i]);}}static double f(double a,double b,double c,double d,double e,double f){return ((d-b)*e+(a-c)*f+c*b-a*d);}}",1
p00035,"凸？
平面上の異なる 4 点　$A (x_a, y_a)$, $B (x_b, y_b)$, $C (x_c, y_c)$, $D(x_d, y_d)$ の座標を読み込んで、それら 4 点を頂点とした四角形 $ABCD$ に凹みがなければ YES、凹みがあれば NO と出力するプログラムを作成してください。
凹みのある四角形とは図 1 のような四角形です。
Input
複数のデータセットが与えられます。各データセットの形式は以下のとおりです。
$x_a$,$y_a$,$x_b$,$y_b$,$x_c$,$y_c$,$x_d$,$y_d$
$x_a$, $y_a$, $x_b$, $y_b$, $x_c$, $y_c$, $x_d$, $y_d$ はそれぞれ -100 以上 100 以下であり、実数で与えられます。
1 直線上に 3 つ以上点が並ぶことはないものとします。また、入力順に点を結んでいけば、四角形になる順番に点の座標が入力されるものとします。（つまり、図 2 のような形になる順番で点が与えられることはありません。)
データセットの数は 100 を超えません。
Output
各データセットごとに、YES または NO を１行に出力します。
Sample Input
0.0,0.0,1.0,0.0,1.0,1.0,0.0,1.0
0.0,0.0,3.0,0.0,1.0,1.0,1.0,3.0
Output for the Sample Input
YES
NO",Python,"import sys

def cross_product(o, a, b):
    return (a[0] - o[0]) * (b[1] - o[1]) - (a[1] - o[1]) * (b[0] - o[0])

def is_convex(points):
    n = len(points)
    sign = None
    
    for i in range(n):
        o = points[i]
        a = points[(i + 1) % n]
        b = points[(i + 2) % n]
        
        cp = cross_product(o, a, b)
        
        if cp != 0:
            if sign is None:
                sign = cp > 0
            elif (cp > 0) != sign:
                return False
    
    return True

for line in sys.stdin:
    coords = list(map(float, line.strip().split(',')))
    points = [(coords[i], coords[i+1]) for i in range(0, 8, 2)]
    
    if is_convex(points):
        print(""YES"")
    else:
        print(""NO"")
",0
p00035,"凸？
平面上の異なる 4 点　$A (x_a, y_a)$, $B (x_b, y_b)$, $C (x_c, y_c)$, $D(x_d, y_d)$ の座標を読み込んで、それら 4 点を頂点とした四角形 $ABCD$ に凹みがなければ YES、凹みがあれば NO と出力するプログラムを作成してください。
凹みのある四角形とは図 1 のような四角形です。
Input
複数のデータセットが与えられます。各データセットの形式は以下のとおりです。
$x_a$,$y_a$,$x_b$,$y_b$,$x_c$,$y_c$,$x_d$,$y_d$
$x_a$, $y_a$, $x_b$, $y_b$, $x_c$, $y_c$, $x_d$, $y_d$ はそれぞれ -100 以上 100 以下であり、実数で与えられます。
1 直線上に 3 つ以上点が並ぶことはないものとします。また、入力順に点を結んでいけば、四角形になる順番に点の座標が入力されるものとします。（つまり、図 2 のような形になる順番で点が与えられることはありません。)
データセットの数は 100 を超えません。
Output
各データセットごとに、YES または NO を１行に出力します。
Sample Input
0.0,0.0,1.0,0.0,1.0,1.0,0.0,1.0
0.0,0.0,3.0,0.0,1.0,1.0,1.0,3.0
Output for the Sample Input
YES
NO",Python,"from __future__ import (division, absolute_import, print_function,
                        unicode_literals)
from sys import stdin
from collections import namedtuple
Point = namedtuple('Point', 'x y')

def make_test(p1, p2):
    if p1.x == p2.x:
        gradient = p1.x
        return lambda p: gradient > p.x
    gradient = (p1.y - p2.y) / (p1.x - p2.x)
    y_intercept = p1.y - gradient * p1.x
    return lambda p: gradient * p.x + y_intercept > p.y

for line in stdin:
    it = (float(s) for s in line.split(','))
    A, B, C, D = (Point(next(it), next(it)) for _ in xrange(4))

    f = make_test(A, C)
    g = make_test(B, D)
    if f(B) == f(D) or g(A) == g(C):
        print('NO')
    else:
        print('YES')",1
p00036,"平面上の図形
縦 8、横 8 のマスからなる図 1 のような平面があります。
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
図１
この平面上に、以下の A から G の図形のどれかが一つだけ置かれています。
A
■
■
■
■
B
■
■
■
■
C
■
■
■
■
D
■
■
■
■
E
■
■
■
■
F
■
■
■
■
G
■
■
■
■
たとえば、次の図 2 の例では E の図形が置かれています。
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
■
■
□
□
□
□
□
□
□
■
■
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
図２
平面の中で図形が占めているマスを 1、占めていないマスを 0 で表現した数字の列を読み込んで、置かれている図形の種類（A〜G）を出力するプログラムを作成してください。
ただし、ひとつの平面に置かれている図形は必ず１つで、複数の図形が置かれていることはありません。また、A〜G で表される図形以外のものが置かれていることはありません。
Input
入力は複数のデータセットからなります。
１つのデータセットとして、平面の中で図形が占めているマスを 1、占めていないマスを 0 で表現した 8 文字からなる 8 つの文字列が与えられます。例えば、図 2 に対応する文字列の並びは次のようになります。
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
1
1
0
0
0
0
0
0
0
1
1
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
データセットの間は１つの空行で区切られています。データセットの数は 50 を超えません。
Output
各データセットごとに、平面に与えられた図形の種類（A〜G のいずれか）を１行に出力してください。
Sample Input
00000000
00000000
01100000
00110000
00000000
00000000
00000000
00000000

00011110
00000000
00000000
00000000
00000000
00000000
00000000
00000000

00000000
00000000
00110000
00110000
00000000
00000000
00000000
00000000
Output for the Sample Input
E
C
A",C,"#include <stdio.h>
#include <string.h>

int main() {
    char grid[8][9];
    
    while(scanf(""%s"", grid[0]) != EOF) {
        for(int i = 1; i < 8; i++) {
            scanf(""%s"", grid[i]);
        }
        
        // Extract the shape pattern
        int minR = 8, maxR = -1, minC = 8, maxC = -1;
        for(int i = 0; i < 8; i++) {
            for(int j = 0; j < 8; j++) {
                if(grid[i][j] == '1') {
                    if(i < minR) minR = i;
                    if(i > maxR) maxR = i;
                    if(j < minC) minC = j;
                    if(j > maxC) maxC = j;
                }
            }
        }
        
        int height = maxR - minR + 1;
        int width = maxC - minC + 1;
        
        // Extract normalized pattern
        int pattern[4][4] = {0};
        for(int i = minR; i <= maxR; i++) {
            for(int j = minC; j <= maxC; j++) {
                if(grid[i][j] == '1') {
                    pattern[i-minR][j-minC] = 1;
                }
            }
        }
        
        // Check each shape
        char result = '?';
        
        // Shape A: 2x2 square
        if(height == 2 && width == 2 && 
           pattern[0][0] && pattern[0][1] && 
           pattern[1][0] && pattern[1][1]) {
            result = 'A';
        }
        // Shape B: 1x4 horizontal
        else if(height == 1 && width == 4 && 
                pattern[0][0] && pattern[0][1] && 
                pattern[0][2] && pattern[0][3]) {
            result = 'B';
        }
        // Shape C: 4x1 vertical
        else if(height == 4 && width == 1 && 
                pattern[0][0] && pattern[1][0] && 
                pattern[2][0] && pattern[3][0]) {
            result = 'C';
        }
        // Shape D: 3x1 vertical
        else if(height == 3 && width == 1 && 
                pattern[0][0] && pattern[1][0] && 
                pattern[2][0]) {
            result = 'D';
        }
        // Shape E: zigzag
        else if(height == 2 && width == 3 && 
                pattern[0][0] && pattern[0][1] && !pattern[0][2] &&
                !pattern[1][0] && pattern[1][1] && pattern[1][2]) {
            result = 'E';
        }
        // Shape F: reverse zigzag
        else if(height == 2 && width == 3 && 
                !pattern[0][0] && pattern[0][1] && pattern[0][2] &&
                pattern[1][0] && pattern[1][1] && !pattern[1][2]) {
            result = 'F';
        }
        // Shape G: L-shape
        else if(height == 2 && width == 2 && 
                pattern[0][0] && !pattern[0][1] && 
                pattern[1][0] && pattern[1][1]) {
            result = 'G';
        }
        
        printf(""%c\n"", result);
    }
    
    return 0;
}
",0
p00036,"平面上の図形
縦 8、横 8 のマスからなる図 1 のような平面があります。
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
図１
この平面上に、以下の A から G の図形のどれかが一つだけ置かれています。
A
■
■
■
■
B
■
■
■
■
C
■
■
■
■
D
■
■
■
■
E
■
■
■
■
F
■
■
■
■
G
■
■
■
■
たとえば、次の図 2 の例では E の図形が置かれています。
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
■
■
□
□
□
□
□
□
□
■
■
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
図２
平面の中で図形が占めているマスを 1、占めていないマスを 0 で表現した数字の列を読み込んで、置かれている図形の種類（A〜G）を出力するプログラムを作成してください。
ただし、ひとつの平面に置かれている図形は必ず１つで、複数の図形が置かれていることはありません。また、A〜G で表される図形以外のものが置かれていることはありません。
Input
入力は複数のデータセットからなります。
１つのデータセットとして、平面の中で図形が占めているマスを 1、占めていないマスを 0 で表現した 8 文字からなる 8 つの文字列が与えられます。例えば、図 2 に対応する文字列の並びは次のようになります。
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
1
1
0
0
0
0
0
0
0
1
1
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
データセットの間は１つの空行で区切られています。データセットの数は 50 を超えません。
Output
各データセットごとに、平面に与えられた図形の種類（A〜G のいずれか）を１行に出力してください。
Sample Input
00000000
00000000
01100000
00110000
00000000
00000000
00000000
00000000

00011110
00000000
00000000
00000000
00000000
00000000
00000000
00000000

00000000
00000000
00110000
00110000
00000000
00000000
00000000
00000000
Output for the Sample Input
E
C
A",C,"#include<stdio.h>

#define X 8
#define Y 8
#define L 3
#define M 2
#define S 1


int main(void)
{
        char ppr[X][Y];/*紙*/
        int x = 0, y = 0;
        int i = 0, j = 0;
        int size = 0;
        int count = 0;
        int max = 0;
        int farst = 0;
        int k = 0;
        int h = 0;
        char ans[4][2];

        for(i = 0; i < X; i++)
        {
                for(j = 0;j < Y; j++)
                {
                        ppr[i][j] = '0';
                }
        }

        for(i = 0; i < 4; i++)
        {
                for(j = 0;j < 2; j++)
                {
                        ans[i][j] = '0';
                }
        }

        while(scanf(""%s"", ppr[0]) != EOF)
        {
                for(i = 1; i < X; i++)
                {
                        scanf(""%s"", ppr[i]);
                }
                for(i = 0; i < X; i++)
                {
                        for(j = 0; j < Y; j++)
                        {
                                if( ppr[i][j] == '1')
                                {
                                        ans[k][0] = j;
                                        ans[k][1] = i;
                                        k++;
                                }
                        }
                }
/*
                for(i = 0;i < 4; i++)
                {
                        printf(""%d %d\n"",ans[i][0],ans[i][1]);
                }
*/
                x = ans[0][0];
                y = ans[0][1];
                ans[0][0] -= x; ans[0][1] -= y;
                ans[1][0] -= x; ans[1][1] -= y;
                ans[2][0] -= x; ans[2][1] -= y;
                ans[3][0] -= x; ans[3][1] -= y;
                /*
                for(i = 0;i < 4; i++)
                {
                        printf(""%d %d\n"",ans[i][0],ans[i][1]);
                }*/

                if(ans[0][0] ==  0 && ans[0][1] == 0 &&
                   ans[1][0] ==  0 && ans[1][1] == 1 &&
                   ans[2][0] ==  1 && ans[2][1] == 0 &&
                   ans[3][0] ==  1 && ans[3][1] == 1 )
                {
                        printf(""A\n"");
                }
                else if(ans[0][0] == 0 &&ans[0][1] == 0 &&
                   ans[1][0] ==  1 && ans[1][1] == 0 &&
                   ans[2][0] ==  2 && ans[2][1] == 0 &&
                   ans[3][0] ==  3 && ans[3][1] == 0 )
                {
                        printf(""B\n"");
                }
                else if(ans[0][0] ==  0 && ans[0][1] == 0 &&
                        ans[1][0] ==  0 && ans[1][1] == 1 &&
                        ans[2][0] ==  0 && ans[2][1] == 2 &&
                        ans[3][0] ==  0 && ans[3][1] == 3 )
                {
                        printf(""C\n"");
                }
                else if(ans[0][0] ==  0 && ans[0][1] == 1 &&
                        ans[1][0] ==  1 && ans[1][1] == 0 &&
                        ans[2][0] ==  1 && ans[2][1] == 1 &&
                        ans[3][0] ==  2 && ans[3][1] == 0 )
                {
                        printf(""D\n"");
                }
                else if(ans[0][0] ==  0 && ans[0][1] == 0 &&
                        ans[1][0] ==  0 && ans[1][1] == 1 &&
                        ans[2][0] ==  1 && ans[2][1] == 1 &&
                        ans[3][0] ==  1 && ans[3][1] == 2 )
                {
                        printf(""E\n"");
                }
                else if(ans[0][0] ==  0 && ans[0][1] == 0 &&
                        ans[1][0] ==  1 && ans[1][1] == 0 &&
                        ans[2][0] ==  1 && ans[2][1] == 1 &&
                        ans[3][0] ==  2 && ans[3][1] == 1 )
                {
                        printf(""F\n"");
                }
                else if(ans[0][0] ==  0 && ans[0][1] == 1 &&
                        ans[1][0] ==  0 && ans[1][1] == 2 &&
                        ans[2][0] ==  1 && ans[2][1] == 0 &&
                        ans[3][0] ==  1 && ans[3][1] == 1 )
                {
                        printf(""G\n"");
                }


        }

        return 0;
}",1
p00036,"平面上の図形
縦 8、横 8 のマスからなる図 1 のような平面があります。
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
図１
この平面上に、以下の A から G の図形のどれかが一つだけ置かれています。
A
■
■
■
■
B
■
■
■
■
C
■
■
■
■
D
■
■
■
■
E
■
■
■
■
F
■
■
■
■
G
■
■
■
■
たとえば、次の図 2 の例では E の図形が置かれています。
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
■
■
□
□
□
□
□
□
□
■
■
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
図２
平面の中で図形が占めているマスを 1、占めていないマスを 0 で表現した数字の列を読み込んで、置かれている図形の種類（A〜G）を出力するプログラムを作成してください。
ただし、ひとつの平面に置かれている図形は必ず１つで、複数の図形が置かれていることはありません。また、A〜G で表される図形以外のものが置かれていることはありません。
Input
入力は複数のデータセットからなります。
１つのデータセットとして、平面の中で図形が占めているマスを 1、占めていないマスを 0 で表現した 8 文字からなる 8 つの文字列が与えられます。例えば、図 2 に対応する文字列の並びは次のようになります。
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
1
1
0
0
0
0
0
0
0
1
1
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
データセットの間は１つの空行で区切られています。データセットの数は 50 を超えません。
Output
各データセットごとに、平面に与えられた図形の種類（A〜G のいずれか）を１行に出力してください。
Sample Input
00000000
00000000
01100000
00110000
00000000
00000000
00000000
00000000

00011110
00000000
00000000
00000000
00000000
00000000
00000000
00000000

00000000
00000000
00110000
00110000
00000000
00000000
00000000
00000000
Output for the Sample Input
E
C
A",Java,"import java.util.*;

public class Main {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        
        while (sc.hasNextLine()) {
            String[][] grid = new String[8][8];
            List<int[]> points = new ArrayList<>();
            
            for (int i = 0; i < 8; i++) {
                String line = sc.nextLine();
                for (int j = 0; j < 8; j++) {
                    grid[i][j] = String.valueOf(line.charAt(j));
                    if (line.charAt(j) == '1') {
                        points.add(new int[]{i, j});
                    }
                }
            }
            
            if (points.size() == 0) break;
            
            // Normalize the shape
            int minRow = Integer.MAX_VALUE;
            int minCol = Integer.MAX_VALUE;
            for (int[] p : points) {
                minRow = Math.min(minRow, p[0]);
                minCol = Math.min(minCol, p[1]);
            }
            
            Set<String> normalized = new HashSet<>();
            for (int[] p : points) {
                normalized.add((p[0] - minRow) + "","" + (p[1] - minCol));
            }
            
            String result = identifyShape(normalized);
            System.out.println(result);
            
            if (sc.hasNextLine()) {
                String blank = sc.nextLine();
            }
        }
        sc.close();
    }
    
    static String identifyShape(Set<String> shape) {
        // Define all shapes
        Map<String, Set<String>> shapes = new HashMap<>();
        
        // A: 2x2 square
        Set<String> a = new HashSet<>();
        a.add(""0,0""); a.add(""0,1""); a.add(""1,0""); a.add(""1,1"");
        shapes.put(""A"", a);
        
        // B: vertical line
        Set<String> b = new HashSet<>();
        b.add(""0,0""); b.add(""1,0""); b.add(""2,0""); b.add(""3,0"");
        shapes.put(""B"", b);
        
        // C: horizontal line
        Set<String> c = new HashSet<>();
        c.add(""0,0""); c.add(""0,1""); c.add(""0,2""); c.add(""0,3"");
        shapes.put(""C"", c);
        
        // D: L shape
        Set<String> d = new HashSet<>();
        d.add(""0,0""); d.add(""1,0""); d.add(""2,0""); d.add(""2,1"");
        shapes.put(""D"", d);
        
        // E: Z shape
        Set<String> e = new HashSet<>();
        e.add(""0,0""); e.add(""0,1""); e.add(""1,1""); e.add(""1,2"");
        shapes.put(""E"", e);
        
        // F: T shape
        Set<String> f = new HashSet<>();
        f.add(""0,0""); f.add(""0,1""); f.add(""0,2""); f.add(""1,1"");
        shapes.put(""F"", f);
        
        // G: small L
        Set<String> g = new HashSet<>();
        g.add(""0,0""); g.add(""1,0""); g.add(""1,1"");
        shapes.put(""G"", g);
        
        // Try all rotations and reflections
        for (String key : shapes.keySet()) {
            Set<String> pattern = shapes.get(key);
            if (matchesWithTransformations(shape, pattern)) {
                return key;
            }
        }
        
        return ""?"";
    }
    
    static boolean matchesWithTransformations(Set<String> shape, Set<String> pattern) {
        Set<String> current = pattern;
        
        for (int rotation = 0; rotation < 4; rotation++) {
            if (matches(shape, current)) return true;
            Set<String> reflected = reflect(current);
            if (matches(shape, reflected)) return true;
            current = rotate90(current);
        }
        
        return false;
    }
    
    static boolean matches(Set<String> shape, Set<String> pattern) {
        Set<String> normalized = normalize(pattern);
        return shape.equals(normalized);
    }
    
    static Set<String> normalize(Set<String> pattern) {
        int minRow = Integer.MAX_VALUE;
        int minCol = Integer.MAX_VALUE;
        
        for (String p : pattern) {
            String[] parts = p.split("","");
            int r = Integer.parseInt(parts[0]);
            int c = Integer.parseInt(parts[1]);
            minRow = Math.min(minRow, r);
            minCol = Math.min(minCol, c);
        }
        
        Set<String> result = new HashSet<>();
        for (String p : pattern) {
            String[] parts = p.split("","");
            int r = Integer.parseInt(parts[0]);
            int c = Integer.parseInt(parts[1]);
            result.add((r - minRow) + "","" + (c - minCol));
        }
        
        return result;
    }
    
    static Set<String> rotate90(Set<String> pattern) {
        Set<String> result = new HashSet<>();
        for (String p : pattern) {
            String[] parts = p.split("","");
            int r = Integer.parseInt(parts[0]);
            int c = Integer.parseInt(parts[1]);
            result.add(c + "","" + (-r));
        }
        return normalize(result);
    }
    
    static Set<String> reflect(Set<String> pattern) {
        Set<String> result = new HashSet<>();
        for (String p : pattern) {
            String[] parts = p.split("","");
            int r = Integer.parseInt(parts[0]);
            int c = Integer.parseInt(parts[1]);
            result.add(r + "","" + (-c));
        }
        return normalize(result);
    }
}
",0
p00036,"平面上の図形
縦 8、横 8 のマスからなる図 1 のような平面があります。
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
図１
この平面上に、以下の A から G の図形のどれかが一つだけ置かれています。
A
■
■
■
■
B
■
■
■
■
C
■
■
■
■
D
■
■
■
■
E
■
■
■
■
F
■
■
■
■
G
■
■
■
■
たとえば、次の図 2 の例では E の図形が置かれています。
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
■
■
□
□
□
□
□
□
□
■
■
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
図２
平面の中で図形が占めているマスを 1、占めていないマスを 0 で表現した数字の列を読み込んで、置かれている図形の種類（A〜G）を出力するプログラムを作成してください。
ただし、ひとつの平面に置かれている図形は必ず１つで、複数の図形が置かれていることはありません。また、A〜G で表される図形以外のものが置かれていることはありません。
Input
入力は複数のデータセットからなります。
１つのデータセットとして、平面の中で図形が占めているマスを 1、占めていないマスを 0 で表現した 8 文字からなる 8 つの文字列が与えられます。例えば、図 2 に対応する文字列の並びは次のようになります。
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
1
1
0
0
0
0
0
0
0
1
1
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
データセットの間は１つの空行で区切られています。データセットの数は 50 を超えません。
Output
各データセットごとに、平面に与えられた図形の種類（A〜G のいずれか）を１行に出力してください。
Sample Input
00000000
00000000
01100000
00110000
00000000
00000000
00000000
00000000

00011110
00000000
00000000
00000000
00000000
00000000
00000000
00000000

00000000
00000000
00110000
00110000
00000000
00000000
00000000
00000000
Output for the Sample Input
E
C
A",Java,"import java.util.Scanner;

public class Main {

	static Scanner sc = new java.util.Scanner(System.in);


	public static void main(String[] args) {

		int[][] num = new int[15][15];
		String str = """";

		while (sc.hasNextLine()) {
			// ?????????
			//syokika(num);
			for (int i = 0; i < 15; i++) {
				for (int j = 0; j < 15; j++) {
					num[i][j] = 0;
				}
			}
			// ???????????¨????????????????´?
			for (int i = 0; i < 8; i++) {
				str = sc.next();
				String[] st = str.split("""");
				for (int j = 0; j < 8; j++) {
					num[i][j] = Integer.parseInt(st[j]);
				}
			}
			// ????????????
			for (int i = 0; i < 8; i++) {
				for (int j = 0; j < 8; j++) {
					if (num[i][j] == 1 && num[i][j + 1] == 1 && num[i + 1][j] == 1 && num[i + 1][j + 1] == 1) {
						System.out.println(""A"");
					} else if (num[i][j] == 1 && num[i + 1][j] == 1 && num[i + 2][j] == 1 && num[i + 3][j] == 1) {
						System.out.println(""B"");
					} else if (num[i][j] == 1 && num[i][j + 1] == 1 && num[i][j + 2] == 1 && num[i][j + 3] == 1) {
						System.out.println(""C"");
					} else if (num[i][j + 1] == 1 && num[i + 1][j] == 1 && num[i][j + 1] == 1 && num[i + 2][j] == 1) {
						System.out.println(""D"");
					} else if (num[i][j] == 1 && num[i][j + 1] == 1 && num[i + 1][j + 1] == 1
							&& num[i + 1][j + 2] == 1) {
						System.out.println(""E"");
					} else if (num[i][j] == 1 && num[i + 1][j] == 1 && num[i + 1][j + 1] == 1
							&& num[i + 2][j + 1] == 1) {
						System.out.println(""F"");
					} else if (num[i][j + 1] == 1 && num[i][j + 2] == 1 && num[i + 1][j] == 1
							&& num[i + 1][j + 1] == 1) {
						System.out.println(""G"");
					}

				}
			}

		}

	}
}",1
p00036,"平面上の図形
縦 8、横 8 のマスからなる図 1 のような平面があります。
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
図１
この平面上に、以下の A から G の図形のどれかが一つだけ置かれています。
A
■
■
■
■
B
■
■
■
■
C
■
■
■
■
D
■
■
■
■
E
■
■
■
■
F
■
■
■
■
G
■
■
■
■
たとえば、次の図 2 の例では E の図形が置かれています。
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
■
■
□
□
□
□
□
□
□
■
■
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
図２
平面の中で図形が占めているマスを 1、占めていないマスを 0 で表現した数字の列を読み込んで、置かれている図形の種類（A〜G）を出力するプログラムを作成してください。
ただし、ひとつの平面に置かれている図形は必ず１つで、複数の図形が置かれていることはありません。また、A〜G で表される図形以外のものが置かれていることはありません。
Input
入力は複数のデータセットからなります。
１つのデータセットとして、平面の中で図形が占めているマスを 1、占めていないマスを 0 で表現した 8 文字からなる 8 つの文字列が与えられます。例えば、図 2 に対応する文字列の並びは次のようになります。
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
1
1
0
0
0
0
0
0
0
1
1
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
データセットの間は１つの空行で区切られています。データセットの数は 50 を超えません。
Output
各データセットごとに、平面に与えられた図形の種類（A〜G のいずれか）を１行に出力してください。
Sample Input
00000000
00000000
01100000
00110000
00000000
00000000
00000000
00000000

00011110
00000000
00000000
00000000
00000000
00000000
00000000
00000000

00000000
00000000
00110000
00110000
00000000
00000000
00000000
00000000
Output for the Sample Input
E
C
A",Python,"import sys

def normalize_shape(points):
    if not points:
        return []
    min_r = min(p[0] for p in points)
    min_c = min(p[1] for p in points)
    normalized = sorted([(r - min_r, c - min_c) for r, c in points])
    return normalized

def get_shape_signature(grid):
    points = []
    for r in range(8):
        for c in range(8):
            if grid[r][c] == '1':
                points.append((r, c))
    return normalize_shape(points)

# Define the shapes A-G
shapes = {
    'A': [(0, 0), (0, 1), (1, 0), (1, 1)],
    'B': [(0, 0), (0, 1), (0, 2), (0, 3)],
    'C': [(0, 0), (0, 1), (0, 2), (0, 3)],
    'D': [(0, 0), (1, 0), (1, 1), (2, 1)],
    'E': [(0, 0), (0, 1), (1, 0), (1, 1)],
    'F': [(0, 1), (1, 0), (1, 1), (2, 0)],
    'G': [(0, 0), (0, 1), (0, 2), (1, 1)]
}

# Generate all rotations and reflections for each shape
def get_all_orientations(points):
    orientations = set()
    pts = points[:]
    
    for _ in range(4):  # 4 rotations
        orientations.add(tuple(normalize_shape(pts)))
        # Rotate 90 degrees clockwise: (r, c) -> (c, -r)
        pts = [(c, -r) for r, c in pts]
    
    # Mirror horizontally
    pts = [(r, -c) for r, c in points]
    for _ in range(4):  # 4 rotations of mirrored
        orientations.add(tuple(normalize_shape(pts)))
        pts = [(c, -r) for r, c in pts]
    
    return orientations

shape_orientations = {}
for name, shape in shapes.items():
    shape_orientations[name] = get_all_orientations(shape)

def identify_shape(grid):
    sig = tuple(get_shape_signature(grid))
    
    for name, orientations in shape_orientations.items():
        if sig in orientations:
            return name
    
    return None

# Read input
lines = []
for line in sys.stdin:
    lines.append(line.rstrip('\n'))

# Process datasets
i = 0
while i < len(lines):
    grid = []
    while i < len(lines) and lines[i] != '':
        grid.append(lines[i])
        i += 1
    
    if len(grid) == 8:
        result = identify_shape(grid)
        print(result)
    
    i += 1  # Skip empty line
",0
p00036,"平面上の図形
縦 8、横 8 のマスからなる図 1 のような平面があります。
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
図１
この平面上に、以下の A から G の図形のどれかが一つだけ置かれています。
A
■
■
■
■
B
■
■
■
■
C
■
■
■
■
D
■
■
■
■
E
■
■
■
■
F
■
■
■
■
G
■
■
■
■
たとえば、次の図 2 の例では E の図形が置かれています。
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
■
■
□
□
□
□
□
□
□
■
■
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
図２
平面の中で図形が占めているマスを 1、占めていないマスを 0 で表現した数字の列を読み込んで、置かれている図形の種類（A〜G）を出力するプログラムを作成してください。
ただし、ひとつの平面に置かれている図形は必ず１つで、複数の図形が置かれていることはありません。また、A〜G で表される図形以外のものが置かれていることはありません。
Input
入力は複数のデータセットからなります。
１つのデータセットとして、平面の中で図形が占めているマスを 1、占めていないマスを 0 で表現した 8 文字からなる 8 つの文字列が与えられます。例えば、図 2 に対応する文字列の並びは次のようになります。
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
1
1
0
0
0
0
0
0
0
1
1
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
データセットの間は１つの空行で区切られています。データセットの数は 50 を超えません。
Output
各データセットごとに、平面に与えられた図形の種類（A〜G のいずれか）を１行に出力してください。
Sample Input
00000000
00000000
01100000
00110000
00000000
00000000
00000000
00000000

00011110
00000000
00000000
00000000
00000000
00000000
00000000
00000000

00000000
00000000
00110000
00110000
00000000
00000000
00000000
00000000
Output for the Sample Input
E
C
A",Python,"import sys;import re
for s in sys.stdin.read().split('\n\n'):print 'BCD F GAE'[len(re.findall('1.*1',s.replace('\n',''))[0])%12-3]",1
p00037,"格子上の経路
上から見ると図 1 のような形の格子状の広場があります。この格子の各辺に「壁」があるかないかを 0 と 1 の並びで表します。点 A に立って壁に右手をつき、壁に右手をついたまま、矢印の方向に歩き続けて再び点 A に戻ってくるまでの経路を出力するプログラムを作成してください。
図1
Input
入力は９行からなり、以下の図 2 に示すように、壁がある場合を 1、ない場合を 0 として、以下の形式で与えられます。
1 行目は一番上の横線の壁の有無を左から 0 と 1 で表した文字列
2 行目はその下の縦線の壁の有無を左から0 と1 で表した文字列
3 行目は上から2 本目の横線の壁の有無を左から0 と1 で表した文字列
...
9 行目は一番下の横線の壁の有無を左から0 と1 で表した文字列
図2 (壁あるところを太線で表しています)　　(対応する数字のならび)
ただし、図１の太線に示すように、点 A から右に 1 区画分は必ず壁があるものとします。すなわち、1 行目の 1 文字目は常に 1 です。
Output
「図の左方向に一区画分進む」を '
L
'、「図の右方向に一区画分進む」を '
R
'、「図の上方向に一区画分進む」を '
U
'、「図の下方向に一区画分進む」を '
D
' で表わし、進む順に '
L
', '
R
', '
U
', '
D
' を１行に並べて出力します。
Sample Input
1111
00001
0110
01011
0010
01111
0010
01001
0111
Output for the Sample Input
RRRRDDDDLLLUUURRDDLURULLDDDRRRUUUULLLL",C,"#include <stdio.h>
#include <string.h>

int main() {
    char h[5][5]; // horizontal walls
    char v[4][5]; // vertical walls
    char input[10];
    
    // Read input
    for (int i = 0; i < 9; i++) {
        scanf(""%s"", input);
        if (i % 2 == 0) {
            // horizontal walls
            int row = i / 2;
            strcpy(h[row], input);
        } else {
            // vertical walls
            int row = i / 2;
            strcpy(v[row], input);
        }
    }
    
    // Start at point A (0,0), facing right (east)
    int x = 0, y = 0;
    int dir = 0; // 0=East, 1=South, 2=West, 3=North
    char dirChars[] = {'R', 'D', 'L', 'U'};
    
    // Direction vectors: dx[dir], dy[dir]
    int dx[] = {1, 0, -1, 0};
    int dy[] = {0, 1, 0, -1};
    
    char path[10000];
    int pathLen = 0;
    
    // Right-hand rule: keep wall on right
    do {
        // Try to turn right first
        int rightDir = (dir + 3) % 4; // turn right
        int rightX = x + dx[rightDir];
        int rightY = y + dy[rightDir];
        
        // Check if we can move right
        int canMoveRight = 0;
        if (rightX >= 0 && rightX <= 4 && rightY >= 0 && rightY <= 4) {
            if (rightDir == 0 && rightX <= 4 && v[y][x] == '0') canMoveRight = 1;
            else if (rightDir == 1 && rightY <= 4 && h[y][x] == '0') canMoveRight = 1;
            else if (rightDir == 2 && rightX >= 0 && v[y][rightX] == '0') canMoveRight = 1;
            else if (rightDir == 3 && rightY >= 0 && h[rightY][x] == '0') canMoveRight = 1;
        }
        
        if (canMoveRight) {
            dir = rightDir;
            x = rightX;
            y = rightY;
            path[pathLen++] = dirChars[dir];
        } else {
            // Try to move forward
            int fwdX = x + dx[dir];
            int fwdY = y + dy[dir];
            
            int canMoveFwd = 0;
            if (fwdX >= 0 && fwdX <= 4 && fwdY >= 0 && fwdY <= 4) {
                if (dir == 0 && fwdX <= 4 && v[y][x] == '0') canMoveFwd = 1;
                else if (dir == 1 && fwdY <= 4 && h[y][x] == '0') canMoveFwd = 1;
                else if (dir == 2 && fwdX >= 0 && v[y][fwdX] == '0') canMoveFwd = 1;
                else if (dir == 3 && fwdY >= 0 && h[fwdY][x] == '0') canMoveFwd = 1;
            }
            
            if (canMoveFwd) {
                x = fwdX;
                y = fwdY;
                path[pathLen++] = dirChars[dir];
            } else {
                // Turn left
                dir = (dir + 1) % 4;
            }
        }
    } while (!(x == 0 && y == 0 && dir == 0));
    
    path[pathLen] = '\0';
    printf(""%s\n"", path);
    
    return 0;
}
",0
p00037,"格子上の経路
上から見ると図 1 のような形の格子状の広場があります。この格子の各辺に「壁」があるかないかを 0 と 1 の並びで表します。点 A に立って壁に右手をつき、壁に右手をついたまま、矢印の方向に歩き続けて再び点 A に戻ってくるまでの経路を出力するプログラムを作成してください。
図1
Input
入力は９行からなり、以下の図 2 に示すように、壁がある場合を 1、ない場合を 0 として、以下の形式で与えられます。
1 行目は一番上の横線の壁の有無を左から 0 と 1 で表した文字列
2 行目はその下の縦線の壁の有無を左から0 と1 で表した文字列
3 行目は上から2 本目の横線の壁の有無を左から0 と1 で表した文字列
...
9 行目は一番下の横線の壁の有無を左から0 と1 で表した文字列
図2 (壁あるところを太線で表しています)　　(対応する数字のならび)
ただし、図１の太線に示すように、点 A から右に 1 区画分は必ず壁があるものとします。すなわち、1 行目の 1 文字目は常に 1 です。
Output
「図の左方向に一区画分進む」を '
L
'、「図の右方向に一区画分進む」を '
R
'、「図の上方向に一区画分進む」を '
U
'、「図の下方向に一区画分進む」を '
D
' で表わし、進む順に '
L
', '
R
', '
U
', '
D
' を１行に並べて出力します。
Sample Input
1111
00001
0110
01011
0010
01111
0010
01001
0111
Output for the Sample Input
RRRRDDDDLLLUUURRDDLURULLDDDRRRUUUULLLL",C,"#include<stdio.h>
int main(void){
  int tate[8][4],yoko[8][3];
  int h,i,j,k,x=0,y=0;
  for(i=0;i<9;i++){
    if(i%2==0){
      scanf(""%1d%1d%1d%1d"",&yoko[i][0],&yoko[i][1],&yoko[i][2],&yoko[i][3]);
      yoko[i][4]=0;   
    }else{  
      scanf(""%1d%1d%1d%1d%1d"",&tate[i][0],&tate[i][1],&tate[i][2],&tate[i][3],&tate[i][4]);
      tate[i][5]=0;
    }
  }

  //printf(""----------------------------------------\n"");
       for(k=0;k<=9;k++){
       if(k%2==0){
	 //printf(""%d%d%d%d%d\n"",yoko[k][0],yoko[k][1],yoko[k][2],yoko[k][3],yoko[k][4]);
       }else{
	 //printf(""%d%d%d%d%d%d\n"",tate[k][0],tate[k][1],tate[k][2],tate[k][3],tate[k][4],tate[k][5]);
       }
       }
  

 
  int sl=1;
  printf(""R"");
  do{
   
    switch(sl){
    case 1:
      //printf(""x=%d:y=%d\n"",x,y);
      //printf(""tate74=%d\n"",tate[7][4]);

      if(tate[y-1][x+1]==1&&y>0){
	x++;
	y--;
	sl=4;
      }else if(yoko[y][x+1]==1&&x<3){
	//printf(""ok\n"");
	x++;
	sl=1;
	//printf(""s=%d"",s);
      }else if(tate[y+1][x+1]==1&&y<8){
	x++;
	y++;
	
	sl=2;
      }
      // printf(""tate74=%d\n"",tate[7][4]);

      break;

    case 2:
      //printf(""x=%d:y=%d\n"",x,y);
      //printf(""%d %d\n"",x+1,y+2);
      //printf(""tate74=%d\n"",tate[7][4]);
      if(yoko[y+1][x]==1&&x<3){
	y++;sl=1;
      }else if(tate[y+2][x]==1&&y<8){
	y=y+2;sl=2;
      }else if(yoko[y+1][x-1]==1&&x>0){
	y++;
	x--;
	sl=3;
      }
      break;


    case 3:
      //printf(""x=%d:y=%d\n"",x,y);
       if(tate[y+1][x]==1&&y<8){
	sl=2;y++;
      }else if(yoko[y][x-1]==1&&x>0){
	x--;sl=3;
      }else if(tate[y-1][x]==1&&y>0){
	y--;sl=4;
      }
      break;


    case 4:
      // printf(""x=%d:y=%d\n"",x,y);
      if(yoko[y-1][x-1]==1&&x>0){
	x--;y--;sl=3;
      }else if(tate[y-2][x]==1&&y>0){
	y=y-2;sl=4;
      }else if(yoko[y-1][x]==1&&x<3){
	y--;sl=1;
      }
      break;


    }
    //printf(""sl=%d\n"",sl);
    if(sl==1)printf(""R"");
    if(sl==2)printf(""D"");
    if(sl==3)printf(""L"");
    if(sl==4)printf(""U"");
    //printf(""tate74=%d\n"",tate[7][4]);
    //printf(""\n"");
   
   
  }while(x!=0||y!=0);
  printf(""\n"");
  return 0;
  
}",1
p00037,"格子上の経路
上から見ると図 1 のような形の格子状の広場があります。この格子の各辺に「壁」があるかないかを 0 と 1 の並びで表します。点 A に立って壁に右手をつき、壁に右手をついたまま、矢印の方向に歩き続けて再び点 A に戻ってくるまでの経路を出力するプログラムを作成してください。
図1
Input
入力は９行からなり、以下の図 2 に示すように、壁がある場合を 1、ない場合を 0 として、以下の形式で与えられます。
1 行目は一番上の横線の壁の有無を左から 0 と 1 で表した文字列
2 行目はその下の縦線の壁の有無を左から0 と1 で表した文字列
3 行目は上から2 本目の横線の壁の有無を左から0 と1 で表した文字列
...
9 行目は一番下の横線の壁の有無を左から0 と1 で表した文字列
図2 (壁あるところを太線で表しています)　　(対応する数字のならび)
ただし、図１の太線に示すように、点 A から右に 1 区画分は必ず壁があるものとします。すなわち、1 行目の 1 文字目は常に 1 です。
Output
「図の左方向に一区画分進む」を '
L
'、「図の右方向に一区画分進む」を '
R
'、「図の上方向に一区画分進む」を '
U
'、「図の下方向に一区画分進む」を '
D
' で表わし、進む順に '
L
', '
R
', '
U
', '
D
' を１行に並べて出力します。
Sample Input
1111
00001
0110
01011
0010
01111
0010
01001
0111
Output for the Sample Input
RRRRDDDDLLLUUURRDDLURULLDDDRRRUUUULLLL",Java,"import java.util.*;

public class Main {
    static class State {
        int row, col;
        int dir; // 0=right, 1=down, 2=left, 3=up
        
        State(int row, int col, int dir) {
            this.row = row;
            this.col = col;
            this.dir = dir;
        }
    }
    
    static int[][] horizontal = new int[5][4]; // 5 horizontal lines, 4 segments each
    static int[][] vertical = new int[4][5]; // 4 vertical lines, 5 segments each
    
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        
        // Read horizontal walls
        for (int i = 0; i < 5; i++) {
            String line = sc.nextLine();
            for (int j = 0; j < 4; j++) {
                horizontal[i][j] = line.charAt(j) - '0';
            }
        }
        
        // Read vertical walls
        for (int i = 0; i < 4; i++) {
            String line = sc.nextLine();
            for (int j = 0; j < 5; j++) {
                vertical[i][j] = line.charAt(j) - '0';
            }
        }
        
        // Start at position (0,0), facing right (dir=0)
        // Right hand is on the wall above (horizontal[0][0] = 1)
        State state = new State(0, 0, 0);
        StringBuilder result = new StringBuilder();
        
        do {
            // Try to turn right first (right-hand rule)
            int rightDir = (state.dir + 3) % 4; // Turn right
            
            if (canMove(state.row, state.col, rightDir)) {
                // Turn right and move
                state.dir = rightDir;
                move(state, result);
            } else if (canMove(state.row, state.col, state.dir)) {
                // Move straight
                move(state, result);
            } else {
                // Turn left
                state.dir = (state.dir + 1) % 4;
            }
        } while (!(state.row == 0 && state.col == 0 && state.dir == 0));
        
        System.out.println(result.toString());
    }
    
    static boolean canMove(int row, int col, int dir) {
        if (dir == 0) { // Right
            if (col >= 4) return false;
            return vertical[col][row] == 0;
        } else if (dir == 1) { // Down
            if (row >= 4) return false;
            return horizontal[row + 1][col] == 0;
        } else if (dir == 2) { // Left
            if (col <= 0) return false;
            return vertical[col - 1][row] == 0;
        } else { // Up
            if (row <= 0) return false;
            return horizontal[row][col] == 0;
        }
    }
    
    static void move(State state, StringBuilder result) {
        if (state.dir == 0) { // Right
            result.append('R');
            state.col++;
        } else if (state.dir == 1) { // Down
            result.append('D');
            state.row++;
        } else if (state.dir == 2) { // Left
            result.append('L');
            state.col--;
        } else { // Up
            result.append('U');
            state.row--;
        }
    }
}
",0
p00037,"格子上の経路
上から見ると図 1 のような形の格子状の広場があります。この格子の各辺に「壁」があるかないかを 0 と 1 の並びで表します。点 A に立って壁に右手をつき、壁に右手をついたまま、矢印の方向に歩き続けて再び点 A に戻ってくるまでの経路を出力するプログラムを作成してください。
図1
Input
入力は９行からなり、以下の図 2 に示すように、壁がある場合を 1、ない場合を 0 として、以下の形式で与えられます。
1 行目は一番上の横線の壁の有無を左から 0 と 1 で表した文字列
2 行目はその下の縦線の壁の有無を左から0 と1 で表した文字列
3 行目は上から2 本目の横線の壁の有無を左から0 と1 で表した文字列
...
9 行目は一番下の横線の壁の有無を左から0 と1 で表した文字列
図2 (壁あるところを太線で表しています)　　(対応する数字のならび)
ただし、図１の太線に示すように、点 A から右に 1 区画分は必ず壁があるものとします。すなわち、1 行目の 1 文字目は常に 1 です。
Output
「図の左方向に一区画分進む」を '
L
'、「図の右方向に一区画分進む」を '
R
'、「図の上方向に一区画分進む」を '
U
'、「図の下方向に一区画分進む」を '
D
' で表わし、進む順に '
L
', '
R
', '
U
', '
D
' を１行に並べて出力します。
Sample Input
1111
00001
0110
01011
0010
01111
0010
01001
0111
Output for the Sample Input
RRRRDDDDLLLUUURRDDLURULLDDDRRRUUUULLLL",Java,"import java.util.*;
import static java.util.Arrays.*;
import static java.lang.Math.*;

// AOJ 0037
public class Main {

	static Scanner sc = new Scanner(System.in);
	static final double EPS = 1e-10;
	public static void main(String[] args) {
		char[][] cs = new char[20][1000];
		for (int i = 0; i < 20; i++) fill(cs[i], '0');
		
		for (int i = 0; i < 9; i++) {
			String buf = sc.next();
			for (int j = 0; j < buf.length(); j++) {
				if (i % 2 == 0) {
					cs[i + 1][j * 2 + 2] = buf.charAt(j);
				} else {
					cs[i + 1][j * 2 + 1] = buf.charAt(j);
				}
			}
			
		}

		int[] dx = {1, 0, -1, 0}, dy = {0, 1, 0, -1};
		String[] str = {""R"", ""D"", ""L"", ""U""}; 
		int x = 1, y = 1, d = 0;
		while (!(x == 1 && y == 1 && d == 2)) {
			if (cs[y + dy[d]][x + dx[d]] == '1') {
				x += dx[d] * 2; 
				y += dy[d] * 2;
				System.out.print(str[d]);
			} else {
				
				if (cs[y + dy[(d - 1 + 4) % 4]][x + dx[(d - 1 + 4) % 4]] == '1') {
					d = (d - 1 + 4) % 4;					
				} else {
					d = (d + 1) % 4;
				}

				
			}
		}
		System.out.println();
		
	}
}",1
p00037,"格子上の経路
上から見ると図 1 のような形の格子状の広場があります。この格子の各辺に「壁」があるかないかを 0 と 1 の並びで表します。点 A に立って壁に右手をつき、壁に右手をついたまま、矢印の方向に歩き続けて再び点 A に戻ってくるまでの経路を出力するプログラムを作成してください。
図1
Input
入力は９行からなり、以下の図 2 に示すように、壁がある場合を 1、ない場合を 0 として、以下の形式で与えられます。
1 行目は一番上の横線の壁の有無を左から 0 と 1 で表した文字列
2 行目はその下の縦線の壁の有無を左から0 と1 で表した文字列
3 行目は上から2 本目の横線の壁の有無を左から0 と1 で表した文字列
...
9 行目は一番下の横線の壁の有無を左から0 と1 で表した文字列
図2 (壁あるところを太線で表しています)　　(対応する数字のならび)
ただし、図１の太線に示すように、点 A から右に 1 区画分は必ず壁があるものとします。すなわち、1 行目の 1 文字目は常に 1 です。
Output
「図の左方向に一区画分進む」を '
L
'、「図の右方向に一区画分進む」を '
R
'、「図の上方向に一区画分進む」を '
U
'、「図の下方向に一区画分進む」を '
D
' で表わし、進む順に '
L
', '
R
', '
U
', '
D
' を１行に並べて出力します。
Sample Input
1111
00001
0110
01011
0010
01111
0010
01001
0111
Output for the Sample Input
RRRRDDDDLLLUUURRDDLURULLDDDRRRUUUULLLL",Python,"def solve():
    # Read input
    lines = []
    for _ in range(9):
        lines.append(input().strip())
    
    # Parse walls
    # h_walls[i][j] = horizontal wall between row i and i+1, at column j
    # v_walls[i][j] = vertical wall between column j and j+1, at row i
    h_walls = []
    v_walls = []
    
    for i in range(9):
        if i % 2 == 0:  # horizontal walls
            h_walls.append([int(c) for c in lines[i]])
        else:  # vertical walls
            v_walls.append([int(c) for c in lines[i]])
    
    # Start at point A (top-left corner, position (0, 0))
    # Initial direction: facing right (since we start by going right with wall on right)
    # Directions: 0=Right, 1=Down, 2=Left, 3=Up
    pos = (0, 0)
    direction = 0  # facing right
    path = []
    
    # Direction vectors
    dx = [1, 0, -1, 0]  # Right, Down, Left, Up
    dy = [0, 1, 0, -1]
    dir_chars = ['R', 'D', 'L', 'U']
    
    def has_wall(r, c, d):
        """"""Check if there's a wall when moving from (r,c) in direction d""""""
        if d == 0:  # Right
            if c >= len(v_walls[0]):
                return True
            return v_walls[r][c] == 1
        elif d == 1:  # Down
            if r >= len(h_walls) - 1:
                return True
            return h_walls[r + 1][c] == 1
        elif d == 2:  # Left
            if c == 0:
                return True
            return v_walls[r][c - 1] == 1
        else:  # Up (d == 3)
            if r == 0:
                return True
            return h_walls[r][c] == 1
    
    while True:
        # Try to turn right first (right-hand rule)
        right_dir = (direction - 1) % 4
        
        # Check if we can go right
        if not has_wall(pos[1], pos[0], right_dir):
            # Turn right and move
            direction = right_dir
            pos = (pos[0] + dx[direction], pos[1] + dy[direction])
            path.append(dir_chars[direction])
        # Check if we can go straight
        elif not has_wall(pos[1], pos[0], direction):
            # Move straight
            pos = (pos[0] + dx[direction], pos[1] + dy[direction])
            path.append(dir_chars[direction])
        else:
            # Turn left
            direction = (direction + 1) % 4
            continue
        
        # Check if we're back at start
        if pos == (0, 0) and len(path) > 0:
            break
    
    print(''.join(path))

solve()
",0
p00037,"格子上の経路
上から見ると図 1 のような形の格子状の広場があります。この格子の各辺に「壁」があるかないかを 0 と 1 の並びで表します。点 A に立って壁に右手をつき、壁に右手をついたまま、矢印の方向に歩き続けて再び点 A に戻ってくるまでの経路を出力するプログラムを作成してください。
図1
Input
入力は９行からなり、以下の図 2 に示すように、壁がある場合を 1、ない場合を 0 として、以下の形式で与えられます。
1 行目は一番上の横線の壁の有無を左から 0 と 1 で表した文字列
2 行目はその下の縦線の壁の有無を左から0 と1 で表した文字列
3 行目は上から2 本目の横線の壁の有無を左から0 と1 で表した文字列
...
9 行目は一番下の横線の壁の有無を左から0 と1 で表した文字列
図2 (壁あるところを太線で表しています)　　(対応する数字のならび)
ただし、図１の太線に示すように、点 A から右に 1 区画分は必ず壁があるものとします。すなわち、1 行目の 1 文字目は常に 1 です。
Output
「図の左方向に一区画分進む」を '
L
'、「図の右方向に一区画分進む」を '
R
'、「図の上方向に一区画分進む」を '
U
'、「図の下方向に一区画分進む」を '
D
' で表わし、進む順に '
L
', '
R
', '
U
', '
D
' を１行に並べて出力します。
Sample Input
1111
00001
0110
01011
0010
01111
0010
01001
0111
Output for the Sample Input
RRRRDDDDLLLUUURRDDLURULLDDDRRRUUUULLLL",Python,"path = [[[] for i in range(5)] for i in range(5)]
for i in range(9):
    if i%2 == 0:
        a = [int(i) for i in list(input())]
        for j in range(4):
            if a[j] == 1:
                path[int(i/2)][j].append(""R"")
                path[int(i/2)][j+1].append(""L"")
    else:
        a = [int(i) for i in list(input())]
        for j in range(5):
            if a[j] == 1:
                path[int(i/2)][j].append(""D"")
                path[int(i/2)+1][j].append(""U"")

prev = ""R""
p = ""R""
x = 0
y = 0
while(1):
    if prev == ""R"":
        if ""U"" in path[x][y]:
            x -= 1
            prev = ""U""
            p += ""U""
        elif ""R"" in path[x][y]:
            y += 1
            prev = ""R""
            p += ""R""
        elif ""D"" in path[x][y]:
            x += 1
            prev = ""D""
            p += ""D""
        elif ""L"" in path[x][y]:
            y -= 1
            prev = ""L""
            p += ""L""
    elif prev == ""L"":
        if ""D"" in path[x][y]:
            x += 1
            prev = ""D""
            p += ""D""
        elif ""L"" in path[x][y]:
            y -= 1
            prev = ""L""
            p += ""L""
        elif ""U"" in path[x][y]:
            x -= 1
            prev = ""U""
            p += ""U""
        elif ""R"" in path[x][y]:
            y += 1
            prev = ""R""
            p += ""R""
    elif prev == ""U"":
        if ""L"" in path[x][y]:
            y -= 1
            prev = ""L""
            p += ""L""
        elif ""U"" in path[x][y]:
            x -= 1
            prev = ""U""
            p += ""U""
        elif ""R"" in path[x][y]:
            y += 1
            prev = ""R""
            p += ""R""
        elif ""D"" in path[x][y]:
            x += 1
            prev = ""D""
            p += ""D""
    elif prev == ""D"":
        if ""R"" in path[x][y]:
            y += 1
            prev = ""R""
            p += ""R""
        elif ""D"" in path[x][y]:
            x += 1
            prev = ""D""
            p += ""D""
        elif ""L"" in path[x][y]:
            y -= 1
            prev = ""L""
            p += ""L""
        elif ""U"" in path[x][y]:
            x -= 1
            prev = ""U""
            p += ""U""
    if x == 0 and y == 0:
        break
print(p[1:])


    

",1
p00038,"ポーカー
ポーカーの手札データを読み込んで、それぞれについてその役を出力するプログラムを作成してください。ただし、この問題では、以下のルールに従います。
ポーカーはトランプ 5 枚で行う競技です。
同じ数字のカードは 5 枚以上ありません。
ジョーカーは無いものとします。
以下のポーカーの役だけを考えるものとします。(番号が大きいほど役が高くなります。)
役なし(以下に挙げるどれにも当てはまらない)
ワンペア（2 枚の同じ数字のカードが1 組ある）
ツーペア（2 枚の同じ数字のカードが2 組ある）
スリーカード（3 枚の同じ数字のカードが1 組ある）
ストレート（5 枚のカードの数字が連続している）
ただし、A を含むストレートの場合、A で終わる並びもストレートとします。つまり、A を含むストレート
は、A 2 3 4 5 　と　10 J Q K A 　の２種類です。J Q K A 2 などのように、A をまたぐ並び
はストレートではありません。（この場合、「役なし」になります）。
フルハウス（3 枚の同じ数字のカードが1 組と、残りの2 枚が同じ数字のカード）
フォーカード（4 枚の同じ数字のカードが1 組ある）
Input
入力は複数のデータセットからなります。各データセットは以下の形式で与えられます。
手札1,手札2,手札3,手札4,手札5
手札は、トランプのJ(ジャック) を11、Q(クイーン) を12、K(キング) を13、A（エース）を 1、その他はそれぞれの数字で表すこととします。
データセットの数は 50 を超えません。
Output
データセットごとに、手札によってできる最も高い役をひとつ出力してください。役の表記については出力例に従ってください。
Sample Input
1,2,3,4,1
2,3,2,3,12
12,13,11,12,12
7,6,7,6,7
3,3,2,3,3
6,7,8,9,10
11,12,10,1,13
11,12,13,1,2
Output for the Sample Input
one pair
two pair
three card
full house
four card
straight
straight
null
3 3 2 3 3 という手札であったときは、two pair ではなく four card です。",C,"#include <stdio.h>
#include <stdlib.h>
#include <string.h>

int compare(const void *a, const void *b) {
    return (*(int*)a - *(int*)b);
}

int main() {
    char line[100];
    
    while (fgets(line, sizeof(line), stdin)) {
        int cards[5];
        sscanf(line, ""%d,%d,%d,%d,%d"", &cards[0], &cards[1], &cards[2], &cards[3], &cards[4]);
        
        // Count frequency of each card value
        int count[14] = {0};
        for (int i = 0; i < 5; i++) {
            count[cards[i]]++;
        }
        
        // Check for pairs, three of a kind, four of a kind
        int pairs = 0, threes = 0, fours = 0;
        for (int i = 1; i <= 13; i++) {
            if (count[i] == 2) pairs++;
            else if (count[i] == 3) threes++;
            else if (count[i] == 4) fours++;
        }
        
        // Check for straight
        qsort(cards, 5, sizeof(int), compare);
        int is_straight = 0;
        
        // Normal straight
        if (cards[1] == cards[0] + 1 && 
            cards[2] == cards[1] + 1 && 
            cards[3] == cards[2] + 1 && 
            cards[4] == cards[3] + 1) {
            is_straight = 1;
        }
        
        // A-2-3-4-5 straight
        if (cards[0] == 1 && cards[1] == 2 && cards[2] == 3 && 
            cards[3] == 4 && cards[4] == 5) {
            is_straight = 1;
        }
        
        // 10-J-Q-K-A straight
        if (cards[0] == 1 && cards[1] == 10 && cards[2] == 11 && 
            cards[3] == 12 && cards[4] == 13) {
            is_straight = 1;
        }
        
        // Determine the hand
        if (fours > 0) {
            printf(""four card\n"");
        } else if (threes > 0 && pairs > 0) {
            printf(""full house\n"");
        } else if (is_straight) {
            printf(""straight\n"");
        } else if (threes > 0) {
            printf(""three card\n"");
        } else if (pairs == 2) {
            printf(""two pair\n"");
        } else if (pairs == 1) {
            printf(""one pair\n"");
        } else {
            printf(""null\n"");
        }
    }
    
    return 0;
}
",0
p00038,"ポーカー
ポーカーの手札データを読み込んで、それぞれについてその役を出力するプログラムを作成してください。ただし、この問題では、以下のルールに従います。
ポーカーはトランプ 5 枚で行う競技です。
同じ数字のカードは 5 枚以上ありません。
ジョーカーは無いものとします。
以下のポーカーの役だけを考えるものとします。(番号が大きいほど役が高くなります。)
役なし(以下に挙げるどれにも当てはまらない)
ワンペア（2 枚の同じ数字のカードが1 組ある）
ツーペア（2 枚の同じ数字のカードが2 組ある）
スリーカード（3 枚の同じ数字のカードが1 組ある）
ストレート（5 枚のカードの数字が連続している）
ただし、A を含むストレートの場合、A で終わる並びもストレートとします。つまり、A を含むストレート
は、A 2 3 4 5 　と　10 J Q K A 　の２種類です。J Q K A 2 などのように、A をまたぐ並び
はストレートではありません。（この場合、「役なし」になります）。
フルハウス（3 枚の同じ数字のカードが1 組と、残りの2 枚が同じ数字のカード）
フォーカード（4 枚の同じ数字のカードが1 組ある）
Input
入力は複数のデータセットからなります。各データセットは以下の形式で与えられます。
手札1,手札2,手札3,手札4,手札5
手札は、トランプのJ(ジャック) を11、Q(クイーン) を12、K(キング) を13、A（エース）を 1、その他はそれぞれの数字で表すこととします。
データセットの数は 50 を超えません。
Output
データセットごとに、手札によってできる最も高い役をひとつ出力してください。役の表記については出力例に従ってください。
Sample Input
1,2,3,4,1
2,3,2,3,12
12,13,11,12,12
7,6,7,6,7
3,3,2,3,3
6,7,8,9,10
11,12,10,1,13
11,12,13,1,2
Output for the Sample Input
one pair
two pair
three card
full house
four card
straight
straight
null
3 3 2 3 3 という手札であったときは、two pair ではなく four card です。",C,"#include <stdio.h>

int isstraight(int[5]);

int main(void) {
	int cards[5];
	int i,j,temp;
	int yaku;
	char yakuname[7][11]={""null"",""one pair"",""two pair"",""three card"",
						""straight"",""full house"",""four card""};
	while(1) {
		if(scanf(""%d,%d,%d,%d,%d"",
			&cards[0],&cards[1],&cards[2],&cards[3],&cards[4])==-1)break;
		for(i=4;i>0;i--) {
			for(j=0;j<i;j++) {
				if(cards[j]>cards[j+1]) {
					temp=cards[j];
					cards[j]=cards[j+1];
					cards[j+1]=temp;
				}
			}
		}
		yaku=0;
		if(cards[1]==cards[2] && cards[2]==cards[3]) {
			if(cards[0]==cards[1] || cards[3]==cards[4])yaku=6;
			else yaku=3;
		} else if(cards[0]==cards[1] && cards[1]==cards[2]) {
			if(cards[3]==cards[4])yaku=5; else yaku=3;
		} else if(cards[2]==cards[3] && cards[3]==cards[4]) {
			if(cards[0]==cards[1])yaku=5; else yaku=3;
		} else if(isstraight(cards))yaku=4;
		else {
			for(i=0;i<4;i++) {
				if(cards[i]==cards[i+1])yaku++;
			}
		}
		printf(""%s\n"",yakuname[yaku]);
	}
	return 0;
}

int isstraight(int cards[5]) {
	int i;
	for(i=0;i<4;i++) {
		if(cards[i]+1!=cards[i+1])break;
	}
	if(i<4) {
		if(cards[0]==1 && cards[1]==10 && cards[2]==11 &&
			cards[3]==12 && cards[4]==13)return 1; else return 0;
	} else return 1;
}",1
p00038,"ポーカー
ポーカーの手札データを読み込んで、それぞれについてその役を出力するプログラムを作成してください。ただし、この問題では、以下のルールに従います。
ポーカーはトランプ 5 枚で行う競技です。
同じ数字のカードは 5 枚以上ありません。
ジョーカーは無いものとします。
以下のポーカーの役だけを考えるものとします。(番号が大きいほど役が高くなります。)
役なし(以下に挙げるどれにも当てはまらない)
ワンペア（2 枚の同じ数字のカードが1 組ある）
ツーペア（2 枚の同じ数字のカードが2 組ある）
スリーカード（3 枚の同じ数字のカードが1 組ある）
ストレート（5 枚のカードの数字が連続している）
ただし、A を含むストレートの場合、A で終わる並びもストレートとします。つまり、A を含むストレート
は、A 2 3 4 5 　と　10 J Q K A 　の２種類です。J Q K A 2 などのように、A をまたぐ並び
はストレートではありません。（この場合、「役なし」になります）。
フルハウス（3 枚の同じ数字のカードが1 組と、残りの2 枚が同じ数字のカード）
フォーカード（4 枚の同じ数字のカードが1 組ある）
Input
入力は複数のデータセットからなります。各データセットは以下の形式で与えられます。
手札1,手札2,手札3,手札4,手札5
手札は、トランプのJ(ジャック) を11、Q(クイーン) を12、K(キング) を13、A（エース）を 1、その他はそれぞれの数字で表すこととします。
データセットの数は 50 を超えません。
Output
データセットごとに、手札によってできる最も高い役をひとつ出力してください。役の表記については出力例に従ってください。
Sample Input
1,2,3,4,1
2,3,2,3,12
12,13,11,12,12
7,6,7,6,7
3,3,2,3,3
6,7,8,9,10
11,12,10,1,13
11,12,13,1,2
Output for the Sample Input
one pair
two pair
three card
full house
four card
straight
straight
null
3 3 2 3 3 という手札であったときは、two pair ではなく four card です。",Java,"import java.util.*;

public class Main {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        
        while (sc.hasNextLine()) {
            String line = sc.nextLine().trim();
            if (line.isEmpty()) break;
            
            String[] cards = line.split("","");
            int[] hand = new int[5];
            for (int i = 0; i < 5; i++) {
                hand[i] = Integer.parseInt(cards[i]);
            }
            
            System.out.println(evaluateHand(hand));
        }
        
        sc.close();
    }
    
    static String evaluateHand(int[] hand) {
        int[] count = new int[14];
        for (int card : hand) {
            count[card]++;
        }
        
        // Check for four card
        for (int i = 1; i <= 13; i++) {
            if (count[i] == 4) {
                return ""four card"";
            }
        }
        
        // Check for full house
        boolean hasThree = false;
        boolean hasTwo = false;
        for (int i = 1; i <= 13; i++) {
            if (count[i] == 3) hasThree = true;
            if (count[i] == 2) hasTwo = true;
        }
        if (hasThree && hasTwo) {
            return ""full house"";
        }
        
        // Check for straight
        if (isStraight(hand)) {
            return ""straight"";
        }
        
        // Check for three card
        if (hasThree) {
            return ""three card"";
        }
        
        // Check for two pair
        int pairCount = 0;
        for (int i = 1; i <= 13; i++) {
            if (count[i] == 2) pairCount++;
        }
        if (pairCount == 2) {
            return ""two pair"";
        }
        
        // Check for one pair
        if (pairCount == 1) {
            return ""one pair"";
        }
        
        return ""null"";
    }
    
    static boolean isStraight(int[] hand) {
        int[] sorted = hand.clone();
        Arrays.sort(sorted);
        
        // Check normal straight
        boolean isConsecutive = true;
        for (int i = 1; i < 5; i++) {
            if (sorted[i] != sorted[i-1] + 1) {
                isConsecutive = false;
                break;
            }
        }
        if (isConsecutive) return true;
        
        // Check A-2-3-4-5
        if (sorted[0] == 1 && sorted[1] == 2 && sorted[2] == 3 && sorted[3] == 4 && sorted[4] == 5) {
            return true;
        }
        
        // Check 10-J-Q-K-A
        if (sorted[0] == 1 && sorted[1] == 10 && sorted[2] == 11 && sorted[3] == 12 && sorted[4] == 13) {
            return true;
        }
        
        return false;
    }
}
",0
p00038,"ポーカー
ポーカーの手札データを読み込んで、それぞれについてその役を出力するプログラムを作成してください。ただし、この問題では、以下のルールに従います。
ポーカーはトランプ 5 枚で行う競技です。
同じ数字のカードは 5 枚以上ありません。
ジョーカーは無いものとします。
以下のポーカーの役だけを考えるものとします。(番号が大きいほど役が高くなります。)
役なし(以下に挙げるどれにも当てはまらない)
ワンペア（2 枚の同じ数字のカードが1 組ある）
ツーペア（2 枚の同じ数字のカードが2 組ある）
スリーカード（3 枚の同じ数字のカードが1 組ある）
ストレート（5 枚のカードの数字が連続している）
ただし、A を含むストレートの場合、A で終わる並びもストレートとします。つまり、A を含むストレート
は、A 2 3 4 5 　と　10 J Q K A 　の２種類です。J Q K A 2 などのように、A をまたぐ並び
はストレートではありません。（この場合、「役なし」になります）。
フルハウス（3 枚の同じ数字のカードが1 組と、残りの2 枚が同じ数字のカード）
フォーカード（4 枚の同じ数字のカードが1 組ある）
Input
入力は複数のデータセットからなります。各データセットは以下の形式で与えられます。
手札1,手札2,手札3,手札4,手札5
手札は、トランプのJ(ジャック) を11、Q(クイーン) を12、K(キング) を13、A（エース）を 1、その他はそれぞれの数字で表すこととします。
データセットの数は 50 を超えません。
Output
データセットごとに、手札によってできる最も高い役をひとつ出力してください。役の表記については出力例に従ってください。
Sample Input
1,2,3,4,1
2,3,2,3,12
12,13,11,12,12
7,6,7,6,7
3,3,2,3,3
6,7,8,9,10
11,12,10,1,13
11,12,13,1,2
Output for the Sample Input
one pair
two pair
three card
full house
four card
straight
straight
null
3 3 2 3 3 という手札であったときは、two pair ではなく four card です。",Java,"import java.util.Arrays;
import java.util.Scanner;

public class Main {
	
	private static boolean checkFourCard(int[] group){
		boolean flag = false;
		for(int i=1; i<group.length; ++i){
			if(group[i] == 4){
				flag = true;
			}
		}
		return flag;
	}
	
	private static boolean checkFullHouse(int[] group){
		boolean two=false, three=false;
		
		for(int i=1; i<group.length; ++i){
			if(group[i] == 2){
				two = true;
			}else if(group[i] == 3){
				three = true;
			}
		}
		if(two && three){
			return true;
		}else{
			return false;
		}
	}
	
	private static boolean checkStraight(int[] group){
		boolean flag = false;
		int count = 0;
		
		for(int i=1; i<group.length; ++i){
			if(group[i] == 1){
				//またいだ回数
				int over = 0;
				for(int j=i; j<i+5; ++j){
					over += j/group.length;
					if(over > 1){	//2まで行ったら、
						return false;
					}
					
					int num = j%13;
					if(num == 0){ num = 13; }
					if(group[num] == 1){
						++count;
					}else{
						count = 0;
						break;
					}
				}
				if(count == 5){
					flag = true;
					break;
				}
			}
		}
		
		return flag;
	}
	private static boolean checkThreeCard(int[] group){
		boolean flag = false;
		
		for(int i=1; i<group.length; ++i){
			//main で else if やっているから大丈夫だけど、full house 誤認防止
			if(group[i] == 2){
				return false;
			}else if(group[i] == 3){		//four cardもfalseで帰る。
				flag = true;
			}
		}
		
		return flag;
	}
	
	private static boolean checkTwoPair(int[] group){
		boolean flag = false;
		
		for(int i=1; i<group.length; ++i){
			if(flag){		//one pair あった上で見つかったら、
				if(group[i] == 2){
					return true;
				}
			}
			if(group[i] == 2){
				flag = true;
			}
		}
		
		return false;
	}
	
	private static boolean checkOnePair(int[] group){
		boolean flag = false;
		
		for(int i=1; i<group.length; ++i){
			if(flag){		//one pair あった上で見つかったら、
				if(group[i] == 2 || group[i] == 3){
					flag = false;
				}
			}
			if(group[i] == 2){
				flag = true;
			}
		}
		
		return flag;
	}
	
	/**
	 * @param args
	 */
	public static void main(String[] args) {
		// TODO Auto-generated method stub
		Scanner scan = new Scanner(System.in);
		int hand[] = new int [5];
		
		while(scan.hasNext()){
			String[] str = scan.next().split("","");
			for(int i=0; i<str.length; ++i){
				hand[i] = Integer.parseInt(str[i]);
			}
			
			int group[] = new int [14];	//添字がカードナンバと対応。０は欠番
			Arrays.fill(group, 0);
			for(int i=0; i<hand.length; ++i){
				++group[hand[i]];
			}
			
			if(checkFourCard(group)){
				System.out.println(""four card"");
			}else if(checkFullHouse(group)){
				System.out.println(""full house"");
			}else if(checkStraight(group)){
				System.out.println(""straight"");
			}else if(checkThreeCard(group)){
				System.out.println(""three card"");
			}else if(checkTwoPair(group)){
				System.out.println(""two pair"");
			}else if(checkOnePair(group)){
				System.out.println(""one pair"");
			}else{
				System.out.println(""null"");
			}
		}
	}
}",1
p00038,"ポーカー
ポーカーの手札データを読み込んで、それぞれについてその役を出力するプログラムを作成してください。ただし、この問題では、以下のルールに従います。
ポーカーはトランプ 5 枚で行う競技です。
同じ数字のカードは 5 枚以上ありません。
ジョーカーは無いものとします。
以下のポーカーの役だけを考えるものとします。(番号が大きいほど役が高くなります。)
役なし(以下に挙げるどれにも当てはまらない)
ワンペア（2 枚の同じ数字のカードが1 組ある）
ツーペア（2 枚の同じ数字のカードが2 組ある）
スリーカード（3 枚の同じ数字のカードが1 組ある）
ストレート（5 枚のカードの数字が連続している）
ただし、A を含むストレートの場合、A で終わる並びもストレートとします。つまり、A を含むストレート
は、A 2 3 4 5 　と　10 J Q K A 　の２種類です。J Q K A 2 などのように、A をまたぐ並び
はストレートではありません。（この場合、「役なし」になります）。
フルハウス（3 枚の同じ数字のカードが1 組と、残りの2 枚が同じ数字のカード）
フォーカード（4 枚の同じ数字のカードが1 組ある）
Input
入力は複数のデータセットからなります。各データセットは以下の形式で与えられます。
手札1,手札2,手札3,手札4,手札5
手札は、トランプのJ(ジャック) を11、Q(クイーン) を12、K(キング) を13、A（エース）を 1、その他はそれぞれの数字で表すこととします。
データセットの数は 50 を超えません。
Output
データセットごとに、手札によってできる最も高い役をひとつ出力してください。役の表記については出力例に従ってください。
Sample Input
1,2,3,4,1
2,3,2,3,12
12,13,11,12,12
7,6,7,6,7
3,3,2,3,3
6,7,8,9,10
11,12,10,1,13
11,12,13,1,2
Output for the Sample Input
one pair
two pair
three card
full house
four card
straight
straight
null
3 3 2 3 3 という手札であったときは、two pair ではなく four card です。",Python,"import sys
from collections import Counter

def get_hand_rank(cards):
    counts = Counter(cards)
    count_values = sorted(counts.values(), reverse=True)
    
    # Check for four card
    if count_values[0] == 4:
        return ""four card""
    
    # Check for full house
    if count_values[0] == 3 and count_values[1] == 2:
        return ""full house""
    
    # Check for straight
    sorted_cards = sorted(cards)
    is_straight = True
    for i in range(4):
        if sorted_cards[i+1] - sorted_cards[i] != 1:
            is_straight = False
            break
    
    if is_straight:
        return ""straight""
    
    # Check for A-2-3-4-5 straight
    if sorted_cards == [1, 2, 3, 4, 5]:
        return ""straight""
    
    # Check for 10-J-Q-K-A straight
    if sorted_cards == [1, 10, 11, 12, 13]:
        return ""straight""
    
    # Check for three card
    if count_values[0] == 3:
        return ""three card""
    
    # Check for two pair
    if count_values[0] == 2 and count_values[1] == 2:
        return ""two pair""
    
    # Check for one pair
    if count_values[0] == 2:
        return ""one pair""
    
    return ""null""

for line in sys.stdin:
    line = line.strip()
    if not line:
        break
    cards = list(map(int, line.split(',')))
    print(get_hand_rank(cards))
",0
p00038,"ポーカー
ポーカーの手札データを読み込んで、それぞれについてその役を出力するプログラムを作成してください。ただし、この問題では、以下のルールに従います。
ポーカーはトランプ 5 枚で行う競技です。
同じ数字のカードは 5 枚以上ありません。
ジョーカーは無いものとします。
以下のポーカーの役だけを考えるものとします。(番号が大きいほど役が高くなります。)
役なし(以下に挙げるどれにも当てはまらない)
ワンペア（2 枚の同じ数字のカードが1 組ある）
ツーペア（2 枚の同じ数字のカードが2 組ある）
スリーカード（3 枚の同じ数字のカードが1 組ある）
ストレート（5 枚のカードの数字が連続している）
ただし、A を含むストレートの場合、A で終わる並びもストレートとします。つまり、A を含むストレート
は、A 2 3 4 5 　と　10 J Q K A 　の２種類です。J Q K A 2 などのように、A をまたぐ並び
はストレートではありません。（この場合、「役なし」になります）。
フルハウス（3 枚の同じ数字のカードが1 組と、残りの2 枚が同じ数字のカード）
フォーカード（4 枚の同じ数字のカードが1 組ある）
Input
入力は複数のデータセットからなります。各データセットは以下の形式で与えられます。
手札1,手札2,手札3,手札4,手札5
手札は、トランプのJ(ジャック) を11、Q(クイーン) を12、K(キング) を13、A（エース）を 1、その他はそれぞれの数字で表すこととします。
データセットの数は 50 を超えません。
Output
データセットごとに、手札によってできる最も高い役をひとつ出力してください。役の表記については出力例に従ってください。
Sample Input
1,2,3,4,1
2,3,2,3,12
12,13,11,12,12
7,6,7,6,7
3,3,2,3,3
6,7,8,9,10
11,12,10,1,13
11,12,13,1,2
Output for the Sample Input
one pair
two pair
three card
full house
four card
straight
straight
null
3 3 2 3 3 という手札であったときは、two pair ではなく four card です。",Python,"# -*- coding: utf-8 -*-

import sys
import os

for s in sys.stdin:
    A = list(map(int, s.split(',')))
    A.sort()
    #print(A)

    if (A[0] == A[1] == A[2] == A[3]) or (A[1] == A[2] == A[3] == A[4]):
        print('four card')

    # full house
    elif (A[0] == A[1] == A[2]) and (A[3] == A[4]):
        print('full house')
    elif (A[0] == A[1]) and (A[2] == A[3] == A[4]):
        print('full house')

    # straight
    elif A[0] == A[1] - 1 == A[2] - 2 == A[3] - 3 == A[4] - 4:
        print('straight')
    elif A[1] == 10 and A[2] == 11 and A[3] == 12 and A[4] == 13 and A[0] == 1:
        print('straight')

    # three card
    elif (A[0] == A[1] == A[2]) or (A[1] == A[2] == A[3]) or (A[2] == A[3] == A[4]):
        print('three card')

    # two pair
    elif ((A[0] == A[1]) and (A[2] == A[3])) or ((A[0] == A[1]) and (A[3] == A[4])) or ((A[1] == A[2]) and (A[3] == A[4])):
        print('two pair')

    # one pair
    elif (A[0] == A[1]) or (A[1] == A[2]) or (A[2] == A[3]) or (A[3] == A[4]):
        print('one pair')

    else:
        print('null')",1
p00040,"アフィン暗号
簡単な暗号法の一つに、アフィン暗号というものがあります。まず、アルファベット a〜z を a = 0, b = 1, c = 2,..., x = 23, y = 24, z = 25 と 0〜25 の数字に置き換えます。そして、以下の式で、原文のアルファベットを置換します。
$F(\gamma) = (\alpha \cdot \gamma + \beta)$ mod $26$
ただし、mod 26 は 26 で割った余りを表します。例えば、$\alpha = 3, \beta = 2$ のとき、アルファベットの 'a' (=0) は、$F(0) = (3 \cdot 0 + 2)$ mod $26 =  2$ で 'c' に、アルファベットの 'n' (=13) は $F(13) = (3 \cdot 13 + 2)$ mod $26 = 15$ で 'p' に置換されます。
このとき、$\gamma$ に対する $F(\gamma)$ が必ず 1 対 1 で対応付けられるように、$\alpha$ と $\beta$ は慎重に選ばれているものとします（$\alpha$ と 26 が互いに素であることが条件）。$\alpha = 4, \beta = 7$ のときのように、$F('a') = 7, F('n') = 7$ と、'a' も 'n' も同じ 'h' に置換されるようなことはありません。また、アルファベット以外の文字は置換されません。
暗号化された文字列を元の文章に復号したものを出力するプログラムを作成してください。元の文章には、キーワードとして
that
this
のいずれかが必ず含まれているものとします。
Input
複数のデータセットが与えられます。１行目にデータセット数 $n$ ($n \leq 30$) が与えられます。続いて $n$ 行のデータが与えられます。各データセットに英小文字と空白からなる 256 文字以内の暗号化された文章が１行に与えられます。
Output
各データセットに対して、復号した元の文章を１行に出力して下さい。
Sample Input
1
y eazqyp pnop pngtg ye obmpngt xmybp mr lygw
Output for the Sample Input
i submit that there is another point of view",C,"#include <stdio.h>
#include <string.h>
#include <ctype.h>

int gcd(int a, int b) {
    if (b == 0) return a;
    return gcd(b, a % b);
}

int mod_inverse(int a, int m) {
    for (int i = 1; i < m; i++) {
        if ((a * i) % m == 1) return i;
    }
    return -1;
}

void decrypt(char *text, int alpha, int beta, char *result) {
    int alpha_inv = mod_inverse(alpha, 26);
    if (alpha_inv == -1) {
        result[0] = '\0';
        return;
    }
    
    int len = strlen(text);
    for (int i = 0; i < len; i++) {
        if (isalpha(text[i])) {
            int c = text[i] - 'a';
            int decoded = (alpha_inv * (c - beta + 26)) % 26;
            if (decoded < 0) decoded += 26;
            result[i] = decoded + 'a';
        } else {
            result[i] = text[i];
        }
    }
    result[len] = '\0';
}

int contains_word(char *text, char *word) {
    int text_len = strlen(text);
    int word_len = strlen(word);
    
    for (int i = 0; i <= text_len - word_len; i++) {
        if (i > 0 && isalpha(text[i-1])) continue;
        if (i + word_len < text_len && isalpha(text[i + word_len])) continue;
        
        int match = 1;
        for (int j = 0; j < word_len; j++) {
            if (text[i + j] != word[j]) {
                match = 0;
                break;
            }
        }
        if (match) return 1;
    }
    return 0;
}

int main() {
    int n;
    scanf(""%d\n"", &n);
    
    for (int t = 0; t < n; t++) {
        char text[257];
        fgets(text, 257, stdin);
        int len = strlen(text);
        if (text[len-1] == '\n') text[len-1] = '\0';
        
        char result[257];
        int found = 0;
        
        for (int alpha = 1; alpha < 26 && !found; alpha++) {
            if (gcd(alpha, 26) != 1) continue;
            
            for (int beta = 0; beta < 26 && !found; beta++) {
                decrypt(text, alpha, beta, result);
                
                if (contains_word(result, ""that"") || contains_word(result, ""this"")) {
                    printf(""%s\n"", result);
                    found = 1;
                }
            }
        }
    }
    
    return 0;
}
",0
p00040,"アフィン暗号
簡単な暗号法の一つに、アフィン暗号というものがあります。まず、アルファベット a〜z を a = 0, b = 1, c = 2,..., x = 23, y = 24, z = 25 と 0〜25 の数字に置き換えます。そして、以下の式で、原文のアルファベットを置換します。
$F(\gamma) = (\alpha \cdot \gamma + \beta)$ mod $26$
ただし、mod 26 は 26 で割った余りを表します。例えば、$\alpha = 3, \beta = 2$ のとき、アルファベットの 'a' (=0) は、$F(0) = (3 \cdot 0 + 2)$ mod $26 =  2$ で 'c' に、アルファベットの 'n' (=13) は $F(13) = (3 \cdot 13 + 2)$ mod $26 = 15$ で 'p' に置換されます。
このとき、$\gamma$ に対する $F(\gamma)$ が必ず 1 対 1 で対応付けられるように、$\alpha$ と $\beta$ は慎重に選ばれているものとします（$\alpha$ と 26 が互いに素であることが条件）。$\alpha = 4, \beta = 7$ のときのように、$F('a') = 7, F('n') = 7$ と、'a' も 'n' も同じ 'h' に置換されるようなことはありません。また、アルファベット以外の文字は置換されません。
暗号化された文字列を元の文章に復号したものを出力するプログラムを作成してください。元の文章には、キーワードとして
that
this
のいずれかが必ず含まれているものとします。
Input
複数のデータセットが与えられます。１行目にデータセット数 $n$ ($n \leq 30$) が与えられます。続いて $n$ 行のデータが与えられます。各データセットに英小文字と空白からなる 256 文字以内の暗号化された文章が１行に与えられます。
Output
各データセットに対して、復号した元の文章を１行に出力して下さい。
Sample Input
1
y eazqyp pnop pngtg ye obmpngt xmybp mr lygw
Output for the Sample Input
i submit that there is another point of view",C,"#include<stdio.h>
#include<string.h>


int main(){
  int i,j,k,l,al[]={0,1,5,7,11,17,19,23,25},n,clen;
  char ci[257],ans[257];
  fgets(ci,256,stdin);
  n=atoi(ci);
  for(i=0;i<n;i++){
    fgets(ci,256,stdin);
    clen=strlen(ci);
    ans[clen]='\0';
    for(j=0;j<9;j++){
      for(k=0;k<26;k++){
	for(l=0;l<clen;l++){
	  if(isalpha(ci[l]))
	    ans[l]=(al[j]*((int)ci[l]-(int)'a')+k)%26+'a';
	  else
	    ans[l]=ci[l];
	}
	if(strstr(ans,""that"")||strstr(ans,""this"")){
	  printf(""%s"",ans);
	  goto find;
	}
      }
    }
  find:;
  }
  return 0;
}",1
p00040,"アフィン暗号
簡単な暗号法の一つに、アフィン暗号というものがあります。まず、アルファベット a〜z を a = 0, b = 1, c = 2,..., x = 23, y = 24, z = 25 と 0〜25 の数字に置き換えます。そして、以下の式で、原文のアルファベットを置換します。
$F(\gamma) = (\alpha \cdot \gamma + \beta)$ mod $26$
ただし、mod 26 は 26 で割った余りを表します。例えば、$\alpha = 3, \beta = 2$ のとき、アルファベットの 'a' (=0) は、$F(0) = (3 \cdot 0 + 2)$ mod $26 =  2$ で 'c' に、アルファベットの 'n' (=13) は $F(13) = (3 \cdot 13 + 2)$ mod $26 = 15$ で 'p' に置換されます。
このとき、$\gamma$ に対する $F(\gamma)$ が必ず 1 対 1 で対応付けられるように、$\alpha$ と $\beta$ は慎重に選ばれているものとします（$\alpha$ と 26 が互いに素であることが条件）。$\alpha = 4, \beta = 7$ のときのように、$F('a') = 7, F('n') = 7$ と、'a' も 'n' も同じ 'h' に置換されるようなことはありません。また、アルファベット以外の文字は置換されません。
暗号化された文字列を元の文章に復号したものを出力するプログラムを作成してください。元の文章には、キーワードとして
that
this
のいずれかが必ず含まれているものとします。
Input
複数のデータセットが与えられます。１行目にデータセット数 $n$ ($n \leq 30$) が与えられます。続いて $n$ 行のデータが与えられます。各データセットに英小文字と空白からなる 256 文字以内の暗号化された文章が１行に与えられます。
Output
各データセットに対して、復号した元の文章を１行に出力して下さい。
Sample Input
1
y eazqyp pnop pngtg ye obmpngt xmybp mr lygw
Output for the Sample Input
i submit that there is another point of view",Java,"import java.util.*;

public class Main {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int n = sc.nextInt();
        sc.nextLine();
        
        for (int i = 0; i < n; i++) {
            String encrypted = sc.nextLine();
            String decrypted = decrypt(encrypted);
            System.out.println(decrypted);
        }
    }
    
    static String decrypt(String encrypted) {
        // Try all possible alpha and beta values
        for (int alpha = 1; alpha < 26; alpha++) {
            if (gcd(alpha, 26) != 1) continue; // alpha must be coprime with 26
            
            for (int beta = 0; beta < 26; beta++) {
                String decrypted = tryDecrypt(encrypted, alpha, beta);
                if (decrypted != null && (decrypted.contains(""that"") || decrypted.contains(""this""))) {
                    return decrypted;
                }
            }
        }
        return encrypted;
    }
    
    static String tryDecrypt(String encrypted, int alpha, int beta) {
        // Find modular inverse of alpha
        int alphaInv = modInverse(alpha, 26);
        if (alphaInv == -1) return null;
        
        StringBuilder sb = new StringBuilder();
        for (char c : encrypted.toCharArray()) {
            if (c >= 'a' && c <= 'z') {
                int y = c - 'a';
                int x = (alphaInv * (y - beta + 26)) % 26;
                if (x < 0) x += 26;
                sb.append((char)('a' + x));
            } else {
                sb.append(c);
            }
        }
        return sb.toString();
    }
    
    static int gcd(int a, int b) {
        if (b == 0) return a;
        return gcd(b, a % b);
    }
    
    static int modInverse(int a, int m) {
        for (int x = 1; x < m; x++) {
            if ((a * x) % m == 1) {
                return x;
            }
        }
        return -1;
    }
}
",0
p00040,"アフィン暗号
簡単な暗号法の一つに、アフィン暗号というものがあります。まず、アルファベット a〜z を a = 0, b = 1, c = 2,..., x = 23, y = 24, z = 25 と 0〜25 の数字に置き換えます。そして、以下の式で、原文のアルファベットを置換します。
$F(\gamma) = (\alpha \cdot \gamma + \beta)$ mod $26$
ただし、mod 26 は 26 で割った余りを表します。例えば、$\alpha = 3, \beta = 2$ のとき、アルファベットの 'a' (=0) は、$F(0) = (3 \cdot 0 + 2)$ mod $26 =  2$ で 'c' に、アルファベットの 'n' (=13) は $F(13) = (3 \cdot 13 + 2)$ mod $26 = 15$ で 'p' に置換されます。
このとき、$\gamma$ に対する $F(\gamma)$ が必ず 1 対 1 で対応付けられるように、$\alpha$ と $\beta$ は慎重に選ばれているものとします（$\alpha$ と 26 が互いに素であることが条件）。$\alpha = 4, \beta = 7$ のときのように、$F('a') = 7, F('n') = 7$ と、'a' も 'n' も同じ 'h' に置換されるようなことはありません。また、アルファベット以外の文字は置換されません。
暗号化された文字列を元の文章に復号したものを出力するプログラムを作成してください。元の文章には、キーワードとして
that
this
のいずれかが必ず含まれているものとします。
Input
複数のデータセットが与えられます。１行目にデータセット数 $n$ ($n \leq 30$) が与えられます。続いて $n$ 行のデータが与えられます。各データセットに英小文字と空白からなる 256 文字以内の暗号化された文章が１行に与えられます。
Output
各データセットに対して、復号した元の文章を１行に出力して下さい。
Sample Input
1
y eazqyp pnop pngtg ye obmpngt xmybp mr lygw
Output for the Sample Input
i submit that there is another point of view",Java,"

import java.io.BufferedReader;
import java.io.InputStreamReader;
import java.util.ArrayList;



 class Main{
     
    static  ArrayList<String> al=new ArrayList<String>();
    static int A=1,B=0;
    static char chars[]= new char[]{
         'a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p',
         'q','r','s','t','u','v','w','x','y','z'
     };
    static char getChar(int n){return chars[n];}
    static int getCode(char c){return (int)c-(int)'a';}
    static int F(int m){return (A*m+B)%26;}
    static String replace(String str){
        StringBuilder sb=new StringBuilder();
        for(int i=0; i<str.length(); i++){
           // System.out.println(str.charAt(i)+"" ""+F(getCode(str.charAt(i))));
            char replaced = getChar(F(getCode(str.charAt(i))));
            //System.out.println(replaced);
            sb.append(replaced);
        }        return new String(sb);
    }
    static void detectAB(){
        A=1;B=0;
        for(int a=1; a<30000;a+=2){
            for(int b=0; b<26;b++){
                A=a;B=b;
                for(String str:al){
                    String rep = replace(str);
                    //System.out.println(rep);
                    if(rep.equals(""this"")||rep.equals(""that""))return;
                }
            }
        }
    }
    
     public static void main(String args[]){
         BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        // System.out.println(getCode('a')+""""+getCode('b')+""""+getCode('z'));
         //System.out.println(replace(""abz""));
         //String line;
         try{
         int n=Integer.parseInt(br.readLine());
         //int n=1;
         //for(int i=0; i<n;i++){
         String line;
         while((line=br.readLine())!=null){
             //System.out.println(""aa""+n);
             al.clear();
             
             //System.out.println(line);
             String split[]=line.split("" "");
             for(String str:split)if(str.length()==4)al.add(str);
            detectAB();
             System.out.print(replace(split[0]));
            for(int j=1; j<split.length;j++){
                System.out.print("" ""+replace(split[j]));
            }
             System.out.println();
         }
         }catch(Exception e){}
         
     }
     
 }",1
p00040,"アフィン暗号
簡単な暗号法の一つに、アフィン暗号というものがあります。まず、アルファベット a〜z を a = 0, b = 1, c = 2,..., x = 23, y = 24, z = 25 と 0〜25 の数字に置き換えます。そして、以下の式で、原文のアルファベットを置換します。
$F(\gamma) = (\alpha \cdot \gamma + \beta)$ mod $26$
ただし、mod 26 は 26 で割った余りを表します。例えば、$\alpha = 3, \beta = 2$ のとき、アルファベットの 'a' (=0) は、$F(0) = (3 \cdot 0 + 2)$ mod $26 =  2$ で 'c' に、アルファベットの 'n' (=13) は $F(13) = (3 \cdot 13 + 2)$ mod $26 = 15$ で 'p' に置換されます。
このとき、$\gamma$ に対する $F(\gamma)$ が必ず 1 対 1 で対応付けられるように、$\alpha$ と $\beta$ は慎重に選ばれているものとします（$\alpha$ と 26 が互いに素であることが条件）。$\alpha = 4, \beta = 7$ のときのように、$F('a') = 7, F('n') = 7$ と、'a' も 'n' も同じ 'h' に置換されるようなことはありません。また、アルファベット以外の文字は置換されません。
暗号化された文字列を元の文章に復号したものを出力するプログラムを作成してください。元の文章には、キーワードとして
that
this
のいずれかが必ず含まれているものとします。
Input
複数のデータセットが与えられます。１行目にデータセット数 $n$ ($n \leq 30$) が与えられます。続いて $n$ 行のデータが与えられます。各データセットに英小文字と空白からなる 256 文字以内の暗号化された文章が１行に与えられます。
Output
各データセットに対して、復号した元の文章を１行に出力して下さい。
Sample Input
1
y eazqyp pnop pngtg ye obmpngt xmybp mr lygw
Output for the Sample Input
i submit that there is another point of view",Python,"def gcd(a, b):
    while b:
        a, b = b, a % b
    return a

def mod_inverse(a, m):
    if gcd(a, m) != 1:
        return None
    for i in range(1, m):
        if (a * i) % m == 1:
            return i
    return None

def decrypt_char(c, alpha, beta):
    if not c.isalpha():
        return c
    alpha_inv = mod_inverse(alpha, 26)
    if alpha_inv is None:
        return c
    val = ord(c) - ord('a')
    decrypted_val = (alpha_inv * (val - beta)) % 26
    return chr(decrypted_val + ord('a'))

def decrypt_text(text, alpha, beta):
    return ''.join(decrypt_char(c, alpha, beta) for c in text)

def try_decrypt(encrypted):
    keywords = [""that"", ""this""]
    
    for alpha in range(1, 26):
        if gcd(alpha, 26) != 1:
            continue
        
        for beta in range(26):
            decrypted = decrypt_text(encrypted, alpha, beta)
            
            for keyword in keywords:
                if keyword in decrypted:
                    return decrypted
    
    return encrypted

n = int(input())
for _ in range(n):
    encrypted = input()
    print(try_decrypt(encrypted))
",0
p00040,"アフィン暗号
簡単な暗号法の一つに、アフィン暗号というものがあります。まず、アルファベット a〜z を a = 0, b = 1, c = 2,..., x = 23, y = 24, z = 25 と 0〜25 の数字に置き換えます。そして、以下の式で、原文のアルファベットを置換します。
$F(\gamma) = (\alpha \cdot \gamma + \beta)$ mod $26$
ただし、mod 26 は 26 で割った余りを表します。例えば、$\alpha = 3, \beta = 2$ のとき、アルファベットの 'a' (=0) は、$F(0) = (3 \cdot 0 + 2)$ mod $26 =  2$ で 'c' に、アルファベットの 'n' (=13) は $F(13) = (3 \cdot 13 + 2)$ mod $26 = 15$ で 'p' に置換されます。
このとき、$\gamma$ に対する $F(\gamma)$ が必ず 1 対 1 で対応付けられるように、$\alpha$ と $\beta$ は慎重に選ばれているものとします（$\alpha$ と 26 が互いに素であることが条件）。$\alpha = 4, \beta = 7$ のときのように、$F('a') = 7, F('n') = 7$ と、'a' も 'n' も同じ 'h' に置換されるようなことはありません。また、アルファベット以外の文字は置換されません。
暗号化された文字列を元の文章に復号したものを出力するプログラムを作成してください。元の文章には、キーワードとして
that
this
のいずれかが必ず含まれているものとします。
Input
複数のデータセットが与えられます。１行目にデータセット数 $n$ ($n \leq 30$) が与えられます。続いて $n$ 行のデータが与えられます。各データセットに英小文字と空白からなる 256 文字以内の暗号化された文章が１行に与えられます。
Output
各データセットに対して、復号した元の文章を１行に出力して下さい。
Sample Input
1
y eazqyp pnop pngtg ye obmpngt xmybp mr lygw
Output for the Sample Input
i submit that there is another point of view",Python,"for _ in[0]*int(input()):
 e=input()
 for i in range(1,26,2):
  for j in range(26):
   a=''.join([c,chr(((ord(c)-97)*i+j)%26+97)][c.islower()]for c in e)
   if'that'in a or'this'in a:print(a);break
",1
p00041,"式
与えられた 4 つの 1 から 9 の整数を使って、答えが 10 になる式をつくります。
 4 つの整数
a, b, c, d
を入力したとき、下記の条件に従い、答えが 10 になる式を出力するプログラムを作成してください。また、答えが複数ある時は、最初に見つかった答えだけを出力するものとします。答えがない時は、0 と出力してください。
演算子として、加算 (+)、減算 (-)、乗算 (*) だけを使います。除算 (/) は使いません。使用できる演算子は３個です。
数を4つとも使わなければいけません。
4つの数の順番は自由に入れ換えてかまいません。
カッコを使ってもかまいません。使用できるカッコは３組（６個）以下です。
Input
複数のデータセットが与えられます。各データセットの形式は以下のとおり：
a
b
c
d
入力は４つの 0 で終了します。データセットの数は 40 を超えません。
Output
各データセットについて、与えられた 4 つの整数と上記の演算記号およびカッコを組み合わせて値が 10 となる式または 0 を１行に出力してください。式の文字列が 1024 文字を超えてはいけません。
Sample Input
8 7 9 9
4 4 4 4
5 5 7 5
0 0 0 0
Output for the Sample Input
((9 * (9 - 7)) - 8)
0
((7 * 5) - (5 * 5))",C,"#include <stdio.h>
#include <string.h>

int nums[4];
char result[1025];
int found;

void generate(int depth, int count, int used, int values[], char* exprs[], int value, char* expr) {
    if (found) return;
    
    if (count == 1) {
        if (value == 10) {
            strcpy(result, expr);
            found = 1;
        }
        return;
    }
    
    for (int i = 0; i < count; i++) {
        for (int j = i + 1; j < count; j++) {
            int newValues[4];
            char* newExprs[4];
            int newCount = 0;
            
            for (int k = 0; k < count; k++) {
                if (k != i && k != j) {
                    newValues[newCount] = values[k];
                    newExprs[newCount] = exprs[k];
                    newCount++;
                }
            }
            
            char expr1[1025], expr2[1025], expr3[1025];
            
            // Addition
            sprintf(expr1, ""(%s + %s)"", exprs[i], exprs[j]);
            newValues[newCount] = values[i] + values[j];
            newExprs[newCount] = expr1;
            generate(depth + 1, newCount + 1, used, newValues, newExprs, newValues[newCount], expr1);
            if (found) return;
            
            // Subtraction (i - j)
            sprintf(expr2, ""(%s - %s)"", exprs[i], exprs[j]);
            newValues[newCount] = values[i] - values[j];
            newExprs[newCount] = expr2;
            generate(depth + 1, newCount + 1, used, newValues, newExprs, newValues[newCount], expr2);
            if (found) return;
            
            // Subtraction (j - i)
            sprintf(expr3, ""(%s - %s)"", exprs[j], exprs[i]);
            newValues[newCount] = values[j] - values[i];
            newExprs[newCount] = expr3;
            generate(depth + 1, newCount + 1, used, newValues, newExprs, newValues[newCount], expr3);
            if (found) return;
            
            // Multiplication
            sprintf(expr1, ""(%s * %s)"", exprs[i], exprs[j]);
            newValues[newCount] = values[i] * values[j];
            newExprs[newCount] = expr1;
            generate(depth + 1, newCount + 1, used, newValues, newExprs, newValues[newCount], expr1);
            if (found) return;
        }
    }
}

void permute(int pos, int used, int perm[]) {
    if (found) return;
    
    if (pos == 4) {
        int values[4];
        char* exprs[4];
        char exprBuf[4][10];
        
        for (int i = 0; i < 4; i++) {
            values[i] = perm[i];
            sprintf(exprBuf[i], ""%d"", perm[i]);
            exprs[i] = exprBuf[i];
        }
        
        generate(0, 4, 0, values, exprs, 0, """");
        return;
    }
    
    for (int i = 0; i < 4; i++) {
        if (!(used & (1 << i))) {
            perm[pos] = nums[i];
            permute(pos + 1, used | (1 << i), perm);
            if (found) return;
        }
    }
}

int main() {
    while (1) {
        scanf(""%d %d %d %d"", &nums[0], &nums[1], &nums[2], &nums[3]);
        
        if (nums[0] == 0 && nums[1] == 0 && nums[2] == 0 && nums[3] == 0) {
            break;
        }
        
        found = 0;
        result[0] = '\0';
        
        int perm[4];
        permute(0, 0, perm);
        
        if (found) {
            printf(""%s\n"", result);
        } else {
            printf(""0\n"");
        }
    }
    
    return 0;
}
",0
p00041,"式
与えられた 4 つの 1 から 9 の整数を使って、答えが 10 になる式をつくります。
 4 つの整数
a, b, c, d
を入力したとき、下記の条件に従い、答えが 10 になる式を出力するプログラムを作成してください。また、答えが複数ある時は、最初に見つかった答えだけを出力するものとします。答えがない時は、0 と出力してください。
演算子として、加算 (+)、減算 (-)、乗算 (*) だけを使います。除算 (/) は使いません。使用できる演算子は３個です。
数を4つとも使わなければいけません。
4つの数の順番は自由に入れ換えてかまいません。
カッコを使ってもかまいません。使用できるカッコは３組（６個）以下です。
Input
複数のデータセットが与えられます。各データセットの形式は以下のとおり：
a
b
c
d
入力は４つの 0 で終了します。データセットの数は 40 を超えません。
Output
各データセットについて、与えられた 4 つの整数と上記の演算記号およびカッコを組み合わせて値が 10 となる式または 0 を１行に出力してください。式の文字列が 1024 文字を超えてはいけません。
Sample Input
8 7 9 9
4 4 4 4
5 5 7 5
0 0 0 0
Output for the Sample Input
((9 * (9 - 7)) - 8)
0
((7 * 5) - (5 * 5))",C,"d[4],e[9],f,k;char x[];z(){int b,c,a=e[f++];a>9?x[k++]=40,b=z(),x[k++]=a,c=z(),x[k++]=41,a=a-43?a-45?b*c:b-c:b+c:(x[k++]=a+48);return a;}y(o,n,i,j){if(i==7){f=k=0;if(z()==10){x[k]=0;puts(x);return 1;}return 0;}if(o)for(;j--;){e[i]=""+-*""[j];if(y(o-1,n+1,i+1,3))return 1;}if(n|i==6)for(j=4;j--;)if(e[i]=d[j]){d[j]=0;if(y(o,n-1,i+1,3))return 1;d[j]=e[i];}return 0;}main(){for(;scanf(""%d%d%d%d"",d,d+1,d+2,d+3),f=*d;)y(3,0,0,3)||puts(""0"");}",1
p00041,"式
与えられた 4 つの 1 から 9 の整数を使って、答えが 10 になる式をつくります。
 4 つの整数
a, b, c, d
を入力したとき、下記の条件に従い、答えが 10 になる式を出力するプログラムを作成してください。また、答えが複数ある時は、最初に見つかった答えだけを出力するものとします。答えがない時は、0 と出力してください。
演算子として、加算 (+)、減算 (-)、乗算 (*) だけを使います。除算 (/) は使いません。使用できる演算子は３個です。
数を4つとも使わなければいけません。
4つの数の順番は自由に入れ換えてかまいません。
カッコを使ってもかまいません。使用できるカッコは３組（６個）以下です。
Input
複数のデータセットが与えられます。各データセットの形式は以下のとおり：
a
b
c
d
入力は４つの 0 で終了します。データセットの数は 40 を超えません。
Output
各データセットについて、与えられた 4 つの整数と上記の演算記号およびカッコを組み合わせて値が 10 となる式または 0 を１行に出力してください。式の文字列が 1024 文字を超えてはいけません。
Sample Input
8 7 9 9
4 4 4 4
5 5 7 5
0 0 0 0
Output for the Sample Input
((9 * (9 - 7)) - 8)
0
((7 * 5) - (5 * 5))",Java,"import java.util.*;

public class Main {
    static class Expr {
        String str;
        int val;
        Expr(String s, int v) {
            str = s;
            val = v;
        }
    }
    
    static String result;
    static boolean found;
    
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        
        while (true) {
            int a = sc.nextInt();
            int b = sc.nextInt();
            int c = sc.nextInt();
            int d = sc.nextInt();
            
            if (a == 0 && b == 0 && c == 0 && d == 0) break;
            
            int[] nums = {a, b, c, d};
            result = null;
            found = false;
            
            permute(nums, 0);
            
            if (result != null) {
                System.out.println(result);
            } else {
                System.out.println(""0"");
            }
        }
    }
    
    static void permute(int[] nums, int start) {
        if (found) return;
        
        if (start == nums.length) {
            solve(nums);
            return;
        }
        
        for (int i = start; i < nums.length; i++) {
            swap(nums, start, i);
            permute(nums, start + 1);
            swap(nums, start, i);
            if (found) return;
        }
    }
    
    static void swap(int[] nums, int i, int j) {
        int temp = nums[i];
        nums[i] = nums[j];
        nums[j] = temp;
    }
    
    static void solve(int[] nums) {
        List<Expr> exprs = new ArrayList<>();
        for (int num : nums) {
            exprs.add(new Expr(String.valueOf(num), num));
        }
        
        generate(exprs);
    }
    
    static void generate(List<Expr> exprs) {
        if (found) return;
        
        if (exprs.size() == 1) {
            if (exprs.get(0).val == 10) {
                result = exprs.get(0).str;
                found = true;
            }
            return;
        }
        
        for (int i = 0; i < exprs.size(); i++) {
            for (int j = 0; j < exprs.size(); j++) {
                if (i == j) continue;
                
                Expr e1 = exprs.get(i);
                Expr e2 = exprs.get(j);
                
                char[] ops = {'+', '-', '*'};
                
                for (char op : ops) {
                    int newVal = calc(e1.val, e2.val, op);
                    String newStr = ""("" + e1.str + "" "" + op + "" "" + e2.str + "")"";
                    
                    List<Expr> newExprs = new ArrayList<>();
                    for (int k = 0; k < exprs.size(); k++) {
                        if (k != i && k != j) {
                            newExprs.add(exprs.get(k));
                        }
                    }
                    newExprs.add(new Expr(newStr, newVal));
                    
                    generate(newExprs);
                    if (found) return;
                }
            }
        }
    }
    
    static int calc(int a, int b, char op) {
        switch (op) {
            case '+': return a + b;
            case '-': return a - b;
            case '*': return a * b;
        }
        return 0;
    }
}
",0
p00041,"式
与えられた 4 つの 1 から 9 の整数を使って、答えが 10 になる式をつくります。
 4 つの整数
a, b, c, d
を入力したとき、下記の条件に従い、答えが 10 になる式を出力するプログラムを作成してください。また、答えが複数ある時は、最初に見つかった答えだけを出力するものとします。答えがない時は、0 と出力してください。
演算子として、加算 (+)、減算 (-)、乗算 (*) だけを使います。除算 (/) は使いません。使用できる演算子は３個です。
数を4つとも使わなければいけません。
4つの数の順番は自由に入れ換えてかまいません。
カッコを使ってもかまいません。使用できるカッコは３組（６個）以下です。
Input
複数のデータセットが与えられます。各データセットの形式は以下のとおり：
a
b
c
d
入力は４つの 0 で終了します。データセットの数は 40 を超えません。
Output
各データセットについて、与えられた 4 つの整数と上記の演算記号およびカッコを組み合わせて値が 10 となる式または 0 を１行に出力してください。式の文字列が 1024 文字を超えてはいけません。
Sample Input
8 7 9 9
4 4 4 4
5 5 7 5
0 0 0 0
Output for the Sample Input
((9 * (9 - 7)) - 8)
0
((7 * 5) - (5 * 5))",Java,"import java.util.*;

class Main{
  public static ArrayList<int[]> perm(int n){
    int[] num = new int[n];
    boolean[] flag = new boolean[n];
    ArrayList<int[]> arrList = new ArrayList<int[]>();
    permCalc(0,num,flag,arrList);
    return arrList;
  }

  public static void permCalc(int rank, int[] num, boolean[] flag, ArrayList<int[]> arrList){
    if (rank == num.length) {
      arrList.add(num.clone());
    }
    else {
      for (int i = 0; i < num.length; i++) {
        if (!flag[i]) {
          num[rank] = i;
          flag[i] = true;
          permCalc(rank+1,num,flag,arrList);
          flag[i] = false;
        }
      }
    }
  }

  public static int ope(int a, int b, int operand){
    switch (operand) {
      case 0:
        return a+b;
      case 1:
        return a-b;
      default:
        return a*b;
    }
  }

  public static String opeToStr(int operand){
    switch (operand) {
      case 0:
        return ""+"";
      case 1:
        return ""-"";
      default:
        return ""*"";
    }
  }

  public static String check(int[] num, int[] op){
    int a = num[0];
    int b = num[1];
    int c = num[2];
    int d = num[3];
    if(ope(ope(ope(a,b,op[0]),c,op[1]),d,op[2]) == 10) {
      return ""((""+a+"" ""+opeToStr(op[0])+"" ""+b+"") ""+opeToStr(op[1])+"" ""+c+"") ""+opeToStr(op[2])+"" ""+d;
    }
    else if(ope(ope(a,b,op[0]),ope(c,d,op[2]),op[1]) == 10) {
      return ""(""+a+"" ""+opeToStr(op[0])+"" ""+b+"") ""+opeToStr(op[1])+"" (""+c+"" ""+opeToStr(op[2])+"" ""+d+"")"";
    }
    else if(ope(ope(a,ope(b,c,op[1]),op[0]),d,op[2]) == 10) {
      return ""(""+a+"" ""+opeToStr(op[0])+"" (""+b+"" ""+opeToStr(op[1])+"" ""+c+"")) ""+opeToStr(op[2])+"" ""+d;
    }
    else if(ope(a,ope(ope(b,c,op[1]),d,op[2]),op[0]) == 10) {
      return a+"" ""+opeToStr(op[0])+"" ((""+b+"" ""+opeToStr(op[1])+"" ""+c+"") ""+opeToStr(op[2])+"" ""+d+"")"";
    }
    else if(ope(a,ope(b,ope(c,d,op[2]),op[1]),op[0]) == 10) {
      return a+"" ""+opeToStr(op[0])+"" (""+b+"" ""+opeToStr(op[1])+"" (""+c+"" ""+opeToStr(op[2])+"" ""+d+""))"";
    }
    else {
      return null;
    }
  }

  public static void main(String[] args){
    Scanner sc = new Scanner(System.in);
    ArrayList<int[]> arrList = perm(4);
    int[][] operand = new int[27][];
    for (int i = 0; i < 3; i++) {
      for (int j = 0; j < 3; j++) {
        for (int k = 0; k < 3; k++) {
          int[] temp = {i,j,k};
          operand[9*i+3*j+k] = temp;
        }
      }
    }
    while(true) {
      int[] num0 = new int[4];
      for (int i = 0; i < 4; i++) {
        num0[i] = sc.nextInt();
      }
      if (num0[0] == 0 && num0[1] == 0 && num0[2] == 0 && num0[3] == 0) {
        break;
      }
      String chk = null;
      search:
      for (int i = 0; i < arrList.size(); i++) {
        int[] num = {num0[arrList.get(i)[0]],num0[arrList.get(i)[1]],
                     num0[arrList.get(i)[2]],num0[arrList.get(i)[3]]};
        for (int j = 0; j < operand.length; j++) {
          chk = check(num, operand[j]);
          if (chk != null) {
            break search;
          }
        }
      }
      if (chk == null) {
        System.out.println(0);
      }
      else {
        System.out.println(chk);
      }
    }
  }
}",1
p00041,"式
与えられた 4 つの 1 から 9 の整数を使って、答えが 10 になる式をつくります。
 4 つの整数
a, b, c, d
を入力したとき、下記の条件に従い、答えが 10 になる式を出力するプログラムを作成してください。また、答えが複数ある時は、最初に見つかった答えだけを出力するものとします。答えがない時は、0 と出力してください。
演算子として、加算 (+)、減算 (-)、乗算 (*) だけを使います。除算 (/) は使いません。使用できる演算子は３個です。
数を4つとも使わなければいけません。
4つの数の順番は自由に入れ換えてかまいません。
カッコを使ってもかまいません。使用できるカッコは３組（６個）以下です。
Input
複数のデータセットが与えられます。各データセットの形式は以下のとおり：
a
b
c
d
入力は４つの 0 で終了します。データセットの数は 40 を超えません。
Output
各データセットについて、与えられた 4 つの整数と上記の演算記号およびカッコを組み合わせて値が 10 となる式または 0 を１行に出力してください。式の文字列が 1024 文字を超えてはいけません。
Sample Input
8 7 9 9
4 4 4 4
5 5 7 5
0 0 0 0
Output for the Sample Input
((9 * (9 - 7)) - 8)
0
((7 * 5) - (5 * 5))",Python,"from itertools import permutations, product

def evaluate(expr):
    try:
        return eval(expr)
    except:
        return None

def generate_expressions(nums):
    operators = ['+', '-', '*']
    
    # Template patterns for 4 numbers with different parenthesizations
    patterns = [
        # No parentheses
        ""{} {} {} {} {} {} {}"",
        # One pair of parentheses
        ""({} {} {}) {} {} {} {}"",
        ""{} {} ({} {} {}) {} {}"",
        ""{} {} {} {} ({} {} {})"",
        # Two pairs of parentheses
        ""({} {} {}) {} ({} {} {})"",
        ""(({} {} {}) {} {}) {} {}"",
        ""{} {} (({} {} {}) {} {})"",
        ""({} {} ({} {} {})) {} {}"",
        ""{} {} ({} {} ({} {} {}))"",
        # Three pairs of parentheses
        ""(({} {} {}) {} ({} {} {}))"",
        ""((({} {} {}) {} {}) {} {})"",
        ""({} {} (({} {} {}) {} {}))"",
        ""({} {} ({} {} ({} {} {})))"",
        ""{} {} ((({} {} {}) {} {}))"",
        ""{} {} (({} {} ({} {} {})))"",
        ""{} {} ({} {} (({} {} {})))"",
        # More complex patterns
        ""((({} {} {}) {} ({} {} {})))"",
        ""(({} {} ({} {} {})) {} {})"",
        ""({} {} (({} {} ({} {} {}))))"",
        ""(({} {} {}) {} (({} {} {})))"",
        ""((({} {} ({} {} {}))) {} {})"",
        ""{} {} (((({} {} {})) {} {}))"",
    ]
    
    for perm in permutations(nums):
        for ops in product(operators, repeat=3):
            for pattern in patterns:
                try:
                    # Interleave numbers and operators
                    elements = []
                    num_idx = 0
                    op_idx = 0
                    for char in pattern:
                        if char == '{}':
                            if num_idx < 4:
                                elements.append(str(perm[num_idx]))
                                num_idx += 1
                            elif op_idx < 3:
                                elements.append(ops[op_idx])
                                op_idx += 1
                    
                    if num_idx == 4 and op_idx == 3:
                        expr = pattern.format(perm[0], ops[0], perm[1], ops[1], perm[2], ops[2], perm[3])
                        result = evaluate(expr)
                        if result == 10:
                            return expr
                except:
                    continue
    
    return None

def solve():
    results = []
    while True:
        line = input().split()
        nums = [int(x) for x in line]
        
        if nums == [0, 0, 0, 0]:
            break
        
        expr = generate_expressions(nums)
        if expr:
            results.append(expr)
        else:
            results.append(""0"")
    
    for result in results:
        print(result)

solve()
",0
p00041,"式
与えられた 4 つの 1 から 9 の整数を使って、答えが 10 になる式をつくります。
 4 つの整数
a, b, c, d
を入力したとき、下記の条件に従い、答えが 10 になる式を出力するプログラムを作成してください。また、答えが複数ある時は、最初に見つかった答えだけを出力するものとします。答えがない時は、0 と出力してください。
演算子として、加算 (+)、減算 (-)、乗算 (*) だけを使います。除算 (/) は使いません。使用できる演算子は３個です。
数を4つとも使わなければいけません。
4つの数の順番は自由に入れ換えてかまいません。
カッコを使ってもかまいません。使用できるカッコは３組（６個）以下です。
Input
複数のデータセットが与えられます。各データセットの形式は以下のとおり：
a
b
c
d
入力は４つの 0 で終了します。データセットの数は 40 を超えません。
Output
各データセットについて、与えられた 4 つの整数と上記の演算記号およびカッコを組み合わせて値が 10 となる式または 0 を１行に出力してください。式の文字列が 1024 文字を超えてはいけません。
Sample Input
8 7 9 9
4 4 4 4
5 5 7 5
0 0 0 0
Output for the Sample Input
((9 * (9 - 7)) - 8)
0
((7 * 5) - (5 * 5))",Python,"from itertools import *
def f(s):
 if sum(s)==10:return""((({} + {}) + {}) + {})"".format(*s)
 for a,b,c,d in permutations(s):
  for x,y,z in permutations('+-**',3):
   for t in[f""({a} {x} {b}) {y} ({c} {z} {d})"",f""(({a} {x} {b}) {y} {c}) {z} {d}"",f""({a} {x} ({b} {y} {c})) {z} {d}""]:
    if eval(t)==10:return'('+t+')'
 else:return 0
for e in iter(input,'0 0 0 0'):print(f(list(map(int,e.split()))))
",1
p00044,"素数 II
素数というのは、1 よりも大きくそれ自身か 1 でしか割りきれない整数をいいます。例えば、2 は、2 と 1 でしか割り切れないので素数ですが、12 は、12 と 1 のほかに、2, 3, 4, 6 で割りきれる数なので素数ではありません。
整数
n
を入力したとき、
n
より小さい素数のうち最も大きいものと、
n
より大きい素数のうち最も小さいものを出力するプログラムを作成してください。
Input
複数のデータセットが与えられます。各データセットに
n
(3 ≤
n
≤ 50,000) が１行に与えられます。
データセットの数は 50 を超えません。
Output
各データセットに対して、
n
より小さい素数のうち最大のものと、
n
より大きい素数のうち最小のものを１つのスペースで区切って１行に出力して下さい。
Sample Input
19
3517
Output for the Sample Input
17 23
3511 3527",C,"#include <stdio.h>
#include <stdbool.h>
#include <math.h>

bool is_prime(int num) {
    if (num < 2) return false;
    if (num == 2) return true;
    if (num % 2 == 0) return false;
    
    int sqrt_num = (int)sqrt(num);
    for (int i = 3; i <= sqrt_num; i += 2) {
        if (num % i == 0) return false;
    }
    return true;
}

int main() {
    int n;
    
    while (scanf(""%d"", &n) != EOF) {
        int smaller = n - 1;
        int larger = n + 1;
        
        while (smaller >= 2 && !is_prime(smaller)) {
            smaller--;
        }
        
        while (!is_prime(larger)) {
            larger++;
        }
        
        printf(""%d %d\n"", smaller, larger);
    }
    
    return 0;
}
",0
p00044,"素数 II
素数というのは、1 よりも大きくそれ自身か 1 でしか割りきれない整数をいいます。例えば、2 は、2 と 1 でしか割り切れないので素数ですが、12 は、12 と 1 のほかに、2, 3, 4, 6 で割りきれる数なので素数ではありません。
整数
n
を入力したとき、
n
より小さい素数のうち最も大きいものと、
n
より大きい素数のうち最も小さいものを出力するプログラムを作成してください。
Input
複数のデータセットが与えられます。各データセットに
n
(3 ≤
n
≤ 50,000) が１行に与えられます。
データセットの数は 50 を超えません。
Output
各データセットに対して、
n
より小さい素数のうち最大のものと、
n
より大きい素数のうち最小のものを１つのスペースで区切って１行に出力して下さい。
Sample Input
19
3517
Output for the Sample Input
17 23
3511 3527",C,"#include<stdio.h>

int main(void)
{
  int i,j;
  int prime[70000];
  int n;
  for(i=0;i<60000;i++){
    prime[i] = 1;
  }
  prime[0]=0;
  scanf(""%d"",&n);

  for(i=1;i*i<=60000;i++){
    if(prime[i]==1){
      for(j=i+1;(i+1)*j<=60000;j++){
	prime[(i+1)*j-1]=0;
      }
    }
  }

  for(i=n-2;0<=i;i--){
    if(prime[i]==1){
      printf(""%d "",i+1); break;
    }
  }

  for(i=n;i<60000;i++){
    if(prime[i]==1){
      printf(""%d"",i+1); break;
    }
  }
  putchar('\n');
  return 0;
}",1
p00044,"素数 II
素数というのは、1 よりも大きくそれ自身か 1 でしか割りきれない整数をいいます。例えば、2 は、2 と 1 でしか割り切れないので素数ですが、12 は、12 と 1 のほかに、2, 3, 4, 6 で割りきれる数なので素数ではありません。
整数
n
を入力したとき、
n
より小さい素数のうち最も大きいものと、
n
より大きい素数のうち最も小さいものを出力するプログラムを作成してください。
Input
複数のデータセットが与えられます。各データセットに
n
(3 ≤
n
≤ 50,000) が１行に与えられます。
データセットの数は 50 を超えません。
Output
各データセットに対して、
n
より小さい素数のうち最大のものと、
n
より大きい素数のうち最小のものを１つのスペースで区切って１行に出力して下さい。
Sample Input
19
3517
Output for the Sample Input
17 23
3511 3527",Java,"import java.util.*;

public class Main {
    static boolean[] isPrime;
    static final int MAX = 100001;
    
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        
        // Sieve of Eratosthenes
        isPrime = new boolean[MAX];
        Arrays.fill(isPrime, true);
        isPrime[0] = isPrime[1] = false;
        
        for (int i = 2; i * i < MAX; i++) {
            if (isPrime[i]) {
                for (int j = i * i; j < MAX; j += i) {
                    isPrime[j] = false;
                }
            }
        }
        
        while (sc.hasNext()) {
            int n = sc.nextInt();
            
            int smaller = 0;
            for (int i = n - 1; i >= 2; i--) {
                if (isPrime[i]) {
                    smaller = i;
                    break;
                }
            }
            
            int larger = 0;
            for (int i = n + 1; i < MAX; i++) {
                if (isPrime[i]) {
                    larger = i;
                    break;
                }
            }
            
            System.out.println(smaller + "" "" + larger);
        }
        
        sc.close();
    }
}
",0
p00044,"素数 II
素数というのは、1 よりも大きくそれ自身か 1 でしか割りきれない整数をいいます。例えば、2 は、2 と 1 でしか割り切れないので素数ですが、12 は、12 と 1 のほかに、2, 3, 4, 6 で割りきれる数なので素数ではありません。
整数
n
を入力したとき、
n
より小さい素数のうち最も大きいものと、
n
より大きい素数のうち最も小さいものを出力するプログラムを作成してください。
Input
複数のデータセットが与えられます。各データセットに
n
(3 ≤
n
≤ 50,000) が１行に与えられます。
データセットの数は 50 を超えません。
Output
各データセットに対して、
n
より小さい素数のうち最大のものと、
n
より大きい素数のうち最小のものを１つのスペースで区切って１行に出力して下さい。
Sample Input
19
3517
Output for the Sample Input
17 23
3511 3527",Java,"import java.util.Scanner;
public class Main {
	public static void main(String[] args){
		Scanner sc=new Scanner(System.in);
		while(sc.hasNext()){
			int n=sc.nextInt();
			for(int i=n-1;i>=2;i--){
				boolean flag=true;
				for(int j=2;j<Math.sqrt(i)+1;j++){
					if(i%j==0){
						flag=false;
						break;
					}
				}
				if(flag){
					System.out.print(i+"" "");
					break;
				}
			}
			for(int i=n+1;i<50000;i++){
				boolean flag=true;
				for(int j=2;j<Math.sqrt(i)+1;j++){
					if(i%j==0){
						flag=false;
						break;
					}
				}
				if(flag){
					System.out.println(i);
					break;
				}
			}
		}
	}
}",1
p00044,"素数 II
素数というのは、1 よりも大きくそれ自身か 1 でしか割りきれない整数をいいます。例えば、2 は、2 と 1 でしか割り切れないので素数ですが、12 は、12 と 1 のほかに、2, 3, 4, 6 で割りきれる数なので素数ではありません。
整数
n
を入力したとき、
n
より小さい素数のうち最も大きいものと、
n
より大きい素数のうち最も小さいものを出力するプログラムを作成してください。
Input
複数のデータセットが与えられます。各データセットに
n
(3 ≤
n
≤ 50,000) が１行に与えられます。
データセットの数は 50 を超えません。
Output
各データセットに対して、
n
より小さい素数のうち最大のものと、
n
より大きい素数のうち最小のものを１つのスペースで区切って１行に出力して下さい。
Sample Input
19
3517
Output for the Sample Input
17 23
3511 3527",Python,"import sys

def sieve_of_eratosthenes(limit):
    is_prime = [True] * (limit + 1)
    is_prime[0] = is_prime[1] = False
    
    for i in range(2, int(limit**0.5) + 1):
        if is_prime[i]:
            for j in range(i*i, limit + 1, i):
                is_prime[j] = False
    
    return is_prime

# Precompute primes up to a reasonable limit
MAX_LIMIT = 100000
is_prime = sieve_of_eratosthenes(MAX_LIMIT)

for line in sys.stdin:
    n = int(line.strip())
    
    # Find largest prime less than n
    smaller = n - 1
    while smaller > 1 and not is_prime[smaller]:
        smaller -= 1
    
    # Find smallest prime greater than n
    larger = n + 1
    while larger <= MAX_LIMIT and not is_prime[larger]:
        larger += 1
    
    print(smaller, larger)
",0
p00044,"素数 II
素数というのは、1 よりも大きくそれ自身か 1 でしか割りきれない整数をいいます。例えば、2 は、2 と 1 でしか割り切れないので素数ですが、12 は、12 と 1 のほかに、2, 3, 4, 6 で割りきれる数なので素数ではありません。
整数
n
を入力したとき、
n
より小さい素数のうち最も大きいものと、
n
より大きい素数のうち最も小さいものを出力するプログラムを作成してください。
Input
複数のデータセットが与えられます。各データセットに
n
(3 ≤
n
≤ 50,000) が１行に与えられます。
データセットの数は 50 を超えません。
Output
各データセットに対して、
n
より小さい素数のうち最大のものと、
n
より大きい素数のうち最小のものを１つのスペースで区切って１行に出力して下さい。
Sample Input
19
3517
Output for the Sample Input
17 23
3511 3527",Python,"import math

r = 50000
sqrt = int(math.sqrt(r))
p = [1]*r
p[0] = 0
for i in range(1,sqrt):
    if p[i]:
        for j in range(2*i+1,r,i+1):
            p[j] = 0
            
while True:
    try:
        n = int(raw_input())
        for i in range(n,50000):
            if p[i] == 1:
                lp = i+1
                break
        for i in range(n-2,0,-1):
            if p[i] == 1:
                sp = i+1
                break
        print sp, lp
    except:
        break",1
p00045,"Sum and Average
販売単価と販売数量を読み込んで、販売金額の総合計と販売数量の平均を出力するプログラムを作成してください。
Input
入力は以下の形式で与えられます。
販売単価,販売数量
販売単価,販売数量
:
:
カンマで区切られた販売単価と販売数量の組が、複数行に渡って与えられます。入力される値はすべて 0 以上 1,000 以下で、販売単価と販売数量の組の数は 100 を超えません。
Output
１行目に販売金額の総合計（整数）、２行目に販売数量の平均(整数）を出力してください。
販売数量の平均に端数（小数点以下の数）が生じた場合は小数点以下第 1 位を四捨五入してください。
Sample Input
100,20
50,10
70,35
Output for the Sample Input
4950
22",C,"#include <stdio.h>

int main() {
    int price, quantity;
    int total_sales = 0;
    int total_quantity = 0;
    int count = 0;
    
    while (scanf(""%d,%d"", &price, &quantity) == 2) {
        total_sales += price * quantity;
        total_quantity += quantity;
        count++;
    }
    
    int average = (total_quantity + count / 2) / count;
    
    printf(""%d\n"", total_sales);
    printf(""%d\n"", average);
    
    return 0;
}
",0
p00045,"Sum and Average
販売単価と販売数量を読み込んで、販売金額の総合計と販売数量の平均を出力するプログラムを作成してください。
Input
入力は以下の形式で与えられます。
販売単価,販売数量
販売単価,販売数量
:
:
カンマで区切られた販売単価と販売数量の組が、複数行に渡って与えられます。入力される値はすべて 0 以上 1,000 以下で、販売単価と販売数量の組の数は 100 を超えません。
Output
１行目に販売金額の総合計（整数）、２行目に販売数量の平均(整数）を出力してください。
販売数量の平均に端数（小数点以下の数）が生じた場合は小数点以下第 1 位を四捨五入してください。
Sample Input
100,20
50,10
70,35
Output for the Sample Input
4950
22",C,"#include <stdio.h>

int main(int argc, char *argv[]){
  int prise,num;
  long long int sum = 0;
  int num_sum = 0;
  int times = 0;
  
  while(scanf(""%d,%d"",&prise,&num) != EOF){
    sum += (long long int)(prise)*(long long int)(num);
    num_sum += num;
    ++times;
  }

  printf(""%lld\n%.0lf\n"",sum,(double)(num_sum)/times);
  
  return 0;    
}",1
p00045,"Sum and Average
販売単価と販売数量を読み込んで、販売金額の総合計と販売数量の平均を出力するプログラムを作成してください。
Input
入力は以下の形式で与えられます。
販売単価,販売数量
販売単価,販売数量
:
:
カンマで区切られた販売単価と販売数量の組が、複数行に渡って与えられます。入力される値はすべて 0 以上 1,000 以下で、販売単価と販売数量の組の数は 100 を超えません。
Output
１行目に販売金額の総合計（整数）、２行目に販売数量の平均(整数）を出力してください。
販売数量の平均に端数（小数点以下の数）が生じた場合は小数点以下第 1 位を四捨五入してください。
Sample Input
100,20
50,10
70,35
Output for the Sample Input
4950
22",Java,"import java.util.Scanner;

public class Main {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        
        int totalAmount = 0;
        int totalQuantity = 0;
        int count = 0;
        
        while (sc.hasNextLine()) {
            String line = sc.nextLine();
            if (line.isEmpty()) break;
            
            String[] parts = line.split("","");
            int price = Integer.parseInt(parts[0]);
            int quantity = Integer.parseInt(parts[1]);
            
            totalAmount += price * quantity;
            totalQuantity += quantity;
            count++;
        }
        
        int averageQuantity = (int) Math.round((double) totalQuantity / count);
        
        System.out.println(totalAmount);
        System.out.println(averageQuantity);
        
        sc.close();
    }
}
",0
p00045,"Sum and Average
販売単価と販売数量を読み込んで、販売金額の総合計と販売数量の平均を出力するプログラムを作成してください。
Input
入力は以下の形式で与えられます。
販売単価,販売数量
販売単価,販売数量
:
:
カンマで区切られた販売単価と販売数量の組が、複数行に渡って与えられます。入力される値はすべて 0 以上 1,000 以下で、販売単価と販売数量の組の数は 100 を超えません。
Output
１行目に販売金額の総合計（整数）、２行目に販売数量の平均(整数）を出力してください。
販売数量の平均に端数（小数点以下の数）が生じた場合は小数点以下第 1 位を四捨五入してください。
Sample Input
100,20
50,10
70,35
Output for the Sample Input
4950
22",Java,"import java.io.*;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Scanner;
public class Main {

	public static void main(String[] args) {
		Scanner stdIn = new Scanner(System.in);
		int count = 0;
		int sum = 0;
		int sum2 = 0;
		while(stdIn.hasNext()) {
			count++;
			String[] in = stdIn.next().split("","");
			int a = Integer.parseInt(in[0]);
			int b = Integer.parseInt(in[1]);
			sum += a*b;
			sum2 += b;
		}
		System.out.println(sum);
		double ave = sum2/(double)count*10;
		if(ave%10 >= 5) {
			ave += 10-ave%10;
		}
		else {
			ave -= (ave*10)%10;
		}
		ave /=10;
		
		System.out.println((int)ave);
	}
}",1
p00045,"Sum and Average
販売単価と販売数量を読み込んで、販売金額の総合計と販売数量の平均を出力するプログラムを作成してください。
Input
入力は以下の形式で与えられます。
販売単価,販売数量
販売単価,販売数量
:
:
カンマで区切られた販売単価と販売数量の組が、複数行に渡って与えられます。入力される値はすべて 0 以上 1,000 以下で、販売単価と販売数量の組の数は 100 を超えません。
Output
１行目に販売金額の総合計（整数）、２行目に販売数量の平均(整数）を出力してください。
販売数量の平均に端数（小数点以下の数）が生じた場合は小数点以下第 1 位を四捨五入してください。
Sample Input
100,20
50,10
70,35
Output for the Sample Input
4950
22",Python,"import sys

total_amount = 0
total_quantity = 0
count = 0

for line in sys.stdin:
    line = line.strip()
    if line:
        price, quantity = map(int, line.split(','))
        total_amount += price * quantity
        total_quantity += quantity
        count += 1

average_quantity = round(total_quantity / count)

print(total_amount)
print(average_quantity)
",0
p00045,"Sum and Average
販売単価と販売数量を読み込んで、販売金額の総合計と販売数量の平均を出力するプログラムを作成してください。
Input
入力は以下の形式で与えられます。
販売単価,販売数量
販売単価,販売数量
:
:
カンマで区切られた販売単価と販売数量の組が、複数行に渡って与えられます。入力される値はすべて 0 以上 1,000 以下で、販売単価と販売数量の組の数は 100 を超えません。
Output
１行目に販売金額の総合計（整数）、２行目に販売数量の平均(整数）を出力してください。
販売数量の平均に端数（小数点以下の数）が生じた場合は小数点以下第 1 位を四捨五入してください。
Sample Input
100,20
50,10
70,35
Output for the Sample Input
4950
22",Python,"# _*_ coding: utf-8 _*_

sum = 0
total = 0
cnt = 0

while True:
	s = input()
	
	if s == '':
		break
	
	list = s.split(',')
	sum += int(list[0])*int(list[1])
	total += int(list[1])
	cnt += 1

ave = total / cnt + 0.5

print(sum)
print(int(ave))",1
p00046,"標高差
今まで登ったことのある山の標高を記録したデータがあります。このデータを読み込んで、一番高い山と一番低い山の標高差を出力するプログラムを作成してください。
Input
入力は以下の形式で与えられます。
山の高さ
...
...
山の高さが複数行に渡って与えられます。入力される値はすべて 0 以上 1,000,000 以下の実数です。入力される山の高さの数は 50 以下です。
Output
一番高い山と一番低い山の標高差を実数で出力する。出力は0.01以下の誤差を含んでもよい。
Sample Input
3776.0
1819.0
645.2
2004.1
1208.6
Output for the Sample Input
3130.8",C,"#include <stdio.h>

int main() {
    double height;
    double max = -1;
    double min = 1000001;
    
    while (scanf(""%lf"", &height) == 1) {
        if (height > max) {
            max = height;
        }
        if (height < min) {
            min = height;
        }
    }
    
    printf(""%.1f\n"", max - min);
    
    return 0;
}
",0
p00046,"標高差
今まで登ったことのある山の標高を記録したデータがあります。このデータを読み込んで、一番高い山と一番低い山の標高差を出力するプログラムを作成してください。
Input
入力は以下の形式で与えられます。
山の高さ
...
...
山の高さが複数行に渡って与えられます。入力される値はすべて 0 以上 1,000,000 以下の実数です。入力される山の高さの数は 50 以下です。
Output
一番高い山と一番低い山の標高差を実数で出力する。出力は0.01以下の誤差を含んでもよい。
Sample Input
3776.0
1819.0
645.2
2004.1
1208.6
Output for the Sample Input
3130.8",C,"#include <stdio.h>
int main(void) {
    double i,max,min;
    scanf(""%lf"",&max);
    min=max;
    while(1) {
        if(scanf(""%lf"",&i) == -0){
            break;
        }
        if(i < min){
            min = i;
        }
        if(i > max){
            max = i;
        }
    }
    printf(""%f\n"",max-min);
    return 0;
}",1
p00046,"標高差
今まで登ったことのある山の標高を記録したデータがあります。このデータを読み込んで、一番高い山と一番低い山の標高差を出力するプログラムを作成してください。
Input
入力は以下の形式で与えられます。
山の高さ
...
...
山の高さが複数行に渡って与えられます。入力される値はすべて 0 以上 1,000,000 以下の実数です。入力される山の高さの数は 50 以下です。
Output
一番高い山と一番低い山の標高差を実数で出力する。出力は0.01以下の誤差を含んでもよい。
Sample Input
3776.0
1819.0
645.2
2004.1
1208.6
Output for the Sample Input
3130.8",Java,"import java.util.Scanner;

public class Main {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        
        double max = Double.MIN_VALUE;
        double min = Double.MAX_VALUE;
        
        while (sc.hasNextDouble()) {
            double height = sc.nextDouble();
            if (height > max) {
                max = height;
            }
            if (height < min) {
                min = height;
            }
        }
        
        double diff = max - min;
        System.out.println(diff);
        
        sc.close();
    }
}
",0
p00046,"標高差
今まで登ったことのある山の標高を記録したデータがあります。このデータを読み込んで、一番高い山と一番低い山の標高差を出力するプログラムを作成してください。
Input
入力は以下の形式で与えられます。
山の高さ
...
...
山の高さが複数行に渡って与えられます。入力される値はすべて 0 以上 1,000,000 以下の実数です。入力される山の高さの数は 50 以下です。
Output
一番高い山と一番低い山の標高差を実数で出力する。出力は0.01以下の誤差を含んでもよい。
Sample Input
3776.0
1819.0
645.2
2004.1
1208.6
Output for the Sample Input
3130.8",Java,"import java.util.Scanner;

public class Main {
	public static void main(String[] args) {
		Scanner scan = new Scanner(System.in);
		double height = Double.MIN_VALUE,min = Double.MAX_VALUE;
		while(scan.hasNext()) {
			double mount = scan.nextDouble();
			if(height < mount) {
				height = mount;
			}
			if(min > mount) {
				min = mount;
			}
		}
		System.out.println(height - min);
		scan.close();
	}
}
",1
p00046,"標高差
今まで登ったことのある山の標高を記録したデータがあります。このデータを読み込んで、一番高い山と一番低い山の標高差を出力するプログラムを作成してください。
Input
入力は以下の形式で与えられます。
山の高さ
...
...
山の高さが複数行に渡って与えられます。入力される値はすべて 0 以上 1,000,000 以下の実数です。入力される山の高さの数は 50 以下です。
Output
一番高い山と一番低い山の標高差を実数で出力する。出力は0.01以下の誤差を含んでもよい。
Sample Input
3776.0
1819.0
645.2
2004.1
1208.6
Output for the Sample Input
3130.8",Python,"import sys

heights = []
for line in sys.stdin:
    heights.append(float(line.strip()))

print(max(heights) - min(heights))
",0
p00046,"標高差
今まで登ったことのある山の標高を記録したデータがあります。このデータを読み込んで、一番高い山と一番低い山の標高差を出力するプログラムを作成してください。
Input
入力は以下の形式で与えられます。
山の高さ
...
...
山の高さが複数行に渡って与えられます。入力される値はすべて 0 以上 1,000,000 以下の実数です。入力される山の高さの数は 50 以下です。
Output
一番高い山と一番低い山の標高差を実数で出力する。出力は0.01以下の誤差を含んでもよい。
Sample Input
3776.0
1819.0
645.2
2004.1
1208.6
Output for the Sample Input
3130.8",Python,"fir=0
sec=0

while True:
        try:
                a=raw_input()
                if a >= fir:
                        sec = fir
                        fir = a
                elif a >= sec:
                        sec = a
        except EOFError:
                break

print fir-sec",1
p00047,"カップゲーム
3 つのカップがふせて置かれています。カップの置かれている場所を、順に A,B,C と呼ぶことにします。最初は A に置かれているカップの中にボールが隠されているとします。カップの位置を入れ替えると、中に入っているボールも一緒に移動します。
入れ替える２つのカップの位置を読み込んで、最終的にどの場所のカップにボールが隠されているかを出力するプログラムを作成してください。
Input
入れ替える２つのカップの位置が順番に複数行にわたり与えられます。各行に、入れ替える２つのカップの位置を表す文字（A, B, または C）がカンマ区切りで与えられます。
入れ替える操作は 50 回を超えません。
Output
ボールが入っているカップの場所（A, B, または C）を１行に出力します。
Sample Input
B,C
A,C
C,B
A,B
C,B
Output for the Sample Input
A",C,"#include <stdio.h>

int main() {
    char ball = 'A';
    char line[10];
    
    while (fgets(line, sizeof(line), stdin) != NULL) {
        char pos1 = line[0];
        char pos2 = line[2];
        
        if (ball == pos1) {
            ball = pos2;
        } else if (ball == pos2) {
            ball = pos1;
        }
    }
    
    printf(""%c\n"", ball);
    
    return 0;
}
",0
p00047,"カップゲーム
3 つのカップがふせて置かれています。カップの置かれている場所を、順に A,B,C と呼ぶことにします。最初は A に置かれているカップの中にボールが隠されているとします。カップの位置を入れ替えると、中に入っているボールも一緒に移動します。
入れ替える２つのカップの位置を読み込んで、最終的にどの場所のカップにボールが隠されているかを出力するプログラムを作成してください。
Input
入れ替える２つのカップの位置が順番に複数行にわたり与えられます。各行に、入れ替える２つのカップの位置を表す文字（A, B, または C）がカンマ区切りで与えられます。
入れ替える操作は 50 回を超えません。
Output
ボールが入っているカップの場所（A, B, または C）を１行に出力します。
Sample Input
B,C
A,C
C,B
A,B
C,B
Output for the Sample Input
A",C,"#include<stdio.h>

int main(void){
	int ball[3];
	int x,y,temp;
	char a,b;
	ball[0]=1;ball[1]=0;ball[2]=0;
	while(scanf(""%c,%c"",&a,&b)!=EOF){
		switch(a){
		case 'A':x=0;break;
		case 'B':x=1;break;
		case 'C':x=2;break;
		}
		switch(b){
		case 'A':y=0;break;
		case 'B':y=1;break;
		case 'C':y=2;break;
		}
		temp=ball[x];ball[x]=ball[y];ball[y]=temp;
	}
	if(ball[0]==1){
		printf(""A\n"");
	}else if(ball[1]==1){
		printf(""B\n"");
	}else{printf(""C\n"");}
	return 0;
}",1
p00047,"カップゲーム
3 つのカップがふせて置かれています。カップの置かれている場所を、順に A,B,C と呼ぶことにします。最初は A に置かれているカップの中にボールが隠されているとします。カップの位置を入れ替えると、中に入っているボールも一緒に移動します。
入れ替える２つのカップの位置を読み込んで、最終的にどの場所のカップにボールが隠されているかを出力するプログラムを作成してください。
Input
入れ替える２つのカップの位置が順番に複数行にわたり与えられます。各行に、入れ替える２つのカップの位置を表す文字（A, B, または C）がカンマ区切りで与えられます。
入れ替える操作は 50 回を超えません。
Output
ボールが入っているカップの場所（A, B, または C）を１行に出力します。
Sample Input
B,C
A,C
C,B
A,B
C,B
Output for the Sample Input
A",Java,"import java.util.Scanner;

public class Main {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        
        char ball = 'A';
        
        while (sc.hasNextLine()) {
            String line = sc.nextLine().trim();
            if (line.isEmpty()) break;
            
            String[] positions = line.split("","");
            char pos1 = positions[0].charAt(0);
            char pos2 = positions[1].charAt(0);
            
            if (ball == pos1) {
                ball = pos2;
            } else if (ball == pos2) {
                ball = pos1;
            }
        }
        
        System.out.println(ball);
        sc.close();
    }
}
",0
p00047,"カップゲーム
3 つのカップがふせて置かれています。カップの置かれている場所を、順に A,B,C と呼ぶことにします。最初は A に置かれているカップの中にボールが隠されているとします。カップの位置を入れ替えると、中に入っているボールも一緒に移動します。
入れ替える２つのカップの位置を読み込んで、最終的にどの場所のカップにボールが隠されているかを出力するプログラムを作成してください。
Input
入れ替える２つのカップの位置が順番に複数行にわたり与えられます。各行に、入れ替える２つのカップの位置を表す文字（A, B, または C）がカンマ区切りで与えられます。
入れ替える操作は 50 回を超えません。
Output
ボールが入っているカップの場所（A, B, または C）を１行に出力します。
Sample Input
B,C
A,C
C,B
A,B
C,B
Output for the Sample Input
A",Java,"import java.io.*;

public class Main{
	public static void main(String[] args)throws IOException{
		BufferedReader reader=new BufferedReader(new InputStreamReader(System.in));
		String s;
		String[] t;
		int[] location=new int[3];
		location[0]=1;
		location[1]=0;
		location[2]=0;
		int alt;
		int[] number=new int[2];
		while((s=reader.readLine())!=null){
			if(s.isEmpty()){
				break;
			}
			if(s==""""){break;}
			t=s.split("","");
			for(int i=0;i<2;i++){
				if(t[i]==""A""){number[i]=0;}
					else if(t[i]==""B""){number[i]=1;}
					else if(t[i]==""C""){number[i]=2;}	
			}
			alt=location[number[0]];
			location[number[0]]=location[number[1]];
			location[number[1]]=alt;
		}
			for(int j=0;j<3;j++){
				if(location[j]==1){
					switch(j){
						case 0:
							System.out.println(""A"");
							break;
						case 1:
							System.out.println(""B"");
							break;
						case 2:
							System.out.println(""C"");
							break;
					}
				}
			}
	}
}",1
p00047,"カップゲーム
3 つのカップがふせて置かれています。カップの置かれている場所を、順に A,B,C と呼ぶことにします。最初は A に置かれているカップの中にボールが隠されているとします。カップの位置を入れ替えると、中に入っているボールも一緒に移動します。
入れ替える２つのカップの位置を読み込んで、最終的にどの場所のカップにボールが隠されているかを出力するプログラムを作成してください。
Input
入れ替える２つのカップの位置が順番に複数行にわたり与えられます。各行に、入れ替える２つのカップの位置を表す文字（A, B, または C）がカンマ区切りで与えられます。
入れ替える操作は 50 回を超えません。
Output
ボールが入っているカップの場所（A, B, または C）を１行に出力します。
Sample Input
B,C
A,C
C,B
A,B
C,B
Output for the Sample Input
A",Python,"import sys

ball_position = 'A'

for line in sys.stdin:
    line = line.strip()
    if not line:
        continue
    pos1, pos2 = line.split(',')
    
    if ball_position == pos1:
        ball_position = pos2
    elif ball_position == pos2:
        ball_position = pos1

print(ball_position)
",0
p00047,"カップゲーム
3 つのカップがふせて置かれています。カップの置かれている場所を、順に A,B,C と呼ぶことにします。最初は A に置かれているカップの中にボールが隠されているとします。カップの位置を入れ替えると、中に入っているボールも一緒に移動します。
入れ替える２つのカップの位置を読み込んで、最終的にどの場所のカップにボールが隠されているかを出力するプログラムを作成してください。
Input
入れ替える２つのカップの位置が順番に複数行にわたり与えられます。各行に、入れ替える２つのカップの位置を表す文字（A, B, または C）がカンマ区切りで与えられます。
入れ替える操作は 50 回を超えません。
Output
ボールが入っているカップの場所（A, B, または C）を１行に出力します。
Sample Input
B,C
A,C
C,B
A,B
C,B
Output for the Sample Input
A",Python,"# -*- coding: utf-8 -*-

import sys
import os
import math
import itertools

A = [1, 0, 0]

for s in sys.stdin:
    s = s.strip()
    a, b = s.split(',')

    if a == 'A':
        i = 0
    elif a == 'B':
        i = 1
    elif a == 'C':
        i = 2

    if b == 'A':
        j = 0
    elif b == 'B':
        j = 1
    elif b == 'C':
        j = 2

    A[i], A[j] = A[j], A[i]

if A[0] == 1:
    print('A')
elif A[1] == 1:
    print('B')
else:
    print('C')",1
p00048,"階級
ボクシングは体重によって階級が分けられています。体重を読み込んで、その階級を出力するプログラムを作成してください。階級と体重の関係は以下の表のとおりとします。
階級
体重（kg）
light fly
48.00kg 以下
fly
48.00kg 超 51.00kg 以下
bantam
51.00kg 超 54.00kg 以下
feather
54.00kg 超 57.00kg 以下
light
57.00kg 超 60.00kg 以下
light welter
60.00kg 超 64.00kg 以下
welter
64.00kg 超 69.00 kg 以下
light middle
69.00kg 超 75.00 kg 以下
middle
75.00kg 超 81.00 kg 以下
light heavy
81.00kg 超 91.00 kg 以下
heavy
91.00kg 超
Input
入力は複数のデータセットからなります。各データセットとして、体重を表す１つの実数
w
(40 ≤
w
≤ 150) が１行に与えられます。データセットの数は 50 を超えません。
Output
データセットごとに、対応する階級を１行に出力します。
Sample Input
60.2
70.2
48.0
80.2
Output for the Sample Input
light welter
light middle
light fly
middle",C,"#include <stdio.h>

int main() {
    double w;
    
    while (scanf(""%lf"", &w) != EOF) {
        if (w <= 48.00) {
            printf(""light fly\n"");
        } else if (w <= 51.00) {
            printf(""fly\n"");
        } else if (w <= 54.00) {
            printf(""bantam\n"");
        } else if (w <= 57.00) {
            printf(""feather\n"");
        } else if (w <= 60.00) {
            printf(""light\n"");
        } else if (w <= 64.00) {
            printf(""light welter\n"");
        } else if (w <= 69.00) {
            printf(""welter\n"");
        } else if (w <= 75.00) {
            printf(""light middle\n"");
        } else if (w <= 81.00) {
            printf(""middle\n"");
        } else if (w <= 91.00) {
            printf(""light heavy\n"");
        } else {
            printf(""heavy\n"");
        }
    }
    
    return 0;
}
",0
p00048,"階級
ボクシングは体重によって階級が分けられています。体重を読み込んで、その階級を出力するプログラムを作成してください。階級と体重の関係は以下の表のとおりとします。
階級
体重（kg）
light fly
48.00kg 以下
fly
48.00kg 超 51.00kg 以下
bantam
51.00kg 超 54.00kg 以下
feather
54.00kg 超 57.00kg 以下
light
57.00kg 超 60.00kg 以下
light welter
60.00kg 超 64.00kg 以下
welter
64.00kg 超 69.00 kg 以下
light middle
69.00kg 超 75.00 kg 以下
middle
75.00kg 超 81.00 kg 以下
light heavy
81.00kg 超 91.00 kg 以下
heavy
91.00kg 超
Input
入力は複数のデータセットからなります。各データセットとして、体重を表す１つの実数
w
(40 ≤
w
≤ 150) が１行に与えられます。データセットの数は 50 を超えません。
Output
データセットごとに、対応する階級を１行に出力します。
Sample Input
60.2
70.2
48.0
80.2
Output for the Sample Input
light welter
light middle
light fly
middle",C,"#include <stdio.h>

int main(void)
{
	float g;
	
	scanf(""%f"", &g);
	
	if (g <= 48.00){
		printf(""light fly\n"");
	}
	else if ((48.00 < g)&&(g <= 51.00)){
		printf(""fly\n"");
	}
	else if ((51.00 < g)&&(g <= 54.00)){
		printf(""bantam\n"");
	}
	else if ((54.00 < g)&&(g <= 57.00)){
		printf(""feather\n"");
	}
	else if ((57.00 < g)&&(g <= 60.00)){
		printf(""light\n"");
	}
	else if ((60.00 < g)&&(g <= 64.00)){
		printf(""light welter\n"");
	}
	else if ((64.00 < g)&&(g <= 69.00)){
		printf(""welter\n"");
	}
	else if ((69.00 < g)&&(g <= 75.00)){
		printf(""light middle\n"");
	}
	else if ((75.00 < g)&&(g <= 81.00)){
		printf(""middle\n"");
	}
	else if ((81.00 < g)&&(g <= 91.00)){
		printf(""light heavy\n"");
	}
	else if (91.00 < g){
		printf(""heavy\n"");
	}
	
	
	return (0);
}",1
p00048,"階級
ボクシングは体重によって階級が分けられています。体重を読み込んで、その階級を出力するプログラムを作成してください。階級と体重の関係は以下の表のとおりとします。
階級
体重（kg）
light fly
48.00kg 以下
fly
48.00kg 超 51.00kg 以下
bantam
51.00kg 超 54.00kg 以下
feather
54.00kg 超 57.00kg 以下
light
57.00kg 超 60.00kg 以下
light welter
60.00kg 超 64.00kg 以下
welter
64.00kg 超 69.00 kg 以下
light middle
69.00kg 超 75.00 kg 以下
middle
75.00kg 超 81.00 kg 以下
light heavy
81.00kg 超 91.00 kg 以下
heavy
91.00kg 超
Input
入力は複数のデータセットからなります。各データセットとして、体重を表す１つの実数
w
(40 ≤
w
≤ 150) が１行に与えられます。データセットの数は 50 を超えません。
Output
データセットごとに、対応する階級を１行に出力します。
Sample Input
60.2
70.2
48.0
80.2
Output for the Sample Input
light welter
light middle
light fly
middle",Java,"import java.util.Scanner;

public class Main {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        
        while (sc.hasNext()) {
            double w = sc.nextDouble();
            
            if (w <= 48.00) {
                System.out.println(""light fly"");
            } else if (w <= 51.00) {
                System.out.println(""fly"");
            } else if (w <= 54.00) {
                System.out.println(""bantam"");
            } else if (w <= 57.00) {
                System.out.println(""feather"");
            } else if (w <= 60.00) {
                System.out.println(""light"");
            } else if (w <= 64.00) {
                System.out.println(""light welter"");
            } else if (w <= 69.00) {
                System.out.println(""welter"");
            } else if (w <= 75.00) {
                System.out.println(""light middle"");
            } else if (w <= 81.00) {
                System.out.println(""middle"");
            } else if (w <= 91.00) {
                System.out.println(""light heavy"");
            } else {
                System.out.println(""heavy"");
            }
        }
        
        sc.close();
    }
}
",0
p00048,"階級
ボクシングは体重によって階級が分けられています。体重を読み込んで、その階級を出力するプログラムを作成してください。階級と体重の関係は以下の表のとおりとします。
階級
体重（kg）
light fly
48.00kg 以下
fly
48.00kg 超 51.00kg 以下
bantam
51.00kg 超 54.00kg 以下
feather
54.00kg 超 57.00kg 以下
light
57.00kg 超 60.00kg 以下
light welter
60.00kg 超 64.00kg 以下
welter
64.00kg 超 69.00 kg 以下
light middle
69.00kg 超 75.00 kg 以下
middle
75.00kg 超 81.00 kg 以下
light heavy
81.00kg 超 91.00 kg 以下
heavy
91.00kg 超
Input
入力は複数のデータセットからなります。各データセットとして、体重を表す１つの実数
w
(40 ≤
w
≤ 150) が１行に与えられます。データセットの数は 50 を超えません。
Output
データセットごとに、対応する階級を１行に出力します。
Sample Input
60.2
70.2
48.0
80.2
Output for the Sample Input
light welter
light middle
light fly
middle",Java,"import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.ArrayList;
public class Main{
	public static void main(String[] args) throws IOException{
		BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
		String str;
		ArrayList<String> list = new ArrayList<String>();
		while((str=br.readLine())!=null){
			list.add(check(Double.parseDouble(str)));
		}
		for(String d : list){
			System.out.println(d);
		}
		
	}
	public static String check(double weight){
		if(weight > 91.0){
            return ""heavy"";
        }
        else if(weight > 81.0){
            return ""light heavy"";
        }
        else if(weight > 75.0){
            return ""middle"";
        }
        else if(weight > 69.0){
            return ""light middle"";
        }
        else if(weight > 64.0){
            return ""welter"";
        }
        else if(weight > 60.0){
            return ""light welter"";
        }
        else if(weight > 57.0){
            return ""light"";
        }
        else if(weight > 54.0){
            return ""feather"";
        }
        else if(weight > 51.0){
            return ""bantam"";
        }
        else if(weight > 48.0){
            return ""fly"";
        }
        else{
            return ""light fly"";
        }
	}
}",1
p00048,"階級
ボクシングは体重によって階級が分けられています。体重を読み込んで、その階級を出力するプログラムを作成してください。階級と体重の関係は以下の表のとおりとします。
階級
体重（kg）
light fly
48.00kg 以下
fly
48.00kg 超 51.00kg 以下
bantam
51.00kg 超 54.00kg 以下
feather
54.00kg 超 57.00kg 以下
light
57.00kg 超 60.00kg 以下
light welter
60.00kg 超 64.00kg 以下
welter
64.00kg 超 69.00 kg 以下
light middle
69.00kg 超 75.00 kg 以下
middle
75.00kg 超 81.00 kg 以下
light heavy
81.00kg 超 91.00 kg 以下
heavy
91.00kg 超
Input
入力は複数のデータセットからなります。各データセットとして、体重を表す１つの実数
w
(40 ≤
w
≤ 150) が１行に与えられます。データセットの数は 50 を超えません。
Output
データセットごとに、対応する階級を１行に出力します。
Sample Input
60.2
70.2
48.0
80.2
Output for the Sample Input
light welter
light middle
light fly
middle",Python,"import sys

for line in sys.stdin:
    w = float(line.strip())
    
    if w <= 48.00:
        print(""light fly"")
    elif w <= 51.00:
        print(""fly"")
    elif w <= 54.00:
        print(""bantam"")
    elif w <= 57.00:
        print(""feather"")
    elif w <= 60.00:
        print(""light"")
    elif w <= 64.00:
        print(""light welter"")
    elif w <= 69.00:
        print(""welter"")
    elif w <= 75.00:
        print(""light middle"")
    elif w <= 81.00:
        print(""middle"")
    elif w <= 91.00:
        print(""light heavy"")
    else:
        print(""heavy"")
",0
p00048,"階級
ボクシングは体重によって階級が分けられています。体重を読み込んで、その階級を出力するプログラムを作成してください。階級と体重の関係は以下の表のとおりとします。
階級
体重（kg）
light fly
48.00kg 以下
fly
48.00kg 超 51.00kg 以下
bantam
51.00kg 超 54.00kg 以下
feather
54.00kg 超 57.00kg 以下
light
57.00kg 超 60.00kg 以下
light welter
60.00kg 超 64.00kg 以下
welter
64.00kg 超 69.00 kg 以下
light middle
69.00kg 超 75.00 kg 以下
middle
75.00kg 超 81.00 kg 以下
light heavy
81.00kg 超 91.00 kg 以下
heavy
91.00kg 超
Input
入力は複数のデータセットからなります。各データセットとして、体重を表す１つの実数
w
(40 ≤
w
≤ 150) が１行に与えられます。データセットの数は 50 を超えません。
Output
データセットごとに、対応する階級を１行に出力します。
Sample Input
60.2
70.2
48.0
80.2
Output for the Sample Input
light welter
light middle
light fly
middle",Python,"from decimal import Decimal
import sys

def classify(w):
    if w <= Decimal(""48.00""):
        return ""light fly""
    elif Decimal(""48.00"") < w <= Decimal(""51.00""):
        return ""fly""
    elif Decimal(""51.00"") < w <= Decimal(""54.00""):
        return ""bantam""
    elif Decimal(""54.00"") < w <= Decimal(""57.00""):
        return ""feather""
    elif Decimal(""57.00"") < w <= Decimal(""60.00""):
        return ""light""
    elif Decimal(""60.00"") < w <= Decimal(""64.00""):
        return ""light welter""
    elif Decimal(""64.00"") < w <= Decimal(""69.00""):
        return ""welter""
    elif Decimal(""69.00"") < w <= Decimal(""75.00""):
        return ""light middle""
    elif Decimal(""75.00"") < w <= Decimal(""81.00""):
        return ""middle""
    elif Decimal(""81.00"") < w <= Decimal(""91.00""):
        return ""light heavy""
    else:
        return ""heavy""
    
[print(classify(Decimal(j))) for j in [i for i in sys.stdin]]

",1
p00049,"血液型
ある学級の生徒の出席番号と ABO 血液型を保存したデータを読み込んで、おのおのの血液型の人数を出力するプログラムを作成してください。なお、ABO 血液型には、A 型、B 型、AB 型、O 型の４種類の血液型があります。
Input
カンマで区切られた出席番号と血液型の組が、複数行に渡って与えられます。出席番号は 1 以上 50 以下の整数、血液型は文字列 ""A"", ""B"", ""AB"" または ""O"" のいずれかです。生徒の人数は 50 を超えません。
Output
１行目に A 型の人数
２行目に B 型の人数
３行目に AB 型の人数
４行目に O 型の人数
を出力します。
Sample Input
1,B
2,A
3,B
4,AB
5,B
6,O
7,A
8,O
9,AB
10,A
11,A
12,B
13,AB
14,A
Output for the Sample Input
5
4
3
2",C,"#include <stdio.h>
#include <string.h>

int main() {
    int num;
    char blood[10];
    int countA = 0, countB = 0, countAB = 0, countO = 0;
    
    while (scanf(""%d,%s"", &num, blood) == 2) {
        if (strcmp(blood, ""A"") == 0) {
            countA++;
        } else if (strcmp(blood, ""B"") == 0) {
            countB++;
        } else if (strcmp(blood, ""AB"") == 0) {
            countAB++;
        } else if (strcmp(blood, ""O"") == 0) {
            countO++;
        }
    }
    
    printf(""%d\n"", countA);
    printf(""%d\n"", countB);
    printf(""%d\n"", countAB);
    printf(""%d\n"", countO);
    
    return 0;
}
",0
p00049,"血液型
ある学級の生徒の出席番号と ABO 血液型を保存したデータを読み込んで、おのおのの血液型の人数を出力するプログラムを作成してください。なお、ABO 血液型には、A 型、B 型、AB 型、O 型の４種類の血液型があります。
Input
カンマで区切られた出席番号と血液型の組が、複数行に渡って与えられます。出席番号は 1 以上 50 以下の整数、血液型は文字列 ""A"", ""B"", ""AB"" または ""O"" のいずれかです。生徒の人数は 50 を超えません。
Output
１行目に A 型の人数
２行目に B 型の人数
３行目に AB 型の人数
４行目に O 型の人数
を出力します。
Sample Input
1,B
2,A
3,B
4,AB
5,B
6,O
7,A
8,O
9,AB
10,A
11,A
12,B
13,AB
14,A
Output for the Sample Input
5
4
3
2",C,"// Aizu Vol0 0049: Blood Groups
// 2017.7.29

#include <stdio.h>
#include <stdlib.h>
#include <ctype.h>

char *gets(char *);

#define MAX 50

int blood[MAX + 5];
int cnt[5];

int main()
{
	char buf[100], *p;
	int k, t;

	for (k = 0; k <= MAX; k++) blood[k] = 0;
	for (k = 1; k < 5; k++) cnt[k] = 0;
	while (gets(buf) != NULL) {
		p = buf;

		while (isspace(*p)) p++;
		k = *p++ - '0';
		if (isdigit(*p)) k = k * 10 + (*p++ - '0');

		while (isspace(*p)) p++;  // ','
		p++;

		while (isspace(*p)) p++;
		if (*p == 'A' && *(p + 1) == 'B') t = 3;
		else if (*p == 'B') t = 2;
		else if (*p == 'O') t = 4;
		else t = 1;

		if (blood[k] == 0) {
			blood[k] = t;
			cnt[t]++;
		} else if (blood[k] != t) while (1);
	}
	for (k = 1; k < 5; k++) printf(""%d\n"", cnt[k]);
	return 0;
}",1
p00049,"血液型
ある学級の生徒の出席番号と ABO 血液型を保存したデータを読み込んで、おのおのの血液型の人数を出力するプログラムを作成してください。なお、ABO 血液型には、A 型、B 型、AB 型、O 型の４種類の血液型があります。
Input
カンマで区切られた出席番号と血液型の組が、複数行に渡って与えられます。出席番号は 1 以上 50 以下の整数、血液型は文字列 ""A"", ""B"", ""AB"" または ""O"" のいずれかです。生徒の人数は 50 を超えません。
Output
１行目に A 型の人数
２行目に B 型の人数
３行目に AB 型の人数
４行目に O 型の人数
を出力します。
Sample Input
1,B
2,A
3,B
4,AB
5,B
6,O
7,A
8,O
9,AB
10,A
11,A
12,B
13,AB
14,A
Output for the Sample Input
5
4
3
2",Java,"import java.util.Scanner;

public class Main {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        
        int countA = 0;
        int countB = 0;
        int countAB = 0;
        int countO = 0;
        
        while (sc.hasNextLine()) {
            String line = sc.nextLine();
            if (line.isEmpty()) break;
            
            String[] parts = line.split("","");
            String bloodType = parts[1];
            
            switch (bloodType) {
                case ""A"":
                    countA++;
                    break;
                case ""B"":
                    countB++;
                    break;
                case ""AB"":
                    countAB++;
                    break;
                case ""O"":
                    countO++;
                    break;
            }
        }
        
        System.out.println(countA);
        System.out.println(countB);
        System.out.println(countAB);
        System.out.println(countO);
        
        sc.close();
    }
}
",0
p00049,"血液型
ある学級の生徒の出席番号と ABO 血液型を保存したデータを読み込んで、おのおのの血液型の人数を出力するプログラムを作成してください。なお、ABO 血液型には、A 型、B 型、AB 型、O 型の４種類の血液型があります。
Input
カンマで区切られた出席番号と血液型の組が、複数行に渡って与えられます。出席番号は 1 以上 50 以下の整数、血液型は文字列 ""A"", ""B"", ""AB"" または ""O"" のいずれかです。生徒の人数は 50 を超えません。
Output
１行目に A 型の人数
２行目に B 型の人数
３行目に AB 型の人数
４行目に O 型の人数
を出力します。
Sample Input
1,B
2,A
3,B
4,AB
5,B
6,O
7,A
8,O
9,AB
10,A
11,A
12,B
13,AB
14,A
Output for the Sample Input
5
4
3
2",Java,"import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;

public class Main {
	public static void main(String[] args){
		int[] abo = {0,0,0,0};
		BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
		String tmp = null;
		int cup = 0;
		int mun = 0;
		int ter = 0;
		String[] rrr;
		int st = 0,sr = 0;
		int mon = 0;
		int syo=0,hisi=0;
		
		
		
		while(true){
			
			try {
				tmp = br.readLine();
			} catch (IOException e) {
				// TODO 自動生成された catch ブロック
				e.printStackTrace();
			}
			
			if(tmp == null){
				break;
			}
			
			if(tmp.equals("""")){
				break;
			}
			
			rrr = tmp.split("","");
			
			if(rrr[1].equals(""A"")){
				abo[0]++;
			}else if(rrr[1].equals(""B"")){
				abo[1]++;
			}else if(rrr[1].equals(""AB"")){
				abo[2]++;
			}else if(rrr[1].equals(""O"")){
				abo[3]++;
			}
		}
		System.out.println(abo[0]);
		System.out.println(abo[1]);
		System.out.println(abo[2]);
		System.out.println(abo[3]);
	}

}",1
p00049,"血液型
ある学級の生徒の出席番号と ABO 血液型を保存したデータを読み込んで、おのおのの血液型の人数を出力するプログラムを作成してください。なお、ABO 血液型には、A 型、B 型、AB 型、O 型の４種類の血液型があります。
Input
カンマで区切られた出席番号と血液型の組が、複数行に渡って与えられます。出席番号は 1 以上 50 以下の整数、血液型は文字列 ""A"", ""B"", ""AB"" または ""O"" のいずれかです。生徒の人数は 50 を超えません。
Output
１行目に A 型の人数
２行目に B 型の人数
３行目に AB 型の人数
４行目に O 型の人数
を出力します。
Sample Input
1,B
2,A
3,B
4,AB
5,B
6,O
7,A
8,O
9,AB
10,A
11,A
12,B
13,AB
14,A
Output for the Sample Input
5
4
3
2",Python,"import sys

count = {'A': 0, 'B': 0, 'AB': 0, 'O': 0}

for line in sys.stdin:
    line = line.strip()
    if line:
        parts = line.split(',')
        blood_type = parts[1]
        count[blood_type] += 1

print(count['A'])
print(count['B'])
print(count['AB'])
print(count['O'])
",0
p00049,"血液型
ある学級の生徒の出席番号と ABO 血液型を保存したデータを読み込んで、おのおのの血液型の人数を出力するプログラムを作成してください。なお、ABO 血液型には、A 型、B 型、AB 型、O 型の４種類の血液型があります。
Input
カンマで区切られた出席番号と血液型の組が、複数行に渡って与えられます。出席番号は 1 以上 50 以下の整数、血液型は文字列 ""A"", ""B"", ""AB"" または ""O"" のいずれかです。生徒の人数は 50 を超えません。
Output
１行目に A 型の人数
２行目に B 型の人数
３行目に AB 型の人数
４行目に O 型の人数
を出力します。
Sample Input
1,B
2,A
3,B
4,AB
5,B
6,O
7,A
8,O
9,AB
10,A
11,A
12,B
13,AB
14,A
Output for the Sample Input
5
4
3
2",Python,"import sys
a = 0
b = 0
ab = 0
o = 0
for i in sys.stdin.readlines():
    if i.find("",AB"") > -1:
        ab += 1
    elif i.find("",B"") > -1:
        b += 1
    elif i.find("",A"") >-1:
        a += 1
    else:
        o += 1
print(a)
print(b)
print(ab)
print(o)",1
p00050,"りんごと桃
福島県は果物の産地としても有名で、その中でも特に桃とりんごは全国でも指折りの生産量を誇っています。ところで、ある販売用の英文パンフレットの印刷原稿を作ったところ、手違いでりんごに関する記述と桃に関する記述を逆に書いてしまいました。
あなたは、apple と peach を修正する仕事を任されましたが、なにぶん面倒です。１行の英文を入力して、そのなかの apple という文字列を全て peach に、peach という文字列を全てapple に交換した英文を出力するプログラムを作成してください。
Input
英文（半角英数字、空白、記号を含む）が１行に与えられます。入力される文字列の長さは 1000 以下です。
Output
apple とpeach という文字列を交換した英文を１行に出力します。
Sample Input
the cost of one peach is higher than that of one apple.
Output for the Sample Input
the cost of one apple is higher than that of one peach.",C,"#include <stdio.h>
#include <string.h>

int main() {
    char line[1001];
    char result[10001];
    int i, j;
    
    fgets(line, sizeof(line), stdin);
    
    i = 0;
    j = 0;
    while (line[i] != '\0' && line[i] != '\n') {
        if (strncmp(&line[i], ""apple"", 5) == 0) {
            strcpy(&result[j], ""peach"");
            j += 5;
            i += 5;
        } else if (strncmp(&line[i], ""peach"", 5) == 0) {
            strcpy(&result[j], ""apple"");
            j += 5;
            i += 5;
        } else {
            result[j] = line[i];
            j++;
            i++;
        }
    }
    result[j] = '\0';
    
    printf(""%s\n"", result);
    
    return 0;
}
",0
p00050,"りんごと桃
福島県は果物の産地としても有名で、その中でも特に桃とりんごは全国でも指折りの生産量を誇っています。ところで、ある販売用の英文パンフレットの印刷原稿を作ったところ、手違いでりんごに関する記述と桃に関する記述を逆に書いてしまいました。
あなたは、apple と peach を修正する仕事を任されましたが、なにぶん面倒です。１行の英文を入力して、そのなかの apple という文字列を全て peach に、peach という文字列を全てapple に交換した英文を出力するプログラムを作成してください。
Input
英文（半角英数字、空白、記号を含む）が１行に与えられます。入力される文字列の長さは 1000 以下です。
Output
apple とpeach という文字列を交換した英文を１行に出力します。
Sample Input
the cost of one peach is higher than that of one apple.
Output for the Sample Input
the cost of one apple is higher than that of one peach.",C,"#include <stdio.h>
#include <string.h>

int main(void){
	char text[1002],i,n;
	fgets(text,1002,stdin);
	n=strlen(text);
	for(i=0;i<n-5;i++){
		if(text[i]=='a' && text[i+1]=='p' && text[i+2]=='p' && text[i+3]=='l' && text[i+4]=='e'){
			text[i]='p';text[i+1]='e';text[i+2]='a';text[i+3]='c';text[i+4]='h';
		}
		else if(text[i]=='p' && text[i+1]=='e' && text[i+2]=='a' && text[i+3]=='c' && text[i+4]=='h'){
			text[i]='a';text[i+1]='p';text[i+2]='p';text[i+3]='l';text[i+4]='e';
		}
		if(text[i]=='A' && text[i+1]=='p' && text[i+2]=='p' && text[i+3]=='l' && text[i+4]=='e'){
			text[i]='P';text[i+1]='e';text[i+2]='a';text[i+3]='c';text[i+4]='h';
		}
		else if(text[i]=='P' && text[i+1]=='e' && text[i+2]=='a' && text[i+3]=='c' && text[i+4]=='h'){
			text[i]='A';text[i+1]='p';text[i+2]='p';text[i+3]='l';text[i+4]='e';
		}
	}
	printf(""%s"",text);
	return 0;
}",1
p00050,"りんごと桃
福島県は果物の産地としても有名で、その中でも特に桃とりんごは全国でも指折りの生産量を誇っています。ところで、ある販売用の英文パンフレットの印刷原稿を作ったところ、手違いでりんごに関する記述と桃に関する記述を逆に書いてしまいました。
あなたは、apple と peach を修正する仕事を任されましたが、なにぶん面倒です。１行の英文を入力して、そのなかの apple という文字列を全て peach に、peach という文字列を全てapple に交換した英文を出力するプログラムを作成してください。
Input
英文（半角英数字、空白、記号を含む）が１行に与えられます。入力される文字列の長さは 1000 以下です。
Output
apple とpeach という文字列を交換した英文を１行に出力します。
Sample Input
the cost of one peach is higher than that of one apple.
Output for the Sample Input
the cost of one apple is higher than that of one peach.",Java,"import java.util.Scanner;

public class Main {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        String line = sc.nextLine();
        
        String result = line.replace(""apple"", ""TEMP"")
                           .replace(""peach"", ""apple"")
                           .replace(""TEMP"", ""peach"");
        
        System.out.println(result);
        sc.close();
    }
}
",0
p00050,"りんごと桃
福島県は果物の産地としても有名で、その中でも特に桃とりんごは全国でも指折りの生産量を誇っています。ところで、ある販売用の英文パンフレットの印刷原稿を作ったところ、手違いでりんごに関する記述と桃に関する記述を逆に書いてしまいました。
あなたは、apple と peach を修正する仕事を任されましたが、なにぶん面倒です。１行の英文を入力して、そのなかの apple という文字列を全て peach に、peach という文字列を全てapple に交換した英文を出力するプログラムを作成してください。
Input
英文（半角英数字、空白、記号を含む）が１行に与えられます。入力される文字列の長さは 1000 以下です。
Output
apple とpeach という文字列を交換した英文を１行に出力します。
Sample Input
the cost of one peach is higher than that of one apple.
Output for the Sample Input
the cost of one apple is higher than that of one peach.",Java,"import java.util.Scanner;
class Main {
	public static void main(String[] args) {
		Scanner in = new Scanner(System.in);
		StringBuilder ans = new StringBuilder();
		while(in.hasNext()) {
			String x = in.next();
			if(x.contains(""apple""))
				ans.append(x.replace(""apple"",""peach"")).append("" "");
			else if(x.contains(""peach""))
				ans.append(x.replace(""peach"",""apple"")).append("" "");
			else
				ans.append(x).append("" "");
		}
		System.out.println(ans.toString().trim());
	}
}",1
p00050,"りんごと桃
福島県は果物の産地としても有名で、その中でも特に桃とりんごは全国でも指折りの生産量を誇っています。ところで、ある販売用の英文パンフレットの印刷原稿を作ったところ、手違いでりんごに関する記述と桃に関する記述を逆に書いてしまいました。
あなたは、apple と peach を修正する仕事を任されましたが、なにぶん面倒です。１行の英文を入力して、そのなかの apple という文字列を全て peach に、peach という文字列を全てapple に交換した英文を出力するプログラムを作成してください。
Input
英文（半角英数字、空白、記号を含む）が１行に与えられます。入力される文字列の長さは 1000 以下です。
Output
apple とpeach という文字列を交換した英文を１行に出力します。
Sample Input
the cost of one peach is higher than that of one apple.
Output for the Sample Input
the cost of one apple is higher than that of one peach.",Python,"s = input()
s = s.replace('apple', '@TEMP@').replace('peach', 'apple').replace('@TEMP@', 'peach')
print(s)
",0
p00050,"りんごと桃
福島県は果物の産地としても有名で、その中でも特に桃とりんごは全国でも指折りの生産量を誇っています。ところで、ある販売用の英文パンフレットの印刷原稿を作ったところ、手違いでりんごに関する記述と桃に関する記述を逆に書いてしまいました。
あなたは、apple と peach を修正する仕事を任されましたが、なにぶん面倒です。１行の英文を入力して、そのなかの apple という文字列を全て peach に、peach という文字列を全てapple に交換した英文を出力するプログラムを作成してください。
Input
英文（半角英数字、空白、記号を含む）が１行に与えられます。入力される文字列の長さは 1000 以下です。
Output
apple とpeach という文字列を交換した英文を１行に出力します。
Sample Input
the cost of one peach is higher than that of one apple.
Output for the Sample Input
the cost of one apple is higher than that of one peach.",Python,"

sent = map(str, raw_input().split(' '))

for i in range(len(sent)):
    if sent[i] == 'apple' :
        sent[i] = 'peach'
    elif sent[i] == 'peach':
        sent[i] = 'apple'

    elif sent[i] == 'apple,' :
        sent[i] = 'peach,'
    elif sent[i] == 'peach,':
        sent[i] = 'apple,'

    elif sent[i] == 'apple.' :
        sent[i] = 'peach.'
    elif sent[i] == 'peach.':
        sent[i] = 'apple.'

    elif sent[i] == 'apple!' :
        sent[i] = 'peach!'
    elif sent[i] == 'peach!':
        sent[i] = 'apple!'

    elif sent[i] == 'apple?' :
        sent[i] = 'peach?'
    elif sent[i] == 'peach?':
        sent[i] = 'apple?'

 



for sen in sent:
    print sen,
    ",1
p00052,"階乗 II
n! = n × (n − 1) × (n − 2) ×
...
× 3 × 2 × 1
を
n
の階乗といいます。例えば、12 の階乗は
12! = 12 × 11 × 10 × 9 × 8 × 7 × 6 × 5 × 4 × 3 × 2 × 1 = 479001600
となり、末尾に 0 が 2 つ連続して並んでいます。
整数
n
を入力して、
n!
の末尾に連続して並んでいる 0 の数を出力するプログラムを作成してください。ただし、
n
は 20000 以下の正の整数とします。
Input
複数のデータが与えられます。各データに
n
(
n
≤ 20000) が１行に与えられます。
n
が 0 の時入力の最後とします。
データの数は 20 を超えません。
Output
各データに対して
n!
の末尾に連続して並んでいる 0 の数を１行に出力して下さい。
Sample Input
2
12
10000
0
Output for the Sample Input
0
2
2499",C,"#include <stdio.h>

int main() {
    int n;
    
    while(1) {
        scanf(""%d"", &n);
        if(n == 0) break;
        
        int count = 0;
        int temp = n;
        
        while(temp >= 5) {
            temp /= 5;
            count += temp;
        }
        
        printf(""%d\n"", count);
    }
    
    return 0;
}
",0
p00052,"階乗 II
n! = n × (n − 1) × (n − 2) ×
...
× 3 × 2 × 1
を
n
の階乗といいます。例えば、12 の階乗は
12! = 12 × 11 × 10 × 9 × 8 × 7 × 6 × 5 × 4 × 3 × 2 × 1 = 479001600
となり、末尾に 0 が 2 つ連続して並んでいます。
整数
n
を入力して、
n!
の末尾に連続して並んでいる 0 の数を出力するプログラムを作成してください。ただし、
n
は 20000 以下の正の整数とします。
Input
複数のデータが与えられます。各データに
n
(
n
≤ 20000) が１行に与えられます。
n
が 0 の時入力の最後とします。
データの数は 20 を超えません。
Output
各データに対して
n!
の末尾に連続して並んでいる 0 の数を１行に出力して下さい。
Sample Input
2
12
10000
0
Output for the Sample Input
0
2
2499",C,"#include <stdio.h>

int main(){
  long a,b,i,n;

  while(scanf(""%ld"",&n),n!=0){
    a=0;
    for(i=5;i<=n;i++){
      b=i;
      while(b>0){
        if(b%5!=0) break;
        a++;
        b=b/5;
      }
    }
    printf(""%ld\n"",a);
  }
  return 0;
}",1
p00052,"階乗 II
n! = n × (n − 1) × (n − 2) ×
...
× 3 × 2 × 1
を
n
の階乗といいます。例えば、12 の階乗は
12! = 12 × 11 × 10 × 9 × 8 × 7 × 6 × 5 × 4 × 3 × 2 × 1 = 479001600
となり、末尾に 0 が 2 つ連続して並んでいます。
整数
n
を入力して、
n!
の末尾に連続して並んでいる 0 の数を出力するプログラムを作成してください。ただし、
n
は 20000 以下の正の整数とします。
Input
複数のデータが与えられます。各データに
n
(
n
≤ 20000) が１行に与えられます。
n
が 0 の時入力の最後とします。
データの数は 20 を超えません。
Output
各データに対して
n!
の末尾に連続して並んでいる 0 の数を１行に出力して下さい。
Sample Input
2
12
10000
0
Output for the Sample Input
0
2
2499",Java,"import java.util.Scanner;

public class Main {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        
        while (true) {
            int n = sc.nextInt();
            if (n == 0) break;
            
            int count = 0;
            int temp = n;
            while (temp > 0) {
                temp /= 5;
                count += temp;
            }
            
            System.out.println(count);
        }
        
        sc.close();
    }
}
",0
p00052,"階乗 II
n! = n × (n − 1) × (n − 2) ×
...
× 3 × 2 × 1
を
n
の階乗といいます。例えば、12 の階乗は
12! = 12 × 11 × 10 × 9 × 8 × 7 × 6 × 5 × 4 × 3 × 2 × 1 = 479001600
となり、末尾に 0 が 2 つ連続して並んでいます。
整数
n
を入力して、
n!
の末尾に連続して並んでいる 0 の数を出力するプログラムを作成してください。ただし、
n
は 20000 以下の正の整数とします。
Input
複数のデータが与えられます。各データに
n
(
n
≤ 20000) が１行に与えられます。
n
が 0 の時入力の最後とします。
データの数は 20 を超えません。
Output
各データに対して
n!
の末尾に連続して並んでいる 0 の数を１行に出力して下さい。
Sample Input
2
12
10000
0
Output for the Sample Input
0
2
2499",Java,"import java.io.*;
import java.util.ArrayDeque;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.Comparator;
import java.util.Scanner;
public class Main {
	static ArrayList<Integer> list = new ArrayList<Integer>();
	public static void main(String[] args) {
		Scanner stdIn = new Scanner(System.in);
		makePrimeList();
		while(true) {
			int a = stdIn.nextInt();
			if(a == 0) break;
			int c2 = 0;
			int c5 = 0;
			for(int i = a; i >= 1; i--) {
				int[] ret = f(i);
				c2 += ret[0];
				c5 += ret[2];
			}
			int count = Math.min(c2, c5);
			
			System.out.println(count);
		}
	}
	public static void makePrimeList() {
		boolean[] isntPrime = new boolean[20001];
		isntPrime[0] = isntPrime[1] = true;
		list.add(2);
		for(int i = 3; i < 20001; i+= 2) {
			if(!isntPrime[i]) {
				list.add(i);
				for(int j = i + i; j < 20001; j+= i) {
					isntPrime[j] = true;
				}
			}
		}
	}
	public static int[] f(int a) {
		int[] ret = new int[list.size()];
		while(a > 1) {
			for(int i = 0; i < list.size(); i++) {
				if(a % list.get(i) == 0) {
					a /= list.get(i);
					ret[i]++;
				}
				
			}
			
		}
		return ret;
	}
	
	
}",1
p00052,"階乗 II
n! = n × (n − 1) × (n − 2) ×
...
× 3 × 2 × 1
を
n
の階乗といいます。例えば、12 の階乗は
12! = 12 × 11 × 10 × 9 × 8 × 7 × 6 × 5 × 4 × 3 × 2 × 1 = 479001600
となり、末尾に 0 が 2 つ連続して並んでいます。
整数
n
を入力して、
n!
の末尾に連続して並んでいる 0 の数を出力するプログラムを作成してください。ただし、
n
は 20000 以下の正の整数とします。
Input
複数のデータが与えられます。各データに
n
(
n
≤ 20000) が１行に与えられます。
n
が 0 の時入力の最後とします。
データの数は 20 を超えません。
Output
各データに対して
n!
の末尾に連続して並んでいる 0 の数を１行に出力して下さい。
Sample Input
2
12
10000
0
Output for the Sample Input
0
2
2499",Python,"import sys

def count_trailing_zeros(n):
    count = 0
    power_of_5 = 5
    while power_of_5 <= n:
        count += n // power_of_5
        power_of_5 *= 5
    return count

for line in sys.stdin:
    n = int(line.strip())
    if n == 0:
        break
    print(count_trailing_zeros(n))
",0
p00052,"階乗 II
n! = n × (n − 1) × (n − 2) ×
...
× 3 × 2 × 1
を
n
の階乗といいます。例えば、12 の階乗は
12! = 12 × 11 × 10 × 9 × 8 × 7 × 6 × 5 × 4 × 3 × 2 × 1 = 479001600
となり、末尾に 0 が 2 つ連続して並んでいます。
整数
n
を入力して、
n!
の末尾に連続して並んでいる 0 の数を出力するプログラムを作成してください。ただし、
n
は 20000 以下の正の整数とします。
Input
複数のデータが与えられます。各データに
n
(
n
≤ 20000) が１行に与えられます。
n
が 0 の時入力の最後とします。
データの数は 20 を超えません。
Output
各データに対して
n!
の末尾に連続して並んでいる 0 の数を１行に出力して下さい。
Sample Input
2
12
10000
0
Output for the Sample Input
0
2
2499",Python,"def f(n):
    for i in range(1,n):
        n*=i
    return n
        
        
while True:
    n=int(input())
    if n==0:
        break
    else:
        a=str(f(n))
        s=0
        l=len(a)
        for i in range(l-1,-1,-1):
            if a[i]==""0"":
                s+=1
            else:
                break
        print(s)
",1
p00053,"素数の和
p(i)
を小さい方から
i
番目の素数とします。例えば、7 は、2, 3, 5, 7 と小さい方から 4 番目の素数なので、
p(4) = 7
です。
n
が与えられたとき、
i = 1
から
n
までの
p(i)
の和
s
s = p(1) + p(2) +
....
+ p(n)
を出力するプログラムを作成してください。例えば、
n = 9
のとき、
s = 2 + 3 + 5 + 7 + 11 + 13 + 17 + 19 + 23 = 100
となります。
Input
複数のデータセットが与えられます。各データセットに整数
n
(
n
≤ 10000) が与えられます。
n
が 0 のとき入力の最後とします。データセットの数は 50 を超えません。
Output
各データセットの
n
に対して、
s
を１行に出力して下さい。
Sample Input
2
9
0
Output for the Sample Input
5
100",C,"#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#define MAX_N 10000
#define MAX_PRIME 104730

int is_prime[MAX_PRIME + 1];
int primes[MAX_N];
int prime_count = 0;

void sieve() {
    memset(is_prime, 1, sizeof(is_prime));
    is_prime[0] = is_prime[1] = 0;
    
    for (int i = 2; i * i <= MAX_PRIME; i++) {
        if (is_prime[i]) {
            for (int j = i * i; j <= MAX_PRIME; j += i) {
                is_prime[j] = 0;
            }
        }
    }
    
    for (int i = 2; i <= MAX_PRIME && prime_count < MAX_N; i++) {
        if (is_prime[i]) {
            primes[prime_count++] = i;
        }
    }
}

int main() {
    sieve();
    
    int n;
    while (scanf(""%d"", &n) == 1 && n != 0) {
        long long sum = 0;
        for (int i = 0; i < n; i++) {
            sum += primes[i];
        }
        printf(""%lld\n"", sum);
    }
    
    return 0;
}
",0
p00053,"素数の和
p(i)
を小さい方から
i
番目の素数とします。例えば、7 は、2, 3, 5, 7 と小さい方から 4 番目の素数なので、
p(4) = 7
です。
n
が与えられたとき、
i = 1
から
n
までの
p(i)
の和
s
s = p(1) + p(2) +
....
+ p(n)
を出力するプログラムを作成してください。例えば、
n = 9
のとき、
s = 2 + 3 + 5 + 7 + 11 + 13 + 17 + 19 + 23 = 100
となります。
Input
複数のデータセットが与えられます。各データセットに整数
n
(
n
≤ 10000) が与えられます。
n
が 0 のとき入力の最後とします。データセットの数は 50 を超えません。
Output
各データセットの
n
に対して、
s
を１行に出力して下さい。
Sample Input
2
9
0
Output for the Sample Input
5
100",C,"#include<stdio.h>
#include<math.h>

int main()
{
	int n=0,d,sw;
	long int i,j,k,s[1000],sum;

	while(1)
	{
		n=1;
		sum=0;
		scanf(""%d"",&d);
		if(!d)
			break;
		s[0]=2;
		s[1]=3;
		if(d<=2)
		{
			for(i=0;i<d;i++)
				sum+=s[i];
		}
		else
		{
			sum=5;
			for(i=5;;i+=2)
			{
				sw=0;
				k=(long int)sqrt((double)i);
				for(j=0;s[j]<=k;j++)
				{
					if(i%s[j]==0)
					{
						sw=1;
						break;
					}
				}
				if(!sw)
				{
					n++;
					if(n<1000)
						s[n]=i;
					sum+=i;
					if(n==d-1)
						break;
				}
			}
		}
		printf(""%d\n"",sum);
	}
	return 0;
}",1
p00053,"素数の和
p(i)
を小さい方から
i
番目の素数とします。例えば、7 は、2, 3, 5, 7 と小さい方から 4 番目の素数なので、
p(4) = 7
です。
n
が与えられたとき、
i = 1
から
n
までの
p(i)
の和
s
s = p(1) + p(2) +
....
+ p(n)
を出力するプログラムを作成してください。例えば、
n = 9
のとき、
s = 2 + 3 + 5 + 7 + 11 + 13 + 17 + 19 + 23 = 100
となります。
Input
複数のデータセットが与えられます。各データセットに整数
n
(
n
≤ 10000) が与えられます。
n
が 0 のとき入力の最後とします。データセットの数は 50 を超えません。
Output
各データセットの
n
に対して、
s
を１行に出力して下さい。
Sample Input
2
9
0
Output for the Sample Input
5
100",Java,"import java.util.*;

public class Main {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        
        // Pre-calculate primes up to a reasonable limit
        // For n=10000, we need the 10000th prime
        // The 10000th prime is approximately 104729
        int limit = 110000;
        boolean[] isPrime = new boolean[limit];
        Arrays.fill(isPrime, true);
        isPrime[0] = isPrime[1] = false;
        
        // Sieve of Eratosthenes
        for (int i = 2; i * i < limit; i++) {
            if (isPrime[i]) {
                for (int j = i * i; j < limit; j += i) {
                    isPrime[j] = false;
                }
            }
        }
        
        // Collect primes in order
        List<Integer> primes = new ArrayList<>();
        for (int i = 2; i < limit; i++) {
            if (isPrime[i]) {
                primes.add(i);
            }
        }
        
        // Pre-calculate cumulative sums
        long[] cumulativeSum = new long[primes.size() + 1];
        for (int i = 0; i < primes.size(); i++) {
            cumulativeSum[i + 1] = cumulativeSum[i] + primes.get(i);
        }
        
        // Process queries
        while (true) {
            int n = sc.nextInt();
            if (n == 0) break;
            System.out.println(cumulativeSum[n]);
        }
        
        sc.close();
    }
}
",0
p00053,"素数の和
p(i)
を小さい方から
i
番目の素数とします。例えば、7 は、2, 3, 5, 7 と小さい方から 4 番目の素数なので、
p(4) = 7
です。
n
が与えられたとき、
i = 1
から
n
までの
p(i)
の和
s
s = p(1) + p(2) +
....
+ p(n)
を出力するプログラムを作成してください。例えば、
n = 9
のとき、
s = 2 + 3 + 5 + 7 + 11 + 13 + 17 + 19 + 23 = 100
となります。
Input
複数のデータセットが与えられます。各データセットに整数
n
(
n
≤ 10000) が与えられます。
n
が 0 のとき入力の最後とします。データセットの数は 50 を超えません。
Output
各データセットの
n
に対して、
s
を１行に出力して下さい。
Sample Input
2
9
0
Output for the Sample Input
5
100",Java,"import java.util.*;
public class Main{
    static Scanner kbd = new Scanner(System.in);
    public static void main(String[] args){
	int[] p = new int[1000000];
	setP(p);
	while(kbd.hasNext()){
	    int n = kbd.nextInt();
	    if(n!=0) solve(p, n);
	}
    }

    static void solve(int[] p, int n){
	int sum=0, i;
	for(i=0; p[i]<=n; i++){
	    if(p[i]!=-1) {
		sum+=i;
		//System.out.println(i);
	    }
	}

	System.out.println(sum);
    }

    static void setP(int[] p){
	int a=1, i, j;
	Arrays.fill(p, 1);
	p[0] = -1;
	p[1] = -1;
	for(i=2; i<p.length; i++){
	    if(p[i] == 1){
		//System.out.println(i+"" ""+a);
		p[i] = a;
		a++;	
	    }
	    for(j=i+i; j<p.length; j+=i){
		p[j] = -1;
	    }
	}
    }
}",1
p00053,"素数の和
p(i)
を小さい方から
i
番目の素数とします。例えば、7 は、2, 3, 5, 7 と小さい方から 4 番目の素数なので、
p(4) = 7
です。
n
が与えられたとき、
i = 1
から
n
までの
p(i)
の和
s
s = p(1) + p(2) +
....
+ p(n)
を出力するプログラムを作成してください。例えば、
n = 9
のとき、
s = 2 + 3 + 5 + 7 + 11 + 13 + 17 + 19 + 23 = 100
となります。
Input
複数のデータセットが与えられます。各データセットに整数
n
(
n
≤ 10000) が与えられます。
n
が 0 のとき入力の最後とします。データセットの数は 50 を超えません。
Output
各データセットの
n
に対して、
s
を１行に出力して下さい。
Sample Input
2
9
0
Output for the Sample Input
5
100",Python,"def sieve_of_eratosthenes(limit):
    is_prime = [True] * (limit + 1)
    is_prime[0] = is_prime[1] = False
    
    for i in range(2, int(limit**0.5) + 1):
        if is_prime[i]:
            for j in range(i*i, limit + 1, i):
                is_prime[j] = False
    
    primes = [i for i in range(2, limit + 1) if is_prime[i]]
    return primes

# Pre-compute primes up to a sufficient limit
# For n=10000, we need the 10000th prime
# The 10000th prime is 104729
primes = sieve_of_eratosthenes(105000)

# Pre-compute cumulative sums
cumsum = [0]
for prime in primes:
    cumsum.append(cumsum[-1] + prime)

while True:
    n = int(input())
    if n == 0:
        break
    print(cumsum[n])
",0
p00053,"素数の和
p(i)
を小さい方から
i
番目の素数とします。例えば、7 は、2, 3, 5, 7 と小さい方から 4 番目の素数なので、
p(4) = 7
です。
n
が与えられたとき、
i = 1
から
n
までの
p(i)
の和
s
s = p(1) + p(2) +
....
+ p(n)
を出力するプログラムを作成してください。例えば、
n = 9
のとき、
s = 2 + 3 + 5 + 7 + 11 + 13 + 17 + 19 + 23 = 100
となります。
Input
複数のデータセットが与えられます。各データセットに整数
n
(
n
≤ 10000) が与えられます。
n
が 0 のとき入力の最後とします。データセットの数は 50 を超えません。
Output
各データセットの
n
に対して、
s
を１行に出力して下さい。
Sample Input
2
9
0
Output for the Sample Input
5
100",Python,"from itertools import *
n=range(104730);a=list(n)
for i in range(2,321):a[i*2::i]=[0]*len(a[i*2::i])
p=list(compress(n,a))
for e in iter(input,'0'):print(sum(p[:int(e)+1])-1)
",1
p00054,"小数位の和
a
,
b
,
n
は、いずれも正の整数であるとします。分数
a
/
b
の小数第
i
位の数を
f(i)
とします (0 ≤
f(i)
≤ 9)。このとき、
i = 1
から
n
までの
f(i)
の和を
s
とします。
s = f(1) + f(2) +
...
+ f(n)
a
,
b
,
n
を読み込んで、
s
を出力して終了するプログラムを作成してください。
Input
入力は複数のデータセットからなります。各データセットとして、3 つの整数
a
(1 ≤
a
≤ 1000),
b
(1 ≤
b
≤ 10000),
n
(1 ≤
n
≤ 100) が空白区切りで１行に与えられます。
データセットの数は 100 を超えません。
Output
データセットごとに、
s
を１行に出力します。
Sample Input
1 2 3
2 3 4
5 4 3
4 3 2
Output for the Sample Input
5
24
7
6",C,"#include <stdio.h>

int main() {
    int a, b, n;
    
    while (scanf(""%d %d %d"", &a, &b, &n) == 3) {
        int sum = 0;
        int remainder = a % b;
        
        for (int i = 0; i < n; i++) {
            remainder *= 10;
            int digit = remainder / b;
            sum += digit;
            remainder = remainder % b;
        }
        
        printf(""%d\n"", sum);
    }
    
    return 0;
}
",0
p00054,"小数位の和
a
,
b
,
n
は、いずれも正の整数であるとします。分数
a
/
b
の小数第
i
位の数を
f(i)
とします (0 ≤
f(i)
≤ 9)。このとき、
i = 1
から
n
までの
f(i)
の和を
s
とします。
s = f(1) + f(2) +
...
+ f(n)
a
,
b
,
n
を読み込んで、
s
を出力して終了するプログラムを作成してください。
Input
入力は複数のデータセットからなります。各データセットとして、3 つの整数
a
(1 ≤
a
≤ 1000),
b
(1 ≤
b
≤ 10000),
n
(1 ≤
n
≤ 100) が空白区切りで１行に与えられます。
データセットの数は 100 を超えません。
Output
データセットごとに、
s
を１行に出力します。
Sample Input
1 2 3
2 3 4
5 4 3
4 3 2
Output for the Sample Input
5
24
7
6",C,"#include <stdio.h>

int main(void) {
	int a,b,n;
	int sum;
	int i,j;
	while(1) {
		if(scanf(""%d %d %d"",&a,&b,&n)==-1)break;
		a-=a/b*b;
		sum=0;
		for(i=1;i<=n;i++) {
			a*=10;
			for(j=9;j>=0;j--) {
				if(b*j<=a)break;
			}
			a-=b*j;
			sum+=j;
		}
		printf(""%d\n"",sum);
	}
	return 0;
}",1
p00054,"小数位の和
a
,
b
,
n
は、いずれも正の整数であるとします。分数
a
/
b
の小数第
i
位の数を
f(i)
とします (0 ≤
f(i)
≤ 9)。このとき、
i = 1
から
n
までの
f(i)
の和を
s
とします。
s = f(1) + f(2) +
...
+ f(n)
a
,
b
,
n
を読み込んで、
s
を出力して終了するプログラムを作成してください。
Input
入力は複数のデータセットからなります。各データセットとして、3 つの整数
a
(1 ≤
a
≤ 1000),
b
(1 ≤
b
≤ 10000),
n
(1 ≤
n
≤ 100) が空白区切りで１行に与えられます。
データセットの数は 100 を超えません。
Output
データセットごとに、
s
を１行に出力します。
Sample Input
1 2 3
2 3 4
5 4 3
4 3 2
Output for the Sample Input
5
24
7
6",Java,"import java.util.Scanner;

public class Main {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        
        while (sc.hasNext()) {
            int a = sc.nextInt();
            int b = sc.nextInt();
            int n = sc.nextInt();
            
            int sum = 0;
            int remainder = a % b;
            
            for (int i = 0; i < n; i++) {
                remainder *= 10;
                int digit = remainder / b;
                sum += digit;
                remainder = remainder % b;
            }
            
            System.out.println(sum);
        }
        
        sc.close();
    }
}
",0
p00054,"小数位の和
a
,
b
,
n
は、いずれも正の整数であるとします。分数
a
/
b
の小数第
i
位の数を
f(i)
とします (0 ≤
f(i)
≤ 9)。このとき、
i = 1
から
n
までの
f(i)
の和を
s
とします。
s = f(1) + f(2) +
...
+ f(n)
a
,
b
,
n
を読み込んで、
s
を出力して終了するプログラムを作成してください。
Input
入力は複数のデータセットからなります。各データセットとして、3 つの整数
a
(1 ≤
a
≤ 1000),
b
(1 ≤
b
≤ 10000),
n
(1 ≤
n
≤ 100) が空白区切りで１行に与えられます。
データセットの数は 100 を超えません。
Output
データセットごとに、
s
を１行に出力します。
Sample Input
1 2 3
2 3 4
5 4 3
4 3 2
Output for the Sample Input
5
24
7
6",Java,"import java.util.Scanner;

public class Main{
	Main(){
		Scanner sc = new Scanner(System.in);
		
		while(sc.hasNext()){
			double a = sc.nextDouble();
			double b = sc.nextDouble();
			int n = sc.nextInt();
			int s = 0;
			String str = Double.toString((a/b)) + ""0000000000"";
			for(int i = 0; i < n; i++){
				s += Integer.parseInt(str.substring(i+2, i+3));
			}
			System.out.println(Integer.toString(s));
		}
	}
	
	public static void main(String[] args){
		new Main();
	}
}",1
p00054,"小数位の和
a
,
b
,
n
は、いずれも正の整数であるとします。分数
a
/
b
の小数第
i
位の数を
f(i)
とします (0 ≤
f(i)
≤ 9)。このとき、
i = 1
から
n
までの
f(i)
の和を
s
とします。
s = f(1) + f(2) +
...
+ f(n)
a
,
b
,
n
を読み込んで、
s
を出力して終了するプログラムを作成してください。
Input
入力は複数のデータセットからなります。各データセットとして、3 つの整数
a
(1 ≤
a
≤ 1000),
b
(1 ≤
b
≤ 10000),
n
(1 ≤
n
≤ 100) が空白区切りで１行に与えられます。
データセットの数は 100 を超えません。
Output
データセットごとに、
s
を１行に出力します。
Sample Input
1 2 3
2 3 4
5 4 3
4 3 2
Output for the Sample Input
5
24
7
6",Python,"import sys

for line in sys.stdin:
    a, b, n = map(int, line.split())
    s = 0
    remainder = a % b
    
    for i in range(n):
        remainder *= 10
        digit = remainder // b
        s += digit
        remainder = remainder % b
    
    print(s)
",0
p00054,"小数位の和
a
,
b
,
n
は、いずれも正の整数であるとします。分数
a
/
b
の小数第
i
位の数を
f(i)
とします (0 ≤
f(i)
≤ 9)。このとき、
i = 1
から
n
までの
f(i)
の和を
s
とします。
s = f(1) + f(2) +
...
+ f(n)
a
,
b
,
n
を読み込んで、
s
を出力して終了するプログラムを作成してください。
Input
入力は複数のデータセットからなります。各データセットとして、3 つの整数
a
(1 ≤
a
≤ 1000),
b
(1 ≤
b
≤ 10000),
n
(1 ≤
n
≤ 100) が空白区切りで１行に与えられます。
データセットの数は 100 を超えません。
Output
データセットごとに、
s
を１行に出力します。
Sample Input
1 2 3
2 3 4
5 4 3
4 3 2
Output for the Sample Input
5
24
7
6",Python,"t=10**9
while 1:
    try:
        a,b,n=map(int,raw_input().split())
        if b==0:
            print 0
            continue
        f=a*t/b
        f=str(f%t)
        ans=0
        for i in range(n):
            ans+=int(f[i])
        print ans
    except:
        break",1
p00055,"数列
次のように定義されている数列があります。
すべての偶数番目の項は一つ前の項に 2 を掛けたものと等しい数である。
すべての奇数番目の項は一つ前の項を 3 で割ったものと等しい数である。
この数列の初項
a
を読み込み、初項から第 10 項までの和
s(10)
を出力するプログラムを作成してください。
Input
入力は複数のテストケースからなります。各テストケースとして、数列の初項を表す実数
a
(1.0 ≤
a
≤ 10.0) が１行に与えられます。
テストケースの数は 50 を超えません。
Output
テストケースごとに
s(10)
を１行に出力します。
出力は0.000001以下の誤差を含んでもよい。
Sample Input
1.0
2.0
3.0
Output for the Sample Input
7.81481481
15.62962963
23.44444444",C,"#include <stdio.h>

int main() {
    double a;
    while (scanf(""%lf"", &a) != EOF) {
        double sum = 0.0;
        double current = a;
        
        for (int i = 1; i <= 10; i++) {
            sum += current;
            if (i % 2 == 0) {
                current = current / 3.0;
            } else {
                current = current * 2.0;
            }
        }
        
        printf(""%.8lf\n"", sum);
    }
    
    return 0;
}
",0
p00055,"数列
次のように定義されている数列があります。
すべての偶数番目の項は一つ前の項に 2 を掛けたものと等しい数である。
すべての奇数番目の項は一つ前の項を 3 で割ったものと等しい数である。
この数列の初項
a
を読み込み、初項から第 10 項までの和
s(10)
を出力するプログラムを作成してください。
Input
入力は複数のテストケースからなります。各テストケースとして、数列の初項を表す実数
a
(1.0 ≤
a
≤ 10.0) が１行に与えられます。
テストケースの数は 50 を超えません。
Output
テストケースごとに
s(10)
を１行に出力します。
出力は0.000001以下の誤差を含んでもよい。
Sample Input
1.0
2.0
3.0
Output for the Sample Input
7.81481481
15.62962963
23.44444444",C,"#include<stdio.h>
int main(void){
  int k;
  double a[11];
  double sum;
  while(scanf(""%lf"",&a[1])!=EOF){
    sum = a[1];
    printf(""test"");
    for(k=2;k=10;k++){
      if(k%2==0){
        a[k] = a[k-1] * 2;
      }else{
        a[k] = a[k-1] / 3;
      }
      sum += a[k];
    }
    printf(""%lf\n"",sum);
  }
  return 0;
}",1
p00055,"数列
次のように定義されている数列があります。
すべての偶数番目の項は一つ前の項に 2 を掛けたものと等しい数である。
すべての奇数番目の項は一つ前の項を 3 で割ったものと等しい数である。
この数列の初項
a
を読み込み、初項から第 10 項までの和
s(10)
を出力するプログラムを作成してください。
Input
入力は複数のテストケースからなります。各テストケースとして、数列の初項を表す実数
a
(1.0 ≤
a
≤ 10.0) が１行に与えられます。
テストケースの数は 50 を超えません。
Output
テストケースごとに
s(10)
を１行に出力します。
出力は0.000001以下の誤差を含んでもよい。
Sample Input
1.0
2.0
3.0
Output for the Sample Input
7.81481481
15.62962963
23.44444444",Java,"import java.util.Scanner;

public class Main {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        
        while (sc.hasNext()) {
            double a = sc.nextDouble();
            double sum = 0;
            double current = a;
            
            for (int i = 1; i <= 10; i++) {
                sum += current;
                if (i % 2 == 0) {
                    current = current / 3.0;
                } else {
                    current = current * 2.0;
                }
            }
            
            System.out.printf(""%.8f%n"", sum);
        }
        
        sc.close();
    }
}
",0
p00055,"数列
次のように定義されている数列があります。
すべての偶数番目の項は一つ前の項に 2 を掛けたものと等しい数である。
すべての奇数番目の項は一つ前の項を 3 で割ったものと等しい数である。
この数列の初項
a
を読み込み、初項から第 10 項までの和
s(10)
を出力するプログラムを作成してください。
Input
入力は複数のテストケースからなります。各テストケースとして、数列の初項を表す実数
a
(1.0 ≤
a
≤ 10.0) が１行に与えられます。
テストケースの数は 50 を超えません。
Output
テストケースごとに
s(10)
を１行に出力します。
出力は0.000001以下の誤差を含んでもよい。
Sample Input
1.0
2.0
3.0
Output for the Sample Input
7.81481481
15.62962963
23.44444444",Java,"import java.util.*;

public class Main{
    private static double calculation(double value){
	double sum = value;
	double[] values = new double[10];
	values[0] = value;
	
	for(int i = 1; i < 10; ++i){
	    if(i%2 == 1){
		values[i] = values[i-1]*2.0;
	    } else {
		values[i] = values[i-1]/3.0;
	    }
	    sum += values[i];
	}
	

	return sum;
    }
    
    public static void main(String[] args){
	Scanner sc = new Scanner(System.in);
	
	while(sc.hasNext()){
	    double value = sc.nextDouble();
	    System.out.printf(""%f\n"", calculation(value));
	}
    }
}",1
p00055,"数列
次のように定義されている数列があります。
すべての偶数番目の項は一つ前の項に 2 を掛けたものと等しい数である。
すべての奇数番目の項は一つ前の項を 3 で割ったものと等しい数である。
この数列の初項
a
を読み込み、初項から第 10 項までの和
s(10)
を出力するプログラムを作成してください。
Input
入力は複数のテストケースからなります。各テストケースとして、数列の初項を表す実数
a
(1.0 ≤
a
≤ 10.0) が１行に与えられます。
テストケースの数は 50 を超えません。
Output
テストケースごとに
s(10)
を１行に出力します。
出力は0.000001以下の誤差を含んでもよい。
Sample Input
1.0
2.0
3.0
Output for the Sample Input
7.81481481
15.62962963
23.44444444",Python,"import sys

for line in sys.stdin:
    a = float(line.strip())
    
    terms = [a]
    for i in range(1, 10):
        if i % 2 == 1:  # odd index (2nd, 4th, 6th... terms)
            terms.append(terms[-1] * 2)
        else:  # even index (3rd, 5th, 7th... terms)
            terms.append(terms[-1] / 3)
    
    s = sum(terms)
    print(f""{s:.8f}"")
",0
p00055,"数列
次のように定義されている数列があります。
すべての偶数番目の項は一つ前の項に 2 を掛けたものと等しい数である。
すべての奇数番目の項は一つ前の項を 3 で割ったものと等しい数である。
この数列の初項
a
を読み込み、初項から第 10 項までの和
s(10)
を出力するプログラムを作成してください。
Input
入力は複数のテストケースからなります。各テストケースとして、数列の初項を表す実数
a
(1.0 ≤
a
≤ 10.0) が１行に与えられます。
テストケースの数は 50 を超えません。
Output
テストケースごとに
s(10)
を１行に出力します。
出力は0.000001以下の誤差を含んでもよい。
Sample Input
1.0
2.0
3.0
Output for the Sample Input
7.81481481
15.62962963
23.44444444",Python,"while 1:
    try:n=float(input())
    except:break
    s=n
    for i in range(9):
        n=n/3 if i%2 else n*2
        s+=n
    print(s)",1
p00056,"ゴールドバッハの予想
4 以上の偶数は 2 つの素数の和で表すことができるということが知られています。これはゴールドバッハ予想といい、コンピュータの計算によりかなり大きな数まで正しいことが確かめられています。例えば、10 は、7 + 3、5 + 5 の 2 通りの素数の和で表すことができます。
整数
n
を入力し、
n
を 2 つの素数の和で表す組み合わせ数が何通りあるかを出力するプログラムを作成してください。ただし、
n
は 4 以上、50,000 以下とします。また、入力される
n
は偶数であるとはかぎりません。
Input
複数のデータセットが与えられます。各データセットに
n
が１行に与えられます。
n
が 0 のとき入力の最後とします。データセットの数は 10,000 を超えません。
Output
各データセットに対して、
n
を 2 つの素数の和で表す組み合わせ数を１行に出力して下さい。
Sample Input
10
11
0
Output for the Sample Input
2
0",C,"#include <stdio.h>
#include <string.h>

#define MAX 50001

int is_prime[MAX];

void sieve() {
    memset(is_prime, 1, sizeof(is_prime));
    is_prime[0] = is_prime[1] = 0;
    
    for (int i = 2; i * i < MAX; i++) {
        if (is_prime[i]) {
            for (int j = i * i; j < MAX; j += i) {
                is_prime[j] = 0;
            }
        }
    }
}

int main() {
    sieve();
    
    int n;
    while (scanf(""%d"", &n) == 1 && n != 0) {
        int count = 0;
        for (int i = 2; i <= n / 2; i++) {
            if (is_prime[i] && is_prime[n - i]) {
                count++;
            }
        }
        printf(""%d\n"", count);
    }
    
    return 0;
}
",0
p00056,"ゴールドバッハの予想
4 以上の偶数は 2 つの素数の和で表すことができるということが知られています。これはゴールドバッハ予想といい、コンピュータの計算によりかなり大きな数まで正しいことが確かめられています。例えば、10 は、7 + 3、5 + 5 の 2 通りの素数の和で表すことができます。
整数
n
を入力し、
n
を 2 つの素数の和で表す組み合わせ数が何通りあるかを出力するプログラムを作成してください。ただし、
n
は 4 以上、50,000 以下とします。また、入力される
n
は偶数であるとはかぎりません。
Input
複数のデータセットが与えられます。各データセットに
n
が１行に与えられます。
n
が 0 のとき入力の最後とします。データセットの数は 10,000 を超えません。
Output
各データセットに対して、
n
を 2 つの素数の和で表す組み合わせ数を１行に出力して下さい。
Sample Input
10
11
0
Output for the Sample Input
2
0",C,"#include <stdio.h>
int prime[50001];
void set(void){
    int i,o;
    for(i=4;i<=5000;i+=2)
        prime[i]=1;
    for(i=3;i*i<=5000;i+=2){
        if(prime[i]==0)
            for(o=i*2;o<=5000;o+=i)
                prime[o]=1;
    }
}
int main(void){
    int num,count,sum,i,o;
    set();
    for(;count=0,scanf(""%d"",&num),num;){
        for(i=2;i<=num;i++)
            if(!prime[i]){
                if(i>num)
                     break;
                for(o=2;o<=num;o++)
                    if(!prime[o]){
                        sum=i+o;
                        if(sum == num){
                            count++;
                            break;
                        }
                        if(sum > num)
                            break;
                    }
            }
        printf(""%d\n"",count%2?(count/2+1):(count/2));
    }
    return 0;
}",1
p00056,"ゴールドバッハの予想
4 以上の偶数は 2 つの素数の和で表すことができるということが知られています。これはゴールドバッハ予想といい、コンピュータの計算によりかなり大きな数まで正しいことが確かめられています。例えば、10 は、7 + 3、5 + 5 の 2 通りの素数の和で表すことができます。
整数
n
を入力し、
n
を 2 つの素数の和で表す組み合わせ数が何通りあるかを出力するプログラムを作成してください。ただし、
n
は 4 以上、50,000 以下とします。また、入力される
n
は偶数であるとはかぎりません。
Input
複数のデータセットが与えられます。各データセットに
n
が１行に与えられます。
n
が 0 のとき入力の最後とします。データセットの数は 10,000 を超えません。
Output
各データセットに対して、
n
を 2 つの素数の和で表す組み合わせ数を１行に出力して下さい。
Sample Input
10
11
0
Output for the Sample Input
2
0",Java,"import java.util.*;

public class Main {
    static boolean[] isPrime;
    static int MAX = 50001;
    
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        
        // Sieve of Eratosthenes
        isPrime = new boolean[MAX];
        Arrays.fill(isPrime, true);
        isPrime[0] = isPrime[1] = false;
        
        for (int i = 2; i * i < MAX; i++) {
            if (isPrime[i]) {
                for (int j = i * i; j < MAX; j += i) {
                    isPrime[j] = false;
                }
            }
        }
        
        while (true) {
            int n = sc.nextInt();
            if (n == 0) break;
            
            int count = 0;
            for (int i = 2; i <= n / 2; i++) {
                if (isPrime[i] && isPrime[n - i]) {
                    count++;
                }
            }
            
            System.out.println(count);
        }
        
        sc.close();
    }
}
",0
p00056,"ゴールドバッハの予想
4 以上の偶数は 2 つの素数の和で表すことができるということが知られています。これはゴールドバッハ予想といい、コンピュータの計算によりかなり大きな数まで正しいことが確かめられています。例えば、10 は、7 + 3、5 + 5 の 2 通りの素数の和で表すことができます。
整数
n
を入力し、
n
を 2 つの素数の和で表す組み合わせ数が何通りあるかを出力するプログラムを作成してください。ただし、
n
は 4 以上、50,000 以下とします。また、入力される
n
は偶数であるとはかぎりません。
Input
複数のデータセットが与えられます。各データセットに
n
が１行に与えられます。
n
が 0 のとき入力の最後とします。データセットの数は 10,000 を超えません。
Output
各データセットに対して、
n
を 2 つの素数の和で表す組み合わせ数を１行に出力して下さい。
Sample Input
10
11
0
Output for the Sample Input
2
0",Java,"import java.util.Arrays;
import java.util.Scanner;

public class Main {
	public static boolean[] p=new boolean[50000];
	public static int counter(int n){
		int c=0,i,j;
		for(i=2;i<=n/2;i++){
			if(p[i])
			for(j=2;i+j<=n;j++){
				if(p[j]){
					if(i+j==n){
						c++;
//						System.out.println(i+"" ""+j);
					}
				}
			}
		}//
		return c;
	}
	public static void main(String[] args) {
		Scanner sc=new Scanner(System.in);
		int n,i,j;
		Arrays.fill(p, true);
		for(i=2;i<50000;i++){
			if(p[i])
			for(j=2;i*j<50000;j++){
				p[i*j]=false;
			}
		}
		while(true){
			n=sc.nextInt();
			if(n==0) break;
			System.out.println(counter(n));
		}
	}
}",1
p00056,"ゴールドバッハの予想
4 以上の偶数は 2 つの素数の和で表すことができるということが知られています。これはゴールドバッハ予想といい、コンピュータの計算によりかなり大きな数まで正しいことが確かめられています。例えば、10 は、7 + 3、5 + 5 の 2 通りの素数の和で表すことができます。
整数
n
を入力し、
n
を 2 つの素数の和で表す組み合わせ数が何通りあるかを出力するプログラムを作成してください。ただし、
n
は 4 以上、50,000 以下とします。また、入力される
n
は偶数であるとはかぎりません。
Input
複数のデータセットが与えられます。各データセットに
n
が１行に与えられます。
n
が 0 のとき入力の最後とします。データセットの数は 10,000 を超えません。
Output
各データセットに対して、
n
を 2 つの素数の和で表す組み合わせ数を１行に出力して下さい。
Sample Input
10
11
0
Output for the Sample Input
2
0",Python,"def sieve_of_eratosthenes(limit):
    is_prime = [True] * (limit + 1)
    is_prime[0] = is_prime[1] = False
    
    for i in range(2, int(limit**0.5) + 1):
        if is_prime[i]:
            for j in range(i*i, limit + 1, i):
                is_prime[j] = False
    
    return is_prime

limit = 50000
is_prime = sieve_of_eratosthenes(limit)

while True:
    n = int(input())
    if n == 0:
        break
    
    count = 0
    for i in range(2, n // 2 + 1):
        if is_prime[i] and is_prime[n - i]:
            count += 1
    
    print(count)
",0
p00056,"ゴールドバッハの予想
4 以上の偶数は 2 つの素数の和で表すことができるということが知られています。これはゴールドバッハ予想といい、コンピュータの計算によりかなり大きな数まで正しいことが確かめられています。例えば、10 は、7 + 3、5 + 5 の 2 通りの素数の和で表すことができます。
整数
n
を入力し、
n
を 2 つの素数の和で表す組み合わせ数が何通りあるかを出力するプログラムを作成してください。ただし、
n
は 4 以上、50,000 以下とします。また、入力される
n
は偶数であるとはかぎりません。
Input
複数のデータセットが与えられます。各データセットに
n
が１行に与えられます。
n
が 0 のとき入力の最後とします。データセットの数は 10,000 を超えません。
Output
各データセットに対して、
n
を 2 つの素数の和で表す組み合わせ数を１行に出力して下さい。
Sample Input
10
11
0
Output for the Sample Input
2
0",Python,"N=50000+1
p=[True]*N
p[0],p[1]=False,False
for i in xrange(2,int(N**0.5)+1):
    if p[i]==True:
        for j in xrange(i**2,N,i):
            p[j]=False
while True:
    n=input()
    if n==0:break
    c=0
    for i in xrange(n/2+1):
        if p[i] and p[n-i]:c+=1
    print c",1
p00057,"領域の数
無限に広い平面の上に、無限に長い直線を数本引くと、この平面はいくつかの領域に分割されます。たとえば、直線を１本引くと、平面は２つの領域に分割されます。同じ数の直線を引いても、引き方によって得られる領域の数は異なります。たとえば、2 本の直線を平行に引けば得られる領域は 3 つになり、互いに垂直に引けば得られる領域は 4 つになります。
n
本の直線を引くことで得られる最大の領域の数を出力するプログラムを作成してください。
Input
複数のデータセットが与えられます。各データセットに
n
(1 ≤
n
≤ 10,000) が１行に与えられます。入力の最後まで処理して下さい。
データセットの数は 50 を超えません。
Output
各データセットに対して、最大の分割数を１行に出力して下さい。
Sample Input
1
3
Output for the Sample Input
2
7",C,"#include <stdio.h>

int main() {
    int n;
    while (scanf(""%d"", &n) != EOF) {
        long long result = 1 + (long long)n * (n + 1) / 2;
        printf(""%lld\n"", result);
    }
    return 0;
}
",0
p00057,"領域の数
無限に広い平面の上に、無限に長い直線を数本引くと、この平面はいくつかの領域に分割されます。たとえば、直線を１本引くと、平面は２つの領域に分割されます。同じ数の直線を引いても、引き方によって得られる領域の数は異なります。たとえば、2 本の直線を平行に引けば得られる領域は 3 つになり、互いに垂直に引けば得られる領域は 4 つになります。
n
本の直線を引くことで得られる最大の領域の数を出力するプログラムを作成してください。
Input
複数のデータセットが与えられます。各データセットに
n
(1 ≤
n
≤ 10,000) が１行に与えられます。入力の最後まで処理して下さい。
データセットの数は 50 を超えません。
Output
各データセットに対して、最大の分割数を１行に出力して下さい。
Sample Input
1
3
Output for the Sample Input
2
7",C,"N,main(){while(~scanf(""%d"",&N))printf(""%d\n"",N*(N+1)/2+1);}",1
p00057,"領域の数
無限に広い平面の上に、無限に長い直線を数本引くと、この平面はいくつかの領域に分割されます。たとえば、直線を１本引くと、平面は２つの領域に分割されます。同じ数の直線を引いても、引き方によって得られる領域の数は異なります。たとえば、2 本の直線を平行に引けば得られる領域は 3 つになり、互いに垂直に引けば得られる領域は 4 つになります。
n
本の直線を引くことで得られる最大の領域の数を出力するプログラムを作成してください。
Input
複数のデータセットが与えられます。各データセットに
n
(1 ≤
n
≤ 10,000) が１行に与えられます。入力の最後まで処理して下さい。
データセットの数は 50 を超えません。
Output
各データセットに対して、最大の分割数を１行に出力して下さい。
Sample Input
1
3
Output for the Sample Input
2
7",Java,"import java.util.Scanner;

public class Main {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        
        while (sc.hasNext()) {
            int n = sc.nextInt();
            long result = (long) n * (n + 1) / 2 + 1;
            System.out.println(result);
        }
        
        sc.close();
    }
}
",0
p00057,"領域の数
無限に広い平面の上に、無限に長い直線を数本引くと、この平面はいくつかの領域に分割されます。たとえば、直線を１本引くと、平面は２つの領域に分割されます。同じ数の直線を引いても、引き方によって得られる領域の数は異なります。たとえば、2 本の直線を平行に引けば得られる領域は 3 つになり、互いに垂直に引けば得られる領域は 4 つになります。
n
本の直線を引くことで得られる最大の領域の数を出力するプログラムを作成してください。
Input
複数のデータセットが与えられます。各データセットに
n
(1 ≤
n
≤ 10,000) が１行に与えられます。入力の最後まで処理して下さい。
データセットの数は 50 を超えません。
Output
各データセットに対して、最大の分割数を１行に出力して下さい。
Sample Input
1
3
Output for the Sample Input
2
7",Java,"import java.util.*;

class Main {
    public static void main(String[] args) {
	Scanner s = new Scanner(System.in);
	int[] d = new int[10001];
	d[0]=1;
	d[1]=2;
	for(int i=2 ; i<10001 ; i++)
	    d[i] = d[i-1]+i;
	while(s.hasNext())
	    System.out.println(d[s.nextInt()]);
    }
}",1
p00057,"領域の数
無限に広い平面の上に、無限に長い直線を数本引くと、この平面はいくつかの領域に分割されます。たとえば、直線を１本引くと、平面は２つの領域に分割されます。同じ数の直線を引いても、引き方によって得られる領域の数は異なります。たとえば、2 本の直線を平行に引けば得られる領域は 3 つになり、互いに垂直に引けば得られる領域は 4 つになります。
n
本の直線を引くことで得られる最大の領域の数を出力するプログラムを作成してください。
Input
複数のデータセットが与えられます。各データセットに
n
(1 ≤
n
≤ 10,000) が１行に与えられます。入力の最後まで処理して下さい。
データセットの数は 50 を超えません。
Output
各データセットに対して、最大の分割数を１行に出力して下さい。
Sample Input
1
3
Output for the Sample Input
2
7",Python,"import sys

for line in sys.stdin:
    n = int(line.strip())
    result = 1 + n * (n + 1) // 2
    print(result)
",0
p00057,"領域の数
無限に広い平面の上に、無限に長い直線を数本引くと、この平面はいくつかの領域に分割されます。たとえば、直線を１本引くと、平面は２つの領域に分割されます。同じ数の直線を引いても、引き方によって得られる領域の数は異なります。たとえば、2 本の直線を平行に引けば得られる領域は 3 つになり、互いに垂直に引けば得られる領域は 4 つになります。
n
本の直線を引くことで得られる最大の領域の数を出力するプログラムを作成してください。
Input
複数のデータセットが与えられます。各データセットに
n
(1 ≤
n
≤ 10,000) が１行に与えられます。入力の最後まで処理して下さい。
データセットの数は 50 を超えません。
Output
各データセットに対して、最大の分割数を１行に出力して下さい。
Sample Input
1
3
Output for the Sample Input
2
7",Python,"while True:
    try:
        a = int(input())
        print(((a * a) + a + 2) / 2)
    except EOFError:
        break",1
p00058,"直交判定
平面上の異なる 4 点、$A (x_A, y_A)$, $B (x_B, y_B)$, $C (x_C, y_C)$, $D (x_D, y_D)$ の座標を読み込んで、直線 $AB$ と $CD$ が直交する場合には
YES
、直交しない場合には
NO
と出力するプログラムを作成してください。ここで、「直線」とは線分のことではありません。以下の図を参考にして下さい。
Input
複数のデータセットが与えられます。各データセットの形式は以下のとおりです。
$x_A$ $y_A$ $x_B$ $y_B$ $x_C$ $y_C$ $x_D$ $y_D$
$x_A$, $y_A$, $x_B$, $y_B$, $x_C$, $y_C$, $x_D$, $y_D$ はそれぞれ -100 以上 100 以下であり、各値は小数点以下最大 5 桁までの数字を含む実数で与えられます。
データセットの数は 100 を超えません。
Output
各データセットに対して、
YES
または
NO
を１行に出力して下さい。
Sample Input
1.0 1.0 2.0 2.0 0.0 0.0 1.0 -1.0
0.0 0.0 2.0 0.0 -1.0 2.0 2.0 2.0
10.0 6.0 3.4 5.2 6.8 9.5 4.3 2.1
2.5 3.5 2.5 4.5 -3.3 -2.3 6.8 -2.3
Output for the Sample Input
YES
NO
NO
YES",C,"#include <stdio.h>
#include <math.h>

int main() {
    double xA, yA, xB, yB, xC, yC, xD, yD;
    
    while (scanf(""%lf %lf %lf %lf %lf %lf %lf %lf"", 
                 &xA, &yA, &xB, &yB, &xC, &yC, &xD, &yD) == 8) {
        double dx1 = xB - xA;
        double dy1 = yB - yA;
        double dx2 = xD - xC;
        double dy2 = yD - yC;
        
        double dot = dx1 * dx2 + dy1 * dy2;
        
        if (fabs(dot) < 1e-9) {
            printf(""YES\n"");
        } else {
            printf(""NO\n"");
        }
    }
    
    return 0;
}
",0
p00058,"直交判定
平面上の異なる 4 点、$A (x_A, y_A)$, $B (x_B, y_B)$, $C (x_C, y_C)$, $D (x_D, y_D)$ の座標を読み込んで、直線 $AB$ と $CD$ が直交する場合には
YES
、直交しない場合には
NO
と出力するプログラムを作成してください。ここで、「直線」とは線分のことではありません。以下の図を参考にして下さい。
Input
複数のデータセットが与えられます。各データセットの形式は以下のとおりです。
$x_A$ $y_A$ $x_B$ $y_B$ $x_C$ $y_C$ $x_D$ $y_D$
$x_A$, $y_A$, $x_B$, $y_B$, $x_C$, $y_C$, $x_D$, $y_D$ はそれぞれ -100 以上 100 以下であり、各値は小数点以下最大 5 桁までの数字を含む実数で与えられます。
データセットの数は 100 を超えません。
Output
各データセットに対して、
YES
または
NO
を１行に出力して下さい。
Sample Input
1.0 1.0 2.0 2.0 0.0 0.0 1.0 -1.0
0.0 0.0 2.0 0.0 -1.0 2.0 2.0 2.0
10.0 6.0 3.4 5.2 6.8 9.5 4.3 2.1
2.5 3.5 2.5 4.5 -3.3 -2.3 6.8 -2.3
Output for the Sample Input
YES
NO
NO
YES",C,"i;main(){float A,a,B,b,C,c,D,d;for(;~scanf(""%f"",&d+i*2);)if(++i==8)puts((A-B)*(C-D)+(a-b)*(c-d)?""NO"":""YES"",i=0);}",1
p00058,"直交判定
平面上の異なる 4 点、$A (x_A, y_A)$, $B (x_B, y_B)$, $C (x_C, y_C)$, $D (x_D, y_D)$ の座標を読み込んで、直線 $AB$ と $CD$ が直交する場合には
YES
、直交しない場合には
NO
と出力するプログラムを作成してください。ここで、「直線」とは線分のことではありません。以下の図を参考にして下さい。
Input
複数のデータセットが与えられます。各データセットの形式は以下のとおりです。
$x_A$ $y_A$ $x_B$ $y_B$ $x_C$ $y_C$ $x_D$ $y_D$
$x_A$, $y_A$, $x_B$, $y_B$, $x_C$, $y_C$, $x_D$, $y_D$ はそれぞれ -100 以上 100 以下であり、各値は小数点以下最大 5 桁までの数字を含む実数で与えられます。
データセットの数は 100 を超えません。
Output
各データセットに対して、
YES
または
NO
を１行に出力して下さい。
Sample Input
1.0 1.0 2.0 2.0 0.0 0.0 1.0 -1.0
0.0 0.0 2.0 0.0 -1.0 2.0 2.0 2.0
10.0 6.0 3.4 5.2 6.8 9.5 4.3 2.1
2.5 3.5 2.5 4.5 -3.3 -2.3 6.8 -2.3
Output for the Sample Input
YES
NO
NO
YES",Java,"import java.util.Scanner;

public class Main {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        
        while (sc.hasNext()) {
            double xA = sc.nextDouble();
            double yA = sc.nextDouble();
            double xB = sc.nextDouble();
            double yB = sc.nextDouble();
            double xC = sc.nextDouble();
            double yC = sc.nextDouble();
            double xD = sc.nextDouble();
            double yD = sc.nextDouble();
            
            double dx1 = xB - xA;
            double dy1 = yB - yA;
            double dx2 = xD - xC;
            double dy2 = yD - yC;
            
            double dotProduct = dx1 * dx2 + dy1 * dy2;
            
            if (Math.abs(dotProduct) < 1e-9) {
                System.out.println(""YES"");
            } else {
                System.out.println(""NO"");
            }
        }
        
        sc.close();
    }
}
",0
p00058,"直交判定
平面上の異なる 4 点、$A (x_A, y_A)$, $B (x_B, y_B)$, $C (x_C, y_C)$, $D (x_D, y_D)$ の座標を読み込んで、直線 $AB$ と $CD$ が直交する場合には
YES
、直交しない場合には
NO
と出力するプログラムを作成してください。ここで、「直線」とは線分のことではありません。以下の図を参考にして下さい。
Input
複数のデータセットが与えられます。各データセットの形式は以下のとおりです。
$x_A$ $y_A$ $x_B$ $y_B$ $x_C$ $y_C$ $x_D$ $y_D$
$x_A$, $y_A$, $x_B$, $y_B$, $x_C$, $y_C$, $x_D$, $y_D$ はそれぞれ -100 以上 100 以下であり、各値は小数点以下最大 5 桁までの数字を含む実数で与えられます。
データセットの数は 100 を超えません。
Output
各データセットに対して、
YES
または
NO
を１行に出力して下さい。
Sample Input
1.0 1.0 2.0 2.0 0.0 0.0 1.0 -1.0
0.0 0.0 2.0 0.0 -1.0 2.0 2.0 2.0
10.0 6.0 3.4 5.2 6.8 9.5 4.3 2.1
2.5 3.5 2.5 4.5 -3.3 -2.3 6.8 -2.3
Output for the Sample Input
YES
NO
NO
YES",Java,"import java.util.Scanner;
class Main{
    public static void main(String[] args) {
        Scanner sc=new Scanner(System.in);
        while(sc.hasNext()){
            double[][]point=new double[4][2];
            for(int i=0;i<4;i++){
                point[i][0]=sc.nextDouble();
                point[i][1]=sc.nextDouble();
            }
            double x1=point[1][0]-point[0][0],y1=point[1][1]-point[0][1],x2=point[3][0]-point[2][0],y2=point[3][1]-point[2][1];
            System.out.println((x1*x2+y1*y2)==0?""YES"":""NO"");
            
        }
    }
}",1
p00058,"直交判定
平面上の異なる 4 点、$A (x_A, y_A)$, $B (x_B, y_B)$, $C (x_C, y_C)$, $D (x_D, y_D)$ の座標を読み込んで、直線 $AB$ と $CD$ が直交する場合には
YES
、直交しない場合には
NO
と出力するプログラムを作成してください。ここで、「直線」とは線分のことではありません。以下の図を参考にして下さい。
Input
複数のデータセットが与えられます。各データセットの形式は以下のとおりです。
$x_A$ $y_A$ $x_B$ $y_B$ $x_C$ $y_C$ $x_D$ $y_D$
$x_A$, $y_A$, $x_B$, $y_B$, $x_C$, $y_C$, $x_D$, $y_D$ はそれぞれ -100 以上 100 以下であり、各値は小数点以下最大 5 桁までの数字を含む実数で与えられます。
データセットの数は 100 を超えません。
Output
各データセットに対して、
YES
または
NO
を１行に出力して下さい。
Sample Input
1.0 1.0 2.0 2.0 0.0 0.0 1.0 -1.0
0.0 0.0 2.0 0.0 -1.0 2.0 2.0 2.0
10.0 6.0 3.4 5.2 6.8 9.5 4.3 2.1
2.5 3.5 2.5 4.5 -3.3 -2.3 6.8 -2.3
Output for the Sample Input
YES
NO
NO
YES",Python,"import sys

for line in sys.stdin:
    coords = list(map(float, line.split()))
    xa, ya, xb, yb, xc, yc, xd, yd = coords
    
    # Vector AB
    vab_x = xb - xa
    vab_y = yb - ya
    
    # Vector CD
    vcd_x = xd - xc
    vcd_y = yd - yc
    
    # Dot product
    dot = vab_x * vcd_x + vab_y * vcd_y
    
    # Check if perpendicular (dot product is 0)
    if abs(dot) < 1e-9:
        print(""YES"")
    else:
        print(""NO"")
",0
p00058,"直交判定
平面上の異なる 4 点、$A (x_A, y_A)$, $B (x_B, y_B)$, $C (x_C, y_C)$, $D (x_D, y_D)$ の座標を読み込んで、直線 $AB$ と $CD$ が直交する場合には
YES
、直交しない場合には
NO
と出力するプログラムを作成してください。ここで、「直線」とは線分のことではありません。以下の図を参考にして下さい。
Input
複数のデータセットが与えられます。各データセットの形式は以下のとおりです。
$x_A$ $y_A$ $x_B$ $y_B$ $x_C$ $y_C$ $x_D$ $y_D$
$x_A$, $y_A$, $x_B$, $y_B$, $x_C$, $y_C$, $x_D$, $y_D$ はそれぞれ -100 以上 100 以下であり、各値は小数点以下最大 5 桁までの数字を含む実数で与えられます。
データセットの数は 100 を超えません。
Output
各データセットに対して、
YES
または
NO
を１行に出力して下さい。
Sample Input
1.0 1.0 2.0 2.0 0.0 0.0 1.0 -1.0
0.0 0.0 2.0 0.0 -1.0 2.0 2.0 2.0
10.0 6.0 3.4 5.2 6.8 9.5 4.3 2.1
2.5 3.5 2.5 4.5 -3.3 -2.3 6.8 -2.3
Output for the Sample Input
YES
NO
NO
YES",Python,"while True:
    try:
        xA,yA,xB,yB,xC,yC,xD,yD = map(float,raw_input().split())
        if (100000*(yB-yA))*(100000*(yD-yC)) + (100000*(xB-xA))*(100000*(xD-xC)) < 1.e-10:
            print ""YES""
        else:
            print ""NO""
    except:
        break",1
p00059,"長方形の重なり
底辺が
x
軸に対して平行な 2 つの長方形があります。長方形 A の左下の座標 (
xa1
,
ya1
) と右上の座標 (
xa2
,
ya2
)、長方形 B の左下の座標 (
xb1
,
yb1
) と右上の座標 (
xb2
,
yb2
) を読み込んで、長方形 A と長方形 B が一部でも重なっていれば YES を、まったく重なっていなければ NO を出力するプログラムを作成してください。ただし、長方形 A と長方形 B は同じものではないとします。また、接しているものも重なっているとみなします。
Input
複数のデータセットが与えられます。各データセットの形式は以下のとおりです。
xa1
ya1
xa2
ya2
xb1
yb1
xb2
yb2
入力される値はそれぞれ -2,000 以上 2,000 以下であり、各値は小数点以下最大 5 桁までの数字を含む実数で与えられます。
データセットの数は 50 を超えません。
Output
各データセットに対して、
YES
または
NO
を１行に出力して下さい。
Sample Input
0.0 0.0 5.0 5.0 1.0 1.0 4.0 4.0
0.0 0.0 4.0 5.0 1.0 1.0 5.0 5.0
0.0 0.0 4.0 4.0 -3.0 -5.0 2.0 -1.0
Output for the Sample Input
YES
YES
NO",C,"#include <stdio.h>

int main() {
    double xa1, ya1, xa2, ya2, xb1, yb1, xb2, yb2;
    
    while (scanf(""%lf %lf %lf %lf %lf %lf %lf %lf"", 
                  &xa1, &ya1, &xa2, &ya2, &xb1, &yb1, &xb2, &yb2) == 8) {
        
        if (xa2 >= xb1 && xb2 >= xa1 && ya2 >= yb1 && yb2 >= ya1) {
            printf(""YES\n"");
        } else {
            printf(""NO\n"");
        }
    }
    
    return 0;
}
",0
p00059,"長方形の重なり
底辺が
x
軸に対して平行な 2 つの長方形があります。長方形 A の左下の座標 (
xa1
,
ya1
) と右上の座標 (
xa2
,
ya2
)、長方形 B の左下の座標 (
xb1
,
yb1
) と右上の座標 (
xb2
,
yb2
) を読み込んで、長方形 A と長方形 B が一部でも重なっていれば YES を、まったく重なっていなければ NO を出力するプログラムを作成してください。ただし、長方形 A と長方形 B は同じものではないとします。また、接しているものも重なっているとみなします。
Input
複数のデータセットが与えられます。各データセットの形式は以下のとおりです。
xa1
ya1
xa2
ya2
xb1
yb1
xb2
yb2
入力される値はそれぞれ -2,000 以上 2,000 以下であり、各値は小数点以下最大 5 桁までの数字を含む実数で与えられます。
データセットの数は 50 を超えません。
Output
各データセットに対して、
YES
または
NO
を１行に出力して下さい。
Sample Input
0.0 0.0 5.0 5.0 1.0 1.0 4.0 4.0
0.0 0.0 4.0 5.0 1.0 1.0 5.0 5.0
0.0 0.0 4.0 4.0 -3.0 -5.0 2.0 -1.0
Output for the Sample Input
YES
YES
NO",C,"#include<stdio.h>
#include<math.h>
#include <stdlib.h>
#include<string.h>
#include<limits.h>

int main(){
	double x[4],y[4];
	int i;
	
	while(scanf(""%lf%lf%lf%lf%lf%lf%lf%lf"",&x[0],&y[0],&x[1],&y[1],&x[2],&y[2],&x[3],&y[3])!=EOF){
	
		if(x[0]<=x[2] && x[1]>=x[2]){
			if((y[0]<=y[2] && y[1]>=y[2]) || (y[0]<=y[3] && y[1]>=y[3]))printf(""YES\n"");
			else printf(""NO\n"");
		}
		else if(x[0]<=x[3] && x[1]>=x[3]){
			if((y[0]<=y[2] && y[1]>=y[2]) || (y[0]<=y[3] && y[1]>=y[3]))printf(""YES\n"");
			else printf(""NO\n"");
		}
		else printf(""NO\n"");
	}
return 0;
}",1
p00059,"長方形の重なり
底辺が
x
軸に対して平行な 2 つの長方形があります。長方形 A の左下の座標 (
xa1
,
ya1
) と右上の座標 (
xa2
,
ya2
)、長方形 B の左下の座標 (
xb1
,
yb1
) と右上の座標 (
xb2
,
yb2
) を読み込んで、長方形 A と長方形 B が一部でも重なっていれば YES を、まったく重なっていなければ NO を出力するプログラムを作成してください。ただし、長方形 A と長方形 B は同じものではないとします。また、接しているものも重なっているとみなします。
Input
複数のデータセットが与えられます。各データセットの形式は以下のとおりです。
xa1
ya1
xa2
ya2
xb1
yb1
xb2
yb2
入力される値はそれぞれ -2,000 以上 2,000 以下であり、各値は小数点以下最大 5 桁までの数字を含む実数で与えられます。
データセットの数は 50 を超えません。
Output
各データセットに対して、
YES
または
NO
を１行に出力して下さい。
Sample Input
0.0 0.0 5.0 5.0 1.0 1.0 4.0 4.0
0.0 0.0 4.0 5.0 1.0 1.0 5.0 5.0
0.0 0.0 4.0 4.0 -3.0 -5.0 2.0 -1.0
Output for the Sample Input
YES
YES
NO",Java,"import java.util.Scanner;

public class Main {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        
        while (sc.hasNext()) {
            double xa1 = sc.nextDouble();
            double ya1 = sc.nextDouble();
            double xa2 = sc.nextDouble();
            double ya2 = sc.nextDouble();
            double xb1 = sc.nextDouble();
            double yb1 = sc.nextDouble();
            double xb2 = sc.nextDouble();
            double yb2 = sc.nextDouble();
            
            boolean xOverlap = !(xa2 < xb1 || xb2 < xa1);
            boolean yOverlap = !(ya2 < yb1 || yb2 < ya1);
            
            if (xOverlap && yOverlap) {
                System.out.println(""YES"");
            } else {
                System.out.println(""NO"");
            }
        }
        
        sc.close();
    }
}
",0
p00059,"長方形の重なり
底辺が
x
軸に対して平行な 2 つの長方形があります。長方形 A の左下の座標 (
xa1
,
ya1
) と右上の座標 (
xa2
,
ya2
)、長方形 B の左下の座標 (
xb1
,
yb1
) と右上の座標 (
xb2
,
yb2
) を読み込んで、長方形 A と長方形 B が一部でも重なっていれば YES を、まったく重なっていなければ NO を出力するプログラムを作成してください。ただし、長方形 A と長方形 B は同じものではないとします。また、接しているものも重なっているとみなします。
Input
複数のデータセットが与えられます。各データセットの形式は以下のとおりです。
xa1
ya1
xa2
ya2
xb1
yb1
xb2
yb2
入力される値はそれぞれ -2,000 以上 2,000 以下であり、各値は小数点以下最大 5 桁までの数字を含む実数で与えられます。
データセットの数は 50 を超えません。
Output
各データセットに対して、
YES
または
NO
を１行に出力して下さい。
Sample Input
0.0 0.0 5.0 5.0 1.0 1.0 4.0 4.0
0.0 0.0 4.0 5.0 1.0 1.0 5.0 5.0
0.0 0.0 4.0 4.0 -3.0 -5.0 2.0 -1.0
Output for the Sample Input
YES
YES
NO",Java,"import java.util.Scanner;
public class Main {
	static double x1[]=new double[2];
	static double y1[]=new double[2];
	static double x2[]=new double[2];
	static double y2[]=new double[2];
	public static boolean check(double x,double y) {
		if(x1[0]<=x && x<=x1[1] && y1[0]<=y && y<=y1[1]){
			return true;
		}
		return false;
	}
	public static boolean check2(double x,double y) {
		if(x2[0]<=x && x<=x2[1] && y2[0]<=y && y<=y2[1]){
			return true;
		}
		return false;
	}
	public static void main(String[] args) {
		Scanner sc=new Scanner(System.in);
		double tmp;
		int i,j;
		while(sc.hasNext()){
			for(i=0;i<2;i++){
				x1[i]=sc.nextDouble();
				y1[i]=sc.nextDouble();
			}
			for(i=0;i<2;i++){
				x2[i]=sc.nextDouble();
				y2[i]=sc.nextDouble();
			}
			if(x1[1]<x1[0]){
				tmp=x1[1];
				x1[0]=x1[1];
				x1[1]=tmp;
			}
			if(y1[1]<y1[0]){
				tmp=y1[1];
				y1[0]=y1[1];
				y1[1]=tmp;
			}
			if(x2[1]<x2[0]){
				tmp=x2[1];
				x2[0]=x2[1];
				x2[1]=tmp;
			}
			if(y2[1]<y2[0]){
				tmp=y2[1];
				y2[0]=y2[1];
				y2[1]=tmp;
			}
			boolean f=false;
			for(i=0;i<2;i++){
				for(j=0;j<2;j++){
					//System.out.println(f+"" ""+x2[i]+"" ""+y2[j]);
					if(f) break;
					f=check(x2[i],y2[j]);
				}
			}//
			for(i=0;i<2;i++){
				for(j=0;j<2;j++){
					//System.out.println(f);
					if(f) break;
					f=check2(x1[i],y1[j]);
				}
			}//
			if(f){
				System.out.println(""YES"");
			}
			else{
				System.out.println(""NO"");
			}
		}
	}
}",1
p00059,"長方形の重なり
底辺が
x
軸に対して平行な 2 つの長方形があります。長方形 A の左下の座標 (
xa1
,
ya1
) と右上の座標 (
xa2
,
ya2
)、長方形 B の左下の座標 (
xb1
,
yb1
) と右上の座標 (
xb2
,
yb2
) を読み込んで、長方形 A と長方形 B が一部でも重なっていれば YES を、まったく重なっていなければ NO を出力するプログラムを作成してください。ただし、長方形 A と長方形 B は同じものではないとします。また、接しているものも重なっているとみなします。
Input
複数のデータセットが与えられます。各データセットの形式は以下のとおりです。
xa1
ya1
xa2
ya2
xb1
yb1
xb2
yb2
入力される値はそれぞれ -2,000 以上 2,000 以下であり、各値は小数点以下最大 5 桁までの数字を含む実数で与えられます。
データセットの数は 50 を超えません。
Output
各データセットに対して、
YES
または
NO
を１行に出力して下さい。
Sample Input
0.0 0.0 5.0 5.0 1.0 1.0 4.0 4.0
0.0 0.0 4.0 5.0 1.0 1.0 5.0 5.0
0.0 0.0 4.0 4.0 -3.0 -5.0 2.0 -1.0
Output for the Sample Input
YES
YES
NO",Python,"import sys

for line in sys.stdin:
    coords = []
    coords.append(list(map(float, line.split())))
    for _ in range(7):
        coords.append(list(map(float, input().split())))
    
    xa1, ya1 = coords[0][0], coords[1][0]
    xa2, ya2 = coords[2][0], coords[3][0]
    xb1, yb1 = coords[4][0], coords[5][0]
    xb2, yb2 = coords[6][0], coords[7][0]
    
    if xa2 >= xb1 and xb2 >= xa1 and ya2 >= yb1 and yb2 >= ya1:
        print(""YES"")
    else:
        print(""NO"")
",0
p00059,"長方形の重なり
底辺が
x
軸に対して平行な 2 つの長方形があります。長方形 A の左下の座標 (
xa1
,
ya1
) と右上の座標 (
xa2
,
ya2
)、長方形 B の左下の座標 (
xb1
,
yb1
) と右上の座標 (
xb2
,
yb2
) を読み込んで、長方形 A と長方形 B が一部でも重なっていれば YES を、まったく重なっていなければ NO を出力するプログラムを作成してください。ただし、長方形 A と長方形 B は同じものではないとします。また、接しているものも重なっているとみなします。
Input
複数のデータセットが与えられます。各データセットの形式は以下のとおりです。
xa1
ya1
xa2
ya2
xb1
yb1
xb2
yb2
入力される値はそれぞれ -2,000 以上 2,000 以下であり、各値は小数点以下最大 5 桁までの数字を含む実数で与えられます。
データセットの数は 50 を超えません。
Output
各データセットに対して、
YES
または
NO
を１行に出力して下さい。
Sample Input
0.0 0.0 5.0 5.0 1.0 1.0 4.0 4.0
0.0 0.0 4.0 5.0 1.0 1.0 5.0 5.0
0.0 0.0 4.0 4.0 -3.0 -5.0 2.0 -1.0
Output for the Sample Input
YES
YES
NO",Python,"import sys


for line in sys.stdin.readline():
    xa1, ya1, xa2, ya2, xb1, yb1, xb2, yb2 = map(float, line.rstrip('\n').split(' '))
    if ((xb1<=xa1 and xa1<=xb2) or (xa1<=xb1 and xb1<=xa2)) and ((yb1<=ya2 and ya2<=yb2) or (ya1<=yb2 and yb2<=ya2)):
        print 'YES'
    else:
        print 'NO'",1
p00060,"カードゲー ム
「1」から「10」までの数字が書かれたカードが各 1 枚、全部で 10 枚あります。このカードは、表側には数字が書かれ、裏側には何も書かれていません。このカードを使って、あなたと相手の 2 名で以下のルールでゲー ムを行います。
あなたと相手には、表を上にして 1 枚、裏を上にして 1 枚、計 2 枚のカードが配られています。あなたは相手の表のカードの数字を見ることができますが、裏のカードの数字は見えません。
配られたカードの数字の合計が 20 以下で、かつ相手の数字の合計より大きいときに勝ちとなります。
      例えば、あなたのカードが「7」「8」 (合計 15) 、相手のカードが「9」「10」 (合計 19) のときは、相手の勝ちです。
あなたと相手は最大であと 1 枚カードを引くことができます。それを引かなくても構いません。
ここで、あと 1 枚のカードを引くかどうかを決定する目安として、カードを引いたときに合計が 20 以下に なる確率を考え、その確率が 50% 以上のときはカードを引くこととしましょう。この確率を計算するときには、あなたの 2 枚のカードと相手の表のカードの計3枚のカードの情報を利用することができます。つまり、各カードは 1 枚ずつしかないので、それらのカードを引くことはないことになります。
あなたの 2 枚のカードと相手の表のカードを読み込んで、それぞれについて、あと 1 枚引いたときに合計が 20 以下になる確率が 50% 以上のときは YES、そうでないなら NO を出力するプログラムを作成してください。
Input
入力は複数のデータセットからなります。 1 枚目のあなたのカードの数字を C1 、2 枚目のあなたのカードの数字を C2 、相手の表になっているカードの数字を C3 とすると、各データセットは以下の形式で与えられます。
C1 C2 C3
Output
各データセットに対して、
YES
または
NO
を１行に出力して下さい。
Sample Input
1 2 3
5 6 9
8 9 10
Output for the Sample Input
YES
YES
NO",C,"#include <stdio.h>

int main() {
    int c1, c2, c3;
    
    while (scanf(""%d %d %d"", &c1, &c2, &c3) == 3) {
        int current_sum = c1 + c2;
        int max_allowed = 20 - current_sum;
        
        int count_valid = 0;
        int count_total = 0;
        
        for (int i = 1; i <= 10; i++) {
            if (i != c1 && i != c2 && i != c3) {
                count_total++;
                if (i <= max_allowed) {
                    count_valid++;
                }
            }
        }
        
        if (count_valid * 2 >= count_total) {
            printf(""YES\n"");
        } else {
            printf(""NO\n"");
        }
    }
    
    return 0;
}
",0
p00060,"カードゲー ム
「1」から「10」までの数字が書かれたカードが各 1 枚、全部で 10 枚あります。このカードは、表側には数字が書かれ、裏側には何も書かれていません。このカードを使って、あなたと相手の 2 名で以下のルールでゲー ムを行います。
あなたと相手には、表を上にして 1 枚、裏を上にして 1 枚、計 2 枚のカードが配られています。あなたは相手の表のカードの数字を見ることができますが、裏のカードの数字は見えません。
配られたカードの数字の合計が 20 以下で、かつ相手の数字の合計より大きいときに勝ちとなります。
      例えば、あなたのカードが「7」「8」 (合計 15) 、相手のカードが「9」「10」 (合計 19) のときは、相手の勝ちです。
あなたと相手は最大であと 1 枚カードを引くことができます。それを引かなくても構いません。
ここで、あと 1 枚のカードを引くかどうかを決定する目安として、カードを引いたときに合計が 20 以下に なる確率を考え、その確率が 50% 以上のときはカードを引くこととしましょう。この確率を計算するときには、あなたの 2 枚のカードと相手の表のカードの計3枚のカードの情報を利用することができます。つまり、各カードは 1 枚ずつしかないので、それらのカードを引くことはないことになります。
あなたの 2 枚のカードと相手の表のカードを読み込んで、それぞれについて、あと 1 枚引いたときに合計が 20 以下になる確率が 50% 以上のときは YES、そうでないなら NO を出力するプログラムを作成してください。
Input
入力は複数のデータセットからなります。 1 枚目のあなたのカードの数字を C1 、2 枚目のあなたのカードの数字を C2 、相手の表になっているカードの数字を C3 とすると、各データセットは以下の形式で与えられます。
C1 C2 C3
Output
各データセットに対して、
YES
または
NO
を１行に出力して下さい。
Sample Input
1 2 3
5 6 9
8 9 10
Output for the Sample Input
YES
YES
NO",C,"#include <stdio.h>

int main()
{
        int c1, c2, c3, i, cnt = 0;
        int card[11];

        for ( int i = 1 ; i < 11 ; i++ ) {
                card[i] = 1;
        }

        while ( scanf( ""%d %d %d"", &c1, &c2, &c3 ) == 3 ) {
                cnt = 0;
                for ( i = 1 ; i < 11 ; i++ ) {
                        if ( c1 != i && c2 != i && c3 != i ) {
                                if ( c1 + c2 + i <= 20 ) {
                                        cnt++;
                                }
                        }
                }
                if ( cnt >= 4 ) {
                        printf( ""YES\n"" );
                } else {
                        printf( ""NO\n"" );
                }
        }
        return 0;
}

",1
p00060,"カードゲー ム
「1」から「10」までの数字が書かれたカードが各 1 枚、全部で 10 枚あります。このカードは、表側には数字が書かれ、裏側には何も書かれていません。このカードを使って、あなたと相手の 2 名で以下のルールでゲー ムを行います。
あなたと相手には、表を上にして 1 枚、裏を上にして 1 枚、計 2 枚のカードが配られています。あなたは相手の表のカードの数字を見ることができますが、裏のカードの数字は見えません。
配られたカードの数字の合計が 20 以下で、かつ相手の数字の合計より大きいときに勝ちとなります。
      例えば、あなたのカードが「7」「8」 (合計 15) 、相手のカードが「9」「10」 (合計 19) のときは、相手の勝ちです。
あなたと相手は最大であと 1 枚カードを引くことができます。それを引かなくても構いません。
ここで、あと 1 枚のカードを引くかどうかを決定する目安として、カードを引いたときに合計が 20 以下に なる確率を考え、その確率が 50% 以上のときはカードを引くこととしましょう。この確率を計算するときには、あなたの 2 枚のカードと相手の表のカードの計3枚のカードの情報を利用することができます。つまり、各カードは 1 枚ずつしかないので、それらのカードを引くことはないことになります。
あなたの 2 枚のカードと相手の表のカードを読み込んで、それぞれについて、あと 1 枚引いたときに合計が 20 以下になる確率が 50% 以上のときは YES、そうでないなら NO を出力するプログラムを作成してください。
Input
入力は複数のデータセットからなります。 1 枚目のあなたのカードの数字を C1 、2 枚目のあなたのカードの数字を C2 、相手の表になっているカードの数字を C3 とすると、各データセットは以下の形式で与えられます。
C1 C2 C3
Output
各データセットに対して、
YES
または
NO
を１行に出力して下さい。
Sample Input
1 2 3
5 6 9
8 9 10
Output for the Sample Input
YES
YES
NO",Java,"import java.util.*;

public class Main {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        
        while (sc.hasNext()) {
            int c1 = sc.nextInt();
            int c2 = sc.nextInt();
            int c3 = sc.nextInt();
            
            int currentSum = c1 + c2;
            
            // Count how many cards from remaining 7 cards would make sum <= 20
            int count = 0;
            for (int i = 1; i <= 10; i++) {
                if (i != c1 && i != c2 && i != c3) {
                    if (currentSum + i <= 20) {
                        count++;
                    }
                }
            }
            
            // Total remaining cards is 7 (10 - 3 known cards)
            // Probability is count/7
            // 50% or more means count/7 >= 0.5, which is count >= 3.5, so count >= 4
            if (count * 2 >= 7) {
                System.out.println(""YES"");
            } else {
                System.out.println(""NO"");
            }
        }
        
        sc.close();
    }
}
",0
p00060,"カードゲー ム
「1」から「10」までの数字が書かれたカードが各 1 枚、全部で 10 枚あります。このカードは、表側には数字が書かれ、裏側には何も書かれていません。このカードを使って、あなたと相手の 2 名で以下のルールでゲー ムを行います。
あなたと相手には、表を上にして 1 枚、裏を上にして 1 枚、計 2 枚のカードが配られています。あなたは相手の表のカードの数字を見ることができますが、裏のカードの数字は見えません。
配られたカードの数字の合計が 20 以下で、かつ相手の数字の合計より大きいときに勝ちとなります。
      例えば、あなたのカードが「7」「8」 (合計 15) 、相手のカードが「9」「10」 (合計 19) のときは、相手の勝ちです。
あなたと相手は最大であと 1 枚カードを引くことができます。それを引かなくても構いません。
ここで、あと 1 枚のカードを引くかどうかを決定する目安として、カードを引いたときに合計が 20 以下に なる確率を考え、その確率が 50% 以上のときはカードを引くこととしましょう。この確率を計算するときには、あなたの 2 枚のカードと相手の表のカードの計3枚のカードの情報を利用することができます。つまり、各カードは 1 枚ずつしかないので、それらのカードを引くことはないことになります。
あなたの 2 枚のカードと相手の表のカードを読み込んで、それぞれについて、あと 1 枚引いたときに合計が 20 以下になる確率が 50% 以上のときは YES、そうでないなら NO を出力するプログラムを作成してください。
Input
入力は複数のデータセットからなります。 1 枚目のあなたのカードの数字を C1 、2 枚目のあなたのカードの数字を C2 、相手の表になっているカードの数字を C3 とすると、各データセットは以下の形式で与えられます。
C1 C2 C3
Output
各データセットに対して、
YES
または
NO
を１行に出力して下さい。
Sample Input
1 2 3
5 6 9
8 9 10
Output for the Sample Input
YES
YES
NO",Java,"import java.util.*;

public class Main {
	
	public static void main(String[] args) {
		Scanner sc = new Scanner(System.in);
		
		while(sc.hasNext()){
			int a = sc.nextInt();
			int b = sc.nextInt();
			int c = sc.nextInt();
			int count = 0;
			for(int i=1;i<=10;i++){
				if(i!=a && i!=b && i!=c && a+b+i>20) count++;
			}
			if(count<=3) System.out.println(""YES"");
			else System.out.println(""NO"");	
		}
	}	
}",1
p00060,"カードゲー ム
「1」から「10」までの数字が書かれたカードが各 1 枚、全部で 10 枚あります。このカードは、表側には数字が書かれ、裏側には何も書かれていません。このカードを使って、あなたと相手の 2 名で以下のルールでゲー ムを行います。
あなたと相手には、表を上にして 1 枚、裏を上にして 1 枚、計 2 枚のカードが配られています。あなたは相手の表のカードの数字を見ることができますが、裏のカードの数字は見えません。
配られたカードの数字の合計が 20 以下で、かつ相手の数字の合計より大きいときに勝ちとなります。
      例えば、あなたのカードが「7」「8」 (合計 15) 、相手のカードが「9」「10」 (合計 19) のときは、相手の勝ちです。
あなたと相手は最大であと 1 枚カードを引くことができます。それを引かなくても構いません。
ここで、あと 1 枚のカードを引くかどうかを決定する目安として、カードを引いたときに合計が 20 以下に なる確率を考え、その確率が 50% 以上のときはカードを引くこととしましょう。この確率を計算するときには、あなたの 2 枚のカードと相手の表のカードの計3枚のカードの情報を利用することができます。つまり、各カードは 1 枚ずつしかないので、それらのカードを引くことはないことになります。
あなたの 2 枚のカードと相手の表のカードを読み込んで、それぞれについて、あと 1 枚引いたときに合計が 20 以下になる確率が 50% 以上のときは YES、そうでないなら NO を出力するプログラムを作成してください。
Input
入力は複数のデータセットからなります。 1 枚目のあなたのカードの数字を C1 、2 枚目のあなたのカードの数字を C2 、相手の表になっているカードの数字を C3 とすると、各データセットは以下の形式で与えられます。
C1 C2 C3
Output
各データセットに対して、
YES
または
NO
を１行に出力して下さい。
Sample Input
1 2 3
5 6 9
8 9 10
Output for the Sample Input
YES
YES
NO",Python,"import sys

for line in sys.stdin:
    c1, c2, c3 = map(int, line.strip().split())
    
    current_sum = c1 + c2
    used_cards = {c1, c2, c3}
    
    available_cards = []
    for i in range(1, 11):
        if i not in used_cards:
            available_cards.append(i)
    
    valid_count = 0
    for card in available_cards:
        if current_sum + card <= 20:
            valid_count += 1
    
    total_count = len(available_cards)
    
    if valid_count / total_count >= 0.5:
        print(""YES"")
    else:
        print(""NO"")
",0
p00060,"カードゲー ム
「1」から「10」までの数字が書かれたカードが各 1 枚、全部で 10 枚あります。このカードは、表側には数字が書かれ、裏側には何も書かれていません。このカードを使って、あなたと相手の 2 名で以下のルールでゲー ムを行います。
あなたと相手には、表を上にして 1 枚、裏を上にして 1 枚、計 2 枚のカードが配られています。あなたは相手の表のカードの数字を見ることができますが、裏のカードの数字は見えません。
配られたカードの数字の合計が 20 以下で、かつ相手の数字の合計より大きいときに勝ちとなります。
      例えば、あなたのカードが「7」「8」 (合計 15) 、相手のカードが「9」「10」 (合計 19) のときは、相手の勝ちです。
あなたと相手は最大であと 1 枚カードを引くことができます。それを引かなくても構いません。
ここで、あと 1 枚のカードを引くかどうかを決定する目安として、カードを引いたときに合計が 20 以下に なる確率を考え、その確率が 50% 以上のときはカードを引くこととしましょう。この確率を計算するときには、あなたの 2 枚のカードと相手の表のカードの計3枚のカードの情報を利用することができます。つまり、各カードは 1 枚ずつしかないので、それらのカードを引くことはないことになります。
あなたの 2 枚のカードと相手の表のカードを読み込んで、それぞれについて、あと 1 枚引いたときに合計が 20 以下になる確率が 50% 以上のときは YES、そうでないなら NO を出力するプログラムを作成してください。
Input
入力は複数のデータセットからなります。 1 枚目のあなたのカードの数字を C1 、2 枚目のあなたのカードの数字を C2 、相手の表になっているカードの数字を C3 とすると、各データセットは以下の形式で与えられます。
C1 C2 C3
Output
各データセットに対して、
YES
または
NO
を１行に出力して下さい。
Sample Input
1 2 3
5 6 9
8 9 10
Output for the Sample Input
YES
YES
NO",Python,"import sys
for x in sys.stdin:
 e=list(map(int,x.split()))
 print(['YES','NO'][len(set(range(1,21-sum(e[:2])))-set(e))/7<.5])
",1
p00061,"Rank Checker
時は2020 年。パソコン甲子園 2020 の予選結果を保存したデータがあります。このデータには、各チームに振られる整理番号と正解数が保存されています。ここでは、正解数で順位を決定するものとし、正解数の多いほうから順に 1 位、2 位 ... と順位をつけていくこととします。
予選結果のデータと整理番号をキーボードから入力して、その番号のチームの順位を出力するプログラムを作成してください。
Input
入力データは２つの部分からなります。前半の部分は、予選結果のデータ、後半の部分は順位を知りたいチーム番号の問い合わせです。予選結果のデータの形式は以下の通りです。
p
1
,
s
1
p
2
,
s
2
...
...
0
,
0
p
i
(1 ≤
p
i
≤ 100 )、
s
i
(0 ≤
s
i
≤ 30) はそれぞれ
i
チーム目の整理番号と正解数を表す整数です。整理番号と正解数がともに 0 のときこのデータの入力が終わるものとします。
続いて後半の問い合わせが複数与えられます。問い合わせの形式は以下の通りです。
q
1
q
2
:
各問い合わせは１行に整理番号
q
i
(1 ≤
q
i
≤ 30) が与えられます。これを入力の最後まで処理して下さい。問い合わせの数は 100 を超えません。
Output
各問い合わせについて、チームの順位を１行に出力して下さい。
Sample Input
1,20
2,20
3,30
4,10
5,10
6,20
0,0
1
2
4
5
Output for the Sample Input
2
2
3
3
Note
入力例のデータにおいて、チームを正解数順に整列すると：
3,30
1,20
2,20
6,20
4,10
5,10
となります。ここでは、正解数を基に順位を決定するため、30問正解チームを1位、20問正解チームを2位、10問正解チームを3位とします（上位のチーム数を考慮し、10問正解チームを5位とする通常の順位付けとは異なることに注意して下さい）。",C,"#include <stdio.h>
#include <stdlib.h>

typedef struct {
    int id;
    int score;
} Team;

int compare(const void *a, const void *b) {
    Team *ta = (Team *)a;
    Team *tb = (Team *)b;
    return tb->score - ta->score;
}

int main() {
    Team teams[100];
    int count = 0;
    int id, score;
    
    while (1) {
        scanf(""%d,%d"", &id, &score);
        if (id == 0 && score == 0) break;
        teams[count].id = id;
        teams[count].score = score;
        count++;
    }
    
    qsort(teams, count, sizeof(Team), compare);
    
    int query;
    while (scanf(""%d"", &query) != EOF) {
        int target_score = -1;
        for (int i = 0; i < count; i++) {
            if (teams[i].id == query) {
                target_score = teams[i].score;
                break;
            }
        }
        
        int rank = 1;
        int prev_score = -1;
        int current_rank = 0;
        
        for (int i = 0; i < count; i++) {
            if (teams[i].score != prev_score) {
                current_rank++;
                prev_score = teams[i].score;
            }
            if (teams[i].score == target_score) {
                rank = current_rank;
                break;
            }
        }
        
        printf(""%d\n"", rank);
    }
    
    return 0;
}
",0
p00061,"Rank Checker
時は2020 年。パソコン甲子園 2020 の予選結果を保存したデータがあります。このデータには、各チームに振られる整理番号と正解数が保存されています。ここでは、正解数で順位を決定するものとし、正解数の多いほうから順に 1 位、2 位 ... と順位をつけていくこととします。
予選結果のデータと整理番号をキーボードから入力して、その番号のチームの順位を出力するプログラムを作成してください。
Input
入力データは２つの部分からなります。前半の部分は、予選結果のデータ、後半の部分は順位を知りたいチーム番号の問い合わせです。予選結果のデータの形式は以下の通りです。
p
1
,
s
1
p
2
,
s
2
...
...
0
,
0
p
i
(1 ≤
p
i
≤ 100 )、
s
i
(0 ≤
s
i
≤ 30) はそれぞれ
i
チーム目の整理番号と正解数を表す整数です。整理番号と正解数がともに 0 のときこのデータの入力が終わるものとします。
続いて後半の問い合わせが複数与えられます。問い合わせの形式は以下の通りです。
q
1
q
2
:
各問い合わせは１行に整理番号
q
i
(1 ≤
q
i
≤ 30) が与えられます。これを入力の最後まで処理して下さい。問い合わせの数は 100 を超えません。
Output
各問い合わせについて、チームの順位を１行に出力して下さい。
Sample Input
1,20
2,20
3,30
4,10
5,10
6,20
0,0
1
2
4
5
Output for the Sample Input
2
2
3
3
Note
入力例のデータにおいて、チームを正解数順に整列すると：
3,30
1,20
2,20
6,20
4,10
5,10
となります。ここでは、正解数を基に順位を決定するため、30問正解チームを1位、20問正解チームを2位、10問正解チームを3位とします（上位のチーム数を考慮し、10問正解チームを5位とする通常の順位付けとは異なることに注意して下さい）。",C,"#include <stdio.h>

int main(void)
{
	int i,j,k;
	int team[100],score[100];
	int rank[100];
	int count,number,tmp1,tmp2,info;
	
	count=0;
	//入力
	for(i=0;i<100;i++)
	{
		scanf(""%d,%d"",&team[i],&score[i]);
		if(team[i]+score[i]==0)
			break;
		count++;
	}
	
	//並び替え
	for(i=0;i<count;i++)
	{
		for(j=count-1;j>i;j--)
		{
			if(score[i]<=score[j])
			{
				tmp1=score[i];
				score[i]=score[j];
				score[j]=tmp1;
				
				tmp1=team[i];
				team[i]=team[j];
				team[j]=tmp1;
			}
		}
	}
	//順位付け
	number=1;
	rank[0]=number;
	tmp2=score[0];
	for(i=1;i<count;i++)
	{
		//printf(""%d %d\n"",score[i],tmp2);
		if(score[i]!=tmp2)
		{
			number++;
			tmp2=score[i];
		}
		rank[i]=number;
	}
	
	
	//問い合わせ
	while(scanf(""%d"",&info)!=EOF)
	{
		for(i=0;i<count;i++)
		{
			if(info==team[i])
				printf(""%d\n"",rank[i]);
			//printf(""%d,%d\n"",team[i],score[i]);
		}
	}
	return 0;
}",1
p00061,"Rank Checker
時は2020 年。パソコン甲子園 2020 の予選結果を保存したデータがあります。このデータには、各チームに振られる整理番号と正解数が保存されています。ここでは、正解数で順位を決定するものとし、正解数の多いほうから順に 1 位、2 位 ... と順位をつけていくこととします。
予選結果のデータと整理番号をキーボードから入力して、その番号のチームの順位を出力するプログラムを作成してください。
Input
入力データは２つの部分からなります。前半の部分は、予選結果のデータ、後半の部分は順位を知りたいチーム番号の問い合わせです。予選結果のデータの形式は以下の通りです。
p
1
,
s
1
p
2
,
s
2
...
...
0
,
0
p
i
(1 ≤
p
i
≤ 100 )、
s
i
(0 ≤
s
i
≤ 30) はそれぞれ
i
チーム目の整理番号と正解数を表す整数です。整理番号と正解数がともに 0 のときこのデータの入力が終わるものとします。
続いて後半の問い合わせが複数与えられます。問い合わせの形式は以下の通りです。
q
1
q
2
:
各問い合わせは１行に整理番号
q
i
(1 ≤
q
i
≤ 30) が与えられます。これを入力の最後まで処理して下さい。問い合わせの数は 100 を超えません。
Output
各問い合わせについて、チームの順位を１行に出力して下さい。
Sample Input
1,20
2,20
3,30
4,10
5,10
6,20
0,0
1
2
4
5
Output for the Sample Input
2
2
3
3
Note
入力例のデータにおいて、チームを正解数順に整列すると：
3,30
1,20
2,20
6,20
4,10
5,10
となります。ここでは、正解数を基に順位を決定するため、30問正解チームを1位、20問正解チームを2位、10問正解チームを3位とします（上位のチーム数を考慮し、10問正解チームを5位とする通常の順位付けとは異なることに注意して下さい）。",Java,"import java.util.*;

public class Main {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        
        Map<Integer, Integer> teamScores = new HashMap<>();
        
        while (true) {
            String line = sc.nextLine();
            String[] parts = line.split("","");
            int teamId = Integer.parseInt(parts[0]);
            int score = Integer.parseInt(parts[1]);
            
            if (teamId == 0 && score == 0) {
                break;
            }
            
            teamScores.put(teamId, score);
        }
        
        List<Integer> sortedScores = new ArrayList<>(teamScores.values());
        Collections.sort(sortedScores, Collections.reverseOrder());
        
        Map<Integer, Integer> scoreToRank = new HashMap<>();
        int rank = 1;
        for (int score : sortedScores) {
            if (!scoreToRank.containsKey(score)) {
                scoreToRank.put(score, rank);
                rank++;
            }
        }
        
        while (sc.hasNextLine()) {
            String line = sc.nextLine();
            if (line.isEmpty()) break;
            int queryTeam = Integer.parseInt(line.trim());
            int score = teamScores.get(queryTeam);
            int teamRank = scoreToRank.get(score);
            System.out.println(teamRank);
        }
        
        sc.close();
    }
}
",0
p00061,"Rank Checker
時は2020 年。パソコン甲子園 2020 の予選結果を保存したデータがあります。このデータには、各チームに振られる整理番号と正解数が保存されています。ここでは、正解数で順位を決定するものとし、正解数の多いほうから順に 1 位、2 位 ... と順位をつけていくこととします。
予選結果のデータと整理番号をキーボードから入力して、その番号のチームの順位を出力するプログラムを作成してください。
Input
入力データは２つの部分からなります。前半の部分は、予選結果のデータ、後半の部分は順位を知りたいチーム番号の問い合わせです。予選結果のデータの形式は以下の通りです。
p
1
,
s
1
p
2
,
s
2
...
...
0
,
0
p
i
(1 ≤
p
i
≤ 100 )、
s
i
(0 ≤
s
i
≤ 30) はそれぞれ
i
チーム目の整理番号と正解数を表す整数です。整理番号と正解数がともに 0 のときこのデータの入力が終わるものとします。
続いて後半の問い合わせが複数与えられます。問い合わせの形式は以下の通りです。
q
1
q
2
:
各問い合わせは１行に整理番号
q
i
(1 ≤
q
i
≤ 30) が与えられます。これを入力の最後まで処理して下さい。問い合わせの数は 100 を超えません。
Output
各問い合わせについて、チームの順位を１行に出力して下さい。
Sample Input
1,20
2,20
3,30
4,10
5,10
6,20
0,0
1
2
4
5
Output for the Sample Input
2
2
3
3
Note
入力例のデータにおいて、チームを正解数順に整列すると：
3,30
1,20
2,20
6,20
4,10
5,10
となります。ここでは、正解数を基に順位を決定するため、30問正解チームを1位、20問正解チームを2位、10問正解チームを3位とします（上位のチーム数を考慮し、10問正解チームを5位とする通常の順位付けとは異なることに注意して下さい）。",Java,"import java.util.Scanner;
class Main{
	public static void main(String args[]){
		Scanner sc = new Scanner(System.in);
		String point[]= new String[100];
		int rank[]= new int[30];
		int n = 0;
		int count=0;
		while(sc.hasNext()){
			String get = sc.next();
			if(get.equals(""0,0""))break;
			String str[] = get.split("","");
			point[n = Integer.parseInt(str[0])]=str[1];
			rank[n= Integer.parseInt(str[1])-1]++;
		}
		while(sc.hasNext()){
			count=1;
			n = sc.nextInt();
			for(int i = 29 ;i > Integer.parseInt(point[n]);i--){
				if(rank[i]>0)count++;
			}
			System.out.println(count);
		}
	}	
}",1
p00061,"Rank Checker
時は2020 年。パソコン甲子園 2020 の予選結果を保存したデータがあります。このデータには、各チームに振られる整理番号と正解数が保存されています。ここでは、正解数で順位を決定するものとし、正解数の多いほうから順に 1 位、2 位 ... と順位をつけていくこととします。
予選結果のデータと整理番号をキーボードから入力して、その番号のチームの順位を出力するプログラムを作成してください。
Input
入力データは２つの部分からなります。前半の部分は、予選結果のデータ、後半の部分は順位を知りたいチーム番号の問い合わせです。予選結果のデータの形式は以下の通りです。
p
1
,
s
1
p
2
,
s
2
...
...
0
,
0
p
i
(1 ≤
p
i
≤ 100 )、
s
i
(0 ≤
s
i
≤ 30) はそれぞれ
i
チーム目の整理番号と正解数を表す整数です。整理番号と正解数がともに 0 のときこのデータの入力が終わるものとします。
続いて後半の問い合わせが複数与えられます。問い合わせの形式は以下の通りです。
q
1
q
2
:
各問い合わせは１行に整理番号
q
i
(1 ≤
q
i
≤ 30) が与えられます。これを入力の最後まで処理して下さい。問い合わせの数は 100 を超えません。
Output
各問い合わせについて、チームの順位を１行に出力して下さい。
Sample Input
1,20
2,20
3,30
4,10
5,10
6,20
0,0
1
2
4
5
Output for the Sample Input
2
2
3
3
Note
入力例のデータにおいて、チームを正解数順に整列すると：
3,30
1,20
2,20
6,20
4,10
5,10
となります。ここでは、正解数を基に順位を決定するため、30問正解チームを1位、20問正解チームを2位、10問正解チームを3位とします（上位のチーム数を考慮し、10問正解チームを5位とする通常の順位付けとは異なることに注意して下さい）。",Python,"# Read team data
teams = {}
while True:
    line = input().strip()
    parts = line.split(',')
    team_id = int(parts[0])
    score = int(parts[1])
    if team_id == 0 and score == 0:
        break
    teams[team_id] = score

# Get unique scores and sort them in descending order
unique_scores = sorted(set(teams.values()), reverse=True)

# Create a mapping from score to rank
score_to_rank = {}
for i, score in enumerate(unique_scores):
    score_to_rank[score] = i + 1

# Process queries
import sys
for line in sys.stdin:
    query = int(line.strip())
    score = teams[query]
    rank = score_to_rank[score]
    print(rank)
",0
p00061,"Rank Checker
時は2020 年。パソコン甲子園 2020 の予選結果を保存したデータがあります。このデータには、各チームに振られる整理番号と正解数が保存されています。ここでは、正解数で順位を決定するものとし、正解数の多いほうから順に 1 位、2 位 ... と順位をつけていくこととします。
予選結果のデータと整理番号をキーボードから入力して、その番号のチームの順位を出力するプログラムを作成してください。
Input
入力データは２つの部分からなります。前半の部分は、予選結果のデータ、後半の部分は順位を知りたいチーム番号の問い合わせです。予選結果のデータの形式は以下の通りです。
p
1
,
s
1
p
2
,
s
2
...
...
0
,
0
p
i
(1 ≤
p
i
≤ 100 )、
s
i
(0 ≤
s
i
≤ 30) はそれぞれ
i
チーム目の整理番号と正解数を表す整数です。整理番号と正解数がともに 0 のときこのデータの入力が終わるものとします。
続いて後半の問い合わせが複数与えられます。問い合わせの形式は以下の通りです。
q
1
q
2
:
各問い合わせは１行に整理番号
q
i
(1 ≤
q
i
≤ 30) が与えられます。これを入力の最後まで処理して下さい。問い合わせの数は 100 を超えません。
Output
各問い合わせについて、チームの順位を１行に出力して下さい。
Sample Input
1,20
2,20
3,30
4,10
5,10
6,20
0,0
1
2
4
5
Output for the Sample Input
2
2
3
3
Note
入力例のデータにおいて、チームを正解数順に整列すると：
3,30
1,20
2,20
6,20
4,10
5,10
となります。ここでは、正解数を基に順位を決定するため、30問正解チームを1位、20問正解チームを2位、10問正解チームを3位とします（上位のチーム数を考慮し、10問正解チームを5位とする通常の順位付けとは異なることに注意して下さい）。",Python,"nums={}
while True:
    p,s=map(int,input().split(','))
    if(p==0 and s==0):break
    if not s in nums:
        nums[s]=[]
    nums[s].append(p)

while True:
    try:
        q=int(input())
        ans=len(nums)
        for ns in nums.items():
            if q in ns[1]:
                print(ans)
                break
            ans-=1
    except:
        break",1
p00063,"回文
半角アルファベット文字列からなる、1 行あたり 100 文字以内のデータがあります。いくつかの行は対称（左端から読んでも右端から読んでも同じ）です。このデータを読み込んで、その中の対称な文字列の数を出力するプログラムを作成してください。なお、１文字だけからなる行は対称であるとします。
Input
複数の文字列が複数行にわたって与えられます。各行に１つの文字列が与えられます。文字列の数は 50 を超えません。
Output
対称な文字列の数を１行に出力します。
Sample Input
abcba
sx
abcddcba
rttrd
Output for the Sample Input
2",C,"#include <stdio.h>
#include <string.h>

int isPalindrome(char *str) {
    int len = strlen(str);
    if (str[len-1] == '\n') {
        str[len-1] = '\0';
        len--;
    }
    
    for (int i = 0; i < len / 2; i++) {
        if (str[i] != str[len - 1 - i]) {
            return 0;
        }
    }
    return 1;
}

int main() {
    char line[101];
    int count = 0;
    
    while (fgets(line, sizeof(line), stdin) != NULL) {
        if (isPalindrome(line)) {
            count++;
        }
    }
    
    printf(""%d\n"", count);
    
    return 0;
}
",0
p00063,"回文
半角アルファベット文字列からなる、1 行あたり 100 文字以内のデータがあります。いくつかの行は対称（左端から読んでも右端から読んでも同じ）です。このデータを読み込んで、その中の対称な文字列の数を出力するプログラムを作成してください。なお、１文字だけからなる行は対称であるとします。
Input
複数の文字列が複数行にわたって与えられます。各行に１つの文字列が与えられます。文字列の数は 50 を超えません。
Output
対称な文字列の数を１行に出力します。
Sample Input
abcba
sx
abcddcba
rttrd
Output for the Sample Input
2",C,"#include <stdio.h>
#include <string.h>
#define N 100

void hanten(char str[],int n){
  char t;
  int i,j;
    for (j=0;j<n/2;j++){
      t=str[j];
      str[j]=str[n-j-1];
      str[n-j-1]=t;
    }
}

int main()
{
  int i,j,cnt=0;
  char str1[N],str2[N];
  while (scanf(""%s"",str1)!=EOF){
    strcpy(str2,str1);
    hanten(str1,strlen(str1));
    if (strcmp(str1,str2)==0)
      cnt++;
  }
  printf(""%d\n"",cnt);

  return 0;
}",1
p00063,"回文
半角アルファベット文字列からなる、1 行あたり 100 文字以内のデータがあります。いくつかの行は対称（左端から読んでも右端から読んでも同じ）です。このデータを読み込んで、その中の対称な文字列の数を出力するプログラムを作成してください。なお、１文字だけからなる行は対称であるとします。
Input
複数の文字列が複数行にわたって与えられます。各行に１つの文字列が与えられます。文字列の数は 50 を超えません。
Output
対称な文字列の数を１行に出力します。
Sample Input
abcba
sx
abcddcba
rttrd
Output for the Sample Input
2",Java,"import java.util.*;

public class Main {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int count = 0;
        
        while (sc.hasNextLine()) {
            String line = sc.nextLine();
            if (isPalindrome(line)) {
                count++;
            }
        }
        
        System.out.println(count);
        sc.close();
    }
    
    static boolean isPalindrome(String s) {
        int left = 0;
        int right = s.length() - 1;
        
        while (left < right) {
            if (s.charAt(left) != s.charAt(right)) {
                return false;
            }
            left++;
            right--;
        }
        
        return true;
    }
}
",0
p00063,"回文
半角アルファベット文字列からなる、1 行あたり 100 文字以内のデータがあります。いくつかの行は対称（左端から読んでも右端から読んでも同じ）です。このデータを読み込んで、その中の対称な文字列の数を出力するプログラムを作成してください。なお、１文字だけからなる行は対称であるとします。
Input
複数の文字列が複数行にわたって与えられます。各行に１つの文字列が与えられます。文字列の数は 50 を超えません。
Output
対称な文字列の数を１行に出力します。
Sample Input
abcba
sx
abcddcba
rttrd
Output for the Sample Input
2",Java,"import java.util.*;

public class Main {
    private static final Scanner scn = new Scanner(System.in);
    
    public static void main(String[] args) {
        int cnt = 0;
        while(scn.hasNext()) {
            String str = scn.next();
            String rev = new String(new StringBuilder(str).reverse());
            if(str.equals(rev)) {
                cnt++;
            }
        }
        System.out.println(cnt);
    }
}",1
p00063,"回文
半角アルファベット文字列からなる、1 行あたり 100 文字以内のデータがあります。いくつかの行は対称（左端から読んでも右端から読んでも同じ）です。このデータを読み込んで、その中の対称な文字列の数を出力するプログラムを作成してください。なお、１文字だけからなる行は対称であるとします。
Input
複数の文字列が複数行にわたって与えられます。各行に１つの文字列が与えられます。文字列の数は 50 を超えません。
Output
対称な文字列の数を１行に出力します。
Sample Input
abcba
sx
abcddcba
rttrd
Output for the Sample Input
2",Python,"import sys

count = 0
for line in sys.stdin:
    s = line.strip()
    if s == s[::-1]:
        count += 1

print(count)
",0
p00063,"回文
半角アルファベット文字列からなる、1 行あたり 100 文字以内のデータがあります。いくつかの行は対称（左端から読んでも右端から読んでも同じ）です。このデータを読み込んで、その中の対称な文字列の数を出力するプログラムを作成してください。なお、１文字だけからなる行は対称であるとします。
Input
複数の文字列が複数行にわたって与えられます。各行に１つの文字列が与えられます。文字列の数は 50 を超えません。
Output
対称な文字列の数を１行に出力します。
Sample Input
abcba
sx
abcddcba
rttrd
Output for the Sample Input
2",Python,"# -*- coding: utf-8 -*-

import sys

def is_pal(s):
    l = len(s)-1
    for i in range(l/2):
        if s[i] != s[l-1-i]:
            return False
    return True

count = 0
for line in sys.stdin:
    if is_pal(line):
        count += 1
print count",1
p00064,"暗証番号
新しい暗証番号は覚えにくいものです。メモするのはダメといわれましたが、覚えられそうにありません。そこで文章の中に数値を埋め込んで暗証番号をメモすることにしました。ここでは全ての数値の和が暗証番号になります。
メモされた文章を読み込んで、暗証番号を出力するプログラムを作成してください。
Input
正の整数が埋め込まれた文章が複数行にわたり与えられます。各行は半角英数字、記号、空白を含む文字列または空行です。
ただし、入力は 1 行あたり 80 文字以内で、暗証番号は 10,000 以下であることが保障されています。
Output
暗証番号（文章中の正の整数の合計）を１行に出力します。
Sample Input
Thereare100yenonthetable.Iam17yearsold.
Ishouldgohomeat6pm.
Output for the Sample Input
123",C,"#include <stdio.h>
#include <ctype.h>

int main() {
    int sum = 0;
    int num = 0;
    int in_number = 0;
    char c;
    
    while ((c = getchar()) != EOF) {
        if (isdigit(c)) {
            num = num * 10 + (c - '0');
            in_number = 1;
        } else {
            if (in_number) {
                sum += num;
                num = 0;
                in_number = 0;
            }
        }
    }
    
    if (in_number) {
        sum += num;
    }
    
    printf(""%d\n"", sum);
    
    return 0;
}
",0
p00064,"暗証番号
新しい暗証番号は覚えにくいものです。メモするのはダメといわれましたが、覚えられそうにありません。そこで文章の中に数値を埋め込んで暗証番号をメモすることにしました。ここでは全ての数値の和が暗証番号になります。
メモされた文章を読み込んで、暗証番号を出力するプログラムを作成してください。
Input
正の整数が埋め込まれた文章が複数行にわたり与えられます。各行は半角英数字、記号、空白を含む文字列または空行です。
ただし、入力は 1 行あたり 80 文字以内で、暗証番号は 10,000 以下であることが保障されています。
Output
暗証番号（文章中の正の整数の合計）を１行に出力します。
Sample Input
Thereare100yenonthetable.Iam17yearsold.
Ishouldgohomeat6pm.
Output for the Sample Input
123",C,"#include <stdio.h>
#include <ctype.h>

int main()
{
        char str[81], tmp[6];
        int num = 0, i, sum = 0;

        while ( scanf( ""%s"", str ) == 1 ) {
                i = 0;
                while ( str[i] ) {
                        if ( isdigit( str[i] ) ) {
                                num = 0;
                                while ( isdigit( str[i] ) ) {
                                        num = 10 * num + ( str[i] - '0' );
                                        i++;
                                }
                                sum = sum + num;
                        } else {
                                i++;
                        }
                }
        }

        printf( ""%d\n"", sum );

        return 0;
}

",1
p00064,"暗証番号
新しい暗証番号は覚えにくいものです。メモするのはダメといわれましたが、覚えられそうにありません。そこで文章の中に数値を埋め込んで暗証番号をメモすることにしました。ここでは全ての数値の和が暗証番号になります。
メモされた文章を読み込んで、暗証番号を出力するプログラムを作成してください。
Input
正の整数が埋め込まれた文章が複数行にわたり与えられます。各行は半角英数字、記号、空白を含む文字列または空行です。
ただし、入力は 1 行あたり 80 文字以内で、暗証番号は 10,000 以下であることが保障されています。
Output
暗証番号（文章中の正の整数の合計）を１行に出力します。
Sample Input
Thereare100yenonthetable.Iam17yearsold.
Ishouldgohomeat6pm.
Output for the Sample Input
123",Java,"import java.util.*;
import java.util.regex.*;

public class Main {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int sum = 0;
        Pattern pattern = Pattern.compile(""\\d+"");
        
        while (sc.hasNextLine()) {
            String line = sc.nextLine();
            Matcher matcher = pattern.matcher(line);
            
            while (matcher.find()) {
                sum += Integer.parseInt(matcher.group());
            }
        }
        
        System.out.println(sum);
        sc.close();
    }
}
",0
p00064,"暗証番号
新しい暗証番号は覚えにくいものです。メモするのはダメといわれましたが、覚えられそうにありません。そこで文章の中に数値を埋め込んで暗証番号をメモすることにしました。ここでは全ての数値の和が暗証番号になります。
メモされた文章を読み込んで、暗証番号を出力するプログラムを作成してください。
Input
正の整数が埋め込まれた文章が複数行にわたり与えられます。各行は半角英数字、記号、空白を含む文字列または空行です。
ただし、入力は 1 行あたり 80 文字以内で、暗証番号は 10,000 以下であることが保障されています。
Output
暗証番号（文章中の正の整数の合計）を１行に出力します。
Sample Input
Thereare100yenonthetable.Iam17yearsold.
Ishouldgohomeat6pm.
Output for the Sample Input
123",Java,"import java.util.Scanner;

public class Main{
	public static void main(String[] args){
		Scanner sc = new Scanner(System.in);
		
		int n = 0,sum = 0;
		
		while(sc.hasNext()){
			char[] ch = sc.next().toCharArray();
		for(int i = 0; i < ch.length; i++){
			if('0' <= ch[i] && ch[i] <= '9'){
				n = n * 10;
				n += ch[i] - '0';
			}else{
				sum += n;
				n = 0;
			}
		}
		sum += n;
		}
		System.out.println(sum);
		
		sc.close();
	}
}",1
p00064,"暗証番号
新しい暗証番号は覚えにくいものです。メモするのはダメといわれましたが、覚えられそうにありません。そこで文章の中に数値を埋め込んで暗証番号をメモすることにしました。ここでは全ての数値の和が暗証番号になります。
メモされた文章を読み込んで、暗証番号を出力するプログラムを作成してください。
Input
正の整数が埋め込まれた文章が複数行にわたり与えられます。各行は半角英数字、記号、空白を含む文字列または空行です。
ただし、入力は 1 行あたり 80 文字以内で、暗証番号は 10,000 以下であることが保障されています。
Output
暗証番号（文章中の正の整数の合計）を１行に出力します。
Sample Input
Thereare100yenonthetable.Iam17yearsold.
Ishouldgohomeat6pm.
Output for the Sample Input
123",Python,"import sys
import re

total = 0
for line in sys.stdin:
    numbers = re.findall(r'\d+', line)
    for num in numbers:
        total += int(num)

print(total)
",0
p00064,"暗証番号
新しい暗証番号は覚えにくいものです。メモするのはダメといわれましたが、覚えられそうにありません。そこで文章の中に数値を埋め込んで暗証番号をメモすることにしました。ここでは全ての数値の和が暗証番号になります。
メモされた文章を読み込んで、暗証番号を出力するプログラムを作成してください。
Input
正の整数が埋め込まれた文章が複数行にわたり与えられます。各行は半角英数字、記号、空白を含む文字列または空行です。
ただし、入力は 1 行あたり 80 文字以内で、暗証番号は 10,000 以下であることが保障されています。
Output
暗証番号（文章中の正の整数の合計）を１行に出力します。
Sample Input
Thereare100yenonthetable.Iam17yearsold.
Ishouldgohomeat6pm.
Output for the Sample Input
123",Python,"import re
ans = 0
while True:
    try:
        line = input()
    except:
        print(ans)
        break
    ans += sum(map(int, re.findall(""[0-9]+"", line)))",1
p00065,"取引
取引先の顧客番号と取引日を月ごとに記録したデータがあります。今月のデータと先月のデータを読み込んで、先月から２ヶ月連続で取引のある会社の顧客番号と取引のあった回数を出力するプログラムを作成してください。ただし、月々の取引先数は 1,000 社以内です。
Input
今月のデータと、先月のデータが１行の空行で区切られて与えられます。それぞれのデータは以下のような形式で与えられます。
c
1
,
d
1
c
2
,
d
2
...
...
c
i
(1 ≤
c
i
≤ 1,000) は顧客番号を表す整数、
d
i
(1 ≤
d
i
≤ 31) は取引日を表す整数です。
Output
２ヶ月連続で取引のある会社について、顧客番号が小さい順に顧客番号と取引回数の総数を空白で区切って出力します。
Sample Input
123,10
56,12
34,14

123,3
56,4
123,5
Output for the Sample Input
56 2
123 3",C,"#include <stdio.h>
#include <string.h>

int main() {
    int this_month[1001] = {0};
    int last_month[1001] = {0};
    int customer, day;
    char line[100];
    int reading_this_month = 1;
    
    while (fgets(line, sizeof(line), stdin)) {
        if (line[0] == '\n' || strlen(line) <= 1) {
            reading_this_month = 0;
            continue;
        }
        
        if (sscanf(line, ""%d,%d"", &customer, &day) == 2) {
            if (reading_this_month) {
                this_month[customer]++;
            } else {
                last_month[customer]++;
            }
        }
    }
    
    for (int i = 1; i <= 1000; i++) {
        if (this_month[i] > 0 && last_month[i] > 0) {
            printf(""%d %d\n"", i, this_month[i] + last_month[i]);
        }
    }
    
    return 0;
}
",0
p00065,"取引
取引先の顧客番号と取引日を月ごとに記録したデータがあります。今月のデータと先月のデータを読み込んで、先月から２ヶ月連続で取引のある会社の顧客番号と取引のあった回数を出力するプログラムを作成してください。ただし、月々の取引先数は 1,000 社以内です。
Input
今月のデータと、先月のデータが１行の空行で区切られて与えられます。それぞれのデータは以下のような形式で与えられます。
c
1
,
d
1
c
2
,
d
2
...
...
c
i
(1 ≤
c
i
≤ 1,000) は顧客番号を表す整数、
d
i
(1 ≤
d
i
≤ 31) は取引日を表す整数です。
Output
２ヶ月連続で取引のある会社について、顧客番号が小さい順に顧客番号と取引回数の総数を空白で区切って出力します。
Sample Input
123,10
56,12
34,14

123,3
56,4
123,5
Output for the Sample Input
56 2
123 3",C,"#include<stdio.h>
#include<math.h>
#include <stdlib.h>
#include<string.h>
#include<limits.h>
#include<time.h>

void sosu(int n){
	int i,j,num[n];
	
	for(i=2;i<=n;i++)num[i]=i;
	for(i=2;i<=sqrt(n);i++){
		for(j=2;j*i<=n;j++)num[j*i]=0;
	}
}

int main(){
	int number[10000]={0};
	int ac[10000]={0};
	int i,j,k,count;
	
	for(i=0;scanf(""%d,%d"",&number[i],&ac[i])!=EOF;i++);
	for(j=i;scanf(""%d,%d"",&number[j],&ac[j])!=EOF;j++);
	count=j;
	
	for(i=0;i<count;i++){
		for(j=0;j<count;j++){
			if(number[i]<number[j]){
				k=number[i];
				number[i]=number[j];
				number[j]=k;
			}
		}
	}
	
	for(i=0,k=0;i<count;i++){
		for(j=i;j<count;j++){
			if(number[i]==number[j] && i!=j)k++;
		}
		i+=k;
		if(k>=1)printf(""%d %d\n"",number[i],k+1);
		k=0;
	}
	
return 0;

}",1
p00065,"取引
取引先の顧客番号と取引日を月ごとに記録したデータがあります。今月のデータと先月のデータを読み込んで、先月から２ヶ月連続で取引のある会社の顧客番号と取引のあった回数を出力するプログラムを作成してください。ただし、月々の取引先数は 1,000 社以内です。
Input
今月のデータと、先月のデータが１行の空行で区切られて与えられます。それぞれのデータは以下のような形式で与えられます。
c
1
,
d
1
c
2
,
d
2
...
...
c
i
(1 ≤
c
i
≤ 1,000) は顧客番号を表す整数、
d
i
(1 ≤
d
i
≤ 31) は取引日を表す整数です。
Output
２ヶ月連続で取引のある会社について、顧客番号が小さい順に顧客番号と取引回数の総数を空白で区切って出力します。
Sample Input
123,10
56,12
34,14

123,3
56,4
123,5
Output for the Sample Input
56 2
123 3",Java,"import java.util.*;

public class Main {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        
        Map<Integer, Integer> thisMonth = new HashMap<>();
        Map<Integer, Integer> lastMonth = new HashMap<>();
        
        // Read this month's data
        while (sc.hasNextLine()) {
            String line = sc.nextLine();
            if (line.trim().isEmpty()) {
                break;
            }
            String[] parts = line.split("","");
            int customer = Integer.parseInt(parts[0]);
            thisMonth.put(customer, thisMonth.getOrDefault(customer, 0) + 1);
        }
        
        // Read last month's data
        while (sc.hasNextLine()) {
            String line = sc.nextLine();
            if (line.trim().isEmpty()) {
                break;
            }
            String[] parts = line.split("","");
            int customer = Integer.parseInt(parts[0]);
            lastMonth.put(customer, lastMonth.getOrDefault(customer, 0) + 1);
        }
        
        // Find customers in both months
        Set<Integer> commonCustomers = new HashSet<>(thisMonth.keySet());
        commonCustomers.retainAll(lastMonth.keySet());
        
        // Sort and output
        List<Integer> sortedCustomers = new ArrayList<>(commonCustomers);
        Collections.sort(sortedCustomers);
        
        for (int customer : sortedCustomers) {
            int total = thisMonth.get(customer) + lastMonth.get(customer);
            System.out.println(customer + "" "" + total);
        }
        
        sc.close();
    }
}
",0
p00065,"取引
取引先の顧客番号と取引日を月ごとに記録したデータがあります。今月のデータと先月のデータを読み込んで、先月から２ヶ月連続で取引のある会社の顧客番号と取引のあった回数を出力するプログラムを作成してください。ただし、月々の取引先数は 1,000 社以内です。
Input
今月のデータと、先月のデータが１行の空行で区切られて与えられます。それぞれのデータは以下のような形式で与えられます。
c
1
,
d
1
c
2
,
d
2
...
...
c
i
(1 ≤
c
i
≤ 1,000) は顧客番号を表す整数、
d
i
(1 ≤
d
i
≤ 31) は取引日を表す整数です。
Output
２ヶ月連続で取引のある会社について、顧客番号が小さい順に顧客番号と取引回数の総数を空白で区切って出力します。
Sample Input
123,10
56,12
34,14

123,3
56,4
123,5
Output for the Sample Input
56 2
123 3",Java,"import java.util.*;
import java.util.Map.Entry;

//文字操作
class Main {
	Scanner sc = new Scanner(System.in);

	public void run() {
		Hashtable<Integer,Integer> data1=new Hashtable<Integer, Integer>();
		Hashtable<Integer,Integer> data2=new Hashtable<Integer, Integer>();

		while(sc.hasNext()){
			String[] str=sc.nextLine().split("","");
			if("""".equals(str[0]))break;
			int[] vals=new int[]{Integer.parseInt(str[0]),Integer.parseInt(str[1])};
			if(data1.containsKey(vals[0])){
				data1.put(vals[0],data1.get(vals[0])+1);
			}else{
				data1.put(vals[0],1);
			}
		}
		while(sc.hasNext()){
			String[] str=sc.nextLine().split("","");
			if("""".equals(str[0]))break;
			int[] vals=new int[]{Integer.parseInt(str[0]),Integer.parseInt(str[1])};
			if(data2.containsKey(vals[0])){
				data2.put(vals[0],data2.get(vals[0])+1);
			}else{
				data2.put(vals[0],1);
			}
		}
		ArrayList<Entry<Integer,Integer>> data1list=new ArrayList<Entry<Integer,Integer>>(data1.entrySet());
		Collections.sort(data1list,new Comparator<Entry<Integer,Integer>>() {
			@Override
			public int compare(Entry<Integer, Integer> o1,
					Entry<Integer, Integer> o2) {
				return o1.getKey()-o2.getKey();
			}
		});
		for(Entry<Integer,Integer> entry:data1list){
			if(data2.containsKey(entry.getKey())){
				ln(entry.getKey()+"" ""+ (entry.getValue()+data2.get(entry.getKey())));
			}
		}
	}

	public static void main(String[] args) {
		new Main().run();
	}

	public static void pr(Object o) {
		System.out.print(o);
	}

	public static void ln(Object o) {
		System.out.println(o);
	}

	public static void ln() {
		System.out.println();
	}
}",1
p00065,"取引
取引先の顧客番号と取引日を月ごとに記録したデータがあります。今月のデータと先月のデータを読み込んで、先月から２ヶ月連続で取引のある会社の顧客番号と取引のあった回数を出力するプログラムを作成してください。ただし、月々の取引先数は 1,000 社以内です。
Input
今月のデータと、先月のデータが１行の空行で区切られて与えられます。それぞれのデータは以下のような形式で与えられます。
c
1
,
d
1
c
2
,
d
2
...
...
c
i
(1 ≤
c
i
≤ 1,000) は顧客番号を表す整数、
d
i
(1 ≤
d
i
≤ 31) は取引日を表す整数です。
Output
２ヶ月連続で取引のある会社について、顧客番号が小さい順に顧客番号と取引回数の総数を空白で区切って出力します。
Sample Input
123,10
56,12
34,14

123,3
56,4
123,5
Output for the Sample Input
56 2
123 3",Python,"import sys

# Read all input
lines = []
for line in sys.stdin:
    lines.append(line.strip())

# Find the empty line that separates this month and last month
separator_idx = -1
for i, line in enumerate(lines):
    if line == '':
        separator_idx = i
        break

# Parse this month's data
this_month = lines[:separator_idx]
last_month = lines[separator_idx + 1:]

# Count transactions for each customer
this_month_customers = {}
last_month_customers = {}

for line in this_month:
    if line:
        parts = line.split(',')
        customer_id = int(parts[0])
        this_month_customers[customer_id] = this_month_customers.get(customer_id, 0) + 1

for line in last_month:
    if line:
        parts = line.split(',')
        customer_id = int(parts[0])
        last_month_customers[customer_id] = last_month_customers.get(customer_id, 0) + 1

# Find customers who appear in both months
common_customers = set(this_month_customers.keys()) & set(last_month_customers.keys())

# Calculate total transactions and sort by customer ID
results = []
for customer_id in common_customers:
    total_transactions = this_month_customers[customer_id] + last_month_customers[customer_id]
    results.append((customer_id, total_transactions))

results.sort()

# Output
for customer_id, total in results:
    print(customer_id, total)
",0
p00065,"取引
取引先の顧客番号と取引日を月ごとに記録したデータがあります。今月のデータと先月のデータを読み込んで、先月から２ヶ月連続で取引のある会社の顧客番号と取引のあった回数を出力するプログラムを作成してください。ただし、月々の取引先数は 1,000 社以内です。
Input
今月のデータと、先月のデータが１行の空行で区切られて与えられます。それぞれのデータは以下のような形式で与えられます。
c
1
,
d
1
c
2
,
d
2
...
...
c
i
(1 ≤
c
i
≤ 1,000) は顧客番号を表す整数、
d
i
(1 ≤
d
i
≤ 31) は取引日を表す整数です。
Output
２ヶ月連続で取引のある会社について、顧客番号が小さい順に顧客番号と取引回数の総数を空白で区切って出力します。
Sample Input
123,10
56,12
34,14

123,3
56,4
123,5
Output for the Sample Input
56 2
123 3",Python,"import sys
b=0
a=[{},{}]
for e in sys.stdin:
 if'\n'==e:b=1
 else:c=int(e.split(',')[0]);a[b].setdefault(c,0);a[b][c]+=1
for k in sorted({*a[0]}&{*a[1]}):print(k,a[0][k]+a[1][k])
",1
p00067,"島の数
地勢を示す縦 12, 横 12 のマスからなる平面図があります。おのおののマスは白か黒に塗られています。白は海を、黒は陸地を表します。二つの黒いマスが上下、あるいは左右に接しているとき、これらは地続きであるといいます。この平面図では、黒いマス一つのみ、あるいは地続きの黒いマスが作る領域を「島」といいます。例えば下図には、5 つの島があります。
■■■■□□□□■■■■
■■■□□□□□■■■■
■■□□□□□□■■■■
■□□□□□□□■■■■
□□□■□□□■□□□□
□□□□□□■■■□□□
□□□□□■■■■■□□
■□□□■■■■■■■□
■■□□□■■■■■□□
■■■□□□■■■□□□
■■■■□□□■□□□□
□□□□□□□□□□□□
マスのデータを読み込んで、島の数を出力するプログラムを作成してください。
Input
入力は複数のデータセットからなります。各データセットに１つの平面図が与えられます。黒いマスを 1、白いマスを 0 で表現した 12 個の数字の列 12 行でひとつの平面図を表します。データセットの間は１つの空行で区切られています。
データセットの数は 20 を超えません。
Output
データセットごとに、島の数を１行に出力します。
Sample Input
111100001111
111000001111
110000001111
100000001111
000100010000
000000111000
000001111100
100011111110
110001111100
111000111000
111100010000
000000000000

010001111100
110010000010
010010000001
010000000001
010000000110
010000111000
010000000100
010000000010
010000000001
010010000001
010010000010
111001111100

000000000000
111111111111
100010100001
100010100001
100010100001
100010100001
100100100101
101000011101
100000000001
100000000001
111111111111
100000000001
Output for the Sample Input
5
13
4
Hint
以下はサンプルインプットを■と□で表したものです。
■■■■□□□□■■■■　　□■□□□■■■■■□□　　□□□□□□□□□□□□
■■■□□□□□■■■■　　■■□□■□□□□□■□　　■■■■■■■■■■■■
■■□□□□□□■■■■　　□■□□■□□□□□□■　　■□□□■□■□□□□■
■□□□□□□□■■■■　　□■□□□□□□□□□■　　■□□□■□■□□□□■
□□□■□□□■□□□□　　□■□□□□□□□■■□　　■□□□■□■□□□□■
□□□□□□■■■□□□　　□■□□□□■■■□□□　　■□□□■□■□□□□■
□□□□□■■■■■□□　　□■□□□□□□□■□□　　■□□■□□■□□■□■
■□□□■■■■■■■□　　□■□□□□□□□□■□　　■□■□□□□■■■□■
■■□□□■■■■■□□　　□■□□□□□□□□□■　　■□□□□□□□□□□■
■■■□□□■■■□□□　　□■□□■□□□□□□■　　■□□□□□□□□□□■
■■■■□□□■□□□□　　□■□□■□□□□□■□　　■■■■■■■■■■■■
□□□□□□□□□□□□　　■■■□□■■■■■□□　　■□□□□□□□□□□■",C,"#include <stdio.h>
#include <string.h>

int grid[12][12];
int visited[12][12];

void dfs(int i, int j) {
    if (i < 0 || i >= 12 || j < 0 || j >= 12) return;
    if (grid[i][j] == 0 || visited[i][j]) return;
    
    visited[i][j] = 1;
    
    dfs(i-1, j);
    dfs(i+1, j);
    dfs(i, j-1);
    dfs(i, j+1);
}

int main() {
    char line[100];
    
    while (1) {
        int hasInput = 0;
        
        for (int i = 0; i < 12; i++) {
            if (fgets(line, sizeof(line), stdin) == NULL) {
                return 0;
            }
            
            if (strlen(line) > 1 && line[0] != '\n') {
                hasInput = 1;
                for (int j = 0; j < 12; j++) {
                    grid[i][j] = line[j] - '0';
                }
            } else if (strlen(line) <= 1 || line[0] == '\n') {
                if (!hasInput) {
                    i--;
                    continue;
                } else {
                    return 0;
                }
            }
        }
        
        if (!hasInput) break;
        
        memset(visited, 0, sizeof(visited));
        
        int islands = 0;
        for (int i = 0; i < 12; i++) {
            for (int j = 0; j < 12; j++) {
                if (grid[i][j] == 1 && !visited[i][j]) {
                    dfs(i, j);
                    islands++;
                }
            }
        }
        
        printf(""%d\n"", islands);
        
        while (fgets(line, sizeof(line), stdin) != NULL) {
            if (line[0] != '\n' && strlen(line) > 1) {
                fseek(stdin, -(long)strlen(line), SEEK_CUR);
                break;
            }
            if (feof(stdin)) return 0;
        }
        
        if (feof(stdin)) break;
    }
    
    return 0;
}
",0
p00067,"島の数
地勢を示す縦 12, 横 12 のマスからなる平面図があります。おのおののマスは白か黒に塗られています。白は海を、黒は陸地を表します。二つの黒いマスが上下、あるいは左右に接しているとき、これらは地続きであるといいます。この平面図では、黒いマス一つのみ、あるいは地続きの黒いマスが作る領域を「島」といいます。例えば下図には、5 つの島があります。
■■■■□□□□■■■■
■■■□□□□□■■■■
■■□□□□□□■■■■
■□□□□□□□■■■■
□□□■□□□■□□□□
□□□□□□■■■□□□
□□□□□■■■■■□□
■□□□■■■■■■■□
■■□□□■■■■■□□
■■■□□□■■■□□□
■■■■□□□■□□□□
□□□□□□□□□□□□
マスのデータを読み込んで、島の数を出力するプログラムを作成してください。
Input
入力は複数のデータセットからなります。各データセットに１つの平面図が与えられます。黒いマスを 1、白いマスを 0 で表現した 12 個の数字の列 12 行でひとつの平面図を表します。データセットの間は１つの空行で区切られています。
データセットの数は 20 を超えません。
Output
データセットごとに、島の数を１行に出力します。
Sample Input
111100001111
111000001111
110000001111
100000001111
000100010000
000000111000
000001111100
100011111110
110001111100
111000111000
111100010000
000000000000

010001111100
110010000010
010010000001
010000000001
010000000110
010000111000
010000000100
010000000010
010000000001
010010000001
010010000010
111001111100

000000000000
111111111111
100010100001
100010100001
100010100001
100010100001
100100100101
101000011101
100000000001
100000000001
111111111111
100000000001
Output for the Sample Input
5
13
4
Hint
以下はサンプルインプットを■と□で表したものです。
■■■■□□□□■■■■　　□■□□□■■■■■□□　　□□□□□□□□□□□□
■■■□□□□□■■■■　　■■□□■□□□□□■□　　■■■■■■■■■■■■
■■□□□□□□■■■■　　□■□□■□□□□□□■　　■□□□■□■□□□□■
■□□□□□□□■■■■　　□■□□□□□□□□□■　　■□□□■□■□□□□■
□□□■□□□■□□□□　　□■□□□□□□□■■□　　■□□□■□■□□□□■
□□□□□□■■■□□□　　□■□□□□■■■□□□　　■□□□■□■□□□□■
□□□□□■■■■■□□　　□■□□□□□□□■□□　　■□□■□□■□□■□■
■□□□■■■■■■■□　　□■□□□□□□□□■□　　■□■□□□□■■■□■
■■□□□■■■■■□□　　□■□□□□□□□□□■　　■□□□□□□□□□□■
■■■□□□■■■□□□　　□■□□■□□□□□□■　　■□□□□□□□□□□■
■■■■□□□■□□□□　　□■□□■□□□□□■□　　■■■■■■■■■■■■
□□□□□□□□□□□□　　■■■□□■■■■■□□　　■□□□□□□□□□□■",C,"#include <stdio.h>

char map[16][16] = {0};

void delete_island(int x, int y)
{
	if (map[x][y] == 0) return;
	map[x][y] = 0;
	delete_island(x - 1, y);
	delete_island(x + 1, y);
	delete_island(x, y - 1);
	delete_island(x, y + 1);
}

int main(void)
{
	while (scanf(""%s"", &map[0][1]) != EOF){
		int i, j;
		int count = 0;
		
		for (i = 1; i < 12; i++) scanf(""%s"", &map[i][1]);
		for (i = 0; i < 12; i++){
			for (j = 0; j < 12; j++) map[i][j + 1] -= '0';
		}
		
		for (i = 0; i < 12; i++){
			for (j = 0; j < 12; j++){
				if (map[i][j + 1] == 1){
					count++;
					delete_island(i, j + 1);
				}
			}
		}
		printf(""%d\n"", count);
		scanf(""%*c"");
	}
	
	return 0;
}",1
p00067,"島の数
地勢を示す縦 12, 横 12 のマスからなる平面図があります。おのおののマスは白か黒に塗られています。白は海を、黒は陸地を表します。二つの黒いマスが上下、あるいは左右に接しているとき、これらは地続きであるといいます。この平面図では、黒いマス一つのみ、あるいは地続きの黒いマスが作る領域を「島」といいます。例えば下図には、5 つの島があります。
■■■■□□□□■■■■
■■■□□□□□■■■■
■■□□□□□□■■■■
■□□□□□□□■■■■
□□□■□□□■□□□□
□□□□□□■■■□□□
□□□□□■■■■■□□
■□□□■■■■■■■□
■■□□□■■■■■□□
■■■□□□■■■□□□
■■■■□□□■□□□□
□□□□□□□□□□□□
マスのデータを読み込んで、島の数を出力するプログラムを作成してください。
Input
入力は複数のデータセットからなります。各データセットに１つの平面図が与えられます。黒いマスを 1、白いマスを 0 で表現した 12 個の数字の列 12 行でひとつの平面図を表します。データセットの間は１つの空行で区切られています。
データセットの数は 20 を超えません。
Output
データセットごとに、島の数を１行に出力します。
Sample Input
111100001111
111000001111
110000001111
100000001111
000100010000
000000111000
000001111100
100011111110
110001111100
111000111000
111100010000
000000000000

010001111100
110010000010
010010000001
010000000001
010000000110
010000111000
010000000100
010000000010
010000000001
010010000001
010010000010
111001111100

000000000000
111111111111
100010100001
100010100001
100010100001
100010100001
100100100101
101000011101
100000000001
100000000001
111111111111
100000000001
Output for the Sample Input
5
13
4
Hint
以下はサンプルインプットを■と□で表したものです。
■■■■□□□□■■■■　　□■□□□■■■■■□□　　□□□□□□□□□□□□
■■■□□□□□■■■■　　■■□□■□□□□□■□　　■■■■■■■■■■■■
■■□□□□□□■■■■　　□■□□■□□□□□□■　　■□□□■□■□□□□■
■□□□□□□□■■■■　　□■□□□□□□□□□■　　■□□□■□■□□□□■
□□□■□□□■□□□□　　□■□□□□□□□■■□　　■□□□■□■□□□□■
□□□□□□■■■□□□　　□■□□□□■■■□□□　　■□□□■□■□□□□■
□□□□□■■■■■□□　　□■□□□□□□□■□□　　■□□■□□■□□■□■
■□□□■■■■■■■□　　□■□□□□□□□□■□　　■□■□□□□■■■□■
■■□□□■■■■■□□　　□■□□□□□□□□□■　　■□□□□□□□□□□■
■■■□□□■■■□□□　　□■□□■□□□□□□■　　■□□□□□□□□□□■
■■■■□□□■□□□□　　□■□□■□□□□□■□　　■■■■■■■■■■■■
□□□□□□□□□□□□　　■■■□□■■■■■□□　　■□□□□□□□□□□■",Java,"import java.util.*;

public class Main {
    static int[][] grid;
    static boolean[][] visited;
    static int[] dx = {-1, 1, 0, 0};
    static int[] dy = {0, 0, -1, 1};
    
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        
        while (sc.hasNextLine()) {
            grid = new int[12][12];
            visited = new boolean[12][12];
            
            // Read 12 lines for the grid
            boolean validInput = true;
            for (int i = 0; i < 12; i++) {
                if (!sc.hasNextLine()) {
                    validInput = false;
                    break;
                }
                String line = sc.nextLine().trim();
                if (line.isEmpty()) {
                    validInput = false;
                    break;
                }
                for (int j = 0; j < 12 && j < line.length(); j++) {
                    grid[i][j] = line.charAt(j) - '0';
                }
            }
            
            if (!validInput) {
                break;
            }
            
            // Count islands
            int islands = 0;
            for (int i = 0; i < 12; i++) {
                for (int j = 0; j < 12; j++) {
                    if (grid[i][j] == 1 && !visited[i][j]) {
                        dfs(i, j);
                        islands++;
                    }
                }
            }
            
            System.out.println(islands);
            
            // Skip empty line between datasets
            if (sc.hasNextLine()) {
                String line = sc.nextLine();
                // If the line is not empty, we need to check if it's the start of next dataset
                if (!line.trim().isEmpty()) {
                    // This is the first line of next dataset
                    grid = new int[12][12];
                    visited = new boolean[12][12];
                    
                    // Process this first line
                    for (int j = 0; j < 12 && j < line.length(); j++) {
                        grid[0][j] = line.charAt(j) - '0';
                    }
                    
                    // Read remaining 11 lines
                    for (int i = 1; i < 12; i++) {
                        if (!sc.hasNextLine()) break;
                        line = sc.nextLine().trim();
                        if (line.isEmpty()) break;
                        for (int j = 0; j < 12 && j < line.length(); j++) {
                            grid[i][j] = line.charAt(j) - '0';
                        }
                    }
                    
                    // Count islands
                    islands = 0;
                    for (int i = 0; i < 12; i++) {
                        for (int j = 0; j < 12; j++) {
                            if (grid[i][j] == 1 && !visited[i][j]) {
                                dfs(i, j);
                                islands++;
                            }
                        }
                    }
                    
                    System.out.println(islands);
                    
                    // Skip empty line
                    if (sc.hasNextLine()) {
                        sc.nextLine();
                    }
                }
            }
        }
        
        sc.close();
    }
    
    static void dfs(int x, int y) {
        visited[x][y] = true;
        
        for (int i = 0; i < 4; i++) {
            int nx = x + dx[i];
            int ny = y + dy[i];
            
            if (nx >= 0 && nx < 12 && ny >= 0 && ny < 12 && 
                grid[nx][ny] == 1 && !visited[nx][ny]) {
                dfs(nx, ny);
            }
        }
    }
}
",0
p00067,"島の数
地勢を示す縦 12, 横 12 のマスからなる平面図があります。おのおののマスは白か黒に塗られています。白は海を、黒は陸地を表します。二つの黒いマスが上下、あるいは左右に接しているとき、これらは地続きであるといいます。この平面図では、黒いマス一つのみ、あるいは地続きの黒いマスが作る領域を「島」といいます。例えば下図には、5 つの島があります。
■■■■□□□□■■■■
■■■□□□□□■■■■
■■□□□□□□■■■■
■□□□□□□□■■■■
□□□■□□□■□□□□
□□□□□□■■■□□□
□□□□□■■■■■□□
■□□□■■■■■■■□
■■□□□■■■■■□□
■■■□□□■■■□□□
■■■■□□□■□□□□
□□□□□□□□□□□□
マスのデータを読み込んで、島の数を出力するプログラムを作成してください。
Input
入力は複数のデータセットからなります。各データセットに１つの平面図が与えられます。黒いマスを 1、白いマスを 0 で表現した 12 個の数字の列 12 行でひとつの平面図を表します。データセットの間は１つの空行で区切られています。
データセットの数は 20 を超えません。
Output
データセットごとに、島の数を１行に出力します。
Sample Input
111100001111
111000001111
110000001111
100000001111
000100010000
000000111000
000001111100
100011111110
110001111100
111000111000
111100010000
000000000000

010001111100
110010000010
010010000001
010000000001
010000000110
010000111000
010000000100
010000000010
010000000001
010010000001
010010000010
111001111100

000000000000
111111111111
100010100001
100010100001
100010100001
100010100001
100100100101
101000011101
100000000001
100000000001
111111111111
100000000001
Output for the Sample Input
5
13
4
Hint
以下はサンプルインプットを■と□で表したものです。
■■■■□□□□■■■■　　□■□□□■■■■■□□　　□□□□□□□□□□□□
■■■□□□□□■■■■　　■■□□■□□□□□■□　　■■■■■■■■■■■■
■■□□□□□□■■■■　　□■□□■□□□□□□■　　■□□□■□■□□□□■
■□□□□□□□■■■■　　□■□□□□□□□□□■　　■□□□■□■□□□□■
□□□■□□□■□□□□　　□■□□□□□□□■■□　　■□□□■□■□□□□■
□□□□□□■■■□□□　　□■□□□□■■■□□□　　■□□□■□■□□□□■
□□□□□■■■■■□□　　□■□□□□□□□■□□　　■□□■□□■□□■□■
■□□□■■■■■■■□　　□■□□□□□□□□■□　　■□■□□□□■■■□■
■■□□□■■■■■□□　　□■□□□□□□□□□■　　■□□□□□□□□□□■
■■■□□□■■■□□□　　□■□□■□□□□□□■　　■□□□□□□□□□□■
■■■■□□□■□□□□　　□■□□■□□□□□■□　　■■■■■■■■■■■■
□□□□□□□□□□□□　　■■■□□■■■■■□□　　■□□□□□□□□□□■",Java,"import java.util.Scanner;

public class Main {

	public static void main(String[] args) {
		// TODO 自動生成されたメソッド・スタブ
		new Main().run();
	}
	
	int filed[][]=new int[12][12];
	void run(){
		Scanner sc=new Scanner(System.in);
		while(sc.hasNext()){
			int count=0;
			
			for(int i=0;i<12;i++){
				char ch[]=sc.next().toCharArray();
				for(int j=0;j<12;j++){
					filed[i][j]=ch[j]-'0';
				}
			}
			
			for(int i=0;i<12;i++){
				for(int j=0;j<12;j++){
					if(filed[i][j]==1){
						count++;
						dfs(j,i,12,12);
					}
				}
			}
			System.out.println(count);
		}
	}
	
    int mx[]={-1,0,1,0};
    int my[]={0,-1,0,1};
	void dfs(int x,int y,int w,int h){
        int i,nx,ny;
        for(i=0;i<4;i++){
            nx=x+mx[i];
            ny=y+my[i];
            if(0<=nx && nx<w && 0<=ny && ny<h && filed[ny][nx]!=0){
                filed[ny][nx]=0;
                dfs(nx,ny,w,h);
            }
        }
    }

}",1
p00067,"島の数
地勢を示す縦 12, 横 12 のマスからなる平面図があります。おのおののマスは白か黒に塗られています。白は海を、黒は陸地を表します。二つの黒いマスが上下、あるいは左右に接しているとき、これらは地続きであるといいます。この平面図では、黒いマス一つのみ、あるいは地続きの黒いマスが作る領域を「島」といいます。例えば下図には、5 つの島があります。
■■■■□□□□■■■■
■■■□□□□□■■■■
■■□□□□□□■■■■
■□□□□□□□■■■■
□□□■□□□■□□□□
□□□□□□■■■□□□
□□□□□■■■■■□□
■□□□■■■■■■■□
■■□□□■■■■■□□
■■■□□□■■■□□□
■■■■□□□■□□□□
□□□□□□□□□□□□
マスのデータを読み込んで、島の数を出力するプログラムを作成してください。
Input
入力は複数のデータセットからなります。各データセットに１つの平面図が与えられます。黒いマスを 1、白いマスを 0 で表現した 12 個の数字の列 12 行でひとつの平面図を表します。データセットの間は１つの空行で区切られています。
データセットの数は 20 を超えません。
Output
データセットごとに、島の数を１行に出力します。
Sample Input
111100001111
111000001111
110000001111
100000001111
000100010000
000000111000
000001111100
100011111110
110001111100
111000111000
111100010000
000000000000

010001111100
110010000010
010010000001
010000000001
010000000110
010000111000
010000000100
010000000010
010000000001
010010000001
010010000010
111001111100

000000000000
111111111111
100010100001
100010100001
100010100001
100010100001
100100100101
101000011101
100000000001
100000000001
111111111111
100000000001
Output for the Sample Input
5
13
4
Hint
以下はサンプルインプットを■と□で表したものです。
■■■■□□□□■■■■　　□■□□□■■■■■□□　　□□□□□□□□□□□□
■■■□□□□□■■■■　　■■□□■□□□□□■□　　■■■■■■■■■■■■
■■□□□□□□■■■■　　□■□□■□□□□□□■　　■□□□■□■□□□□■
■□□□□□□□■■■■　　□■□□□□□□□□□■　　■□□□■□■□□□□■
□□□■□□□■□□□□　　□■□□□□□□□■■□　　■□□□■□■□□□□■
□□□□□□■■■□□□　　□■□□□□■■■□□□　　■□□□■□■□□□□■
□□□□□■■■■■□□　　□■□□□□□□□■□□　　■□□■□□■□□■□■
■□□□■■■■■■■□　　□■□□□□□□□□■□　　■□■□□□□■■■□■
■■□□□■■■■■□□　　□■□□□□□□□□□■　　■□□□□□□□□□□■
■■■□□□■■■□□□　　□■□□■□□□□□□■　　■□□□□□□□□□□■
■■■■□□□■□□□□　　□■□□■□□□□□■□　　■■■■■■■■■■■■
□□□□□□□□□□□□　　■■■□□■■■■■□□　　■□□□□□□□□□□■",Python,"import sys
from collections import deque

def count_islands(grid):
    rows = 12
    cols = 12
    visited = [[False] * cols for _ in range(rows)]
    count = 0
    
    def bfs(start_r, start_c):
        queue = deque([(start_r, start_c)])
        visited[start_r][start_c] = True
        
        while queue:
            r, c = queue.popleft()
            # Check 4 directions: up, down, left, right
            for dr, dc in [(-1, 0), (1, 0), (0, -1), (0, 1)]:
                nr, nc = r + dr, c + dc
                if 0 <= nr < rows and 0 <= nc < cols and not visited[nr][nc] and grid[nr][nc] == 1:
                    visited[nr][nc] = True
                    queue.append((nr, nc))
    
    for i in range(rows):
        for j in range(cols):
            if grid[i][j] == 1 and not visited[i][j]:
                bfs(i, j)
                count += 1
    
    return count

def main():
    lines = []
    for line in sys.stdin:
        lines.append(line.rstrip('\n'))
    
    datasets = []
    current_dataset = []
    
    for line in lines:
        if line == '':
            if current_dataset:
                datasets.append(current_dataset)
                current_dataset = []
        else:
            current_dataset.append(line)
    
    if current_dataset:
        datasets.append(current_dataset)
    
    for dataset in datasets:
        grid = []
        for line in dataset:
            row = [int(c) for c in line]
            grid.append(row)
        
        result = count_islands(grid)
        print(result)

if __name__ == ""__main__"":
    main()
",0
p00067,"島の数
地勢を示す縦 12, 横 12 のマスからなる平面図があります。おのおののマスは白か黒に塗られています。白は海を、黒は陸地を表します。二つの黒いマスが上下、あるいは左右に接しているとき、これらは地続きであるといいます。この平面図では、黒いマス一つのみ、あるいは地続きの黒いマスが作る領域を「島」といいます。例えば下図には、5 つの島があります。
■■■■□□□□■■■■
■■■□□□□□■■■■
■■□□□□□□■■■■
■□□□□□□□■■■■
□□□■□□□■□□□□
□□□□□□■■■□□□
□□□□□■■■■■□□
■□□□■■■■■■■□
■■□□□■■■■■□□
■■■□□□■■■□□□
■■■■□□□■□□□□
□□□□□□□□□□□□
マスのデータを読み込んで、島の数を出力するプログラムを作成してください。
Input
入力は複数のデータセットからなります。各データセットに１つの平面図が与えられます。黒いマスを 1、白いマスを 0 で表現した 12 個の数字の列 12 行でひとつの平面図を表します。データセットの間は１つの空行で区切られています。
データセットの数は 20 を超えません。
Output
データセットごとに、島の数を１行に出力します。
Sample Input
111100001111
111000001111
110000001111
100000001111
000100010000
000000111000
000001111100
100011111110
110001111100
111000111000
111100010000
000000000000

010001111100
110010000010
010010000001
010000000001
010000000110
010000111000
010000000100
010000000010
010000000001
010010000001
010010000010
111001111100

000000000000
111111111111
100010100001
100010100001
100010100001
100010100001
100100100101
101000011101
100000000001
100000000001
111111111111
100000000001
Output for the Sample Input
5
13
4
Hint
以下はサンプルインプットを■と□で表したものです。
■■■■□□□□■■■■　　□■□□□■■■■■□□　　□□□□□□□□□□□□
■■■□□□□□■■■■　　■■□□■□□□□□■□　　■■■■■■■■■■■■
■■□□□□□□■■■■　　□■□□■□□□□□□■　　■□□□■□■□□□□■
■□□□□□□□■■■■　　□■□□□□□□□□□■　　■□□□■□■□□□□■
□□□■□□□■□□□□　　□■□□□□□□□■■□　　■□□□■□■□□□□■
□□□□□□■■■□□□　　□■□□□□■■■□□□　　■□□□■□■□□□□■
□□□□□■■■■■□□　　□■□□□□□□□■□□　　■□□■□□■□□■□■
■□□□■■■■■■■□　　□■□□□□□□□□■□　　■□■□□□□■■■□■
■■□□□■■■■■□□　　□■□□□□□□□□□■　　■□□□□□□□□□□■
■■■□□□■■■□□□　　□■□□■□□□□□□■　　■□□□□□□□□□□■
■■■■□□□■□□□□　　□■□□■□□□□□■□　　■■■■■■■■■■■■
□□□□□□□□□□□□　　■■■□□■■■■■□□　　■□□□□□□□□□□■",Python,"class Depth_First_Search_stack:
    def __init__(self, map):
        self.map = map
        self.num_island = 0
        self.stack = []
        self.start_point = None

    def get_start_point(self):
        get_start = False
        for i in range(12):
            for j in range(12):
                if self.map[i][j] == '1':
                    self.start_point = [i, j]
                    get_start = True
        return get_start

    def check(self, new_r, new_c):
        return 0<=new_r<12 and 0<=new_c<12 and self.map[new_r][new_c] == '1'

    def search(self, r, c):
        while self.stack:
            r, c = self.stack.pop()
            self.map[r][c] = '0'
            for (i, j) in [[1, 0], [0, 1], [-1, 0], [0, -1]]:
                if self.check(r+i, c+j):
                    self.stack.append([r+i, c+j])

    def run(self):
        while self.get_start_point():
            r, c = self.start_point
            self.stack.append([r, c])
            self.search(r, c)
            self.num_island += 1

if __name__ == '__main__':
    while 1:
        map = []
        for i in range(12):
            row = [x for x in input()]
            map.append(row)

        if len(map[0]) != 12:
            break

        DFS = Depth_First_Search_stack(map)
        DFS.run()
        print(DFS.num_island)

        empty = input()",1
p00068,"輪ゴム
n
本の釘を平板上の座標
P
1
(
x
1
,
y
1
),
P
2
(
x
2
,
y
2
),
P
3
(
x
3
,
y
3
),...,
P
n
(
x
n
,
y
n
) に１本ずつ打ち、輪ゴムの輪の中に全ての釘が入るように 1 本の輪ゴムで囲みます。このとき、輪ゴムが交差してはいけません。
釘の座標を読み込んで、上記のように釘を輪ゴムで囲んだときに輪ゴムに接していない釘の本数を出力するプログラムを作成してください。輪ゴムは充分に伸び縮みするものとします。同じ座標に 2 本以上の釘を打つことはないものとします。また、輪ゴムがかかった釘と釘の間は直線で結ばれるものとし、その直線上に 3 本以上の釘が並ぶことはないものとします。例えば、図 1 に示すような入力はありえません。図 2 に示すように輪ゴムがかかっていない釘が 1 直線上に並ぶことはありえます。
図１
図２
ただし、それぞれの座標値は -1000.0 以上1000.0 以下の実数です。また、
n
は 3 以上 100 以下の整数です。
Input
複数のデータセットが与えられます。各データセットは以下のような形式です与えられます。
n
x
1
,
y
1
x
2
,
y
2
... 　　　　
...
x
n
,
y
n
n
が 0 の時、入力の最後を示します。データセットの数は 50 を超えません。
Output
データセットごとに、ゴムと接していない釘の本数を出力してください。

例えば、図 3 に示す４つの釘を表す入力があった場合、図 4 のように囲まれるので、輪ゴムに接していない釘の本数は 1 本です。
図３
図４
Sample Input
4
1.0,0.0
0.0,1.0
2.0,1.0
1.0,2.0
9
-509.94,892.63
567.62,639.99
-859.32,-64.84
-445.99,383.69
667.54,430.49
551.12,828.21
-940.2,-877.2
-361.62,-970
-125.42,-178.48
0
Output for the Sample Input
0
3
Hint
以下は２つめのサンプル入力に対する図です。",C,"#include <stdio.h>
#include <math.h>

typedef struct {
    double x, y;
} Point;

double cross(Point O, Point A, Point B) {
    return (A.x - O.x) * (B.y - O.y) - (A.y - O.y) * (B.x - O.x);
}

int convexHull(Point points[], int n, int hull[]) {
    int k = 0;
    
    // Find bottommost point (or leftmost in case of tie)
    int minIdx = 0;
    for (int i = 1; i < n; i++) {
        if (points[i].y < points[minIdx].y || 
            (points[i].y == points[minIdx].y && points[i].x < points[minIdx].x)) {
            minIdx = i;
        }
    }
    
    // Start from bottommost point
    int current = minIdx;
    do {
        hull[k++] = current;
        int next = 0;
        for (int i = 0; i < n; i++) {
            if (i == current) continue;
            
            if (next == current) {
                next = i;
            } else {
                double cp = cross(points[current], points[next], points[i]);
                if (cp < 0 || (cp == 0 && 
                    (pow(points[i].x - points[current].x, 2) + pow(points[i].y - points[current].y, 2)) >
                    (pow(points[next].x - points[current].x, 2) + pow(points[next].y - points[current].y, 2)))) {
                    next = i;
                }
            }
        }
        current = next;
    } while (current != minIdx);
    
    return k;
}

int main() {
    int n;
    while (scanf(""%d"", &n) == 1 && n != 0) {
        Point points[100];
        for (int i = 0; i < n; i++) {
            scanf(""%lf,%lf"", &points[i].x, &points[i].y);
        }
        
        if (n == 3) {
            printf(""0\n"");
            continue;
        }
        
        int hull[100];
        int hullSize = convexHull(points, n, hull);
        
        printf(""%d\n"", n - hullSize);
    }
    
    return 0;
}
",0
p00068,"輪ゴム
n
本の釘を平板上の座標
P
1
(
x
1
,
y
1
),
P
2
(
x
2
,
y
2
),
P
3
(
x
3
,
y
3
),...,
P
n
(
x
n
,
y
n
) に１本ずつ打ち、輪ゴムの輪の中に全ての釘が入るように 1 本の輪ゴムで囲みます。このとき、輪ゴムが交差してはいけません。
釘の座標を読み込んで、上記のように釘を輪ゴムで囲んだときに輪ゴムに接していない釘の本数を出力するプログラムを作成してください。輪ゴムは充分に伸び縮みするものとします。同じ座標に 2 本以上の釘を打つことはないものとします。また、輪ゴムがかかった釘と釘の間は直線で結ばれるものとし、その直線上に 3 本以上の釘が並ぶことはないものとします。例えば、図 1 に示すような入力はありえません。図 2 に示すように輪ゴムがかかっていない釘が 1 直線上に並ぶことはありえます。
図１
図２
ただし、それぞれの座標値は -1000.0 以上1000.0 以下の実数です。また、
n
は 3 以上 100 以下の整数です。
Input
複数のデータセットが与えられます。各データセットは以下のような形式です与えられます。
n
x
1
,
y
1
x
2
,
y
2
... 　　　　
...
x
n
,
y
n
n
が 0 の時、入力の最後を示します。データセットの数は 50 を超えません。
Output
データセットごとに、ゴムと接していない釘の本数を出力してください。

例えば、図 3 に示す４つの釘を表す入力があった場合、図 4 のように囲まれるので、輪ゴムに接していない釘の本数は 1 本です。
図３
図４
Sample Input
4
1.0,0.0
0.0,1.0
2.0,1.0
1.0,2.0
9
-509.94,892.63
567.62,639.99
-859.32,-64.84
-445.99,383.69
667.54,430.49
551.12,828.21
-940.2,-877.2
-361.62,-970
-125.42,-178.48
0
Output for the Sample Input
0
3
Hint
以下は２つめのサンプル入力に対する図です。",C,"#include <stdio.h>
#include <stdlib.h>

typedef struct {
	double x,y;
} xy_t;

int qsort_comp(const void* x,const void* y) {
	const xy_t* a=(const xy_t*)x;
	const xy_t* b=(const xy_t*)y;
	if((a->x)>(b->x))return 1;
	if((a->x)<(b->x))return -1;
	if((a->y)>(b->y))return 1;
	if((a->y)<(b->y))return -1;
	return 0;
}

int zahyou_num;
xy_t zahyou[100];

int th_up_n;
int th_down_n;
xy_t th_up[100];
xy_t th_down[100];

int main(void) {
	int i;
	while(1) {
		scanf(""%d"",&zahyou_num);
		if(zahyou_num==0)break;
		for(i=0;i<zahyou_num;i++) {
			scanf(""%lf,%lf"",&zahyou[i].x,&zahyou[i].y);
		}
		qsort(zahyou,zahyou_num,sizeof(xy_t),qsort_comp);
		//sita no totu-ho
		th_down_n=1;
		th_down[0].x=zahyou[0].x;
		th_down[0].y=zahyou[0].y;
		for(i=1;i<zahyou_num;i++) {
			//if(zahyou[i].y<th_down[th_down_n-1].y) {
				while(th_down_n>1) {
					double k1,k2;
					if(zahyou[i].x==th_down[th_down_n-1].x) {
						//INF
						if(zahyou[i].y<th_down[th_down_n-1].y) {
							k1=-1e+200;
						} else if(zahyou[i].y>th_down[th_down_n-1].y) {
							k1=1e+200;
						} else k1=0;
					} else {
						k1=(zahyou[i].y-th_down[th_down_n-1].y)/
						   (zahyou[i].x-th_down[th_down_n-1].x);
					}
					if(th_down[th_down_n-1].x==th_down[th_down_n-2].x) {
						//INF
						if(th_down[th_down_n-1].y<th_down[th_down_n-2].y) {
							k2=-1e+200;
						} else if(th_down[th_down_n-1].y>th_down[th_down_n-2].y) {
							k2=1e+200;
						} else k2=0;
					} else {
						k2=(th_down[th_down_n-1].y-th_down[th_down_n-2].y)/
						   (th_down[th_down_n-1].x-th_down[th_down_n-2].x);
					}
					if(k1>=k2)break;
					th_down_n--;
				}
			//}
			th_down[th_down_n].x=zahyou[i].x;
			th_down[th_down_n].y=zahyou[i].y;
			th_down_n++;
		}
		//ue no totu-ho
		th_up_n=1;
		th_up[0].x=zahyou[zahyou_num-1].x;
		th_up[0].y=zahyou[zahyou_num-1].y;
		for(i=zahyou_num-2;i>=0;i--) {
			//if(zahyou[i].y>th_up[th_up_n-1].y) {
				while(th_up_n>1) {
					double k1,k2;
					if(zahyou[i].x==th_up[th_up_n-1].x) {
						//INF
						if(zahyou[i].y<th_up[th_up_n-1].y) {
							k1=1e+200;
						} else if(zahyou[i].y>th_up[th_up_n-1].y) {
							k1=-1e+200;
						} else k1=0;
					} else {
						k1=(zahyou[i].y-th_up[th_up_n-1].y)/
						   (zahyou[i].x-th_up[th_up_n-1].x);
					}
					if(th_up[th_up_n-1].x==th_up[th_up_n-2].x) {
						//INF
						if(th_up[th_up_n-1].y<th_up[th_up_n-2].y) {
							k2=1e+200;
						} else if(th_up[th_up_n-1].y>th_up[th_up_n-2].y) {
							k2=-1e+200;
						} else k2=0;
					} else {
						k2=(th_up[th_up_n-1].y-th_up[th_up_n-2].y)/
						   (th_up[th_up_n-1].x-th_up[th_up_n-2].x);
					}
					if(k1>=k2)break;
					th_up_n--;
				}
			//}
			th_up[th_up_n].x=zahyou[i].x;
			th_up[th_up_n].y=zahyou[i].y;
			th_up_n++;
		}
		printf(""%d\n"",zahyou_num-(th_down_n+th_up_n-2));
	}
	return 0;
}",1
p00068,"輪ゴム
n
本の釘を平板上の座標
P
1
(
x
1
,
y
1
),
P
2
(
x
2
,
y
2
),
P
3
(
x
3
,
y
3
),...,
P
n
(
x
n
,
y
n
) に１本ずつ打ち、輪ゴムの輪の中に全ての釘が入るように 1 本の輪ゴムで囲みます。このとき、輪ゴムが交差してはいけません。
釘の座標を読み込んで、上記のように釘を輪ゴムで囲んだときに輪ゴムに接していない釘の本数を出力するプログラムを作成してください。輪ゴムは充分に伸び縮みするものとします。同じ座標に 2 本以上の釘を打つことはないものとします。また、輪ゴムがかかった釘と釘の間は直線で結ばれるものとし、その直線上に 3 本以上の釘が並ぶことはないものとします。例えば、図 1 に示すような入力はありえません。図 2 に示すように輪ゴムがかかっていない釘が 1 直線上に並ぶことはありえます。
図１
図２
ただし、それぞれの座標値は -1000.0 以上1000.0 以下の実数です。また、
n
は 3 以上 100 以下の整数です。
Input
複数のデータセットが与えられます。各データセットは以下のような形式です与えられます。
n
x
1
,
y
1
x
2
,
y
2
... 　　　　
...
x
n
,
y
n
n
が 0 の時、入力の最後を示します。データセットの数は 50 を超えません。
Output
データセットごとに、ゴムと接していない釘の本数を出力してください。

例えば、図 3 に示す４つの釘を表す入力があった場合、図 4 のように囲まれるので、輪ゴムに接していない釘の本数は 1 本です。
図３
図４
Sample Input
4
1.0,0.0
0.0,1.0
2.0,1.0
1.0,2.0
9
-509.94,892.63
567.62,639.99
-859.32,-64.84
-445.99,383.69
667.54,430.49
551.12,828.21
-940.2,-877.2
-361.62,-970
-125.42,-178.48
0
Output for the Sample Input
0
3
Hint
以下は２つめのサンプル入力に対する図です。",Java,"import java.util.*;
import java.io.*;

public class Main {
    static class Point {
        double x, y;
        Point(double x, double y) {
            this.x = x;
            this.y = y;
        }
    }
    
    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        String line;
        
        while ((line = br.readLine()) != null) {
            int n = Integer.parseInt(line.trim());
            if (n == 0) break;
            
            Point[] points = new Point[n];
            for (int i = 0; i < n; i++) {
                String[] parts = br.readLine().trim().split("","");
                double x = Double.parseDouble(parts[0]);
                double y = Double.parseDouble(parts[1]);
                points[i] = new Point(x, y);
            }
            
            List<Integer> hull = convexHull(points);
            System.out.println(n - hull.size());
        }
    }
    
    static List<Integer> convexHull(Point[] points) {
        int n = points.length;
        if (n < 3) {
            List<Integer> result = new ArrayList<>();
            for (int i = 0; i < n; i++) result.add(i);
            return result;
        }
        
        // Find the bottommost point (or leftmost in case of tie)
        int start = 0;
        for (int i = 1; i < n; i++) {
            if (points[i].y < points[start].y || 
                (points[i].y == points[start].y && points[i].x < points[start].x)) {
                start = i;
            }
        }
        
        List<Integer> hull = new ArrayList<>();
        int current = start;
        
        do {
            hull.add(current);
            int next = (current + 1) % n;
            
            for (int i = 0; i < n; i++) {
                if (i == current) continue;
                double cross = crossProduct(points[current], points[next], points[i]);
                if (cross > 0) {
                    next = i;
                } else if (cross == 0) {
                    // Collinear points - choose the farthest one
                    if (distance(points[current], points[i]) > distance(points[current], points[next])) {
                        next = i;
                    }
                }
            }
            
            current = next;
        } while (current != start);
        
        return hull;
    }
    
    static double crossProduct(Point o, Point a, Point b) {
        return (a.x - o.x) * (b.y - o.y) - (a.y - o.y) * (b.x - o.x);
    }
    
    static double distance(Point a, Point b) {
        double dx = a.x - b.x;
        double dy = a.y - b.y;
        return dx * dx + dy * dy;
    }
}
",0
p00068,"輪ゴム
n
本の釘を平板上の座標
P
1
(
x
1
,
y
1
),
P
2
(
x
2
,
y
2
),
P
3
(
x
3
,
y
3
),...,
P
n
(
x
n
,
y
n
) に１本ずつ打ち、輪ゴムの輪の中に全ての釘が入るように 1 本の輪ゴムで囲みます。このとき、輪ゴムが交差してはいけません。
釘の座標を読み込んで、上記のように釘を輪ゴムで囲んだときに輪ゴムに接していない釘の本数を出力するプログラムを作成してください。輪ゴムは充分に伸び縮みするものとします。同じ座標に 2 本以上の釘を打つことはないものとします。また、輪ゴムがかかった釘と釘の間は直線で結ばれるものとし、その直線上に 3 本以上の釘が並ぶことはないものとします。例えば、図 1 に示すような入力はありえません。図 2 に示すように輪ゴムがかかっていない釘が 1 直線上に並ぶことはありえます。
図１
図２
ただし、それぞれの座標値は -1000.0 以上1000.0 以下の実数です。また、
n
は 3 以上 100 以下の整数です。
Input
複数のデータセットが与えられます。各データセットは以下のような形式です与えられます。
n
x
1
,
y
1
x
2
,
y
2
... 　　　　
...
x
n
,
y
n
n
が 0 の時、入力の最後を示します。データセットの数は 50 を超えません。
Output
データセットごとに、ゴムと接していない釘の本数を出力してください。

例えば、図 3 に示す４つの釘を表す入力があった場合、図 4 のように囲まれるので、輪ゴムに接していない釘の本数は 1 本です。
図３
図４
Sample Input
4
1.0,0.0
0.0,1.0
2.0,1.0
1.0,2.0
9
-509.94,892.63
567.62,639.99
-859.32,-64.84
-445.99,383.69
667.54,430.49
551.12,828.21
-940.2,-877.2
-361.62,-970
-125.42,-178.48
0
Output for the Sample Input
0
3
Hint
以下は２つめのサンプル入力に対する図です。",Java,"import java.util.Scanner;

public class Main {
	
	Scanner sc;
	
	class Point{
		public double x,y;
		
		public String toString(){
			return ""(""+x+"",""+y+"")"";
		}
		
		public Point(double x,double y){
			this.x=x;
			this.y=y;
		}
	}
	
	double getTheta(Point p,Point p0){
		double theta=Math.acos((p.x-p0.x)/Math.hypot(p.x-p0.x,p.y-p0.y));
		if(p.y<p0.y)theta=Math.PI*2-theta;
		return theta;
	}
	
	int solve(Point[] points){
		Point start=points[0];
		for(Point v:points){
			if(v.y<start.y)start=v;
		}
		Point p0=start;
		int n=0;
		double prev=0;
		do{
			double min=Math.PI*3;
			Point next=p0;
			for(Point p: points){
				double theta=getTheta(p,p0);
				if(theta>=prev&&theta<min){
					min=theta;
					next=p;
				}
			}
			p0=next;
			prev=min;
			++n;
		}while(p0!=start);
		return points.length-n;
	}
	
	double nd(){
		return sc.nextDouble();
	}
	
	int ni(){
		return sc.nextInt();
	}
	
	void io(){
		sc=new Scanner(System.in).useDelimiter("",|\r\n|\n"");
		
		int n;
		Point[] points;
		while((n=ni())!=0){
			points=new Point[n];
			for(int i=0;i<n;++i){
				points[i]=new Point(nd(),nd());
			}
			System.out.println(solve(points));
		}
		sc.close();
	}
	
	public static void main(String[] args) {
		// TODO Auto-generated method stub
		new Main().io();
	}
}",1
p00068,"輪ゴム
n
本の釘を平板上の座標
P
1
(
x
1
,
y
1
),
P
2
(
x
2
,
y
2
),
P
3
(
x
3
,
y
3
),...,
P
n
(
x
n
,
y
n
) に１本ずつ打ち、輪ゴムの輪の中に全ての釘が入るように 1 本の輪ゴムで囲みます。このとき、輪ゴムが交差してはいけません。
釘の座標を読み込んで、上記のように釘を輪ゴムで囲んだときに輪ゴムに接していない釘の本数を出力するプログラムを作成してください。輪ゴムは充分に伸び縮みするものとします。同じ座標に 2 本以上の釘を打つことはないものとします。また、輪ゴムがかかった釘と釘の間は直線で結ばれるものとし、その直線上に 3 本以上の釘が並ぶことはないものとします。例えば、図 1 に示すような入力はありえません。図 2 に示すように輪ゴムがかかっていない釘が 1 直線上に並ぶことはありえます。
図１
図２
ただし、それぞれの座標値は -1000.0 以上1000.0 以下の実数です。また、
n
は 3 以上 100 以下の整数です。
Input
複数のデータセットが与えられます。各データセットは以下のような形式です与えられます。
n
x
1
,
y
1
x
2
,
y
2
... 　　　　
...
x
n
,
y
n
n
が 0 の時、入力の最後を示します。データセットの数は 50 を超えません。
Output
データセットごとに、ゴムと接していない釘の本数を出力してください。

例えば、図 3 に示す４つの釘を表す入力があった場合、図 4 のように囲まれるので、輪ゴムに接していない釘の本数は 1 本です。
図３
図４
Sample Input
4
1.0,0.0
0.0,1.0
2.0,1.0
1.0,2.0
9
-509.94,892.63
567.62,639.99
-859.32,-64.84
-445.99,383.69
667.54,430.49
551.12,828.21
-940.2,-877.2
-361.62,-970
-125.42,-178.48
0
Output for the Sample Input
0
3
Hint
以下は２つめのサンプル入力に対する図です。",Python,"def cross(o, a, b):
    return (a[0] - o[0]) * (b[1] - o[1]) - (a[1] - o[1]) * (b[0] - o[0])

def convex_hull(points):
    points = sorted(points)
    if len(points) <= 1:
        return points
    
    lower = []
    for p in points:
        while len(lower) >= 2 and cross(lower[-2], lower[-1], p) <= 0:
            lower.pop()
        lower.append(p)
    
    upper = []
    for p in reversed(points):
        while len(upper) >= 2 and cross(upper[-2], upper[-1], p) <= 0:
            upper.pop()
        upper.append(p)
    
    return lower[:-1] + upper[:-1]

while True:
    n = int(input())
    if n == 0:
        break
    
    points = []
    for _ in range(n):
        line = input().strip()
        x, y = map(float, line.split(','))
        points.append((x, y))
    
    hull = convex_hull(points)
    hull_set = set(hull)
    
    count = 0
    for p in points:
        if p not in hull_set:
            count += 1
    
    print(count)
",0
p00068,"輪ゴム
n
本の釘を平板上の座標
P
1
(
x
1
,
y
1
),
P
2
(
x
2
,
y
2
),
P
3
(
x
3
,
y
3
),...,
P
n
(
x
n
,
y
n
) に１本ずつ打ち、輪ゴムの輪の中に全ての釘が入るように 1 本の輪ゴムで囲みます。このとき、輪ゴムが交差してはいけません。
釘の座標を読み込んで、上記のように釘を輪ゴムで囲んだときに輪ゴムに接していない釘の本数を出力するプログラムを作成してください。輪ゴムは充分に伸び縮みするものとします。同じ座標に 2 本以上の釘を打つことはないものとします。また、輪ゴムがかかった釘と釘の間は直線で結ばれるものとし、その直線上に 3 本以上の釘が並ぶことはないものとします。例えば、図 1 に示すような入力はありえません。図 2 に示すように輪ゴムがかかっていない釘が 1 直線上に並ぶことはありえます。
図１
図２
ただし、それぞれの座標値は -1000.0 以上1000.0 以下の実数です。また、
n
は 3 以上 100 以下の整数です。
Input
複数のデータセットが与えられます。各データセットは以下のような形式です与えられます。
n
x
1
,
y
1
x
2
,
y
2
... 　　　　
...
x
n
,
y
n
n
が 0 の時、入力の最後を示します。データセットの数は 50 を超えません。
Output
データセットごとに、ゴムと接していない釘の本数を出力してください。

例えば、図 3 に示す４つの釘を表す入力があった場合、図 4 のように囲まれるので、輪ゴムに接していない釘の本数は 1 本です。
図３
図４
Sample Input
4
1.0,0.0
0.0,1.0
2.0,1.0
1.0,2.0
9
-509.94,892.63
567.62,639.99
-859.32,-64.84
-445.99,383.69
667.54,430.49
551.12,828.21
-940.2,-877.2
-361.62,-970
-125.42,-178.48
0
Output for the Sample Input
0
3
Hint
以下は２つめのサンプル入力に対する図です。",Python,"def f(x,y,x1,y1,x2,y2):
    if x1 <= x2:
        return (x2-x1)*y-(y2-y1)*x+x1*y2-x2*y1
    else:
        return -((x2-x1)*y-(y2-y1)*x+x1*y2-x2*y1)

def DC(a):
    if len(a) > 3:
        # Divide
        la = a[:len(a)/2]
        ra = a[len(a)/2:]
        # Conquer
        la,ra = DC(la),DC(ra)
        while f(ra[1][0],ra[1][1],la[-1][0],la[-1][1],ra[0][0],ra[0][1]) > 0 and len(ra) > 1:
            ra.pop(0)
        while f(la[-2][0],la[-2][1],ra[0][0],ra[0][1],la[-1][0],la[-1][1]) > 0 and len(la) > 1:
            la.pop(-1)
        return la+ra
    else:
        return a

while True:
    n = int(raw_input())
    if n == 0:
        break
    p = []
    for i in range(n):
        p.append(map(float, raw_input().split("","")))
    p = sorted(p, key = lambda x: x[0])
    print n - len(DC(p))",1
p00069,"あみだくじ II
縦線が
n
本のあみだくじがあります。このあみだくじは以下の条件を満たしています。
横線は真横に引きます。斜めに引くことはありません。
横線は必ず隣り合った縦線同士をつなぎます。つまり、横線が縦線をまたぐことはありません。
どの縦線についても同じ点から左右同時に横線が出ることはありません。つまり、横線が縦線を横切ることはありません。
当りはひとつだけです。
下図 に
n
= 5 のときの、あみだくじの例を示します。上側の数字は縦線の番号(左から1, 2, 3, 4, 5 ) を表します。☆が当たりです。
縦線の本数
n
、選んだ縦線の番号
m
、あみだくじの当りの場所、各段における横線の有無を読み込んで、当りにたどり着けるかどうかの判定を出力するプログラムを作成してください。ただし、与えられたあみだくじの任意の位置に1 本だけ横線を付け加えることができるものとします（付け加えなくてもかまいません）。横線を1 本付け加えた後のあみだくじも前述の条件を満たしていなければなりません。
Input
複数のデータセットが与えられます。各データセットは以下のとおりです：
１行目に、縦線の本数
n
(1 <
n
≤ 10) が書かれています。
２行目には、選んだ縦線の番号
m
(1 ≤
m
≤
n
) が書かれています。
３行目には、当りの場所（図でいう☆）が左から数えて何番目かが書かれています。
４行目には、あみだくじの段数
d
(1 ≤
d
≤ 30) が書かれています。
５行目以降は、図に対応する数字の並びのように、あみだくじの上から順に、各縦線の間に横線があるときを 1、ないときを 0 として、
n
- 1 つの数字が並んでいます。
入力は１つの 0 が書かれた行で終わります。
Output
各データセットについて、選んだ縦線の番号
m
から当りにたどり着けるかどうかに応じて以下の値を出力してください。
横線を引かなくても当りにたどり着けるときは 0 を出力してください。
横線を1 本引けば当りにたどり着けるときは、その中で最も出発側（図でみて上）に近い横線の位置を出力してください。出発側から数えて何段目（図 を参考にしてください）に、左から数えて何番目の縦線から右に向かって横線を引くかを半角の空白で区切って出力してください。
横線を1 本引いても当りにたどり着けないときには 1 を出力してください。
Sample Input
5
2
3
9
1010
1001
0100
1001
0010
1000
0100
0101
1010
0
Output for the Sample Input
6 4",C,"#include <stdio.h>
#include <string.h>

int n, m, target, d;
int amida[31][10];

int trace(int start, int skipRow, int skipCol) {
    int pos = start;
    for (int row = 1; row <= d; row++) {
        if (row == skipRow && skipCol == pos && amida[row][pos] == 0) {
            pos++;
        } else if (row == skipRow && skipCol == pos - 1 && amida[row][pos - 1] == 0) {
            pos--;
        } else if (pos > 1 && amida[row][pos - 1] == 1) {
            pos--;
        } else if (pos < n && amida[row][pos] == 1) {
            pos++;
        }
    }
    return pos;
}

int canAdd(int row, int col) {
    if (amida[row][col] == 1) return 0;
    if (col > 1 && amida[row][col - 1] == 1) return 0;
    if (col < n - 1 && amida[row][col + 1] == 1) return 0;
    return 1;
}

int main() {
    while (1) {
        scanf(""%d"", &n);
        if (n == 0) break;
        
        scanf(""%d"", &m);
        scanf(""%d"", &target);
        scanf(""%d"", &d);
        
        for (int i = 1; i <= d; i++) {
            char line[11];
            scanf(""%s"", line);
            for (int j = 0; j < n - 1; j++) {
                amida[i][j + 1] = line[j] - '0';
            }
        }
        
        int result = trace(m, -1, -1);
        if (result == target) {
            printf(""0\n"");
            continue;
        }
        
        int found = 0;
        for (int row = 1; row <= d && !found; row++) {
            for (int col = 1; col < n && !found; col++) {
                if (canAdd(row, col)) {
                    int res = trace(m, row, col);
                    if (res == target) {
                        printf(""%d %d\n"", row, col);
                        found = 1;
                    }
                }
            }
        }
        
        if (!found) {
            printf(""1\n"");
        }
    }
    
    return 0;
}
",0
p00069,"あみだくじ II
縦線が
n
本のあみだくじがあります。このあみだくじは以下の条件を満たしています。
横線は真横に引きます。斜めに引くことはありません。
横線は必ず隣り合った縦線同士をつなぎます。つまり、横線が縦線をまたぐことはありません。
どの縦線についても同じ点から左右同時に横線が出ることはありません。つまり、横線が縦線を横切ることはありません。
当りはひとつだけです。
下図 に
n
= 5 のときの、あみだくじの例を示します。上側の数字は縦線の番号(左から1, 2, 3, 4, 5 ) を表します。☆が当たりです。
縦線の本数
n
、選んだ縦線の番号
m
、あみだくじの当りの場所、各段における横線の有無を読み込んで、当りにたどり着けるかどうかの判定を出力するプログラムを作成してください。ただし、与えられたあみだくじの任意の位置に1 本だけ横線を付け加えることができるものとします（付け加えなくてもかまいません）。横線を1 本付け加えた後のあみだくじも前述の条件を満たしていなければなりません。
Input
複数のデータセットが与えられます。各データセットは以下のとおりです：
１行目に、縦線の本数
n
(1 <
n
≤ 10) が書かれています。
２行目には、選んだ縦線の番号
m
(1 ≤
m
≤
n
) が書かれています。
３行目には、当りの場所（図でいう☆）が左から数えて何番目かが書かれています。
４行目には、あみだくじの段数
d
(1 ≤
d
≤ 30) が書かれています。
５行目以降は、図に対応する数字の並びのように、あみだくじの上から順に、各縦線の間に横線があるときを 1、ないときを 0 として、
n
- 1 つの数字が並んでいます。
入力は１つの 0 が書かれた行で終わります。
Output
各データセットについて、選んだ縦線の番号
m
から当りにたどり着けるかどうかに応じて以下の値を出力してください。
横線を引かなくても当りにたどり着けるときは 0 を出力してください。
横線を1 本引けば当りにたどり着けるときは、その中で最も出発側（図でみて上）に近い横線の位置を出力してください。出発側から数えて何段目（図 を参考にしてください）に、左から数えて何番目の縦線から右に向かって横線を引くかを半角の空白で区切って出力してください。
横線を1 本引いても当りにたどり着けないときには 1 を出力してください。
Sample Input
5
2
3
9
1010
1001
0100
1001
0010
1000
0100
0101
1010
0
Output for the Sample Input
6 4",C,"#include <stdio.h>
#include <string.h>

int i, j;
int flag;
int n;
int m;
int atari;
int d;
char amida[11][31];
int temp[10], keep[10];

int check_amida(void){
	int k, l;
	for (k = 0; k < d; k++){
		for (l = 0; l < n - 1; l++){
			if (amida[k][l] == '1'){
				temp[l] += temp[l + 1];
				temp[l + 1] = temp[l] - temp[l + 1];
				temp[l] -= temp[l + 1];
			}
		}
	}
	if (temp[atari - 1] == m){
		return (1);
	}
	else {
		return (0);
	}
}

int ins_amida(int a, int b){
	int res;
	amida[a][b] = '1';
	res = check_amida();
	amida[a][b] = '0';
	
	return (res);
}

int main(void)
{
	while (1){
		scanf(""%d"", &n);
		
		if (!n){
			break;
		}
		
		for (i = 0; i < n; i++){
			temp[i] = i + 1;
			keep[i] = i + 1;
		}
		
		scanf(""%d"", &m);
		scanf(""%d"", &atari);
		scanf(""%d"", &d);
		
		for (i = 0; i < d; i++){
			scanf(""%s"", amida[i]);
			getchar();
		}
		
		flag = 0;
		
		if (check_amida() == 1){
			printf(""0\n"");
			flag = 1;
		}
		if (flag == 0){
			for (i = 0; i < d; i++){
				for (j = 0; j < n - 1; j++){
					memcpy(temp, keep, sizeof(keep));
					if (amida[i][j] == '1'){
						continue;
					}
					if (j > 0){
						if (amida[i][j - 1] == '1'){
							continue;
						}
					}
					if (j != n - 2){
						if (amida[i][j + 1] == '1'){
							continue;
						}
					}
					if (ins_amida(i, j) == 1){
						printf(""%d %d\n"", i + 1, j + 1);
						flag = 1;
						break;
					}
				}
				if (flag == 1){
					break;
				}
			}
		}
		if (flag == 0){
			printf(""1\n"");
		}
	}
	return (0);
}",1
p00069,"あみだくじ II
縦線が
n
本のあみだくじがあります。このあみだくじは以下の条件を満たしています。
横線は真横に引きます。斜めに引くことはありません。
横線は必ず隣り合った縦線同士をつなぎます。つまり、横線が縦線をまたぐことはありません。
どの縦線についても同じ点から左右同時に横線が出ることはありません。つまり、横線が縦線を横切ることはありません。
当りはひとつだけです。
下図 に
n
= 5 のときの、あみだくじの例を示します。上側の数字は縦線の番号(左から1, 2, 3, 4, 5 ) を表します。☆が当たりです。
縦線の本数
n
、選んだ縦線の番号
m
、あみだくじの当りの場所、各段における横線の有無を読み込んで、当りにたどり着けるかどうかの判定を出力するプログラムを作成してください。ただし、与えられたあみだくじの任意の位置に1 本だけ横線を付け加えることができるものとします（付け加えなくてもかまいません）。横線を1 本付け加えた後のあみだくじも前述の条件を満たしていなければなりません。
Input
複数のデータセットが与えられます。各データセットは以下のとおりです：
１行目に、縦線の本数
n
(1 <
n
≤ 10) が書かれています。
２行目には、選んだ縦線の番号
m
(1 ≤
m
≤
n
) が書かれています。
３行目には、当りの場所（図でいう☆）が左から数えて何番目かが書かれています。
４行目には、あみだくじの段数
d
(1 ≤
d
≤ 30) が書かれています。
５行目以降は、図に対応する数字の並びのように、あみだくじの上から順に、各縦線の間に横線があるときを 1、ないときを 0 として、
n
- 1 つの数字が並んでいます。
入力は１つの 0 が書かれた行で終わります。
Output
各データセットについて、選んだ縦線の番号
m
から当りにたどり着けるかどうかに応じて以下の値を出力してください。
横線を引かなくても当りにたどり着けるときは 0 を出力してください。
横線を1 本引けば当りにたどり着けるときは、その中で最も出発側（図でみて上）に近い横線の位置を出力してください。出発側から数えて何段目（図 を参考にしてください）に、左から数えて何番目の縦線から右に向かって横線を引くかを半角の空白で区切って出力してください。
横線を1 本引いても当りにたどり着けないときには 1 を出力してください。
Sample Input
5
2
3
9
1010
1001
0100
1001
0010
1000
0100
0101
1010
0
Output for the Sample Input
6 4",Java,"import java.util.*;

public class Main {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        
        while (true) {
            int n = sc.nextInt();
            if (n == 0) break;
            
            int m = sc.nextInt();
            int target = sc.nextInt();
            int d = sc.nextInt();
            
            int[][] ladder = new int[d][n - 1];
            for (int i = 0; i < d; i++) {
                String line = sc.next();
                for (int j = 0; j < n - 1; j++) {
                    ladder[i][j] = line.charAt(j) - '0';
                }
            }
            
            // Check if we can reach without adding
            int result = traverse(ladder, m - 1, d, n);
            if (result == target - 1) {
                System.out.println(0);
                continue;
            }
            
            // Try adding one horizontal line
            boolean found = false;
            for (int row = 0; row < d; row++) {
                for (int col = 0; col < n - 1; col++) {
                    if (canAddLine(ladder, row, col, n)) {
                        ladder[row][col] = 1;
                        int newResult = traverse(ladder, m - 1, d, n);
                        if (newResult == target - 1) {
                            System.out.println((row + 1) + "" "" + (col + 1));
                            found = true;
                            ladder[row][col] = 0;
                            break;
                        }
                        ladder[row][col] = 0;
                    }
                }
                if (found) break;
            }
            
            if (!found) {
                System.out.println(1);
            }
        }
        
        sc.close();
    }
    
    static int traverse(int[][] ladder, int start, int d, int n) {
        int pos = start;
        for (int row = 0; row < d; row++) {
            // Check left
            if (pos > 0 && ladder[row][pos - 1] == 1) {
                pos--;
            }
            // Check right
            else if (pos < n - 1 && ladder[row][pos] == 1) {
                pos++;
            }
        }
        return pos;
    }
    
    static boolean canAddLine(int[][] ladder, int row, int col, int n) {
        if (ladder[row][col] == 1) {
            return false;
        }
        
        // Check if adjacent positions have lines
        if (col > 0 && ladder[row][col - 1] == 1) {
            return false;
        }
        if (col < n - 2 && ladder[row][col + 1] == 1) {
            return false;
        }
        
        return true;
    }
}
",0
p00069,"あみだくじ II
縦線が
n
本のあみだくじがあります。このあみだくじは以下の条件を満たしています。
横線は真横に引きます。斜めに引くことはありません。
横線は必ず隣り合った縦線同士をつなぎます。つまり、横線が縦線をまたぐことはありません。
どの縦線についても同じ点から左右同時に横線が出ることはありません。つまり、横線が縦線を横切ることはありません。
当りはひとつだけです。
下図 に
n
= 5 のときの、あみだくじの例を示します。上側の数字は縦線の番号(左から1, 2, 3, 4, 5 ) を表します。☆が当たりです。
縦線の本数
n
、選んだ縦線の番号
m
、あみだくじの当りの場所、各段における横線の有無を読み込んで、当りにたどり着けるかどうかの判定を出力するプログラムを作成してください。ただし、与えられたあみだくじの任意の位置に1 本だけ横線を付け加えることができるものとします（付け加えなくてもかまいません）。横線を1 本付け加えた後のあみだくじも前述の条件を満たしていなければなりません。
Input
複数のデータセットが与えられます。各データセットは以下のとおりです：
１行目に、縦線の本数
n
(1 <
n
≤ 10) が書かれています。
２行目には、選んだ縦線の番号
m
(1 ≤
m
≤
n
) が書かれています。
３行目には、当りの場所（図でいう☆）が左から数えて何番目かが書かれています。
４行目には、あみだくじの段数
d
(1 ≤
d
≤ 30) が書かれています。
５行目以降は、図に対応する数字の並びのように、あみだくじの上から順に、各縦線の間に横線があるときを 1、ないときを 0 として、
n
- 1 つの数字が並んでいます。
入力は１つの 0 が書かれた行で終わります。
Output
各データセットについて、選んだ縦線の番号
m
から当りにたどり着けるかどうかに応じて以下の値を出力してください。
横線を引かなくても当りにたどり着けるときは 0 を出力してください。
横線を1 本引けば当りにたどり着けるときは、その中で最も出発側（図でみて上）に近い横線の位置を出力してください。出発側から数えて何段目（図 を参考にしてください）に、左から数えて何番目の縦線から右に向かって横線を引くかを半角の空白で区切って出力してください。
横線を1 本引いても当りにたどり着けないときには 1 を出力してください。
Sample Input
5
2
3
9
1010
1001
0100
1001
0010
1000
0100
0101
1010
0
Output for the Sample Input
6 4",Java,"import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;

public class Main{
	public static void main(String[] args)throws IOException{
		InputStreamReader isr = new InputStreamReader(System.in);
		BufferedReader reader = new BufferedReader(isr);
		String string;
		
		while(!(string = reader.readLine()).equals(""0"")){
			int n = Integer.valueOf(string);
			int m = Integer.valueOf(reader.readLine()) - 1;
			int a = Integer.valueOf(reader.readLine()) - 1;
			int d = Integer.valueOf(reader.readLine());
			
			int node[][] = new int[n - 1][d];
			for(int i = 0; i < d; i++){
				string = reader.readLine();
				for(int j = 0; j < n - 1; j++){
					node[j][i] = string.charAt(j) - '0';
				}
			}
			
			if(doing(node, n, m, d) == a){
				System.out.println(0);
				continue;
			}else{
				boolean judge = false;
				x : for(int i = 0; i < d; i++){
					for(int j = 0; j < n - 1; j++){
						if(j + 1 < n && j - 1 >= 0)
						if(node[j][i] == 0){
							node[j][i] = 1;
							if(doing(node, n, m, d) == a){
								System.out.println((i + 1) + "" "" + (j + 1));
								judge = true;
								break x;
							}
							node[j][i] = 0;
						}
					}
				}
				if(!judge) System.out.println(1);
			}
		}
		reader.close();
	}
	
	public static int doing(int node[][], int n, int s, int d){
		for(int i = 0; i < d; i++){
			if(s > 0 && node[s - 1][i] == 1) s--;
			else if(s < n - 1 && node[s][i] == 1) s++;
		}
		return s;
	}
}",1
p00069,"あみだくじ II
縦線が
n
本のあみだくじがあります。このあみだくじは以下の条件を満たしています。
横線は真横に引きます。斜めに引くことはありません。
横線は必ず隣り合った縦線同士をつなぎます。つまり、横線が縦線をまたぐことはありません。
どの縦線についても同じ点から左右同時に横線が出ることはありません。つまり、横線が縦線を横切ることはありません。
当りはひとつだけです。
下図 に
n
= 5 のときの、あみだくじの例を示します。上側の数字は縦線の番号(左から1, 2, 3, 4, 5 ) を表します。☆が当たりです。
縦線の本数
n
、選んだ縦線の番号
m
、あみだくじの当りの場所、各段における横線の有無を読み込んで、当りにたどり着けるかどうかの判定を出力するプログラムを作成してください。ただし、与えられたあみだくじの任意の位置に1 本だけ横線を付け加えることができるものとします（付け加えなくてもかまいません）。横線を1 本付け加えた後のあみだくじも前述の条件を満たしていなければなりません。
Input
複数のデータセットが与えられます。各データセットは以下のとおりです：
１行目に、縦線の本数
n
(1 <
n
≤ 10) が書かれています。
２行目には、選んだ縦線の番号
m
(1 ≤
m
≤
n
) が書かれています。
３行目には、当りの場所（図でいう☆）が左から数えて何番目かが書かれています。
４行目には、あみだくじの段数
d
(1 ≤
d
≤ 30) が書かれています。
５行目以降は、図に対応する数字の並びのように、あみだくじの上から順に、各縦線の間に横線があるときを 1、ないときを 0 として、
n
- 1 つの数字が並んでいます。
入力は１つの 0 が書かれた行で終わります。
Output
各データセットについて、選んだ縦線の番号
m
から当りにたどり着けるかどうかに応じて以下の値を出力してください。
横線を引かなくても当りにたどり着けるときは 0 を出力してください。
横線を1 本引けば当りにたどり着けるときは、その中で最も出発側（図でみて上）に近い横線の位置を出力してください。出発側から数えて何段目（図 を参考にしてください）に、左から数えて何番目の縦線から右に向かって横線を引くかを半角の空白で区切って出力してください。
横線を1 本引いても当りにたどり着けないときには 1 を出力してください。
Sample Input
5
2
3
9
1010
1001
0100
1001
0010
1000
0100
0101
1010
0
Output for the Sample Input
6 4",Python,"def follow_amida(n, start, lines):
    pos = start
    for line in lines:
        if pos > 1 and line[pos-2] == 1:
            pos -= 1
        elif pos < n and line[pos-1] == 1:
            pos += 1
    return pos

def can_add_line(lines, level, bridge_pos):
    # Check if we can add a horizontal line at level between bridge_pos and bridge_pos+1
    line = lines[level]
    
    # Check if there's already a line there
    if line[bridge_pos] == 1:
        return False
    
    # Check left neighbor
    if bridge_pos > 0 and line[bridge_pos-1] == 1:
        return False
    
    # Check right neighbor
    if bridge_pos < len(line) - 1 and line[bridge_pos+1] == 1:
        return False
    
    return True

def solve():
    while True:
        n = int(input())
        if n == 0:
            break
        
        m = int(input())
        target = int(input())
        d = int(input())
        
        lines = []
        for _ in range(d):
            line_str = input().strip()
            line = [int(c) for c in line_str]
            lines.append(line)
        
        # Check if already reaches target without adding any line
        result = follow_amida(n, m, lines)
        if result == target:
            print(0)
            continue
        
        # Try adding one line at each possible position
        found = False
        for level in range(d):
            for bridge_pos in range(n-1):
                if can_add_line(lines, level, bridge_pos):
                    # Make a copy and add the line
                    new_lines = [line[:] for line in lines]
                    new_lines[level][bridge_pos] = 1
                    
                    # Check if this reaches target
                    result = follow_amida(n, m, new_lines)
                    if result == target:
                        print(level + 1, bridge_pos + 1)
                        found = True
                        break
            if found:
                break
        
        if not found:
            print(1)

solve()
",0
p00069,"あみだくじ II
縦線が
n
本のあみだくじがあります。このあみだくじは以下の条件を満たしています。
横線は真横に引きます。斜めに引くことはありません。
横線は必ず隣り合った縦線同士をつなぎます。つまり、横線が縦線をまたぐことはありません。
どの縦線についても同じ点から左右同時に横線が出ることはありません。つまり、横線が縦線を横切ることはありません。
当りはひとつだけです。
下図 に
n
= 5 のときの、あみだくじの例を示します。上側の数字は縦線の番号(左から1, 2, 3, 4, 5 ) を表します。☆が当たりです。
縦線の本数
n
、選んだ縦線の番号
m
、あみだくじの当りの場所、各段における横線の有無を読み込んで、当りにたどり着けるかどうかの判定を出力するプログラムを作成してください。ただし、与えられたあみだくじの任意の位置に1 本だけ横線を付け加えることができるものとします（付け加えなくてもかまいません）。横線を1 本付け加えた後のあみだくじも前述の条件を満たしていなければなりません。
Input
複数のデータセットが与えられます。各データセットは以下のとおりです：
１行目に、縦線の本数
n
(1 <
n
≤ 10) が書かれています。
２行目には、選んだ縦線の番号
m
(1 ≤
m
≤
n
) が書かれています。
３行目には、当りの場所（図でいう☆）が左から数えて何番目かが書かれています。
４行目には、あみだくじの段数
d
(1 ≤
d
≤ 30) が書かれています。
５行目以降は、図に対応する数字の並びのように、あみだくじの上から順に、各縦線の間に横線があるときを 1、ないときを 0 として、
n
- 1 つの数字が並んでいます。
入力は１つの 0 が書かれた行で終わります。
Output
各データセットについて、選んだ縦線の番号
m
から当りにたどり着けるかどうかに応じて以下の値を出力してください。
横線を引かなくても当りにたどり着けるときは 0 を出力してください。
横線を1 本引けば当りにたどり着けるときは、その中で最も出発側（図でみて上）に近い横線の位置を出力してください。出発側から数えて何段目（図 を参考にしてください）に、左から数えて何番目の縦線から右に向かって横線を引くかを半角の空白で区切って出力してください。
横線を1 本引いても当りにたどり着けないときには 1 を出力してください。
Sample Input
5
2
3
9
1010
1001
0100
1001
0010
1000
0100
0101
1010
0
Output for the Sample Input
6 4",Python,"import sys
import itertools


def one_step(lo,lis):
    nu = [ e for e in lis ]
    for j in xrange(len(nu)):
        if lo[0][j] == 1:
            nu[j],nu[j+1] = nu[j+1],nu[j]
    return lo[1:],nu


def solve(lo,lis):
    if len(lo) == 0:
        return lis
    nu = [ e for e in lis]
    lo2,nu2 = one_step(lo,nu)
    return solve(lo2,nu2)

n = input()
m = input()
star = input()
d = input()
lis = range(n+1)
lots = []
for i in xrange(d):
    lots.append([0]+[ 1 if e == '1' else 0 for e in list(raw_input()) ] +[0])

if solve(lots,lis)[star] == m: print 0;exit()
for i in xrange(d):
    for j in xrange(1,n):
        if lots[0][j-1] == 0 and lots[0][j] == 0 and lots[0][j+1] == 0:
            lots[0][j] = 1
            if solve(lots,lis)[star] == m: print i+1,j;exit()
            lots[0][j] = 0
    lots,lis = one_step(lots,lis)
print 1",1
p00070,"Combination of Number Sequences
0 から 9 までの整数を使った
n
個の数の並び
k
1
,
k
2
, ...,
k
n
を考えます。正の整数
n
と
s
を読み込んで、
k
1
+ 2 × k
2
+ 3 × k
3
+
...
+ n × k
n
= s
となっているような
n
個の数の並びが何通りあるかを出力するプログラムを作成してください。ただし、1 つの「
n
個の数の並び」には同じ数が 2 回以上現われないものとします。
Input
入力は複数のデータセットからなります。各データセットとして、
n
(1 ≤
n
≤ 10) と
s
(0 ≤
s
≤ 10,000)が空白区切りで１行に与えられます。
データセットの数は 100 を超えません。
Output
データセットごとに、
n
個の整数の和が
s
になる組み合わせの個数を１行に出力します。
Sample Input
3 10
3 1
Output for the Sample Input
8
0",C,"#include <stdio.h>

int n, s;
int count;
int used[10];
int seq[11];

void solve(int pos, int sum) {
    if (pos > n) {
        if (sum == s) {
            count++;
        }
        return;
    }
    
    for (int i = 0; i <= 9; i++) {
        if (!used[i]) {
            used[i] = 1;
            seq[pos] = i;
            solve(pos + 1, sum + pos * i);
            used[i] = 0;
        }
    }
}

int main() {
    while (scanf(""%d %d"", &n, &s) == 2) {
        count = 0;
        for (int i = 0; i <= 9; i++) {
            used[i] = 0;
        }
        solve(1, 0);
        printf(""%d\n"", count);
    }
    return 0;
}
",0
p00070,"Combination of Number Sequences
0 から 9 までの整数を使った
n
個の数の並び
k
1
,
k
2
, ...,
k
n
を考えます。正の整数
n
と
s
を読み込んで、
k
1
+ 2 × k
2
+ 3 × k
3
+
...
+ n × k
n
= s
となっているような
n
個の数の並びが何通りあるかを出力するプログラムを作成してください。ただし、1 つの「
n
個の数の並び」には同じ数が 2 回以上現われないものとします。
Input
入力は複数のデータセットからなります。各データセットとして、
n
(1 ≤
n
≤ 10) と
s
(0 ≤
s
≤ 10,000)が空白区切りで１行に与えられます。
データセットの数は 100 を超えません。
Output
データセットごとに、
n
個の整数の和が
s
になる組み合わせの個数を１行に出力します。
Sample Input
3 10
3 1
Output for the Sample Input
8
0",C,"#include <stdio.h>

int num[10]={1,2,3,4,5,6,7,8,9,0}, dp[11][331];
#define exch(A,B) {int t; t=A, A=B, B=t;}

/* k¶Úðßé, sÉÍ»Ì_ÅÌað */
void solve(int k, int s){
     int i, j, ts;

     for(i=k; i<10; i++){
	  exch(num[i],num[k]);

	  /* n=kÅÌsðL^ */
	  ts=s;
	  ts+=num[k]*(k+1);
	  dp[k+1][ts]++;

	  if(k<9) solve(k+1,ts);

	  exch(num[i],num[k]);
     }
}

int main(int argc, char *argv[]){
     int n, s;

     solve(0,0);
     
     while(~scanf(""%d %d"",&n,&s))
	  printf(""%d\n"",(n<=10 && s<=330)?dp[n][s]:0);

     return 0;
}",1
p00070,"Combination of Number Sequences
0 から 9 までの整数を使った
n
個の数の並び
k
1
,
k
2
, ...,
k
n
を考えます。正の整数
n
と
s
を読み込んで、
k
1
+ 2 × k
2
+ 3 × k
3
+
...
+ n × k
n
= s
となっているような
n
個の数の並びが何通りあるかを出力するプログラムを作成してください。ただし、1 つの「
n
個の数の並び」には同じ数が 2 回以上現われないものとします。
Input
入力は複数のデータセットからなります。各データセットとして、
n
(1 ≤
n
≤ 10) と
s
(0 ≤
s
≤ 10,000)が空白区切りで１行に与えられます。
データセットの数は 100 を超えません。
Output
データセットごとに、
n
個の整数の和が
s
になる組み合わせの個数を１行に出力します。
Sample Input
3 10
3 1
Output for the Sample Input
8
0",Java,"import java.util.*;

public class Main {
    static int n, s;
    static int count;
    
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        
        while (sc.hasNext()) {
            n = sc.nextInt();
            s = sc.nextInt();
            
            count = 0;
            boolean[] used = new boolean[10];
            solve(1, 0, used);
            
            System.out.println(count);
        }
        
        sc.close();
    }
    
    static void solve(int pos, int sum, boolean[] used) {
        if (pos > n) {
            if (sum == s) {
                count++;
            }
            return;
        }
        
        for (int i = 0; i <= 9; i++) {
            if (!used[i]) {
                used[i] = true;
                solve(pos + 1, sum + pos * i, used);
                used[i] = false;
            }
        }
    }
}
",0
p00070,"Combination of Number Sequences
0 から 9 までの整数を使った
n
個の数の並び
k
1
,
k
2
, ...,
k
n
を考えます。正の整数
n
と
s
を読み込んで、
k
1
+ 2 × k
2
+ 3 × k
3
+
...
+ n × k
n
= s
となっているような
n
個の数の並びが何通りあるかを出力するプログラムを作成してください。ただし、1 つの「
n
個の数の並び」には同じ数が 2 回以上現われないものとします。
Input
入力は複数のデータセットからなります。各データセットとして、
n
(1 ≤
n
≤ 10) と
s
(0 ≤
s
≤ 10,000)が空白区切りで１行に与えられます。
データセットの数は 100 を超えません。
Output
データセットごとに、
n
個の整数の和が
s
になる組み合わせの個数を１行に出力します。
Sample Input
3 10
3 1
Output for the Sample Input
8
0",Java,"import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;

/**
 * Combination of Number Sequences
 */
public class Main {

	static int count;

	public static void main(String[] args) throws IOException {
		BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
		String line = """";

		while ((line = br.readLine()) != null && !line.isEmpty()) {

			int n = Integer.parseInt(line.substring(0, line.indexOf(' ')));
			int s = Integer.parseInt(line.substring(line.indexOf(' ') + 1));

			count = 0;
			solve(0, n, 1, s);
			System.out.println(count);

		}

	}

	static void solve(int p, int n, int a, int s) {

		if (p > 9 || n <= 0 || p * a > s) {
			return;
		}

		if (n == 1 && p * a == s) {
			++count;
		} else {
			solve(p + 1, n - 1, a + 1, s - p * a);
			solve(p + 1, n, a, s);
		}
	}
}",1
p00070,"Combination of Number Sequences
0 から 9 までの整数を使った
n
個の数の並び
k
1
,
k
2
, ...,
k
n
を考えます。正の整数
n
と
s
を読み込んで、
k
1
+ 2 × k
2
+ 3 × k
3
+
...
+ n × k
n
= s
となっているような
n
個の数の並びが何通りあるかを出力するプログラムを作成してください。ただし、1 つの「
n
個の数の並び」には同じ数が 2 回以上現われないものとします。
Input
入力は複数のデータセットからなります。各データセットとして、
n
(1 ≤
n
≤ 10) と
s
(0 ≤
s
≤ 10,000)が空白区切りで１行に与えられます。
データセットの数は 100 を超えません。
Output
データセットごとに、
n
個の整数の和が
s
になる組み合わせの個数を１行に出力します。
Sample Input
3 10
3 1
Output for the Sample Input
8
0",Python,"import sys
from itertools import permutations

def count_combinations(n, s):
    count = 0
    # Generate all permutations of n numbers from 0-9
    for perm in permutations(range(10), n):
        # Calculate the weighted sum
        weighted_sum = sum((i + 1) * perm[i] for i in range(n))
        if weighted_sum == s:
            count += 1
    return count

for line in sys.stdin:
    n, s = map(int, line.strip().split())
    print(count_combinations(n, s))
",0
p00070,"Combination of Number Sequences
0 から 9 までの整数を使った
n
個の数の並び
k
1
,
k
2
, ...,
k
n
を考えます。正の整数
n
と
s
を読み込んで、
k
1
+ 2 × k
2
+ 3 × k
3
+
...
+ n × k
n
= s
となっているような
n
個の数の並びが何通りあるかを出力するプログラムを作成してください。ただし、1 つの「
n
個の数の並び」には同じ数が 2 回以上現われないものとします。
Input
入力は複数のデータセットからなります。各データセットとして、
n
(1 ≤
n
≤ 10) と
s
(0 ≤
s
≤ 10,000)が空白区切りで１行に与えられます。
データセットの数は 100 を超えません。
Output
データセットごとに、
n
個の整数の和が
s
になる組み合わせの個数を１行に出力します。
Sample Input
3 10
3 1
Output for the Sample Input
8
0",Python,"
import sys
import itertools


table = [[], [], [], [], [], [], [], [], [], [], []]

def solv(n, s):
    if s > 330:
        return 0
    dp = table[n]
    if dp:
        return dp[s]
    else:
        for i in xrange(331):
            dp.append(0)
        for p in itertools.permutations(xrange(10), n):
            s0 = foo(p, n)
            dp[s0] += 1
        return dp[s]


def foo(perm, n):
    return sum(map(lambda x, y: x * y, xrange(1, n+1), perm))


for line in sys.stdin:
    n, s = map(int, line.split(' '))
    print solv(n, s)",1
p00071,"爆弾の連鎖
縦 8、横 8 のマスからなる図1 のような平面があります。その平面上に、いくつかの爆弾が置かれています。図2 にその例を示します（● = 爆弾）。
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
●
□
□
●
□
□
□
□
□
□
●
□
□
●
□
□
□
●
□
□
●
□
□
●
□
□
□
●
□
□
●
□
□
□
□
□
□
□
□
□
□
●
□
□
□
●
□
●
□
□
□
●
□
□
●
□
●
□
□
●
□
図1
図2
爆弾が爆発すると、その爆弾の上下左右 3 マスに爆風の影響が及び、それらのマスに置かれている爆弾も連鎖的に爆発します。たとえば、図 3 に示す爆弾が爆発すると図 4 の■のマスに爆風の影響が及びます。
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
●
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
■
□
□
□
□
□
□
□
■
□
□
□
□
□
□
□
■
□
□
□
□
■
■
■
●
■
■
■
□
□
□
□
■
□
□
□
□
□
□
□
■
□
□
□
□
図3
図4
爆弾が置かれている状態と最初に爆発する爆弾の位置を読み込んで、最終的な平面の状態を出力するプログラムを作成してください。
Input
入力は以下の形式で与えられます。
n
（空行）
データセット 1
（空行）
データセット 2
..
..
データセット
n
１行目にデータセットの数
n
(
n
≤ 20) が与えられます。続いて
n
個のデータセットが与えられます。各データセットの直前に１つの空行が与えられます。各データセットは以下の形式で与えられます。
g
1,1
g
2,1
...
g
8,1
g
1,2
g
2,2
...
g
8,2
:
g
1,8
g
2,8
...
g
8,8
X
Y
最初の８行に、平面を表す８つの文字列が与えられます。各文字列は８文字からなる数列で、爆弾が置かれているマスを 1、置かれていないマスを 0 で表します。
続く２行で、最初に爆発する爆弾の
X
座標と
Y
座標が与えられます。左上、左下、右上、右下の座標が、それぞれ、(1, 1)、(1, 8)、(8, 1)、(8, 8) です。例えば、図 4 に示す爆弾が最初に爆発するとき、与えられる座標は (4, 6) です。
Output
各データセットについて以下のように出力して下さい。
爆発しないで残った爆弾のあるマスを 1、爆弾のないマスを 0 で表現することとします。平面の一行を数字 8 個からなる一行とし 8 行の文字列で最終的な平面の状態を出力してください。各データセットの先頭は、サンプル出力のように Data
x
: から出力しなければなりません。ここで、
x
はデータセットの番号です。
Sample Input
2

00010010
00000100
10001001
00100010
01000000
00001000
10100010
01010010
2
5

00010010
00000100
10001001
00100010
01000000
00001000
10100010
01010010
2
5
Output for the Sample Input
Data 1:
00000000
00000100
10001001
00100000
00000000
00001000
10100000
00000000
Data 2:
00000000
00000100
10001001
00100000
00000000
00001000
10100000
00000000",C,"#include <stdio.h>
#include <string.h>

int grid[8][8];
int exploded[8][8];

void explode(int x, int y) {
    if (x < 0 || x >= 8 || y < 0 || y >= 8) return;
    if (exploded[y][x]) return;
    if (grid[y][x] == 0) return;
    
    exploded[y][x] = 1;
    
    // Explode bombs in range (3 squares in each direction)
    for (int i = 1; i <= 3; i++) {
        if (x - i >= 0) explode(x - i, y);
        if (x + i < 8) explode(x + i, y);
        if (y - i >= 0) explode(x, y - i);
        if (y + i < 8) explode(x, y + i);
    }
}

int main() {
    int n;
    scanf(""%d"", &n);
    
    for (int dataset = 1; dataset <= n; dataset++) {
        // Read the grid
        for (int i = 0; i < 8; i++) {
            char line[10];
            scanf(""%s"", line);
            for (int j = 0; j < 8; j++) {
                grid[i][j] = line[j] - '0';
            }
        }
        
        int x, y;
        scanf(""%d %d"", &x, &y);
        x--; y--; // Convert to 0-indexed
        
        // Initialize exploded array
        memset(exploded, 0, sizeof(exploded));
        
        // Start the chain reaction
        explode(x, y);
        
        // Output
        printf(""Data %d:\n"", dataset);
        for (int i = 0; i < 8; i++) {
            for (int j = 0; j < 8; j++) {
                if (exploded[i][j]) {
                    printf(""0"");
                } else {
                    printf(""%d"", grid[i][j]);
                }
            }
            printf(""\n"");
        }
    }
    
    return 0;
}
",0
p00071,"爆弾の連鎖
縦 8、横 8 のマスからなる図1 のような平面があります。その平面上に、いくつかの爆弾が置かれています。図2 にその例を示します（● = 爆弾）。
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
●
□
□
●
□
□
□
□
□
□
●
□
□
●
□
□
□
●
□
□
●
□
□
●
□
□
□
●
□
□
●
□
□
□
□
□
□
□
□
□
□
●
□
□
□
●
□
●
□
□
□
●
□
□
●
□
●
□
□
●
□
図1
図2
爆弾が爆発すると、その爆弾の上下左右 3 マスに爆風の影響が及び、それらのマスに置かれている爆弾も連鎖的に爆発します。たとえば、図 3 に示す爆弾が爆発すると図 4 の■のマスに爆風の影響が及びます。
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
●
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
■
□
□
□
□
□
□
□
■
□
□
□
□
□
□
□
■
□
□
□
□
■
■
■
●
■
■
■
□
□
□
□
■
□
□
□
□
□
□
□
■
□
□
□
□
図3
図4
爆弾が置かれている状態と最初に爆発する爆弾の位置を読み込んで、最終的な平面の状態を出力するプログラムを作成してください。
Input
入力は以下の形式で与えられます。
n
（空行）
データセット 1
（空行）
データセット 2
..
..
データセット
n
１行目にデータセットの数
n
(
n
≤ 20) が与えられます。続いて
n
個のデータセットが与えられます。各データセットの直前に１つの空行が与えられます。各データセットは以下の形式で与えられます。
g
1,1
g
2,1
...
g
8,1
g
1,2
g
2,2
...
g
8,2
:
g
1,8
g
2,8
...
g
8,8
X
Y
最初の８行に、平面を表す８つの文字列が与えられます。各文字列は８文字からなる数列で、爆弾が置かれているマスを 1、置かれていないマスを 0 で表します。
続く２行で、最初に爆発する爆弾の
X
座標と
Y
座標が与えられます。左上、左下、右上、右下の座標が、それぞれ、(1, 1)、(1, 8)、(8, 1)、(8, 8) です。例えば、図 4 に示す爆弾が最初に爆発するとき、与えられる座標は (4, 6) です。
Output
各データセットについて以下のように出力して下さい。
爆発しないで残った爆弾のあるマスを 1、爆弾のないマスを 0 で表現することとします。平面の一行を数字 8 個からなる一行とし 8 行の文字列で最終的な平面の状態を出力してください。各データセットの先頭は、サンプル出力のように Data
x
: から出力しなければなりません。ここで、
x
はデータセットの番号です。
Sample Input
2

00010010
00000100
10001001
00100010
01000000
00001000
10100010
01010010
2
5

00010010
00000100
10001001
00100010
01000000
00001000
10100010
01010010
2
5
Output for the Sample Input
Data 1:
00000000
00000100
10001001
00100000
00000000
00001000
10100000
00000000
Data 2:
00000000
00000100
10001001
00100000
00000000
00001000
10100000
00000000",C,"#include <stdio.h>

void bomb(int field[8][8],int x,int y);

int main(){
	int i,j,k,n;
	int field[8][8];
	char line[9];
	int x,y;
	
	scanf(""%d"",&n);
	for(i=1;i<=n;i++){		
		for(j=0;j<8;j++){
			scanf(""%s"",line);
			for(k=0;k<8;k++){
				field[j][k] = line[k] - '0';
			}
		}
		scanf(""%d"",&x);
		scanf(""%d"",&y);
		x--; y--;
		
		bomb(field,y,x);
		
		printf(""Data %d:\n"",i);
		for(j=0;j<8;j++){
			for(k=0;k<8;k++){
				printf(""%d"",field[j][k]);
			}
			printf(""\n"");
		}
	}
	
	return 0;
}

void bomb(int field[8][8],int x,int y){
	int i;
	field[x][y] = 0;
	for(i=1;i<=3&&x-i>=0;i++){
		if(field[x-i][y] == 1){
			field[x-i][y] = 0;
			bomb(field,x-i,y);
		}
	}
	for(i=1;i<=3&&x+i<8;i++){
		if(field[x+i][y] == 1){
			field[x+i][y] = 0;
			bomb(field,x+i,y);
		}
	}
	for(i=1;i<=3&&y-i>=0;i++){
		if(field[x][y-i] == 1){
			field[x][y-i] = 0;
			bomb(field,x,y-i);
		}
	}
	for(i=1;i<=3&&y+i<8;i++){
		if(field[x][y+i] == 1){
			field[x][y+i] = 0;
			bomb(field,x,y+i);
		}
	}
}",1
p00071,"爆弾の連鎖
縦 8、横 8 のマスからなる図1 のような平面があります。その平面上に、いくつかの爆弾が置かれています。図2 にその例を示します（● = 爆弾）。
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
●
□
□
●
□
□
□
□
□
□
●
□
□
●
□
□
□
●
□
□
●
□
□
●
□
□
□
●
□
□
●
□
□
□
□
□
□
□
□
□
□
●
□
□
□
●
□
●
□
□
□
●
□
□
●
□
●
□
□
●
□
図1
図2
爆弾が爆発すると、その爆弾の上下左右 3 マスに爆風の影響が及び、それらのマスに置かれている爆弾も連鎖的に爆発します。たとえば、図 3 に示す爆弾が爆発すると図 4 の■のマスに爆風の影響が及びます。
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
●
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
■
□
□
□
□
□
□
□
■
□
□
□
□
□
□
□
■
□
□
□
□
■
■
■
●
■
■
■
□
□
□
□
■
□
□
□
□
□
□
□
■
□
□
□
□
図3
図4
爆弾が置かれている状態と最初に爆発する爆弾の位置を読み込んで、最終的な平面の状態を出力するプログラムを作成してください。
Input
入力は以下の形式で与えられます。
n
（空行）
データセット 1
（空行）
データセット 2
..
..
データセット
n
１行目にデータセットの数
n
(
n
≤ 20) が与えられます。続いて
n
個のデータセットが与えられます。各データセットの直前に１つの空行が与えられます。各データセットは以下の形式で与えられます。
g
1,1
g
2,1
...
g
8,1
g
1,2
g
2,2
...
g
8,2
:
g
1,8
g
2,8
...
g
8,8
X
Y
最初の８行に、平面を表す８つの文字列が与えられます。各文字列は８文字からなる数列で、爆弾が置かれているマスを 1、置かれていないマスを 0 で表します。
続く２行で、最初に爆発する爆弾の
X
座標と
Y
座標が与えられます。左上、左下、右上、右下の座標が、それぞれ、(1, 1)、(1, 8)、(8, 1)、(8, 8) です。例えば、図 4 に示す爆弾が最初に爆発するとき、与えられる座標は (4, 6) です。
Output
各データセットについて以下のように出力して下さい。
爆発しないで残った爆弾のあるマスを 1、爆弾のないマスを 0 で表現することとします。平面の一行を数字 8 個からなる一行とし 8 行の文字列で最終的な平面の状態を出力してください。各データセットの先頭は、サンプル出力のように Data
x
: から出力しなければなりません。ここで、
x
はデータセットの番号です。
Sample Input
2

00010010
00000100
10001001
00100010
01000000
00001000
10100010
01010010
2
5

00010010
00000100
10001001
00100010
01000000
00001000
10100010
01010010
2
5
Output for the Sample Input
Data 1:
00000000
00000100
10001001
00100000
00000000
00001000
10100000
00000000
Data 2:
00000000
00000100
10001001
00100000
00000000
00001000
10100000
00000000",Java,"import java.util.*;

public class Main {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int n = sc.nextInt();
        sc.nextLine();
        
        for (int dataSet = 1; dataSet <= n; dataSet++) {
            sc.nextLine(); // empty line
            
            int[][] grid = new int[8][8];
            for (int y = 0; y < 8; y++) {
                String line = sc.nextLine();
                for (int x = 0; x < 8; x++) {
                    grid[y][x] = line.charAt(x) - '0';
                }
            }
            
            int startX = sc.nextInt() - 1;
            int startY = sc.nextInt() - 1;
            sc.nextLine();
            
            // BFS to explode bombs
            Queue<int[]> queue = new LinkedList<>();
            boolean[][] exploded = new boolean[8][8];
            
            queue.offer(new int[]{startX, startY});
            exploded[startY][startX] = true;
            
            while (!queue.isEmpty()) {
                int[] pos = queue.poll();
                int x = pos[0];
                int y = pos[1];
                
                // Check up to 3 cells in each direction
                for (int dy = -3; dy <= 3; dy++) {
                    int ny = y + dy;
                    if (ny >= 0 && ny < 8 && grid[ny][x] == 1 && !exploded[ny][x]) {
                        exploded[ny][x] = true;
                        queue.offer(new int[]{x, ny});
                    }
                }
                
                for (int dx = -3; dx <= 3; dx++) {
                    int nx = x + dx;
                    if (nx >= 0 && nx < 8 && grid[y][nx] == 1 && !exploded[y][nx]) {
                        exploded[y][nx] = true;
                        queue.offer(new int[]{nx, y});
                    }
                }
            }
            
            // Update grid
            for (int y = 0; y < 8; y++) {
                for (int x = 0; x < 8; x++) {
                    if (exploded[y][x]) {
                        grid[y][x] = 0;
                    }
                }
            }
            
            // Output
            System.out.println(""Data "" + dataSet + "":"");
            for (int y = 0; y < 8; y++) {
                for (int x = 0; x < 8; x++) {
                    System.out.print(grid[y][x]);
                }
                System.out.println();
            }
        }
        
        sc.close();
    }
}
",0
p00071,"爆弾の連鎖
縦 8、横 8 のマスからなる図1 のような平面があります。その平面上に、いくつかの爆弾が置かれています。図2 にその例を示します（● = 爆弾）。
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
●
□
□
●
□
□
□
□
□
□
●
□
□
●
□
□
□
●
□
□
●
□
□
●
□
□
□
●
□
□
●
□
□
□
□
□
□
□
□
□
□
●
□
□
□
●
□
●
□
□
□
●
□
□
●
□
●
□
□
●
□
図1
図2
爆弾が爆発すると、その爆弾の上下左右 3 マスに爆風の影響が及び、それらのマスに置かれている爆弾も連鎖的に爆発します。たとえば、図 3 に示す爆弾が爆発すると図 4 の■のマスに爆風の影響が及びます。
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
●
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
■
□
□
□
□
□
□
□
■
□
□
□
□
□
□
□
■
□
□
□
□
■
■
■
●
■
■
■
□
□
□
□
■
□
□
□
□
□
□
□
■
□
□
□
□
図3
図4
爆弾が置かれている状態と最初に爆発する爆弾の位置を読み込んで、最終的な平面の状態を出力するプログラムを作成してください。
Input
入力は以下の形式で与えられます。
n
（空行）
データセット 1
（空行）
データセット 2
..
..
データセット
n
１行目にデータセットの数
n
(
n
≤ 20) が与えられます。続いて
n
個のデータセットが与えられます。各データセットの直前に１つの空行が与えられます。各データセットは以下の形式で与えられます。
g
1,1
g
2,1
...
g
8,1
g
1,2
g
2,2
...
g
8,2
:
g
1,8
g
2,8
...
g
8,8
X
Y
最初の８行に、平面を表す８つの文字列が与えられます。各文字列は８文字からなる数列で、爆弾が置かれているマスを 1、置かれていないマスを 0 で表します。
続く２行で、最初に爆発する爆弾の
X
座標と
Y
座標が与えられます。左上、左下、右上、右下の座標が、それぞれ、(1, 1)、(1, 8)、(8, 1)、(8, 8) です。例えば、図 4 に示す爆弾が最初に爆発するとき、与えられる座標は (4, 6) です。
Output
各データセットについて以下のように出力して下さい。
爆発しないで残った爆弾のあるマスを 1、爆弾のないマスを 0 で表現することとします。平面の一行を数字 8 個からなる一行とし 8 行の文字列で最終的な平面の状態を出力してください。各データセットの先頭は、サンプル出力のように Data
x
: から出力しなければなりません。ここで、
x
はデータセットの番号です。
Sample Input
2

00010010
00000100
10001001
00100010
01000000
00001000
10100010
01010010
2
5

00010010
00000100
10001001
00100010
01000000
00001000
10100010
01010010
2
5
Output for the Sample Input
Data 1:
00000000
00000100
10001001
00100000
00000000
00001000
10100000
00000000
Data 2:
00000000
00000100
10001001
00100000
00000000
00001000
10100000
00000000",Java,"import java.util.LinkedList;
import java.util.Scanner;

public class Main {
	private Scanner sc;

	int[][] map;
	public static void main(String[] args) {
		new Main();
	}
	
	public Main() {
		sc = new Scanner(System.in);
		
		int sets = Integer.parseInt(sc.nextLine());
		
		for (int index = 0; index < sets; index++) {
			sc.nextLine();
			
			map = new int[8][8];
			for (int i = 0; i < map.length; i++) {
				String line = sc.nextLine();
				for (int j = 0; j < map.length; j++) {
					map[j][i] = line.charAt(j) - '0';
				}
			}
			
			LinkedList<Integer[]> boms = new LinkedList<Integer[]>();
			Integer[] xy = new Integer[2];
			xy[0] = Integer.parseInt(sc.nextLine()) - 1;
			xy[1] = Integer.parseInt(sc.nextLine()) - 1;
			map[xy[0]][xy[1]] = 0;
			boms.add(xy);
			
			while (boms.isEmpty() == false) {
				xy = boms.pop();
				
				int tx = xy[0];
				int ty = xy[1];
				
				
				for (int i = -3; i < 4; i++) {
					if ((tx + i) < 0) continue;
					if ((tx + i) > 7) break;
					
					if (map[tx + i][ty] == 1) {
						map[tx + i][ty] = 0;
						xy[0] = tx + i;
						xy[1] = ty;
						boms.add(xy);
					}
				}

				for (int i = -3; i < 4; i++) {
					if ((ty + i) < 0) continue;
					if ((ty + i) > 7) break;	
					
					if (map[tx][ty + i] == 1) {
						map[tx][ty + i] = 0;
						xy[0] = tx;
						xy[1] = ty + i;
						boms.add(xy);
					}
				}
			}
			
			System.out.println(""Data "" + (index + 1) + "":"");
			for (int i = 0; i < map.length; i++) {
				for (int j = 0; j < map.length; j++) {
					System.out.print(map[j][i]);
				}
				System.out.println();
			}
		}
	}
}",1
p00071,"爆弾の連鎖
縦 8、横 8 のマスからなる図1 のような平面があります。その平面上に、いくつかの爆弾が置かれています。図2 にその例を示します（● = 爆弾）。
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
●
□
□
●
□
□
□
□
□
□
●
□
□
●
□
□
□
●
□
□
●
□
□
●
□
□
□
●
□
□
●
□
□
□
□
□
□
□
□
□
□
●
□
□
□
●
□
●
□
□
□
●
□
□
●
□
●
□
□
●
□
図1
図2
爆弾が爆発すると、その爆弾の上下左右 3 マスに爆風の影響が及び、それらのマスに置かれている爆弾も連鎖的に爆発します。たとえば、図 3 に示す爆弾が爆発すると図 4 の■のマスに爆風の影響が及びます。
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
●
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
■
□
□
□
□
□
□
□
■
□
□
□
□
□
□
□
■
□
□
□
□
■
■
■
●
■
■
■
□
□
□
□
■
□
□
□
□
□
□
□
■
□
□
□
□
図3
図4
爆弾が置かれている状態と最初に爆発する爆弾の位置を読み込んで、最終的な平面の状態を出力するプログラムを作成してください。
Input
入力は以下の形式で与えられます。
n
（空行）
データセット 1
（空行）
データセット 2
..
..
データセット
n
１行目にデータセットの数
n
(
n
≤ 20) が与えられます。続いて
n
個のデータセットが与えられます。各データセットの直前に１つの空行が与えられます。各データセットは以下の形式で与えられます。
g
1,1
g
2,1
...
g
8,1
g
1,2
g
2,2
...
g
8,2
:
g
1,8
g
2,8
...
g
8,8
X
Y
最初の８行に、平面を表す８つの文字列が与えられます。各文字列は８文字からなる数列で、爆弾が置かれているマスを 1、置かれていないマスを 0 で表します。
続く２行で、最初に爆発する爆弾の
X
座標と
Y
座標が与えられます。左上、左下、右上、右下の座標が、それぞれ、(1, 1)、(1, 8)、(8, 1)、(8, 8) です。例えば、図 4 に示す爆弾が最初に爆発するとき、与えられる座標は (4, 6) です。
Output
各データセットについて以下のように出力して下さい。
爆発しないで残った爆弾のあるマスを 1、爆弾のないマスを 0 で表現することとします。平面の一行を数字 8 個からなる一行とし 8 行の文字列で最終的な平面の状態を出力してください。各データセットの先頭は、サンプル出力のように Data
x
: から出力しなければなりません。ここで、
x
はデータセットの番号です。
Sample Input
2

00010010
00000100
10001001
00100010
01000000
00001000
10100010
01010010
2
5

00010010
00000100
10001001
00100010
01000000
00001000
10100010
01010010
2
5
Output for the Sample Input
Data 1:
00000000
00000100
10001001
00100000
00000000
00001000
10100000
00000000
Data 2:
00000000
00000100
10001001
00100000
00000000
00001000
10100000
00000000",Python,"from collections import deque

def solve():
    n = int(input())
    
    for dataset_num in range(1, n + 1):
        # Read empty line
        input()
        
        # Read 8x8 grid
        grid = []
        for i in range(8):
            line = input().strip()
            grid.append([int(c) for c in line])
        
        # Read starting position
        x = int(input())
        y = int(input())
        
        # Convert to 0-indexed
        x -= 1
        y -= 1
        
        # BFS to simulate chain explosions
        exploded = [[False] * 8 for _ in range(8)]
        queue = deque()
        
        # Start explosion at (x, y)
        if grid[y][x] == 1:
            queue.append((x, y))
            exploded[y][x] = True
        
        while queue:
            cx, cy = queue.popleft()
            
            # Explosion affects 3 squares in each direction (up, down, left, right)
            directions = []
            # Up
            for dy in range(1, 4):
                if cy - dy >= 0:
                    directions.append((cx, cy - dy))
            # Down
            for dy in range(1, 4):
                if cy + dy < 8:
                    directions.append((cx, cy + dy))
            # Left
            for dx in range(1, 4):
                if cx - dx >= 0:
                    directions.append((cx - dx, cy))
            # Right
            for dx in range(1, 4):
                if cx + dx < 8:
                    directions.append((cx + dx, cy))
            
            for nx, ny in directions:
                if grid[ny][nx] == 1 and not exploded[ny][nx]:
                    exploded[ny][nx] = True
                    queue.append((nx, ny))
        
        # Remove exploded bombs from grid
        for i in range(8):
            for j in range(8):
                if exploded[i][j]:
                    grid[i][j] = 0
        
        # Output result
        print(f""Data {dataset_num}:"")
        for row in grid:
            print(''.join(map(str, row)))

solve()
",0
p00071,"爆弾の連鎖
縦 8、横 8 のマスからなる図1 のような平面があります。その平面上に、いくつかの爆弾が置かれています。図2 にその例を示します（● = 爆弾）。
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
●
□
□
●
□
□
□
□
□
□
●
□
□
●
□
□
□
●
□
□
●
□
□
●
□
□
□
●
□
□
●
□
□
□
□
□
□
□
□
□
□
●
□
□
□
●
□
●
□
□
□
●
□
□
●
□
●
□
□
●
□
図1
図2
爆弾が爆発すると、その爆弾の上下左右 3 マスに爆風の影響が及び、それらのマスに置かれている爆弾も連鎖的に爆発します。たとえば、図 3 に示す爆弾が爆発すると図 4 の■のマスに爆風の影響が及びます。
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
●
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
□
■
□
□
□
□
□
□
□
■
□
□
□
□
□
□
□
■
□
□
□
□
■
■
■
●
■
■
■
□
□
□
□
■
□
□
□
□
□
□
□
■
□
□
□
□
図3
図4
爆弾が置かれている状態と最初に爆発する爆弾の位置を読み込んで、最終的な平面の状態を出力するプログラムを作成してください。
Input
入力は以下の形式で与えられます。
n
（空行）
データセット 1
（空行）
データセット 2
..
..
データセット
n
１行目にデータセットの数
n
(
n
≤ 20) が与えられます。続いて
n
個のデータセットが与えられます。各データセットの直前に１つの空行が与えられます。各データセットは以下の形式で与えられます。
g
1,1
g
2,1
...
g
8,1
g
1,2
g
2,2
...
g
8,2
:
g
1,8
g
2,8
...
g
8,8
X
Y
最初の８行に、平面を表す８つの文字列が与えられます。各文字列は８文字からなる数列で、爆弾が置かれているマスを 1、置かれていないマスを 0 で表します。
続く２行で、最初に爆発する爆弾の
X
座標と
Y
座標が与えられます。左上、左下、右上、右下の座標が、それぞれ、(1, 1)、(1, 8)、(8, 1)、(8, 8) です。例えば、図 4 に示す爆弾が最初に爆発するとき、与えられる座標は (4, 6) です。
Output
各データセットについて以下のように出力して下さい。
爆発しないで残った爆弾のあるマスを 1、爆弾のないマスを 0 で表現することとします。平面の一行を数字 8 個からなる一行とし 8 行の文字列で最終的な平面の状態を出力してください。各データセットの先頭は、サンプル出力のように Data
x
: から出力しなければなりません。ここで、
x
はデータセットの番号です。
Sample Input
2

00010010
00000100
10001001
00100010
01000000
00001000
10100010
01010010
2
5

00010010
00000100
10001001
00100010
01000000
00001000
10100010
01010010
2
5
Output for the Sample Input
Data 1:
00000000
00000100
10001001
00100000
00000000
00001000
10100000
00000000
Data 2:
00000000
00000100
10001001
00100000
00000000
00001000
10100000
00000000",Python,"def bomb(x,y):
    s=M[y]
    if s[x]==""0"":return
    M[y]=s[:x]+""0""+s[x+1:]
    R=[-3,-2,-1,1,2,3]
    for e in R:
        bomb(x+e,y)
        bomb(x,y+e)
    return

A=range(3,11)
M=[""00000000000000"" for i in range(14)]
z=""000""
n=input()
for i in range(n):
    s=raw_input()
    for j in A:
        M[j]=z+raw_input()+z
    x=input()+2
    y=input()+2
    bomb(x,y)
    print ""Data %d:"" %(i+1)
    for j in A:
        print M[j][3:-3]",1
p00072,"灯篭
会津若松市は「歴史の町」として知られています。今から約 400 年前、蒲生氏郷により城下町の骨格が作られましたが、その後、徳川三代将軍家光公の異母弟「保科正之」公を藩祖とする会津藩 23 万石の中心都市として発展しました。今でも市内のいたるところに史跡や昔日の面影が残っているため、毎年、全国から多くの観光客が訪れています。
今年は、ＮＨＫ大河ドラマで「新選組！」が放送されているため、新選組ゆかりの地(*1)として、大幅に観光客が増加しています。そこで市では、市内に点在する史跡を結ぶ通り沿いに 100 m 間隔で灯篭を設置して飾りたてることにしました。灯篭を飾ってある通りを辿れば市内の全ての史跡に到達できるように設置することが条件ですが、一筆書きでたどれる必要はありません。しかし、予算が限られているので設置する灯篭の数を最小限にする必要があります。
史跡と史跡を結ぶ通りのデータを読み込んで、必要最小限の灯篭の数を出力するプログラムを作成して下さい。ただし、史跡と史跡の間の距離は 200 m 以上で、100 の倍数で与えられます。おのおのの史跡から一番近い灯篭までの距離は 100 m で、市内の史跡は 100 箇所以内です。史跡自身には灯篭を設置する必要はありません。
(*1) 新選組は会津藩御預という形で発足、白虎隊の悲劇で知られる会津戊辰戦争に参戦、市内天寧寺に土方歳三が近藤勇の墓を建立
Input
複数のデータセットが与えられます。各データセットは以下の形式で与えられます。
n
m
a
1
,
b
1
,
d
1
a
2
,
b
2
,
d
2
:
a
m
,
b
m
,
d
m
各データセットの最初の 1 行には史跡の箇所数
n
が与えられます。続いて史跡と史跡を結ぶ通りの数
m
が与えられます。続く
m
行に カンマで区切られてた3 つの数数
a
i
,
b
i
,
d
i
が与えられます。
a
i
,
b
i
は史跡の番号です。史跡の番号は 0 番から
n
- 1 番まで振られています。
a
i
b
i
はそれらを結ぶ通りがあることを示し、
d
i
は
a
i
b
i
間の道路の距離を表します。
n
が 0 のとき入力の最後とします。データセットの数は 20 を超えません。
Output
各データセットに対して、必要最小限の灯篭の数を１行に出力して下さい。
Sample Input
4
4
0,1,1500
0,2,2000
1,2,600
1,3,500
0
Output for the Sample Input
23",C,"#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#define MAX_N 100
#define MAX_M 5000

typedef struct {
    int u, v, w;
} Edge;

int parent[MAX_N];
Edge edges[MAX_M];

int find(int x) {
    if (parent[x] != x) {
        parent[x] = find(parent[x]);
    }
    return parent[x];
}

void unite(int x, int y) {
    int px = find(x);
    int py = find(y);
    if (px != py) {
        parent[px] = py;
    }
}

int compare(const void *a, const void *b) {
    Edge *ea = (Edge *)a;
    Edge *eb = (Edge *)b;
    return ea->w - eb->w;
}

int main() {
    int n, m;
    
    while (scanf(""%d"", &n) == 1 && n != 0) {
        scanf(""%d"", &m);
        
        for (int i = 0; i < m; i++) {
            int a, b, d;
            scanf(""%d,%d,%d"", &a, &b, &d);
            edges[i].u = a;
            edges[i].v = b;
            edges[i].w = d;
        }
        
        qsort(edges, m, sizeof(Edge), compare);
        
        for (int i = 0; i < n; i++) {
            parent[i] = i;
        }
        
        int total_lanterns = 0;
        int edges_used = 0;
        
        for (int i = 0; i < m && edges_used < n - 1; i++) {
            int u = edges[i].u;
            int v = edges[i].v;
            int w = edges[i].w;
            
            if (find(u) != find(v)) {
                unite(u, v);
                edges_used++;
                total_lanterns += (w / 100 - 1);
            }
        }
        
        printf(""%d\n"", total_lanterns);
    }
    
    return 0;
}
",0
p00072,"灯篭
会津若松市は「歴史の町」として知られています。今から約 400 年前、蒲生氏郷により城下町の骨格が作られましたが、その後、徳川三代将軍家光公の異母弟「保科正之」公を藩祖とする会津藩 23 万石の中心都市として発展しました。今でも市内のいたるところに史跡や昔日の面影が残っているため、毎年、全国から多くの観光客が訪れています。
今年は、ＮＨＫ大河ドラマで「新選組！」が放送されているため、新選組ゆかりの地(*1)として、大幅に観光客が増加しています。そこで市では、市内に点在する史跡を結ぶ通り沿いに 100 m 間隔で灯篭を設置して飾りたてることにしました。灯篭を飾ってある通りを辿れば市内の全ての史跡に到達できるように設置することが条件ですが、一筆書きでたどれる必要はありません。しかし、予算が限られているので設置する灯篭の数を最小限にする必要があります。
史跡と史跡を結ぶ通りのデータを読み込んで、必要最小限の灯篭の数を出力するプログラムを作成して下さい。ただし、史跡と史跡の間の距離は 200 m 以上で、100 の倍数で与えられます。おのおのの史跡から一番近い灯篭までの距離は 100 m で、市内の史跡は 100 箇所以内です。史跡自身には灯篭を設置する必要はありません。
(*1) 新選組は会津藩御預という形で発足、白虎隊の悲劇で知られる会津戊辰戦争に参戦、市内天寧寺に土方歳三が近藤勇の墓を建立
Input
複数のデータセットが与えられます。各データセットは以下の形式で与えられます。
n
m
a
1
,
b
1
,
d
1
a
2
,
b
2
,
d
2
:
a
m
,
b
m
,
d
m
各データセットの最初の 1 行には史跡の箇所数
n
が与えられます。続いて史跡と史跡を結ぶ通りの数
m
が与えられます。続く
m
行に カンマで区切られてた3 つの数数
a
i
,
b
i
,
d
i
が与えられます。
a
i
,
b
i
は史跡の番号です。史跡の番号は 0 番から
n
- 1 番まで振られています。
a
i
b
i
はそれらを結ぶ通りがあることを示し、
d
i
は
a
i
b
i
間の道路の距離を表します。
n
が 0 のとき入力の最後とします。データセットの数は 20 を超えません。
Output
各データセットに対して、必要最小限の灯篭の数を１行に出力して下さい。
Sample Input
4
4
0,1,1500
0,2,2000
1,2,600
1,3,500
0
Output for the Sample Input
23",C,"#include <stdio.h>
#define INF 1000000

int cost[100][100];
int mincost[100];
char used[100];
int V;

int min(int a, int b){
	if (a > b){
		return (b);
	}
	return (a);
}

int prim(void)
{
	int i;
	int res;
	int u, v;
	
	for (i = 0; i < V; i++){
		mincost[i] = INF;
		used[i] = 0;
	}
	
	mincost[0] = 0;
	res = 0;
	
	while (1){
		v = -1;
		for (u = 0; u < V; u++){
			if (!used[u] && (v == -1 || mincost[u] < mincost[v])){
				v = u;
			}
		}
		
		if (v == -1){
			break;
		}
		used[v] = 1;
		res += mincost[v];
		
		for (u = 0; u < V; u++){
			mincost[u] = min(mincost[u], cost[v][u]);
		}
	}
	return (res);
}

int main(void)
{
	int num, from, to, dist;
	int i,j;
	
	while (1){
		scanf(""%d"", &V);
		if (V == 0){
			break;
		}
		scanf(""%d"", &num);
		
		for (i = 0; i < num; i++){
			for (j = 0; j < num; j++){
				cost[i][j] = INF;
			}
		}
		
		for (i = 0; i < num; i++){
			scanf(""%d,%d,%d"", &from, &to, &dist);
			cost[from][to] = cost[to][from] = (dist / 100) - 1;
		}
		
		printf(""%d\n"", prim());
	}
	return (0);
}",1
p00072,"灯篭
会津若松市は「歴史の町」として知られています。今から約 400 年前、蒲生氏郷により城下町の骨格が作られましたが、その後、徳川三代将軍家光公の異母弟「保科正之」公を藩祖とする会津藩 23 万石の中心都市として発展しました。今でも市内のいたるところに史跡や昔日の面影が残っているため、毎年、全国から多くの観光客が訪れています。
今年は、ＮＨＫ大河ドラマで「新選組！」が放送されているため、新選組ゆかりの地(*1)として、大幅に観光客が増加しています。そこで市では、市内に点在する史跡を結ぶ通り沿いに 100 m 間隔で灯篭を設置して飾りたてることにしました。灯篭を飾ってある通りを辿れば市内の全ての史跡に到達できるように設置することが条件ですが、一筆書きでたどれる必要はありません。しかし、予算が限られているので設置する灯篭の数を最小限にする必要があります。
史跡と史跡を結ぶ通りのデータを読み込んで、必要最小限の灯篭の数を出力するプログラムを作成して下さい。ただし、史跡と史跡の間の距離は 200 m 以上で、100 の倍数で与えられます。おのおのの史跡から一番近い灯篭までの距離は 100 m で、市内の史跡は 100 箇所以内です。史跡自身には灯篭を設置する必要はありません。
(*1) 新選組は会津藩御預という形で発足、白虎隊の悲劇で知られる会津戊辰戦争に参戦、市内天寧寺に土方歳三が近藤勇の墓を建立
Input
複数のデータセットが与えられます。各データセットは以下の形式で与えられます。
n
m
a
1
,
b
1
,
d
1
a
2
,
b
2
,
d
2
:
a
m
,
b
m
,
d
m
各データセットの最初の 1 行には史跡の箇所数
n
が与えられます。続いて史跡と史跡を結ぶ通りの数
m
が与えられます。続く
m
行に カンマで区切られてた3 つの数数
a
i
,
b
i
,
d
i
が与えられます。
a
i
,
b
i
は史跡の番号です。史跡の番号は 0 番から
n
- 1 番まで振られています。
a
i
b
i
はそれらを結ぶ通りがあることを示し、
d
i
は
a
i
b
i
間の道路の距離を表します。
n
が 0 のとき入力の最後とします。データセットの数は 20 を超えません。
Output
各データセットに対して、必要最小限の灯篭の数を１行に出力して下さい。
Sample Input
4
4
0,1,1500
0,2,2000
1,2,600
1,3,500
0
Output for the Sample Input
23",Java,"import java.util.*;

public class Main {
    static class Edge {
        int to, dist;
        Edge(int to, int dist) {
            this.to = to;
            this.dist = dist;
        }
    }
    
    static class UnionFind {
        int[] parent, rank;
        
        UnionFind(int n) {
            parent = new int[n];
            rank = new int[n];
            for (int i = 0; i < n; i++) {
                parent[i] = i;
            }
        }
        
        int find(int x) {
            if (parent[x] != x) {
                parent[x] = find(parent[x]);
            }
            return parent[x];
        }
        
        void union(int x, int y) {
            int px = find(x);
            int py = find(y);
            if (px == py) return;
            
            if (rank[px] < rank[py]) {
                parent[px] = py;
            } else if (rank[px] > rank[py]) {
                parent[py] = px;
            } else {
                parent[py] = px;
                rank[px]++;
            }
        }
        
        boolean connected(int x, int y) {
            return find(x) == find(y);
        }
    }
    
    static class MSTEdge implements Comparable<MSTEdge> {
        int u, v, dist;
        MSTEdge(int u, int v, int dist) {
            this.u = u;
            this.v = v;
            this.dist = dist;
        }
        
        public int compareTo(MSTEdge other) {
            return this.dist - other.dist;
        }
    }
    
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        
        while (true) {
            int n = sc.nextInt();
            if (n == 0) break;
            
            int m = sc.nextInt();
            sc.nextLine();
            
            List<MSTEdge> edges = new ArrayList<>();
            
            for (int i = 0; i < m; i++) {
                String line = sc.nextLine();
                String[] parts = line.split("","");
                int a = Integer.parseInt(parts[0]);
                int b = Integer.parseInt(parts[1]);
                int d = Integer.parseInt(parts[2]);
                edges.add(new MSTEdge(a, b, d));
            }
            
            // Kruskal's algorithm to find MST
            Collections.sort(edges);
            UnionFind uf = new UnionFind(n);
            
            int totalLanterns = 0;
            
            for (MSTEdge edge : edges) {
                if (!uf.connected(edge.u, edge.v)) {
                    uf.union(edge.u, edge.v);
                    // Calculate lanterns needed for this edge
                    // Distance is in meters, lanterns are every 100m
                    // First lantern at 100m from one end, last at 100m from other end
                    // For distance d, we need (d/100 - 1) lanterns
                    int lanterns = edge.dist / 100 - 1;
                    totalLanterns += lanterns;
                }
            }
            
            System.out.println(totalLanterns);
        }
        
        sc.close();
    }
}
",0
p00072,"灯篭
会津若松市は「歴史の町」として知られています。今から約 400 年前、蒲生氏郷により城下町の骨格が作られましたが、その後、徳川三代将軍家光公の異母弟「保科正之」公を藩祖とする会津藩 23 万石の中心都市として発展しました。今でも市内のいたるところに史跡や昔日の面影が残っているため、毎年、全国から多くの観光客が訪れています。
今年は、ＮＨＫ大河ドラマで「新選組！」が放送されているため、新選組ゆかりの地(*1)として、大幅に観光客が増加しています。そこで市では、市内に点在する史跡を結ぶ通り沿いに 100 m 間隔で灯篭を設置して飾りたてることにしました。灯篭を飾ってある通りを辿れば市内の全ての史跡に到達できるように設置することが条件ですが、一筆書きでたどれる必要はありません。しかし、予算が限られているので設置する灯篭の数を最小限にする必要があります。
史跡と史跡を結ぶ通りのデータを読み込んで、必要最小限の灯篭の数を出力するプログラムを作成して下さい。ただし、史跡と史跡の間の距離は 200 m 以上で、100 の倍数で与えられます。おのおのの史跡から一番近い灯篭までの距離は 100 m で、市内の史跡は 100 箇所以内です。史跡自身には灯篭を設置する必要はありません。
(*1) 新選組は会津藩御預という形で発足、白虎隊の悲劇で知られる会津戊辰戦争に参戦、市内天寧寺に土方歳三が近藤勇の墓を建立
Input
複数のデータセットが与えられます。各データセットは以下の形式で与えられます。
n
m
a
1
,
b
1
,
d
1
a
2
,
b
2
,
d
2
:
a
m
,
b
m
,
d
m
各データセットの最初の 1 行には史跡の箇所数
n
が与えられます。続いて史跡と史跡を結ぶ通りの数
m
が与えられます。続く
m
行に カンマで区切られてた3 つの数数
a
i
,
b
i
,
d
i
が与えられます。
a
i
,
b
i
は史跡の番号です。史跡の番号は 0 番から
n
- 1 番まで振られています。
a
i
b
i
はそれらを結ぶ通りがあることを示し、
d
i
は
a
i
b
i
間の道路の距離を表します。
n
が 0 のとき入力の最後とします。データセットの数は 20 を超えません。
Output
各データセットに対して、必要最小限の灯篭の数を１行に出力して下さい。
Sample Input
4
4
0,1,1500
0,2,2000
1,2,600
1,3,500
0
Output for the Sample Input
23",Java,"import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.Arrays;

public class Main{
	public static void main(String[] args)throws IOException{
		InputStreamReader isr = new InputStreamReader(System.in);
		BufferedReader reader = new BufferedReader(isr);
		StringBuilder sb = new StringBuilder();
		int n = 0, m = 0, a = 0, b = 0, c = 0;
		
		while(!(sb.append(reader.readLine())).equals(""0"")){
			n = Integer.valueOf(sb.toString());
			m = Integer.valueOf(reader.readLine());
			
			int map[][] = new int[n][n];
			boolean visit[] = new boolean[n];
			for(int i = 0;i < n; i++) Arrays.fill(map[i], 1 << 29);
			for(int i = 0; i < m; i++){
				sb.setLength(0);
				sb.append(reader.readLine());
				a = Integer.valueOf(sb.toString().split("","")[0]);
				b = Integer.valueOf(sb.toString().split("","")[1]);
				c = (Integer.valueOf(sb.toString().split("","")[2]) - 100) / 100;
				map[a][b] = map[b][a] = c;
			}
			c = 0;
			visit[0] = true;
			for(int x = 0; x < n - 1; x++){
				m = 1 << 29;
				for(int i = 0; i < n; i++){
					if(map[0][i] < m && !visit[i]){
						m = map[0][i];
						b = i;
					}
				}
				visit[b] = true;
				c += map[0][b];
				for(int i = 0; i < n; i++){
					map[0][i] = Math.min(map[0][i], map[b][i]);
				}
			}
			System.out.println(c);
			sb.setLength(0);
		}
		reader.close();
	}
}",1
p00072,"灯篭
会津若松市は「歴史の町」として知られています。今から約 400 年前、蒲生氏郷により城下町の骨格が作られましたが、その後、徳川三代将軍家光公の異母弟「保科正之」公を藩祖とする会津藩 23 万石の中心都市として発展しました。今でも市内のいたるところに史跡や昔日の面影が残っているため、毎年、全国から多くの観光客が訪れています。
今年は、ＮＨＫ大河ドラマで「新選組！」が放送されているため、新選組ゆかりの地(*1)として、大幅に観光客が増加しています。そこで市では、市内に点在する史跡を結ぶ通り沿いに 100 m 間隔で灯篭を設置して飾りたてることにしました。灯篭を飾ってある通りを辿れば市内の全ての史跡に到達できるように設置することが条件ですが、一筆書きでたどれる必要はありません。しかし、予算が限られているので設置する灯篭の数を最小限にする必要があります。
史跡と史跡を結ぶ通りのデータを読み込んで、必要最小限の灯篭の数を出力するプログラムを作成して下さい。ただし、史跡と史跡の間の距離は 200 m 以上で、100 の倍数で与えられます。おのおのの史跡から一番近い灯篭までの距離は 100 m で、市内の史跡は 100 箇所以内です。史跡自身には灯篭を設置する必要はありません。
(*1) 新選組は会津藩御預という形で発足、白虎隊の悲劇で知られる会津戊辰戦争に参戦、市内天寧寺に土方歳三が近藤勇の墓を建立
Input
複数のデータセットが与えられます。各データセットは以下の形式で与えられます。
n
m
a
1
,
b
1
,
d
1
a
2
,
b
2
,
d
2
:
a
m
,
b
m
,
d
m
各データセットの最初の 1 行には史跡の箇所数
n
が与えられます。続いて史跡と史跡を結ぶ通りの数
m
が与えられます。続く
m
行に カンマで区切られてた3 つの数数
a
i
,
b
i
,
d
i
が与えられます。
a
i
,
b
i
は史跡の番号です。史跡の番号は 0 番から
n
- 1 番まで振られています。
a
i
b
i
はそれらを結ぶ通りがあることを示し、
d
i
は
a
i
b
i
間の道路の距離を表します。
n
が 0 のとき入力の最後とします。データセットの数は 20 を超えません。
Output
各データセットに対して、必要最小限の灯篭の数を１行に出力して下さい。
Sample Input
4
4
0,1,1500
0,2,2000
1,2,600
1,3,500
0
Output for the Sample Input
23",Python,"import sys
from collections import defaultdict

def find(parent, x):
    if parent[x] != x:
        parent[x] = find(parent, parent[x])
    return parent[x]

def union(parent, rank, x, y):
    px, py = find(parent, x), find(parent, y)
    if px == py:
        return False
    if rank[px] < rank[py]:
        px, py = py, px
    parent[py] = px
    if rank[px] == rank[py]:
        rank[px] += 1
    return True

def kruskal_mst(n, edges):
    parent = list(range(n))
    rank = [0] * n
    edges.sort(key=lambda x: x[2])
    mst_edges = []
    
    for a, b, d in edges:
        if union(parent, rank, a, b):
            mst_edges.append((a, b, d))
            if len(mst_edges) == n - 1:
                break
    
    return mst_edges

while True:
    n = int(input())
    if n == 0:
        break
    
    m = int(input())
    edges = []
    
    for _ in range(m):
        line = input().strip()
        a, b, d = map(int, line.split(','))
        edges.append((a, b, d))
    
    # Find MST
    mst_edges = kruskal_mst(n, edges)
    
    # Calculate total lanterns needed
    total_lanterns = 0
    for a, b, d in mst_edges:
        # Distance between two sites is d meters
        # Lanterns are placed every 100m
        # First lantern is 100m from site a, last is 100m from site b
        # So number of lanterns = d/100 - 1
        lanterns = d // 100 - 1
        total_lanterns += lanterns
    
    print(total_lanterns)
",0
p00072,"灯篭
会津若松市は「歴史の町」として知られています。今から約 400 年前、蒲生氏郷により城下町の骨格が作られましたが、その後、徳川三代将軍家光公の異母弟「保科正之」公を藩祖とする会津藩 23 万石の中心都市として発展しました。今でも市内のいたるところに史跡や昔日の面影が残っているため、毎年、全国から多くの観光客が訪れています。
今年は、ＮＨＫ大河ドラマで「新選組！」が放送されているため、新選組ゆかりの地(*1)として、大幅に観光客が増加しています。そこで市では、市内に点在する史跡を結ぶ通り沿いに 100 m 間隔で灯篭を設置して飾りたてることにしました。灯篭を飾ってある通りを辿れば市内の全ての史跡に到達できるように設置することが条件ですが、一筆書きでたどれる必要はありません。しかし、予算が限られているので設置する灯篭の数を最小限にする必要があります。
史跡と史跡を結ぶ通りのデータを読み込んで、必要最小限の灯篭の数を出力するプログラムを作成して下さい。ただし、史跡と史跡の間の距離は 200 m 以上で、100 の倍数で与えられます。おのおのの史跡から一番近い灯篭までの距離は 100 m で、市内の史跡は 100 箇所以内です。史跡自身には灯篭を設置する必要はありません。
(*1) 新選組は会津藩御預という形で発足、白虎隊の悲劇で知られる会津戊辰戦争に参戦、市内天寧寺に土方歳三が近藤勇の墓を建立
Input
複数のデータセットが与えられます。各データセットは以下の形式で与えられます。
n
m
a
1
,
b
1
,
d
1
a
2
,
b
2
,
d
2
:
a
m
,
b
m
,
d
m
各データセットの最初の 1 行には史跡の箇所数
n
が与えられます。続いて史跡と史跡を結ぶ通りの数
m
が与えられます。続く
m
行に カンマで区切られてた3 つの数数
a
i
,
b
i
,
d
i
が与えられます。
a
i
,
b
i
は史跡の番号です。史跡の番号は 0 番から
n
- 1 番まで振られています。
a
i
b
i
はそれらを結ぶ通りがあることを示し、
d
i
は
a
i
b
i
間の道路の距離を表します。
n
が 0 のとき入力の最後とします。データセットの数は 20 を超えません。
Output
各データセットに対して、必要最小限の灯篭の数を１行に出力して下さい。
Sample Input
4
4
0,1,1500
0,2,2000
1,2,600
1,3,500
0
Output for the Sample Input
23",Python,"while 1:
  n=int(input())
  if not n:break
  X={0}
  Y=set(range(n))-X
  s=0
  l=[tuple(map(int,input().split("",""))) for _ in range(int(input()))]

  while Y:
    cd=[i for i in l if (i[0] in X and i[1] in Y) or (i[0] in Y and i[1] in X)]
    cd=sorted(cd,key=lambda x:x[2])[0]
    if cd[0] in X and cd[1] in Y:
      X.add(cd[1])
      Y=Y-X
    elif cd[0] in Y and cd[1] in X:
      X.add(cd[0])
      Y=Y-X
    s+=int(cd[2]/100-1)
  print(s)
",1
p00074,"ビデオテープ
標準録画で 120 分のビデオテープがあります。テープを完全に巻き戻した状態でビデオデッキのカウンタを 00:00:00 にし、標準録画モードで録画したところ、あるカウンタ値になりました。このカウンタ値（時、分、秒）を入力し、残りのテープの長さ（録画可能時間）を求め、時：分：秒の形式で出力するプログラムを作成して下さい。
ただし、2 時間（120分）以内の入力とします。なお、テープ残量は標準録画モードと 3  倍録画モードの場合の２通りを計算し、出力例のように時、分、秒とも 2 桁ずつ出力します。また ""05"" のように 10 の位が 0 の場合は、""0"" をつけてください。
入力
複数のデータセットが与えられます。各データセットは以下のとおりです。
T
H
S
T
,
H
,
S
はそれぞれ時、分、秒を表す整数です。
T
,
H
,
S
がすべて -1 のとき入力の終わりとします。データセットの数は 50 を超えません。
出力
各データセットごとに
1 行目に、テープの残りを標準録画した場合の録画可能時間の時、分、秒を半角コロン区切りで、
2 行目に、テープの残りを３倍録画した場合の録画可能時間の時、分、秒を半角コロン区切りで
出力して下さい。
Sample Input
1 30 0
-1 -1 -1
Output for the Sample Input
00:30:00
01:30:00",C,"#include <stdio.h>

int main() {
    int T, H, S;
    
    while(1) {
        scanf(""%d %d %d"", &T, &H, &S);
        
        if(T == -1 && H == -1 && S == -1) {
            break;
        }
        
        // Convert current time to seconds
        int current_seconds = T * 3600 + H * 60 + S;
        
        // Total tape is 120 minutes = 7200 seconds
        int total_seconds = 120 * 60;
        
        // Remaining seconds
        int remaining_seconds = total_seconds - current_seconds;
        
        // Standard mode: remaining time as is
        int std_hours = remaining_seconds / 3600;
        int std_minutes = (remaining_seconds % 3600) / 60;
        int std_seconds = remaining_seconds % 60;
        
        // 3x mode: 3 times the remaining time
        int triple_total_seconds = remaining_seconds * 3;
        int triple_hours = triple_total_seconds / 3600;
        int triple_minutes = (triple_total_seconds % 3600) / 60;
        int triple_seconds = triple_total_seconds % 60;
        
        printf(""%02d:%02d:%02d\n"", std_hours, std_minutes, std_seconds);
        printf(""%02d:%02d:%02d\n"", triple_hours, triple_minutes, triple_seconds);
    }
    
    return 0;
}
",0
p00074,"ビデオテープ
標準録画で 120 分のビデオテープがあります。テープを完全に巻き戻した状態でビデオデッキのカウンタを 00:00:00 にし、標準録画モードで録画したところ、あるカウンタ値になりました。このカウンタ値（時、分、秒）を入力し、残りのテープの長さ（録画可能時間）を求め、時：分：秒の形式で出力するプログラムを作成して下さい。
ただし、2 時間（120分）以内の入力とします。なお、テープ残量は標準録画モードと 3  倍録画モードの場合の２通りを計算し、出力例のように時、分、秒とも 2 桁ずつ出力します。また ""05"" のように 10 の位が 0 の場合は、""0"" をつけてください。
入力
複数のデータセットが与えられます。各データセットは以下のとおりです。
T
H
S
T
,
H
,
S
はそれぞれ時、分、秒を表す整数です。
T
,
H
,
S
がすべて -1 のとき入力の終わりとします。データセットの数は 50 を超えません。
出力
各データセットごとに
1 行目に、テープの残りを標準録画した場合の録画可能時間の時、分、秒を半角コロン区切りで、
2 行目に、テープの残りを３倍録画した場合の録画可能時間の時、分、秒を半角コロン区切りで
出力して下さい。
Sample Input
1 30 0
-1 -1 -1
Output for the Sample Input
00:30:00
01:30:00",C,"#include <stdio.h>

void timePrint(int time);

int main(void){
  int t, h, s;
  int time;

  scanf(""%d%d%d"", &t, &h, &s);
  while(!(t == -1 && h == -1 && s == -1)){
    time = t*3600 + h*60 + s;
    timePrint(7200-time);
    timePrint(7200-time/3);
    scanf(""%d%d%d"", &t, &h, &s);
  }
  return 0;
}

void timePrint(int time){
  printf(""%02d:"", time/3600);
  time %= 3600;
  printf(""%02d:"", time/60);
  time %= 60;
  printf(""%02d\n"", time);
  return;
}",1
p00074,"ビデオテープ
標準録画で 120 分のビデオテープがあります。テープを完全に巻き戻した状態でビデオデッキのカウンタを 00:00:00 にし、標準録画モードで録画したところ、あるカウンタ値になりました。このカウンタ値（時、分、秒）を入力し、残りのテープの長さ（録画可能時間）を求め、時：分：秒の形式で出力するプログラムを作成して下さい。
ただし、2 時間（120分）以内の入力とします。なお、テープ残量は標準録画モードと 3  倍録画モードの場合の２通りを計算し、出力例のように時、分、秒とも 2 桁ずつ出力します。また ""05"" のように 10 の位が 0 の場合は、""0"" をつけてください。
入力
複数のデータセットが与えられます。各データセットは以下のとおりです。
T
H
S
T
,
H
,
S
はそれぞれ時、分、秒を表す整数です。
T
,
H
,
S
がすべて -1 のとき入力の終わりとします。データセットの数は 50 を超えません。
出力
各データセットごとに
1 行目に、テープの残りを標準録画した場合の録画可能時間の時、分、秒を半角コロン区切りで、
2 行目に、テープの残りを３倍録画した場合の録画可能時間の時、分、秒を半角コロン区切りで
出力して下さい。
Sample Input
1 30 0
-1 -1 -1
Output for the Sample Input
00:30:00
01:30:00",Java,"import java.util.Scanner;

public class Main {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        
        while (true) {
            int h = sc.nextInt();
            int m = sc.nextInt();
            int s = sc.nextInt();
            
            if (h == -1 && m == -1 && s == -1) {
                break;
            }
            
            // Convert current counter to seconds
            int usedSeconds = h * 3600 + m * 60 + s;
            
            // Total tape capacity in seconds (120 minutes)
            int totalSeconds = 120 * 60;
            
            // Remaining seconds
            int remainingSeconds = totalSeconds - usedSeconds;
            
            // Standard recording mode (remaining time as is)
            int stdHours = remainingSeconds / 3600;
            int stdMinutes = (remainingSeconds % 3600) / 60;
            int stdSeconds = remainingSeconds % 60;
            
            // 3x recording mode (remaining time * 3)
            int tripleSeconds = remainingSeconds * 3;
            int tripleHours = tripleSeconds / 3600;
            int tripleMinutes = (tripleSeconds % 3600) / 60;
            int tripleSecs = tripleSeconds % 60;
            
            System.out.printf(""%02d:%02d:%02d%n"", stdHours, stdMinutes, stdSeconds);
            System.out.printf(""%02d:%02d:%02d%n"", tripleHours, tripleMinutes, tripleSecs);
        }
        
        sc.close();
    }
}
",0
p00074,"ビデオテープ
標準録画で 120 分のビデオテープがあります。テープを完全に巻き戻した状態でビデオデッキのカウンタを 00:00:00 にし、標準録画モードで録画したところ、あるカウンタ値になりました。このカウンタ値（時、分、秒）を入力し、残りのテープの長さ（録画可能時間）を求め、時：分：秒の形式で出力するプログラムを作成して下さい。
ただし、2 時間（120分）以内の入力とします。なお、テープ残量は標準録画モードと 3  倍録画モードの場合の２通りを計算し、出力例のように時、分、秒とも 2 桁ずつ出力します。また ""05"" のように 10 の位が 0 の場合は、""0"" をつけてください。
入力
複数のデータセットが与えられます。各データセットは以下のとおりです。
T
H
S
T
,
H
,
S
はそれぞれ時、分、秒を表す整数です。
T
,
H
,
S
がすべて -1 のとき入力の終わりとします。データセットの数は 50 を超えません。
出力
各データセットごとに
1 行目に、テープの残りを標準録画した場合の録画可能時間の時、分、秒を半角コロン区切りで、
2 行目に、テープの残りを３倍録画した場合の録画可能時間の時、分、秒を半角コロン区切りで
出力して下さい。
Sample Input
1 30 0
-1 -1 -1
Output for the Sample Input
00:30:00
01:30:00",Java,"
import java.util.Scanner;

public class Main {

	public static void main(String[] args) {

		Scanner scanner = new Scanner(System.in);
		while (true) {
			int h = scanner.nextInt();
			int m = scanner.nextInt();
			int s = scanner.nextInt();
			if (h == -1 && m == -1 && s == -1) {
				break;
			}
			int sc = 7200 - (h * 3600 + m * 60 + s);
			int sc3 = sc * 3;
			System.out.println(String.format(""%02d:%02d:%02d"", sc / 3600,
					sc / 60 % 60, sc % 60));
			System.out.println(String.format(""%02d:%02d:%02d"", sc3 / 3600,
					sc3 / 60 % 60, sc3 % 60));
		}
	}
}",1
p00074,"ビデオテープ
標準録画で 120 分のビデオテープがあります。テープを完全に巻き戻した状態でビデオデッキのカウンタを 00:00:00 にし、標準録画モードで録画したところ、あるカウンタ値になりました。このカウンタ値（時、分、秒）を入力し、残りのテープの長さ（録画可能時間）を求め、時：分：秒の形式で出力するプログラムを作成して下さい。
ただし、2 時間（120分）以内の入力とします。なお、テープ残量は標準録画モードと 3  倍録画モードの場合の２通りを計算し、出力例のように時、分、秒とも 2 桁ずつ出力します。また ""05"" のように 10 の位が 0 の場合は、""0"" をつけてください。
入力
複数のデータセットが与えられます。各データセットは以下のとおりです。
T
H
S
T
,
H
,
S
はそれぞれ時、分、秒を表す整数です。
T
,
H
,
S
がすべて -1 のとき入力の終わりとします。データセットの数は 50 を超えません。
出力
各データセットごとに
1 行目に、テープの残りを標準録画した場合の録画可能時間の時、分、秒を半角コロン区切りで、
2 行目に、テープの残りを３倍録画した場合の録画可能時間の時、分、秒を半角コロン区切りで
出力して下さい。
Sample Input
1 30 0
-1 -1 -1
Output for the Sample Input
00:30:00
01:30:00",Python,"while True:
    T, H, S = map(int, input().split())
    if T == -1 and H == -1 and S == -1:
        break
    
    # Convert current counter to seconds
    current_seconds = T * 3600 + H * 60 + S
    
    # Total tape capacity in seconds (120 minutes)
    total_seconds = 120 * 60
    
    # Remaining tape in seconds
    remaining_seconds = total_seconds - current_seconds
    
    # Standard recording: remaining time is as is
    std_hours = remaining_seconds // 3600
    std_minutes = (remaining_seconds % 3600) // 60
    std_seconds = remaining_seconds % 60
    
    # 3x recording: can record 3 times the remaining tape time
    triple_total_seconds = remaining_seconds * 3
    triple_hours = triple_total_seconds // 3600
    triple_minutes = (triple_total_seconds % 3600) // 60
    triple_seconds = triple_total_seconds % 60
    
    print(f""{std_hours:02d}:{std_minutes:02d}:{std_seconds:02d}"")
    print(f""{triple_hours:02d}:{triple_minutes:02d}:{triple_seconds:02d}"")
",0
p00074,"ビデオテープ
標準録画で 120 分のビデオテープがあります。テープを完全に巻き戻した状態でビデオデッキのカウンタを 00:00:00 にし、標準録画モードで録画したところ、あるカウンタ値になりました。このカウンタ値（時、分、秒）を入力し、残りのテープの長さ（録画可能時間）を求め、時：分：秒の形式で出力するプログラムを作成して下さい。
ただし、2 時間（120分）以内の入力とします。なお、テープ残量は標準録画モードと 3  倍録画モードの場合の２通りを計算し、出力例のように時、分、秒とも 2 桁ずつ出力します。また ""05"" のように 10 の位が 0 の場合は、""0"" をつけてください。
入力
複数のデータセットが与えられます。各データセットは以下のとおりです。
T
H
S
T
,
H
,
S
はそれぞれ時、分、秒を表す整数です。
T
,
H
,
S
がすべて -1 のとき入力の終わりとします。データセットの数は 50 を超えません。
出力
各データセットごとに
1 行目に、テープの残りを標準録画した場合の録画可能時間の時、分、秒を半角コロン区切りで、
2 行目に、テープの残りを３倍録画した場合の録画可能時間の時、分、秒を半角コロン区切りで
出力して下さい。
Sample Input
1 30 0
-1 -1 -1
Output for the Sample Input
00:30:00
01:30:00",Python,"#!/usr/bin/python
# coding: utf-8

while True:
    h, m, s = map(int, raw_input().split())
    if h == m == s == -1:
        break

    full = 2 * 3600
    rest = full - (h * 3600 + m * 60 + s)

    h = int(rest / 3600)
    m = int((rest - h * 3600) / 60)
    s = rest - h * 3600 - m * 60 

    th = int(rest / 1200)
    tm = int((rest - th * 1200) / 20)
    ts = (rest - th * 1200 - tm * 20) * 3

    print ""{:02d}:{:02d}:{:02d}"".format(h, m, s)
    print ""{:02d}:{:02d}:{:02d}"".format(th, tm, ts)",1
p00076,"宝探し II
蔵を片付けていたら、先祖の宝のありかへの行き方を記した古文書が見つかりました。この古文書にはおおよそ次のような事が書かれていました。
1. まず、町外れの井戸から、真東に 1m の地点に立ち、まっすぐ井戸の方向を向け。
2. 右回りに 90 度向きを変え、1m 直進したら、まっすぐ井戸の方向を向け。
3. 右回りに 90 度向きを変え、1m 直進したら、まっすぐ井戸の方向を向け。
4.                   〃
5.                   〃
6.                   ：
2 行目以降は、全く同じことが書かれていました。あなたは、宝を探そうと思いましたが、厄介なことに気がつきました。昔と違い建物が邪魔をしていて、まっすぐ井戸の方向をむこうにも井戸が見えなかったり 1m 直進しようにも直進できなかったりします。さらに、この古文書ときたら、1000 行近くあり、古文書どおりの作業をすることは、かなりの時間と体力が要ります。しかしながら、幸運なことに、あなたはコンピュータを利用することができます。
古文書に書かれている行数
n
を入力して、宝のありかを出力するプログラムを作成してください。ただし、
n
は 2 以上 1,000 以下の正の整数とします。
入力
複数のデータセットが与えられます。各データセットとして、古文書の行数を表す１つの整数
n
が１行に与えられます。
入力は -1 で終わります。データセットの数は 50 を超えません。
出力
町外れの井戸から東に
x
(m)，北に
y
(m)の位置に宝があるとして、
各データセットごとに以下の形式で出力して下さい。
x
y
出力は実数とし、0.01 以下の誤差を含んでもよい。
Sample Input
3
6
-1
Output for the Sample Input
0.29 
1.71
-2.31 
0.80
参考
n
=2, 3, 4, 5, 6 の宝の位置",C,"#include <stdio.h>
#include <math.h>

int main() {
    int n;
    while (scanf(""%d"", &n) == 1 && n != -1) {
        double x = 1.0, y = 0.0;
        double wx = 0.0, wy = 0.0;
        
        for (int i = 2; i <= n; i++) {
            double dx = wx - x;
            double dy = wy - y;
            double dist = sqrt(dx * dx + dy * dy);
            
            double ux = dx / dist;
            double uy = dy / dist;
            
            double rx = -uy;
            double ry = ux;
            
            x = x + rx;
            y = y + ry;
        }
        
        printf(""%.2f\n%.2f\n"", x, y);
    }
    
    return 0;
}
",0
p00076,"宝探し II
蔵を片付けていたら、先祖の宝のありかへの行き方を記した古文書が見つかりました。この古文書にはおおよそ次のような事が書かれていました。
1. まず、町外れの井戸から、真東に 1m の地点に立ち、まっすぐ井戸の方向を向け。
2. 右回りに 90 度向きを変え、1m 直進したら、まっすぐ井戸の方向を向け。
3. 右回りに 90 度向きを変え、1m 直進したら、まっすぐ井戸の方向を向け。
4.                   〃
5.                   〃
6.                   ：
2 行目以降は、全く同じことが書かれていました。あなたは、宝を探そうと思いましたが、厄介なことに気がつきました。昔と違い建物が邪魔をしていて、まっすぐ井戸の方向をむこうにも井戸が見えなかったり 1m 直進しようにも直進できなかったりします。さらに、この古文書ときたら、1000 行近くあり、古文書どおりの作業をすることは、かなりの時間と体力が要ります。しかしながら、幸運なことに、あなたはコンピュータを利用することができます。
古文書に書かれている行数
n
を入力して、宝のありかを出力するプログラムを作成してください。ただし、
n
は 2 以上 1,000 以下の正の整数とします。
入力
複数のデータセットが与えられます。各データセットとして、古文書の行数を表す１つの整数
n
が１行に与えられます。
入力は -1 で終わります。データセットの数は 50 を超えません。
出力
町外れの井戸から東に
x
(m)，北に
y
(m)の位置に宝があるとして、
各データセットごとに以下の形式で出力して下さい。
x
y
出力は実数とし、0.01 以下の誤差を含んでもよい。
Sample Input
3
6
-1
Output for the Sample Input
0.29 
1.71
-2.31 
0.80
参考
n
=2, 3, 4, 5, 6 の宝の位置",C,"main(n){while(~scanf(""%d"",&n)){float x=1,y=0,r,t;for(;--n>0;x=t)r=hypot(x,y),t=x-y/r,y+=x/r;n+2&&printf(""%f\n%f\n"",x,y);}}",1
p00076,"宝探し II
蔵を片付けていたら、先祖の宝のありかへの行き方を記した古文書が見つかりました。この古文書にはおおよそ次のような事が書かれていました。
1. まず、町外れの井戸から、真東に 1m の地点に立ち、まっすぐ井戸の方向を向け。
2. 右回りに 90 度向きを変え、1m 直進したら、まっすぐ井戸の方向を向け。
3. 右回りに 90 度向きを変え、1m 直進したら、まっすぐ井戸の方向を向け。
4.                   〃
5.                   〃
6.                   ：
2 行目以降は、全く同じことが書かれていました。あなたは、宝を探そうと思いましたが、厄介なことに気がつきました。昔と違い建物が邪魔をしていて、まっすぐ井戸の方向をむこうにも井戸が見えなかったり 1m 直進しようにも直進できなかったりします。さらに、この古文書ときたら、1000 行近くあり、古文書どおりの作業をすることは、かなりの時間と体力が要ります。しかしながら、幸運なことに、あなたはコンピュータを利用することができます。
古文書に書かれている行数
n
を入力して、宝のありかを出力するプログラムを作成してください。ただし、
n
は 2 以上 1,000 以下の正の整数とします。
入力
複数のデータセットが与えられます。各データセットとして、古文書の行数を表す１つの整数
n
が１行に与えられます。
入力は -1 で終わります。データセットの数は 50 を超えません。
出力
町外れの井戸から東に
x
(m)，北に
y
(m)の位置に宝があるとして、
各データセットごとに以下の形式で出力して下さい。
x
y
出力は実数とし、0.01 以下の誤差を含んでもよい。
Sample Input
3
6
-1
Output for the Sample Input
0.29 
1.71
-2.31 
0.80
参考
n
=2, 3, 4, 5, 6 の宝の位置",Java,"import java.util.Scanner;

public class Main {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        
        while (true) {
            int n = sc.nextInt();
            if (n == -1) break;
            
            // Start at position (1, 0) - 1m east of the well at (0, 0)
            double x = 1.0;
            double y = 0.0;
            
            // Initial direction: facing the well (west)
            double dx = -1.0;
            double dy = 0.0;
            
            // Process steps 2 to n
            for (int i = 2; i <= n; i++) {
                // Turn right 90 degrees
                double newDx = dy;
                double newDy = -dx;
                dx = newDx;
                dy = newDy;
                
                // Move 1m forward
                x += dx;
                y += dy;
                
                // Face the well again
                double dist = Math.sqrt(x * x + y * y);
                dx = -x / dist;
                dy = -y / dist;
            }
            
            System.out.printf(""%.2f\n%.2f\n"", x, y);
        }
        
        sc.close();
    }
}
",0
p00076,"宝探し II
蔵を片付けていたら、先祖の宝のありかへの行き方を記した古文書が見つかりました。この古文書にはおおよそ次のような事が書かれていました。
1. まず、町外れの井戸から、真東に 1m の地点に立ち、まっすぐ井戸の方向を向け。
2. 右回りに 90 度向きを変え、1m 直進したら、まっすぐ井戸の方向を向け。
3. 右回りに 90 度向きを変え、1m 直進したら、まっすぐ井戸の方向を向け。
4.                   〃
5.                   〃
6.                   ：
2 行目以降は、全く同じことが書かれていました。あなたは、宝を探そうと思いましたが、厄介なことに気がつきました。昔と違い建物が邪魔をしていて、まっすぐ井戸の方向をむこうにも井戸が見えなかったり 1m 直進しようにも直進できなかったりします。さらに、この古文書ときたら、1000 行近くあり、古文書どおりの作業をすることは、かなりの時間と体力が要ります。しかしながら、幸運なことに、あなたはコンピュータを利用することができます。
古文書に書かれている行数
n
を入力して、宝のありかを出力するプログラムを作成してください。ただし、
n
は 2 以上 1,000 以下の正の整数とします。
入力
複数のデータセットが与えられます。各データセットとして、古文書の行数を表す１つの整数
n
が１行に与えられます。
入力は -1 で終わります。データセットの数は 50 を超えません。
出力
町外れの井戸から東に
x
(m)，北に
y
(m)の位置に宝があるとして、
各データセットごとに以下の形式で出力して下さい。
x
y
出力は実数とし、0.01 以下の誤差を含んでもよい。
Sample Input
3
6
-1
Output for the Sample Input
0.29 
1.71
-2.31 
0.80
参考
n
=2, 3, 4, 5, 6 の宝の位置",Java,"import java.util.Scanner;

public class Main {
	public static void main(String args[]) {
		Scanner sc = new Scanner(System.in);
		double x, y;
		int n;

		n = sc.nextInt();
		while (n != -1) {
			x = 1.0;
			y = 0.0;

			for (int i = 0; i < n; i++) {
				if (x == 0.0) {
					if (0 < y) {
						x -= 1.0;
					} else {
						x += 1.0;
					}
				} else if (y == 0.0) {
					if (0 < x) {
						y += 1.0;
					} else {
						y -= 1.0;
					}
				} else {
					double theta = Math.atan2(y, x) + Math.PI / 2;
					x += Math.cos(theta);
					y += Math.sin(theta);
				}
			}
			System.out.println(x);
			System.out.println(y);
			n = sc.nextInt();
		}		
	}
}",1
p00076,"宝探し II
蔵を片付けていたら、先祖の宝のありかへの行き方を記した古文書が見つかりました。この古文書にはおおよそ次のような事が書かれていました。
1. まず、町外れの井戸から、真東に 1m の地点に立ち、まっすぐ井戸の方向を向け。
2. 右回りに 90 度向きを変え、1m 直進したら、まっすぐ井戸の方向を向け。
3. 右回りに 90 度向きを変え、1m 直進したら、まっすぐ井戸の方向を向け。
4.                   〃
5.                   〃
6.                   ：
2 行目以降は、全く同じことが書かれていました。あなたは、宝を探そうと思いましたが、厄介なことに気がつきました。昔と違い建物が邪魔をしていて、まっすぐ井戸の方向をむこうにも井戸が見えなかったり 1m 直進しようにも直進できなかったりします。さらに、この古文書ときたら、1000 行近くあり、古文書どおりの作業をすることは、かなりの時間と体力が要ります。しかしながら、幸運なことに、あなたはコンピュータを利用することができます。
古文書に書かれている行数
n
を入力して、宝のありかを出力するプログラムを作成してください。ただし、
n
は 2 以上 1,000 以下の正の整数とします。
入力
複数のデータセットが与えられます。各データセットとして、古文書の行数を表す１つの整数
n
が１行に与えられます。
入力は -1 で終わります。データセットの数は 50 を超えません。
出力
町外れの井戸から東に
x
(m)，北に
y
(m)の位置に宝があるとして、
各データセットごとに以下の形式で出力して下さい。
x
y
出力は実数とし、0.01 以下の誤差を含んでもよい。
Sample Input
3
6
-1
Output for the Sample Input
0.29 
1.71
-2.31 
0.80
参考
n
=2, 3, 4, 5, 6 の宝の位置",Python,"import math

def solve(n):
    # Start at position (1, 0) - 1m east of the well
    x, y = 1.0, 0.0
    
    # Initial direction: facing the well (west)
    # We'll track the angle we're facing
    
    for step in range(2, n + 1):
        # Calculate direction to well from current position
        dx_to_well = -x
        dy_to_well = -y
        angle_to_well = math.atan2(dy_to_well, dx_to_well)
        
        # Turn right 90 degrees from facing the well
        new_angle = angle_to_well - math.pi / 2
        
        # Move 1m in that direction
        x += math.cos(new_angle)
        y += math.sin(new_angle)
    
    return x, y

while True:
    n = int(input())
    if n == -1:
        break
    
    x, y = solve(n)
    print(f""{x:.2f}"")
    print(f""{y:.2f}"")
",0
p00076,"宝探し II
蔵を片付けていたら、先祖の宝のありかへの行き方を記した古文書が見つかりました。この古文書にはおおよそ次のような事が書かれていました。
1. まず、町外れの井戸から、真東に 1m の地点に立ち、まっすぐ井戸の方向を向け。
2. 右回りに 90 度向きを変え、1m 直進したら、まっすぐ井戸の方向を向け。
3. 右回りに 90 度向きを変え、1m 直進したら、まっすぐ井戸の方向を向け。
4.                   〃
5.                   〃
6.                   ：
2 行目以降は、全く同じことが書かれていました。あなたは、宝を探そうと思いましたが、厄介なことに気がつきました。昔と違い建物が邪魔をしていて、まっすぐ井戸の方向をむこうにも井戸が見えなかったり 1m 直進しようにも直進できなかったりします。さらに、この古文書ときたら、1000 行近くあり、古文書どおりの作業をすることは、かなりの時間と体力が要ります。しかしながら、幸運なことに、あなたはコンピュータを利用することができます。
古文書に書かれている行数
n
を入力して、宝のありかを出力するプログラムを作成してください。ただし、
n
は 2 以上 1,000 以下の正の整数とします。
入力
複数のデータセットが与えられます。各データセットとして、古文書の行数を表す１つの整数
n
が１行に与えられます。
入力は -1 で終わります。データセットの数は 50 を超えません。
出力
町外れの井戸から東に
x
(m)，北に
y
(m)の位置に宝があるとして、
各データセットごとに以下の形式で出力して下さい。
x
y
出力は実数とし、0.01 以下の誤差を含んでもよい。
Sample Input
3
6
-1
Output for the Sample Input
0.29 
1.71
-2.31 
0.80
参考
n
=2, 3, 4, 5, 6 の宝の位置",Python,"for e in iter(input,'-1'):
 z=1
 for _ in[0]*~-int(e):d=z*1j;z+=d/abs(d)
 print(z.real)
 print(z.imag)
",1
p00077,"ランレングス
文字列が連続した場合、ある規則で文字を置き換え文字列を短くすることができます。たとえば、AAAA という文字列の場合、@4A と表現すれば 1 文字分圧縮されます。この規則で圧縮された文字列を入力してもとの文字列に復元するプログラムを作成してください。ただし、復元した文字列に＠文字は出現しないものとします。
また、原文の文字列は英大文字、英小文字、数字、記号であり 100 文字以内、連続する文字は 9 文字以内です。
入力
複数の文字列が与えられます。１行に１つの文字列が与えられます。文字列の数は 50 を超えません。
出力
文字列ごとに、各文字に対して復元した文字列を１行に出力して下さい。
Sample Input
ab@5C1@8050
@99+1=1@90
Output for the Sample Input
abCCCCC10000000050
999999999+1=1000000000",C,"#include <stdio.h>
#include <string.h>
#include <ctype.h>

int main() {
    char line[256];
    
    while (fgets(line, sizeof(line), stdin)) {
        int len = strlen(line);
        if (len > 0 && line[len-1] == '\n') {
            line[len-1] = '\0';
            len--;
        }
        
        int i = 0;
        while (i < len) {
            if (line[i] == '@') {
                i++;
                int count = line[i] - '0';
                i++;
                char ch = line[i];
                for (int j = 0; j < count; j++) {
                    putchar(ch);
                }
                i++;
            } else {
                putchar(line[i]);
                i++;
            }
        }
        putchar('\n');
    }
    
    return 0;
}
",0
p00077,"ランレングス
文字列が連続した場合、ある規則で文字を置き換え文字列を短くすることができます。たとえば、AAAA という文字列の場合、@4A と表現すれば 1 文字分圧縮されます。この規則で圧縮された文字列を入力してもとの文字列に復元するプログラムを作成してください。ただし、復元した文字列に＠文字は出現しないものとします。
また、原文の文字列は英大文字、英小文字、数字、記号であり 100 文字以内、連続する文字は 9 文字以内です。
入力
複数の文字列が与えられます。１行に１つの文字列が与えられます。文字列の数は 50 を超えません。
出力
文字列ごとに、各文字に対して復元した文字列を１行に出力して下さい。
Sample Input
ab@5C1@8050
@99+1=1@90
Output for the Sample Input
abCCCCC10000000050
999999999+1=1000000000",C,"#include <stdio.h>
#include <string.h>
#define LENGTH 1001

int main(void)
{
  char st[LENGTH];
  int i, j, k, l, m, check, fix, count, kosuu, decimal=1;
  int a, b, t=0;
  char ch;

  i = 0;
  while(scanf(""%1c"",&ch)!=EOF)
    {
      st[i] = ch;
      i++;
    }
  st[i+1] = 0;
  st[i+2] = 0;
  st[i+3] = 0;

  k = strlen(st);


  /*
  printf(""k = %d\n"",strlen(st));

  for(i=0;i<=strlen(st);i++)
    {
      printf(""st[%d] %d\n"",i,st[i]); 
      }
  */

  j = 1;
  count = 1;
  kosuu = 0;

  i = 0;
  t = 0;
  while(1)
    {
      if(st[i]=='@')
	{
	  kosuu = st[i+1]-48;
	  for(j=0;j<=kosuu-1;j++)
	    {
	      printf(""%c"",st[i+2]);
	    }
	  i = i + 3;
	}
      else if(st[i]==10)
	{
	  printf(""\n"");
	  i++;
	}
      else if(st[i]==0)
	{
	  break;
	}
      else
	{
	  printf(""%c"",st[i]);
	  i++;
	}
    }
  printf(""\n"");
  return 0;
}",1
p00077,"ランレングス
文字列が連続した場合、ある規則で文字を置き換え文字列を短くすることができます。たとえば、AAAA という文字列の場合、@4A と表現すれば 1 文字分圧縮されます。この規則で圧縮された文字列を入力してもとの文字列に復元するプログラムを作成してください。ただし、復元した文字列に＠文字は出現しないものとします。
また、原文の文字列は英大文字、英小文字、数字、記号であり 100 文字以内、連続する文字は 9 文字以内です。
入力
複数の文字列が与えられます。１行に１つの文字列が与えられます。文字列の数は 50 を超えません。
出力
文字列ごとに、各文字に対して復元した文字列を１行に出力して下さい。
Sample Input
ab@5C1@8050
@99+1=1@90
Output for the Sample Input
abCCCCC10000000050
999999999+1=1000000000",Java,"import java.util.Scanner;

public class Main {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        
        while (sc.hasNextLine()) {
            String line = sc.nextLine();
            StringBuilder result = new StringBuilder();
            
            int i = 0;
            while (i < line.length()) {
                if (line.charAt(i) == '@') {
                    // Found @ symbol, next character is count, character after that is the character to repeat
                    i++; // move past @
                    int count = line.charAt(i) - '0'; // get the count digit
                    i++; // move to the character to repeat
                    char charToRepeat = line.charAt(i);
                    
                    // Append the character 'count' times
                    for (int j = 0; j < count; j++) {
                        result.append(charToRepeat);
                    }
                    i++; // move past the repeated character
                } else {
                    // Regular character, just append it
                    result.append(line.charAt(i));
                    i++;
                }
            }
            
            System.out.println(result.toString());
        }
        
        sc.close();
    }
}
",0
p00077,"ランレングス
文字列が連続した場合、ある規則で文字を置き換え文字列を短くすることができます。たとえば、AAAA という文字列の場合、@4A と表現すれば 1 文字分圧縮されます。この規則で圧縮された文字列を入力してもとの文字列に復元するプログラムを作成してください。ただし、復元した文字列に＠文字は出現しないものとします。
また、原文の文字列は英大文字、英小文字、数字、記号であり 100 文字以内、連続する文字は 9 文字以内です。
入力
複数の文字列が与えられます。１行に１つの文字列が与えられます。文字列の数は 50 を超えません。
出力
文字列ごとに、各文字に対して復元した文字列を１行に出力して下さい。
Sample Input
ab@5C1@8050
@99+1=1@90
Output for the Sample Input
abCCCCC10000000050
999999999+1=1000000000",Java,"import java.io.FileInputStream;
import java.util.Scanner;


public class Main {

    /**
     * @param args
     */
    public static void main(String[] args) throws Exception{
        while(hasNext()){
            StringBuilder s = new StringBuilder(NLine());
            StringBuilder ans=new StringBuilder();
            if(s.length()==0)return;
            for (int i = 0; i < s.length(); i++) {
                if(s.charAt(i)=='@'){
                    i++;
                    int len = s.charAt(i)-'0';
                    i++;
                    for (int j = 0; j < len; j++) {
                        ans.append(s.charAt(i));
                    }
                } else {
                    ans.append(s.charAt(i));
                }
            }
            System.out.println(ans);
        }
    }

    
    static int c=0;
    static int NI(){
        return (int)NL();
    }
    
    static long NL(){
        try {
            long r = 0;
            skip();
            if(c=='-') return -NL();
            for(;'0'<=c&&c<='9';c=System.in.read())
                r = r * 10 + c - '0';
            return r;
        } catch (Exception e) {
            return -1;
        }
    }
    
    static char NC(){
        try {
            skip();
            return (char)c;
        } catch (Exception e) {
            return 0;
        }
    }
    
    static String NS(){
        StringBuilder sb=new StringBuilder();
        try {
            skip();
            for(;!isSkip();){
                sb.append((char)c);
                c=System.in.read();
            }
            return sb.toString();
        } catch (Exception e) {
            return """";
        }
    }
    
    static String NLine(){
        StringBuilder sb=new StringBuilder();
        try {
            for(;c!='\n'&&c!='\r';){
                sb.append((char)c);
                c=System.in.read();
//                System.out.println(c);
            }
            c=System.in.read();
            return sb.toString();
        } catch (Exception e) {
            return """";
        }
    }
    
    static void skip(){
        try{
            while(isSkip()){
                c=System.in.read();
            }
        } catch (Exception e){}
        
    }
    
    static boolean hasNext(){
        skip();
        return c!=-1;
    }
    
    static boolean isSkip(){
        return 0 <= c && c <= ' ';
    }
}",1
p00077,"ランレングス
文字列が連続した場合、ある規則で文字を置き換え文字列を短くすることができます。たとえば、AAAA という文字列の場合、@4A と表現すれば 1 文字分圧縮されます。この規則で圧縮された文字列を入力してもとの文字列に復元するプログラムを作成してください。ただし、復元した文字列に＠文字は出現しないものとします。
また、原文の文字列は英大文字、英小文字、数字、記号であり 100 文字以内、連続する文字は 9 文字以内です。
入力
複数の文字列が与えられます。１行に１つの文字列が与えられます。文字列の数は 50 を超えません。
出力
文字列ごとに、各文字に対して復元した文字列を１行に出力して下さい。
Sample Input
ab@5C1@8050
@99+1=1@90
Output for the Sample Input
abCCCCC10000000050
999999999+1=1000000000",Python,"import sys
import re

for line in sys.stdin:
    line = line.rstrip('\n')
    result = []
    i = 0
    while i < len(line):
        if line[i] == '@':
            # Find the digit(s) after @
            j = i + 1
            while j < len(line) and line[j].isdigit():
                j += 1
            count = int(line[i+1:j])
            # The character to repeat is at position j
            if j < len(line):
                char = line[j]
                result.append(char * count)
                i = j + 1
            else:
                i = j
        else:
            result.append(line[i])
            i += 1
    print(''.join(result))
",0
p00077,"ランレングス
文字列が連続した場合、ある規則で文字を置き換え文字列を短くすることができます。たとえば、AAAA という文字列の場合、@4A と表現すれば 1 文字分圧縮されます。この規則で圧縮された文字列を入力してもとの文字列に復元するプログラムを作成してください。ただし、復元した文字列に＠文字は出現しないものとします。
また、原文の文字列は英大文字、英小文字、数字、記号であり 100 文字以内、連続する文字は 9 文字以内です。
入力
複数の文字列が与えられます。１行に１つの文字列が与えられます。文字列の数は 50 を超えません。
出力
文字列ごとに、各文字に対して復元した文字列を１行に出力して下さい。
Sample Input
ab@5C1@8050
@99+1=1@90
Output for the Sample Input
abCCCCC10000000050
999999999+1=1000000000",Python,"import sys


def method(l):
    return l if l.find('@') < 0 else method(l.replace(l[l.find('@'):l.find('@')+3], l[l.find('@')+2]*int(l[l.find('@')+1])))

if __name__ == '__main__':
    for line in sys.stdin:
        print(method(line))",1
p00079,"凸
n
角形の面積
凸
n
角形（すべての頂点の内角が 180 度未満である多角形、要するにへこんでいない多角形のこと）の頂点の座標を読んで、その面積を出力するプログラムを作成してください。頂点には辺のつながりの順序に従って頂点 1、頂点 2、頂点 3、‥‥頂点
n
という名前がついています。
ただし、
n
は 3 以上 20 以下とします。また、次の、三角形の 3 辺の長さ
a, b, c
から面積
S
を求める公式を使ってもかまいません。
入力
入力は以下の形式で与えられます。
x
1
,
y
1
x
2
,
y
2
:
x
n
,
y
n
x
i
,
y
i
はそれぞれ頂点
i
の
x
座標,
y
座標を表す実数です。
出力
面積
S
（実数）を１行に出力します。
出力は 0.000001 以下の誤差を含んでもかまいません。
Sample Input
0.0,0.0
0.0,1.0 
1.0,1.0 
2.0,0.0 
1.0,-1.0
Output for the Sample Input
2.500000",C,"#include <stdio.h>
#include <math.h>

int main() {
    double x[20], y[20];
    int n = 0;
    char c;
    
    while (scanf(""%lf,%lf"", &x[n], &y[n]) == 2) {
        n++;
        while ((c = getchar()) != '\n' && c != EOF);
        if (c == EOF) break;
    }
    
    double area = 0.0;
    for (int i = 0; i < n; i++) {
        int j = (i + 1) % n;
        area += x[i] * y[j] - x[j] * y[i];
    }
    area = fabs(area) / 2.0;
    
    printf(""%.6f\n"", area);
    
    return 0;
}
",0
p00079,"凸
n
角形の面積
凸
n
角形（すべての頂点の内角が 180 度未満である多角形、要するにへこんでいない多角形のこと）の頂点の座標を読んで、その面積を出力するプログラムを作成してください。頂点には辺のつながりの順序に従って頂点 1、頂点 2、頂点 3、‥‥頂点
n
という名前がついています。
ただし、
n
は 3 以上 20 以下とします。また、次の、三角形の 3 辺の長さ
a, b, c
から面積
S
を求める公式を使ってもかまいません。
入力
入力は以下の形式で与えられます。
x
1
,
y
1
x
2
,
y
2
:
x
n
,
y
n
x
i
,
y
i
はそれぞれ頂点
i
の
x
座標,
y
座標を表す実数です。
出力
面積
S
（実数）を１行に出力します。
出力は 0.000001 以下の誤差を含んでもかまいません。
Sample Input
0.0,0.0
0.0,1.0 
1.0,1.0 
2.0,0.0 
1.0,-1.0
Output for the Sample Input
2.500000",C,"#include <stdio.h>
#include <math.h>
int main(){
	int i=0,j;
	double x[20],y[20],s=0;
    //値の読み込み
    
    while(scanf(""%lf,%lf\n"",&x[i],&y[i]) !=EOF) {
    		//scanf(""%lf%lf"",&x[i],&y[i]);
    		i++;
    	}
    	j=i
    	for(i=1;i<j;i++){
    		s+=(x[i]*y[i+1]-x[i+1]*y[i]);
    	}
        s+=(x[i]*y[0]-x[0]*y[i]);
    	printf(""%0.6lf\n"",fabs(s)/2.0);
    
    return 0;
}
",1
p00079,"凸
n
角形の面積
凸
n
角形（すべての頂点の内角が 180 度未満である多角形、要するにへこんでいない多角形のこと）の頂点の座標を読んで、その面積を出力するプログラムを作成してください。頂点には辺のつながりの順序に従って頂点 1、頂点 2、頂点 3、‥‥頂点
n
という名前がついています。
ただし、
n
は 3 以上 20 以下とします。また、次の、三角形の 3 辺の長さ
a, b, c
から面積
S
を求める公式を使ってもかまいません。
入力
入力は以下の形式で与えられます。
x
1
,
y
1
x
2
,
y
2
:
x
n
,
y
n
x
i
,
y
i
はそれぞれ頂点
i
の
x
座標,
y
座標を表す実数です。
出力
面積
S
（実数）を１行に出力します。
出力は 0.000001 以下の誤差を含んでもかまいません。
Sample Input
0.0,0.0
0.0,1.0 
1.0,1.0 
2.0,0.0 
1.0,-1.0
Output for the Sample Input
2.500000",Java,"import java.util.Scanner;
import java.util.ArrayList;

public class Main {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        ArrayList<Double> x = new ArrayList<>();
        ArrayList<Double> y = new ArrayList<>();
        
        while (sc.hasNext()) {
            String line = sc.nextLine().trim();
            if (line.isEmpty()) continue;
            
            String[] parts = line.split("","");
            x.add(Double.parseDouble(parts[0]));
            y.add(Double.parseDouble(parts[1]));
        }
        
        int n = x.size();
        double area = 0.0;
        
        for (int i = 0; i < n; i++) {
            int j = (i + 1) % n;
            area += x.get(i) * y.get(j);
            area -= x.get(j) * y.get(i);
        }
        
        area = Math.abs(area) / 2.0;
        
        System.out.printf(""%.6f\n"", area);
        sc.close();
    }
}
",0
p00079,"凸
n
角形の面積
凸
n
角形（すべての頂点の内角が 180 度未満である多角形、要するにへこんでいない多角形のこと）の頂点の座標を読んで、その面積を出力するプログラムを作成してください。頂点には辺のつながりの順序に従って頂点 1、頂点 2、頂点 3、‥‥頂点
n
という名前がついています。
ただし、
n
は 3 以上 20 以下とします。また、次の、三角形の 3 辺の長さ
a, b, c
から面積
S
を求める公式を使ってもかまいません。
入力
入力は以下の形式で与えられます。
x
1
,
y
1
x
2
,
y
2
:
x
n
,
y
n
x
i
,
y
i
はそれぞれ頂点
i
の
x
座標,
y
座標を表す実数です。
出力
面積
S
（実数）を１行に出力します。
出力は 0.000001 以下の誤差を含んでもかまいません。
Sample Input
0.0,0.0
0.0,1.0 
1.0,1.0 
2.0,0.0 
1.0,-1.0
Output for the Sample Input
2.500000",Java,"import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;

public class Main{
	public static void main(String[] args)throws IOException{
		InputStreamReader isr = new InputStreamReader(System.in);
		BufferedReader reader = new BufferedReader(isr);
		double[] x = new double[20];
		double[] y = new double[20];
		int i = 0;
		String string;
		
		while((string = reader.readLine()) != null){
			x[i] = Double.valueOf(string.split("","")[0]);
			y[i] = Double.valueOf(string.split("","")[1]);
			i++;
		}
		
		double a = Math.hypot(x[1] - x[0], y[1] - y[0]);
		double b = Math.hypot(x[2] - x[0], y[2] - y[0]);
		double c = Math.hypot(x[2] - x[1], y[2] - y[1]);
		double z = (a + b + c) / 2;
		double S = Math.sqrt(z * (z - a) * (z - b) * (z - c));
		for(int j = 2; j < i - 1; j++){
			a = Math.hypot(x[j] - x[0], y[j] - y[0]);
			b = Math.hypot(x[j + 1] - x[0], y[j + 1] - y[0]);
			c = Math.hypot(x[j + 1] - x[j], y[j + 1] - y[j]);
			z = (a + b + c) / 2;
			S += Math.sqrt(z * (z - a) * (z - b) * (z - c));
		}
		System.out.println(S);
	}
}",1
p00079,"凸
n
角形の面積
凸
n
角形（すべての頂点の内角が 180 度未満である多角形、要するにへこんでいない多角形のこと）の頂点の座標を読んで、その面積を出力するプログラムを作成してください。頂点には辺のつながりの順序に従って頂点 1、頂点 2、頂点 3、‥‥頂点
n
という名前がついています。
ただし、
n
は 3 以上 20 以下とします。また、次の、三角形の 3 辺の長さ
a, b, c
から面積
S
を求める公式を使ってもかまいません。
入力
入力は以下の形式で与えられます。
x
1
,
y
1
x
2
,
y
2
:
x
n
,
y
n
x
i
,
y
i
はそれぞれ頂点
i
の
x
座標,
y
座標を表す実数です。
出力
面積
S
（実数）を１行に出力します。
出力は 0.000001 以下の誤差を含んでもかまいません。
Sample Input
0.0,0.0
0.0,1.0 
1.0,1.0 
2.0,0.0 
1.0,-1.0
Output for the Sample Input
2.500000",Python,"import sys
import math

def polygon_area(points):
    n = len(points)
    area = 0.0
    for i in range(n):
        j = (i + 1) % n
        area += points[i][0] * points[j][1]
        area -= points[j][0] * points[i][1]
    area = abs(area) / 2.0
    return area

points = []
for line in sys.stdin:
    line = line.strip()
    if line:
        x, y = map(float, line.split(','))
        points.append((x, y))

area = polygon_area(points)
print(f""{area:.6f}"")
",0
p00079,"凸
n
角形の面積
凸
n
角形（すべての頂点の内角が 180 度未満である多角形、要するにへこんでいない多角形のこと）の頂点の座標を読んで、その面積を出力するプログラムを作成してください。頂点には辺のつながりの順序に従って頂点 1、頂点 2、頂点 3、‥‥頂点
n
という名前がついています。
ただし、
n
は 3 以上 20 以下とします。また、次の、三角形の 3 辺の長さ
a, b, c
から面積
S
を求める公式を使ってもかまいません。
入力
入力は以下の形式で与えられます。
x
1
,
y
1
x
2
,
y
2
:
x
n
,
y
n
x
i
,
y
i
はそれぞれ頂点
i
の
x
座標,
y
座標を表す実数です。
出力
面積
S
（実数）を１行に出力します。
出力は 0.000001 以下の誤差を含んでもかまいません。
Sample Input
0.0,0.0
0.0,1.0 
1.0,1.0 
2.0,0.0 
1.0,-1.0
Output for the Sample Input
2.500000",Python,"i = 0
x = []
y = []
while 1:
    try:
        a,b = map(float,input().split("",""))
        x.append(a)
        y.append(b)
    except EOFError:
        break

S = 0
for i in range(len(x)-2):
    a = ((x[0]-x[i+1]) ** 2 + (y[0]-y[i+1]) ** 2) ** 0.5
    b = ((x[0]-x[i+2]) ** 2 + (y[0]-y[i+2]) ** 2) ** 0.5
    c = ((x[i+1]-x[i+2]) ** 2 + (y[i+1]-y[i+2]) ** 2) ** 0.5
    z = (a + b + c)/2
    S += (z * (z - a) * (z - b) * (z - c)) ** 0.5
print(S)
",1
p00080,"３乗根
$x^3 = q$ の解は漸化式 $x_{n+1} = x_n - \frac{x_{n}^3 - q}{3x_{n}^2}$ を計算していくことで近似的に求めることができます。
$x_1$ に正の数 $\frac{q}{2}$ をいれ
$x_2 = x_1 - \frac{x_{1}^3 - q}{3x_{1}^2}$、$x_3 = x_2 - \frac{x_{2}^3 - q}{3x_{2}^2}$、…　と計算します。
この計算をしながら、
$|x^3 - q|$ の値が、十分小さくなったところで、計算をやめ、最後に計算した $x_n$ を $x^3 = q$ の近似解とします。
この方法に従って、入力された正の整数 $q$ に対し、 $q$ の３乗根の近似値を出力するプログラムを作成してください。ただし、「十分小さくなった」という判定は $|x^3 - q| < 0.00001 q$ を用いてください。
入力
複数のデータセットが与えられる。各データセットに $q$ ($1 \leq q < 2^{31}$)（整数）が一行に与えられる。入力の終わりは -1 である。
データセットの数は 50 を超えない。
出力
各データセットに対して $x$ （実数）を１行に出力する。出力結果に 0.00001 以下の誤差を含んでもよい。
Sample Input
15
15
-1
Output for the Sample Input
2.466212
2.466212",C,"#include <stdio.h>
#include <math.h>

int main() {
    double q;
    
    while(1) {
        scanf(""%lf"", &q);
        if(q == -1) break;
        
        double x = q / 2.0;
        
        while(fabs(x * x * x - q) >= 0.00001 * q) {
            x = x - (x * x * x - q) / (3 * x * x);
        }
        
        printf(""%.6f\n"", x);
    }
    
    return 0;
}
",0
p00080,"３乗根
$x^3 = q$ の解は漸化式 $x_{n+1} = x_n - \frac{x_{n}^3 - q}{3x_{n}^2}$ を計算していくことで近似的に求めることができます。
$x_1$ に正の数 $\frac{q}{2}$ をいれ
$x_2 = x_1 - \frac{x_{1}^3 - q}{3x_{1}^2}$、$x_3 = x_2 - \frac{x_{2}^3 - q}{3x_{2}^2}$、…　と計算します。
この計算をしながら、
$|x^3 - q|$ の値が、十分小さくなったところで、計算をやめ、最後に計算した $x_n$ を $x^3 = q$ の近似解とします。
この方法に従って、入力された正の整数 $q$ に対し、 $q$ の３乗根の近似値を出力するプログラムを作成してください。ただし、「十分小さくなった」という判定は $|x^3 - q| < 0.00001 q$ を用いてください。
入力
複数のデータセットが与えられる。各データセットに $q$ ($1 \leq q < 2^{31}$)（整数）が一行に与えられる。入力の終わりは -1 である。
データセットの数は 50 を超えない。
出力
各データセットに対して $x$ （実数）を１行に出力する。出力結果に 0.00001 以下の誤差を含んでもよい。
Sample Input
15
15
-1
Output for the Sample Input
2.466212
2.466212",C,"#include <stdio.h>
#include <math.h>

int main(int argc,char* argv[]){
  
  for(;;){
    int q;
    double x;

    scanf(""%d"",&q);
    if(q == -1){break;}
    
    x = q/2;
    while(!(fabs(x*x*x - q) < 0.00001*q)){
      x = x - (x*x*x-q)/(3*x*x);
    }

    printf(""%lf\n"",x);
  }

  return 0;
  
}",1
p00080,"３乗根
$x^3 = q$ の解は漸化式 $x_{n+1} = x_n - \frac{x_{n}^3 - q}{3x_{n}^2}$ を計算していくことで近似的に求めることができます。
$x_1$ に正の数 $\frac{q}{2}$ をいれ
$x_2 = x_1 - \frac{x_{1}^3 - q}{3x_{1}^2}$、$x_3 = x_2 - \frac{x_{2}^3 - q}{3x_{2}^2}$、…　と計算します。
この計算をしながら、
$|x^3 - q|$ の値が、十分小さくなったところで、計算をやめ、最後に計算した $x_n$ を $x^3 = q$ の近似解とします。
この方法に従って、入力された正の整数 $q$ に対し、 $q$ の３乗根の近似値を出力するプログラムを作成してください。ただし、「十分小さくなった」という判定は $|x^3 - q| < 0.00001 q$ を用いてください。
入力
複数のデータセットが与えられる。各データセットに $q$ ($1 \leq q < 2^{31}$)（整数）が一行に与えられる。入力の終わりは -1 である。
データセットの数は 50 を超えない。
出力
各データセットに対して $x$ （実数）を１行に出力する。出力結果に 0.00001 以下の誤差を含んでもよい。
Sample Input
15
15
-1
Output for the Sample Input
2.466212
2.466212",Java,"import java.util.Scanner;

public class Main {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        
        while (true) {
            int q = sc.nextInt();
            if (q == -1) break;
            
            double x = q / 2.0;
            
            while (Math.abs(x * x * x - q) >= 0.00001 * q) {
                x = x - (x * x * x - q) / (3 * x * x);
            }
            
            System.out.printf(""%.6f\n"", x);
        }
        
        sc.close();
    }
}
",0
p00080,"３乗根
$x^3 = q$ の解は漸化式 $x_{n+1} = x_n - \frac{x_{n}^3 - q}{3x_{n}^2}$ を計算していくことで近似的に求めることができます。
$x_1$ に正の数 $\frac{q}{2}$ をいれ
$x_2 = x_1 - \frac{x_{1}^3 - q}{3x_{1}^2}$、$x_3 = x_2 - \frac{x_{2}^3 - q}{3x_{2}^2}$、…　と計算します。
この計算をしながら、
$|x^3 - q|$ の値が、十分小さくなったところで、計算をやめ、最後に計算した $x_n$ を $x^3 = q$ の近似解とします。
この方法に従って、入力された正の整数 $q$ に対し、 $q$ の３乗根の近似値を出力するプログラムを作成してください。ただし、「十分小さくなった」という判定は $|x^3 - q| < 0.00001 q$ を用いてください。
入力
複数のデータセットが与えられる。各データセットに $q$ ($1 \leq q < 2^{31}$)（整数）が一行に与えられる。入力の終わりは -1 である。
データセットの数は 50 を超えない。
出力
各データセットに対して $x$ （実数）を１行に出力する。出力結果に 0.00001 以下の誤差を含んでもよい。
Sample Input
15
15
-1
Output for the Sample Input
2.466212
2.466212",Java,"
import java.util.*;
import static java.lang.Math.*;
import static java.util.Arrays.*;

public class Main {

	int INF = 1 << 28;
	double EPS = 1e-5;

	void run() {
		Scanner sc = new Scanner(System.in);
		for(;;) {
			double q = sc.nextDouble();
			if( q == 0 ) { System.out.println(0.00000); continue; }
			if( q == -1 ) break;
			double x = q / 2;
			while( abs( x*x*x - q) >= EPS * q ) {
				x = f(x, q);
			}
			debug(EPS*q);
			System.out.println(x);
		}
	}
	
	double f(double x, double q) {
		return x - (x*x*x - q) / ( 3 * x*x);
	}

	public static void main(String[] args) {
		new Main().run();
	}

	void debug(Object... os) {
//		System.err.println(Arrays.deepToString(os));
	}
}",1
p00080,"３乗根
$x^3 = q$ の解は漸化式 $x_{n+1} = x_n - \frac{x_{n}^3 - q}{3x_{n}^2}$ を計算していくことで近似的に求めることができます。
$x_1$ に正の数 $\frac{q}{2}$ をいれ
$x_2 = x_1 - \frac{x_{1}^3 - q}{3x_{1}^2}$、$x_3 = x_2 - \frac{x_{2}^3 - q}{3x_{2}^2}$、…　と計算します。
この計算をしながら、
$|x^3 - q|$ の値が、十分小さくなったところで、計算をやめ、最後に計算した $x_n$ を $x^3 = q$ の近似解とします。
この方法に従って、入力された正の整数 $q$ に対し、 $q$ の３乗根の近似値を出力するプログラムを作成してください。ただし、「十分小さくなった」という判定は $|x^3 - q| < 0.00001 q$ を用いてください。
入力
複数のデータセットが与えられる。各データセットに $q$ ($1 \leq q < 2^{31}$)（整数）が一行に与えられる。入力の終わりは -1 である。
データセットの数は 50 を超えない。
出力
各データセットに対して $x$ （実数）を１行に出力する。出力結果に 0.00001 以下の誤差を含んでもよい。
Sample Input
15
15
-1
Output for the Sample Input
2.466212
2.466212",Python,"import sys

for line in sys.stdin:
    q = int(line.strip())
    if q == -1:
        break
    
    x = q / 2.0
    
    while abs(x**3 - q) >= 0.00001 * q:
        x = x - (x**3 - q) / (3 * x**2)
    
    print(f""{x:.6f}"")
",0
p00080,"３乗根
$x^3 = q$ の解は漸化式 $x_{n+1} = x_n - \frac{x_{n}^3 - q}{3x_{n}^2}$ を計算していくことで近似的に求めることができます。
$x_1$ に正の数 $\frac{q}{2}$ をいれ
$x_2 = x_1 - \frac{x_{1}^3 - q}{3x_{1}^2}$、$x_3 = x_2 - \frac{x_{2}^3 - q}{3x_{2}^2}$、…　と計算します。
この計算をしながら、
$|x^3 - q|$ の値が、十分小さくなったところで、計算をやめ、最後に計算した $x_n$ を $x^3 = q$ の近似解とします。
この方法に従って、入力された正の整数 $q$ に対し、 $q$ の３乗根の近似値を出力するプログラムを作成してください。ただし、「十分小さくなった」という判定は $|x^3 - q| < 0.00001 q$ を用いてください。
入力
複数のデータセットが与えられる。各データセットに $q$ ($1 \leq q < 2^{31}$)（整数）が一行に与えられる。入力の終わりは -1 である。
データセットの数は 50 を超えない。
出力
各データセットに対して $x$ （実数）を１行に出力する。出力結果に 0.00001 以下の誤差を含んでもよい。
Sample Input
15
15
-1
Output for the Sample Input
2.466212
2.466212",Python,"while True :
    q = int(input())
    if q == -1 :
        break
    
    n = 1
    x = q / 2
    while True :
        if abs(x**3 - q) < (0.00001 * q) :
            break
        x = x - (x**3 - q) / (3 * x**2)
    
    print('{:.6f}'.format(x))
",1
p00081,"線対称
平面上の異なる 3 点
P1(x1,y1)
,
P2(x2,y2)
,
Q(xq,yq)
の座標の組を読み込んで、点
P1
点
P2
を通る直線を対称軸として点
Q
と線対称の位置にある点
R(x,y)
を出力するプログラムを作成してください。なお、点
Q
は、その対称軸上にないものとします。
入力
入力は複数のデータセットからなります。各データセットは以下の形式で与えられます。
x1
,
y1
,
x2
,
y2
,
xq
,
yq
x1
,
y1
,
x2
,
y2
,
xq
,
yq
(-100 以上 100 以下の実数) がカンマ区切りで１行に与えられます。
データセットの数は 50 を超えない。
出力
データセットごとに、
x
,
y
を空白区切りで 1 行に出力する。出力は実数で 0.0001 以下の誤差を含んでもよい。
Sample Input
1.0,0.0,-1.0,0.0,1.0,1.0 
1.0,0.0,0.0,-1.0,3.0,0.0 
0.0,1.0,0.0,-1.0,1.0,1.0
Output for the Sample Input
1.000000 -1.000000
1.000000 2.000000
-1.000000 1.000000",C,"#include <stdio.h>

int main() {
    double x1, y1, x2, y2, xq, yq;
    
    while (scanf(""%lf,%lf,%lf,%lf,%lf,%lf"", &x1, &y1, &x2, &y2, &xq, &yq) == 6) {
        double dx = x2 - x1;
        double dy = y2 - y1;
        
        double a = dx * dx + dy * dy;
        double t = ((xq - x1) * dx + (yq - y1) * dy) / a;
        
        double px = x1 + t * dx;
        double py = y1 + t * dy;
        
        double rx = 2 * px - xq;
        double ry = 2 * py - yq;
        
        printf(""%.6f %.6f\n"", rx, ry);
    }
    
    return 0;
}
",0
p00081,"線対称
平面上の異なる 3 点
P1(x1,y1)
,
P2(x2,y2)
,
Q(xq,yq)
の座標の組を読み込んで、点
P1
点
P2
を通る直線を対称軸として点
Q
と線対称の位置にある点
R(x,y)
を出力するプログラムを作成してください。なお、点
Q
は、その対称軸上にないものとします。
入力
入力は複数のデータセットからなります。各データセットは以下の形式で与えられます。
x1
,
y1
,
x2
,
y2
,
xq
,
yq
x1
,
y1
,
x2
,
y2
,
xq
,
yq
(-100 以上 100 以下の実数) がカンマ区切りで１行に与えられます。
データセットの数は 50 を超えない。
出力
データセットごとに、
x
,
y
を空白区切りで 1 行に出力する。出力は実数で 0.0001 以下の誤差を含んでもよい。
Sample Input
1.0,0.0,-1.0,0.0,1.0,1.0 
1.0,0.0,0.0,-1.0,3.0,0.0 
0.0,1.0,0.0,-1.0,1.0,1.0
Output for the Sample Input
1.000000 -1.000000
1.000000 2.000000
-1.000000 1.000000",C,"#include<stdio.h>

int main(void){

  double x1,y1,x2,y2,xq,yq,x,y;
  double a,b,A,B,cx,cy;

  while(~scanf(""%lf,%lf,%lf,%lf,%lf,%lf"",&x1,&y1,&x2,&y2,&xq,&yq)){
    
    if(y1==0 && y2==0){
      printf(""%lf %lf\n"",xq,-yq);
      continue;
    }
    if(xx1==0 && x2==0){
      printf(""%lf %lf\n"",-xq,yq);
      continue;
    }
    a=(y2-y1)?(x2-x1)/(y2-y1):0;
    b=y2-a*x2;

    A=a?-1/a:0;
    B=yq-A*xq;

    cx=(a-A)?(B-b)/(a-A):0;
    cy=A*cx+B;

    x=2*cx-xq;
    y=2*cy-yq;

    printf(""%lf %lf\n"",x,y);
  }

  return 0;
}",1
p00081,"線対称
平面上の異なる 3 点
P1(x1,y1)
,
P2(x2,y2)
,
Q(xq,yq)
の座標の組を読み込んで、点
P1
点
P2
を通る直線を対称軸として点
Q
と線対称の位置にある点
R(x,y)
を出力するプログラムを作成してください。なお、点
Q
は、その対称軸上にないものとします。
入力
入力は複数のデータセットからなります。各データセットは以下の形式で与えられます。
x1
,
y1
,
x2
,
y2
,
xq
,
yq
x1
,
y1
,
x2
,
y2
,
xq
,
yq
(-100 以上 100 以下の実数) がカンマ区切りで１行に与えられます。
データセットの数は 50 を超えない。
出力
データセットごとに、
x
,
y
を空白区切りで 1 行に出力する。出力は実数で 0.0001 以下の誤差を含んでもよい。
Sample Input
1.0,0.0,-1.0,0.0,1.0,1.0 
1.0,0.0,0.0,-1.0,3.0,0.0 
0.0,1.0,0.0,-1.0,1.0,1.0
Output for the Sample Input
1.000000 -1.000000
1.000000 2.000000
-1.000000 1.000000",Java,"import java.util.Scanner;

public class Main {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        
        while (sc.hasNext()) {
            String line = sc.nextLine();
            String[] parts = line.split("","");
            
            double x1 = Double.parseDouble(parts[0]);
            double y1 = Double.parseDouble(parts[1]);
            double x2 = Double.parseDouble(parts[2]);
            double y2 = Double.parseDouble(parts[3]);
            double xq = Double.parseDouble(parts[4]);
            double yq = Double.parseDouble(parts[5]);
            
            // Direction vector of the line P1P2
            double dx = x2 - x1;
            double dy = y2 - y1;
            
            // Vector from P1 to Q
            double qx = xq - x1;
            double qy = yq - y1;
            
            // Project Q onto the line P1P2
            // Parameter t for the projection point
            double t = (qx * dx + qy * dy) / (dx * dx + dy * dy);
            
            // Projection point H on the line
            double hx = x1 + t * dx;
            double hy = y1 + t * dy;
            
            // R is the reflection of Q across H
            double rx = 2 * hx - xq;
            double ry = 2 * hy - yq;
            
            System.out.printf(""%.6f %.6f%n"", rx, ry);
        }
        
        sc.close();
    }
}
",0
p00081,"線対称
平面上の異なる 3 点
P1(x1,y1)
,
P2(x2,y2)
,
Q(xq,yq)
の座標の組を読み込んで、点
P1
点
P2
を通る直線を対称軸として点
Q
と線対称の位置にある点
R(x,y)
を出力するプログラムを作成してください。なお、点
Q
は、その対称軸上にないものとします。
入力
入力は複数のデータセットからなります。各データセットは以下の形式で与えられます。
x1
,
y1
,
x2
,
y2
,
xq
,
yq
x1
,
y1
,
x2
,
y2
,
xq
,
yq
(-100 以上 100 以下の実数) がカンマ区切りで１行に与えられます。
データセットの数は 50 を超えない。
出力
データセットごとに、
x
,
y
を空白区切りで 1 行に出力する。出力は実数で 0.0001 以下の誤差を含んでもよい。
Sample Input
1.0,0.0,-1.0,0.0,1.0,1.0 
1.0,0.0,0.0,-1.0,3.0,0.0 
0.0,1.0,0.0,-1.0,1.0,1.0
Output for the Sample Input
1.000000 -1.000000
1.000000 2.000000
-1.000000 1.000000",Java,"import java.awt.geom.Line2D;
import java.awt.geom.Point2D;
import java.util.*;
public class Main {
	Scanner in = new Scanner(System.in);
	public static void main(String[] args) {
		new Main();
	}

	public Main() {
		while(in.hasNext())new AOJ0081().doIt();
	}

	class AOJ0081{
		//p0-p1の直線があるときに直線p2から直線らしたときp0-p1上の垂直な点を求める。
		private Point2D projection(Line2D l,Point2D p2){
			double kyori = l.getP1().distance(l.getP2());
			double angle = angle(l.getP1(),l.getP2(), p2);
			double t = l.getP1().distance(p2) * Math.cos(angle);
			Point2D result = new Point2D.Double(l.getP1().getX()+(l.getP2().getX()-l.getP1().getX())*t/kyori,
					l.getP1().getY()+(l.getP2().getY()-l.getP1().getY())*t/kyori);
			return result;
		}
		private double angle(Point2D p0, Point2D p1, Point2D p2){
			return Math.atan2(p2.getY()-p0.getY(),p2.getX()-p0.getX())-
					Math.atan2(p1.getY()-p0.getY(),p1.getX()-p0.getX());
		}
		
		
		void doIt(){
			String input[] = in.next().split("","");
			double a[] = new double[input.length];
			for(int i=0;i<a.length;i++)a[i] = Double.parseDouble(input[i]);
			Line2D l = new Line2D.Double(a[0], a[1], a[2], a[3]);
			Point2D p = new Point2D.Double(a[4],a[5]);
			Point2D result = projection(l, p);
			 double dx = result.getX()-p.getX();
             double dy = result.getY()-p.getY();
             double tx = dx+result.getX();
             double ty = dy+result.getY();
             System.out.printf(""%.9f %.9f\n"",tx,ty);
		}
	}

}",1
p00081,"線対称
平面上の異なる 3 点
P1(x1,y1)
,
P2(x2,y2)
,
Q(xq,yq)
の座標の組を読み込んで、点
P1
点
P2
を通る直線を対称軸として点
Q
と線対称の位置にある点
R(x,y)
を出力するプログラムを作成してください。なお、点
Q
は、その対称軸上にないものとします。
入力
入力は複数のデータセットからなります。各データセットは以下の形式で与えられます。
x1
,
y1
,
x2
,
y2
,
xq
,
yq
x1
,
y1
,
x2
,
y2
,
xq
,
yq
(-100 以上 100 以下の実数) がカンマ区切りで１行に与えられます。
データセットの数は 50 を超えない。
出力
データセットごとに、
x
,
y
を空白区切りで 1 行に出力する。出力は実数で 0.0001 以下の誤差を含んでもよい。
Sample Input
1.0,0.0,-1.0,0.0,1.0,1.0 
1.0,0.0,0.0,-1.0,3.0,0.0 
0.0,1.0,0.0,-1.0,1.0,1.0
Output for the Sample Input
1.000000 -1.000000
1.000000 2.000000
-1.000000 1.000000",Python,"import sys

def reflect_point(x1, y1, x2, y2, xq, yq):
    # Vector along the line P1P2
    dx = x2 - x1
    dy = y2 - y1
    
    # Vector from P1 to Q
    qx = xq - x1
    qy = yq - y1
    
    # Project Q onto the line P1P2
    # t = dot(PQ, P1P2) / dot(P1P2, P1P2)
    t = (qx * dx + qy * dy) / (dx * dx + dy * dy)
    
    # Point on the line closest to Q
    px = x1 + t * dx
    py = y1 + t * dy
    
    # Reflect Q across the line
    rx = 2 * px - xq
    ry = 2 * py - yq
    
    return rx, ry

for line in sys.stdin:
    coords = list(map(float, line.strip().split(',')))
    x1, y1, x2, y2, xq, yq = coords
    rx, ry = reflect_point(x1, y1, x2, y2, xq, yq)
    print(f""{rx:.6f} {ry:.6f}"")
",0
p00081,"線対称
平面上の異なる 3 点
P1(x1,y1)
,
P2(x2,y2)
,
Q(xq,yq)
の座標の組を読み込んで、点
P1
点
P2
を通る直線を対称軸として点
Q
と線対称の位置にある点
R(x,y)
を出力するプログラムを作成してください。なお、点
Q
は、その対称軸上にないものとします。
入力
入力は複数のデータセットからなります。各データセットは以下の形式で与えられます。
x1
,
y1
,
x2
,
y2
,
xq
,
yq
x1
,
y1
,
x2
,
y2
,
xq
,
yq
(-100 以上 100 以下の実数) がカンマ区切りで１行に与えられます。
データセットの数は 50 を超えない。
出力
データセットごとに、
x
,
y
を空白区切りで 1 行に出力する。出力は実数で 0.0001 以下の誤差を含んでもよい。
Sample Input
1.0,0.0,-1.0,0.0,1.0,1.0 
1.0,0.0,0.0,-1.0,3.0,0.0 
0.0,1.0,0.0,-1.0,1.0,1.0
Output for the Sample Input
1.000000 -1.000000
1.000000 2.000000
-1.000000 1.000000",Python,"import sys
from math import complex as C
for e in sys.stdin:
 a,b,c,d,e,f=map(float,e.split(','))
 z,w,q=C(a,b),C(c,d),C(e,f)
 w-=z
 z+=(w/abs(w))**2*(q-z).conjugate()
 print(z.real,z.imag)
",1
p00082,"メリーゴーランド
遊園地にあるメリーゴーランドはご存じでしょう。大きな円盤の上に馬や馬車などの乗り物が固定されていて、円盤が回転すると同時に乗り物が上下に揺れる、定番の遊具です。ある遊園地のメリーゴーランドは、４人乗りの馬車が２台、２人乗りの車２台、１人乗りの馬が４台、計８台の乗り物が図１のような順序で備えられています。そして、遊園地においでのお客様は、図１に示す乗り場０〜７のどこかで待つようになっています。
この遊園地のメリーゴーランドは、かならず乗り物が乗り場にぴったりと合う位置に停止します。そして、０〜７のそれぞれで待っているお客さまは、目の前にとまった乗り物に乗ることになっています。急いで他の乗り場へ移動してそこから乗るということはできません。効率よく、お客さまにたのしんでいただくためには、メリーゴーランドの停止する位置をうまく調整して、乗れないお客さまをできるだけ少なくするようにしなければなりません。
乗り場０〜７で待っているお客さまの人数を読み込んで、どの位置にどの乗り物が来るように止めれば乗れないお客さまが最も少なくなるかを出力するプログラムを作成してください。
入力
入力は複数のデータセットからなります。各データセットは以下の形式で与えられます。
p
0
p
1
p
2
p
3
p
4
p
5
p
6
p
7
乗り場 0, 1, ..., 7 で待っているお客様の人数を表す整数
p
0
,
p
1
,... ,
p
7
( 0 ≤
p
i
≤ 10,000) が空白区切りで１行に与えられます。
出力
メリーゴーランドの乗り物の馬車を 4、車を 2、馬を 1 で表すこととします。乗り場 0, 1, ... , 7 にとめる乗り物を、それぞれ
c
0
,
c
1
,...,
c
7
とします。データセットごとに、
c
0
,
c
1
,...,
c
7
を空白区切りで 1 行に出力します。
なお、乗れなくなるお客さまが最小となるとめ方が複数ある場合は、
c
0
c
1
c
2
c
3
c
4
c
5
c
6
c
7
を 8 桁の整数
V
とみなし、
V
が最小となるとめ方を選ぶものとします。
データセットの数は 100 を超えません。
Sample Input
2 3 1 4 0 1 0 1 
4 2 3 2 2 2 1 1
Output for the Sample Input
1 4 1 4 1 2 1 2 
4 1 4 1 2 1 2 1",C,"#include <stdio.h>
#include <string.h>

int main() {
    int p[8];
    int rides[8] = {4, 1, 4, 1, 2, 1, 2, 1}; // Initial configuration
    
    while (scanf(""%d %d %d %d %d %d %d %d"", &p[0], &p[1], &p[2], &p[3], &p[4], &p[5], &p[6], &p[7]) == 8) {
        int best_rotation = 0;
        int min_left = 1000000;
        long long min_value = 99999999;
        
        // Try all 8 rotations
        for (int rot = 0; rot < 8; rot++) {
            int left = 0;
            long long value = 0;
            
            // Calculate how many customers can't ride and the resulting value
            for (int i = 0; i < 8; i++) {
                int ride_pos = (i - rot + 8) % 8;
                int capacity = rides[ride_pos];
                int customers = p[i];
                
                if (customers > capacity) {
                    left += customers - capacity;
                }
                
                value = value * 10 + capacity;
            }
            
            // Update best if this is better
            if (left < min_left || (left == min_left && value < min_value)) {
                min_left = left;
                min_value = value;
                best_rotation = rot;
            }
        }
        
        // Output the best configuration
        for (int i = 0; i < 8; i++) {
            int ride_pos = (i - best_rotation + 8) % 8;
            if (i > 0) printf("" "");
            printf(""%d"", rides[ride_pos]);
        }
        printf(""\n"");
    }
    
    return 0;
}
",0
p00082,"メリーゴーランド
遊園地にあるメリーゴーランドはご存じでしょう。大きな円盤の上に馬や馬車などの乗り物が固定されていて、円盤が回転すると同時に乗り物が上下に揺れる、定番の遊具です。ある遊園地のメリーゴーランドは、４人乗りの馬車が２台、２人乗りの車２台、１人乗りの馬が４台、計８台の乗り物が図１のような順序で備えられています。そして、遊園地においでのお客様は、図１に示す乗り場０〜７のどこかで待つようになっています。
この遊園地のメリーゴーランドは、かならず乗り物が乗り場にぴったりと合う位置に停止します。そして、０〜７のそれぞれで待っているお客さまは、目の前にとまった乗り物に乗ることになっています。急いで他の乗り場へ移動してそこから乗るということはできません。効率よく、お客さまにたのしんでいただくためには、メリーゴーランドの停止する位置をうまく調整して、乗れないお客さまをできるだけ少なくするようにしなければなりません。
乗り場０〜７で待っているお客さまの人数を読み込んで、どの位置にどの乗り物が来るように止めれば乗れないお客さまが最も少なくなるかを出力するプログラムを作成してください。
入力
入力は複数のデータセットからなります。各データセットは以下の形式で与えられます。
p
0
p
1
p
2
p
3
p
4
p
5
p
6
p
7
乗り場 0, 1, ..., 7 で待っているお客様の人数を表す整数
p
0
,
p
1
,... ,
p
7
( 0 ≤
p
i
≤ 10,000) が空白区切りで１行に与えられます。
出力
メリーゴーランドの乗り物の馬車を 4、車を 2、馬を 1 で表すこととします。乗り場 0, 1, ... , 7 にとめる乗り物を、それぞれ
c
0
,
c
1
,...,
c
7
とします。データセットごとに、
c
0
,
c
1
,...,
c
7
を空白区切りで 1 行に出力します。
なお、乗れなくなるお客さまが最小となるとめ方が複数ある場合は、
c
0
c
1
c
2
c
3
c
4
c
5
c
6
c
7
を 8 桁の整数
V
とみなし、
V
が最小となるとめ方を選ぶものとします。
データセットの数は 100 を超えません。
Sample Input
2 3 1 4 0 1 0 1 
4 2 3 2 2 2 1 1
Output for the Sample Input
1 4 1 4 1 2 1 2 
4 1 4 1 2 1 2 1",C,"#include <stdio.h>
#include <limits.h>

static int units[8];
static int waitings[8];

void setup() {
	units[0] = 4;
	units[1] = 1;
	units[2] = 4;
	units[3] = 1;
	units[4] = 2;
	units[5] = 1;
	units[6] = 2;
	units[7] = 1;
}

int scan_waitings() {
	return scanf(""%d %d %d %d %d %d %d %d"",
			&waitings[0], &waitings[1], &waitings[2], &waitings[3],
			&waitings[4], &waitings[5], &waitings[6], &waitings[7]);
}

int count_passengers(int offset) {
	int sum = 0;
	int i;
	for (i = 0; i < 8; i++) {
		sum += (units[(i + offset) % 8] > waitings[i]) ? waitings[i] : units[(i + offset) % 8];
	}
	return sum;
}

void print_result(int offset) {
	int i;
	for (i = 0; i < 8; i++) {
		printf(""%d"", units[(i + offset) % 8]);
		if (i < 7) {
			printf("" "");
		} else {
			printf(""\n"");
		}
	}
}

int main() {
	int offset = 0;
	int max = 0;
	int count = 0;
	int max_offset = 0;
	char str[9];
	int num = INT_MAX;
	setup();

	while (scan_waitings() > 0) {
		max = 0;
		count = 0;
		max_offset = 0;
		num = INT_MAX;
		for (offset = 0; offset < 8; offset++) {
			count = count_passengers(offset);
			sprintf(str, ""%d%d%d%d%d%d%d%d"",
						units[(0 + offset) % 8],
						units[(1 + offset) % 8],
						units[(2 + offset) % 8],
						units[(3 + offset) % 8],
						units[(4 + offset) % 8],
						units[(5 + offset) % 8],
						units[(6 + offset) % 8],
						units[(7 + offset) % 8]
						);
			if (count > max) {
//				printf(""新記録   offset = %d, 配置 = %d\n"", offset, atoi(str));
				num = atoi(str);
				max_offset = offset;
				max = count;
			} else if (count == max) {
				printf(""タイ記録 offset = %d, 配置 = %d\n"", offset, atoi(str));
				if (num > atoi(str)) {
					max = count;
					num = atoi(str);
					max_offset = offset;
				}
			}
		}
		print_result(max_offset);
	}
	return 0;
}",1
p00082,"メリーゴーランド
遊園地にあるメリーゴーランドはご存じでしょう。大きな円盤の上に馬や馬車などの乗り物が固定されていて、円盤が回転すると同時に乗り物が上下に揺れる、定番の遊具です。ある遊園地のメリーゴーランドは、４人乗りの馬車が２台、２人乗りの車２台、１人乗りの馬が４台、計８台の乗り物が図１のような順序で備えられています。そして、遊園地においでのお客様は、図１に示す乗り場０〜７のどこかで待つようになっています。
この遊園地のメリーゴーランドは、かならず乗り物が乗り場にぴったりと合う位置に停止します。そして、０〜７のそれぞれで待っているお客さまは、目の前にとまった乗り物に乗ることになっています。急いで他の乗り場へ移動してそこから乗るということはできません。効率よく、お客さまにたのしんでいただくためには、メリーゴーランドの停止する位置をうまく調整して、乗れないお客さまをできるだけ少なくするようにしなければなりません。
乗り場０〜７で待っているお客さまの人数を読み込んで、どの位置にどの乗り物が来るように止めれば乗れないお客さまが最も少なくなるかを出力するプログラムを作成してください。
入力
入力は複数のデータセットからなります。各データセットは以下の形式で与えられます。
p
0
p
1
p
2
p
3
p
4
p
5
p
6
p
7
乗り場 0, 1, ..., 7 で待っているお客様の人数を表す整数
p
0
,
p
1
,... ,
p
7
( 0 ≤
p
i
≤ 10,000) が空白区切りで１行に与えられます。
出力
メリーゴーランドの乗り物の馬車を 4、車を 2、馬を 1 で表すこととします。乗り場 0, 1, ... , 7 にとめる乗り物を、それぞれ
c
0
,
c
1
,...,
c
7
とします。データセットごとに、
c
0
,
c
1
,...,
c
7
を空白区切りで 1 行に出力します。
なお、乗れなくなるお客さまが最小となるとめ方が複数ある場合は、
c
0
c
1
c
2
c
3
c
4
c
5
c
6
c
7
を 8 桁の整数
V
とみなし、
V
が最小となるとめ方を選ぶものとします。
データセットの数は 100 を超えません。
Sample Input
2 3 1 4 0 1 0 1 
4 2 3 2 2 2 1 1
Output for the Sample Input
1 4 1 4 1 2 1 2 
4 1 4 1 2 1 2 1",Java,"import java.util.*;

public class Main {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        
        while (sc.hasNext()) {
            int[] people = new int[8];
            for (int i = 0; i < 8; i++) {
                people[i] = sc.nextInt();
            }
            
            int[] rides = {4, 1, 4, 1, 2, 1, 2, 1};
            
            int minUnserved = Integer.MAX_VALUE;
            int[] bestArrangement = new int[8];
            
            for (int rotation = 0; rotation < 8; rotation++) {
                int[] currentArrangement = new int[8];
                for (int i = 0; i < 8; i++) {
                    currentArrangement[i] = rides[(i - rotation + 8) % 8];
                }
                
                int unserved = 0;
                for (int i = 0; i < 8; i++) {
                    unserved += Math.max(0, people[i] - currentArrangement[i]);
                }
                
                if (unserved < minUnserved) {
                    minUnserved = unserved;
                    bestArrangement = currentArrangement.clone();
                } else if (unserved == minUnserved) {
                    if (isSmaller(currentArrangement, bestArrangement)) {
                        bestArrangement = currentArrangement.clone();
                    }
                }
            }
            
            for (int i = 0; i < 8; i++) {
                if (i > 0) System.out.print("" "");
                System.out.print(bestArrangement[i]);
            }
            System.out.println();
        }
        
        sc.close();
    }
    
    private static boolean isSmaller(int[] a, int[] b) {
        for (int i = 0; i < 8; i++) {
            if (a[i] < b[i]) return true;
            if (a[i] > b[i]) return false;
        }
        return false;
    }
}
",0
p00082,"メリーゴーランド
遊園地にあるメリーゴーランドはご存じでしょう。大きな円盤の上に馬や馬車などの乗り物が固定されていて、円盤が回転すると同時に乗り物が上下に揺れる、定番の遊具です。ある遊園地のメリーゴーランドは、４人乗りの馬車が２台、２人乗りの車２台、１人乗りの馬が４台、計８台の乗り物が図１のような順序で備えられています。そして、遊園地においでのお客様は、図１に示す乗り場０〜７のどこかで待つようになっています。
この遊園地のメリーゴーランドは、かならず乗り物が乗り場にぴったりと合う位置に停止します。そして、０〜７のそれぞれで待っているお客さまは、目の前にとまった乗り物に乗ることになっています。急いで他の乗り場へ移動してそこから乗るということはできません。効率よく、お客さまにたのしんでいただくためには、メリーゴーランドの停止する位置をうまく調整して、乗れないお客さまをできるだけ少なくするようにしなければなりません。
乗り場０〜７で待っているお客さまの人数を読み込んで、どの位置にどの乗り物が来るように止めれば乗れないお客さまが最も少なくなるかを出力するプログラムを作成してください。
入力
入力は複数のデータセットからなります。各データセットは以下の形式で与えられます。
p
0
p
1
p
2
p
3
p
4
p
5
p
6
p
7
乗り場 0, 1, ..., 7 で待っているお客様の人数を表す整数
p
0
,
p
1
,... ,
p
7
( 0 ≤
p
i
≤ 10,000) が空白区切りで１行に与えられます。
出力
メリーゴーランドの乗り物の馬車を 4、車を 2、馬を 1 で表すこととします。乗り場 0, 1, ... , 7 にとめる乗り物を、それぞれ
c
0
,
c
1
,...,
c
7
とします。データセットごとに、
c
0
,
c
1
,...,
c
7
を空白区切りで 1 行に出力します。
なお、乗れなくなるお客さまが最小となるとめ方が複数ある場合は、
c
0
c
1
c
2
c
3
c
4
c
5
c
6
c
7
を 8 桁の整数
V
とみなし、
V
が最小となるとめ方を選ぶものとします。
データセットの数は 100 を超えません。
Sample Input
2 3 1 4 0 1 0 1 
4 2 3 2 2 2 1 1
Output for the Sample Input
1 4 1 4 1 2 1 2 
4 1 4 1 2 1 2 1",Java,"import java.util.*;
import java.io.*;
import static java.lang.Math.*;

class Main {
    
    public static void main( final String[] args ) {
	
	final Scanner stdin = new Scanner( System.in );
	final int[] ls = { 4, 1, 4, 1, 2, 1, 2, 1 };
	
	while ( stdin.hasNextInt() ) {
	    final int[] ps = new int[8];
	    for ( int i = 0; i < 8; i++ ) {
		ps[i] = stdin.nextInt();
	    }
	    
	    final int[] ans = new int[8];	    
	    int maxPeople = 0;
	    for ( int i = 0; i < 8; i++ ) {
		final int p = ip( ps, ls );
		if ( p > maxPeople ) {
		    maxPeople = p;
		    System.arraycopy( ls, 0, ans, 0, 8 );
		}
		next( ls );
	    }
	    System.out.print( ans[0] );
	    for ( int i = 1; i < 8; i++ ) {
		System.out.print( "" "" + ans[i] );
	    }
	    System.out.println();
	}
    }
    
    static void next( int[] a ) {
	final int front = a[0];
	for ( int i = 0; i < 7; i++ ) {
	    a[i] = a[i + 1];
	}
	a[7] = front;
    }

    static int ip( int[] ps, int[] ls ) {
	int sum = 0;
	for ( int i = 0; i < ps.length; i++ ){
	    sum += min( ls[i], ps[i] );
	}
	return sum;
    }    
}",1
p00082,"メリーゴーランド
遊園地にあるメリーゴーランドはご存じでしょう。大きな円盤の上に馬や馬車などの乗り物が固定されていて、円盤が回転すると同時に乗り物が上下に揺れる、定番の遊具です。ある遊園地のメリーゴーランドは、４人乗りの馬車が２台、２人乗りの車２台、１人乗りの馬が４台、計８台の乗り物が図１のような順序で備えられています。そして、遊園地においでのお客様は、図１に示す乗り場０〜７のどこかで待つようになっています。
この遊園地のメリーゴーランドは、かならず乗り物が乗り場にぴったりと合う位置に停止します。そして、０〜７のそれぞれで待っているお客さまは、目の前にとまった乗り物に乗ることになっています。急いで他の乗り場へ移動してそこから乗るということはできません。効率よく、お客さまにたのしんでいただくためには、メリーゴーランドの停止する位置をうまく調整して、乗れないお客さまをできるだけ少なくするようにしなければなりません。
乗り場０〜７で待っているお客さまの人数を読み込んで、どの位置にどの乗り物が来るように止めれば乗れないお客さまが最も少なくなるかを出力するプログラムを作成してください。
入力
入力は複数のデータセットからなります。各データセットは以下の形式で与えられます。
p
0
p
1
p
2
p
3
p
4
p
5
p
6
p
7
乗り場 0, 1, ..., 7 で待っているお客様の人数を表す整数
p
0
,
p
1
,... ,
p
7
( 0 ≤
p
i
≤ 10,000) が空白区切りで１行に与えられます。
出力
メリーゴーランドの乗り物の馬車を 4、車を 2、馬を 1 で表すこととします。乗り場 0, 1, ... , 7 にとめる乗り物を、それぞれ
c
0
,
c
1
,...,
c
7
とします。データセットごとに、
c
0
,
c
1
,...,
c
7
を空白区切りで 1 行に出力します。
なお、乗れなくなるお客さまが最小となるとめ方が複数ある場合は、
c
0
c
1
c
2
c
3
c
4
c
5
c
6
c
7
を 8 桁の整数
V
とみなし、
V
が最小となるとめ方を選ぶものとします。
データセットの数は 100 を超えません。
Sample Input
2 3 1 4 0 1 0 1 
4 2 3 2 2 2 1 1
Output for the Sample Input
1 4 1 4 1 2 1 2 
4 1 4 1 2 1 2 1",Python,"import sys
from itertools import permutations

def solve(passengers):
    # Define the vehicles: 4, 4, 2, 2, 1, 1, 1, 1
    vehicles = [4, 4, 2, 2, 1, 1, 1, 1]
    
    min_unable = float('inf')
    best_arrangement = None
    
    # Generate all unique permutations of vehicles
    seen = set()
    for perm in permutations(vehicles):
        if perm in seen:
            continue
        seen.add(perm)
        
        # Calculate unable to ride
        unable = 0
        for i in range(8):
            if passengers[i] > perm[i]:
                unable += passengers[i] - perm[i]
        
        # Check if this is better
        if unable < min_unable:
            min_unable = unable
            best_arrangement = perm
        elif unable == min_unable:
            # Compare lexicographically
            if perm < best_arrangement:
                best_arrangement = perm
    
    return best_arrangement

# Read all input
lines = []
for line in sys.stdin:
    line = line.strip()
    if line:
        lines.append(line)

# Process each dataset
for line in lines:
    passengers = list(map(int, line.split()))
    result = solve(passengers)
    print(' '.join(map(str, result)))
",0
p00082,"メリーゴーランド
遊園地にあるメリーゴーランドはご存じでしょう。大きな円盤の上に馬や馬車などの乗り物が固定されていて、円盤が回転すると同時に乗り物が上下に揺れる、定番の遊具です。ある遊園地のメリーゴーランドは、４人乗りの馬車が２台、２人乗りの車２台、１人乗りの馬が４台、計８台の乗り物が図１のような順序で備えられています。そして、遊園地においでのお客様は、図１に示す乗り場０〜７のどこかで待つようになっています。
この遊園地のメリーゴーランドは、かならず乗り物が乗り場にぴったりと合う位置に停止します。そして、０〜７のそれぞれで待っているお客さまは、目の前にとまった乗り物に乗ることになっています。急いで他の乗り場へ移動してそこから乗るということはできません。効率よく、お客さまにたのしんでいただくためには、メリーゴーランドの停止する位置をうまく調整して、乗れないお客さまをできるだけ少なくするようにしなければなりません。
乗り場０〜７で待っているお客さまの人数を読み込んで、どの位置にどの乗り物が来るように止めれば乗れないお客さまが最も少なくなるかを出力するプログラムを作成してください。
入力
入力は複数のデータセットからなります。各データセットは以下の形式で与えられます。
p
0
p
1
p
2
p
3
p
4
p
5
p
6
p
7
乗り場 0, 1, ..., 7 で待っているお客様の人数を表す整数
p
0
,
p
1
,... ,
p
7
( 0 ≤
p
i
≤ 10,000) が空白区切りで１行に与えられます。
出力
メリーゴーランドの乗り物の馬車を 4、車を 2、馬を 1 で表すこととします。乗り場 0, 1, ... , 7 にとめる乗り物を、それぞれ
c
0
,
c
1
,...,
c
7
とします。データセットごとに、
c
0
,
c
1
,...,
c
7
を空白区切りで 1 行に出力します。
なお、乗れなくなるお客さまが最小となるとめ方が複数ある場合は、
c
0
c
1
c
2
c
3
c
4
c
5
c
6
c
7
を 8 桁の整数
V
とみなし、
V
が最小となるとめ方を選ぶものとします。
データセットの数は 100 を超えません。
Sample Input
2 3 1 4 0 1 0 1 
4 2 3 2 2 2 1 1
Output for the Sample Input
1 4 1 4 1 2 1 2 
4 1 4 1 2 1 2 1",Python,"import sys
p=['41412121','41212141','21414121','21214141','14141212','14121214','12141412','12121414']
g=lambda x:list(map(int,x))
for e in sys.stdin:
 d={}
 for f in p:d[sum(s-t for s,t in zip(g(e.split()),g(f))if s>t)]=f
 print(*list(d[min(d)]))
",1
p00083,"西暦和暦変換
西暦で表された年月日を、元号を用いた和暦に変換し、その年月日を出力するプログラムを作成してください。入力は例に示すように 3 つの整数であり、順に西暦年、月、日です。これを、出力例に示すように変換してください。なお、明治以前の年月日が入力された場合は「pre-meiji」と表示してください。
各年号の最初の年は「元年」ではなく「１年」と出力することとします。
元号
期間
meiji
1868. 9. 8	〜	1912. 7.29
taisho
1912. 7.30	〜	1926.12.24
showa
1926.12.25	〜	1989. 1. 7
heisei
1989. 1. 8	〜
入力
複数のデータが与えられます。各データとして年、月、日を表す３つの整数が空白区切りで１行に与えられます。
入力の終わりまで処理してください。データの数は 50 を超えません。
出力
空白区切りの元号、年、月、日、または「pre-meiji」を１行に出力してください。
Sample Input
2005 9 3
1868 12 2
1868 9 7
Output for the Sample Input
heisei 17 9 3
meiji 1 12 2
pre-meiji",C,"#include <stdio.h>

int main() {
    int year, month, day;
    
    while (scanf(""%d %d %d"", &year, &month, &day) != EOF) {
        if (year < 1868 || (year == 1868 && month < 9) || (year == 1868 && month == 9 && day < 8)) {
            printf(""pre-meiji\n"");
        }
        else if (year < 1912 || (year == 1912 && month < 7) || (year == 1912 && month == 7 && day <= 29)) {
            printf(""meiji %d %d %d\n"", year - 1868 + 1, month, day);
        }
        else if (year < 1926 || (year == 1926 && month < 12) || (year == 1926 && month == 12 && day <= 24)) {
            printf(""taisho %d %d %d\n"", year - 1912 + 1, month, day);
        }
        else if (year < 1989 || (year == 1989 && month == 1 && day <= 7)) {
            printf(""showa %d %d %d\n"", year - 1926 + 1, month, day);
        }
        else {
            printf(""heisei %d %d %d\n"", year - 1989 + 1, month, day);
        }
    }
    
    return 0;
}
",0
p00083,"西暦和暦変換
西暦で表された年月日を、元号を用いた和暦に変換し、その年月日を出力するプログラムを作成してください。入力は例に示すように 3 つの整数であり、順に西暦年、月、日です。これを、出力例に示すように変換してください。なお、明治以前の年月日が入力された場合は「pre-meiji」と表示してください。
各年号の最初の年は「元年」ではなく「１年」と出力することとします。
元号
期間
meiji
1868. 9. 8	〜	1912. 7.29
taisho
1912. 7.30	〜	1926.12.24
showa
1926.12.25	〜	1989. 1. 7
heisei
1989. 1. 8	〜
入力
複数のデータが与えられます。各データとして年、月、日を表す３つの整数が空白区切りで１行に与えられます。
入力の終わりまで処理してください。データの数は 50 を超えません。
出力
空白区切りの元号、年、月、日、または「pre-meiji」を１行に出力してください。
Sample Input
2005 9 3
1868 12 2
1868 9 7
Output for the Sample Input
heisei 17 9 3
meiji 1 12 2
pre-meiji",C,"#include<stdio.h>
int main(){
  int a,b,c,d,t=0;
  char s;
  while(scanf(""%d %d %d"",&a,&b,&c)!=EOF){
    if(a<=1868 && b<=9 && c<8){
      printf(""pre-meiji\n"");
      d=1;
      t=1;
    }
    else if(a<=1912){
      if(a!=1912){
	printf(""meiji "");
	a=a-1868+1;
	d=0;
	t=1;
      }
      else if(a==1912){
	if(b<7){
	  printf(""meiji "");
	  a=a-1868+1;
	  d=0;
	  t=1;
	}
	else if(b>=7){
	  if(c<30){
	    printf(""meiji "");
	    a=a-1868+1;
	    d=0;
	    t=1;
	  }
	}
      }
    }
    if(a<=1926 && t==0){
      if(a!=1926){
	printf(""taisyo "");
	a=a-1912+1;
	d=0;
	t=1;
      }
      else if(a==1926){
	if(b<12){
	  printf(""taisyo "");
	  a=a-1912+1;
	  d=0;
	  t=1;
	}
	else if(b==12){
	  if(c<25){
	    printf(""taisyo "");
	    a=a-1912+1;
	    d=0;
	    t=1;
	  }
	  if(c>=25){
	    printf(""showa "");
	    a=a-1926+1;
	    d=0;
	    t=1;
	  }
	}
      }
    }
    if(a<=1989 && t==0){
      if(a!=1989){
	printf(""showa "");
	a=a-1926+1;
	d=0;
	t=1;
      }
      else if(a==1989){
	if(b==1){
	  if(c<8){
	    printf(""showa "");
	    a=a-1926+1;
	    d=0;
	    t=1;
	  }
	}
      }
    }
    if(a>=1989 && t==0){
      if(a!=1989){
      printf(""heisei "");
      a=a-1989+1;
      d=0;
    }
      else if(a==1989){
	if(b!=1){
	  printf(""heisei "");
	  a=a-1989+1;
	  d=0;
	}
	else if(b==1){
	  if(c>=8){
	  printf(""heisei "");
	  a=a-1989+1;
	  d=0;
	  }
	}
      }
    }
    if(d==0){
      printf(""%d %d %d\n"",a,b,c);
    }
  }
  return (0);
}",1
p00083,"西暦和暦変換
西暦で表された年月日を、元号を用いた和暦に変換し、その年月日を出力するプログラムを作成してください。入力は例に示すように 3 つの整数であり、順に西暦年、月、日です。これを、出力例に示すように変換してください。なお、明治以前の年月日が入力された場合は「pre-meiji」と表示してください。
各年号の最初の年は「元年」ではなく「１年」と出力することとします。
元号
期間
meiji
1868. 9. 8	〜	1912. 7.29
taisho
1912. 7.30	〜	1926.12.24
showa
1926.12.25	〜	1989. 1. 7
heisei
1989. 1. 8	〜
入力
複数のデータが与えられます。各データとして年、月、日を表す３つの整数が空白区切りで１行に与えられます。
入力の終わりまで処理してください。データの数は 50 を超えません。
出力
空白区切りの元号、年、月、日、または「pre-meiji」を１行に出力してください。
Sample Input
2005 9 3
1868 12 2
1868 9 7
Output for the Sample Input
heisei 17 9 3
meiji 1 12 2
pre-meiji",Java,"import java.util.Scanner;

public class Main {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        
        while (sc.hasNext()) {
            int year = sc.nextInt();
            int month = sc.nextInt();
            int day = sc.nextInt();
            
            // Convert to comparable format (YYYYMMDD)
            int date = year * 10000 + month * 100 + day;
            
            // Define era boundaries
            int meijiStart = 18680908;
            int meijiEnd = 19120729;
            int taishoStart = 19120730;
            int taishoEnd = 19261224;
            int showaStart = 19261225;
            int showaEnd = 19890107;
            int heiseiStart = 19890108;
            
            if (date < meijiStart) {
                System.out.println(""pre-meiji"");
            } else if (date >= meijiStart && date <= meijiEnd) {
                int eraYear = year - 1868 + 1;
                System.out.println(""meiji "" + eraYear + "" "" + month + "" "" + day);
            } else if (date >= taishoStart && date <= taishoEnd) {
                int eraYear = year - 1912 + 1;
                System.out.println(""taisho "" + eraYear + "" "" + month + "" "" + day);
            } else if (date >= showaStart && date <= showaEnd) {
                int eraYear = year - 1926 + 1;
                System.out.println(""showa "" + eraYear + "" "" + month + "" "" + day);
            } else if (date >= heiseiStart) {
                int eraYear = year - 1989 + 1;
                System.out.println(""heisei "" + eraYear + "" "" + month + "" "" + day);
            }
        }
        
        sc.close();
    }
}
",0
p00083,"西暦和暦変換
西暦で表された年月日を、元号を用いた和暦に変換し、その年月日を出力するプログラムを作成してください。入力は例に示すように 3 つの整数であり、順に西暦年、月、日です。これを、出力例に示すように変換してください。なお、明治以前の年月日が入力された場合は「pre-meiji」と表示してください。
各年号の最初の年は「元年」ではなく「１年」と出力することとします。
元号
期間
meiji
1868. 9. 8	〜	1912. 7.29
taisho
1912. 7.30	〜	1926.12.24
showa
1926.12.25	〜	1989. 1. 7
heisei
1989. 1. 8	〜
入力
複数のデータが与えられます。各データとして年、月、日を表す３つの整数が空白区切りで１行に与えられます。
入力の終わりまで処理してください。データの数は 50 を超えません。
出力
空白区切りの元号、年、月、日、または「pre-meiji」を１行に出力してください。
Sample Input
2005 9 3
1868 12 2
1868 9 7
Output for the Sample Input
heisei 17 9 3
meiji 1 12 2
pre-meiji",Java,"import java.io.*;
class Main
{
    public static void main(String args[])throws IOException
    {
	BufferedReader input=new BufferedReader(new InputStreamReader(System.in));
	String str;
	while((str=input.readLine())!=null)
	    {
		String str_ary[]=str.split("" "");
		int x[]=new int[3];
		for(int i=0;i<3;i++)
		    {
			x[i]=Integer.parseInt(str_ary[i]);
			
		    }
		if((x[0]<1868) 
		   || ((x[0]==1868) && (x[1]<9))
		   || ((x[0]==1868) && (x[1]==9) && (x[2]<8)))System.out.println(""pre-meiji"");
		if(((1869<=x[0]) && (x[0]<=1911))
		   || (x[0]==1868) && (9<=x[1]) && (8<=x[2])
		   
		   || (x[0]==1912 && x[1]==7 && x[2]<=29)
		   || (x[0]==1912) && x[1]<=7)System.out.println(""meiji"");
		if(((1913<=x[0]) && (x[0]<=1925))
		   || ((x[0]==1912) && (7<=x[1]) && (30<=x[2]))
		   || (x[0]==1926 && x[1]==12 && x[2]<=24)
		   || ((x[0]==1912) && (7<=x[1]))
		   )System.out.println(""taisho"");
		if(((1927<=x[0]) && (x[0]<=1988))
		   || ((x[0]==1926) && (12==x[1]) && (25<=x[2]))
		   || ((x[0]==1989) && (x[1]==1) && (x[2]<=7))
		   
		   
)System.out.println(""showa"");
		if((1989==x[0]) && (1<=x[1]) && (8<=x[2])
		   || 1990<=x[0]
		   || (1989==x[0]) && (1<x[1]))System.out.println(""heisei"");
	    }
    }
}",1
p00083,"西暦和暦変換
西暦で表された年月日を、元号を用いた和暦に変換し、その年月日を出力するプログラムを作成してください。入力は例に示すように 3 つの整数であり、順に西暦年、月、日です。これを、出力例に示すように変換してください。なお、明治以前の年月日が入力された場合は「pre-meiji」と表示してください。
各年号の最初の年は「元年」ではなく「１年」と出力することとします。
元号
期間
meiji
1868. 9. 8	〜	1912. 7.29
taisho
1912. 7.30	〜	1926.12.24
showa
1926.12.25	〜	1989. 1. 7
heisei
1989. 1. 8	〜
入力
複数のデータが与えられます。各データとして年、月、日を表す３つの整数が空白区切りで１行に与えられます。
入力の終わりまで処理してください。データの数は 50 を超えません。
出力
空白区切りの元号、年、月、日、または「pre-meiji」を１行に出力してください。
Sample Input
2005 9 3
1868 12 2
1868 9 7
Output for the Sample Input
heisei 17 9 3
meiji 1 12 2
pre-meiji",Python,"import sys

def to_wareki(year, month, day):
    # Convert date to comparable format (YYYYMMDD)
    date = year * 10000 + month * 100 + day
    
    # Era boundaries in YYYYMMDD format
    meiji_start = 18680908
    meiji_end = 19120729
    taisho_start = 19120730
    taisho_end = 19261224
    showa_start = 19261225
    showa_end = 19890107
    heisei_start = 19890108
    
    if date < meiji_start:
        return ""pre-meiji""
    elif date <= meiji_end:
        wareki_year = year - 1868 + 1
        return f""meiji {wareki_year} {month} {day}""
    elif date <= taisho_end:
        wareki_year = year - 1912 + 1
        return f""taisho {wareki_year} {month} {day}""
    elif date <= showa_end:
        wareki_year = year - 1926 + 1
        return f""showa {wareki_year} {month} {day}""
    else:
        wareki_year = year - 1989 + 1
        return f""heisei {wareki_year} {month} {day}""

for line in sys.stdin:
    parts = line.strip().split()
    year = int(parts[0])
    month = int(parts[1])
    day = int(parts[2])
    print(to_wareki(year, month, day))
",0
p00083,"西暦和暦変換
西暦で表された年月日を、元号を用いた和暦に変換し、その年月日を出力するプログラムを作成してください。入力は例に示すように 3 つの整数であり、順に西暦年、月、日です。これを、出力例に示すように変換してください。なお、明治以前の年月日が入力された場合は「pre-meiji」と表示してください。
各年号の最初の年は「元年」ではなく「１年」と出力することとします。
元号
期間
meiji
1868. 9. 8	〜	1912. 7.29
taisho
1912. 7.30	〜	1926.12.24
showa
1926.12.25	〜	1989. 1. 7
heisei
1989. 1. 8	〜
入力
複数のデータが与えられます。各データとして年、月、日を表す３つの整数が空白区切りで１行に与えられます。
入力の終わりまで処理してください。データの数は 50 を超えません。
出力
空白区切りの元号、年、月、日、または「pre-meiji」を１行に出力してください。
Sample Input
2005 9 3
1868 12 2
1868 9 7
Output for the Sample Input
heisei 17 9 3
meiji 1 12 2
pre-meiji",Python,"from datetime import datetime
def era(f):
    meiji_st  = datetime(1868, 9, 8)
    taisho_st = datetime(1912, 7,30)
    showa_st  = datetime(1926,12,25)
    heisei_st = datetime(1989, 1, 8)

    y,m,d = f
    dt = datetime(y,m,d)
    if dt > heisei_st:
        ret = ""heisei %d %d %d"" % (dt.year - heisei_st.year+1,dt.month,dt.day) 
    elif dt > showa_st:
        ret = ""showa %d %d %d"" % (dt.year - showa_st.year+1,dt.month,dt.day) 
    elif dt > taisho_st:
        ret = ""taisho %d %d %d"" % (dt.year - taisho_st.year+1,dt.month,dt.day) 
    elif dt > meiji_st:
        ret = ""meiji %d %d %d"" % (dt.year - meiji_st.year+1,dt.month,dt.day) 
    else:
       ret = ""pre-meiji""

    return(ret)

while True:
    try:
        f = map(int, input().strip().split())
        print(era(f))
    except EOFError:
        break",1
p00085,"ヨセフのおイモ
昔、ヨセフのおイモというゲームがありました。
n
人が参加しているとしましょう。参加者は中心を向いて円陣を組み、1 から順番に番号が振られます。アツアツのおイモがひとつ、参加者
n
(左の図内側の大きい数字の 30 )に渡されます。おイモを渡された参加者は右隣の参加者にそのおイモを渡します。
m
回目に渡された人は右隣の人に渡して円陣から抜けます(左の図では
m
= 9 の場合を表しています) 。 回渡す毎に一人ずつぬけ、最後に残った人が勝者となり、おイモをいただきます。
n
,
m
が決まってから、実際におイモを渡し始める前にどこにいたら勝てるかわかるといいですよね。上の図は 30 人の参加者で 9 人ごとに抜けるというルールでこのゲームをした場合を書き表しています。内側の大きい数字が参加者に振られた番号、外側の小さい数字が抜ける順番です。それによると、9,18,27,6,16,26 という順番で円陣から抜け出し、最後には 21 が残ることになります。すなわち 21 が勝者となります(小さい数字が 30 になっています)。
ゲーム参加者数
n
と円陣から抜け出す参加者の間隔
m
を入力し、勝者の番号を出力するプログラムを作成してください。ただし、
m
,
n
< 1000 とします。
入力
複数のデータセットが与えられます。各データセットは以下の形式で与えられます。
n
m
ゲーム参加者数
n
（整数）と円陣から抜け出す参加者の間隔
m
（整数）が空白区切りで１行に与えられます。
入力は２つの 0 で終わります。データセットの数は 50 を超えません。
出力
各データセットに対して、勝者となりおイモをいただく人の番号（整数）を１行に出力してください。
Sample Input
41 3
30 9
0 0
Output for the Sample Input
31
21",C,"#include <stdio.h>

int main() {
    int n, m;
    
    while(1) {
        scanf(""%d %d"", &n, &m);
        if(n == 0 && m == 0) break;
        
        int people[1000];
        for(int i = 0; i < n; i++) {
            people[i] = i + 1;
        }
        
        int count = n;
        int pos = n - 1;
        
        while(count > 1) {
            int steps = m % count;
            if(steps == 0) steps = count;
            
            pos = (pos + steps) % count;
            
            for(int i = pos; i < count - 1; i++) {
                people[i] = people[i + 1];
            }
            count--;
            
            if(count > 0) {
                pos = pos % count;
            }
        }
        
        printf(""%d\n"", people[0]);
    }
    
    return 0;
}
",0
p00085,"ヨセフのおイモ
昔、ヨセフのおイモというゲームがありました。
n
人が参加しているとしましょう。参加者は中心を向いて円陣を組み、1 から順番に番号が振られます。アツアツのおイモがひとつ、参加者
n
(左の図内側の大きい数字の 30 )に渡されます。おイモを渡された参加者は右隣の参加者にそのおイモを渡します。
m
回目に渡された人は右隣の人に渡して円陣から抜けます(左の図では
m
= 9 の場合を表しています) 。 回渡す毎に一人ずつぬけ、最後に残った人が勝者となり、おイモをいただきます。
n
,
m
が決まってから、実際におイモを渡し始める前にどこにいたら勝てるかわかるといいですよね。上の図は 30 人の参加者で 9 人ごとに抜けるというルールでこのゲームをした場合を書き表しています。内側の大きい数字が参加者に振られた番号、外側の小さい数字が抜ける順番です。それによると、9,18,27,6,16,26 という順番で円陣から抜け出し、最後には 21 が残ることになります。すなわち 21 が勝者となります(小さい数字が 30 になっています)。
ゲーム参加者数
n
と円陣から抜け出す参加者の間隔
m
を入力し、勝者の番号を出力するプログラムを作成してください。ただし、
m
,
n
< 1000 とします。
入力
複数のデータセットが与えられます。各データセットは以下の形式で与えられます。
n
m
ゲーム参加者数
n
（整数）と円陣から抜け出す参加者の間隔
m
（整数）が空白区切りで１行に与えられます。
入力は２つの 0 で終わります。データセットの数は 50 を超えません。
出力
各データセットに対して、勝者となりおイモをいただく人の番号（整数）を１行に出力してください。
Sample Input
41 3
30 9
0 0
Output for the Sample Input
31
21",C,"#include<stdio.h>
#include<stdlib.h>
int main(void){
	int n,m,i,j;
	while(scanf(""%d"",&n)!=EOF){
		scanf(""%d"",&m);
		for(i=j=0;i++<n;j%=i){j+=m;}
		printf(""%d\n"",j+1);
	}
	return 0; 
}",1
p00085,"ヨセフのおイモ
昔、ヨセフのおイモというゲームがありました。
n
人が参加しているとしましょう。参加者は中心を向いて円陣を組み、1 から順番に番号が振られます。アツアツのおイモがひとつ、参加者
n
(左の図内側の大きい数字の 30 )に渡されます。おイモを渡された参加者は右隣の参加者にそのおイモを渡します。
m
回目に渡された人は右隣の人に渡して円陣から抜けます(左の図では
m
= 9 の場合を表しています) 。 回渡す毎に一人ずつぬけ、最後に残った人が勝者となり、おイモをいただきます。
n
,
m
が決まってから、実際におイモを渡し始める前にどこにいたら勝てるかわかるといいですよね。上の図は 30 人の参加者で 9 人ごとに抜けるというルールでこのゲームをした場合を書き表しています。内側の大きい数字が参加者に振られた番号、外側の小さい数字が抜ける順番です。それによると、9,18,27,6,16,26 という順番で円陣から抜け出し、最後には 21 が残ることになります。すなわち 21 が勝者となります(小さい数字が 30 になっています)。
ゲーム参加者数
n
と円陣から抜け出す参加者の間隔
m
を入力し、勝者の番号を出力するプログラムを作成してください。ただし、
m
,
n
< 1000 とします。
入力
複数のデータセットが与えられます。各データセットは以下の形式で与えられます。
n
m
ゲーム参加者数
n
（整数）と円陣から抜け出す参加者の間隔
m
（整数）が空白区切りで１行に与えられます。
入力は２つの 0 で終わります。データセットの数は 50 を超えません。
出力
各データセットに対して、勝者となりおイモをいただく人の番号（整数）を１行に出力してください。
Sample Input
41 3
30 9
0 0
Output for the Sample Input
31
21",Java,"import java.util.*;

public class Main {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        
        while (true) {
            int n = sc.nextInt();
            int m = sc.nextInt();
            
            if (n == 0 && m == 0) {
                break;
            }
            
            ArrayList<Integer> people = new ArrayList<>();
            for (int i = 1; i <= n; i++) {
                people.add(i);
            }
            
            int currentIndex = 0;
            
            while (people.size() > 1) {
                currentIndex = (currentIndex + m - 1) % people.size();
                people.remove(currentIndex);
                if (currentIndex == people.size() && people.size() > 0) {
                    currentIndex = 0;
                }
            }
            
            System.out.println(people.get(0));
        }
        
        sc.close();
    }
}
",0
p00085,"ヨセフのおイモ
昔、ヨセフのおイモというゲームがありました。
n
人が参加しているとしましょう。参加者は中心を向いて円陣を組み、1 から順番に番号が振られます。アツアツのおイモがひとつ、参加者
n
(左の図内側の大きい数字の 30 )に渡されます。おイモを渡された参加者は右隣の参加者にそのおイモを渡します。
m
回目に渡された人は右隣の人に渡して円陣から抜けます(左の図では
m
= 9 の場合を表しています) 。 回渡す毎に一人ずつぬけ、最後に残った人が勝者となり、おイモをいただきます。
n
,
m
が決まってから、実際におイモを渡し始める前にどこにいたら勝てるかわかるといいですよね。上の図は 30 人の参加者で 9 人ごとに抜けるというルールでこのゲームをした場合を書き表しています。内側の大きい数字が参加者に振られた番号、外側の小さい数字が抜ける順番です。それによると、9,18,27,6,16,26 という順番で円陣から抜け出し、最後には 21 が残ることになります。すなわち 21 が勝者となります(小さい数字が 30 になっています)。
ゲーム参加者数
n
と円陣から抜け出す参加者の間隔
m
を入力し、勝者の番号を出力するプログラムを作成してください。ただし、
m
,
n
< 1000 とします。
入力
複数のデータセットが与えられます。各データセットは以下の形式で与えられます。
n
m
ゲーム参加者数
n
（整数）と円陣から抜け出す参加者の間隔
m
（整数）が空白区切りで１行に与えられます。
入力は２つの 0 で終わります。データセットの数は 50 を超えません。
出力
各データセットに対して、勝者となりおイモをいただく人の番号（整数）を１行に出力してください。
Sample Input
41 3
30 9
0 0
Output for the Sample Input
31
21",Java,"import java.io.*;
import java.util.*;

public class Main {
	public static void main ( String[] args ) {
		Scanner sc = new Scanner(System.in);
		ArrayList<Integer> List;
		while ( true ) {
			int remove = 0;
			List = new ArrayList<Integer>();
			int size = sc.nextInt();
			int space = sc.nextInt();
			if ( size == 0 && space == 0 ) break;
			space--;
			for ( int i = 1; i <= size; i++ )
				List.add(i);
			while ( List.size() != 1 ) {
				remove += space;
				while ( remove >= List.size() )
					remove -= List.size();
				List.remove(remove);
			}
			System.out.println(List.get(0));
		}
	}
}",1
p00085,"ヨセフのおイモ
昔、ヨセフのおイモというゲームがありました。
n
人が参加しているとしましょう。参加者は中心を向いて円陣を組み、1 から順番に番号が振られます。アツアツのおイモがひとつ、参加者
n
(左の図内側の大きい数字の 30 )に渡されます。おイモを渡された参加者は右隣の参加者にそのおイモを渡します。
m
回目に渡された人は右隣の人に渡して円陣から抜けます(左の図では
m
= 9 の場合を表しています) 。 回渡す毎に一人ずつぬけ、最後に残った人が勝者となり、おイモをいただきます。
n
,
m
が決まってから、実際におイモを渡し始める前にどこにいたら勝てるかわかるといいですよね。上の図は 30 人の参加者で 9 人ごとに抜けるというルールでこのゲームをした場合を書き表しています。内側の大きい数字が参加者に振られた番号、外側の小さい数字が抜ける順番です。それによると、9,18,27,6,16,26 という順番で円陣から抜け出し、最後には 21 が残ることになります。すなわち 21 が勝者となります(小さい数字が 30 になっています)。
ゲーム参加者数
n
と円陣から抜け出す参加者の間隔
m
を入力し、勝者の番号を出力するプログラムを作成してください。ただし、
m
,
n
< 1000 とします。
入力
複数のデータセットが与えられます。各データセットは以下の形式で与えられます。
n
m
ゲーム参加者数
n
（整数）と円陣から抜け出す参加者の間隔
m
（整数）が空白区切りで１行に与えられます。
入力は２つの 0 で終わります。データセットの数は 50 を超えません。
出力
各データセットに対して、勝者となりおイモをいただく人の番号（整数）を１行に出力してください。
Sample Input
41 3
30 9
0 0
Output for the Sample Input
31
21",Python,"def find_winner(n, m):
    people = list(range(1, n + 1))
    current = 0
    
    while len(people) > 1:
        current = (current + m - 1) % len(people)
        people.pop(current)
        if current == len(people) and len(people) > 0:
            current = 0
    
    return people[0]

while True:
    n, m = map(int, input().split())
    if n == 0 and m == 0:
        break
    print(find_winner(n, m))
",0
p00085,"ヨセフのおイモ
昔、ヨセフのおイモというゲームがありました。
n
人が参加しているとしましょう。参加者は中心を向いて円陣を組み、1 から順番に番号が振られます。アツアツのおイモがひとつ、参加者
n
(左の図内側の大きい数字の 30 )に渡されます。おイモを渡された参加者は右隣の参加者にそのおイモを渡します。
m
回目に渡された人は右隣の人に渡して円陣から抜けます(左の図では
m
= 9 の場合を表しています) 。 回渡す毎に一人ずつぬけ、最後に残った人が勝者となり、おイモをいただきます。
n
,
m
が決まってから、実際におイモを渡し始める前にどこにいたら勝てるかわかるといいですよね。上の図は 30 人の参加者で 9 人ごとに抜けるというルールでこのゲームをした場合を書き表しています。内側の大きい数字が参加者に振られた番号、外側の小さい数字が抜ける順番です。それによると、9,18,27,6,16,26 という順番で円陣から抜け出し、最後には 21 が残ることになります。すなわち 21 が勝者となります(小さい数字が 30 になっています)。
ゲーム参加者数
n
と円陣から抜け出す参加者の間隔
m
を入力し、勝者の番号を出力するプログラムを作成してください。ただし、
m
,
n
< 1000 とします。
入力
複数のデータセットが与えられます。各データセットは以下の形式で与えられます。
n
m
ゲーム参加者数
n
（整数）と円陣から抜け出す参加者の間隔
m
（整数）が空白区切りで１行に与えられます。
入力は２つの 0 で終わります。データセットの数は 50 を超えません。
出力
各データセットに対して、勝者となりおイモをいただく人の番号（整数）を１行に出力してください。
Sample Input
41 3
30 9
0 0
Output for the Sample Input
31
21",Python,"while 1:
  n,m=map(int,raw_input().split())
  if n==0==m:break
  p=0
  for i in range(2,n+1):p=(p+m)%i
  print p+1",1
p00086,"パトロール
文久２（1862）年、会津の殿様が京都守護職を命ぜられました。京都守護職とは治安の悪化した幕末の京都を守る大切な役目です。幕府や他の藩と分担して市中をパトロールしなければなりません。ところがいざ分担ルートを決める段になって、家臣の中でも有名な頑固者の古老から以下のような注文がつきました。
大変なことになりました。殿様といえどもこの家臣の言い分を無視するわけにはいきません。分担ルートの選択によっては、「武士の面目が立たない」ということになってしまいます。
ということで、スタート地点、ゴール地点、交差点の情報を入力として、上の三つの条件を満たすかどうかを判定するプログラムを作って、殿様に献上してください。
スタート地点を 1、ゴール地点を2、その他の交差点を 3 以上の整数で表します。1つの道路は、その道が結ぶ1組の交差点番号で表します。なお、交差点の数は 100 以下とし、全ての交差点からスタート地点およびゴール地点への経路がそれぞれ一つ以上あるものとします。
入力
複数のデータセットが与えられます。各データセットは以下の形式で与えられます。
a
1
b
1
a
2
b
2
：
：
0
0
各行の２つの整数は、交差点
a
i
と交差点
b
i
とをつなぐ道路が存在することを示します。
a
i
と
b
i
がともに 0 のとき交差点情報の入力の終わりを示します。
データセットの数は50を超えません。
出力
各データセットに対して、武士の面目が立つ場合（三つの条件を満たす場合）OK、それ以外の場合（三つの条件を満たさない場合）NG と１行に出力してください。
Sample Input
1 3
3 4
3 5
3 6
4 6
4 7
4 7
5 6
6 7
5 8
5 8
6 8
6 9
7 9
8 9
9 2
0 0
1 3
3 4
3 4
4 2
0 0
Output for the Sample Input
OK
NG",C,"#include <stdio.h>
#include <string.h>
#include <stdlib.h>

#define MAXN 105

int adj[MAXN][MAXN];
int n;
int visited[MAXN];
int path[MAXN];
int pathlen;
int found;

void dfs(int u, int goal) {
    if (found) return;
    if (u == goal) {
        found = 1;
        return;
    }
    
    for (int v = 1; v <= n; v++) {
        if (adj[u][v] > 0 && !visited[v]) {
            visited[v] = 1;
            path[pathlen++] = v;
            
            for (int i = 0; i < adj[u][v]; i++) {
                dfs(v, goal);
                if (found) return;
            }
            
            pathlen--;
            visited[v] = 0;
        }
    }
}

int canReach(int start, int goal, int avoid) {
    memset(visited, 0, sizeof(visited));
    visited[start] = 1;
    visited[avoid] = 1;
    
    pathlen = 0;
    path[pathlen++] = start;
    found = 0;
    
    dfs(start, goal);
    return found;
}

int main() {
    int a, b;
    
    while (1) {
        memset(adj, 0, sizeof(adj));
        n = 0;
        
        int first = 1;
        while (1) {
            if (scanf(""%d %d"", &a, &b) != 2) return 0;
            if (a == 0 && b == 0) break;
            
            adj[a][b]++;
            adj[b][a]++;
            
            if (a > n) n = a;
            if (b > n) n = b;
            first = 0;
        }
        
        if (first) break;
        
        memset(visited, 0, sizeof(visited));
        visited[1] = 1;
        pathlen = 0;
        path[pathlen++] = 1;
        found = 0;
        
        dfs(1, 2);
        
        if (!found) {
            printf(""NG\n"");
            continue;
        }
        
        int ok = 1;
        for (int i = 1; i < pathlen - 1; i++) {
            int v = path[i];
            if (!canReach(1, v, 2) || !canReach(v, 2, 1)) {
                ok = 0;
                break;
            }
        }
        
        if (ok) {
            printf(""OK\n"");
        } else {
            printf(""NG\n"");
        }
    }
    
    return 0;
}
",0
p00086,"パトロール
文久２（1862）年、会津の殿様が京都守護職を命ぜられました。京都守護職とは治安の悪化した幕末の京都を守る大切な役目です。幕府や他の藩と分担して市中をパトロールしなければなりません。ところがいざ分担ルートを決める段になって、家臣の中でも有名な頑固者の古老から以下のような注文がつきました。
大変なことになりました。殿様といえどもこの家臣の言い分を無視するわけにはいきません。分担ルートの選択によっては、「武士の面目が立たない」ということになってしまいます。
ということで、スタート地点、ゴール地点、交差点の情報を入力として、上の三つの条件を満たすかどうかを判定するプログラムを作って、殿様に献上してください。
スタート地点を 1、ゴール地点を2、その他の交差点を 3 以上の整数で表します。1つの道路は、その道が結ぶ1組の交差点番号で表します。なお、交差点の数は 100 以下とし、全ての交差点からスタート地点およびゴール地点への経路がそれぞれ一つ以上あるものとします。
入力
複数のデータセットが与えられます。各データセットは以下の形式で与えられます。
a
1
b
1
a
2
b
2
：
：
0
0
各行の２つの整数は、交差点
a
i
と交差点
b
i
とをつなぐ道路が存在することを示します。
a
i
と
b
i
がともに 0 のとき交差点情報の入力の終わりを示します。
データセットの数は50を超えません。
出力
各データセットに対して、武士の面目が立つ場合（三つの条件を満たす場合）OK、それ以外の場合（三つの条件を満たさない場合）NG と１行に出力してください。
Sample Input
1 3
3 4
3 5
3 6
4 6
4 7
4 7
5 6
6 7
5 8
5 8
6 8
6 9
7 9
8 9
9 2
0 0
1 3
3 4
3 4
4 2
0 0
Output for the Sample Input
OK
NG",C,"#include <stdio.h>

int main(int argc,char* argv[]){
  int i;
  int graph[101];

  for(;;){
    int from = -1,to = -1,odd_num = 0;

    for(i = 1; i <= 100; i++){
      graph[i] = -1;
    }

    while(scanf(""%d %d"",&from,&to) != EOF){
      if(from == 0 && to == 0){
	break;
      }else{
	graph[to] = (graph[to] == -1) ? 1 : graph[to]+1;
	graph[from] = (graph[from] == -1) ? 1 : graph[from]+1;
      }
    }

    if(from != 0 || to != 0){
      break;
    }

    for(i = 1; i <= 100; i++){
      if(graph[i] == -1){break;}
      if(graph[i]%2 == 1){odd_num++;}
    }

    if(odd_num == 0 || odd_num == 2){
      printf(""OK\n"");
    }else{
      printf(""NG\n"");
    }
  }

  return 0;
  
}",1
p00086,"パトロール
文久２（1862）年、会津の殿様が京都守護職を命ぜられました。京都守護職とは治安の悪化した幕末の京都を守る大切な役目です。幕府や他の藩と分担して市中をパトロールしなければなりません。ところがいざ分担ルートを決める段になって、家臣の中でも有名な頑固者の古老から以下のような注文がつきました。
大変なことになりました。殿様といえどもこの家臣の言い分を無視するわけにはいきません。分担ルートの選択によっては、「武士の面目が立たない」ということになってしまいます。
ということで、スタート地点、ゴール地点、交差点の情報を入力として、上の三つの条件を満たすかどうかを判定するプログラムを作って、殿様に献上してください。
スタート地点を 1、ゴール地点を2、その他の交差点を 3 以上の整数で表します。1つの道路は、その道が結ぶ1組の交差点番号で表します。なお、交差点の数は 100 以下とし、全ての交差点からスタート地点およびゴール地点への経路がそれぞれ一つ以上あるものとします。
入力
複数のデータセットが与えられます。各データセットは以下の形式で与えられます。
a
1
b
1
a
2
b
2
：
：
0
0
各行の２つの整数は、交差点
a
i
と交差点
b
i
とをつなぐ道路が存在することを示します。
a
i
と
b
i
がともに 0 のとき交差点情報の入力の終わりを示します。
データセットの数は50を超えません。
出力
各データセットに対して、武士の面目が立つ場合（三つの条件を満たす場合）OK、それ以外の場合（三つの条件を満たさない場合）NG と１行に出力してください。
Sample Input
1 3
3 4
3 5
3 6
4 6
4 7
4 7
5 6
6 7
5 8
5 8
6 8
6 9
7 9
8 9
9 2
0 0
1 3
3 4
3 4
4 2
0 0
Output for the Sample Input
OK
NG",Java,"import java.util.*;

public class Main {
    static class Edge {
        int to;
        int id;
        Edge(int to, int id) {
            this.to = to;
            this.id = id;
        }
    }
    
    static List<List<Edge>> graph;
    static int[] edgeCount;
    static boolean[] visited;
    static boolean[] edgeUsed;
    static int start = 1, goal = 2;
    static boolean found;
    static List<Integer> path;
    
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        
        while (sc.hasNext()) {
            Map<String, Integer> edges = new HashMap<>();
            List<int[]> edgeList = new ArrayList<>();
            Set<Integer> nodes = new HashSet<>();
            
            while (true) {
                int a = sc.nextInt();
                int b = sc.nextInt();
                if (a == 0 && b == 0) break;
                
                nodes.add(a);
                nodes.add(b);
                edgeList.add(new int[]{a, b});
                
                String key = Math.min(a, b) + ""-"" + Math.max(a, b);
                edges.put(key, edges.getOrDefault(key, 0) + 1);
            }
            
            int maxNode = 0;
            for (int node : nodes) {
                maxNode = Math.max(maxNode, node);
            }
            
            graph = new ArrayList<>();
            for (int i = 0; i <= maxNode; i++) {
                graph.add(new ArrayList<>());
            }
            
            edgeCount = new int[edgeList.size()];
            int edgeId = 0;
            for (int[] edge : edgeList) {
                int a = edge[0];
                int b = edge[1];
                graph.get(a).add(new Edge(b, edgeId));
                graph.get(b).add(new Edge(a, edgeId));
                edgeId++;
            }
            
            visited = new boolean[maxNode + 1];
            edgeUsed = new boolean[edgeList.size()];
            found = false;
            path = new ArrayList<>();
            
            dfs(start, new ArrayList<>());
            
            if (found) {
                System.out.println(""OK"");
            } else {
                System.out.println(""NG"");
            }
        }
        sc.close();
    }
    
    static void dfs(int current, List<Integer> currentPath) {
        if (found) return;
        
        if (current == goal) {
            // Check if all edges are used exactly once
            boolean allUsed = true;
            for (boolean used : edgeUsed) {
                if (!used) {
                    allUsed = false;
                    break;
                }
            }
            if (allUsed) {
                found = true;
                path = new ArrayList<>(currentPath);
            }
            return;
        }
        
        visited[current] = true;
        currentPath.add(current);
        
        for (Edge edge : graph.get(current)) {
            if (!edgeUsed[edge.id]) {
                edgeUsed[edge.id] = true;
                dfs(edge.to, currentPath);
                edgeUsed[edge.id] = false;
                if (found) return;
            }
        }
        
        currentPath.remove(currentPath.size() - 1);
        visited[current] = false;
    }
}
",0
p00086,"パトロール
文久２（1862）年、会津の殿様が京都守護職を命ぜられました。京都守護職とは治安の悪化した幕末の京都を守る大切な役目です。幕府や他の藩と分担して市中をパトロールしなければなりません。ところがいざ分担ルートを決める段になって、家臣の中でも有名な頑固者の古老から以下のような注文がつきました。
大変なことになりました。殿様といえどもこの家臣の言い分を無視するわけにはいきません。分担ルートの選択によっては、「武士の面目が立たない」ということになってしまいます。
ということで、スタート地点、ゴール地点、交差点の情報を入力として、上の三つの条件を満たすかどうかを判定するプログラムを作って、殿様に献上してください。
スタート地点を 1、ゴール地点を2、その他の交差点を 3 以上の整数で表します。1つの道路は、その道が結ぶ1組の交差点番号で表します。なお、交差点の数は 100 以下とし、全ての交差点からスタート地点およびゴール地点への経路がそれぞれ一つ以上あるものとします。
入力
複数のデータセットが与えられます。各データセットは以下の形式で与えられます。
a
1
b
1
a
2
b
2
：
：
0
0
各行の２つの整数は、交差点
a
i
と交差点
b
i
とをつなぐ道路が存在することを示します。
a
i
と
b
i
がともに 0 のとき交差点情報の入力の終わりを示します。
データセットの数は50を超えません。
出力
各データセットに対して、武士の面目が立つ場合（三つの条件を満たす場合）OK、それ以外の場合（三つの条件を満たさない場合）NG と１行に出力してください。
Sample Input
1 3
3 4
3 5
3 6
4 6
4 7
4 7
5 6
6 7
5 8
5 8
6 8
6 9
7 9
8 9
9 2
0 0
1 3
3 4
3 4
4 2
0 0
Output for the Sample Input
OK
NG",Java,"public class Main{
  public void run(java.io.InputStream in, java.io.PrintStream out){
    java.util.Scanner sc = new java.util.Scanner(in);
/*answer*/
    int a, b;
    int[] count;
    int i, n;

    count = new int[100];
    for(;sc.hasNext();){
      for(i = 0;i < 100;i++)count[i] = 0;
      n = 0;
      for(;;){
        a = sc.nextInt();
        b = sc.nextInt();
        if(a == 0 && b == 0)break;
        count[a - 1]++; count[b - 1]++;
      }

      for(i = 0;i < 2;i++)if(count[i] % 2 == 0)n = 1;
      for(i = 2;i < 100;i++)if(count[i] % 2 != 0)n = 1;

      if(n == 1)out.println(""NG"");
      else out.println(""OK"");
    }

    sc.close();
  }
  public static void main(String[] args){
    (new Main()).run(System.in, System.out);
  }
}",1
p00086,"パトロール
文久２（1862）年、会津の殿様が京都守護職を命ぜられました。京都守護職とは治安の悪化した幕末の京都を守る大切な役目です。幕府や他の藩と分担して市中をパトロールしなければなりません。ところがいざ分担ルートを決める段になって、家臣の中でも有名な頑固者の古老から以下のような注文がつきました。
大変なことになりました。殿様といえどもこの家臣の言い分を無視するわけにはいきません。分担ルートの選択によっては、「武士の面目が立たない」ということになってしまいます。
ということで、スタート地点、ゴール地点、交差点の情報を入力として、上の三つの条件を満たすかどうかを判定するプログラムを作って、殿様に献上してください。
スタート地点を 1、ゴール地点を2、その他の交差点を 3 以上の整数で表します。1つの道路は、その道が結ぶ1組の交差点番号で表します。なお、交差点の数は 100 以下とし、全ての交差点からスタート地点およびゴール地点への経路がそれぞれ一つ以上あるものとします。
入力
複数のデータセットが与えられます。各データセットは以下の形式で与えられます。
a
1
b
1
a
2
b
2
：
：
0
0
各行の２つの整数は、交差点
a
i
と交差点
b
i
とをつなぐ道路が存在することを示します。
a
i
と
b
i
がともに 0 のとき交差点情報の入力の終わりを示します。
データセットの数は50を超えません。
出力
各データセットに対して、武士の面目が立つ場合（三つの条件を満たす場合）OK、それ以外の場合（三つの条件を満たさない場合）NG と１行に出力してください。
Sample Input
1 3
3 4
3 5
3 6
4 6
4 7
4 7
5 6
6 7
5 8
5 8
6 8
6 9
7 9
8 9
9 2
0 0
1 3
3 4
3 4
4 2
0 0
Output for the Sample Input
OK
NG",Python,"import sys
from collections import defaultdict, deque

def read_input():
    datasets = []
    current_edges = []
    
    for line in sys.stdin:
        line = line.strip()
        if not line:
            continue
        a, b = map(int, line.split())
        if a == 0 and b == 0:
            if current_edges:
                datasets.append(current_edges)
                current_edges = []
        else:
            current_edges.append((a, b))
    
    return datasets

def can_reach(graph, start, end, excluded_edge=None):
    """"""BFS to check if we can reach end from start, optionally excluding an edge""""""
    visited = set()
    queue = deque([start])
    visited.add(start)
    
    while queue:
        node = queue.popleft()
        if node == end:
            return True
        
        for neighbor in graph[node]:
            if neighbor not in visited:
                # Check if this edge should be excluded
                if excluded_edge:
                    edge = tuple(sorted([node, neighbor]))
                    if edge == excluded_edge:
                        continue
                visited.add(neighbor)
                queue.append(neighbor)
    
    return False

def check_conditions(edges):
    # Build adjacency list (undirected graph)
    graph = defaultdict(list)
    edge_set = set()
    
    for a, b in edges:
        graph[a].append(b)
        graph[b].append(a)
        edge_set.add(tuple(sorted([a, b])))
    
    # Condition 1: There must be a path from 1 to 2
    if not can_reach(graph, 1, 2):
        return False
    
    # Condition 2: Every road must be on some path from 1 to 2
    for edge in edge_set:
        a, b = edge
        # Remove this edge temporarily and check if we can still reach 2 from 1
        if not can_reach(graph, 1, 2, excluded_edge=edge):
            # This edge is essential, so condition 2 is satisfied for this edge
            continue
        else:
            # This edge is not essential, condition 2 fails
            return False
    
    # Condition 3: Every intersection (except 1 and 2) must be on some path from 1 to 2
    all_nodes = set()
    for a, b in edges:
        all_nodes.add(a)
        all_nodes.add(b)
    
    for node in all_nodes:
        if node == 1 or node == 2:
            continue
        
        # Check if node is on some path from 1 to 2
        # Node is on a path from 1 to 2 if:
        # - we can reach node from 1, AND
        # - we can reach 2 from node
        if can_reach(graph, 1, node) and can_reach(graph, node, 2):
            # Additionally, we need to check if removing this node disconnects 1 and 2
            # But a simpler check: node is critical if there's no path from 1 to 2 avoiding it
            
            # For now, just check basic reachability
            # Actually, we need to verify the node is on SOME path, not ALL paths
            # If we can reach it from 1 and reach 2 from it, it's on some path
            continue
        else:
            return False
    
    return True

def solve():
    datasets = read_input()
    
    for edges in datasets:
        if check_conditions(edges):
            print(""OK"")
        else:
            print(""NG"")

solve()
",0
p00086,"パトロール
文久２（1862）年、会津の殿様が京都守護職を命ぜられました。京都守護職とは治安の悪化した幕末の京都を守る大切な役目です。幕府や他の藩と分担して市中をパトロールしなければなりません。ところがいざ分担ルートを決める段になって、家臣の中でも有名な頑固者の古老から以下のような注文がつきました。
大変なことになりました。殿様といえどもこの家臣の言い分を無視するわけにはいきません。分担ルートの選択によっては、「武士の面目が立たない」ということになってしまいます。
ということで、スタート地点、ゴール地点、交差点の情報を入力として、上の三つの条件を満たすかどうかを判定するプログラムを作って、殿様に献上してください。
スタート地点を 1、ゴール地点を2、その他の交差点を 3 以上の整数で表します。1つの道路は、その道が結ぶ1組の交差点番号で表します。なお、交差点の数は 100 以下とし、全ての交差点からスタート地点およびゴール地点への経路がそれぞれ一つ以上あるものとします。
入力
複数のデータセットが与えられます。各データセットは以下の形式で与えられます。
a
1
b
1
a
2
b
2
：
：
0
0
各行の２つの整数は、交差点
a
i
と交差点
b
i
とをつなぐ道路が存在することを示します。
a
i
と
b
i
がともに 0 のとき交差点情報の入力の終わりを示します。
データセットの数は50を超えません。
出力
各データセットに対して、武士の面目が立つ場合（三つの条件を満たす場合）OK、それ以外の場合（三つの条件を満たさない場合）NG と１行に出力してください。
Sample Input
1 3
3 4
3 5
3 6
4 6
4 7
4 7
5 6
6 7
5 8
5 8
6 8
6 9
7 9
8 9
9 2
0 0
1 3
3 4
3 4
4 2
0 0
Output for the Sample Input
OK
NG",Python,"import sys
from collections import defaultdict
data_list = []

for line in sys.stdin:
    data_list.append(list(map(int, line.split())))

def is_half_euler_graph(node_list):

    for node in node_list:
        odd_num_counter = 0
        for dic_value in node.values():
            if dic_value % 2 != 0:
                odd_num_counter = odd_num_counter + 1

        if odd_num_counter == 2:
            print(""OK"")
        else :
            print(""NG"")


if __name__ == '__main__' :
    node_data_lists = []
    tmp_list = []
    count_lists = []
    tmp_dic = {}
    tmp_dic = defaultdict(int)

    for i in range(0, len(data_list)):
        if data_list[i][0] == 0 and data_list[i][1] == 0:
            node_data_lists.append(tmp_list[:])
            tmp_list.clear()
        else :
            tmp_list.append(data_list[i])

    for node_data_list in node_data_lists :
        tmp_dic.clear()
        for i in range(0, len(node_data_list)):
            tmp_dic[node_data_list[i][0]] += 1
            tmp_dic[node_data_list[i][1]] += 1

        count_lists.append(tmp_dic.copy())
    is_half_euler_graph(count_lists)

",1
p00087,"未熟者の数式
博士 : ピーター君、ついにやったよ。
ピーター : またですか。今度はどんなくだらない発明ですか。
博士 : ついに数式を計算機で処理する画期的な方法を思いついたんだ。この表をみてごらん。
通常の記法
博士の「画期的な」記法
1 + 2
1 2 +
3 * 4 + 7
3 4 * 7 +
10 / ( 2 - 12 )
10 2 12 - /
( 3 - 4 ) * ( 7 + 2 * 3 )
3 4 - 7 2 3 * + *
ピーター : はぁ。
博士 : ふっふっふ。これだけでは、未熟者の君には何のことだかわからないだろうねえ。ここからが肝心なんじゃ。
ピーター : っていうか・・・。
博士 : 計算機にはスタックというデータ構造があることは君も知っているね。ほれ、「先入れ後出し」のあれじゃよ。
ピーター : はい。知ってますが、あの・・・。
博士 : この画期的な記法はあのスタックを使うんじゃ。例えばこの 10 2 12 - / だが、次のように処理する。
処理対象
10
2
12
-
/
↓
↓
↓
↓2-12
↓10/-10
スタック
.
.
10
.
2
10
12
2
10
.
-10
10
.
.
-1
博士 : どうじゃな。括弧も演算子の優先順位も気にする必要がないじゃろう？語順も「10 を 2 から 12 を引いたもので割る。」となり、何となく彼の極東の島国の言葉、日本語と似ておるじゃろうて。
       この画期的な発明さえあれば、我が研究室は安泰じゃて。ファファファ。
ピーター : っていうか博士。これって日本にいたとき会津大学の基礎コースで習いましたよ。「逆ポーランド記法」とかいって、みんな簡単にプログラムしてました。
博士 : ・・・。
ということで、ピーター君に変わって博士に、このプログラムを教える事になりました。「逆ポーランド記法」で書かれた数式を入力とし、計算結果を出力するプログラムを作成してください。
入力
複数のデータセットが与えられます。各データセットでは、逆ポーランド記法による数式（整数と演算記号が空白文字１文字（半角）で区切られた80文字以内の文字列）が １ 行に与えられます。
ある値を 0 や 0 に限りなく近い値で割るような数式は与えられません。
データセットの数は 50 を超えません。
出力
各データセットごとに、計算結果（実数）を１行に出力してください。なお、計算結果は 0.00001 以下の誤差を含んでもよい。
Sample Input
10 2 12 - /
3 4 - 7 2 3 * + *
-1 -2 3 + +
Output for the Sample Input
-1.000000
-13.000000
0.000000",C,"#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <ctype.h>

#define MAX_STACK 1000

double stack[MAX_STACK];
int top = -1;

void push(double val) {
    stack[++top] = val;
}

double pop() {
    return stack[top--];
}

int is_operator(char *token) {
    return (strlen(token) == 1 && (token[0] == '+' || token[0] == '-' || 
            token[0] == '*' || token[0] == '/'));
}

double calculate(double a, double b, char op) {
    switch(op) {
        case '+': return a + b;
        case '-': return a - b;
        case '*': return a * b;
        case '/': return a / b;
    }
    return 0;
}

int main() {
    char line[1000];
    
    while(fgets(line, sizeof(line), stdin)) {
        if(line[0] == '\n') break;
        
        top = -1;
        char *token = strtok(line, "" \n"");
        
        while(token != NULL) {
            if(is_operator(token)) {
                double b = pop();
                double a = pop();
                double result = calculate(a, b, token[0]);
                push(result);
            } else {
                double num = atof(token);
                push(num);
            }
            token = strtok(NULL, "" \n"");
        }
        
        printf(""%f\n"", stack[0]);
    }
    
    return 0;
}
",0
p00087,"未熟者の数式
博士 : ピーター君、ついにやったよ。
ピーター : またですか。今度はどんなくだらない発明ですか。
博士 : ついに数式を計算機で処理する画期的な方法を思いついたんだ。この表をみてごらん。
通常の記法
博士の「画期的な」記法
1 + 2
1 2 +
3 * 4 + 7
3 4 * 7 +
10 / ( 2 - 12 )
10 2 12 - /
( 3 - 4 ) * ( 7 + 2 * 3 )
3 4 - 7 2 3 * + *
ピーター : はぁ。
博士 : ふっふっふ。これだけでは、未熟者の君には何のことだかわからないだろうねえ。ここからが肝心なんじゃ。
ピーター : っていうか・・・。
博士 : 計算機にはスタックというデータ構造があることは君も知っているね。ほれ、「先入れ後出し」のあれじゃよ。
ピーター : はい。知ってますが、あの・・・。
博士 : この画期的な記法はあのスタックを使うんじゃ。例えばこの 10 2 12 - / だが、次のように処理する。
処理対象
10
2
12
-
/
↓
↓
↓
↓2-12
↓10/-10
スタック
.
.
10
.
2
10
12
2
10
.
-10
10
.
.
-1
博士 : どうじゃな。括弧も演算子の優先順位も気にする必要がないじゃろう？語順も「10 を 2 から 12 を引いたもので割る。」となり、何となく彼の極東の島国の言葉、日本語と似ておるじゃろうて。
       この画期的な発明さえあれば、我が研究室は安泰じゃて。ファファファ。
ピーター : っていうか博士。これって日本にいたとき会津大学の基礎コースで習いましたよ。「逆ポーランド記法」とかいって、みんな簡単にプログラムしてました。
博士 : ・・・。
ということで、ピーター君に変わって博士に、このプログラムを教える事になりました。「逆ポーランド記法」で書かれた数式を入力とし、計算結果を出力するプログラムを作成してください。
入力
複数のデータセットが与えられます。各データセットでは、逆ポーランド記法による数式（整数と演算記号が空白文字１文字（半角）で区切られた80文字以内の文字列）が １ 行に与えられます。
ある値を 0 や 0 に限りなく近い値で割るような数式は与えられません。
データセットの数は 50 を超えません。
出力
各データセットごとに、計算結果（実数）を１行に出力してください。なお、計算結果は 0.00001 以下の誤差を含んでもよい。
Sample Input
10 2 12 - /
3 4 - 7 2 3 * + *
-1 -2 3 + +
Output for the Sample Input
-1.000000
-13.000000
0.000000",C,"double*q,a[99],b;char s[9];main(){for(q=a;~scanf(""%s"",s);getchar()<14&&printf(""%f\n"",*q)){!sscanf(s,""%lf"",q+1)?b=*q--,*q=*s-47?*s-42?*s-45?*q+b:*q-b:*q*b:*q/b:*++q;}}",1
p00087,"未熟者の数式
博士 : ピーター君、ついにやったよ。
ピーター : またですか。今度はどんなくだらない発明ですか。
博士 : ついに数式を計算機で処理する画期的な方法を思いついたんだ。この表をみてごらん。
通常の記法
博士の「画期的な」記法
1 + 2
1 2 +
3 * 4 + 7
3 4 * 7 +
10 / ( 2 - 12 )
10 2 12 - /
( 3 - 4 ) * ( 7 + 2 * 3 )
3 4 - 7 2 3 * + *
ピーター : はぁ。
博士 : ふっふっふ。これだけでは、未熟者の君には何のことだかわからないだろうねえ。ここからが肝心なんじゃ。
ピーター : っていうか・・・。
博士 : 計算機にはスタックというデータ構造があることは君も知っているね。ほれ、「先入れ後出し」のあれじゃよ。
ピーター : はい。知ってますが、あの・・・。
博士 : この画期的な記法はあのスタックを使うんじゃ。例えばこの 10 2 12 - / だが、次のように処理する。
処理対象
10
2
12
-
/
↓
↓
↓
↓2-12
↓10/-10
スタック
.
.
10
.
2
10
12
2
10
.
-10
10
.
.
-1
博士 : どうじゃな。括弧も演算子の優先順位も気にする必要がないじゃろう？語順も「10 を 2 から 12 を引いたもので割る。」となり、何となく彼の極東の島国の言葉、日本語と似ておるじゃろうて。
       この画期的な発明さえあれば、我が研究室は安泰じゃて。ファファファ。
ピーター : っていうか博士。これって日本にいたとき会津大学の基礎コースで習いましたよ。「逆ポーランド記法」とかいって、みんな簡単にプログラムしてました。
博士 : ・・・。
ということで、ピーター君に変わって博士に、このプログラムを教える事になりました。「逆ポーランド記法」で書かれた数式を入力とし、計算結果を出力するプログラムを作成してください。
入力
複数のデータセットが与えられます。各データセットでは、逆ポーランド記法による数式（整数と演算記号が空白文字１文字（半角）で区切られた80文字以内の文字列）が １ 行に与えられます。
ある値を 0 や 0 に限りなく近い値で割るような数式は与えられません。
データセットの数は 50 を超えません。
出力
各データセットごとに、計算結果（実数）を１行に出力してください。なお、計算結果は 0.00001 以下の誤差を含んでもよい。
Sample Input
10 2 12 - /
3 4 - 7 2 3 * + *
-1 -2 3 + +
Output for the Sample Input
-1.000000
-13.000000
0.000000",Java,"import java.util.*;
import java.io.*;

public class Main {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        
        while (sc.hasNextLine()) {
            String line = sc.nextLine();
            if (line == null || line.trim().isEmpty()) {
                break;
            }
            
            String[] tokens = line.trim().split(""\\s+"");
            Stack<Double> stack = new Stack<>();
            
            for (String token : tokens) {
                if (token.equals(""+"")) {
                    double b = stack.pop();
                    double a = stack.pop();
                    stack.push(a + b);
                } else if (token.equals(""-"")) {
                    double b = stack.pop();
                    double a = stack.pop();
                    stack.push(a - b);
                } else if (token.equals(""*"")) {
                    double b = stack.pop();
                    double a = stack.pop();
                    stack.push(a * b);
                } else if (token.equals(""/"")) {
                    double b = stack.pop();
                    double a = stack.pop();
                    stack.push(a / b);
                } else {
                    stack.push(Double.parseDouble(token));
                }
            }
            
            System.out.printf(""%.6f%n"", stack.pop());
        }
        
        sc.close();
    }
}
",0
p00087,"未熟者の数式
博士 : ピーター君、ついにやったよ。
ピーター : またですか。今度はどんなくだらない発明ですか。
博士 : ついに数式を計算機で処理する画期的な方法を思いついたんだ。この表をみてごらん。
通常の記法
博士の「画期的な」記法
1 + 2
1 2 +
3 * 4 + 7
3 4 * 7 +
10 / ( 2 - 12 )
10 2 12 - /
( 3 - 4 ) * ( 7 + 2 * 3 )
3 4 - 7 2 3 * + *
ピーター : はぁ。
博士 : ふっふっふ。これだけでは、未熟者の君には何のことだかわからないだろうねえ。ここからが肝心なんじゃ。
ピーター : っていうか・・・。
博士 : 計算機にはスタックというデータ構造があることは君も知っているね。ほれ、「先入れ後出し」のあれじゃよ。
ピーター : はい。知ってますが、あの・・・。
博士 : この画期的な記法はあのスタックを使うんじゃ。例えばこの 10 2 12 - / だが、次のように処理する。
処理対象
10
2
12
-
/
↓
↓
↓
↓2-12
↓10/-10
スタック
.
.
10
.
2
10
12
2
10
.
-10
10
.
.
-1
博士 : どうじゃな。括弧も演算子の優先順位も気にする必要がないじゃろう？語順も「10 を 2 から 12 を引いたもので割る。」となり、何となく彼の極東の島国の言葉、日本語と似ておるじゃろうて。
       この画期的な発明さえあれば、我が研究室は安泰じゃて。ファファファ。
ピーター : っていうか博士。これって日本にいたとき会津大学の基礎コースで習いましたよ。「逆ポーランド記法」とかいって、みんな簡単にプログラムしてました。
博士 : ・・・。
ということで、ピーター君に変わって博士に、このプログラムを教える事になりました。「逆ポーランド記法」で書かれた数式を入力とし、計算結果を出力するプログラムを作成してください。
入力
複数のデータセットが与えられます。各データセットでは、逆ポーランド記法による数式（整数と演算記号が空白文字１文字（半角）で区切られた80文字以内の文字列）が １ 行に与えられます。
ある値を 0 や 0 に限りなく近い値で割るような数式は与えられません。
データセットの数は 50 を超えません。
出力
各データセットごとに、計算結果（実数）を１行に出力してください。なお、計算結果は 0.00001 以下の誤差を含んでもよい。
Sample Input
10 2 12 - /
3 4 - 7 2 3 * + *
-1 -2 3 + +
Output for the Sample Input
-1.000000
-13.000000
0.000000",Java,"import java.util.*;
import java.lang.*;
import java.math.*;
import java.io.*;

import static java.lang.Math.*;
import static java.util.Arrays.*;

public class Main{

	Scanner sc;

	static final int INF=1<<28;
	static final double EPS=1e-9;

	void run(){
		sc=new Scanner(System.in);
		for(; sc.hasNext();){
			Scanner c=new Scanner(sc.nextLine());
			LinkedList<Double> stack=new LinkedList<Double>();
			for(; c.hasNext();){
				String s=c.next();
				if(Character.isDigit(s.charAt(0))){
					stack.addFirst(Double.parseDouble(s));
				}else{
					double d2=stack.removeFirst();
					double d1=stack.removeFirst();
					double d=0;
//					double d1=0,d2=0,d=0;
					switch(s.charAt(0)){
					case '+':
						d=d1+d2;
						break;
					case '-':
						d=d1-d2;
						break;
					case '*':
						d=d1*d2;
						break;
					case '/':
						d=d1/d2;
						break;
					}
					stack.addFirst(d);
				}
			}
			double ans=stack.removeFirst();
			println(ans+"""");
		}
		sc.close();
	}

	void print(String s){
		System.out.print(s);
	}

	void println(String s){
		System.out.println(s);
	}

	public static void main(String[] args){
		new Main().run();
	}
}",1
p00087,"未熟者の数式
博士 : ピーター君、ついにやったよ。
ピーター : またですか。今度はどんなくだらない発明ですか。
博士 : ついに数式を計算機で処理する画期的な方法を思いついたんだ。この表をみてごらん。
通常の記法
博士の「画期的な」記法
1 + 2
1 2 +
3 * 4 + 7
3 4 * 7 +
10 / ( 2 - 12 )
10 2 12 - /
( 3 - 4 ) * ( 7 + 2 * 3 )
3 4 - 7 2 3 * + *
ピーター : はぁ。
博士 : ふっふっふ。これだけでは、未熟者の君には何のことだかわからないだろうねえ。ここからが肝心なんじゃ。
ピーター : っていうか・・・。
博士 : 計算機にはスタックというデータ構造があることは君も知っているね。ほれ、「先入れ後出し」のあれじゃよ。
ピーター : はい。知ってますが、あの・・・。
博士 : この画期的な記法はあのスタックを使うんじゃ。例えばこの 10 2 12 - / だが、次のように処理する。
処理対象
10
2
12
-
/
↓
↓
↓
↓2-12
↓10/-10
スタック
.
.
10
.
2
10
12
2
10
.
-10
10
.
.
-1
博士 : どうじゃな。括弧も演算子の優先順位も気にする必要がないじゃろう？語順も「10 を 2 から 12 を引いたもので割る。」となり、何となく彼の極東の島国の言葉、日本語と似ておるじゃろうて。
       この画期的な発明さえあれば、我が研究室は安泰じゃて。ファファファ。
ピーター : っていうか博士。これって日本にいたとき会津大学の基礎コースで習いましたよ。「逆ポーランド記法」とかいって、みんな簡単にプログラムしてました。
博士 : ・・・。
ということで、ピーター君に変わって博士に、このプログラムを教える事になりました。「逆ポーランド記法」で書かれた数式を入力とし、計算結果を出力するプログラムを作成してください。
入力
複数のデータセットが与えられます。各データセットでは、逆ポーランド記法による数式（整数と演算記号が空白文字１文字（半角）で区切られた80文字以内の文字列）が １ 行に与えられます。
ある値を 0 や 0 に限りなく近い値で割るような数式は与えられません。
データセットの数は 50 を超えません。
出力
各データセットごとに、計算結果（実数）を１行に出力してください。なお、計算結果は 0.00001 以下の誤差を含んでもよい。
Sample Input
10 2 12 - /
3 4 - 7 2 3 * + *
-1 -2 3 + +
Output for the Sample Input
-1.000000
-13.000000
0.000000",Python,"import sys

for line in sys.stdin:
    tokens = line.strip().split()
    stack = []
    
    for token in tokens:
        if token in ['+', '-', '*', '/']:
            b = stack.pop()
            a = stack.pop()
            if token == '+':
                result = a + b
            elif token == '-':
                result = a - b
            elif token == '*':
                result = a * b
            elif token == '/':
                result = a / b
            stack.append(result)
        else:
            stack.append(float(token))
    
    print(f""{stack[0]:.6f}"")
",0
p00087,"未熟者の数式
博士 : ピーター君、ついにやったよ。
ピーター : またですか。今度はどんなくだらない発明ですか。
博士 : ついに数式を計算機で処理する画期的な方法を思いついたんだ。この表をみてごらん。
通常の記法
博士の「画期的な」記法
1 + 2
1 2 +
3 * 4 + 7
3 4 * 7 +
10 / ( 2 - 12 )
10 2 12 - /
( 3 - 4 ) * ( 7 + 2 * 3 )
3 4 - 7 2 3 * + *
ピーター : はぁ。
博士 : ふっふっふ。これだけでは、未熟者の君には何のことだかわからないだろうねえ。ここからが肝心なんじゃ。
ピーター : っていうか・・・。
博士 : 計算機にはスタックというデータ構造があることは君も知っているね。ほれ、「先入れ後出し」のあれじゃよ。
ピーター : はい。知ってますが、あの・・・。
博士 : この画期的な記法はあのスタックを使うんじゃ。例えばこの 10 2 12 - / だが、次のように処理する。
処理対象
10
2
12
-
/
↓
↓
↓
↓2-12
↓10/-10
スタック
.
.
10
.
2
10
12
2
10
.
-10
10
.
.
-1
博士 : どうじゃな。括弧も演算子の優先順位も気にする必要がないじゃろう？語順も「10 を 2 から 12 を引いたもので割る。」となり、何となく彼の極東の島国の言葉、日本語と似ておるじゃろうて。
       この画期的な発明さえあれば、我が研究室は安泰じゃて。ファファファ。
ピーター : っていうか博士。これって日本にいたとき会津大学の基礎コースで習いましたよ。「逆ポーランド記法」とかいって、みんな簡単にプログラムしてました。
博士 : ・・・。
ということで、ピーター君に変わって博士に、このプログラムを教える事になりました。「逆ポーランド記法」で書かれた数式を入力とし、計算結果を出力するプログラムを作成してください。
入力
複数のデータセットが与えられます。各データセットでは、逆ポーランド記法による数式（整数と演算記号が空白文字１文字（半角）で区切られた80文字以内の文字列）が １ 行に与えられます。
ある値を 0 や 0 に限りなく近い値で割るような数式は与えられません。
データセットの数は 50 を超えません。
出力
各データセットごとに、計算結果（実数）を１行に出力してください。なお、計算結果は 0.00001 以下の誤差を含んでもよい。
Sample Input
10 2 12 - /
3 4 - 7 2 3 * + *
-1 -2 3 + +
Output for the Sample Input
-1.000000
-13.000000
0.000000",Python,"import sys
for l in sys.stdin:
  t=l.split()
  l=[]
  for i in t:
    try:
      j=int(i)
      l.append(j)
    except:
      b=l.pop()
      a=l.pop()
      l.append(eval(""a""+i+""b""))
  print(""{:.6f}"".format(l[0]))
",1
p00088,"博士が愛した符号
博士 : ピーター君、ついにやったよ。
ピーター : どうしました、デビッド博士？またくだらない発明ですか？
博士 : この表だよ、この表。
文字
符号
（空白）
101
'
000000
,
000011
-
10010001
.
010001
?
000001
A
100101
B
10011010
文字
符号
C
0101
D
0001
E
110
F
01001
G
10011011
H
010000
I
0111
J
10011000
文字
符号
K
0110
L
00100
M
10011001
N
10011110
O
00101
P
111
Q
10011111
R
1000
文字
符号
S
00110
T
00111
U
10011100
V
10011101
W
000010
X
10010010
Y
10010011
Z
10010000
ピーター : なんですか? この表は。
博士 : いいから、言う通りにしてみなさい。まず、お前の名前を紙に書いてごらん。
ピーター : はい""PETER POTTER"" っと。
博士 : そうしたら、１文字ずつ、この表の「符号」に置き換えるのだよ。
ピーター : えーと""P"" を「111」にして""E"" を「110」して…結構面倒ですね。
111 110 00111 110 1000 101 111 00101 00111 00111 110 1000
になりました。なんだか、バーコードみたいですね。
博士 : よろしい。そうしたら、置き換えた文字列を全部つなげて、５文字ごとに区切ってみなさい。
ピーター : はいはい、つなげて区切ると。
11111 00011 11101 00010 11110 01010 01110 01111 10100 0
こんな感じになりました。けど、最後の「0」だけのやつはどうしますか?
博士 : ０を付け加えて５文字にしておいてくれ。
ピーター : えーと最後が０が1個だけだから０をあと４つ加えてやればいいんですね。できました。
11111 00011 11101 00010 11110 01010 01110 01111 10100 00000
博士 : 次はこの表を使うのだ。
符号
文字
00000
A
00001
B
00010
C
00011
D
00100
E
00101
F
00110
G
00111
H
符号
文字
01000
I
01001
J
01010
K
01011
L
01100
M
01101
N
01110
O
01111
P
符号
文字
10000
Q
10001
R
10010
S
10011
T
10100
U
10101
V
10110
W
10111
X
符号
文字
11000
Y
11001
Z
11010
（空白）
11011
.
11100
,
11101
-
11110
'
11111
?
ピーター : これをどう使うんですか…そうか!今度は符号から文字に置き換えるのか!
博士 : そうそう。「11111」だったら「?」に、「00011」だったら「D」にとやってゆけばいいんだよ。
ピーター : これは単純ですね……えーと「?D-C'KOPUA」になりました。でも意味不明ですよ。
博士 : 文字数を数えてごらん。
ピーター : １０文字ですよ。あっ、「PETER POTTER」は１２文字だったのに２文字減っています。
博士 : そう、この表を使えば文字を減らすことができるのだよ。じゃあ今度はこの文章で同じことをやっ
       てごらん。
PETER PIPER PICKED A PECK OF PICKLED PEPPERS. A PECK OF PICKLED PEPPERS
PETER PIPER PICKED. IF PETER PIPER PICKED A PECK OF PICKLED PEPPERS, WHERE'S
THE PECK OF PICKLED PEPPERS PETER PIPER PICKED?
ピーター : ぎょぎょ、行が分かれていますが、どうするんですか?
博士 : 紙の都合で３行になってしまったが、改行文字のかわりに空白がある長い１行だと思っておくれ。
ピーター : はいはい。行と行の間にあるのは空白だと。しかし面倒だな……。
博士 : だったらプログラムにやらせればいいではないか。
ということで、ピーターの代わりに、読み込んだ文字列を符号に変換し出力するプログラムを作成してください。
入力
複数のデータセットが与えられます。各データセットに文字列１行（表に含まれる文字からなる）が与えられます。文字列に含まれる文字の数は 1 文字以上 100 文字以下です。
データセットの数は 200 を超えません。
出力
各データセットごとに、変換後の文字列を１行に出力してください。
Sample Input
PETER POTTER
Output for the Sample Input
?D-C'KOPUA",C,"#include <stdio.h>
#include <string.h>

int main() {
    char *encode1[] = {
        ""101"", ""000000"", ""000011"", ""10010001"", ""010001"", ""000001"",
        ""100101"", ""10011010"", ""0101"", ""0001"", ""110"", ""01001"",
        ""10011011"", ""010000"", ""0111"", ""10011000"", ""0110"", ""00100"",
        ""10011001"", ""10011110"", ""00101"", ""111"", ""10011111"", ""1000"",
        ""00110"", ""00111"", ""10011100"", ""10011101"", ""000010"", ""10010010"",
        ""10010011"", ""10010000""
    };
    
    char *decode2[] = {
        ""A"", ""B"", ""C"", ""D"", ""E"", ""F"", ""G"", ""H"",
        ""I"", ""J"", ""K"", ""L"", ""M"", ""N"", ""O"", ""P"",
        ""Q"", ""R"", ""S"", ""T"", ""U"", ""V"", ""W"", ""X"",
        ""Y"", ""Z"", "" "", ""."", "","", ""-"", ""'"", ""?""
    };
    
    char input[1024];
    
    while (fgets(input, sizeof(input), stdin)) {
        int len = strlen(input);
        if (len > 0 && input[len-1] == '\n') {
            input[len-1] = '\0';
            len--;
        }
        
        char binary[10000] = """";
        
        for (int i = 0; i < len; i++) {
            char c = input[i];
            int idx = -1;
            
            if (c == ' ') idx = 0;
            else if (c == '\'') idx = 1;
            else if (c == ',') idx = 2;
            else if (c == '-') idx = 3;
            else if (c == '.') idx = 4;
            else if (c == '?') idx = 5;
            else if (c >= 'A' && c <= 'Z') idx = c - 'A' + 6;
            
            if (idx >= 0) {
                strcat(binary, encode1[idx]);
            }
        }
        
        int blen = strlen(binary);
        if (blen % 5 != 0) {
            int pad = 5 - (blen % 5);
            for (int i = 0; i < pad; i++) {
                strcat(binary, ""0"");
            }
            blen = strlen(binary);
        }
        
        char result[10000] = """";
        for (int i = 0; i < blen; i += 5) {
            char chunk[6];
            strncpy(chunk, binary + i, 5);
            chunk[5] = '\0';
            
            int val = 0;
            for (int j = 0; j < 5; j++) {
                val = val * 2 + (chunk[j] - '0');
            }
            
            strcat(result, decode2[val]);
        }
        
        printf(""%s\n"", result);
    }
    
    return 0;
}
",0
p00088,"博士が愛した符号
博士 : ピーター君、ついにやったよ。
ピーター : どうしました、デビッド博士？またくだらない発明ですか？
博士 : この表だよ、この表。
文字
符号
（空白）
101
'
000000
,
000011
-
10010001
.
010001
?
000001
A
100101
B
10011010
文字
符号
C
0101
D
0001
E
110
F
01001
G
10011011
H
010000
I
0111
J
10011000
文字
符号
K
0110
L
00100
M
10011001
N
10011110
O
00101
P
111
Q
10011111
R
1000
文字
符号
S
00110
T
00111
U
10011100
V
10011101
W
000010
X
10010010
Y
10010011
Z
10010000
ピーター : なんですか? この表は。
博士 : いいから、言う通りにしてみなさい。まず、お前の名前を紙に書いてごらん。
ピーター : はい""PETER POTTER"" っと。
博士 : そうしたら、１文字ずつ、この表の「符号」に置き換えるのだよ。
ピーター : えーと""P"" を「111」にして""E"" を「110」して…結構面倒ですね。
111 110 00111 110 1000 101 111 00101 00111 00111 110 1000
になりました。なんだか、バーコードみたいですね。
博士 : よろしい。そうしたら、置き換えた文字列を全部つなげて、５文字ごとに区切ってみなさい。
ピーター : はいはい、つなげて区切ると。
11111 00011 11101 00010 11110 01010 01110 01111 10100 0
こんな感じになりました。けど、最後の「0」だけのやつはどうしますか?
博士 : ０を付け加えて５文字にしておいてくれ。
ピーター : えーと最後が０が1個だけだから０をあと４つ加えてやればいいんですね。できました。
11111 00011 11101 00010 11110 01010 01110 01111 10100 00000
博士 : 次はこの表を使うのだ。
符号
文字
00000
A
00001
B
00010
C
00011
D
00100
E
00101
F
00110
G
00111
H
符号
文字
01000
I
01001
J
01010
K
01011
L
01100
M
01101
N
01110
O
01111
P
符号
文字
10000
Q
10001
R
10010
S
10011
T
10100
U
10101
V
10110
W
10111
X
符号
文字
11000
Y
11001
Z
11010
（空白）
11011
.
11100
,
11101
-
11110
'
11111
?
ピーター : これをどう使うんですか…そうか!今度は符号から文字に置き換えるのか!
博士 : そうそう。「11111」だったら「?」に、「00011」だったら「D」にとやってゆけばいいんだよ。
ピーター : これは単純ですね……えーと「?D-C'KOPUA」になりました。でも意味不明ですよ。
博士 : 文字数を数えてごらん。
ピーター : １０文字ですよ。あっ、「PETER POTTER」は１２文字だったのに２文字減っています。
博士 : そう、この表を使えば文字を減らすことができるのだよ。じゃあ今度はこの文章で同じことをやっ
       てごらん。
PETER PIPER PICKED A PECK OF PICKLED PEPPERS. A PECK OF PICKLED PEPPERS
PETER PIPER PICKED. IF PETER PIPER PICKED A PECK OF PICKLED PEPPERS, WHERE'S
THE PECK OF PICKLED PEPPERS PETER PIPER PICKED?
ピーター : ぎょぎょ、行が分かれていますが、どうするんですか?
博士 : 紙の都合で３行になってしまったが、改行文字のかわりに空白がある長い１行だと思っておくれ。
ピーター : はいはい。行と行の間にあるのは空白だと。しかし面倒だな……。
博士 : だったらプログラムにやらせればいいではないか。
ということで、ピーターの代わりに、読み込んだ文字列を符号に変換し出力するプログラムを作成してください。
入力
複数のデータセットが与えられます。各データセットに文字列１行（表に含まれる文字からなる）が与えられます。文字列に含まれる文字の数は 1 文字以上 100 文字以下です。
データセットの数は 200 を超えません。
出力
各データセットごとに、変換後の文字列を１行に出力してください。
Sample Input
PETER POTTER
Output for the Sample Input
?D-C'KOPUA",C,"#include <stdio.h>
int main()
{
  unsigned char *a = ""\n ',-.?ABCDEFGHIJKLMNOPQRSTUVWXYZ"";
  unsigned char *b[] = {
    ""101"",""101"",""000000"",""000011"",""10010001"",""010001"",""000001"",""100101"",
    ""10011010"",""0101"",""0001"",""110"",""01001"",""10011011"",""010000"",""0111"",
    ""10011000"",""0110"",""00100"",""10011001"",""10011110"",""00101"",""111"",
    ""10011111"",""1000"",""00110"",""00111"",""10011100"",""10011101"",""000010"",
    ""10010010"",""10010011"",""10010000""
  };
  unsigned char *c = ""ABCDEFGHIJKLMNOPQRSTUVWXYZ .,-'?"";
  unsigned char d[4096];
  unsigned char *p;
  int i,j,k;
  i = 0;
  while((k = getc(stdin)) != '\n'){
    j = 0;
    while(*(a + j) != k) j++;
    p = b[j];
    while(*p) d[i++] = *p++;
  }
  while(i % 5) d[i++] = '0';
  d[i] = '\0';
  i = 0;
  while(d[i]) {
    k = 0;
    j = 4;
    do {
      k |= (d[i++] == '1') << j;
    } while(j--);
    putc(*(c + k),stdout);
  }
  putc('\n',stdout);
  return 0;
}",1
p00088,"博士が愛した符号
博士 : ピーター君、ついにやったよ。
ピーター : どうしました、デビッド博士？またくだらない発明ですか？
博士 : この表だよ、この表。
文字
符号
（空白）
101
'
000000
,
000011
-
10010001
.
010001
?
000001
A
100101
B
10011010
文字
符号
C
0101
D
0001
E
110
F
01001
G
10011011
H
010000
I
0111
J
10011000
文字
符号
K
0110
L
00100
M
10011001
N
10011110
O
00101
P
111
Q
10011111
R
1000
文字
符号
S
00110
T
00111
U
10011100
V
10011101
W
000010
X
10010010
Y
10010011
Z
10010000
ピーター : なんですか? この表は。
博士 : いいから、言う通りにしてみなさい。まず、お前の名前を紙に書いてごらん。
ピーター : はい""PETER POTTER"" っと。
博士 : そうしたら、１文字ずつ、この表の「符号」に置き換えるのだよ。
ピーター : えーと""P"" を「111」にして""E"" を「110」して…結構面倒ですね。
111 110 00111 110 1000 101 111 00101 00111 00111 110 1000
になりました。なんだか、バーコードみたいですね。
博士 : よろしい。そうしたら、置き換えた文字列を全部つなげて、５文字ごとに区切ってみなさい。
ピーター : はいはい、つなげて区切ると。
11111 00011 11101 00010 11110 01010 01110 01111 10100 0
こんな感じになりました。けど、最後の「0」だけのやつはどうしますか?
博士 : ０を付け加えて５文字にしておいてくれ。
ピーター : えーと最後が０が1個だけだから０をあと４つ加えてやればいいんですね。できました。
11111 00011 11101 00010 11110 01010 01110 01111 10100 00000
博士 : 次はこの表を使うのだ。
符号
文字
00000
A
00001
B
00010
C
00011
D
00100
E
00101
F
00110
G
00111
H
符号
文字
01000
I
01001
J
01010
K
01011
L
01100
M
01101
N
01110
O
01111
P
符号
文字
10000
Q
10001
R
10010
S
10011
T
10100
U
10101
V
10110
W
10111
X
符号
文字
11000
Y
11001
Z
11010
（空白）
11011
.
11100
,
11101
-
11110
'
11111
?
ピーター : これをどう使うんですか…そうか!今度は符号から文字に置き換えるのか!
博士 : そうそう。「11111」だったら「?」に、「00011」だったら「D」にとやってゆけばいいんだよ。
ピーター : これは単純ですね……えーと「?D-C'KOPUA」になりました。でも意味不明ですよ。
博士 : 文字数を数えてごらん。
ピーター : １０文字ですよ。あっ、「PETER POTTER」は１２文字だったのに２文字減っています。
博士 : そう、この表を使えば文字を減らすことができるのだよ。じゃあ今度はこの文章で同じことをやっ
       てごらん。
PETER PIPER PICKED A PECK OF PICKLED PEPPERS. A PECK OF PICKLED PEPPERS
PETER PIPER PICKED. IF PETER PIPER PICKED A PECK OF PICKLED PEPPERS, WHERE'S
THE PECK OF PICKLED PEPPERS PETER PIPER PICKED?
ピーター : ぎょぎょ、行が分かれていますが、どうするんですか?
博士 : 紙の都合で３行になってしまったが、改行文字のかわりに空白がある長い１行だと思っておくれ。
ピーター : はいはい。行と行の間にあるのは空白だと。しかし面倒だな……。
博士 : だったらプログラムにやらせればいいではないか。
ということで、ピーターの代わりに、読み込んだ文字列を符号に変換し出力するプログラムを作成してください。
入力
複数のデータセットが与えられます。各データセットに文字列１行（表に含まれる文字からなる）が与えられます。文字列に含まれる文字の数は 1 文字以上 100 文字以下です。
データセットの数は 200 を超えません。
出力
各データセットごとに、変換後の文字列を１行に出力してください。
Sample Input
PETER POTTER
Output for the Sample Input
?D-C'KOPUA",Java,"import java.util.*;

public class Main {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        
        Map<Character, String> encode1 = new HashMap<>();
        encode1.put(' ', ""101"");
        encode1.put('\'', ""000000"");
        encode1.put(',', ""000011"");
        encode1.put('-', ""10010001"");
        encode1.put('.', ""010001"");
        encode1.put('?', ""000001"");
        encode1.put('A', ""100101"");
        encode1.put('B', ""10011010"");
        encode1.put('C', ""0101"");
        encode1.put('D', ""0001"");
        encode1.put('E', ""110"");
        encode1.put('F', ""01001"");
        encode1.put('G', ""10011011"");
        encode1.put('H', ""010000"");
        encode1.put('I', ""0111"");
        encode1.put('J', ""10011000"");
        encode1.put('K', ""0110"");
        encode1.put('L', ""00100"");
        encode1.put('M', ""10011001"");
        encode1.put('N', ""10011110"");
        encode1.put('O', ""00101"");
        encode1.put('P', ""111"");
        encode1.put('Q', ""10011111"");
        encode1.put('R', ""1000"");
        encode1.put('S', ""00110"");
        encode1.put('T', ""00111"");
        encode1.put('U', ""10011100"");
        encode1.put('V', ""10011101"");
        encode1.put('W', ""000010"");
        encode1.put('X', ""10010010"");
        encode1.put('Y', ""10010011"");
        encode1.put('Z', ""10010000"");
        
        Map<String, Character> encode2 = new HashMap<>();
        encode2.put(""00000"", 'A');
        encode2.put(""00001"", 'B');
        encode2.put(""00010"", 'C');
        encode2.put(""00011"", 'D');
        encode2.put(""00100"", 'E');
        encode2.put(""00101"", 'F');
        encode2.put(""00110"", 'G');
        encode2.put(""00111"", 'H');
        encode2.put(""01000"", 'I');
        encode2.put(""01001"", 'J');
        encode2.put(""01010"", 'K');
        encode2.put(""01011"", 'L');
        encode2.put(""01100"", 'M');
        encode2.put(""01101"", 'N');
        encode2.put(""01110"", 'O');
        encode2.put(""01111"", 'P');
        encode2.put(""10000"", 'Q');
        encode2.put(""10001"", 'R');
        encode2.put(""10010"", 'S');
        encode2.put(""10011"", 'T');
        encode2.put(""10100"", 'U');
        encode2.put(""10101"", 'V');
        encode2.put(""10110"", 'W');
        encode2.put(""10111"", 'X');
        encode2.put(""11000"", 'Y');
        encode2.put(""11001"", 'Z');
        encode2.put(""11010"", ' ');
        encode2.put(""11011"", '.');
        encode2.put(""11100"", ',');
        encode2.put(""11101"", '-');
        encode2.put(""11110"", '\'');
        encode2.put(""11111"", '?');
        
        while (sc.hasNextLine()) {
            String line = sc.nextLine();
            
            StringBuilder binary = new StringBuilder();
            for (char c : line.toCharArray()) {
                binary.append(encode1.get(c));
            }
            
            while (binary.length() % 5 != 0) {
                binary.append('0');
            }
            
            StringBuilder result = new StringBuilder();
            for (int i = 0; i < binary.length(); i += 5) {
                String chunk = binary.substring(i, i + 5);
                result.append(encode2.get(chunk));
            }
            
            System.out.println(result.toString());
        }
        
        sc.close();
    }
}
",0
p00088,"博士が愛した符号
博士 : ピーター君、ついにやったよ。
ピーター : どうしました、デビッド博士？またくだらない発明ですか？
博士 : この表だよ、この表。
文字
符号
（空白）
101
'
000000
,
000011
-
10010001
.
010001
?
000001
A
100101
B
10011010
文字
符号
C
0101
D
0001
E
110
F
01001
G
10011011
H
010000
I
0111
J
10011000
文字
符号
K
0110
L
00100
M
10011001
N
10011110
O
00101
P
111
Q
10011111
R
1000
文字
符号
S
00110
T
00111
U
10011100
V
10011101
W
000010
X
10010010
Y
10010011
Z
10010000
ピーター : なんですか? この表は。
博士 : いいから、言う通りにしてみなさい。まず、お前の名前を紙に書いてごらん。
ピーター : はい""PETER POTTER"" っと。
博士 : そうしたら、１文字ずつ、この表の「符号」に置き換えるのだよ。
ピーター : えーと""P"" を「111」にして""E"" を「110」して…結構面倒ですね。
111 110 00111 110 1000 101 111 00101 00111 00111 110 1000
になりました。なんだか、バーコードみたいですね。
博士 : よろしい。そうしたら、置き換えた文字列を全部つなげて、５文字ごとに区切ってみなさい。
ピーター : はいはい、つなげて区切ると。
11111 00011 11101 00010 11110 01010 01110 01111 10100 0
こんな感じになりました。けど、最後の「0」だけのやつはどうしますか?
博士 : ０を付け加えて５文字にしておいてくれ。
ピーター : えーと最後が０が1個だけだから０をあと４つ加えてやればいいんですね。できました。
11111 00011 11101 00010 11110 01010 01110 01111 10100 00000
博士 : 次はこの表を使うのだ。
符号
文字
00000
A
00001
B
00010
C
00011
D
00100
E
00101
F
00110
G
00111
H
符号
文字
01000
I
01001
J
01010
K
01011
L
01100
M
01101
N
01110
O
01111
P
符号
文字
10000
Q
10001
R
10010
S
10011
T
10100
U
10101
V
10110
W
10111
X
符号
文字
11000
Y
11001
Z
11010
（空白）
11011
.
11100
,
11101
-
11110
'
11111
?
ピーター : これをどう使うんですか…そうか!今度は符号から文字に置き換えるのか!
博士 : そうそう。「11111」だったら「?」に、「00011」だったら「D」にとやってゆけばいいんだよ。
ピーター : これは単純ですね……えーと「?D-C'KOPUA」になりました。でも意味不明ですよ。
博士 : 文字数を数えてごらん。
ピーター : １０文字ですよ。あっ、「PETER POTTER」は１２文字だったのに２文字減っています。
博士 : そう、この表を使えば文字を減らすことができるのだよ。じゃあ今度はこの文章で同じことをやっ
       てごらん。
PETER PIPER PICKED A PECK OF PICKLED PEPPERS. A PECK OF PICKLED PEPPERS
PETER PIPER PICKED. IF PETER PIPER PICKED A PECK OF PICKLED PEPPERS, WHERE'S
THE PECK OF PICKLED PEPPERS PETER PIPER PICKED?
ピーター : ぎょぎょ、行が分かれていますが、どうするんですか?
博士 : 紙の都合で３行になってしまったが、改行文字のかわりに空白がある長い１行だと思っておくれ。
ピーター : はいはい。行と行の間にあるのは空白だと。しかし面倒だな……。
博士 : だったらプログラムにやらせればいいではないか。
ということで、ピーターの代わりに、読み込んだ文字列を符号に変換し出力するプログラムを作成してください。
入力
複数のデータセットが与えられます。各データセットに文字列１行（表に含まれる文字からなる）が与えられます。文字列に含まれる文字の数は 1 文字以上 100 文字以下です。
データセットの数は 200 を超えません。
出力
各データセットごとに、変換後の文字列を１行に出力してください。
Sample Input
PETER POTTER
Output for the Sample Input
?D-C'KOPUA",Java,"import java.util.*;
public class Main {
    public static void main(String[] args) throws java.io.IOException{
        Scanner scan = new Scanner(System.in);
        HashMap<Character,String> ep =new HashMap<Character,String>();
        HashMap<String,Character> dp =new HashMap<String,Character>();

		ep.put(' ', ""101"");
		ep.put('\'', ""000000"");
		ep.put(',', ""000011"");
		ep.put('-', ""10010001"");
		ep.put('.', ""010001"");
		ep.put('?', ""000001"");
		ep.put('A', ""100101"");
		ep.put('B', ""10011010"");
		ep.put('C', ""0101"");
		ep.put('D', ""0001"");
		ep.put('E', ""110"");
		ep.put('F', ""01001"");
		ep.put('G', ""10011011"");
		ep.put('H', ""010000"");
		ep.put('I', ""0111"");
		ep.put('J', ""10011000"");
		ep.put('K', ""0110"");
		ep.put('L', ""00100"");
		ep.put('M', ""10011001"");
		ep.put('N', ""10011110"");
		ep.put('O', ""00101"");
		ep.put('P', ""111"");
		ep.put('Q', ""10011111"");
		ep.put('R', ""1000"");
		ep.put('S', ""00110"");
		ep.put('T', ""00111"");
		ep.put('U', ""10011100"");
		ep.put('V', ""10011101"");
		ep.put('W', ""000010"");
		ep.put('X', ""10010010"");
		ep.put('Y', ""10010011"");
		ep.put('Z', ""10010000"");
        
		dp.put(""00000"", 'A');
		dp.put(""00001"", 'B');
		dp.put(""00010"", 'C');
		dp.put(""00011"", 'D');
		dp.put(""00100"", 'E');
		dp.put(""00101"", 'F');
		dp.put(""00110"", 'G');
		dp.put(""00111"", 'H');
		dp.put(""01000"", 'I');
		dp.put(""01001"", 'J');
		dp.put(""01010"", 'K');
		dp.put(""01011"", 'L');
		dp.put(""01100"", 'M');
		dp.put(""01101"", 'N');
		dp.put(""01110"", 'O');
		dp.put(""01111"", 'P');
		dp.put(""10000"", 'Q');
		dp.put(""10001"", 'R');
		dp.put(""10010"", 'S');
		dp.put(""10011"", 'T');
		dp.put(""10100"", 'U');
		dp.put(""10101"", 'V');
		dp.put(""10110"", 'W');
		dp.put(""10111"", 'X');
		dp.put(""11000"", 'Y');
		dp.put(""11001"", 'Z');
		dp.put(""11010"", ' ');
		dp.put(""11011"", '.');
		dp.put(""11100"", ',');
		dp.put(""11101"", '-');
		dp.put(""11110"", '\'');
		dp.put(""11111"", '?');
        
        while(scan.hasNext()){
        	char [] line= scan.nextLine().toCharArray();
        	String tmp="""";
        	for(int i=0;i<line.length;i++)
        		tmp+=ep.get(line[i]);
        	String [] splitedCode =new String[tmp.length()/5+1];
        	for(int i=0;i<splitedCode.length;i++){	
        		if(i==(splitedCode.length-1))
        			splitedCode[i]=tmp.substring(5*i,tmp.length());
        		else splitedCode[i]=tmp.substring(5*i,5*i+5);
        	}
        		if(tmp.length()%5!=0)
        	for(int i=0;i<(5-tmp.length()%5);i++)
        		splitedCode[splitedCode.length-1]+=""0"";
        	
        	StringBuilder sb = new StringBuilder();
        	for(int i=0;i<splitedCode.length;i++)
        		sb.append(dp.get(splitedCode[i]));
        	System.out.println(sb);
        }
    }
}",1
p00088,"博士が愛した符号
博士 : ピーター君、ついにやったよ。
ピーター : どうしました、デビッド博士？またくだらない発明ですか？
博士 : この表だよ、この表。
文字
符号
（空白）
101
'
000000
,
000011
-
10010001
.
010001
?
000001
A
100101
B
10011010
文字
符号
C
0101
D
0001
E
110
F
01001
G
10011011
H
010000
I
0111
J
10011000
文字
符号
K
0110
L
00100
M
10011001
N
10011110
O
00101
P
111
Q
10011111
R
1000
文字
符号
S
00110
T
00111
U
10011100
V
10011101
W
000010
X
10010010
Y
10010011
Z
10010000
ピーター : なんですか? この表は。
博士 : いいから、言う通りにしてみなさい。まず、お前の名前を紙に書いてごらん。
ピーター : はい""PETER POTTER"" っと。
博士 : そうしたら、１文字ずつ、この表の「符号」に置き換えるのだよ。
ピーター : えーと""P"" を「111」にして""E"" を「110」して…結構面倒ですね。
111 110 00111 110 1000 101 111 00101 00111 00111 110 1000
になりました。なんだか、バーコードみたいですね。
博士 : よろしい。そうしたら、置き換えた文字列を全部つなげて、５文字ごとに区切ってみなさい。
ピーター : はいはい、つなげて区切ると。
11111 00011 11101 00010 11110 01010 01110 01111 10100 0
こんな感じになりました。けど、最後の「0」だけのやつはどうしますか?
博士 : ０を付け加えて５文字にしておいてくれ。
ピーター : えーと最後が０が1個だけだから０をあと４つ加えてやればいいんですね。できました。
11111 00011 11101 00010 11110 01010 01110 01111 10100 00000
博士 : 次はこの表を使うのだ。
符号
文字
00000
A
00001
B
00010
C
00011
D
00100
E
00101
F
00110
G
00111
H
符号
文字
01000
I
01001
J
01010
K
01011
L
01100
M
01101
N
01110
O
01111
P
符号
文字
10000
Q
10001
R
10010
S
10011
T
10100
U
10101
V
10110
W
10111
X
符号
文字
11000
Y
11001
Z
11010
（空白）
11011
.
11100
,
11101
-
11110
'
11111
?
ピーター : これをどう使うんですか…そうか!今度は符号から文字に置き換えるのか!
博士 : そうそう。「11111」だったら「?」に、「00011」だったら「D」にとやってゆけばいいんだよ。
ピーター : これは単純ですね……えーと「?D-C'KOPUA」になりました。でも意味不明ですよ。
博士 : 文字数を数えてごらん。
ピーター : １０文字ですよ。あっ、「PETER POTTER」は１２文字だったのに２文字減っています。
博士 : そう、この表を使えば文字を減らすことができるのだよ。じゃあ今度はこの文章で同じことをやっ
       てごらん。
PETER PIPER PICKED A PECK OF PICKLED PEPPERS. A PECK OF PICKLED PEPPERS
PETER PIPER PICKED. IF PETER PIPER PICKED A PECK OF PICKLED PEPPERS, WHERE'S
THE PECK OF PICKLED PEPPERS PETER PIPER PICKED?
ピーター : ぎょぎょ、行が分かれていますが、どうするんですか?
博士 : 紙の都合で３行になってしまったが、改行文字のかわりに空白がある長い１行だと思っておくれ。
ピーター : はいはい。行と行の間にあるのは空白だと。しかし面倒だな……。
博士 : だったらプログラムにやらせればいいではないか。
ということで、ピーターの代わりに、読み込んだ文字列を符号に変換し出力するプログラムを作成してください。
入力
複数のデータセットが与えられます。各データセットに文字列１行（表に含まれる文字からなる）が与えられます。文字列に含まれる文字の数は 1 文字以上 100 文字以下です。
データセットの数は 200 を超えません。
出力
各データセットごとに、変換後の文字列を１行に出力してください。
Sample Input
PETER POTTER
Output for the Sample Input
?D-C'KOPUA",Python,"import sys

# First encoding table (character to binary code)
encode1 = {
    ' ': '101',
    ""'"": '000000',
    ',': '000011',
    '-': '10010001',
    '.': '010001',
    '?': '000001',
    'A': '100101',
    'B': '10011010',
    'C': '0101',
    'D': '0001',
    'E': '110',
    'F': '01001',
    'G': '10011011',
    'H': '010000',
    'I': '0111',
    'J': '10011000',
    'K': '0110',
    'L': '00100',
    'M': '10011001',
    'N': '10011110',
    'O': '00101',
    'P': '111',
    'Q': '10011111',
    'R': '1000',
    'S': '00110',
    'T': '00111',
    'U': '10011100',
    'V': '10011101',
    'W': '000010',
    'X': '10010010',
    'Y': '10010011',
    'Z': '10010000'
}

# Second encoding table (5-bit binary to character)
encode2 = {
    '00000': 'A',
    '00001': 'B',
    '00010': 'C',
    '00011': 'D',
    '00100': 'E',
    '00101': 'F',
    '00110': 'G',
    '00111': 'H',
    '01000': 'I',
    '01001': 'J',
    '01010': 'K',
    '01011': 'L',
    '01100': 'M',
    '01101': 'N',
    '01110': 'O',
    '01111': 'P',
    '10000': 'Q',
    '10001': 'R',
    '10010': 'S',
    '10011': 'T',
    '10100': 'U',
    '10101': 'V',
    '10110': 'W',
    '10111': 'X',
    '11000': 'Y',
    '11001': 'Z',
    '11010': ' ',
    '11011': '.',
    '11100': ',',
    '11101': '-',
    '11110': ""'"",
    '11111': '?'
}

for line in sys.stdin:
    line = line.rstrip('\n')
    
    # Step 1: Convert each character to its binary code
    binary_string = ''.join(encode1[c] for c in line)
    
    # Step 2: Pad with zeros to make length multiple of 5
    remainder = len(binary_string) % 5
    if remainder != 0:
        binary_string += '0' * (5 - remainder)
    
    # Step 3: Split into chunks of 5 and convert using second table
    result = ''
    for i in range(0, len(binary_string), 5):
        chunk = binary_string[i:i+5]
        result += encode2[chunk]
    
    print(result)
",0
p00088,"博士が愛した符号
博士 : ピーター君、ついにやったよ。
ピーター : どうしました、デビッド博士？またくだらない発明ですか？
博士 : この表だよ、この表。
文字
符号
（空白）
101
'
000000
,
000011
-
10010001
.
010001
?
000001
A
100101
B
10011010
文字
符号
C
0101
D
0001
E
110
F
01001
G
10011011
H
010000
I
0111
J
10011000
文字
符号
K
0110
L
00100
M
10011001
N
10011110
O
00101
P
111
Q
10011111
R
1000
文字
符号
S
00110
T
00111
U
10011100
V
10011101
W
000010
X
10010010
Y
10010011
Z
10010000
ピーター : なんですか? この表は。
博士 : いいから、言う通りにしてみなさい。まず、お前の名前を紙に書いてごらん。
ピーター : はい""PETER POTTER"" っと。
博士 : そうしたら、１文字ずつ、この表の「符号」に置き換えるのだよ。
ピーター : えーと""P"" を「111」にして""E"" を「110」して…結構面倒ですね。
111 110 00111 110 1000 101 111 00101 00111 00111 110 1000
になりました。なんだか、バーコードみたいですね。
博士 : よろしい。そうしたら、置き換えた文字列を全部つなげて、５文字ごとに区切ってみなさい。
ピーター : はいはい、つなげて区切ると。
11111 00011 11101 00010 11110 01010 01110 01111 10100 0
こんな感じになりました。けど、最後の「0」だけのやつはどうしますか?
博士 : ０を付け加えて５文字にしておいてくれ。
ピーター : えーと最後が０が1個だけだから０をあと４つ加えてやればいいんですね。できました。
11111 00011 11101 00010 11110 01010 01110 01111 10100 00000
博士 : 次はこの表を使うのだ。
符号
文字
00000
A
00001
B
00010
C
00011
D
00100
E
00101
F
00110
G
00111
H
符号
文字
01000
I
01001
J
01010
K
01011
L
01100
M
01101
N
01110
O
01111
P
符号
文字
10000
Q
10001
R
10010
S
10011
T
10100
U
10101
V
10110
W
10111
X
符号
文字
11000
Y
11001
Z
11010
（空白）
11011
.
11100
,
11101
-
11110
'
11111
?
ピーター : これをどう使うんですか…そうか!今度は符号から文字に置き換えるのか!
博士 : そうそう。「11111」だったら「?」に、「00011」だったら「D」にとやってゆけばいいんだよ。
ピーター : これは単純ですね……えーと「?D-C'KOPUA」になりました。でも意味不明ですよ。
博士 : 文字数を数えてごらん。
ピーター : １０文字ですよ。あっ、「PETER POTTER」は１２文字だったのに２文字減っています。
博士 : そう、この表を使えば文字を減らすことができるのだよ。じゃあ今度はこの文章で同じことをやっ
       てごらん。
PETER PIPER PICKED A PECK OF PICKLED PEPPERS. A PECK OF PICKLED PEPPERS
PETER PIPER PICKED. IF PETER PIPER PICKED A PECK OF PICKLED PEPPERS, WHERE'S
THE PECK OF PICKLED PEPPERS PETER PIPER PICKED?
ピーター : ぎょぎょ、行が分かれていますが、どうするんですか?
博士 : 紙の都合で３行になってしまったが、改行文字のかわりに空白がある長い１行だと思っておくれ。
ピーター : はいはい。行と行の間にあるのは空白だと。しかし面倒だな……。
博士 : だったらプログラムにやらせればいいではないか。
ということで、ピーターの代わりに、読み込んだ文字列を符号に変換し出力するプログラムを作成してください。
入力
複数のデータセットが与えられます。各データセットに文字列１行（表に含まれる文字からなる）が与えられます。文字列に含まれる文字の数は 1 文字以上 100 文字以下です。
データセットの数は 200 を超えません。
出力
各データセットごとに、変換後の文字列を１行に出力してください。
Sample Input
PETER POTTER
Output for the Sample Input
?D-C'KOPUA",Python,"import sys
d={' ':'101',""'"":'000000',',':'000011','-':'10010001','.':'010001','?':'000001','A':'100101','B':'10011010','C':'0101','D':'0001','E':'110',
'F':'01001','G':'10011011','H':'010000','I':'0111','J':'10011000','K':'0110','L':'00100','M':'10011001','N':'10011110','O':'00101','P':'111',
'Q':'10011111','R':'1000','S':'00110','T':'00111','U':'10011100','V':'10011101','W':'000010','X':'10010010','Y':'10010011','Z':'10010000'}
for e in sys.stdin:
 a=''.join(d[c]for c in e[:-1])
 a+='0'*(-len(a)%5)
 print(''.join(""ABCDEFGHIJKLMNOPQRSTUVWXYZ .,-'?""[int(a[i*5:i*5+5],2)]for i in range(len(a)//5)))
",1
p00089,"最短経路
図１に例示するように整数（0 以上 99 以下）をひしがたに並べます。このような、ひしがたを表すデータを読み込んで、一番上からスタートして一番下まで次のルールに従って進むとき、通過する整数の和の最大値を出力するプログラムを作成してください。
各ステップで、対角線上の左下か対角線上の右下に進むことができます。
例えば図1の例では、図2に示すように、7,3,8,7,5,7,8,3,7を選んで通ったとき、その和は最大の 55 （7+3+8+7+5+7+8+3+7=55） となります。
Input
入力例に示すように、カンマで区切られた整数の並びが、ひし形状に与えられます。各行に空白文字は含まれません。入力例は図１に対応しています。
データの行数は 100 行未満です。
Output
ルールに従って通過する整数の和の最大値を１行に出力します。
Sample Input
7
3,8
8,1,0
2,7,4,4
4,5,2,6,5
2,7,4,4
8,1,0
3,8
7
Sample Output
55",C,"#include <stdio.h>
#include <string.h>
#include <stdlib.h>

int main() {
    int diamond[200][100];
    int dp[200][100];
    int rows = 0;
    char line[1000];
    
    // Read input
    while (fgets(line, sizeof(line), stdin)) {
        int len = strlen(line);
        if (len > 0 && line[len-1] == '\n') {
            line[len-1] = '\0';
        }
        
        int col = 0;
        char *token = strtok(line, "","");
        while (token != NULL) {
            diamond[rows][col] = atoi(token);
            col++;
            token = strtok(NULL, "","");
        }
        rows++;
    }
    
    // Find the middle row (widest part)
    int maxRow = 0;
    for (int i = 0; i < rows; i++) {
        if (i > maxRow) {
            maxRow = i;
        }
    }
    
    // Initialize dp
    for (int i = 0; i < rows; i++) {
        for (int j = 0; j < 100; j++) {
            dp[i][j] = -1;
        }
    }
    
    // Start with first element
    dp[0][0] = diamond[0][0];
    
    // Determine middle row
    int mid = rows / 2;
    
    // Process upper half (expanding)
    for (int i = 0; i < mid; i++) {
        for (int j = 0; j <= i; j++) {
            if (dp[i][j] != -1) {
                // Move to left-down diagonal
                if (dp[i+1][j] < dp[i][j] + diamond[i+1][j]) {
                    dp[i+1][j] = dp[i][j] + diamond[i+1][j];
                }
                // Move to right-down diagonal
                if (dp[i+1][j+1] < dp[i][j] + diamond[i+1][j+1]) {
                    dp[i+1][j+1] = dp[i][j] + diamond[i+1][j+1];
                }
            }
        }
    }
    
    // Process lower half (contracting)
    for (int i = mid; i < rows - 1; i++) {
        int width = rows - i - 1;
        for (int j = 0; j <= width; j++) {
            if (dp[i][j] != -1) {
                // Move to left-down diagonal
                if (j > 0) {
                    if (dp[i+1][j-1] < dp[i][j] + diamond[i+1][j-1]) {
                        dp[i+1][j-1] = dp[i][j] + diamond[i+1][j-1];
                    }
                }
                // Move to right-down diagonal
                if (j < width) {
                    if (dp[i+1][j] < dp[i][j] + diamond[i+1][j]) {
                        dp[i+1][j] = dp[i][j] + diamond[i+1][j];
                    }
                }
            }
        }
    }
    
    printf(""%d\n"", dp[rows-1][0]);
    
    return 0;
}
",0
p00089,"最短経路
図１に例示するように整数（0 以上 99 以下）をひしがたに並べます。このような、ひしがたを表すデータを読み込んで、一番上からスタートして一番下まで次のルールに従って進むとき、通過する整数の和の最大値を出力するプログラムを作成してください。
各ステップで、対角線上の左下か対角線上の右下に進むことができます。
例えば図1の例では、図2に示すように、7,3,8,7,5,7,8,3,7を選んで通ったとき、その和は最大の 55 （7+3+8+7+5+7+8+3+7=55） となります。
Input
入力例に示すように、カンマで区切られた整数の並びが、ひし形状に与えられます。各行に空白文字は含まれません。入力例は図１に対応しています。
データの行数は 100 行未満です。
Output
ルールに従って通過する整数の和の最大値を１行に出力します。
Sample Input
7
3,8
8,1,0
2,7,4,4
4,5,2,6,5
2,7,4,4
8,1,0
3,8
7
Sample Output
55",C,"/* ????????????????????????????????????????????? */
#include <stdio.h>

/* ?????°???????????? */
typedef	void			VD;
typedef	signed char		I1;
typedef unsigned char 	U1;
typedef	signed short	I2;
typedef unsigned short 	U2;
typedef	signed long		I4;
typedef unsigned long 	U4;

/* ?????°?????? */
#define MAXOFNUM_ROW 	99					/* ?????°????????§??? */
#define MAXOFSUM_COLUMN	(MAXOFNUM_ROW+1)/2	/* ?????°????????§??? */

/* ??°?????????????????° */
U1 mu1InputNum[MAXOFNUM_ROW][MAXOFSUM_COLUMN];	/* ??\??????????????°??????????´????????????? */

/* 
??¢??°??????u1ReadData
???????????\???????????????????????????????????°???????????? 
?????°???
?????????
????????????U1 ??\?????????????????°
*/
U1 u1ReadData();

/*
??¢??°??????u2SearchMax
???????????¨????????????????????§?????§???????????????
?????°???
????¬¬1?????°????????°
????????????U2 ?????§???
*/
U2 u2SearchMax(U1 u1NumOfRow);

/*
??¢??°??????
?????????2????????°??????????????§????????°????????????
?????°???
????¬¬1?????°?????°???1
????¬¬2?????°?????°???2
????????????U2 ??§??????????????°???
*/
U2 u2JudjeBigNum(U2 u2Num1,U2 u2Num2);

VD main(void)
{
	U1 u1NumOfRow;						/* ?????????????????° */
	U2 u2MaxOfSum;						/* ???????????§??? */
	
	u1NumOfRow = u1ReadData();				/* ??????1 ??\??????????????????????????? */
	u2MaxOfSum = u2SearchMax(u1NumOfRow);	/* ??????2 ?????§????????¢??? */
	printf(""%d\n"",u2MaxOfSum);				/* ??????3 ?????§????????¨????????? */
}

U1 u1ReadData()
{
	U1 u1NumOfRow;		/* ?????????????????° */
	U1 u1NumOfColumn;	/* ?????????????????° */
	U1 u1TmpChar;		/* ','????????????'\n'???????´????????????° */
	I1 i1ReturnScanf;	/* scanf??¢??°???????????????????´????????????° */
	
	U1 u1OnlyNumCnt;
	
	u1NumOfRow = 0;
	u1NumOfColumn = 0;
	u1OnlyNumCnt = 0;
	
	while(u1OnlyNumCnt != 2){
		scanf(""%d%c"",&mu1InputNum[u1NumOfRow][u1NumOfColumn],&u1TmpChar);
		if(u1TmpChar == ','){
			u1NumOfColumn++;
			u1TmpChar = 0;
		}
		else{
			if(u1NumOfColumn == 0){
				u1OnlyNumCnt++;
			}
			u1NumOfRow++;
			u1NumOfColumn = 0;
		}
	}
	return u1NumOfRow;
}


U2 u2SearchMax(U1 u1NumOfRow)
{
	U2 mu2work[MAXOFNUM_ROW][MAXOFSUM_COLUMN];	/* ?¨???????????????????????´????????????? */
	U1 u1RowCnt;		/* ?????°???????????? */
	U1 u1ColumnCnt;		/* ?????°???????????? */
	U1 u1HalfNumOfRow;	/* ?????°????????? */
	U2 u2Num1;			/* ?¨?????????????????´???????????????°??????????´????????????° */
	U2 u2Num2;			/* ?¨?????????????????´???????????????°??????????´????????????° */
	
	u1HalfNumOfRow = u1NumOfRow/2+1;
	
	/* ??\?????????????????????mu2work?????????????????? */
	for(u1RowCnt = 0; u1RowCnt < u1NumOfRow; u1RowCnt++){
		for(u1ColumnCnt = 0; u1ColumnCnt <= u1RowCnt; u1ColumnCnt++){
			if(u1RowCnt >= u1HalfNumOfRow){
				if(u1ColumnCnt >= u1HalfNumOfRow*2-(u1RowCnt+1)){
					break;
				}
			}
			mu2work[u1RowCnt][u1ColumnCnt] = mu1InputNum[u1RowCnt][u1ColumnCnt];
		}
	}
	
	for(u1RowCnt = 1; u1RowCnt < u1NumOfRow; u1RowCnt++){
		for(u1ColumnCnt = 0; u1ColumnCnt <= u1RowCnt; u1ColumnCnt++){
			/* ????????¢?????¨???????´???°????¨????????????´??? */
			if(u1RowCnt < u1HalfNumOfRow){				
				if(u1ColumnCnt == 0){
					mu2work[u1RowCnt][u1ColumnCnt] = mu1InputNum[u1RowCnt][u1ColumnCnt]+mu2work[u1RowCnt-1][0];
				}
				else if(u1ColumnCnt == u1RowCnt){
					mu2work[u1RowCnt][u1ColumnCnt] = mu1InputNum[u1RowCnt][u1ColumnCnt]+mu2work[u1RowCnt-1][u1RowCnt-1];
				}
				else{
					u2Num1 = mu2work[u1RowCnt-1][u1ColumnCnt-1];
					u2Num2 = mu2work[u1RowCnt-1][u1ColumnCnt];
					mu2work[u1RowCnt][u1ColumnCnt] = mu1InputNum[u1RowCnt][u1ColumnCnt]+u2JudjeBigNum(u2Num1,u2Num2);
				}
			}
			/* ????????¢?????¨???????´???°????¨????????????´??? */
			else{
				if(u1ColumnCnt >= u1HalfNumOfRow*2-(u1RowCnt+1)){
					break;
				}
				u2Num1 = mu2work[u1RowCnt-1][u1ColumnCnt];
				u2Num2 = mu2work[u1RowCnt-1][u1ColumnCnt+1];
				mu2work[u1RowCnt][u1ColumnCnt] = mu1InputNum[u1RowCnt][u1ColumnCnt]+u2JudjeBigNum(u2Num1,u2Num2);
			}
		}
	}
	return mu2work[u1NumOfRow-1][0];
}

U2 u2JudjeBigNum(U2 u2Num1,U2 u2Num2)
{
	U2 u2Rtn;	/* ????????????????´????????????° */
	
	if(u2Num1 >= u2Num2){
		u2Rtn = u2Num1;
	}else{
		u2Rtn = u2Num2;
	}	
	return u2Rtn;
}",1
p00089,"最短経路
図１に例示するように整数（0 以上 99 以下）をひしがたに並べます。このような、ひしがたを表すデータを読み込んで、一番上からスタートして一番下まで次のルールに従って進むとき、通過する整数の和の最大値を出力するプログラムを作成してください。
各ステップで、対角線上の左下か対角線上の右下に進むことができます。
例えば図1の例では、図2に示すように、7,3,8,7,5,7,8,3,7を選んで通ったとき、その和は最大の 55 （7+3+8+7+5+7+8+3+7=55） となります。
Input
入力例に示すように、カンマで区切られた整数の並びが、ひし形状に与えられます。各行に空白文字は含まれません。入力例は図１に対応しています。
データの行数は 100 行未満です。
Output
ルールに従って通過する整数の和の最大値を１行に出力します。
Sample Input
7
3,8
8,1,0
2,7,4,4
4,5,2,6,5
2,7,4,4
8,1,0
3,8
7
Sample Output
55",Java,"import java.util.*;

public class Main {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        List<List<Integer>> diamond = new ArrayList<>();
        
        while (sc.hasNextLine()) {
            String line = sc.nextLine().trim();
            if (line.isEmpty()) break;
            
            List<Integer> row = new ArrayList<>();
            if (line.contains("","")) {
                String[] parts = line.split("","");
                for (String part : parts) {
                    row.add(Integer.parseInt(part));
                }
            } else {
                row.add(Integer.parseInt(line));
            }
            diamond.add(row);
        }
        
        int n = diamond.size();
        int mid = n / 2;
        
        List<List<Integer>> dp = new ArrayList<>();
        for (int i = 0; i < n; i++) {
            List<Integer> row = new ArrayList<>();
            for (int j = 0; j < diamond.get(i).size(); j++) {
                row.add(Integer.MIN_VALUE);
            }
            dp.add(row);
        }
        
        dp.get(0).set(0, diamond.get(0).get(0));
        
        for (int i = 0; i < n - 1; i++) {
            int currSize = diamond.get(i).size();
            int nextSize = diamond.get(i + 1).size();
            
            if (nextSize > currSize) {
                for (int j = 0; j < currSize; j++) {
                    if (dp.get(i).get(j) != Integer.MIN_VALUE) {
                        dp.get(i + 1).set(j, Math.max(dp.get(i + 1).get(j), 
                            dp.get(i).get(j) + diamond.get(i + 1).get(j)));
                        dp.get(i + 1).set(j + 1, Math.max(dp.get(i + 1).get(j + 1), 
                            dp.get(i).get(j) + diamond.get(i + 1).get(j + 1)));
                    }
                }
            } else {
                for (int j = 0; j < currSize; j++) {
                    if (dp.get(i).get(j) != Integer.MIN_VALUE) {
                        if (j > 0) {
                            dp.get(i + 1).set(j - 1, Math.max(dp.get(i + 1).get(j - 1), 
                                dp.get(i).get(j) + diamond.get(i + 1).get(j - 1)));
                        }
                        if (j < nextSize) {
                            dp.get(i + 1).set(j, Math.max(dp.get(i + 1).get(j), 
                                dp.get(i).get(j) + diamond.get(i + 1).get(j)));
                        }
                    }
                }
            }
        }
        
        System.out.println(dp.get(n - 1).get(0));
    }
}
",0
p00089,"最短経路
図１に例示するように整数（0 以上 99 以下）をひしがたに並べます。このような、ひしがたを表すデータを読み込んで、一番上からスタートして一番下まで次のルールに従って進むとき、通過する整数の和の最大値を出力するプログラムを作成してください。
各ステップで、対角線上の左下か対角線上の右下に進むことができます。
例えば図1の例では、図2に示すように、7,3,8,7,5,7,8,3,7を選んで通ったとき、その和は最大の 55 （7+3+8+7+5+7+8+3+7=55） となります。
Input
入力例に示すように、カンマで区切られた整数の並びが、ひし形状に与えられます。各行に空白文字は含まれません。入力例は図１に対応しています。
データの行数は 100 行未満です。
Output
ルールに従って通過する整数の和の最大値を１行に出力します。
Sample Input
7
3,8
8,1,0
2,7,4,4
4,5,2,6,5
2,7,4,4
8,1,0
3,8
7
Sample Output
55",Java,"
import java.util.*;
import static java.lang.Math.*;
import static java.util.Arrays.*;

public class Main {

	int INF = 1 << 28;
	int[] now, next;
	int[] dp1, dp2;
	void run() {
		Scanner sc = new Scanner(System.in);
		String[] str = sc.next().split("","");
		now = new int[str.length+4];
		now[2] = Integer.parseInt(str[0]);
		dp1 = new int[51];
		dp2 = new int[51];
		dp1[1] = now[2]; 
		for(;sc.hasNext();) {
	//		debug(dp1);
			str = sc.next().split("","");
			dp2 = dp1.clone();
	//		if(str[0].equals(""0"")) break;
			next = new int[str.length+4];
			for(int i=0;i<str.length;i++) next[i+2] = Integer.parseInt(str[i]);
	//		debug(next);
			for(int i=2;i<=str.length+1;i++) {
				if(now.length < next.length) dp1[i-1] = max( dp2[i-2] + next[i], dp2[i-1] + next[i]);
				else dp1[i-1] = max( dp2[i-1] + next[i], dp2[i] + next[i]);
			}
			now = next.clone();
		}
		System.out.println(dp1[1]);
	}

	public static void main(String[] args) {
		new Main().run();
	}

	void debug(Object... os) {
		System.err.println(Arrays.deepToString(os));
	}
}",1
p00089,"最短経路
図１に例示するように整数（0 以上 99 以下）をひしがたに並べます。このような、ひしがたを表すデータを読み込んで、一番上からスタートして一番下まで次のルールに従って進むとき、通過する整数の和の最大値を出力するプログラムを作成してください。
各ステップで、対角線上の左下か対角線上の右下に進むことができます。
例えば図1の例では、図2に示すように、7,3,8,7,5,7,8,3,7を選んで通ったとき、その和は最大の 55 （7+3+8+7+5+7+8+3+7=55） となります。
Input
入力例に示すように、カンマで区切られた整数の並びが、ひし形状に与えられます。各行に空白文字は含まれません。入力例は図１に対応しています。
データの行数は 100 行未満です。
Output
ルールに従って通過する整数の和の最大値を１行に出力します。
Sample Input
7
3,8
8,1,0
2,7,4,4
4,5,2,6,5
2,7,4,4
8,1,0
3,8
7
Sample Output
55",Python,"import sys

lines = []
for line in sys.stdin:
    line = line.strip()
    if line:
        lines.append(line)

# Parse the diamond
diamond = []
for line in lines:
    if ',' in line:
        diamond.append(list(map(int, line.split(','))))
    else:
        diamond.append([int(line)])

n = len(diamond)
mid = n // 2

# Dynamic programming
dp = [[float('-inf')] * len(row) for row in diamond]
dp[0][0] = diamond[0][0]

# Process upper half (expanding)
for i in range(1, mid + 1):
    for j in range(len(diamond[i])):
        # Can come from position j-1 or j in previous row
        if j > 0:
            dp[i][j] = max(dp[i][j], dp[i-1][j-1] + diamond[i][j])
        if j < len(diamond[i-1]):
            dp[i][j] = max(dp[i][j], dp[i-1][j] + diamond[i][j])

# Process lower half (contracting)
for i in range(mid + 1, n):
    for j in range(len(diamond[i])):
        # Can come from position j or j+1 in previous row
        if j < len(diamond[i-1]):
            dp[i][j] = max(dp[i][j], dp[i-1][j] + diamond[i][j])
        if j + 1 < len(diamond[i-1]):
            dp[i][j] = max(dp[i][j], dp[i-1][j+1] + diamond[i][j])

print(dp[n-1][0])
",0
p00089,"最短経路
図１に例示するように整数（0 以上 99 以下）をひしがたに並べます。このような、ひしがたを表すデータを読み込んで、一番上からスタートして一番下まで次のルールに従って進むとき、通過する整数の和の最大値を出力するプログラムを作成してください。
各ステップで、対角線上の左下か対角線上の右下に進むことができます。
例えば図1の例では、図2に示すように、7,3,8,7,5,7,8,3,7を選んで通ったとき、その和は最大の 55 （7+3+8+7+5+7+8+3+7=55） となります。
Input
入力例に示すように、カンマで区切られた整数の並びが、ひし形状に与えられます。各行に空白文字は含まれません。入力例は図１に対応しています。
データの行数は 100 行未満です。
Output
ルールに従って通過する整数の和の最大値を１行に出力します。
Sample Input
7
3,8
8,1,0
2,7,4,4
4,5,2,6,5
2,7,4,4
8,1,0
3,8
7
Sample Output
55",Python,"def path(mx,w,h):
	if h < c/2:
		if w > 0:
			mx[h][w] = max(mx[h-1][w],mx[h-1][w-1]) + inp[h][w]
		else:
			mx[h][w] = mx[h-1][w] + inp[h][w]
	else:
		if w < len(inp[h])-1:
			mx[h][w] = max(mx[h-1][w],mx[h-1][w+1]) + inp[h][w]
		else:
			mx[h][w] = mx[h-1][w] + inp[h][w]
	return mx
	
c = 0
inp = []
while True:
	try:
		inp.append(map(int, raw_input().split("","")))
		c += 1
	except:
		mx = [[0 for i in range((c+1)/2)] for i in range(c)]
		mx[0][0] = inp[0][0]
		for h in range(1,c):
			for w in range(len(inp[h])):
				mx = path(mx,w,h)
		print mx[c-1][0]
		break",1
p00090,"シールの重なり
1 辺の長さが 10 の正方形の折り紙に半径 1 の円形のシールを
n
枚貼ります。シールは重ねて貼ることができます。シールを貼る位置の座標を読み込んで、折り紙上でもっとも多くシールが重なっている場所(シールが１枚だけでも""重なっている""とする)でのシールの枚数を出力するプログラムを作成してください。
折り紙の左下を原点とした
x, y
座標を与えます。この
x, y
を円の中心としてシールを貼ることとします。円の中心が折り紙の外に出ることはありません。また、同一座標に複数のシールが貼られることはありません。
Input
複数のデータセットが与えられます。各データセットは以下のような形式で与えられます。
n
x
1
,
y
1
x
2
,
y
2
:
x
n
,
y
n
１行目にシールの枚数
n
(0 ≤ 100) が与えられます。続く
n
行に、各シールの中心座標が与えられます。
x
i
,
y
i
は
i
枚目のシールの中心の
x
座標と
y
座標を表します。各値は小数点以下最大 6 桁までの数字を含む実数で与えられます。
n
が 0 のとき、入力の最後とします。データセットの数は 50 を超えません。
Output
各データセットに対し、折り紙上で最も多くシールが重なっている場所でのシールの枚数（整数）を出力して下さい。
Sample Input
15
3.14979,8.51743 
2.39506,3.84915 
2.68432,5.39095 
5.61904,9.16332 
7.85653,4.75593 
2.84021,5.41511 
1.79500,8.59211 
7.55389,8.17604 
4.70665,4.66125 
1.63470,4.42538 
7.34959,4.61981 
5.09003,8.11122 
5.24373,1.30066 
0.13517,1.83659 
7.57313,1.58150 
0
Output for the Sample Input
4
Hint
入力例のようにシールを貼った図です。円はシール、数字は入力例の行数を表しています。
点(2.3,4.6)では、入力例の 2 行目、3 行目、6 行目、10 行目の 4 枚のシールが重なっています。
6 と 9 のおのおのの中心の距離は 2.01293 なので、シールは重なっていません。1 と 12 のおのおのの中心の距離は 1.98231 なので、シールは重なっています。
２つの円が接しているとき（おのおのの中心の距離が 2 のとき）は、重なっているものとします。",C,"#include <stdio.h>
#include <math.h>

#define MAX_N 100
#define EPS 1e-9

typedef struct {
    double x, y;
} Point;

int main() {
    int n;
    Point stickers[MAX_N];
    
    while (scanf(""%d"", &n) == 1 && n != 0) {
        for (int i = 0; i < n; i++) {
            scanf(""%lf,%lf"", &stickers[i].x, &stickers[i].y);
        }
        
        int maxOverlap = 1;
        
        // Check all pairs of stickers
        for (int i = 0; i < n; i++) {
            for (int j = i + 1; j < n; j++) {
                double dx = stickers[i].x - stickers[j].x;
                double dy = stickers[i].y - stickers[j].y;
                double dist = sqrt(dx * dx + dy * dy);
                
                // If circles overlap or touch
                if (dist <= 2.0 + EPS) {
                    // Find intersection points
                    if (dist < EPS) continue; // Same center (shouldn't happen)
                    
                    // Calculate intersection points
                    double a = dist / 2.0;
                    double h = sqrt(1.0 - a * a);
                    
                    double mx = (stickers[i].x + stickers[j].x) / 2.0;
                    double my = (stickers[i].y + stickers[j].y) / 2.0;
                    
                    double px1 = mx + h * (stickers[j].y - stickers[i].y) / dist;
                    double py1 = my - h * (stickers[j].x - stickers[i].x) / dist;
                    
                    double px2 = mx - h * (stickers[j].y - stickers[i].y) / dist;
                    double py2 = my + h * (stickers[j].x - stickers[i].x) / dist;
                    
                    // Check point 1
                    int count1 = 0;
                    for (int k = 0; k < n; k++) {
                        double d = sqrt((px1 - stickers[k].x) * (px1 - stickers[k].x) + 
                                      (py1 - stickers[k].y) * (py1 - stickers[k].y));
                        if (d <= 1.0 + EPS) count1++;
                    }
                    if (count1 > maxOverlap) maxOverlap = count1;
                    
                    // Check point 2
                    int count2 = 0;
                    for (int k = 0; k < n; k++) {
                        double d = sqrt((px2 - stickers[k].x) * (px2 - stickers[k].x) + 
                                      (py2 - stickers[k].y) * (py2 - stickers[k].y));
                        if (d <= 1.0 + EPS) count2++;
                    }
                    if (count2 > maxOverlap) maxOverlap = count2;
                }
            }
            
            // Check center of each sticker
            int count = 0;
            for (int k = 0; k < n; k++) {
                double d = sqrt((stickers[i].x - stickers[k].x) * (stickers[i].x - stickers[k].x) + 
                              (stickers[i].y - stickers[k].y) * (stickers[i].y - stickers[k].y));
                if (d <= 1.0 + EPS) count++;
            }
            if (count > maxOverlap) maxOverlap = count;
        }
        
        printf(""%d\n"", maxOverlap);
    }
    
    return 0;
}
",0
p00090,"シールの重なり
1 辺の長さが 10 の正方形の折り紙に半径 1 の円形のシールを
n
枚貼ります。シールは重ねて貼ることができます。シールを貼る位置の座標を読み込んで、折り紙上でもっとも多くシールが重なっている場所(シールが１枚だけでも""重なっている""とする)でのシールの枚数を出力するプログラムを作成してください。
折り紙の左下を原点とした
x, y
座標を与えます。この
x, y
を円の中心としてシールを貼ることとします。円の中心が折り紙の外に出ることはありません。また、同一座標に複数のシールが貼られることはありません。
Input
複数のデータセットが与えられます。各データセットは以下のような形式で与えられます。
n
x
1
,
y
1
x
2
,
y
2
:
x
n
,
y
n
１行目にシールの枚数
n
(0 ≤ 100) が与えられます。続く
n
行に、各シールの中心座標が与えられます。
x
i
,
y
i
は
i
枚目のシールの中心の
x
座標と
y
座標を表します。各値は小数点以下最大 6 桁までの数字を含む実数で与えられます。
n
が 0 のとき、入力の最後とします。データセットの数は 50 を超えません。
Output
各データセットに対し、折り紙上で最も多くシールが重なっている場所でのシールの枚数（整数）を出力して下さい。
Sample Input
15
3.14979,8.51743 
2.39506,3.84915 
2.68432,5.39095 
5.61904,9.16332 
7.85653,4.75593 
2.84021,5.41511 
1.79500,8.59211 
7.55389,8.17604 
4.70665,4.66125 
1.63470,4.42538 
7.34959,4.61981 
5.09003,8.11122 
5.24373,1.30066 
0.13517,1.83659 
7.57313,1.58150 
0
Output for the Sample Input
4
Hint
入力例のようにシールを貼った図です。円はシール、数字は入力例の行数を表しています。
点(2.3,4.6)では、入力例の 2 行目、3 行目、6 行目、10 行目の 4 枚のシールが重なっています。
6 と 9 のおのおのの中心の距離は 2.01293 なので、シールは重なっていません。1 と 12 のおのおのの中心の距離は 1.98231 なので、シールは重なっています。
２つの円が接しているとき（おのおのの中心の距離が 2 のとき）は、重なっているものとします。",C,"// AOJ0090 Overlaps of Seals

#include <stdio.h>
#include <string.h>

#define MAX_N	(200)


int main(void)
{
    int n;
	double circle[MAX_N][2];
    double d;
    int flag[MAX_N][MAX_N];
    int overlap[MAX_N][MAX_N];
    int max_overlap;
	int i, j, k;
	int num[MAX_N], max[MAX_N], min[MAX_N];
    int cont_flag;
	
	while (1){
		scanf(""%d"", &n);
		if (n == 0){
			break;
		}
		
		// üÍ
		for (i = 0; i < n; i++){
			scanf(""%lf,%lf"", &circle[i][0], &circle[i][1]);
		}
		
		// dÈèe[uì¬
		memset(flag, 0, sizeof(flag));
		for (i = 0; i < n; i++){
			for (j = i; j < n; j++){
				if (i == j){
					flag[i][j] = 1;
				}
				else {
					d = (circle[i][0] - circle[j][0]) * (circle[i][0] - circle[j][0]) +
					    (circle[i][1] - circle[j][1]) * (circle[i][1] - circle[j][1]);
					if (d <= 4.0){
						flag[i][j] = flag[j][i] = 1;
					}
				}
			}
		}
        
                    // [Á±Ìí
        max_overlap = 1;
        do {
			for (i = 0; i < n; i++){
                num[i] = 0;
				for (j = 0; j < n; j++){
					num[i] += flag[i][j];
				}
   			}

            cont_flag = 0;
			for (i = 0; i < n; i++){
                if (num[i] == 2){
                    max_overlap = 2;
                }
				if (num[i] == 1 || num[i] == 2){
					for (j = 0; j < n; j++){
						flag[i][j] = flag[j][i] = 0; 
					}
                    cont_flag = 1;
				}
			}
		} while (cont_flag == 1);

        
		memset(overlap, 0, sizeof(overlap));
        for (i = 0; i < n; i++){
            if (num[i] > 0){
                for (j = 0; j < n; j++){
                    if (flag[i][j] == 1){
                        for (k = j + 1; k < n; k++){
                            if (flag[i][k] == 1){
                                if (flag[j][k] == 1){
                                    overlap[i][j]++;
                                    overlap[i][k]++;
                                }
                            }
                        }
                    }
                }
            }
        }
        
        for (i = 0; i < n; i++){
            max[i] = 0;
            min[i] = 1000;
        }
        for (i = 0; i < n; i++){
            for (j = 0; j < n; j++){
                if (max[i] < overlap[i][j]){
                    max[i] = overlap[i][j];
                }
                if (overlap[i][j] > 0 && min[i] > overlap[i][j]){
                    min[i] = overlap[i][j];
                }
            }
//            printf(""<%d %d-%d>"", i, min[i], max[i]);
        }

        for (i = 0; i < n; i++){
            for (j = 0; j < n; j++){
//                printf(""[%d]"",overlap[i][j]);
                if (overlap[i][j] < overlap[i][i] || max[i] == min[i]){
                    if (max_overlap < overlap[i][j]){
                        max_overlap = overlap[i][j];
                    }
                }
            }
//            printf(""\n"");
        }
        
        printf(""%d\n"", max_overlap + 1);
	}
	
	return (0);
}",1
p00090,"シールの重なり
1 辺の長さが 10 の正方形の折り紙に半径 1 の円形のシールを
n
枚貼ります。シールは重ねて貼ることができます。シールを貼る位置の座標を読み込んで、折り紙上でもっとも多くシールが重なっている場所(シールが１枚だけでも""重なっている""とする)でのシールの枚数を出力するプログラムを作成してください。
折り紙の左下を原点とした
x, y
座標を与えます。この
x, y
を円の中心としてシールを貼ることとします。円の中心が折り紙の外に出ることはありません。また、同一座標に複数のシールが貼られることはありません。
Input
複数のデータセットが与えられます。各データセットは以下のような形式で与えられます。
n
x
1
,
y
1
x
2
,
y
2
:
x
n
,
y
n
１行目にシールの枚数
n
(0 ≤ 100) が与えられます。続く
n
行に、各シールの中心座標が与えられます。
x
i
,
y
i
は
i
枚目のシールの中心の
x
座標と
y
座標を表します。各値は小数点以下最大 6 桁までの数字を含む実数で与えられます。
n
が 0 のとき、入力の最後とします。データセットの数は 50 を超えません。
Output
各データセットに対し、折り紙上で最も多くシールが重なっている場所でのシールの枚数（整数）を出力して下さい。
Sample Input
15
3.14979,8.51743 
2.39506,3.84915 
2.68432,5.39095 
5.61904,9.16332 
7.85653,4.75593 
2.84021,5.41511 
1.79500,8.59211 
7.55389,8.17604 
4.70665,4.66125 
1.63470,4.42538 
7.34959,4.61981 
5.09003,8.11122 
5.24373,1.30066 
0.13517,1.83659 
7.57313,1.58150 
0
Output for the Sample Input
4
Hint
入力例のようにシールを貼った図です。円はシール、数字は入力例の行数を表しています。
点(2.3,4.6)では、入力例の 2 行目、3 行目、6 行目、10 行目の 4 枚のシールが重なっています。
6 と 9 のおのおのの中心の距離は 2.01293 なので、シールは重なっていません。1 と 12 のおのおのの中心の距離は 1.98231 なので、シールは重なっています。
２つの円が接しているとき（おのおのの中心の距離が 2 のとき）は、重なっているものとします。",Java,"import java.util.*;
import java.io.*;

public class Main {
    static class Point {
        double x, y;
        Point(double x, double y) {
            this.x = x;
            this.y = y;
        }
        double dist(Point p) {
            return Math.sqrt((x - p.x) * (x - p.x) + (y - p.y) * (y - p.y));
        }
    }
    
    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        String line;
        
        while ((line = br.readLine()) != null) {
            int n = Integer.parseInt(line.trim());
            if (n == 0) break;
            
            Point[] stickers = new Point[n];
            for (int i = 0; i < n; i++) {
                String[] parts = br.readLine().trim().split("","");
                double x = Double.parseDouble(parts[0]);
                double y = Double.parseDouble(parts[1]);
                stickers[i] = new Point(x, y);
            }
            
            int maxOverlap = 1;
            
            // Check all pairs of stickers and find intersection points
            for (int i = 0; i < n; i++) {
                for (int j = i + 1; j < n; j++) {
                    double d = stickers[i].dist(stickers[j]);
                    if (d <= 2.0) {
                        // Find intersection points
                        List<Point> testPoints = getIntersectionPoints(stickers[i], stickers[j]);
                        for (Point p : testPoints) {
                            int count = 0;
                            for (int k = 0; k < n; k++) {
                                if (stickers[k].dist(p) <= 1.0 + 1e-9) {
                                    count++;
                                }
                            }
                            maxOverlap = Math.max(maxOverlap, count);
                        }
                    }
                }
                // Also check the center of each sticker
                int count = 0;
                for (int k = 0; k < n; k++) {
                    if (stickers[k].dist(stickers[i]) <= 1.0 + 1e-9) {
                        count++;
                    }
                }
                maxOverlap = Math.max(maxOverlap, count);
            }
            
            System.out.println(maxOverlap);
        }
    }
    
    static List<Point> getIntersectionPoints(Point c1, Point c2) {
        List<Point> points = new ArrayList<>();
        double d = c1.dist(c2);
        
        if (d > 2.0 + 1e-9) return points;
        
        double r = 1.0;
        double a = (r * r - r * r + d * d) / (2 * d);
        double h = Math.sqrt(Math.max(0, r * r - a * a));
        
        double cx = c1.x + a * (c2.x - c1.x) / d;
        double cy = c1.y + a * (c2.y - c1.y) / d;
        
        double px1 = cx + h * (c2.y - c1.y) / d;
        double py1 = cy - h * (c2.x - c1.x) / d;
        
        double px2 = cx - h * (c2.y - c1.y) / d;
        double py2 = cy + h * (c2.x - c1.x) / d;
        
        points.add(new Point(px1, py1));
        if (h > 1e-9) {
            points.add(new Point(px2, py2));
        }
        
        return points;
    }
}
",0
p00090,"シールの重なり
1 辺の長さが 10 の正方形の折り紙に半径 1 の円形のシールを
n
枚貼ります。シールは重ねて貼ることができます。シールを貼る位置の座標を読み込んで、折り紙上でもっとも多くシールが重なっている場所(シールが１枚だけでも""重なっている""とする)でのシールの枚数を出力するプログラムを作成してください。
折り紙の左下を原点とした
x, y
座標を与えます。この
x, y
を円の中心としてシールを貼ることとします。円の中心が折り紙の外に出ることはありません。また、同一座標に複数のシールが貼られることはありません。
Input
複数のデータセットが与えられます。各データセットは以下のような形式で与えられます。
n
x
1
,
y
1
x
2
,
y
2
:
x
n
,
y
n
１行目にシールの枚数
n
(0 ≤ 100) が与えられます。続く
n
行に、各シールの中心座標が与えられます。
x
i
,
y
i
は
i
枚目のシールの中心の
x
座標と
y
座標を表します。各値は小数点以下最大 6 桁までの数字を含む実数で与えられます。
n
が 0 のとき、入力の最後とします。データセットの数は 50 を超えません。
Output
各データセットに対し、折り紙上で最も多くシールが重なっている場所でのシールの枚数（整数）を出力して下さい。
Sample Input
15
3.14979,8.51743 
2.39506,3.84915 
2.68432,5.39095 
5.61904,9.16332 
7.85653,4.75593 
2.84021,5.41511 
1.79500,8.59211 
7.55389,8.17604 
4.70665,4.66125 
1.63470,4.42538 
7.34959,4.61981 
5.09003,8.11122 
5.24373,1.30066 
0.13517,1.83659 
7.57313,1.58150 
0
Output for the Sample Input
4
Hint
入力例のようにシールを貼った図です。円はシール、数字は入力例の行数を表しています。
点(2.3,4.6)では、入力例の 2 行目、3 行目、6 行目、10 行目の 4 枚のシールが重なっています。
6 と 9 のおのおのの中心の距離は 2.01293 なので、シールは重なっていません。1 と 12 のおのおのの中心の距離は 1.98231 なので、シールは重なっています。
２つの円が接しているとき（おのおのの中心の距離が 2 のとき）は、重なっているものとします。",Java,"import java.util.Scanner;

public class Main 
{
	public static void main(String[] args)
	{
		Scanner scanner = new Scanner(System.in);
		
		for(; ;)
		{
			int n = scanner.nextInt();
			if(n == 0)
			{
				break;
			}
			
			int max_len = 0;
			float[] x = new float[n];
			float[] y = new float[n];
			for(int i=0; i<n; i++)
			{
				String[] input = scanner.next().split("","");
				
				x[i] = Float.parseFloat(input[0]);
				y[i] = Float.parseFloat(input[1]);
			}
			
			for(float px=0; px<=10; px+=0.001)
			{
				for(float py=0; py<=10; py+=0.001)
				{
					int len = 0;
					for(int i=0; i<n; i++)
					{
						if((px-x[i])*(px-x[i])+(py-y[i])*(py-y[i]) <= 1)
						{
							len ++;
						}
					}
					if(max_len < len)
					{
						max_len = len;
					}
				}
			}
			
			System.out.println(max_len);
		}
	}
}",1
p00090,"シールの重なり
1 辺の長さが 10 の正方形の折り紙に半径 1 の円形のシールを
n
枚貼ります。シールは重ねて貼ることができます。シールを貼る位置の座標を読み込んで、折り紙上でもっとも多くシールが重なっている場所(シールが１枚だけでも""重なっている""とする)でのシールの枚数を出力するプログラムを作成してください。
折り紙の左下を原点とした
x, y
座標を与えます。この
x, y
を円の中心としてシールを貼ることとします。円の中心が折り紙の外に出ることはありません。また、同一座標に複数のシールが貼られることはありません。
Input
複数のデータセットが与えられます。各データセットは以下のような形式で与えられます。
n
x
1
,
y
1
x
2
,
y
2
:
x
n
,
y
n
１行目にシールの枚数
n
(0 ≤ 100) が与えられます。続く
n
行に、各シールの中心座標が与えられます。
x
i
,
y
i
は
i
枚目のシールの中心の
x
座標と
y
座標を表します。各値は小数点以下最大 6 桁までの数字を含む実数で与えられます。
n
が 0 のとき、入力の最後とします。データセットの数は 50 を超えません。
Output
各データセットに対し、折り紙上で最も多くシールが重なっている場所でのシールの枚数（整数）を出力して下さい。
Sample Input
15
3.14979,8.51743 
2.39506,3.84915 
2.68432,5.39095 
5.61904,9.16332 
7.85653,4.75593 
2.84021,5.41511 
1.79500,8.59211 
7.55389,8.17604 
4.70665,4.66125 
1.63470,4.42538 
7.34959,4.61981 
5.09003,8.11122 
5.24373,1.30066 
0.13517,1.83659 
7.57313,1.58150 
0
Output for the Sample Input
4
Hint
入力例のようにシールを貼った図です。円はシール、数字は入力例の行数を表しています。
点(2.3,4.6)では、入力例の 2 行目、3 行目、6 行目、10 行目の 4 枚のシールが重なっています。
6 と 9 のおのおのの中心の距離は 2.01293 なので、シールは重なっていません。1 と 12 のおのおのの中心の距離は 1.98231 なので、シールは重なっています。
２つの円が接しているとき（おのおのの中心の距離が 2 のとき）は、重なっているものとします。",Python,"import sys
from math import sqrt

def distance(p1, p2):
    return sqrt((p1[0] - p2[0])**2 + (p1[1] - p2[1])**2)

def circles_overlap(c1, c2):
    return distance(c1, c2) <= 2.0

def max_overlap(circles):
    if not circles:
        return 0
    
    n = len(circles)
    if n == 1:
        return 1
    
    max_count = 1
    
    # Check overlaps at each circle center
    for i in range(n):
        count = 0
        for j in range(n):
            if circles_overlap(circles[i], circles[j]):
                count += 1
        max_count = max(max_count, count)
    
    # Check intersection points of pairs of circles
    for i in range(n):
        for j in range(i + 1, n):
            if circles_overlap(circles[i], circles[j]):
                # Find intersection points
                x1, y1 = circles[i]
                x2, y2 = circles[j]
                
                d = distance(circles[i], circles[j])
                
                if d == 0:
                    continue
                
                if d <= 2.0:
                    # Calculate intersection points
                    a = d / 2.0
                    h = sqrt(1.0 - a * a) if a <= 1.0 else 0
                    
                    mx = (x1 + x2) / 2.0
                    my = (y1 + y2) / 2.0
                    
                    dx = (x2 - x1) / d
                    dy = (y2 - y1) / d
                    
                    # Two intersection points
                    points = []
                    if h > 0:
                        points.append((mx + h * dy, my - h * dx))
                        points.append((mx - h * dy, my + h * dx))
                    else:
                        points.append((mx, my))
                    
                    for point in points:
                        count = 0
                        for k in range(n):
                            if distance(point, circles[k]) <= 1.0 + 1e-9:
                                count += 1
                        max_count = max(max_count, count)
    
    return max_count

while True:
    n = int(input())
    if n == 0:
        break
    
    circles = []
    for _ in range(n):
        line = input().strip()
        x, y = map(float, line.split(','))
        circles.append((x, y))
    
    print(max_overlap(circles))
",0
p00090,"シールの重なり
1 辺の長さが 10 の正方形の折り紙に半径 1 の円形のシールを
n
枚貼ります。シールは重ねて貼ることができます。シールを貼る位置の座標を読み込んで、折り紙上でもっとも多くシールが重なっている場所(シールが１枚だけでも""重なっている""とする)でのシールの枚数を出力するプログラムを作成してください。
折り紙の左下を原点とした
x, y
座標を与えます。この
x, y
を円の中心としてシールを貼ることとします。円の中心が折り紙の外に出ることはありません。また、同一座標に複数のシールが貼られることはありません。
Input
複数のデータセットが与えられます。各データセットは以下のような形式で与えられます。
n
x
1
,
y
1
x
2
,
y
2
:
x
n
,
y
n
１行目にシールの枚数
n
(0 ≤ 100) が与えられます。続く
n
行に、各シールの中心座標が与えられます。
x
i
,
y
i
は
i
枚目のシールの中心の
x
座標と
y
座標を表します。各値は小数点以下最大 6 桁までの数字を含む実数で与えられます。
n
が 0 のとき、入力の最後とします。データセットの数は 50 を超えません。
Output
各データセットに対し、折り紙上で最も多くシールが重なっている場所でのシールの枚数（整数）を出力して下さい。
Sample Input
15
3.14979,8.51743 
2.39506,3.84915 
2.68432,5.39095 
5.61904,9.16332 
7.85653,4.75593 
2.84021,5.41511 
1.79500,8.59211 
7.55389,8.17604 
4.70665,4.66125 
1.63470,4.42538 
7.34959,4.61981 
5.09003,8.11122 
5.24373,1.30066 
0.13517,1.83659 
7.57313,1.58150 
0
Output for the Sample Input
4
Hint
入力例のようにシールを貼った図です。円はシール、数字は入力例の行数を表しています。
点(2.3,4.6)では、入力例の 2 行目、3 行目、6 行目、10 行目の 4 枚のシールが重なっています。
6 と 9 のおのおのの中心の距離は 2.01293 なので、シールは重なっていません。1 と 12 のおのおのの中心の距離は 1.98231 なので、シールは重なっています。
２つの円が接しているとき（おのおのの中心の距離が 2 のとき）は、重なっているものとします。",Python,"import math

def overlap(p1, p2, d):
    return (p1[0] - p2[0])**2 + (p1[1] - p2[1])**2 <= d

def intersection(o1,o2):
    a  = 2*(o2[0] - o1[0])
    b  = 2*(o2[1] - o1[1])
    c  = (o1[0] - o2[0])*(o1[0] + o2[0]) + (o1[1] - o2[1])*(o1[1] + o2[1])
    a2 = a**2 + b**2
    b2 = a*c + a*b*o1[1] - b**2*o1[0]
    c2 = b**2*(o1[0]**2 + o1[1]**2 - 1) + c**2 + 2*b*c*o1[1]
    x1 = (-b2 + math.sqrt(b2**2 - a2*c2))/a2
    x2 = (-b2 - math.sqrt(b2**2 - a2*c2))/a2
    if abs(b) < 10e-6:
        y1 = (o1[1] + o2[1])/2
        y2 = (o1[1] + o2[1])/2
    else:
        y1 = -(a*x1 + c)/b
        y2 = -(a*x2 + c)/b
    if abs(b2**2 - a2*c2) < 10e-6:
        return [x1, y1], [None, None]
    else:
        return [x1, y1], [x2, y2]

while True:
    n = int(input())
    if n == 0:
        break
    p = []
    for i in range(n):
        p.append(list(map(float, input().split("",""))))
    ans = 0
    for i in range(n - 1):
        for j in range(i + 1, n):
            if not overlap(p[i], p[j], 4):
                continue
            elif overlap(p[i], p[j], 10e-6):
                continue
            p1, p2 = intersection(p[i], p[j])
            cnt1 = 0
            cnt2 = 0
            for k in range(n):
                if overlap(p1, p[k], 1):
                    cnt1 += 1
                if p2[0] != None and overlap(p2, p[k], 1):
                    cnt2 += 1
            ans = max([ans, cnt1, cnt2])
    print(ans)

",1
p00092,"正方形探索
縦に
n
行、横に
n
列並べられた、合計
n × n
のマス目があります。いくつかのマス目には印がついています。各マス目の印の状態を読み込み、印のついていないマス目だけからなる最大の正方形の辺の長さを出力として表示するプログラムを作成してください。
たとえば各データセットで以下のようなデータが与えられます。
10
...*....**
..........
**....**..
........*.
..*.......
..........
.*........
..........
....*..***
.*....*...
入力データの一行が、一行のマス目を表現します。入力データの文字列のうち、.（ピリオド）は印のついていないマス目、*（アスタリスク）は印のついているマス目を示しています。
上記の例では、下図の 0 で示される正方形が最大となります。
...*....**
..........
**....**..
...00000*.
..*00000..
...00000..
.*.00000..
...00000..
....*..***
.*....*...
よって、5 と出力すれば正解になります。
なお、すべてのマス目に印がついている場合には、0 を出力してください。
Input
上記形式で複数のデータセットが与えられます。
n
が 0 のとき入力の最後とします。
n
は 1000 以下とします。入力データの文字列には、ピリオド、アスタリスク、改行以外の文字は含まれません。データセットの数は 50 を超えません。
Output
各データセットに対し、最大の正方形の辺の長さ（整数）を１行に出力して下さい。
Sample Input
10
...*....**
..........
**....**..
........*.
..*.......
..........
.*........
..........
....*..***
.*....*...
10
****.*****
*..*.*....
****.*....
*....*....
*....*****
..........
****.*****
*..*...*..
****...*..
*..*...*..
0
Output for the Sample Input
5
3",C,"#include <stdio.h>
#include <string.h>

int main() {
    int n;
    char grid[1001][1001];
    int dp[1001][1001];
    
    while(scanf(""%d"", &n) == 1 && n != 0) {
        // Read the grid
        for(int i = 0; i < n; i++) {
            scanf(""%s"", grid[i]);
        }
        
        // Initialize dp array
        for(int i = 0; i < n; i++) {
            for(int j = 0; j < n; j++) {
                dp[i][j] = 0;
            }
        }
        
        // Build dp array
        int maxSize = 0;
        for(int i = 0; i < n; i++) {
            for(int j = 0; j < n; j++) {
                if(grid[i][j] == '.') {
                    if(i == 0 || j == 0) {
                        dp[i][j] = 1;
                    } else {
                        int min = dp[i-1][j];
                        if(dp[i][j-1] < min) min = dp[i][j-1];
                        if(dp[i-1][j-1] < min) min = dp[i-1][j-1];
                        dp[i][j] = min + 1;
                    }
                    if(dp[i][j] > maxSize) {
                        maxSize = dp[i][j];
                    }
                }
            }
        }
        
        printf(""%d\n"", maxSize);
    }
    
    return 0;
}
",0
p00092,"正方形探索
縦に
n
行、横に
n
列並べられた、合計
n × n
のマス目があります。いくつかのマス目には印がついています。各マス目の印の状態を読み込み、印のついていないマス目だけからなる最大の正方形の辺の長さを出力として表示するプログラムを作成してください。
たとえば各データセットで以下のようなデータが与えられます。
10
...*....**
..........
**....**..
........*.
..*.......
..........
.*........
..........
....*..***
.*....*...
入力データの一行が、一行のマス目を表現します。入力データの文字列のうち、.（ピリオド）は印のついていないマス目、*（アスタリスク）は印のついているマス目を示しています。
上記の例では、下図の 0 で示される正方形が最大となります。
...*....**
..........
**....**..
...00000*.
..*00000..
...00000..
.*.00000..
...00000..
....*..***
.*....*...
よって、5 と出力すれば正解になります。
なお、すべてのマス目に印がついている場合には、0 を出力してください。
Input
上記形式で複数のデータセットが与えられます。
n
が 0 のとき入力の最後とします。
n
は 1000 以下とします。入力データの文字列には、ピリオド、アスタリスク、改行以外の文字は含まれません。データセットの数は 50 を超えません。
Output
各データセットに対し、最大の正方形の辺の長さ（整数）を１行に出力して下さい。
Sample Input
10
...*....**
..........
**....**..
........*.
..*.......
..........
.*........
..........
....*..***
.*....*...
10
****.*****
*..*.*....
****.*....
*....*....
*....*****
..........
****.*****
*..*...*..
****...*..
*..*...*..
0
Output for the Sample Input
5
3",C,"z[4000],*a=z,*b=z+2000,m,i,j,t,u;main(n){for(;scanf(""%d"",&n)*n++;m=!printf(""%d\n"",m))for(i=n;i--;j=a,a=b,b=j)for(j=n;j--;t>m?m=t:0)t=b[j]=n+~i&&getchar()>45?1+fmin(u=a[j],fmin(t,u)):0;}",1
p00092,"正方形探索
縦に
n
行、横に
n
列並べられた、合計
n × n
のマス目があります。いくつかのマス目には印がついています。各マス目の印の状態を読み込み、印のついていないマス目だけからなる最大の正方形の辺の長さを出力として表示するプログラムを作成してください。
たとえば各データセットで以下のようなデータが与えられます。
10
...*....**
..........
**....**..
........*.
..*.......
..........
.*........
..........
....*..***
.*....*...
入力データの一行が、一行のマス目を表現します。入力データの文字列のうち、.（ピリオド）は印のついていないマス目、*（アスタリスク）は印のついているマス目を示しています。
上記の例では、下図の 0 で示される正方形が最大となります。
...*....**
..........
**....**..
...00000*.
..*00000..
...00000..
.*.00000..
...00000..
....*..***
.*....*...
よって、5 と出力すれば正解になります。
なお、すべてのマス目に印がついている場合には、0 を出力してください。
Input
上記形式で複数のデータセットが与えられます。
n
が 0 のとき入力の最後とします。
n
は 1000 以下とします。入力データの文字列には、ピリオド、アスタリスク、改行以外の文字は含まれません。データセットの数は 50 を超えません。
Output
各データセットに対し、最大の正方形の辺の長さ（整数）を１行に出力して下さい。
Sample Input
10
...*....**
..........
**....**..
........*.
..*.......
..........
.*........
..........
....*..***
.*....*...
10
****.*****
*..*.*....
****.*....
*....*....
*....*****
..........
****.*****
*..*...*..
****...*..
*..*...*..
0
Output for the Sample Input
5
3",Java,"import java.util.*;

public class Main {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        
        while (true) {
            int n = sc.nextInt();
            if (n == 0) break;
            sc.nextLine();
            
            char[][] grid = new char[n][n];
            for (int i = 0; i < n; i++) {
                String line = sc.nextLine();
                for (int j = 0; j < n; j++) {
                    grid[i][j] = line.charAt(j);
                }
            }
            
            int[][] dp = new int[n][n];
            int maxSize = 0;
            
            for (int i = 0; i < n; i++) {
                for (int j = 0; j < n; j++) {
                    if (grid[i][j] == '.') {
                        if (i == 0 || j == 0) {
                            dp[i][j] = 1;
                        } else {
                            dp[i][j] = Math.min(Math.min(dp[i-1][j], dp[i][j-1]), dp[i-1][j-1]) + 1;
                        }
                        maxSize = Math.max(maxSize, dp[i][j]);
                    } else {
                        dp[i][j] = 0;
                    }
                }
            }
            
            System.out.println(maxSize);
        }
        
        sc.close();
    }
}
",0
p00092,"正方形探索
縦に
n
行、横に
n
列並べられた、合計
n × n
のマス目があります。いくつかのマス目には印がついています。各マス目の印の状態を読み込み、印のついていないマス目だけからなる最大の正方形の辺の長さを出力として表示するプログラムを作成してください。
たとえば各データセットで以下のようなデータが与えられます。
10
...*....**
..........
**....**..
........*.
..*.......
..........
.*........
..........
....*..***
.*....*...
入力データの一行が、一行のマス目を表現します。入力データの文字列のうち、.（ピリオド）は印のついていないマス目、*（アスタリスク）は印のついているマス目を示しています。
上記の例では、下図の 0 で示される正方形が最大となります。
...*....**
..........
**....**..
...00000*.
..*00000..
...00000..
.*.00000..
...00000..
....*..***
.*....*...
よって、5 と出力すれば正解になります。
なお、すべてのマス目に印がついている場合には、0 を出力してください。
Input
上記形式で複数のデータセットが与えられます。
n
が 0 のとき入力の最後とします。
n
は 1000 以下とします。入力データの文字列には、ピリオド、アスタリスク、改行以外の文字は含まれません。データセットの数は 50 を超えません。
Output
各データセットに対し、最大の正方形の辺の長さ（整数）を１行に出力して下さい。
Sample Input
10
...*....**
..........
**....**..
........*.
..*.......
..........
.*........
..........
....*..***
.*....*...
10
****.*****
*..*.*....
****.*....
*....*....
*....*****
..........
****.*****
*..*...*..
****...*..
*..*...*..
0
Output for the Sample Input
5
3",Java,"import java.io.*;

class Main {
	private static String check = ""."";

	public static void main(String args[]) {
		BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
		String buf;

		try {
			while (!(buf = br.readLine()).equals(""0"")) {
				int n = Integer.parseInt(buf);
				int mat[][] = new int[n][n];
				String str[] = new String[n];
				for (int i=0;i<n;i++) {
					str[i] = br.readLine();
					for (int j=0;j<n;j++) {
						if (str[i].charAt(j)=='.') mat[i][j] = 0;
						else if (str[i].charAt(j)=='*') mat[i][j] = 1;
					}
				}
				int max = 0;
				for (int i=0;i<n;i++) {
					if (str[i].indexOf(check)>=0) {
						for (int j=0;j<n;j++) {
							int d = Square(mat,i,j,n);
							if (max<d) {
								max = d;
								check = ""."";
								for (int k=0;k<max;k++) check = check+""."";
							}
						}
					}
				}
				System.out.println(max);
			}
		} catch (Exception e) {
			e.printStackTrace();
		}
	}

	public static int Square(int[][] m,int x,int y,int n) {
		int c = 0;
		boolean end = false;
		while (x+c<n&&y+c<n) {
			for (int i=y;i<=y+c;i++) {
				if (m[i][x+c]==1) {
					return c;
				}
			}
			for (int i=x+c;i>=x;i--) {
				if (m[y+c][i]==1) {
					return c;
				}
			}
			c++;
		}
		return c;
	}
}",1
p00092,"正方形探索
縦に
n
行、横に
n
列並べられた、合計
n × n
のマス目があります。いくつかのマス目には印がついています。各マス目の印の状態を読み込み、印のついていないマス目だけからなる最大の正方形の辺の長さを出力として表示するプログラムを作成してください。
たとえば各データセットで以下のようなデータが与えられます。
10
...*....**
..........
**....**..
........*.
..*.......
..........
.*........
..........
....*..***
.*....*...
入力データの一行が、一行のマス目を表現します。入力データの文字列のうち、.（ピリオド）は印のついていないマス目、*（アスタリスク）は印のついているマス目を示しています。
上記の例では、下図の 0 で示される正方形が最大となります。
...*....**
..........
**....**..
...00000*.
..*00000..
...00000..
.*.00000..
...00000..
....*..***
.*....*...
よって、5 と出力すれば正解になります。
なお、すべてのマス目に印がついている場合には、0 を出力してください。
Input
上記形式で複数のデータセットが与えられます。
n
が 0 のとき入力の最後とします。
n
は 1000 以下とします。入力データの文字列には、ピリオド、アスタリスク、改行以外の文字は含まれません。データセットの数は 50 を超えません。
Output
各データセットに対し、最大の正方形の辺の長さ（整数）を１行に出力して下さい。
Sample Input
10
...*....**
..........
**....**..
........*.
..*.......
..........
.*........
..........
....*..***
.*....*...
10
****.*****
*..*.*....
****.*....
*....*....
*....*****
..........
****.*****
*..*...*..
****...*..
*..*...*..
0
Output for the Sample Input
5
3",Python,"import sys

def max_square(n, grid):
    if n == 0:
        return 0
    
    # Create DP table
    dp = [[0] * n for _ in range(n)]
    max_side = 0
    
    # Initialize first row and column
    for i in range(n):
        if grid[i][0] == '.':
            dp[i][0] = 1
            max_side = 1
    
    for j in range(n):
        if grid[0][j] == '.':
            dp[0][j] = 1
            max_side = 1
    
    # Fill DP table
    for i in range(1, n):
        for j in range(1, n):
            if grid[i][j] == '.':
                dp[i][j] = min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1]) + 1
                max_side = max(max_side, dp[i][j])
    
    return max_side

while True:
    n = int(input())
    if n == 0:
        break
    
    grid = []
    for _ in range(n):
        grid.append(input().strip())
    
    result = max_square(n, grid)
    print(result)
",0
p00092,"正方形探索
縦に
n
行、横に
n
列並べられた、合計
n × n
のマス目があります。いくつかのマス目には印がついています。各マス目の印の状態を読み込み、印のついていないマス目だけからなる最大の正方形の辺の長さを出力として表示するプログラムを作成してください。
たとえば各データセットで以下のようなデータが与えられます。
10
...*....**
..........
**....**..
........*.
..*.......
..........
.*........
..........
....*..***
.*....*...
入力データの一行が、一行のマス目を表現します。入力データの文字列のうち、.（ピリオド）は印のついていないマス目、*（アスタリスク）は印のついているマス目を示しています。
上記の例では、下図の 0 で示される正方形が最大となります。
...*....**
..........
**....**..
...00000*.
..*00000..
...00000..
.*.00000..
...00000..
....*..***
.*....*...
よって、5 と出力すれば正解になります。
なお、すべてのマス目に印がついている場合には、0 を出力してください。
Input
上記形式で複数のデータセットが与えられます。
n
が 0 のとき入力の最後とします。
n
は 1000 以下とします。入力データの文字列には、ピリオド、アスタリスク、改行以外の文字は含まれません。データセットの数は 50 を超えません。
Output
各データセットに対し、最大の正方形の辺の長さ（整数）を１行に出力して下さい。
Sample Input
10
...*....**
..........
**....**..
........*.
..*.......
..........
.*........
..........
....*..***
.*....*...
10
****.*****
*..*.*....
****.*....
*....*....
*....*****
..........
****.*****
*..*...*..
****...*..
*..*...*..
0
Output for the Sample Input
5
3",Python,"while(1):
    n = int(input())
    if n == 0:
        break
    a = [0 for i in range(n)]
    b = [[0 for i in range(n)] for j in range(n)]
    c_ = [[2000 for i in range(n)] for j in range(n)]
    c = [[0 for i in range(n)] for j in range(n)]
    for i in range(n):
        a[i] = [0 if i == ""."" else 1 for i in list(input())]
        count = 0
        for j in range(n)[::-1]:
            if a[i][j] == 0:
                count += 1
                b[i][j] = count
            else:
                count = 0
                b[i][j] = count
                
    for col in range(n):
        for i in range(n):
            for j in range(i,n):
                if b[j][col] < c_[i][col]:
                    c_[i][col] = b[j][col]
                l = j-i+1
                if c_[i][col] < l:
                    break
                c[i][col] = l
    
    print(max([max(i) for i in c]))

",1
p00093,"うるう年
西暦
a
年から
b
年までの間にあるすべてのうるう年を出力するプログラムを作成してください。
うるう年の条件は、次のとおりとします。ただし、0 <
a
≤
b
< 3,000 とします。与えられた期間にうるう年がない場合には ""NA""と出力してください。
西暦年が 4 で割り切れる年であること。
ただし、100 で割り切れる年はうるう年としない。
しかし、400 で割り切れる年はうるう年である。
Input
複数のデータセットが与えられます。各データセットの形式は以下のとおりです：
a
b
a
,
b
がともに 0 のとき入力の終了とします。データセットの数は 50 を超えません。
Output
データセットごとに、西暦または NA を出力してください。
データセットの間に１つの空行を入れてください。
Sample Input
2001 2010
2005 2005
2001 2010
0 0
Output for the Sample Input
2004
2008

NA

2004
2008",C,"#include <stdio.h>

int isLeapYear(int year) {
    if (year % 400 == 0) return 1;
    if (year % 100 == 0) return 0;
    if (year % 4 == 0) return 1;
    return 0;
}

int main() {
    int a, b;
    int first = 1;
    
    while (1) {
        scanf(""%d %d"", &a, &b);
        if (a == 0 && b == 0) break;
        
        if (!first) {
            printf(""\n"");
        }
        first = 0;
        
        int found = 0;
        for (int year = a; year <= b; year++) {
            if (isLeapYear(year)) {
                printf(""%d\n"", year);
                found = 1;
            }
        }
        
        if (!found) {
            printf(""NA\n"");
        }
    }
    
    return 0;
}
",0
p00093,"うるう年
西暦
a
年から
b
年までの間にあるすべてのうるう年を出力するプログラムを作成してください。
うるう年の条件は、次のとおりとします。ただし、0 <
a
≤
b
< 3,000 とします。与えられた期間にうるう年がない場合には ""NA""と出力してください。
西暦年が 4 で割り切れる年であること。
ただし、100 で割り切れる年はうるう年としない。
しかし、400 で割り切れる年はうるう年である。
Input
複数のデータセットが与えられます。各データセットの形式は以下のとおりです：
a
b
a
,
b
がともに 0 のとき入力の終了とします。データセットの数は 50 を超えません。
Output
データセットごとに、西暦または NA を出力してください。
データセットの間に１つの空行を入れてください。
Sample Input
2001 2010
2005 2005
2001 2010
0 0
Output for the Sample Input
2004
2008

NA

2004
2008",C,"#include<stdio.h>
int main(void){
	int before,after;
	int i;
	int flag = 0;
	while(scanf(""%d %d"",&before,&after)){
		if(before == 0 && after == 0){
			break;
		}
		for(i = before;i <= after;i++){
			if(i % 4 == 0){
				if(i % 100 != 0){
					flag = 1;
					printf(""%d\n"",i);
				}
			}
			if(i % 4 == 0){
				if(i % 400 == 0){
					flag = 1;
					printf(""%d\n"",i);
				}
			}
		}
		if(flag == 0){
			printf(""NA\n"");
		}
		printf(""\n\n"");
		flag = 0;
	}
	return 0;
}",1
p00093,"うるう年
西暦
a
年から
b
年までの間にあるすべてのうるう年を出力するプログラムを作成してください。
うるう年の条件は、次のとおりとします。ただし、0 <
a
≤
b
< 3,000 とします。与えられた期間にうるう年がない場合には ""NA""と出力してください。
西暦年が 4 で割り切れる年であること。
ただし、100 で割り切れる年はうるう年としない。
しかし、400 で割り切れる年はうるう年である。
Input
複数のデータセットが与えられます。各データセットの形式は以下のとおりです：
a
b
a
,
b
がともに 0 のとき入力の終了とします。データセットの数は 50 を超えません。
Output
データセットごとに、西暦または NA を出力してください。
データセットの間に１つの空行を入れてください。
Sample Input
2001 2010
2005 2005
2001 2010
0 0
Output for the Sample Input
2004
2008

NA

2004
2008",Java,"import java.util.*;

public class Main {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        boolean first = true;
        
        while (true) {
            int a = sc.nextInt();
            int b = sc.nextInt();
            
            if (a == 0 && b == 0) {
                break;
            }
            
            if (!first) {
                System.out.println();
            }
            first = false;
            
            boolean found = false;
            for (int year = a; year <= b; year++) {
                if (isLeapYear(year)) {
                    System.out.println(year);
                    found = true;
                }
            }
            
            if (!found) {
                System.out.println(""NA"");
            }
        }
        
        sc.close();
    }
    
    private static boolean isLeapYear(int year) {
        if (year % 400 == 0) {
            return true;
        }
        if (year % 100 == 0) {
            return false;
        }
        if (year % 4 == 0) {
            return true;
        }
        return false;
    }
}
",0
p00093,"うるう年
西暦
a
年から
b
年までの間にあるすべてのうるう年を出力するプログラムを作成してください。
うるう年の条件は、次のとおりとします。ただし、0 <
a
≤
b
< 3,000 とします。与えられた期間にうるう年がない場合には ""NA""と出力してください。
西暦年が 4 で割り切れる年であること。
ただし、100 で割り切れる年はうるう年としない。
しかし、400 で割り切れる年はうるう年である。
Input
複数のデータセットが与えられます。各データセットの形式は以下のとおりです：
a
b
a
,
b
がともに 0 のとき入力の終了とします。データセットの数は 50 を超えません。
Output
データセットごとに、西暦または NA を出力してください。
データセットの間に１つの空行を入れてください。
Sample Input
2001 2010
2005 2005
2001 2010
0 0
Output for the Sample Input
2004
2008

NA

2004
2008",Java,"import java.io.IOException;
import java.io.BufferedReader;
import java.io.InputStreamReader;

class Main {
    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));

        String line;

        while (!(line = br.readLine()).equals(""0 0"")) {
            String[] input = line.split("" "");
            int a = Integer.parseInt(input[0]);
            int b = Integer.parseInt(input[1]);
            StringBuilder sb = new StringBuilder();

            boolean isNA = true;

            for (int now = a; now <= b; now++) {
                if (now % 4 == 0) {
                    if(now % 100 == 0){
                        if(now % 400 == 0){
                            sb.append(now).append(""\n"");
                            if (isNA)   isNA = false;
                        }
                    }else{
                        sb.append(now).append(""\n"");
                        if (isNA)   isNA = false;
                    }
                }
            }

            if (isNA) {
                sb.append(""NA"").append(""\n"");
            }

            System.out.println(sb);
        }

    }
}
",1
p00093,"うるう年
西暦
a
年から
b
年までの間にあるすべてのうるう年を出力するプログラムを作成してください。
うるう年の条件は、次のとおりとします。ただし、0 <
a
≤
b
< 3,000 とします。与えられた期間にうるう年がない場合には ""NA""と出力してください。
西暦年が 4 で割り切れる年であること。
ただし、100 で割り切れる年はうるう年としない。
しかし、400 で割り切れる年はうるう年である。
Input
複数のデータセットが与えられます。各データセットの形式は以下のとおりです：
a
b
a
,
b
がともに 0 のとき入力の終了とします。データセットの数は 50 を超えません。
Output
データセットごとに、西暦または NA を出力してください。
データセットの間に１つの空行を入れてください。
Sample Input
2001 2010
2005 2005
2001 2010
0 0
Output for the Sample Input
2004
2008

NA

2004
2008",Python,"def is_leap_year(year):
    if year % 400 == 0:
        return True
    if year % 100 == 0:
        return False
    if year % 4 == 0:
        return True
    return False

first_dataset = True

while True:
    a, b = map(int, input().split())
    if a == 0 and b == 0:
        break
    
    if not first_dataset:
        print()
    first_dataset = False
    
    leap_years = []
    for year in range(a, b + 1):
        if is_leap_year(year):
            leap_years.append(year)
    
    if leap_years:
        for year in leap_years:
            print(year)
    else:
        print(""NA"")
",0
p00093,"うるう年
西暦
a
年から
b
年までの間にあるすべてのうるう年を出力するプログラムを作成してください。
うるう年の条件は、次のとおりとします。ただし、0 <
a
≤
b
< 3,000 とします。与えられた期間にうるう年がない場合には ""NA""と出力してください。
西暦年が 4 で割り切れる年であること。
ただし、100 で割り切れる年はうるう年としない。
しかし、400 で割り切れる年はうるう年である。
Input
複数のデータセットが与えられます。各データセットの形式は以下のとおりです：
a
b
a
,
b
がともに 0 のとき入力の終了とします。データセットの数は 50 を超えません。
Output
データセットごとに、西暦または NA を出力してください。
データセットの間に１つの空行を入れてください。
Sample Input
2001 2010
2005 2005
2001 2010
0 0
Output for the Sample Input
2004
2008

NA

2004
2008",Python,"while True:
    a,b=map(int,raw_input().split("" ""))
    if a==0 and b==0:
        break
    uruu=[]
    for i in [year for year in range(b+1) if year >=a]:
        if i%4==0 and i%100!=0 or i%400==0:
            uruu.append(str(i))
    if len(uruu)!=0:
        print '\n'.join(uruu)
    else:
        print ""NA""
    print ''",1
p00094,"坪面積の計算
土地の面積を表現する「○○坪」という単位を聞いたことはないでしょうか？ 古来、１人の武士が１日に食べるお米を作る面積を言いました。
a
［m］×
b
［m］の土地があります。
a
と
b
を入力し、その土地の坪面積
S
［坪］を出力するプログラムを作成してください。 1 坪 = 3.305785 [m
2
] とし、
a
と
b
は 100 以下の整数とします。
入力
a
b
１つの空白で区切られた
a
と
b
が１行に与えられる。
出力
坪面積
S
を１行に出力する。0.0001 以下の誤差が許される。
入力例1
15 25
出力例1
113.437508",C,"#include <stdio.h>

int main() {
    int a, b;
    scanf(""%d %d"", &a, &b);
    
    double area_m2 = a * b;
    double area_tsubo = area_m2 / 3.305785;
    
    printf(""%.6f\n"", area_tsubo);
    
    return 0;
}
",0
p00094,"坪面積の計算
土地の面積を表現する「○○坪」という単位を聞いたことはないでしょうか？ 古来、１人の武士が１日に食べるお米を作る面積を言いました。
a
［m］×
b
［m］の土地があります。
a
と
b
を入力し、その土地の坪面積
S
［坪］を出力するプログラムを作成してください。 1 坪 = 3.305785 [m
2
] とし、
a
と
b
は 100 以下の整数とします。
入力
a
b
１つの空白で区切られた
a
と
b
が１行に与えられる。
出力
坪面積
S
を１行に出力する。0.0001 以下の誤差が許される。
入力例1
15 25
出力例1
113.437508",C,"int main(){double a,b;scanf(""%lf%lf"",&a,&b);printf(""%.8f\n"",a*b*0.3025);return 0;}",1
p00094,"坪面積の計算
土地の面積を表現する「○○坪」という単位を聞いたことはないでしょうか？ 古来、１人の武士が１日に食べるお米を作る面積を言いました。
a
［m］×
b
［m］の土地があります。
a
と
b
を入力し、その土地の坪面積
S
［坪］を出力するプログラムを作成してください。 1 坪 = 3.305785 [m
2
] とし、
a
と
b
は 100 以下の整数とします。
入力
a
b
１つの空白で区切られた
a
と
b
が１行に与えられる。
出力
坪面積
S
を１行に出力する。0.0001 以下の誤差が許される。
入力例1
15 25
出力例1
113.437508",Java,"import java.util.Scanner;

public class Main {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int a = sc.nextInt();
        int b = sc.nextInt();
        
        double area = a * b;
        double tsubo = area / 3.305785;
        
        System.out.println(tsubo);
        
        sc.close();
    }
}
",0
p00094,"坪面積の計算
土地の面積を表現する「○○坪」という単位を聞いたことはないでしょうか？ 古来、１人の武士が１日に食べるお米を作る面積を言いました。
a
［m］×
b
［m］の土地があります。
a
と
b
を入力し、その土地の坪面積
S
［坪］を出力するプログラムを作成してください。 1 坪 = 3.305785 [m
2
] とし、
a
と
b
は 100 以下の整数とします。
入力
a
b
１つの空白で区切られた
a
と
b
が１行に与えられる。
出力
坪面積
S
を１行に出力する。0.0001 以下の誤差が許される。
入力例1
15 25
出力例1
113.437508",Java,"import java.util.Scanner;

public class Main 
{
	public static void main(String[] args)
	{
		String[] input = new Scanner(System.in).nextLine().split("" "");
		
		float a = Float.parseFloat(input[0]);
		float b = Float.parseFloat(input[1]);
		
		System.out.printf(""%1$.6f\n"", a*b/3.305785);
	}
}",1
p00094,"坪面積の計算
土地の面積を表現する「○○坪」という単位を聞いたことはないでしょうか？ 古来、１人の武士が１日に食べるお米を作る面積を言いました。
a
［m］×
b
［m］の土地があります。
a
と
b
を入力し、その土地の坪面積
S
［坪］を出力するプログラムを作成してください。 1 坪 = 3.305785 [m
2
] とし、
a
と
b
は 100 以下の整数とします。
入力
a
b
１つの空白で区切られた
a
と
b
が１行に与えられる。
出力
坪面積
S
を１行に出力する。0.0001 以下の誤差が許される。
入力例1
15 25
出力例1
113.437508",Python,"a, b = map(int, input().split())
area_m2 = a * b
tsubo = area_m2 / 3.305785
print(tsubo)
",0
p00094,"坪面積の計算
土地の面積を表現する「○○坪」という単位を聞いたことはないでしょうか？ 古来、１人の武士が１日に食べるお米を作る面積を言いました。
a
［m］×
b
［m］の土地があります。
a
と
b
を入力し、その土地の坪面積
S
［坪］を出力するプログラムを作成してください。 1 坪 = 3.305785 [m
2
] とし、
a
と
b
は 100 以下の整数とします。
入力
a
b
１つの空白で区切られた
a
と
b
が１行に与えられる。
出力
坪面積
S
を１行に出力する。0.0001 以下の誤差が許される。
入力例1
15 25
出力例1
113.437508",Python,"a, b = map(int, input().split())
print(a * b / 3.305785)",1
p00095,"ワカサギ釣り大会
桧原湖でワカサギ釣り大会が行われました。一番多くのワカサギを獲得した人が優勝者です。
参加者番号と釣った匹数のリストを読み込み、優勝者の番号と釣った匹数を出力するプログラムを作成してください。優勝者が複数いる場合は、
その中で参加者番号が最も小さい一人を出力してください。
入力
入力は以下の形式で与えられる。
n
a
1
v
1
a
2
v
2
:
a
n
v
n
n
(1 ≤
n
≤ 20) は参加者の数、
a
i
は参加者番号を表す。参加者番号は 1 以上
n
以下の異なる整数である。
v
i
( 0 ≤
v
i
≤ 100) は参加者
a
i
が獲得した匹数である。
出力
優勝者の参加者番号と釣った匹数を空白区切りで１行に出力せよ。
入力例
6
1 14
2 25
3 42
4 11
5 40
6 37
出力例
3 42",C,"#include <stdio.h>

int main() {
    int n;
    scanf(""%d"", &n);
    
    int max_count = -1;
    int winner_id = 100000;
    
    for (int i = 0; i < n; i++) {
        int a, v;
        scanf(""%d %d"", &a, &v);
        
        if (v > max_count || (v == max_count && a < winner_id)) {
            max_count = v;
            winner_id = a;
        }
    }
    
    printf(""%d %d\n"", winner_id, max_count);
    
    return 0;
}
",0
p00095,"ワカサギ釣り大会
桧原湖でワカサギ釣り大会が行われました。一番多くのワカサギを獲得した人が優勝者です。
参加者番号と釣った匹数のリストを読み込み、優勝者の番号と釣った匹数を出力するプログラムを作成してください。優勝者が複数いる場合は、
その中で参加者番号が最も小さい一人を出力してください。
入力
入力は以下の形式で与えられる。
n
a
1
v
1
a
2
v
2
:
a
n
v
n
n
(1 ≤
n
≤ 20) は参加者の数、
a
i
は参加者番号を表す。参加者番号は 1 以上
n
以下の異なる整数である。
v
i
( 0 ≤
v
i
≤ 100) は参加者
a
i
が獲得した匹数である。
出力
優勝者の参加者番号と釣った匹数を空白区切りで１行に出力せよ。
入力例
6
1 14
2 25
3 42
4 11
5 40
6 37
出力例
3 42",C,"#include <stdio.h>
#include <stdlib.h>

int
main (
  int   argc,
  char *argv[ ]
  )
{
  int wo, ws, n;
  int i;

  scanf ( ""%d%d%d"", &n, &wo, &ws );
  for ( i = 1; i < n; ++i )
  {
    int o, s;

    scanf ( ""%d%d"", &o, &s );
    if ( s > ws
      || ( s == ws && o < wo ) )
    {
      wo = o;
      ws = s;
    }
  }

  printf ( ""%d %d\n"", wo, ws );

  return ( EXIT_SUCCESS );
}",1
p00095,"ワカサギ釣り大会
桧原湖でワカサギ釣り大会が行われました。一番多くのワカサギを獲得した人が優勝者です。
参加者番号と釣った匹数のリストを読み込み、優勝者の番号と釣った匹数を出力するプログラムを作成してください。優勝者が複数いる場合は、
その中で参加者番号が最も小さい一人を出力してください。
入力
入力は以下の形式で与えられる。
n
a
1
v
1
a
2
v
2
:
a
n
v
n
n
(1 ≤
n
≤ 20) は参加者の数、
a
i
は参加者番号を表す。参加者番号は 1 以上
n
以下の異なる整数である。
v
i
( 0 ≤
v
i
≤ 100) は参加者
a
i
が獲得した匹数である。
出力
優勝者の参加者番号と釣った匹数を空白区切りで１行に出力せよ。
入力例
6
1 14
2 25
3 42
4 11
5 40
6 37
出力例
3 42",Java,"import java.util.Scanner;

public class Main {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        
        int n = sc.nextInt();
        int winnerNumber = 0;
        int maxCount = -1;
        
        for (int i = 0; i < n; i++) {
            int participantNumber = sc.nextInt();
            int count = sc.nextInt();
            
            if (count > maxCount || (count == maxCount && participantNumber < winnerNumber)) {
                maxCount = count;
                winnerNumber = participantNumber;
            }
        }
        
        System.out.println(winnerNumber + "" "" + maxCount);
        
        sc.close();
    }
}
",0
p00095,"ワカサギ釣り大会
桧原湖でワカサギ釣り大会が行われました。一番多くのワカサギを獲得した人が優勝者です。
参加者番号と釣った匹数のリストを読み込み、優勝者の番号と釣った匹数を出力するプログラムを作成してください。優勝者が複数いる場合は、
その中で参加者番号が最も小さい一人を出力してください。
入力
入力は以下の形式で与えられる。
n
a
1
v
1
a
2
v
2
:
a
n
v
n
n
(1 ≤
n
≤ 20) は参加者の数、
a
i
は参加者番号を表す。参加者番号は 1 以上
n
以下の異なる整数である。
v
i
( 0 ≤
v
i
≤ 100) は参加者
a
i
が獲得した匹数である。
出力
優勝者の参加者番号と釣った匹数を空白区切りで１行に出力せよ。
入力例
6
1 14
2 25
3 42
4 11
5 40
6 37
出力例
3 42",Java,"import java.util.Scanner;

class Main{
	public static void main(String[] args){
		Scanner sc = new Scanner(System.in);
		
		int n = sc.nextInt(),x = 0,y,max = 0;
		
		for(int i = 0; i < n; i++){
			x = Math.max(x, (y = sc.nextInt()));
			if(y == x)max = i + 1;
		}
		System.out.println(max + "" "" + x);
		
		sc.close();
		}
}",1
p00095,"ワカサギ釣り大会
桧原湖でワカサギ釣り大会が行われました。一番多くのワカサギを獲得した人が優勝者です。
参加者番号と釣った匹数のリストを読み込み、優勝者の番号と釣った匹数を出力するプログラムを作成してください。優勝者が複数いる場合は、
その中で参加者番号が最も小さい一人を出力してください。
入力
入力は以下の形式で与えられる。
n
a
1
v
1
a
2
v
2
:
a
n
v
n
n
(1 ≤
n
≤ 20) は参加者の数、
a
i
は参加者番号を表す。参加者番号は 1 以上
n
以下の異なる整数である。
v
i
( 0 ≤
v
i
≤ 100) は参加者
a
i
が獲得した匹数である。
出力
優勝者の参加者番号と釣った匹数を空白区切りで１行に出力せよ。
入力例
6
1 14
2 25
3 42
4 11
5 40
6 37
出力例
3 42",Python,"n = int(input())
max_count = -1
winner_id = float('inf')

for _ in range(n):
    a, v = map(int, input().split())
    if v > max_count or (v == max_count and a < winner_id):
        max_count = v
        winner_id = a

print(winner_id, max_count)
",0
p00095,"ワカサギ釣り大会
桧原湖でワカサギ釣り大会が行われました。一番多くのワカサギを獲得した人が優勝者です。
参加者番号と釣った匹数のリストを読み込み、優勝者の番号と釣った匹数を出力するプログラムを作成してください。優勝者が複数いる場合は、
その中で参加者番号が最も小さい一人を出力してください。
入力
入力は以下の形式で与えられる。
n
a
1
v
1
a
2
v
2
:
a
n
v
n
n
(1 ≤
n
≤ 20) は参加者の数、
a
i
は参加者番号を表す。参加者番号は 1 以上
n
以下の異なる整数である。
v
i
( 0 ≤
v
i
≤ 100) は参加者
a
i
が獲得した匹数である。
出力
優勝者の参加者番号と釣った匹数を空白区切りで１行に出力せよ。
入力例
6
1 14
2 25
3 42
4 11
5 40
6 37
出力例
3 42",Python,"n=input()
x=[0]*(n+1)
for i in range(n):
  a,v=map(int, raw_input().split())
  x[a]=v
m=max(x)
print x.index(m), m",1
p00096,"４つの整数の和 II
4,000 以下の正の整数
n
を入力し、0 〜 1000 の範囲の整数
a, b, c, d
の組で
a + b + c + d = n
を満たすものの組み合わせ数を出力するプログラムを作成して下さい。
Input
複数のデータセットが与えられます。各データセットに
n
が１行に与えられます。入力の最後まで処理して下さい。
データセットの数は 50 を超えません。
Output
各データセットごとに、
a, b, c, d
の組み合わせの個数を１行に出力して下さい。
Sample Input
2
3
35
Output for the Sample Input
10
20
8436",C,"#include <stdio.h>

int main() {
    int n;
    while (scanf(""%d"", &n) != EOF) {
        long long count = 0;
        for (int a = 0; a <= 1000 && a <= n; a++) {
            for (int b = 0; b <= 1000 && a + b <= n; b++) {
                for (int c = 0; c <= 1000 && a + b + c <= n; c++) {
                    int d = n - a - b - c;
                    if (d >= 0 && d <= 1000) {
                        count++;
                    }
                }
            }
        }
        printf(""%lld\n"", count);
    }
    return 0;
}
",0
p00096,"４つの整数の和 II
4,000 以下の正の整数
n
を入力し、0 〜 1000 の範囲の整数
a, b, c, d
の組で
a + b + c + d = n
を満たすものの組み合わせ数を出力するプログラムを作成して下さい。
Input
複数のデータセットが与えられます。各データセットに
n
が１行に与えられます。入力の最後まで処理して下さい。
データセットの数は 50 を超えません。
Output
各データセットごとに、
a, b, c, d
の組み合わせの個数を１行に出力して下さい。
Sample Input
2
3
35
Output for the Sample Input
10
20
8436",C,"#include <stdio.h>

int main(void)
{
	int n;
	int i, j, k, l;
	int c;
	
	while (scanf(""%d"", &n) != EOF){
		c = 0;
		for (i = 0; i <= 1000; i++){
			for (j = 0; j <= 1000; j++){
				for (k = 0; k <= 1000; k++){
					for (l = 0; l <= 1000; l++){
						if (i + j + k + l == n){
							c++;
						}
					}
				}
			}
		}
		printf(""%d\n"", c);
	}
	
	return (0);
}",1
p00096,"４つの整数の和 II
4,000 以下の正の整数
n
を入力し、0 〜 1000 の範囲の整数
a, b, c, d
の組で
a + b + c + d = n
を満たすものの組み合わせ数を出力するプログラムを作成して下さい。
Input
複数のデータセットが与えられます。各データセットに
n
が１行に与えられます。入力の最後まで処理して下さい。
データセットの数は 50 を超えません。
Output
各データセットごとに、
a, b, c, d
の組み合わせの個数を１行に出力して下さい。
Sample Input
2
3
35
Output for the Sample Input
10
20
8436",Java,"import java.util.*;

public class Main {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        
        // Precompute all possible sums for two numbers (a+b and c+d)
        Map<Integer, Integer> sumCount = new HashMap<>();
        for (int i = 0; i <= 1000; i++) {
            for (int j = 0; j <= 1000; j++) {
                int sum = i + j;
                sumCount.put(sum, sumCount.getOrDefault(sum, 0) + 1);
            }
        }
        
        while (sc.hasNextInt()) {
            int n = sc.nextInt();
            long count = 0;
            
            // For each possible sum of a+b, check if n-(a+b) exists as c+d
            for (Map.Entry<Integer, Integer> entry : sumCount.entrySet()) {
                int sum1 = entry.getKey();
                int count1 = entry.getValue();
                int sum2 = n - sum1;
                
                if (sumCount.containsKey(sum2)) {
                    count += (long) count1 * sumCount.get(sum2);
                }
            }
            
            System.out.println(count);
        }
        
        sc.close();
    }
}
",0
p00096,"４つの整数の和 II
4,000 以下の正の整数
n
を入力し、0 〜 1000 の範囲の整数
a, b, c, d
の組で
a + b + c + d = n
を満たすものの組み合わせ数を出力するプログラムを作成して下さい。
Input
複数のデータセットが与えられます。各データセットに
n
が１行に与えられます。入力の最後まで処理して下さい。
データセットの数は 50 を超えません。
Output
各データセットごとに、
a, b, c, d
の組み合わせの個数を１行に出力して下さい。
Sample Input
2
3
35
Output for the Sample Input
10
20
8436",Java,"import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;

import static java.lang.Integer.parseInt;

/**
 * Sum of 4 Integers II
 */
public class Main {

	public static void main(String[] args) throws IOException {
		BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
		String line;

		int[][] dp = new int[5][4001];

		for (int i = 1; i <= 4; i++) {
			for (int j = 0; j <= 1000; j++) {
				dp[i][i * j] = 1;
			}
		}
		for (int i = 1; i <= 4; i++) {
			dp[i][0] = 1;
		}

		for (int i = 2; i <= 4; i++) {
			for (int j = 1; j <= 1000; j++) {
				dp[i][j] = dp[i - 1][j] + dp[i][j - 1];
			}
		}

		while ((line = br.readLine()) != null && !line.isEmpty()) {
			System.out.println(dp[4][parseInt(line)]);
		} // end while
	} // end main
}",1
p00096,"４つの整数の和 II
4,000 以下の正の整数
n
を入力し、0 〜 1000 の範囲の整数
a, b, c, d
の組で
a + b + c + d = n
を満たすものの組み合わせ数を出力するプログラムを作成して下さい。
Input
複数のデータセットが与えられます。各データセットに
n
が１行に与えられます。入力の最後まで処理して下さい。
データセットの数は 50 を超えません。
Output
各データセットごとに、
a, b, c, d
の組み合わせの個数を１行に出力して下さい。
Sample Input
2
3
35
Output for the Sample Input
10
20
8436",Python,"import sys
from collections import defaultdict

def count_combinations(n):
    # Count all possible sums of two numbers (a+b)
    sum_count = defaultdict(int)
    
    # Calculate all possible sums a+b where 0 <= a, b <= 1000
    for a in range(min(n+1, 1001)):
        for b in range(min(n+1, 1001)):
            if a + b <= n:
                sum_count[a + b] += 1
    
    # For each sum of c+d, find how many a+b sums match to make n
    result = 0
    for c in range(min(n+1, 1001)):
        for d in range(min(n+1, 1001)):
            if c + d <= n:
                needed = n - (c + d)
                if needed in sum_count:
                    result += sum_count[needed]
    
    return result

for line in sys.stdin:
    n = int(line.strip())
    print(count_combinations(n))
",0
p00096,"４つの整数の和 II
4,000 以下の正の整数
n
を入力し、0 〜 1000 の範囲の整数
a, b, c, d
の組で
a + b + c + d = n
を満たすものの組み合わせ数を出力するプログラムを作成して下さい。
Input
複数のデータセットが与えられます。各データセットに
n
が１行に与えられます。入力の最後まで処理して下さい。
データセットの数は 50 を超えません。
Output
各データセットごとに、
a, b, c, d
の組み合わせの個数を１行に出力して下さい。
Sample Input
2
3
35
Output for the Sample Input
10
20
8436",Python,"while 1:
    try:
        n = input(); p = min(2000, n);
        print (p+1)*(p+2)*(3*n-2*p+3)/6
    except EOFError:
        break",1
p00098,"Maximum Sum Sequence II
与えられた整数の行列
a
1,1
a
1,2
...
a
1,n
a
2,1
a
2,2
...
a
2,n
:
a
n,1
a
n,2
...
a
n, n
で、縦・横方向に１つ以上連続した項（部分行列）の和の最大値を出力して終了するプログラムを作成して下さい。
Input
入力データは以下の形式で与えられます。
n
a
1,1
a
1,2
...
a
1,n
a
2,1
a
2,2
...
a
2,n
:
a
n,1
a
n,2
...
a
n, n
n
は 1 以上 100 以下、
a
i,j
は -10000 以上 10000 以下です。
Output
最大値を 1 行に出力して下さい。
Sample Input 1
3
1 -2 3
-4 5 6
7 8 -9
Output for the Sample Input 1
16
この入力の場合、以下の部分行列の項の和が最大となります。
-4 5
7 8
Sample Input 2
4
1 3 -9 2
2 7 -1 5
-8 3 2 -1
5 0 -3 1
Output for the Sample Input 2
15
この入力の場合、以下の部分行列の項の和が最大となります。
7 -1 5
3 2 -1",C,"#include <stdio.h>

int main() {
    int n;
    scanf(""%d"", &n);
    
    int a[100][100];
    for (int i = 0; i < n; i++) {
        for (int j = 0; j < n; j++) {
            scanf(""%d"", &a[i][j]);
        }
    }
    
    int max_sum = a[0][0];
    
    for (int top = 0; top < n; top++) {
        int col_sum[100] = {0};
        
        for (int bottom = top; bottom < n; bottom++) {
            for (int j = 0; j < n; j++) {
                col_sum[j] += a[bottom][j];
            }
            
            int current_sum = 0;
            for (int j = 0; j < n; j++) {
                current_sum += col_sum[j];
                if (current_sum > max_sum) {
                    max_sum = current_sum;
                }
                if (current_sum < 0) {
                    current_sum = 0;
                }
            }
        }
    }
    
    printf(""%d\n"", max_sum);
    
    return 0;
}
",0
p00098,"Maximum Sum Sequence II
与えられた整数の行列
a
1,1
a
1,2
...
a
1,n
a
2,1
a
2,2
...
a
2,n
:
a
n,1
a
n,2
...
a
n, n
で、縦・横方向に１つ以上連続した項（部分行列）の和の最大値を出力して終了するプログラムを作成して下さい。
Input
入力データは以下の形式で与えられます。
n
a
1,1
a
1,2
...
a
1,n
a
2,1
a
2,2
...
a
2,n
:
a
n,1
a
n,2
...
a
n, n
n
は 1 以上 100 以下、
a
i,j
は -10000 以上 10000 以下です。
Output
最大値を 1 行に出力して下さい。
Sample Input 1
3
1 -2 3
-4 5 6
7 8 -9
Output for the Sample Input 1
16
この入力の場合、以下の部分行列の項の和が最大となります。
-4 5
7 8
Sample Input 2
4
1 3 -9 2
2 7 -1 5
-8 3 2 -1
5 0 -3 1
Output for the Sample Input 2
15
この入力の場合、以下の部分行列の項の和が最大となります。
7 -1 5
3 2 -1",C,"// AOJ 0098: Maximum Sum Sequence II 
// 2017.8.15 bal4u@uu
// 2017.11.1 retry

#include <stdio.h>

int a[102][102];
int s[102][102];

char buf[1000], *p;
int getint()
{
	int n = 0;
	while (*p >= '0') n = (n<<3) + (n<<1) + (*p++ & 0xf);
	return n;
}

int main()
{
	int n, r, c, k, ans;

	fgets(p=buf, 10, stdin), n = getint();
	for (r = 0; r < n; r++) {
		fgets(p=buf, sizeof(buf), stdin);
		for (c = 0; c < n; c++, p++) {
			if (*p == '-') p++, a[r][c] = -getint();
			else                a[r][c] =  getint();
		}
	}

	for (r = 0; r < n; r++)
		for (c = 0; c < n; c++)
			s[r][c+1] += s[r][c] + a[r][c];

	ans = s[0][1];
	for (c = 0; c < n; c++) for (k = c+1; k <= n; k++) {
		int t = 0;
		for (r = 0; r < n; r++) {
			if (t < 0) t  = s[r][k] - s[r][c];
			else       t += s[r][k] - s[r][c];
			if (t > ans) ans = t;
		}
	}
	printf(""%d\n"", ans);
	return 0;
}",1
p00098,"Maximum Sum Sequence II
与えられた整数の行列
a
1,1
a
1,2
...
a
1,n
a
2,1
a
2,2
...
a
2,n
:
a
n,1
a
n,2
...
a
n, n
で、縦・横方向に１つ以上連続した項（部分行列）の和の最大値を出力して終了するプログラムを作成して下さい。
Input
入力データは以下の形式で与えられます。
n
a
1,1
a
1,2
...
a
1,n
a
2,1
a
2,2
...
a
2,n
:
a
n,1
a
n,2
...
a
n, n
n
は 1 以上 100 以下、
a
i,j
は -10000 以上 10000 以下です。
Output
最大値を 1 行に出力して下さい。
Sample Input 1
3
1 -2 3
-4 5 6
7 8 -9
Output for the Sample Input 1
16
この入力の場合、以下の部分行列の項の和が最大となります。
-4 5
7 8
Sample Input 2
4
1 3 -9 2
2 7 -1 5
-8 3 2 -1
5 0 -3 1
Output for the Sample Input 2
15
この入力の場合、以下の部分行列の項の和が最大となります。
7 -1 5
3 2 -1",Java,"import java.util.*;

public class Main {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int n = sc.nextInt();
        int[][] a = new int[n][n];
        
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < n; j++) {
                a[i][j] = sc.nextInt();
            }
        }
        
        long maxSum = Long.MIN_VALUE;
        
        for (int top = 0; top < n; top++) {
            int[] colSum = new int[n];
            
            for (int bottom = top; bottom < n; bottom++) {
                for (int col = 0; col < n; col++) {
                    colSum[col] += a[bottom][col];
                }
                
                long currentSum = 0;
                long maxEndingHere = Long.MIN_VALUE;
                
                for (int col = 0; col < n; col++) {
                    currentSum += colSum[col];
                    maxEndingHere = Math.max(maxEndingHere, currentSum);
                    if (currentSum < 0) {
                        currentSum = 0;
                    }
                }
                
                maxSum = Math.max(maxSum, maxEndingHere);
            }
        }
        
        System.out.println(maxSum);
        sc.close();
    }
}
",0
p00098,"Maximum Sum Sequence II
与えられた整数の行列
a
1,1
a
1,2
...
a
1,n
a
2,1
a
2,2
...
a
2,n
:
a
n,1
a
n,2
...
a
n, n
で、縦・横方向に１つ以上連続した項（部分行列）の和の最大値を出力して終了するプログラムを作成して下さい。
Input
入力データは以下の形式で与えられます。
n
a
1,1
a
1,2
...
a
1,n
a
2,1
a
2,2
...
a
2,n
:
a
n,1
a
n,2
...
a
n, n
n
は 1 以上 100 以下、
a
i,j
は -10000 以上 10000 以下です。
Output
最大値を 1 行に出力して下さい。
Sample Input 1
3
1 -2 3
-4 5 6
7 8 -9
Output for the Sample Input 1
16
この入力の場合、以下の部分行列の項の和が最大となります。
-4 5
7 8
Sample Input 2
4
1 3 -9 2
2 7 -1 5
-8 3 2 -1
5 0 -3 1
Output for the Sample Input 2
15
この入力の場合、以下の部分行列の項の和が最大となります。
7 -1 5
3 2 -1",Java,"public class
Main
{
  public void
  run (
    final java.util.Scanner sc,
    final java.io.PrintStream out
    )
  {
    int[ ][ ] a;
    int N;
    int i, j, k, l;
    int res;

    N = sc.nextInt ( );
    a = new int[ N ][ N + 1 ];
    for ( i = 0; i < N; ++i )
    for ( j = 1; j <= N ; ++j )
      a[ i ][ j ] = sc.nextInt ( );

    for ( i = 0; i < N; ++i )
    for ( j = 1; j <= N; ++j )
      a[ i ][ j ] += a[ i ][ j - 1 ];

    res = a[ 0 ][ 1 ];
    for ( i = 0; i < N; ++i )
    for ( j = i + 1; j <= N; ++j )
    {
      for ( k = 0; k < N; ++k )
      {
        int t = 0;

        for ( l = k; l < N; ++l )
        {
          t += a[ l ][ j ] - a[ l ][ i ];
          res = Math.max ( res, t );
        }
      }
    }

    out.println ( res );
  }

  public static void
  main (
    String[ ] args
    )
  {
    ( new Main ( ) ).run ( new java.util.Scanner ( System.in ), System.out );
  }
}",1
p00098,"Maximum Sum Sequence II
与えられた整数の行列
a
1,1
a
1,2
...
a
1,n
a
2,1
a
2,2
...
a
2,n
:
a
n,1
a
n,2
...
a
n, n
で、縦・横方向に１つ以上連続した項（部分行列）の和の最大値を出力して終了するプログラムを作成して下さい。
Input
入力データは以下の形式で与えられます。
n
a
1,1
a
1,2
...
a
1,n
a
2,1
a
2,2
...
a
2,n
:
a
n,1
a
n,2
...
a
n, n
n
は 1 以上 100 以下、
a
i,j
は -10000 以上 10000 以下です。
Output
最大値を 1 行に出力して下さい。
Sample Input 1
3
1 -2 3
-4 5 6
7 8 -9
Output for the Sample Input 1
16
この入力の場合、以下の部分行列の項の和が最大となります。
-4 5
7 8
Sample Input 2
4
1 3 -9 2
2 7 -1 5
-8 3 2 -1
5 0 -3 1
Output for the Sample Input 2
15
この入力の場合、以下の部分行列の項の和が最大となります。
7 -1 5
3 2 -1",Python,"def max_subarray_sum(arr):
    if not arr:
        return 0
    max_sum = float('-inf')
    current_sum = 0
    for num in arr:
        current_sum = max(num, current_sum + num)
        max_sum = max(max_sum, current_sum)
    return max_sum

n = int(input())
matrix = []
for _ in range(n):
    row = list(map(int, input().split()))
    matrix.append(row)

max_sum = float('-inf')

for top in range(n):
    temp = [0] * n
    for bottom in range(top, n):
        for col in range(n):
            temp[col] += matrix[bottom][col]
        current_max = max_subarray_sum(temp)
        max_sum = max(max_sum, current_max)

print(max_sum)
",0
p00098,"Maximum Sum Sequence II
与えられた整数の行列
a
1,1
a
1,2
...
a
1,n
a
2,1
a
2,2
...
a
2,n
:
a
n,1
a
n,2
...
a
n, n
で、縦・横方向に１つ以上連続した項（部分行列）の和の最大値を出力して終了するプログラムを作成して下さい。
Input
入力データは以下の形式で与えられます。
n
a
1,1
a
1,2
...
a
1,n
a
2,1
a
2,2
...
a
2,n
:
a
n,1
a
n,2
...
a
n, n
n
は 1 以上 100 以下、
a
i,j
は -10000 以上 10000 以下です。
Output
最大値を 1 行に出力して下さい。
Sample Input 1
3
1 -2 3
-4 5 6
7 8 -9
Output for the Sample Input 1
16
この入力の場合、以下の部分行列の項の和が最大となります。
-4 5
7 8
Sample Input 2
4
1 3 -9 2
2 7 -1 5
-8 3 2 -1
5 0 -3 1
Output for the Sample Input 2
15
この入力の場合、以下の部分行列の項の和が最大となります。
7 -1 5
3 2 -1",Python,"# -*- coding: utf-8 -*-
""""""
http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=0098

""""""
import sys
from sys import stdin
input = stdin.readline


def calc_points(n, array):
    # 右下から(x, y)までの長方形に含まれる値の和
    dp = [[0] * (n + 1) for _ in range(n + 1)]
    for y in range(n - 1, -1, -1):
        for x in range(n - 1, -1, -1):
            dp[y][x] = dp[y+1][x] + dp[y][x+1] - dp[y+1][x+1] + array[y][x]
    return dp


def solve(n, array):
    ans = []
    dp = calc_points(n, array)

    for sy in range(n + 1):
        for sx in range(n + 1):
            for ey in range(sy, n + 1):
                for ex in range(sx, n + 1):
                    s1 = dp[sy][sx] #  右下から始点まで
                    s2 = dp[sy][ex] #  重なり部分
                    s3 = dp[ey][sx] #  重なり部分
                    s4 = dp[ey][ex] #  重なりの重なり部分
                    s = s1 - s2 -s3 + s4 #  (sx, sy) - (ex, ey) 長方形の美味しさポイント
                    # area = abs(sy - ey) * abs(sx - ex) #  長方形の面積
                    ans.append(s)
    return max(ans)


def main(args):
    array = []
    # n = 3
    # array.append([1, -2, 3])
    # array.append([-4, 5, 6])
    # array.append([7, 8, -9])

    n = int(input())
    for _ in range(n):
        array.append([int(x) for x in input().split()])
    ans = solve(n, array)
    print(ans)



if __name__ == '__main__':
    main(sys.argv[1:])

",1
p00099,"ワカサギ釣り大会 2
桧原湖でワカサギ釣り大会が行われました。今回はキャッチ＆リリースが推奨されているようです。
参加者番号と釣った匹数またはリリースした匹数を１つのイベントとして順番に読み込み、各イベントの直後に最も多くのワカサギを手元に獲得している参加者番号と匹数を出力するプログラムを作成してください。最も多く獲得している参加者が複数いる場合（あるいは全ての参加者が 0 匹の場合）は、その中で参加者番号が最も小さい一人を出力してください。
入力
入力は以下の形式で与えられる。
n
q
a
1
v
1
a
2
v
2
:
a
q
v
q
n
(1 ≤
n
≤ 1000000) は参加者の数、
q
(1 ≤
q
≤ 100000)はイベントの数を表す。
a
i
(1 ≤
a
i
≤
n
)
v
i
( -100 ≤
v
i
≤ 100) は、
i
番目のイベントで参加者
a
i
が
v
i
匹獲得あるいはリリースしたことを示す。
v
i
は正の値が獲得、負の値がリリースを示し、0 が与えられることはない。
出力
各イベントごとに、最も多くのワカサギを手元に獲得している参加者の参加者番号と匹数を１つの空白区切りで１行に出力する。
入力例1
3 5
1 4 
2 5 
1 3
3 6
2 7
出力例1
1 4
2 5
1 7
1 7
2 12
入力例2
3 5
1 4 
2 5 
2 -3
3 4
1 -1
出力例2
1 4
2 5
1 4
1 4
3 4",C,"#include <stdio.h>
#include <stdlib.h>

int main() {
    int n, q;
    scanf(""%d %d"", &n, &q);
    
    long long *counts = (long long *)calloc(n + 1, sizeof(long long));
    
    int max_id = 1;
    long long max_count = 0;
    
    for (int i = 0; i < q; i++) {
        int a, v;
        scanf(""%d %d"", &a, &v);
        
        counts[a] += v;
        
        max_id = 1;
        max_count = counts[1];
        for (int j = 2; j <= n; j++) {
            if (counts[j] > max_count) {
                max_count = counts[j];
                max_id = j;
            }
        }
        
        printf(""%d %lld\n"", max_id, max_count);
    }
    
    free(counts);
    return 0;
}
",0
p00099,"ワカサギ釣り大会 2
桧原湖でワカサギ釣り大会が行われました。今回はキャッチ＆リリースが推奨されているようです。
参加者番号と釣った匹数またはリリースした匹数を１つのイベントとして順番に読み込み、各イベントの直後に最も多くのワカサギを手元に獲得している参加者番号と匹数を出力するプログラムを作成してください。最も多く獲得している参加者が複数いる場合（あるいは全ての参加者が 0 匹の場合）は、その中で参加者番号が最も小さい一人を出力してください。
入力
入力は以下の形式で与えられる。
n
q
a
1
v
1
a
2
v
2
:
a
q
v
q
n
(1 ≤
n
≤ 1000000) は参加者の数、
q
(1 ≤
q
≤ 100000)はイベントの数を表す。
a
i
(1 ≤
a
i
≤
n
)
v
i
( -100 ≤
v
i
≤ 100) は、
i
番目のイベントで参加者
a
i
が
v
i
匹獲得あるいはリリースしたことを示す。
v
i
は正の値が獲得、負の値がリリースを示し、0 が与えられることはない。
出力
各イベントごとに、最も多くのワカサギを手元に獲得している参加者の参加者番号と匹数を１つの空白区切りで１行に出力する。
入力例1
3 5
1 4 
2 5 
1 3
3 6
2 7
出力例1
1 4
2 5
1 7
1 7
2 12
入力例2
3 5
1 4 
2 5 
2 -3
3 4
1 -1
出力例2
1 4
2 5
1 4
1 4
3 4",C,"#include <stdio.h>
#include <assert.h>
int main(void){
	int i,x,n,q,a,v,aaa=0,vvv=0,vv[9000],f[1000001],next[1000001],prev[1000001];
	scanf(""%d %d"",&n,&q);
	for(i=0;i<=n;i++){f[i]=0;prev[i]=0;next[i]=0;}
	for(i=0;i<9000;i++)vv[i]=0;
	for(;q>0;q--){
		scanf(""%d %d"",&a,&v);

		x=f[a];

		if(x>0){
			if(vv[x]==a){
				if(next[a]>0){vv[x]=next[a];}
				else vv[x]=0;
			}
			next[prev[a]]=next[a];
			prev[next[a]]=prev[a];
			prev[0]=0;next[0]=0;
		}

		f[a]+=v;x+=v;
		
		if(x>0){
			if(a<vv[x] || vv[x]==0){
				prev[a]=0;
				next[a]=vv[x];
				prev[vv[x]]=a;
				prev[0]=0;
				vv[x]=a;
			}
			else{
				i=vv[x];
				while(a>next[i] && next[i]>0){i=next[i];assert(i>0 && i<=n);}
				prev[a]=i;
				next[a]=next[i];
				prev[next[i]]=a;
				next[i]=a;
				prev[0]=0;
			}
		}else{prev[a]=0;next[a]=0;}
		
		if(v>0){if(x>vvv || (x==vvv && a<aaa)){vvv=x;aaa=a;}}
		else if(a==aaa){
			i=vvv;
			//for(i=vvv; vv[i]<1 && i>0 ;i--){assert(i>0 && i<9000);}
			vvv=i;
			//aaa=vv[i];
		}
		printf(""%d %d\n"",aaa,vvv);
	}
	return 0;
}",1
p00099,"ワカサギ釣り大会 2
桧原湖でワカサギ釣り大会が行われました。今回はキャッチ＆リリースが推奨されているようです。
参加者番号と釣った匹数またはリリースした匹数を１つのイベントとして順番に読み込み、各イベントの直後に最も多くのワカサギを手元に獲得している参加者番号と匹数を出力するプログラムを作成してください。最も多く獲得している参加者が複数いる場合（あるいは全ての参加者が 0 匹の場合）は、その中で参加者番号が最も小さい一人を出力してください。
入力
入力は以下の形式で与えられる。
n
q
a
1
v
1
a
2
v
2
:
a
q
v
q
n
(1 ≤
n
≤ 1000000) は参加者の数、
q
(1 ≤
q
≤ 100000)はイベントの数を表す。
a
i
(1 ≤
a
i
≤
n
)
v
i
( -100 ≤
v
i
≤ 100) は、
i
番目のイベントで参加者
a
i
が
v
i
匹獲得あるいはリリースしたことを示す。
v
i
は正の値が獲得、負の値がリリースを示し、0 が与えられることはない。
出力
各イベントごとに、最も多くのワカサギを手元に獲得している参加者の参加者番号と匹数を１つの空白区切りで１行に出力する。
入力例1
3 5
1 4 
2 5 
1 3
3 6
2 7
出力例1
1 4
2 5
1 7
1 7
2 12
入力例2
3 5
1 4 
2 5 
2 -3
3 4
1 -1
出力例2
1 4
2 5
1 4
1 4
3 4",Java,"import java.util.*;

public class Main {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int n = sc.nextInt();
        int q = sc.nextInt();
        
        Map<Integer, Integer> counts = new HashMap<>();
        
        for (int i = 0; i < q; i++) {
            int a = sc.nextInt();
            int v = sc.nextInt();
            
            counts.put(a, counts.getOrDefault(a, 0) + v);
            
            int maxCount = Integer.MIN_VALUE;
            int maxParticipant = Integer.MAX_VALUE;
            
            for (int participant = 1; participant <= n; participant++) {
                int count = counts.getOrDefault(participant, 0);
                if (count > maxCount || (count == maxCount && participant < maxParticipant)) {
                    maxCount = count;
                    maxParticipant = participant;
                }
            }
            
            System.out.println(maxParticipant + "" "" + maxCount);
        }
        
        sc.close();
    }
}
",0
p00099,"ワカサギ釣り大会 2
桧原湖でワカサギ釣り大会が行われました。今回はキャッチ＆リリースが推奨されているようです。
参加者番号と釣った匹数またはリリースした匹数を１つのイベントとして順番に読み込み、各イベントの直後に最も多くのワカサギを手元に獲得している参加者番号と匹数を出力するプログラムを作成してください。最も多く獲得している参加者が複数いる場合（あるいは全ての参加者が 0 匹の場合）は、その中で参加者番号が最も小さい一人を出力してください。
入力
入力は以下の形式で与えられる。
n
q
a
1
v
1
a
2
v
2
:
a
q
v
q
n
(1 ≤
n
≤ 1000000) は参加者の数、
q
(1 ≤
q
≤ 100000)はイベントの数を表す。
a
i
(1 ≤
a
i
≤
n
)
v
i
( -100 ≤
v
i
≤ 100) は、
i
番目のイベントで参加者
a
i
が
v
i
匹獲得あるいはリリースしたことを示す。
v
i
は正の値が獲得、負の値がリリースを示し、0 が与えられることはない。
出力
各イベントごとに、最も多くのワカサギを手元に獲得している参加者の参加者番号と匹数を１つの空白区切りで１行に出力する。
入力例1
3 5
1 4 
2 5 
1 3
3 6
2 7
出力例1
1 4
2 5
1 7
1 7
2 12
入力例2
3 5
1 4 
2 5 
2 -3
3 4
1 -1
出力例2
1 4
2 5
1 4
1 4
3 4",Java,"public class
Main
{
  public void
  run (
    final java.util.Scanner sc,
    final java.io.PrintStream out
    )
  {
    Pair[ ] heap;
    int[ ]  paeh;
    int n, q;
    int i;
    
    n = sc.nextInt ( );
    q = sc.nextInt ( );

    heap = new Pair[ n ];
    paeh = new int[ n + 1 ];
    for ( i = 1; i <= n; ++i )
    {
      paeh[ i ] = i - 1;
      heap[ paeh[ i ] ] = new Pair ( i, 0 );
    }

    for ( ; q > 0; --q )
    {
      int a, v, b;

      a = sc.nextInt ( );
      v = sc.nextInt ( );
      b = heap[ heap.length - 1 ].index;

      swap ( heap, paeh[ a ], paeh[ b ] );
      swap ( paeh, a, heap[ paeh[ a ] ].index );
      for ( ; ; )
      {
        if ( paeh[ b ] * 2 + 2 < heap.length - 1
          && heap[ paeh[ b ] * 2 + 2 ].compareTo ( heap[ paeh[ b ] * 2 + 1 ] ) < 0
          && heap[ paeh[ b ] * 2 + 2 ].compareTo ( heap[ paeh[ b ] ] ) < 0 )
        {
          swap ( heap, paeh[ b ], paeh[ b ] * 2 + 2 );
          swap ( paeh, b, heap[ paeh[ b ] ].index );
        }
        else if ( paeh[ b ] * 2 + 1 < heap.length - 1
               && heap[ paeh[ b ] * 2 + 1 ].compareTo ( heap[ paeh[ b ] ] ) < 0 )
        {
          swap ( heap, paeh[ b ], paeh[ b ] * 2 + 1 );
          swap ( paeh, b, heap[ paeh[ b ] ].index );
        }
        else break ;
      }
      heap[ paeh[ a ] ].value += v;
      for ( ; ; )
      {
        if ( paeh[ a ] > 0
          && heap[ paeh[ a ] ].compareTo ( heap[ ( paeh[ a ] - 1 ) / 2 ] ) < 0 )
        {
          swap ( heap, paeh[ a ], ( paeh[ a ] - 1 ) / 2 );
          swap ( paeh, a, heap[ paeh[ a ] ].index );
        }
        else break ;
      }
      System.out.println ( heap[ 0 ].index + "" "" + heap[ 0 ].value );
    }
  }

  private static void
  swap (
    int[ ] a,
    int i,
    int j
    )
  {
    final int t = a[ i ];
    a[ i ] = a[ j ];
    a[ j ] = t;
  }

  private static <T> void
  swap (
    T[ ] a,
    int i,
    int j
    )
  {
    final T t = a[ i ];
    a[ i ] = a[ j ];
    a[ j ] = t;
  }

  public static void
  main (
    final String[ ] args
    )
  {
    ( new Main ( ) ).run ( new java.util.Scanner ( System.in ), System.out );
  }

  private class
  Pair
  implements Comparable<Pair>
  {
    public final int index;
    public       int value;

    public
    Pair (
      final int index,
      final int value
      )
    {
      this.index = index;
      this.value = value;
    }

    public int
    compareTo (
      final Pair obj
      )
    {
      if ( this.value == obj.value )
        return ( this.index - obj.index );
      return ( obj.value - this.value );
    }
  }
}",1
p00099,"ワカサギ釣り大会 2
桧原湖でワカサギ釣り大会が行われました。今回はキャッチ＆リリースが推奨されているようです。
参加者番号と釣った匹数またはリリースした匹数を１つのイベントとして順番に読み込み、各イベントの直後に最も多くのワカサギを手元に獲得している参加者番号と匹数を出力するプログラムを作成してください。最も多く獲得している参加者が複数いる場合（あるいは全ての参加者が 0 匹の場合）は、その中で参加者番号が最も小さい一人を出力してください。
入力
入力は以下の形式で与えられる。
n
q
a
1
v
1
a
2
v
2
:
a
q
v
q
n
(1 ≤
n
≤ 1000000) は参加者の数、
q
(1 ≤
q
≤ 100000)はイベントの数を表す。
a
i
(1 ≤
a
i
≤
n
)
v
i
( -100 ≤
v
i
≤ 100) は、
i
番目のイベントで参加者
a
i
が
v
i
匹獲得あるいはリリースしたことを示す。
v
i
は正の値が獲得、負の値がリリースを示し、0 が与えられることはない。
出力
各イベントごとに、最も多くのワカサギを手元に獲得している参加者の参加者番号と匹数を１つの空白区切りで１行に出力する。
入力例1
3 5
1 4 
2 5 
1 3
3 6
2 7
出力例1
1 4
2 5
1 7
1 7
2 12
入力例2
3 5
1 4 
2 5 
2 -3
3 4
1 -1
出力例2
1 4
2 5
1 4
1 4
3 4",Python,"n, q = map(int, input().split())
counts = [0] * (n + 1)

for _ in range(q):
    a, v = map(int, input().split())
    counts[a] += v
    
    max_count = max(counts[1:n+1])
    for i in range(1, n + 1):
        if counts[i] == max_count:
            print(i, max_count)
            break
",0
p00099,"ワカサギ釣り大会 2
桧原湖でワカサギ釣り大会が行われました。今回はキャッチ＆リリースが推奨されているようです。
参加者番号と釣った匹数またはリリースした匹数を１つのイベントとして順番に読み込み、各イベントの直後に最も多くのワカサギを手元に獲得している参加者番号と匹数を出力するプログラムを作成してください。最も多く獲得している参加者が複数いる場合（あるいは全ての参加者が 0 匹の場合）は、その中で参加者番号が最も小さい一人を出力してください。
入力
入力は以下の形式で与えられる。
n
q
a
1
v
1
a
2
v
2
:
a
q
v
q
n
(1 ≤
n
≤ 1000000) は参加者の数、
q
(1 ≤
q
≤ 100000)はイベントの数を表す。
a
i
(1 ≤
a
i
≤
n
)
v
i
( -100 ≤
v
i
≤ 100) は、
i
番目のイベントで参加者
a
i
が
v
i
匹獲得あるいはリリースしたことを示す。
v
i
は正の値が獲得、負の値がリリースを示し、0 が与えられることはない。
出力
各イベントごとに、最も多くのワカサギを手元に獲得している参加者の参加者番号と匹数を１つの空白区切りで１行に出力する。
入力例1
3 5
1 4 
2 5 
1 3
3 6
2 7
出力例1
1 4
2 5
1 7
1 7
2 12
入力例2
3 5
1 4 
2 5 
2 -3
3 4
1 -1
出力例2
1 4
2 5
1 4
1 4
3 4",Python,"# -*- coding: utf-8 -*-
""""""
http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=0099
""""""
import sys
import bisect



def main(args):
    #data = [(1, 4), (2, 5), (1, 3), (3, 6), (2, 7)]
    #data = [(1, 4), (2, 5), (2, -3),(3, 4), (1, -1)]
    fisher, event = [int(x) for x in input().split(' ')]
    fishes = [0 for _ in range(fisher + 1)]

    winner = 9999999999
    max_fish = -1
    for _ in range(event):
        id, fish = [int(x) for x in input().strip().split(' ')]
        fishes[id] += fish
        if fish > 0:
            if fishes[id] > max_fish:
                max_fish = fishes[id]
                winner = id
            elif fishes[id] == max_fish:
                winner = min(winner, id)
            else:
                pass
        else:
            max_fish = max(fishes)
            winner = fishes.index(max_fish)
        print('{} {}'.format(winner, max_fish))


if __name__ == '__main__':
    main(sys.argv[1:])",1
p00100,"Sale Result
There is data on sales of your company. Your task is to write a program which identifies good workers.
The program should read a list of data where each item includes the employee ID
i
, the amount of sales
q
and the corresponding unit price
p
. Then, the program should print IDs of employees whose total sales proceeds (i.e. sum of p × q) is greater than or equal to 1,000,000 in the order of inputting. If there is no such employees, the program should print ""NA"". You can suppose that
n
< 4000, and each employee has an unique ID. The unit price
p
is less than or equal to 1,000,000 and the amount of sales
q
is less than or equal to 100,000.
Input
The input consists of several datasets. The input ends with a line including a single 0. Each dataset consists of:
n
(the number of data in the list)
i
p
q
i
p
q
:
 :
i
p
q
Output
For each dataset, print a list of employee IDs or a text ""NA""
Sample Input
4
1001 2000 520
1002 1800 450
1003 1600 625
1001 200 1220
2
1001 100 3
1005 1000 100
2
2013 5000 100
2013 5000 100
0
Output for the Sample Input
1001
1003
NA
2013",C,"#include <stdio.h>
#include <string.h>

int main() {
    int n;
    while(scanf(""%d"", &n) && n != 0) {
        int ids[4000];
        long long sales[4000];
        int count = 0;
        
        for(int i = 0; i < n; i++) {
            int id, p, q;
            scanf(""%d %d %d"", &id, &p, &q);
            
            int found = -1;
            for(int j = 0; j < count; j++) {
                if(ids[j] == id) {
                    found = j;
                    break;
                }
            }
            
            if(found == -1) {
                ids[count] = id;
                sales[count] = (long long)p * q;
                count++;
            } else {
                sales[found] += (long long)p * q;
            }
        }
        
        int found_any = 0;
        for(int i = 0; i < count; i++) {
            if(sales[i] >= 1000000) {
                printf(""%d\n"", ids[i]);
                found_any = 1;
            }
        }
        
        if(!found_any) {
            printf(""NA\n"");
        }
    }
    
    return 0;
}
",0
p00100,"Sale Result
There is data on sales of your company. Your task is to write a program which identifies good workers.
The program should read a list of data where each item includes the employee ID
i
, the amount of sales
q
and the corresponding unit price
p
. Then, the program should print IDs of employees whose total sales proceeds (i.e. sum of p × q) is greater than or equal to 1,000,000 in the order of inputting. If there is no such employees, the program should print ""NA"". You can suppose that
n
< 4000, and each employee has an unique ID. The unit price
p
is less than or equal to 1,000,000 and the amount of sales
q
is less than or equal to 100,000.
Input
The input consists of several datasets. The input ends with a line including a single 0. Each dataset consists of:
n
(the number of data in the list)
i
p
q
i
p
q
:
 :
i
p
q
Output
For each dataset, print a list of employee IDs or a text ""NA""
Sample Input
4
1001 2000 520
1002 1800 450
1003 1600 625
1001 200 1220
2
1001 100 3
1005 1000 100
2
2013 5000 100
2013 5000 100
0
Output for the Sample Input
1001
1003
NA
2013",C,"#include<stdio.h>

int main(void){
	int n;
	int staff,price,sold;
	while(1){
		int i,j = 0;
		int sccess[4000];
		scanf(""%d"", &n);
		if(n == 0)
			return 0;
		
		for(i = 0;i < n;i++){
			scanf(""%d %d %d"", &staff, &price, &sold);
			if(price * sold >= 1000000){
				sccess[j] = staff;
				j++;
			}
		}
		if(j == 0){
			printf(""NA\n"");
		}
		for(i = 0; j > i; i++){
			printf(""%d\n"", sccess[i]);
		}
	}
}",1
p00100,"Sale Result
There is data on sales of your company. Your task is to write a program which identifies good workers.
The program should read a list of data where each item includes the employee ID
i
, the amount of sales
q
and the corresponding unit price
p
. Then, the program should print IDs of employees whose total sales proceeds (i.e. sum of p × q) is greater than or equal to 1,000,000 in the order of inputting. If there is no such employees, the program should print ""NA"". You can suppose that
n
< 4000, and each employee has an unique ID. The unit price
p
is less than or equal to 1,000,000 and the amount of sales
q
is less than or equal to 100,000.
Input
The input consists of several datasets. The input ends with a line including a single 0. Each dataset consists of:
n
(the number of data in the list)
i
p
q
i
p
q
:
 :
i
p
q
Output
For each dataset, print a list of employee IDs or a text ""NA""
Sample Input
4
1001 2000 520
1002 1800 450
1003 1600 625
1001 200 1220
2
1001 100 3
1005 1000 100
2
2013 5000 100
2013 5000 100
0
Output for the Sample Input
1001
1003
NA
2013",Java,"import java.util.*;

public class Main {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        
        while (true) {
            int n = sc.nextInt();
            if (n == 0) break;
            
            LinkedHashMap<Integer, Long> sales = new LinkedHashMap<>();
            
            for (int i = 0; i < n; i++) {
                int id = sc.nextInt();
                long price = sc.nextLong();
                long quantity = sc.nextLong();
                long amount = price * quantity;
                
                sales.put(id, sales.getOrDefault(id, 0L) + amount);
            }
            
            boolean found = false;
            for (Map.Entry<Integer, Long> entry : sales.entrySet()) {
                if (entry.getValue() >= 1000000) {
                    System.out.println(entry.getKey());
                    found = true;
                }
            }
            
            if (!found) {
                System.out.println(""NA"");
            }
        }
        
        sc.close();
    }
}
",0
p00100,"Sale Result
There is data on sales of your company. Your task is to write a program which identifies good workers.
The program should read a list of data where each item includes the employee ID
i
, the amount of sales
q
and the corresponding unit price
p
. Then, the program should print IDs of employees whose total sales proceeds (i.e. sum of p × q) is greater than or equal to 1,000,000 in the order of inputting. If there is no such employees, the program should print ""NA"". You can suppose that
n
< 4000, and each employee has an unique ID. The unit price
p
is less than or equal to 1,000,000 and the amount of sales
q
is less than or equal to 100,000.
Input
The input consists of several datasets. The input ends with a line including a single 0. Each dataset consists of:
n
(the number of data in the list)
i
p
q
i
p
q
:
 :
i
p
q
Output
For each dataset, print a list of employee IDs or a text ""NA""
Sample Input
4
1001 2000 520
1002 1800 450
1003 1600 625
1001 200 1220
2
1001 100 3
1005 1000 100
2
2013 5000 100
2013 5000 100
0
Output for the Sample Input
1001
1003
NA
2013",Java,"import java.util.ArrayList;
import java.util.Collections;
import java.util.List;
import java.util.Scanner;

//Sale Result
public class Main{

	static class P implements Comparable<P>{
		public int o;
		public long s;
		public int compareTo(P o) {
			return this.o-o.o;
		}
	}
	
	public static void main(String[] args) {
		Scanner sc = new Scanner(System.in);
		while(true){
			int n = sc.nextInt();
			if(n==0)break;
			List<Integer> l = new ArrayList<Integer>();
			P[] s = new P[4001];
			int id = 0;
			while(n--!=0){
				int d = sc.nextInt();
				if(s[d]==null){
					s[d] = new P();
					s[d].o = id++;
				}
				long p = sc.nextLong();
				long k = sc.nextLong();
				s[d].s+=p*k;
			}
			for(int i=1;i<4001;i++)if(s[i]!=null&&1000000<=s[i].s)l.add(i);
			Collections.sort(l);
			if(l.isEmpty())System.out.println(""NA"");
			else for(int i:l)System.out.println(i);
		}
	}
}",1
p00100,"Sale Result
There is data on sales of your company. Your task is to write a program which identifies good workers.
The program should read a list of data where each item includes the employee ID
i
, the amount of sales
q
and the corresponding unit price
p
. Then, the program should print IDs of employees whose total sales proceeds (i.e. sum of p × q) is greater than or equal to 1,000,000 in the order of inputting. If there is no such employees, the program should print ""NA"". You can suppose that
n
< 4000, and each employee has an unique ID. The unit price
p
is less than or equal to 1,000,000 and the amount of sales
q
is less than or equal to 100,000.
Input
The input consists of several datasets. The input ends with a line including a single 0. Each dataset consists of:
n
(the number of data in the list)
i
p
q
i
p
q
:
 :
i
p
q
Output
For each dataset, print a list of employee IDs or a text ""NA""
Sample Input
4
1001 2000 520
1002 1800 450
1003 1600 625
1001 200 1220
2
1001 100 3
1005 1000 100
2
2013 5000 100
2013 5000 100
0
Output for the Sample Input
1001
1003
NA
2013",Python,"while True:
    n = int(input())
    if n == 0:
        break
    
    sales = {}
    order = []
    
    for _ in range(n):
        line = input().split()
        employee_id = line[0]
        p = int(line[1])
        q = int(line[2])
        
        if employee_id not in sales:
            sales[employee_id] = 0
            order.append(employee_id)
        
        sales[employee_id] += p * q
    
    result = []
    for employee_id in order:
        if sales[employee_id] >= 1000000:
            result.append(employee_id)
    
    if result:
        for emp_id in result:
            print(emp_id)
    else:
        print(""NA"")
",0
p00100,"Sale Result
There is data on sales of your company. Your task is to write a program which identifies good workers.
The program should read a list of data where each item includes the employee ID
i
, the amount of sales
q
and the corresponding unit price
p
. Then, the program should print IDs of employees whose total sales proceeds (i.e. sum of p × q) is greater than or equal to 1,000,000 in the order of inputting. If there is no such employees, the program should print ""NA"". You can suppose that
n
< 4000, and each employee has an unique ID. The unit price
p
is less than or equal to 1,000,000 and the amount of sales
q
is less than or equal to 100,000.
Input
The input consists of several datasets. The input ends with a line including a single 0. Each dataset consists of:
n
(the number of data in the list)
i
p
q
i
p
q
:
 :
i
p
q
Output
For each dataset, print a list of employee IDs or a text ""NA""
Sample Input
4
1001 2000 520
1002 1800 450
1003 1600 625
1001 200 1220
2
1001 100 3
1005 1000 100
2
2013 5000 100
2013 5000 100
0
Output for the Sample Input
1001
1003
NA
2013",Python,"# -*- coding: utf-8 -*-

import sys
import os
import math
from collections import defaultdict

for s in sys.stdin:
    n = int(s)
    if n == 0:
        break

    d = defaultdict(int)
    keys = []
    for i in range(n):
        e, p, q = map(int, input().split())
        d[e] += p * q
        if e not in keys:
            keys.append(e)

    # remove dup
    is_exist = False

    for key in keys:
        v = d[key]
        if v >= 1000000:
            print(key)
            is_exist = True

    if not is_exist:
        print('NA')",1
p00101,"Aizu PR
An English booklet has been created for publicizing Aizu to the world.
When you read it carefully, you found a misnomer (an error in writing) on the last name of Masayuki Hoshina, the lord of the Aizu domain. The booklet says ""Hoshino"" not ""Hoshina"".
Your task is to write a program which replace all the words ""Hoshino"" with ""Hoshina"". You can assume that the number of characters in a text is less than or equal to 1000.
Input
The input consists of several datasets. There will be the number of datasets
n
in the first line. There will be
n
lines. A line consisting of english texts will be given for each dataset.
Output
For each dataset, print the converted texts in a line.
Sample Input
3
Hoshino
Hashino
Masayuki Hoshino was the grandson of Ieyasu Tokugawa.
Output for the Sample Input
Hoshina
Hashino
Masayuki Hoshina was the grandson of Ieyasu Tokugawa.",C,"#include <stdio.h>
#include <string.h>

int main() {
    int n;
    char line[1001];
    char result[1001];
    
    scanf(""%d\n"", &n);
    
    for (int i = 0; i < n; i++) {
        fgets(line, sizeof(line), stdin);
        
        int len = strlen(line);
        if (line[len-1] == '\n') {
            line[len-1] = '\0';
            len--;
        }
        
        int j = 0;
        int k = 0;
        
        while (j < len) {
            if (j + 6 < len && strncmp(&line[j], ""Hoshino"", 7) == 0) {
                strcpy(&result[k], ""Hoshina"");
                k += 7;
                j += 7;
            } else if (j + 6 == len && strncmp(&line[j], ""Hoshino"", 7) == 0) {
                strcpy(&result[k], ""Hoshina"");
                k += 7;
                j += 7;
            } else {
                result[k] = line[j];
                k++;
                j++;
            }
        }
        
        result[k] = '\0';
        printf(""%s\n"", result);
    }
    
    return 0;
}
",0
p00101,"Aizu PR
An English booklet has been created for publicizing Aizu to the world.
When you read it carefully, you found a misnomer (an error in writing) on the last name of Masayuki Hoshina, the lord of the Aizu domain. The booklet says ""Hoshino"" not ""Hoshina"".
Your task is to write a program which replace all the words ""Hoshino"" with ""Hoshina"". You can assume that the number of characters in a text is less than or equal to 1000.
Input
The input consists of several datasets. There will be the number of datasets
n
in the first line. There will be
n
lines. A line consisting of english texts will be given for each dataset.
Output
For each dataset, print the converted texts in a line.
Sample Input
3
Hoshino
Hashino
Masayuki Hoshino was the grandson of Ieyasu Tokugawa.
Output for the Sample Input
Hoshina
Hashino
Masayuki Hoshina was the grandson of Ieyasu Tokugawa.",C,"#include <stdio.h>
#include <string.h>

int main(void) {
	int n;
	char in[1024], *ptr;

	scanf(""%d "", &n);

	while (n--) {
		fgets(in, 1023, stdin);
		ptr = strstr(in, ""Hoshino"");
		while (ptr != NULL) {
			ptr[6] = 'a';
			ptr = strstr(ptr, ""Hoshino"");
		}
		printf(""%s"", in);
	}
	return 0;
}",1
p00101,"Aizu PR
An English booklet has been created for publicizing Aizu to the world.
When you read it carefully, you found a misnomer (an error in writing) on the last name of Masayuki Hoshina, the lord of the Aizu domain. The booklet says ""Hoshino"" not ""Hoshina"".
Your task is to write a program which replace all the words ""Hoshino"" with ""Hoshina"". You can assume that the number of characters in a text is less than or equal to 1000.
Input
The input consists of several datasets. There will be the number of datasets
n
in the first line. There will be
n
lines. A line consisting of english texts will be given for each dataset.
Output
For each dataset, print the converted texts in a line.
Sample Input
3
Hoshino
Hashino
Masayuki Hoshino was the grandson of Ieyasu Tokugawa.
Output for the Sample Input
Hoshina
Hashino
Masayuki Hoshina was the grandson of Ieyasu Tokugawa.",Java,"import java.util.Scanner;

public class Main {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int n = Integer.parseInt(sc.nextLine());
        
        for (int i = 0; i < n; i++) {
            String line = sc.nextLine();
            String result = line.replace(""Hoshino"", ""Hoshina"");
            System.out.println(result);
        }
        
        sc.close();
    }
}
",0
p00101,"Aizu PR
An English booklet has been created for publicizing Aizu to the world.
When you read it carefully, you found a misnomer (an error in writing) on the last name of Masayuki Hoshina, the lord of the Aizu domain. The booklet says ""Hoshino"" not ""Hoshina"".
Your task is to write a program which replace all the words ""Hoshino"" with ""Hoshina"". You can assume that the number of characters in a text is less than or equal to 1000.
Input
The input consists of several datasets. There will be the number of datasets
n
in the first line. There will be
n
lines. A line consisting of english texts will be given for each dataset.
Output
For each dataset, print the converted texts in a line.
Sample Input
3
Hoshino
Hashino
Masayuki Hoshino was the grandson of Ieyasu Tokugawa.
Output for the Sample Input
Hoshina
Hashino
Masayuki Hoshina was the grandson of Ieyasu Tokugawa.",Java,"import java.util.Scanner;

public class Main {
	public static void main(String args[]){
		Scanner sc = new Scanner(System.in);
		int n = Integer.parseInt(sc.nextLine());
		for (int i = 0; i < n; i++) {
			String str = sc.nextLine();
			str = str.replaceAll(""Hoshino"", ""Hoshina"");
			System.out.println(str);
		}
	}
}
",1
p00101,"Aizu PR
An English booklet has been created for publicizing Aizu to the world.
When you read it carefully, you found a misnomer (an error in writing) on the last name of Masayuki Hoshina, the lord of the Aizu domain. The booklet says ""Hoshino"" not ""Hoshina"".
Your task is to write a program which replace all the words ""Hoshino"" with ""Hoshina"". You can assume that the number of characters in a text is less than or equal to 1000.
Input
The input consists of several datasets. There will be the number of datasets
n
in the first line. There will be
n
lines. A line consisting of english texts will be given for each dataset.
Output
For each dataset, print the converted texts in a line.
Sample Input
3
Hoshino
Hashino
Masayuki Hoshino was the grandson of Ieyasu Tokugawa.
Output for the Sample Input
Hoshina
Hashino
Masayuki Hoshina was the grandson of Ieyasu Tokugawa.",Python,"n = int(input())
for _ in range(n):
    line = input()
    print(line.replace(""Hoshino"", ""Hoshina""))
",0
p00101,"Aizu PR
An English booklet has been created for publicizing Aizu to the world.
When you read it carefully, you found a misnomer (an error in writing) on the last name of Masayuki Hoshina, the lord of the Aizu domain. The booklet says ""Hoshino"" not ""Hoshina"".
Your task is to write a program which replace all the words ""Hoshino"" with ""Hoshina"". You can assume that the number of characters in a text is less than or equal to 1000.
Input
The input consists of several datasets. There will be the number of datasets
n
in the first line. There will be
n
lines. A line consisting of english texts will be given for each dataset.
Output
For each dataset, print the converted texts in a line.
Sample Input
3
Hoshino
Hashino
Masayuki Hoshino was the grandson of Ieyasu Tokugawa.
Output for the Sample Input
Hoshina
Hashino
Masayuki Hoshina was the grandson of Ieyasu Tokugawa.",Python,"import sys

def main():
  n = int(sys.stdin.readline())
  for _ in range(n):
    line = sys.stdin.readline()
    print(line.strip().replace(""Hoshino"", ""Hoshina""))

if __name__ == ""__main__"":
  main()",1
p00102,"Matrix-like Computation
Your task is to develop a tiny little part of spreadsheet software.
Write a program which adds up columns and rows of given table as shown in the following figure:
Input
The input consists of several datasets. Each dataset consists of:
n
(the size of row and column of the given table)
1st row of the table
2nd row of the table
 :
 :
n
th row of the table
The input ends with a line consisting of a single 0.
Output
For each dataset, print the table with sums of rows and columns. Each item of the table should be aligned to the right with a margin for five digits. Please see the sample output for details.
Sample Input
4
52 96 15 20
86 22 35 45
45 78 54 36
16 86 74 55
4
52 96 15 20
86 22 35 45
45 78 54 36
16 86 74 55
0
Output for the Sample Input
52   96   15   20  183
   86   22   35   45  188
   45   78   54   36  213
   16   86   74   55  231
  199  282  178  156  815
   52   96   15   20  183
   86   22   35   45  188
   45   78   54   36  213
   16   86   74   55  231
  199  282  178  156  815",C,"#include <stdio.h>

int main() {
    int n;
    
    while(1) {
        scanf(""%d"", &n);
        if(n == 0) break;
        
        int table[n][n];
        int rowSum[n];
        int colSum[n];
        int totalSum = 0;
        
        // Read input
        for(int i = 0; i < n; i++) {
            for(int j = 0; j < n; j++) {
                scanf(""%d"", &table[i][j]);
            }
        }
        
        // Calculate row sums
        for(int i = 0; i < n; i++) {
            rowSum[i] = 0;
            for(int j = 0; j < n; j++) {
                rowSum[i] += table[i][j];
            }
        }
        
        // Calculate column sums
        for(int j = 0; j < n; j++) {
            colSum[j] = 0;
            for(int i = 0; i < n; i++) {
                colSum[j] += table[i][j];
            }
        }
        
        // Calculate total sum
        for(int i = 0; i < n; i++) {
            totalSum += rowSum[i];
        }
        
        // Print table with row sums
        for(int i = 0; i < n; i++) {
            for(int j = 0; j < n; j++) {
                printf(""%5d"", table[i][j]);
            }
            printf(""%5d\n"", rowSum[i]);
        }
        
        // Print column sums and total sum
        for(int j = 0; j < n; j++) {
            printf(""%5d"", colSum[j]);
        }
        printf(""%5d\n"", totalSum);
    }
    
    return 0;
}
",0
p00102,"Matrix-like Computation
Your task is to develop a tiny little part of spreadsheet software.
Write a program which adds up columns and rows of given table as shown in the following figure:
Input
The input consists of several datasets. Each dataset consists of:
n
(the size of row and column of the given table)
1st row of the table
2nd row of the table
 :
 :
n
th row of the table
The input ends with a line consisting of a single 0.
Output
For each dataset, print the table with sums of rows and columns. Each item of the table should be aligned to the right with a margin for five digits. Please see the sample output for details.
Sample Input
4
52 96 15 20
86 22 35 45
45 78 54 36
16 86 74 55
4
52 96 15 20
86 22 35 45
45 78 54 36
16 86 74 55
0
Output for the Sample Input
52   96   15   20  183
   86   22   35   45  188
   45   78   54   36  213
   16   86   74   55  231
  199  282  178  156  815
   52   96   15   20  183
   86   22   35   45  188
   45   78   54   36  213
   16   86   74   55  231
  199  282  178  156  815",C,"#include<stdio.h>

int main(){
  int a[11][11]={};
  int i,j,n,s,t;

  for(;;){
    scanf(""%d"",&n);
    if(!n)
      break;
    t=0;

    for(i=0;i<n;i++){
      s=0;
      for(j=0;j<n;j++){
	scanf(""%d"",&a[i][j]);
	s+=a[i][j];
      }
      a[i][n]=s;
      t+=s;
    }
    a[n][n]=t;
    for(j=0;j<n;j++){
      s=0;
      for(i=0;i<n;i++){
	s+=a[i][j];
      }
      a[n][j]=s;
    }
    for(i=0;i<=n;i++){
      for(j=0;j<=n;j++){
	printf(""%5d"",a[i][j]);
      }
      puts("""");
    }
  }
  return 0;
}",1
p00102,"Matrix-like Computation
Your task is to develop a tiny little part of spreadsheet software.
Write a program which adds up columns and rows of given table as shown in the following figure:
Input
The input consists of several datasets. Each dataset consists of:
n
(the size of row and column of the given table)
1st row of the table
2nd row of the table
 :
 :
n
th row of the table
The input ends with a line consisting of a single 0.
Output
For each dataset, print the table with sums of rows and columns. Each item of the table should be aligned to the right with a margin for five digits. Please see the sample output for details.
Sample Input
4
52 96 15 20
86 22 35 45
45 78 54 36
16 86 74 55
4
52 96 15 20
86 22 35 45
45 78 54 36
16 86 74 55
0
Output for the Sample Input
52   96   15   20  183
   86   22   35   45  188
   45   78   54   36  213
   16   86   74   55  231
  199  282  178  156  815
   52   96   15   20  183
   86   22   35   45  188
   45   78   54   36  213
   16   86   74   55  231
  199  282  178  156  815",Java,"import java.util.Scanner;

public class Main {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        
        while (true) {
            int n = sc.nextInt();
            if (n == 0) break;
            
            int[][] table = new int[n][n];
            
            for (int i = 0; i < n; i++) {
                for (int j = 0; j < n; j++) {
                    table[i][j] = sc.nextInt();
                }
            }
            
            int[] rowSums = new int[n];
            int[] colSums = new int[n];
            
            for (int i = 0; i < n; i++) {
                int rowSum = 0;
                for (int j = 0; j < n; j++) {
                    rowSum += table[i][j];
                }
                rowSums[i] = rowSum;
            }
            
            for (int j = 0; j < n; j++) {
                int colSum = 0;
                for (int i = 0; i < n; i++) {
                    colSum += table[i][j];
                }
                colSums[j] = colSum;
            }
            
            int totalSum = 0;
            for (int i = 0; i < n; i++) {
                totalSum += rowSums[i];
            }
            
            for (int i = 0; i < n; i++) {
                for (int j = 0; j < n; j++) {
                    System.out.printf(""%5d"", table[i][j]);
                }
                System.out.printf(""%5d\n"", rowSums[i]);
            }
            
            for (int j = 0; j < n; j++) {
                System.out.printf(""%5d"", colSums[j]);
            }
            System.out.printf(""%5d\n"", totalSum);
        }
        
        sc.close();
    }
}
",0
p00102,"Matrix-like Computation
Your task is to develop a tiny little part of spreadsheet software.
Write a program which adds up columns and rows of given table as shown in the following figure:
Input
The input consists of several datasets. Each dataset consists of:
n
(the size of row and column of the given table)
1st row of the table
2nd row of the table
 :
 :
n
th row of the table
The input ends with a line consisting of a single 0.
Output
For each dataset, print the table with sums of rows and columns. Each item of the table should be aligned to the right with a margin for five digits. Please see the sample output for details.
Sample Input
4
52 96 15 20
86 22 35 45
45 78 54 36
16 86 74 55
4
52 96 15 20
86 22 35 45
45 78 54 36
16 86 74 55
0
Output for the Sample Input
52   96   15   20  183
   86   22   35   45  188
   45   78   54   36  213
   16   86   74   55  231
  199  282  178  156  815
   52   96   15   20  183
   86   22   35   45  188
   45   78   54   36  213
   16   86   74   55  231
  199  282  178  156  815",Java,"import java.util.*;

class Main{
    public static void main(String args[]){
        Scanner in = new Scanner(System.in);
        while(true){
            int n = in.nextInt();
            if(n == 0) return ;
            int mat[][] = new int[n+1][n+1];
            for(int i=0; i<n; i++){
                int sumr = 0;
                for(int j=0; j<n; j++){
                    mat[i][j] = in.nextInt();
                    sumr += mat[i][j];
                }
                mat[i][n] = sumr;
            }
            for(int j=0; j<=n; j++){
                int sumc = 0;
                for(int i=0; i<n; i++){
                    sumc += mat[i][j];
                }
                mat[n][j] = sumc;
            }
            for(int i=0; i<=n; i++){
                for(int j=0; j<=n; j++){
                    System.out.printf(""%5d"",mat[i][j]);
                }
                System.out.println();
            }
        }
    }
}",1
p00102,"Matrix-like Computation
Your task is to develop a tiny little part of spreadsheet software.
Write a program which adds up columns and rows of given table as shown in the following figure:
Input
The input consists of several datasets. Each dataset consists of:
n
(the size of row and column of the given table)
1st row of the table
2nd row of the table
 :
 :
n
th row of the table
The input ends with a line consisting of a single 0.
Output
For each dataset, print the table with sums of rows and columns. Each item of the table should be aligned to the right with a margin for five digits. Please see the sample output for details.
Sample Input
4
52 96 15 20
86 22 35 45
45 78 54 36
16 86 74 55
4
52 96 15 20
86 22 35 45
45 78 54 36
16 86 74 55
0
Output for the Sample Input
52   96   15   20  183
   86   22   35   45  188
   45   78   54   36  213
   16   86   74   55  231
  199  282  178  156  815
   52   96   15   20  183
   86   22   35   45  188
   45   78   54   36  213
   16   86   74   55  231
  199  282  178  156  815",Python,"while True:
    n = int(input())
    if n == 0:
        break
    
    table = []
    for i in range(n):
        row = list(map(int, input().split()))
        table.append(row)
    
    # Calculate row sums
    row_sums = []
    for row in table:
        row_sums.append(sum(row))
    
    # Calculate column sums
    col_sums = []
    for j in range(n):
        col_sum = sum(table[i][j] for i in range(n))
        col_sums.append(col_sum)
    
    # Calculate total sum
    total_sum = sum(row_sums)
    
    # Print the table with sums
    for i in range(n):
        for j in range(n):
            print(f""{table[i][j]:5d}"", end="""")
        print(f""{row_sums[i]:5d}"")
    
    # Print column sums row
    for col_sum in col_sums:
        print(f""{col_sum:5d}"", end="""")
    print(f""{total_sum:5d}"")
",0
p00102,"Matrix-like Computation
Your task is to develop a tiny little part of spreadsheet software.
Write a program which adds up columns and rows of given table as shown in the following figure:
Input
The input consists of several datasets. Each dataset consists of:
n
(the size of row and column of the given table)
1st row of the table
2nd row of the table
 :
 :
n
th row of the table
The input ends with a line consisting of a single 0.
Output
For each dataset, print the table with sums of rows and columns. Each item of the table should be aligned to the right with a margin for five digits. Please see the sample output for details.
Sample Input
4
52 96 15 20
86 22 35 45
45 78 54 36
16 86 74 55
4
52 96 15 20
86 22 35 45
45 78 54 36
16 86 74 55
0
Output for the Sample Input
52   96   15   20  183
   86   22   35   45  188
   45   78   54   36  213
   16   86   74   55  231
  199  282  178  156  815
   52   96   15   20  183
   86   22   35   45  188
   45   78   54   36  213
   16   86   74   55  231
  199  282  178  156  815",Python,"import functools

n = input()
while(n):
    list = []
    bottom_record = [0]*(n+1)

    for i in range(0, n):
        l = map(int, raw_input().split())
        l.append(functools.reduce(lambda x, y: x + y, l))
        bottom_record = [x + y for(x,y) in zip(bottom_record, l)]
        print(' '.join(map(str, l))) 
    print(' '.join(map(str, bottom_record)))
    n = input()",1
p00103,"Baseball Simulation
Ichiro likes baseball and has decided to write a program which simulates baseball.
The program reads events in an inning and prints score in that inning. There are only three events as follows:
Single hit
put a runner on the first base.
the runner in the first base advances to the second base and the runner in the second base advances to the third base.
the runner in the third base advances to the home base (and go out of base) and a point is added to the score.
Home run
all the runners on base advance to the home base.
points are added to the score by an amount equal to the number of the runners plus one.
Out
The number of outs is increased by 1.
The runners and the score remain stationary.
The inning ends with three-out.
Ichiro decided to represent these events using ""HIT"", ""HOMERUN"" and ""OUT"", respectively.
Write a program which reads events in an inning and prints score in that inning. You can assume that the number of events is less than or equal to 100.
Input
The input consists of several datasets. In the first line, the number of datasets
n
is given. Each dataset consists of a list of events (strings) in an inning.
Output
For each dataset, prints the score in the corresponding inning.
Sample Input
2
HIT
OUT
HOMERUN
HIT
HIT
HOMERUN
HIT
OUT
HIT
HIT
HIT
HIT
OUT
HIT
HIT
OUT
HIT
OUT
OUT
Output for the Sample Input
7
0",C,"#include <stdio.h>
#include <string.h>

int main() {
    int n;
    scanf(""%d"", &n);
    
    while (n--) {
        int base[4] = {0}; // base[1], base[2], base[3] for first, second, third
        int score = 0;
        int outs = 0;
        char event[10];
        
        while (outs < 3 && scanf(""%s"", event) == 1) {
            if (strcmp(event, ""HIT"") == 0) {
                if (base[3]) {
                    score++;
                    base[3] = 0;
                }
                if (base[2]) {
                    base[3] = 1;
                    base[2] = 0;
                }
                if (base[1]) {
                    base[2] = 1;
                    base[1] = 0;
                }
                base[1] = 1;
            } else if (strcmp(event, ""HOMERUN"") == 0) {
                score++; // batter scores
                if (base[1]) {
                    score++;
                    base[1] = 0;
                }
                if (base[2]) {
                    score++;
                    base[2] = 0;
                }
                if (base[3]) {
                    score++;
                    base[3] = 0;
                }
            } else if (strcmp(event, ""OUT"") == 0) {
                outs++;
            }
        }
        
        printf(""%d\n"", score);
    }
    
    return 0;
}
",0
p00103,"Baseball Simulation
Ichiro likes baseball and has decided to write a program which simulates baseball.
The program reads events in an inning and prints score in that inning. There are only three events as follows:
Single hit
put a runner on the first base.
the runner in the first base advances to the second base and the runner in the second base advances to the third base.
the runner in the third base advances to the home base (and go out of base) and a point is added to the score.
Home run
all the runners on base advance to the home base.
points are added to the score by an amount equal to the number of the runners plus one.
Out
The number of outs is increased by 1.
The runners and the score remain stationary.
The inning ends with three-out.
Ichiro decided to represent these events using ""HIT"", ""HOMERUN"" and ""OUT"", respectively.
Write a program which reads events in an inning and prints score in that inning. You can assume that the number of events is less than or equal to 100.
Input
The input consists of several datasets. In the first line, the number of datasets
n
is given. Each dataset consists of a list of events (strings) in an inning.
Output
For each dataset, prints the score in the corresponding inning.
Sample Input
2
HIT
OUT
HOMERUN
HIT
HIT
HOMERUN
HIT
OUT
HIT
HIT
HIT
HIT
OUT
HIT
HIT
OUT
HIT
OUT
OUT
Output for the Sample Input
7
0",C,"#include <stdio.h>
#include <string.h>

int main(void)
{
	int n;
	char event[8];
	int out = 0;
	int base[3] = {0};
	int i;
	int score;
	
	scanf(""%d"", &n);
			 
	while (n != 0){
		score = 0;
		base[0] = 0;
		base[1] = 0;
		base[2] = 0;
		out = 0;
		while (out < 3){
			scanf(""%s"", event);
			if (strcmp(event, ""HIT"") == 0){
				base[0]++;
				for (i = 0; i < 3; i++){
					if (base[i] > 1){
						if (i < 2){
							base[i + 1]++;
						}
						else {
							score++;
						}
						base[i]--;
					}
					
				}
			}
			else if (strcmp(event, ""HOMERUN"") == 0){
				for (i = 0; i < 3; i++){
					if (base[i] == 1){
						score++;
						base[i] = 0;
					}
				}
				score++;
			}
			else if (strcmp(event, ""OUT"") == 0){
				out++;
			}
		}
		printf(""%d\n"", score);
		n--;
	}
	
	return 0;
}",1
p00103,"Baseball Simulation
Ichiro likes baseball and has decided to write a program which simulates baseball.
The program reads events in an inning and prints score in that inning. There are only three events as follows:
Single hit
put a runner on the first base.
the runner in the first base advances to the second base and the runner in the second base advances to the third base.
the runner in the third base advances to the home base (and go out of base) and a point is added to the score.
Home run
all the runners on base advance to the home base.
points are added to the score by an amount equal to the number of the runners plus one.
Out
The number of outs is increased by 1.
The runners and the score remain stationary.
The inning ends with three-out.
Ichiro decided to represent these events using ""HIT"", ""HOMERUN"" and ""OUT"", respectively.
Write a program which reads events in an inning and prints score in that inning. You can assume that the number of events is less than or equal to 100.
Input
The input consists of several datasets. In the first line, the number of datasets
n
is given. Each dataset consists of a list of events (strings) in an inning.
Output
For each dataset, prints the score in the corresponding inning.
Sample Input
2
HIT
OUT
HOMERUN
HIT
HIT
HOMERUN
HIT
OUT
HIT
HIT
HIT
HIT
OUT
HIT
HIT
OUT
HIT
OUT
OUT
Output for the Sample Input
7
0",Java,"import java.util.*;

public class Main {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int n = sc.nextInt();
        sc.nextLine();
        
        for (int i = 0; i < n; i++) {
            int score = 0;
            int outs = 0;
            boolean[] bases = new boolean[3]; // 0: first, 1: second, 2: third
            
            while (outs < 3) {
                String event = sc.nextLine().trim();
                
                if (event.equals(""HIT"")) {
                    if (bases[2]) {
                        score++;
                        bases[2] = false;
                    }
                    if (bases[1]) {
                        bases[2] = true;
                        bases[1] = false;
                    }
                    if (bases[0]) {
                        bases[1] = true;
                    }
                    bases[0] = true;
                } else if (event.equals(""HOMERUN"")) {
                    score++; // for the batter
                    for (int j = 0; j < 3; j++) {
                        if (bases[j]) {
                            score++;
                            bases[j] = false;
                        }
                    }
                } else if (event.equals(""OUT"")) {
                    outs++;
                }
            }
            
            System.out.println(score);
        }
        
        sc.close();
    }
}
",0
p00103,"Baseball Simulation
Ichiro likes baseball and has decided to write a program which simulates baseball.
The program reads events in an inning and prints score in that inning. There are only three events as follows:
Single hit
put a runner on the first base.
the runner in the first base advances to the second base and the runner in the second base advances to the third base.
the runner in the third base advances to the home base (and go out of base) and a point is added to the score.
Home run
all the runners on base advance to the home base.
points are added to the score by an amount equal to the number of the runners plus one.
Out
The number of outs is increased by 1.
The runners and the score remain stationary.
The inning ends with three-out.
Ichiro decided to represent these events using ""HIT"", ""HOMERUN"" and ""OUT"", respectively.
Write a program which reads events in an inning and prints score in that inning. You can assume that the number of events is less than or equal to 100.
Input
The input consists of several datasets. In the first line, the number of datasets
n
is given. Each dataset consists of a list of events (strings) in an inning.
Output
For each dataset, prints the score in the corresponding inning.
Sample Input
2
HIT
OUT
HOMERUN
HIT
HIT
HOMERUN
HIT
OUT
HIT
HIT
HIT
HIT
OUT
HIT
HIT
OUT
HIT
OUT
OUT
Output for the Sample Input
7
0",Java,"import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.Arrays;
import java.util.List;

public class Main {
	public static void main(String[] args) {
		BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
		int field = 0;
		long scoreCount = 0;
		int outCount = 0;
		int finishedGame = 0;
		try {
			int gameNumber = br.read();
			while (finishedGame < gameNumber) {
				switch (br.readLine()) {
				case ""HIT"":
					if(field==3) {
						scoreCount++;
					}
					field++;
					break;
				case ""OUT"":
					outCount++;
					if (outCount == 3) {
						System.out.println(scoreCount);
						scoreCount = 0;
						outCount = 0;
						field = 0;
						finishedGame++;
					}
					break;
				case ""HOMERUN"":
					scoreCount += 1 + field;
					field = 0;
					break;
				}
			}
			br.close();
		} catch (IOException e) {
			e.printStackTrace();
		}
	}
}",1
p00103,"Baseball Simulation
Ichiro likes baseball and has decided to write a program which simulates baseball.
The program reads events in an inning and prints score in that inning. There are only three events as follows:
Single hit
put a runner on the first base.
the runner in the first base advances to the second base and the runner in the second base advances to the third base.
the runner in the third base advances to the home base (and go out of base) and a point is added to the score.
Home run
all the runners on base advance to the home base.
points are added to the score by an amount equal to the number of the runners plus one.
Out
The number of outs is increased by 1.
The runners and the score remain stationary.
The inning ends with three-out.
Ichiro decided to represent these events using ""HIT"", ""HOMERUN"" and ""OUT"", respectively.
Write a program which reads events in an inning and prints score in that inning. You can assume that the number of events is less than or equal to 100.
Input
The input consists of several datasets. In the first line, the number of datasets
n
is given. Each dataset consists of a list of events (strings) in an inning.
Output
For each dataset, prints the score in the corresponding inning.
Sample Input
2
HIT
OUT
HOMERUN
HIT
HIT
HOMERUN
HIT
OUT
HIT
HIT
HIT
HIT
OUT
HIT
HIT
OUT
HIT
OUT
OUT
Output for the Sample Input
7
0",Python,"n = int(input())
for _ in range(n):
    score = 0
    bases = [False, False, False]  # 1st, 2nd, 3rd base
    outs = 0
    
    while outs < 3:
        event = input().strip()
        
        if event == ""HIT"":
            # Score runners from 3rd base
            if bases[2]:
                score += 1
            # Advance runners
            bases[2] = bases[1]
            bases[1] = bases[0]
            bases[0] = True
            
        elif event == ""HOMERUN"":
            # Count runners on base
            runners_on_base = sum(bases)
            # Score all runners plus batter
            score += runners_on_base + 1
            # Clear all bases
            bases = [False, False, False]
            
        elif event == ""OUT"":
            outs += 1
    
    print(score)
",0
p00103,"Baseball Simulation
Ichiro likes baseball and has decided to write a program which simulates baseball.
The program reads events in an inning and prints score in that inning. There are only three events as follows:
Single hit
put a runner on the first base.
the runner in the first base advances to the second base and the runner in the second base advances to the third base.
the runner in the third base advances to the home base (and go out of base) and a point is added to the score.
Home run
all the runners on base advance to the home base.
points are added to the score by an amount equal to the number of the runners plus one.
Out
The number of outs is increased by 1.
The runners and the score remain stationary.
The inning ends with three-out.
Ichiro decided to represent these events using ""HIT"", ""HOMERUN"" and ""OUT"", respectively.
Write a program which reads events in an inning and prints score in that inning. You can assume that the number of events is less than or equal to 100.
Input
The input consists of several datasets. In the first line, the number of datasets
n
is given. Each dataset consists of a list of events (strings) in an inning.
Output
For each dataset, prints the score in the corresponding inning.
Sample Input
2
HIT
OUT
HOMERUN
HIT
HIT
HOMERUN
HIT
OUT
HIT
HIT
HIT
HIT
OUT
HIT
HIT
OUT
HIT
OUT
OUT
Output for the Sample Input
7
0",Python,"def hit(bases):
    got_point = False
    if bases[2]:
        got_point = True
    bases[0], bases[1], bases[2] = 1, bases[0], bases[1]
    if got_point:
        return 1
    else:
        return 0

def homerun(bases):
    num_runner = bases.count(1)
    bases[0], bases[1], bases[2] = 0, 0, 0
    return num_runner + 1

for i in range(int(raw_input())):
    bases = [0, 0, 0]
    out_count = 0
    points = 0
    while out_count != 3:
        event = raw_input()
        if event == ""HIT"":
            points += hit(bases)
        elif event == ""HOMERUN"":
            points += homerun(bases)
        else:
            out_count += 1
    print points",1
p00106,"Discounts of Buckwheat
Aizu is famous for its buckwheat. There are many people who make buckwheat noodles by themselves.
One day, you went shopping to buy buckwheat flour. You can visit three shops, A, B and C. The amount in a bag and its unit price for each shop is determined by the follows table. Note that it is discounted when you buy buckwheat flour in several bags.
Shop A
Shop B
Shop C
Amount in a bag
200g
300g
500g
Unit price for a bag (nominal cost)
380 yen
550 yen
850 yen
Discounted units
per 5 bags
per 4 bags
per 3 bags
Discount rate
reduced by 20 %
reduced by 15 %
reduced by 12 %
For example, when you buy 12 bags of flour at shop A, the price is reduced by 20 % for 10 bags, but not for other 2 bags. So, the total amount shall be (380 × 10) × 0.8 + 380 × 2 = 3,800 yen.
Write a program which reads the amount of flour, and prints the lowest cost to buy them. Note that you should buy the flour of exactly the same amount as the given input.
Input
The input consists of multiple datasets. For each dataset, an integer
a
(500 ≤
a
≤ 5000,
a
is divisible by 100) which represents the amount of flour is given in a line.
The input ends with a line including a zero. Your program should not process for the terminal symbol. The number of datasets does not exceed 50.
Output
For each dataset, print an integer which represents the lowest cost.
Sample Input
500
2200
0
Output for the Sample Input
850
3390",C,"#include <stdio.h>

int main() {
    int a;
    
    while(scanf(""%d"", &a) == 1 && a != 0) {
        int minCost = -1;
        
        // Shop A: 200g bags, 380 yen, per 5 bags 20% discount
        if(a % 200 == 0) {
            int bags = a / 200;
            int discountedBags = (bags / 5) * 5;
            int normalBags = bags % 5;
            int cost = (int)(discountedBags * 380 * 0.8) + normalBags * 380;
            if(minCost == -1 || cost < minCost) {
                minCost = cost;
            }
        }
        
        // Shop B: 300g bags, 550 yen, per 4 bags 15% discount
        if(a % 300 == 0) {
            int bags = a / 300;
            int discountedBags = (bags / 4) * 4;
            int normalBags = bags % 4;
            int cost = (int)(discountedBags * 550 * 0.85) + normalBags * 550;
            if(minCost == -1 || cost < minCost) {
                minCost = cost;
            }
        }
        
        // Shop C: 500g bags, 850 yen, per 3 bags 12% discount
        if(a % 500 == 0) {
            int bags = a / 500;
            int discountedBags = (bags / 3) * 3;
            int normalBags = bags % 3;
            int cost = (int)(discountedBags * 850 * 0.88) + normalBags * 850;
            if(minCost == -1 || cost < minCost) {
                minCost = cost;
            }
        }
        
        printf(""%d\n"", minCost);
    }
    
    return 0;
}
",0
p00106,"Discounts of Buckwheat
Aizu is famous for its buckwheat. There are many people who make buckwheat noodles by themselves.
One day, you went shopping to buy buckwheat flour. You can visit three shops, A, B and C. The amount in a bag and its unit price for each shop is determined by the follows table. Note that it is discounted when you buy buckwheat flour in several bags.
Shop A
Shop B
Shop C
Amount in a bag
200g
300g
500g
Unit price for a bag (nominal cost)
380 yen
550 yen
850 yen
Discounted units
per 5 bags
per 4 bags
per 3 bags
Discount rate
reduced by 20 %
reduced by 15 %
reduced by 12 %
For example, when you buy 12 bags of flour at shop A, the price is reduced by 20 % for 10 bags, but not for other 2 bags. So, the total amount shall be (380 × 10) × 0.8 + 380 × 2 = 3,800 yen.
Write a program which reads the amount of flour, and prints the lowest cost to buy them. Note that you should buy the flour of exactly the same amount as the given input.
Input
The input consists of multiple datasets. For each dataset, an integer
a
(500 ≤
a
≤ 5000,
a
is divisible by 100) which represents the amount of flour is given in a line.
The input ends with a line including a zero. Your program should not process for the terminal symbol. The number of datasets does not exceed 50.
Output
For each dataset, print an integer which represents the lowest cost.
Sample Input
500
2200
0
Output for the Sample Input
850
3390",C,"C[51],c;
#define min(a,b) ((a)<(b)?(a):(b))
main(i){
	C[1]=380;
	for(i=2;i<=50;i++){
		c=9999;
		if(i>=2)c=min(c,C[i-2]+380);
		if(i>=3)c=min(c,C[i-3]+550);
		if(i>=5)c=min(c,C[i-5]+850);
		if(i>=10)c=min(c,C[i-10]+1520);
		if(i>=12)c=min(c,C[i-12]+1870);
		if(i>=15)c=min(c,C[i-15]+2244);
		C[i]=c;
	}
	for(;~scanf(""%d"",&i);)
		i&&printf(""%d\n"",C[(i+99)/100]);
}",1
p00106,"Discounts of Buckwheat
Aizu is famous for its buckwheat. There are many people who make buckwheat noodles by themselves.
One day, you went shopping to buy buckwheat flour. You can visit three shops, A, B and C. The amount in a bag and its unit price for each shop is determined by the follows table. Note that it is discounted when you buy buckwheat flour in several bags.
Shop A
Shop B
Shop C
Amount in a bag
200g
300g
500g
Unit price for a bag (nominal cost)
380 yen
550 yen
850 yen
Discounted units
per 5 bags
per 4 bags
per 3 bags
Discount rate
reduced by 20 %
reduced by 15 %
reduced by 12 %
For example, when you buy 12 bags of flour at shop A, the price is reduced by 20 % for 10 bags, but not for other 2 bags. So, the total amount shall be (380 × 10) × 0.8 + 380 × 2 = 3,800 yen.
Write a program which reads the amount of flour, and prints the lowest cost to buy them. Note that you should buy the flour of exactly the same amount as the given input.
Input
The input consists of multiple datasets. For each dataset, an integer
a
(500 ≤
a
≤ 5000,
a
is divisible by 100) which represents the amount of flour is given in a line.
The input ends with a line including a zero. Your program should not process for the terminal symbol. The number of datasets does not exceed 50.
Output
For each dataset, print an integer which represents the lowest cost.
Sample Input
500
2200
0
Output for the Sample Input
850
3390",Java,"import java.util.Scanner;

public class Main {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        
        while (true) {
            int a = sc.nextInt();
            if (a == 0) break;
            
            int minCost = Integer.MAX_VALUE;
            
            // Shop A: 200g per bag, 380 yen, 5 bags discount 20%
            if (a % 200 == 0) {
                int bags = a / 200;
                int discountedBags = (bags / 5) * 5;
                int normalBags = bags % 5;
                int cost = (int)(discountedBags * 380 * 0.8) + normalBags * 380;
                minCost = Math.min(minCost, cost);
            }
            
            // Shop B: 300g per bag, 550 yen, 4 bags discount 15%
            if (a % 300 == 0) {
                int bags = a / 300;
                int discountedBags = (bags / 4) * 4;
                int normalBags = bags % 4;
                int cost = (int)(discountedBags * 550 * 0.85) + normalBags * 550;
                minCost = Math.min(minCost, cost);
            }
            
            // Shop C: 500g per bag, 850 yen, 3 bags discount 12%
            if (a % 500 == 0) {
                int bags = a / 500;
                int discountedBags = (bags / 3) * 3;
                int normalBags = bags % 3;
                int cost = (int)(discountedBags * 850 * 0.88) + normalBags * 850;
                minCost = Math.min(minCost, cost);
            }
            
            System.out.println(minCost);
        }
        
        sc.close();
    }
}
",0
p00106,"Discounts of Buckwheat
Aizu is famous for its buckwheat. There are many people who make buckwheat noodles by themselves.
One day, you went shopping to buy buckwheat flour. You can visit three shops, A, B and C. The amount in a bag and its unit price for each shop is determined by the follows table. Note that it is discounted when you buy buckwheat flour in several bags.
Shop A
Shop B
Shop C
Amount in a bag
200g
300g
500g
Unit price for a bag (nominal cost)
380 yen
550 yen
850 yen
Discounted units
per 5 bags
per 4 bags
per 3 bags
Discount rate
reduced by 20 %
reduced by 15 %
reduced by 12 %
For example, when you buy 12 bags of flour at shop A, the price is reduced by 20 % for 10 bags, but not for other 2 bags. So, the total amount shall be (380 × 10) × 0.8 + 380 × 2 = 3,800 yen.
Write a program which reads the amount of flour, and prints the lowest cost to buy them. Note that you should buy the flour of exactly the same amount as the given input.
Input
The input consists of multiple datasets. For each dataset, an integer
a
(500 ≤
a
≤ 5000,
a
is divisible by 100) which represents the amount of flour is given in a line.
The input ends with a line including a zero. Your program should not process for the terminal symbol. The number of datasets does not exceed 50.
Output
For each dataset, print an integer which represents the lowest cost.
Sample Input
500
2200
0
Output for the Sample Input
850
3390",Java,"import java.util.*;

class Main{
	public static void main(String[] args){
		Scanner sc = new Scanner(System.in);
		int n = sc.nextInt();
		while(true){ 
			if(n == 0)break;
			System.out.println(min(n));
			n = sc.nextInt();
		}   
	}   
	static int min(int n){
		int min = Integer.MAX_VALUE;
		for(int c = n/500 ; c >= 0 ; c--){
			for(int b = (n-c*500)/300 ; b >= 0 ; b--){
				if((n-c*500-b*300)%200 == 0){ 
					int a = (n-c*500-b*300)/200;
					int cost = cost(a, b, c); 
					if(cost < min){
						min = cost;
					}   
				}   
			}   
		}   
		return min;
	}   
	static int cost(int a, int b, int c){
		return (a%5)*380+(a/5)*5*380*8/10+(b%4)*550+(b/4)*4*550*85/100+(c%3)*850+(c/3)*3*850*88/100;
	}   
}",1
p00106,"Discounts of Buckwheat
Aizu is famous for its buckwheat. There are many people who make buckwheat noodles by themselves.
One day, you went shopping to buy buckwheat flour. You can visit three shops, A, B and C. The amount in a bag and its unit price for each shop is determined by the follows table. Note that it is discounted when you buy buckwheat flour in several bags.
Shop A
Shop B
Shop C
Amount in a bag
200g
300g
500g
Unit price for a bag (nominal cost)
380 yen
550 yen
850 yen
Discounted units
per 5 bags
per 4 bags
per 3 bags
Discount rate
reduced by 20 %
reduced by 15 %
reduced by 12 %
For example, when you buy 12 bags of flour at shop A, the price is reduced by 20 % for 10 bags, but not for other 2 bags. So, the total amount shall be (380 × 10) × 0.8 + 380 × 2 = 3,800 yen.
Write a program which reads the amount of flour, and prints the lowest cost to buy them. Note that you should buy the flour of exactly the same amount as the given input.
Input
The input consists of multiple datasets. For each dataset, an integer
a
(500 ≤
a
≤ 5000,
a
is divisible by 100) which represents the amount of flour is given in a line.
The input ends with a line including a zero. Your program should not process for the terminal symbol. The number of datasets does not exceed 50.
Output
For each dataset, print an integer which represents the lowest cost.
Sample Input
500
2200
0
Output for the Sample Input
850
3390",Python,"def calculate_cost(amount, bag_size, unit_price, discount_unit, discount_rate):
    if amount % bag_size != 0:
        return float('inf')
    
    num_bags = amount // bag_size
    discounted_bags = (num_bags // discount_unit) * discount_unit
    regular_bags = num_bags % discount_unit
    
    discounted_cost = discounted_bags * unit_price * (1 - discount_rate)
    regular_cost = regular_bags * unit_price
    
    return int(discounted_cost + regular_cost)

while True:
    a = int(input())
    if a == 0:
        break
    
    # Shop A: 200g, 380 yen, per 5 bags, 20% off
    cost_a = calculate_cost(a, 200, 380, 5, 0.20)
    
    # Shop B: 300g, 550 yen, per 4 bags, 15% off
    cost_b = calculate_cost(a, 300, 550, 4, 0.15)
    
    # Shop C: 500g, 850 yen, per 3 bags, 12% off
    cost_c = calculate_cost(a, 500, 850, 3, 0.12)
    
    print(min(cost_a, cost_b, cost_c))
",0
p00106,"Discounts of Buckwheat
Aizu is famous for its buckwheat. There are many people who make buckwheat noodles by themselves.
One day, you went shopping to buy buckwheat flour. You can visit three shops, A, B and C. The amount in a bag and its unit price for each shop is determined by the follows table. Note that it is discounted when you buy buckwheat flour in several bags.
Shop A
Shop B
Shop C
Amount in a bag
200g
300g
500g
Unit price for a bag (nominal cost)
380 yen
550 yen
850 yen
Discounted units
per 5 bags
per 4 bags
per 3 bags
Discount rate
reduced by 20 %
reduced by 15 %
reduced by 12 %
For example, when you buy 12 bags of flour at shop A, the price is reduced by 20 % for 10 bags, but not for other 2 bags. So, the total amount shall be (380 × 10) × 0.8 + 380 × 2 = 3,800 yen.
Write a program which reads the amount of flour, and prints the lowest cost to buy them. Note that you should buy the flour of exactly the same amount as the given input.
Input
The input consists of multiple datasets. For each dataset, an integer
a
(500 ≤
a
≤ 5000,
a
is divisible by 100) which represents the amount of flour is given in a line.
The input ends with a line including a zero. Your program should not process for the terminal symbol. The number of datasets does not exceed 50.
Output
For each dataset, print an integer which represents the lowest cost.
Sample Input
500
2200
0
Output for the Sample Input
850
3390",Python,"a=[(2,380),(3,550),(5,850),(10,1520),(12,1870),(15,2244)]
dp=[1<<20]*51
for i,j in a:
    dp[i]=j
    for k in range(51-i):
        if dp[k]!=1<<20 and dp[k+i]>dp[k]+j:
            dp[k+i]=dp[k]+j
while 1:
    n=int(input())
    if n==0:break
    print(dp[n//100])",1
p00107,"Carry a Cheese
Jerry is a little mouse. He is trying to survive from the cat Tom. Jerry is carrying a parallelepiped-like piece of cheese of size
A
×
B
×
C
. It is necessary to trail this cheese to the Jerry's house. There are several entrances in the Jerry's house. Each entrance is a rounded hole having its own radius
R
. Could you help Jerry to find suitable holes to be survive?
Your task is to create a program which estimates whether Jerry can trail the cheese via each hole.
The program should print ""
OK
"" if Jerry can trail the cheese via the corresponding hole (without touching it). Otherwise the program should print ""
NA
"".
You may assume that the number of holes is less than 10000.
Input
The input is a sequence of datasets. The end of input is indicated by a line containing three zeros. Each dataset is formatted as follows:
A B C
n
R
1
R
2
.
 .
R
n
n
indicates the number of holes (entrances) and
R
i
indicates the radius of
i
-th hole.
Output
For each datasets, the output should have
n
lines. Each line points the result of estimation of the corresponding hole.
Sample Input
10 6 8
5
4
8
6
2
5
0 0 0
Output for the Sample Input
NA
OK
OK
NA
NA",C,"#include <stdio.h>
#include <math.h>

int main() {
    int A, B, C;
    
    while(1) {
        scanf(""%d %d %d"", &A, &B, &C);
        
        if(A == 0 && B == 0 && C == 0) break;
        
        int n;
        scanf(""%d"", &n);
        
        // Calculate the minimum diagonal of any face
        // The cheese can pass through a circular hole if the diagonal of the smallest rectangular face
        // can fit through the circle
        double diag1 = sqrt(A * A + B * B);
        double diag2 = sqrt(B * B + C * C);
        double diag3 = sqrt(A * A + C * C);
        
        double min_diag = diag1;
        if(diag2 < min_diag) min_diag = diag2;
        if(diag3 < min_diag) min_diag = diag3;
        
        for(int i = 0; i < n; i++) {
            int R;
            scanf(""%d"", &R);
            
            // The cheese can pass if the diameter of the hole is greater than the minimum diagonal
            if(2 * R > min_diag) {
                printf(""OK\n"");
            } else {
                printf(""NA\n"");
            }
        }
    }
    
    return 0;
}
",0
p00107,"Carry a Cheese
Jerry is a little mouse. He is trying to survive from the cat Tom. Jerry is carrying a parallelepiped-like piece of cheese of size
A
×
B
×
C
. It is necessary to trail this cheese to the Jerry's house. There are several entrances in the Jerry's house. Each entrance is a rounded hole having its own radius
R
. Could you help Jerry to find suitable holes to be survive?
Your task is to create a program which estimates whether Jerry can trail the cheese via each hole.
The program should print ""
OK
"" if Jerry can trail the cheese via the corresponding hole (without touching it). Otherwise the program should print ""
NA
"".
You may assume that the number of holes is less than 10000.
Input
The input is a sequence of datasets. The end of input is indicated by a line containing three zeros. Each dataset is formatted as follows:
A B C
n
R
1
R
2
.
 .
R
n
n
indicates the number of holes (entrances) and
R
i
indicates the radius of
i
-th hole.
Output
For each datasets, the output should have
n
lines. Each line points the result of estimation of the corresponding hole.
Sample Input
10 6 8
5
4
8
6
2
5
0 0 0
Output for the Sample Input
NA
OK
OK
NA
NA",C,"#include<stdio.h>

int main(){
  int i,n,t[3];
  int data,kari,hakari;

  while(1){
    scanf(""%d%d%d"",&t[0],&t[1],&t[2]);
    if(t[0] == 0 || t[1] == 0 || t[2] == 0)
      break;
    scanf(""%d"",&n);
    if(t[0] >= t[2]){
      t[0] = t[2];
       t[2] = -1;
      }
    if(t[1] >= t[2]&&t[2] != -1)
      t[1] = t[2];
    hakari = t[0] * t[0] + t[1] *t[1];
    for(i = 0; i < n; i++){
      scanf(""%d"",&data);
      data = data * 2;
      data = data * data;
      if(hakari < data)
	printf(""OK\n"");
      else 
	printf(""NA\n"");
    }
  }
  return 0;
}",1
p00107,"Carry a Cheese
Jerry is a little mouse. He is trying to survive from the cat Tom. Jerry is carrying a parallelepiped-like piece of cheese of size
A
×
B
×
C
. It is necessary to trail this cheese to the Jerry's house. There are several entrances in the Jerry's house. Each entrance is a rounded hole having its own radius
R
. Could you help Jerry to find suitable holes to be survive?
Your task is to create a program which estimates whether Jerry can trail the cheese via each hole.
The program should print ""
OK
"" if Jerry can trail the cheese via the corresponding hole (without touching it). Otherwise the program should print ""
NA
"".
You may assume that the number of holes is less than 10000.
Input
The input is a sequence of datasets. The end of input is indicated by a line containing three zeros. Each dataset is formatted as follows:
A B C
n
R
1
R
2
.
 .
R
n
n
indicates the number of holes (entrances) and
R
i
indicates the radius of
i
-th hole.
Output
For each datasets, the output should have
n
lines. Each line points the result of estimation of the corresponding hole.
Sample Input
10 6 8
5
4
8
6
2
5
0 0 0
Output for the Sample Input
NA
OK
OK
NA
NA",Java,"import java.util.Scanner;

public class Main {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        
        while (true) {
            int A = sc.nextInt();
            int B = sc.nextInt();
            int C = sc.nextInt();
            
            if (A == 0 && B == 0 && C == 0) {
                break;
            }
            
            // Find the minimum diagonal among all three faces
            // The cheese can pass through if oriented diagonally through a face
            double diag1 = Math.sqrt(A * A + B * B);
            double diag2 = Math.sqrt(B * B + C * C);
            double diag3 = Math.sqrt(A * A + C * C);
            
            double minDiag = Math.min(diag1, Math.min(diag2, diag3));
            
            int n = sc.nextInt();
            
            for (int i = 0; i < n; i++) {
                int R = sc.nextInt();
                
                if (2 * R > minDiag) {
                    System.out.println(""OK"");
                } else {
                    System.out.println(""NA"");
                }
            }
        }
        
        sc.close();
    }
}
",0
p00107,"Carry a Cheese
Jerry is a little mouse. He is trying to survive from the cat Tom. Jerry is carrying a parallelepiped-like piece of cheese of size
A
×
B
×
C
. It is necessary to trail this cheese to the Jerry's house. There are several entrances in the Jerry's house. Each entrance is a rounded hole having its own radius
R
. Could you help Jerry to find suitable holes to be survive?
Your task is to create a program which estimates whether Jerry can trail the cheese via each hole.
The program should print ""
OK
"" if Jerry can trail the cheese via the corresponding hole (without touching it). Otherwise the program should print ""
NA
"".
You may assume that the number of holes is less than 10000.
Input
The input is a sequence of datasets. The end of input is indicated by a line containing three zeros. Each dataset is formatted as follows:
A B C
n
R
1
R
2
.
 .
R
n
n
indicates the number of holes (entrances) and
R
i
indicates the radius of
i
-th hole.
Output
For each datasets, the output should have
n
lines. Each line points the result of estimation of the corresponding hole.
Sample Input
10 6 8
5
4
8
6
2
5
0 0 0
Output for the Sample Input
NA
OK
OK
NA
NA",Java,"import java.util.Scanner;
import java.util.Arrays;

class Main
{
	public static void main(String args[])
	{
		Scanner sc = new Scanner(System.in);
		
		while (true)
		{
			int a[] = new int[3];
			for (int i = 0; i < 3; i++)
				a[i] = sc.nextInt();
			if (a[0] == 0 && a[1] == 0 && a[2] == 0) break;
			
			//Arrays.sort(a);
			int minR = a[0] * a[0] + a[2] + a[2];
			
			int n = sc.nextInt();
			for (int i = 0; i < n; i++)
			{
				int r = sc.nextInt() * 2;
				if (minR < r * r) System.out.println(""OK"");
				else System.out.println(""NA"");
			}
		}
	}
}",1
p00107,"Carry a Cheese
Jerry is a little mouse. He is trying to survive from the cat Tom. Jerry is carrying a parallelepiped-like piece of cheese of size
A
×
B
×
C
. It is necessary to trail this cheese to the Jerry's house. There are several entrances in the Jerry's house. Each entrance is a rounded hole having its own radius
R
. Could you help Jerry to find suitable holes to be survive?
Your task is to create a program which estimates whether Jerry can trail the cheese via each hole.
The program should print ""
OK
"" if Jerry can trail the cheese via the corresponding hole (without touching it). Otherwise the program should print ""
NA
"".
You may assume that the number of holes is less than 10000.
Input
The input is a sequence of datasets. The end of input is indicated by a line containing three zeros. Each dataset is formatted as follows:
A B C
n
R
1
R
2
.
 .
R
n
n
indicates the number of holes (entrances) and
R
i
indicates the radius of
i
-th hole.
Output
For each datasets, the output should have
n
lines. Each line points the result of estimation of the corresponding hole.
Sample Input
10 6 8
5
4
8
6
2
5
0 0 0
Output for the Sample Input
NA
OK
OK
NA
NA",Python,"import math

while True:
    line = input().split()
    A, B, C = int(line[0]), int(line[1]), int(line[2])
    
    if A == 0 and B == 0 and C == 0:
        break
    
    # The smallest diagonal that can fit through a circle of radius R
    # is when we orient the cheese optimally through the hole.
    # The cheese can pass through if the smallest cross-sectional diagonal
    # fits in the circle of radius R.
    
    # For a parallelepiped with dimensions A, B, C, the smallest
    # cross-sectional diagonal occurs when we look at the rectangular
    # faces. The diagonals of the three faces are:
    # sqrt(A^2 + B^2), sqrt(B^2 + C^2), sqrt(A^2 + C^2)
    
    # The smallest of these is what we need to fit through the hole
    # (divided by 2 for radius)
    
    sides = [A, B, C]
    sides.sort()
    
    # The minimum diagonal is between the two smallest sides
    min_diagonal = math.sqrt(sides[0]**2 + sides[1]**2)
    min_radius_needed = min_diagonal / 2
    
    n = int(input())
    
    for _ in range(n):
        R = int(input())
        if R > min_radius_needed:
            print(""OK"")
        else:
            print(""NA"")
",0
p00107,"Carry a Cheese
Jerry is a little mouse. He is trying to survive from the cat Tom. Jerry is carrying a parallelepiped-like piece of cheese of size
A
×
B
×
C
. It is necessary to trail this cheese to the Jerry's house. There are several entrances in the Jerry's house. Each entrance is a rounded hole having its own radius
R
. Could you help Jerry to find suitable holes to be survive?
Your task is to create a program which estimates whether Jerry can trail the cheese via each hole.
The program should print ""
OK
"" if Jerry can trail the cheese via the corresponding hole (without touching it). Otherwise the program should print ""
NA
"".
You may assume that the number of holes is less than 10000.
Input
The input is a sequence of datasets. The end of input is indicated by a line containing three zeros. Each dataset is formatted as follows:
A B C
n
R
1
R
2
.
 .
R
n
n
indicates the number of holes (entrances) and
R
i
indicates the radius of
i
-th hole.
Output
For each datasets, the output should have
n
lines. Each line points the result of estimation of the corresponding hole.
Sample Input
10 6 8
5
4
8
6
2
5
0 0 0
Output for the Sample Input
NA
OK
OK
NA
NA",Python,"while 1:
 a,b,_=sorted(map(int,input().split()))
 if a==0:break
 for _ in[0]*int(input()):print(""OK""if(int(input())*2)**2>a*a+b*b else""NA"")
",1
p00109,"Smart Calculator
Your task is to write a program which reads an expression and evaluates it.
The expression consists of numerical values, operators and parentheses, and the ends with '='.
The operators includes +, - , *, / where respectively represents, addition, subtraction, multiplication and division.
Precedence of the operators is based on usual laws. That is one should perform all multiplication and division first, then addition and subtraction. When two operators have the same precedence, they are applied from left to right.
You may assume that there is no division by zero.
All calculation is performed as integers, and after the decimal point should be truncated
Length of the expression will not exceed 100.
-1 × 10
9
≤ intermediate results of computation ≤ 10
9
Input
The input is a sequence of datasets. The first line contains an integer
n
which represents the number of datasets. There will be
n
lines where each line contains an expression.
Output
For each datasets, prints the result of calculation.
Sample Input
2
4-2*3=
4*(8+4+3)=
Output for the Sample Input
-2
60",C,"#include <stdio.h>
#include <string.h>
#include <ctype.h>

char expr[105];
int pos;

long long parse_expr();
long long parse_term();
long long parse_factor();

long long parse_number() {
    long long num = 0;
    int sign = 1;
    
    if (expr[pos] == '-') {
        sign = -1;
        pos++;
    } else if (expr[pos] == '+') {
        pos++;
    }
    
    while (isdigit(expr[pos])) {
        num = num * 10 + (expr[pos] - '0');
        pos++;
    }
    
    return sign * num;
}

long long parse_factor() {
    if (expr[pos] == '(') {
        pos++; // skip '('
        long long result = parse_expr();
        pos++; // skip ')'
        return result;
    } else {
        return parse_number();
    }
}

long long parse_term() {
    long long result = parse_factor();
    
    while (expr[pos] == '*' || expr[pos] == '/') {
        char op = expr[pos];
        pos++;
        long long right = parse_factor();
        if (op == '*') {
            result = result * right;
        } else {
            result = result / right;
        }
    }
    
    return result;
}

long long parse_expr() {
    long long result = parse_term();
    
    while (expr[pos] == '+' || expr[pos] == '-') {
        char op = expr[pos];
        pos++;
        long long right = parse_term();
        if (op == '+') {
            result = result + right;
        } else {
            result = result - right;
        }
    }
    
    return result;
}

int main() {
    int n;
    scanf(""%d"", &n);
    getchar();
    
    while (n--) {
        fgets(expr, 105, stdin);
        pos = 0;
        long long result = parse_expr();
        printf(""%lld\n"", result);
    }
    
    return 0;
}
",0
p00109,"Smart Calculator
Your task is to write a program which reads an expression and evaluates it.
The expression consists of numerical values, operators and parentheses, and the ends with '='.
The operators includes +, - , *, / where respectively represents, addition, subtraction, multiplication and division.
Precedence of the operators is based on usual laws. That is one should perform all multiplication and division first, then addition and subtraction. When two operators have the same precedence, they are applied from left to right.
You may assume that there is no division by zero.
All calculation is performed as integers, and after the decimal point should be truncated
Length of the expression will not exceed 100.
-1 × 10
9
≤ intermediate results of computation ≤ 10
9
Input
The input is a sequence of datasets. The first line contains an integer
n
which represents the number of datasets. There will be
n
lines where each line contains an expression.
Output
For each datasets, prints the result of calculation.
Sample Input
2
4-2*3=
4*(8+4+3)=
Output for the Sample Input
-2
60",C,"#include <stdio.h>

int expr(char **s);

int number(char **s) {
  int val = 0;
  while ('0' <= **s && **s <= '9') {
    val = val * 10 + **s - '0';
    (*s)++;
  }
  return val;
}

int factor(char **s) {
  if (**s == '(') {
    (*s)++;
    int val = expr(s);
    (*s)++;
    return val;
  }
  return number(s);
}

int term(char **s) {
  int val = factor(s);
  while (1) {
    if (**s == '*') {
      (*s)++;
      val *= factor(s);
    } else if (**s == '/') {
      (*s)++;
      val /= factor(s);
    } else {
      break;
    }
  }
  return val;
}

int expr(char **s) {
  int val = term(s);
  while (1) {
    if (**s == '+') {
      (*s)++;
      val += term(s);
    } else if (**s == '-') {
      (*s)++;
      val -= term(s);
    } else {
      break;
    }
  }
  return val;
}

int main() {
  int n;
  scanf(""%d"", &n);
  char s[101];
  while (n--) {
    scanf(""%s"", s);
    char *p = s;
    printf(""%d\n"", expr(&p));
  }
}",1
p00109,"Smart Calculator
Your task is to write a program which reads an expression and evaluates it.
The expression consists of numerical values, operators and parentheses, and the ends with '='.
The operators includes +, - , *, / where respectively represents, addition, subtraction, multiplication and division.
Precedence of the operators is based on usual laws. That is one should perform all multiplication and division first, then addition and subtraction. When two operators have the same precedence, they are applied from left to right.
You may assume that there is no division by zero.
All calculation is performed as integers, and after the decimal point should be truncated
Length of the expression will not exceed 100.
-1 × 10
9
≤ intermediate results of computation ≤ 10
9
Input
The input is a sequence of datasets. The first line contains an integer
n
which represents the number of datasets. There will be
n
lines where each line contains an expression.
Output
For each datasets, prints the result of calculation.
Sample Input
2
4-2*3=
4*(8+4+3)=
Output for the Sample Input
-2
60",Java,"import java.util.*;

public class Main {
    static String expr;
    static int pos;
    
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int n = sc.nextInt();
        sc.nextLine();
        
        for (int i = 0; i < n; i++) {
            expr = sc.nextLine().trim();
            pos = 0;
            System.out.println(parseExpression());
        }
        sc.close();
    }
    
    static long parseExpression() {
        long result = parseTerm();
        
        while (pos < expr.length() && (expr.charAt(pos) == '+' || expr.charAt(pos) == '-')) {
            char op = expr.charAt(pos);
            pos++;
            long term = parseTerm();
            if (op == '+') {
                result += term;
            } else {
                result -= term;
            }
        }
        
        return result;
    }
    
    static long parseTerm() {
        long result = parseFactor();
        
        while (pos < expr.length() && (expr.charAt(pos) == '*' || expr.charAt(pos) == '/')) {
            char op = expr.charAt(pos);
            pos++;
            long factor = parseFactor();
            if (op == '*') {
                result *= factor;
            } else {
                result /= factor;
            }
        }
        
        return result;
    }
    
    static long parseFactor() {
        if (expr.charAt(pos) == '(') {
            pos++;
            long result = parseExpression();
            pos++;
            return result;
        }
        
        boolean negative = false;
        if (expr.charAt(pos) == '-') {
            negative = true;
            pos++;
        } else if (expr.charAt(pos) == '+') {
            pos++;
        }
        
        long num = 0;
        while (pos < expr.length() && Character.isDigit(expr.charAt(pos))) {
            num = num * 10 + (expr.charAt(pos) - '0');
            pos++;
        }
        
        return negative ? -num : num;
    }
}
",0
p00109,"Smart Calculator
Your task is to write a program which reads an expression and evaluates it.
The expression consists of numerical values, operators and parentheses, and the ends with '='.
The operators includes +, - , *, / where respectively represents, addition, subtraction, multiplication and division.
Precedence of the operators is based on usual laws. That is one should perform all multiplication and division first, then addition and subtraction. When two operators have the same precedence, they are applied from left to right.
You may assume that there is no division by zero.
All calculation is performed as integers, and after the decimal point should be truncated
Length of the expression will not exceed 100.
-1 × 10
9
≤ intermediate results of computation ≤ 10
9
Input
The input is a sequence of datasets. The first line contains an integer
n
which represents the number of datasets. There will be
n
lines where each line contains an expression.
Output
For each datasets, prints the result of calculation.
Sample Input
2
4-2*3=
4*(8+4+3)=
Output for the Sample Input
-2
60",Java,"import java.util.Scanner;

public class Main {
	static String str;
	static int pos;

	public static void main(String[] args) {
		Scanner sc = new Scanner(System.in);
		int n = sc.nextInt();
		for (int i = 0; i < n; i++) {
			str = sc.next();
			pos = 0;
			System.out.println(expression());
		}
		sc.close();
	}

	static int expression() {
		int ret = term();
		while (str.charAt(pos) != '=') {
			if (str.charAt(pos) == '+') {
				pos++;
				ret += term();
			} else if (str.charAt(pos) == '-') {
				pos++;
				ret -= term();
			} else {
				break;
			}
		}
		return ret;
	}

	static int term() {
		int ret = factor();
		while (str.charAt(pos) != '=') {
			if (str.charAt(pos) == '*') {
				pos++;
				ret *= factor();
			} else if (str.charAt(pos) == '/') {
				pos++;
				ret /= factor();
			} else {
				break;
			}
		}
		return ret;
	}

	static int factor() {
		if (str.charAt(pos) == '(') {
			pos++;
			int temp = expression();
			pos++;
			return temp;
		} else {
			return number();
		}
	}

	static int number() {
		int ret = 0;
		while (Character.isDigit(str.charAt(pos))) {
			ret *= 10;
			ret += str.charAt(pos) - '0';
			pos++;
		}
		return ret;
	}

}",1
p00109,"Smart Calculator
Your task is to write a program which reads an expression and evaluates it.
The expression consists of numerical values, operators and parentheses, and the ends with '='.
The operators includes +, - , *, / where respectively represents, addition, subtraction, multiplication and division.
Precedence of the operators is based on usual laws. That is one should perform all multiplication and division first, then addition and subtraction. When two operators have the same precedence, they are applied from left to right.
You may assume that there is no division by zero.
All calculation is performed as integers, and after the decimal point should be truncated
Length of the expression will not exceed 100.
-1 × 10
9
≤ intermediate results of computation ≤ 10
9
Input
The input is a sequence of datasets. The first line contains an integer
n
which represents the number of datasets. There will be
n
lines where each line contains an expression.
Output
For each datasets, prints the result of calculation.
Sample Input
2
4-2*3=
4*(8+4+3)=
Output for the Sample Input
-2
60",Python,"def evaluate(expr):
    expr = expr.strip().rstrip('=')
    
    def parse_number(s, i):
        j = i
        if j < len(s) and s[j] in '+-':
            j += 1
        while j < len(s) and s[j].isdigit():
            j += 1
        return int(s[i:j]), j
    
    def parse_factor(s, i):
        if s[i] == '(':
            val, j = parse_expr(s, i + 1)
            return val, j + 1
        else:
            return parse_number(s, i)
    
    def parse_term(s, i):
        left, i = parse_factor(s, i)
        while i < len(s) and s[i] in '*/':
            op = s[i]
            right, i = parse_factor(s, i + 1)
            if op == '*':
                left = left * right
            else:
                left = int(left / right)
        return left, i
    
    def parse_expr(s, i):
        left, i = parse_term(s, i)
        while i < len(s) and s[i] in '+-' and (i == 0 or s[i-1] not in '(+*-/'):
            op = s[i]
            right, i = parse_term(s, i + 1)
            if op == '+':
                left = left + right
            else:
                left = left - right
        return left, i
    
    result, _ = parse_expr(expr, 0)
    return result

n = int(input())
for _ in range(n):
    expr = input()
    print(evaluate(expr))
",0
p00109,"Smart Calculator
Your task is to write a program which reads an expression and evaluates it.
The expression consists of numerical values, operators and parentheses, and the ends with '='.
The operators includes +, - , *, / where respectively represents, addition, subtraction, multiplication and division.
Precedence of the operators is based on usual laws. That is one should perform all multiplication and division first, then addition and subtraction. When two operators have the same precedence, they are applied from left to right.
You may assume that there is no division by zero.
All calculation is performed as integers, and after the decimal point should be truncated
Length of the expression will not exceed 100.
-1 × 10
9
≤ intermediate results of computation ≤ 10
9
Input
The input is a sequence of datasets. The first line contains an integer
n
which represents the number of datasets. There will be
n
lines where each line contains an expression.
Output
For each datasets, prints the result of calculation.
Sample Input
2
4-2*3=
4*(8+4+3)=
Output for the Sample Input
-2
60",Python,"def String2List(s):
    L = []
    flag = True
    l = len(s)
    for i in range(l):
        if s[i].isdigit() and flag:
            t = """"
            j = 0
            while s[i+j].isdigit():
                t += s[i+j]
                if i+j == l-1:
                    break
                j += 1
            L.append(t)
            flag = False

        elif not s[i].isdigit():
            L.append(s[i])
            flag = True

    return L


def RPN_list(L):
    S, L2 = [], []
    table = {""*"": 1, ""/"": 1, ""+"": 0, ""-"": 0, ""("": -1, "")"": -1}
    rpn = """"
    for i in L:
        if i.isdigit():
            L2.append(i)
        elif i == ""("":
            S.append(i)
        elif i == "")"":
            while S[-1] != ""("":
                L2.append(S.pop())
            S.pop()
        else:
            if len(S) != 0 and (table[S[-1]] >= table[i]):
                L2.append(S.pop())            
            S.append(i)

    while len(S) != 0:
        L2.append(S.pop())

    return L2


def RPN_cul(L):
    St = []

    for i in L:
        if i == '+':
            St.append(int(St.pop()) + int(St.pop()))
        elif i == '-':
            St.append(-int(St.pop()) + int(St.pop()))
        elif i == '*':
            St.append(int(St.pop()) * int(St.pop()))
        elif i == '/':
            a = int(St.pop())
            b = float(St.pop())
            r = b/a
            if b < 0 and b % a != 0:
                r += 1
            St.append(r)
        else:
            St.append(i)

    return St[0]


N = int(raw_input())

for i in range(N):
    s = raw_input()
    L = String2List(s[:-1])
    L = RPN_list(L)
    print int(RPN_cul(L))",1
p00110,"覆面算
数式の一部を隠してしまって、隠した数字を探す問題を覆面算といいます。今回は、数式の中のある数字のいくつかを X で隠してしまった式を扱います。以下の数式を入力して、結果を出力するプログラムを作成してください。
数式
「数字列 + 数字列 = 数字列」の形で、1 行の単純な足し算式です。
「数字列」は、数字 0 から 9 と文字 X の並びです。
2 桁以上の「数字列」の左端の数字は 0 ではないものとします。
X は、数式全体の中で必ず 1 つ以上含まれます。
結果
覆面算の答えです。数式が成り立つ様な X の値で 0 ~ 9 のどれか 1 つです。2 つ以上の答えはないものとします。
答えがない場合、結果は“NA”としてください。
Input
複数のデータセットが与えられます。各データセットとして、X を 1 つ以上含む足し算式(空白を含まない 126 文字以内の文字列) が１行に与えられます。データセットの数は 150 を超えません。
Output
各データセットについて、覆面算の結果を１行に出力してください。数字 0 ~ 9 または NA を出力してください。
Sample Input
123+4X6=X79
12X+4X6=X79
XX22+89=X2XX
Output for the Sample Input
5
NA
1",C,"#include <stdio.h>
#include <string.h>
#include <stdlib.h>

int hasLeadingZero(char *str) {
    if (strlen(str) > 1 && str[0] == '0') {
        return 1;
    }
    return 0;
}

int checkEquation(char *left1, char *left2, char *right) {
    if (hasLeadingZero(left1) || hasLeadingZero(left2) || hasLeadingZero(right)) {
        return 0;
    }
    
    long long num1 = atoll(left1);
    long long num2 = atoll(left2);
    long long sum = atoll(right);
    
    return (num1 + num2 == sum);
}

void replaceX(char *str, char digit, char *result) {
    int i;
    for (i = 0; str[i]; i++) {
        if (str[i] == 'X') {
            result[i] = digit;
        } else {
            result[i] = str[i];
        }
    }
    result[i] = '\0';
}

int main() {
    char input[256];
    
    while (fgets(input, sizeof(input), stdin)) {
        input[strcspn(input, ""\n"")] = 0;
        
        char *plus = strchr(input, '+');
        char *equal = strchr(input, '=');
        
        if (!plus || !equal) continue;
        
        char left1[128], left2[128], right[128];
        
        int len1 = plus - input;
        int len2 = equal - plus - 1;
        int len3 = strlen(equal + 1);
        
        strncpy(left1, input, len1);
        left1[len1] = '\0';
        
        strncpy(left2, plus + 1, len2);
        left2[len2] = '\0';
        
        strcpy(right, equal + 1);
        
        int found = -1;
        int count = 0;
        
        for (int digit = 0; digit <= 9; digit++) {
            char temp1[128], temp2[128], temp3[128];
            char digitChar = '0' + digit;
            
            replaceX(left1, digitChar, temp1);
            replaceX(left2, digitChar, temp2);
            replaceX(right, digitChar, temp3);
            
            if (checkEquation(temp1, temp2, temp3)) {
                found = digit;
                count++;
            }
        }
        
        if (count == 1) {
            printf(""%d\n"", found);
        } else {
            printf(""NA\n"");
        }
    }
    
    return 0;
}
",0
p00110,"覆面算
数式の一部を隠してしまって、隠した数字を探す問題を覆面算といいます。今回は、数式の中のある数字のいくつかを X で隠してしまった式を扱います。以下の数式を入力して、結果を出力するプログラムを作成してください。
数式
「数字列 + 数字列 = 数字列」の形で、1 行の単純な足し算式です。
「数字列」は、数字 0 から 9 と文字 X の並びです。
2 桁以上の「数字列」の左端の数字は 0 ではないものとします。
X は、数式全体の中で必ず 1 つ以上含まれます。
結果
覆面算の答えです。数式が成り立つ様な X の値で 0 ~ 9 のどれか 1 つです。2 つ以上の答えはないものとします。
答えがない場合、結果は“NA”としてください。
Input
複数のデータセットが与えられます。各データセットとして、X を 1 つ以上含む足し算式(空白を含まない 126 文字以内の文字列) が１行に与えられます。データセットの数は 150 を超えません。
Output
各データセットについて、覆面算の結果を１行に出力してください。数字 0 ~ 9 または NA を出力してください。
Sample Input
123+4X6=X79
12X+4X6=X79
XX22+89=X2XX
Output for the Sample Input
5
NA
1",C,"#include <stdio.h>
#include <string.h>
#include <math.h>

#define DIGIT (pow(10, (strlen(num) - 1 -j)))

int solved(char num[100], int i){
  int s = 0, j;
  for(j = 0;j < strlen(num);j++){
    if(num[j] == 'X')
      s += i * DIGIT;
    else 
      s += (num[j] - '0') * DIGIT;
  }
  return s;
}

int main(){
  int a, b, c, i, j;
  char calc[100], *f, *s, *ans;
  while(scanf(""%s"", calc) != EOF){
    f = strtok(calc, ""+"");
    s = strtok(NULL, ""="");
    ans = strtok(NULL, "","");
    
    for(i = 0;i < 10;i++)
      if(solved(f, i) + solved(s, i) == solved(ans, i)){
	printf(""%d\n"", i);
	break;
      }
    if(i > 9)
      puts(""NA"");
  }
  return 0;
}",1
p00110,"覆面算
数式の一部を隠してしまって、隠した数字を探す問題を覆面算といいます。今回は、数式の中のある数字のいくつかを X で隠してしまった式を扱います。以下の数式を入力して、結果を出力するプログラムを作成してください。
数式
「数字列 + 数字列 = 数字列」の形で、1 行の単純な足し算式です。
「数字列」は、数字 0 から 9 と文字 X の並びです。
2 桁以上の「数字列」の左端の数字は 0 ではないものとします。
X は、数式全体の中で必ず 1 つ以上含まれます。
結果
覆面算の答えです。数式が成り立つ様な X の値で 0 ~ 9 のどれか 1 つです。2 つ以上の答えはないものとします。
答えがない場合、結果は“NA”としてください。
Input
複数のデータセットが与えられます。各データセットとして、X を 1 つ以上含む足し算式(空白を含まない 126 文字以内の文字列) が１行に与えられます。データセットの数は 150 を超えません。
Output
各データセットについて、覆面算の結果を１行に出力してください。数字 0 ~ 9 または NA を出力してください。
Sample Input
123+4X6=X79
12X+4X6=X79
XX22+89=X2XX
Output for the Sample Input
5
NA
1",Java,"import java.util.*;

public class Main {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        
        while (sc.hasNextLine()) {
            String line = sc.nextLine().trim();
            if (line.isEmpty()) break;
            
            String result = solve(line);
            System.out.println(result);
        }
        sc.close();
    }
    
    static String solve(String equation) {
        String[] parts = equation.split(""="");
        String leftSide = parts[0];
        String rightSide = parts[1];
        
        String[] addends = leftSide.split(""\\+"");
        String num1Pattern = addends[0];
        String num2Pattern = addends[1];
        String sumPattern = rightSide;
        
        int validDigit = -1;
        int validCount = 0;
        
        for (int x = 0; x <= 9; x++) {
            String num1Str = num1Pattern.replace('X', (char)('0' + x));
            String num2Str = num2Pattern.replace('X', (char)('0' + x));
            String sumStr = sumPattern.replace('X', (char)('0' + x));
            
            // Check for leading zeros
            if (num1Str.length() > 1 && num1Str.charAt(0) == '0') continue;
            if (num2Str.length() > 1 && num2Str.charAt(0) == '0') continue;
            if (sumStr.length() > 1 && sumStr.charAt(0) == '0') continue;
            
            try {
                long num1 = Long.parseLong(num1Str);
                long num2 = Long.parseLong(num2Str);
                long sum = Long.parseLong(sumStr);
                
                if (num1 + num2 == sum) {
                    validDigit = x;
                    validCount++;
                }
            } catch (NumberFormatException e) {
                // Skip invalid numbers
            }
        }
        
        if (validCount == 1) {
            return String.valueOf(validDigit);
        } else {
            return ""NA"";
        }
    }
}
",0
p00110,"覆面算
数式の一部を隠してしまって、隠した数字を探す問題を覆面算といいます。今回は、数式の中のある数字のいくつかを X で隠してしまった式を扱います。以下の数式を入力して、結果を出力するプログラムを作成してください。
数式
「数字列 + 数字列 = 数字列」の形で、1 行の単純な足し算式です。
「数字列」は、数字 0 から 9 と文字 X の並びです。
2 桁以上の「数字列」の左端の数字は 0 ではないものとします。
X は、数式全体の中で必ず 1 つ以上含まれます。
結果
覆面算の答えです。数式が成り立つ様な X の値で 0 ~ 9 のどれか 1 つです。2 つ以上の答えはないものとします。
答えがない場合、結果は“NA”としてください。
Input
複数のデータセットが与えられます。各データセットとして、X を 1 つ以上含む足し算式(空白を含まない 126 文字以内の文字列) が１行に与えられます。データセットの数は 150 を超えません。
Output
各データセットについて、覆面算の結果を１行に出力してください。数字 0 ~ 9 または NA を出力してください。
Sample Input
123+4X6=X79
12X+4X6=X79
XX22+89=X2XX
Output for the Sample Input
5
NA
1",Java,"import java.util.*;

public class Main{
    Scanner in = new Scanner(System.in);

    void solve(){
        String s;
        while(in.hasNextLine()){
            s = in.nextLine();
            calc(s);
        }
    }
    void calc(String str){
        String a = str.substring(0, str.indexOf('+'));
        String b = str.substring(str.indexOf('+') + 1, str.indexOf('='));
        String c = str.substring(str.indexOf('=') + 1);
        for(int i = 0; i < 10; i++){
            String left = sum(a, b, i);
            String right = c.replace(""X"", String.valueOf(i));
            if(left.equals(right)){
                System.out.println(i);
                return;
            }
        }
        System.out.println(""NA"");
    }

    String sum(String a, String b, int rep){
        StringBuilder ans  = new StringBuilder();
        a = new StringBuilder(a.replace(""X"", String.valueOf(rep))).reverse().toString();
        b = new StringBuilder(b.replace(""X"", String.valueOf(rep))).reverse().toString();

        int t = 0;
        for(int i = 0; i < Math.max(a.length(), b.length()); i++){
            int x = i < a.length() ? a.charAt(i) - '0' : 0;
            int y = i < b.length() ? b.charAt(i) - '0' : 0;
            ans.append(String.valueOf((x + y + t) % 10));
            t = (x + y + t) / 10;
        }

        if(t != 0){
            ans.append(String.valueOf(t));
        }

        return ans.reverse().toString();
    }
    
    public static void main(String[] args){
        new Main().solve();    
    }
}",1
p00110,"覆面算
数式の一部を隠してしまって、隠した数字を探す問題を覆面算といいます。今回は、数式の中のある数字のいくつかを X で隠してしまった式を扱います。以下の数式を入力して、結果を出力するプログラムを作成してください。
数式
「数字列 + 数字列 = 数字列」の形で、1 行の単純な足し算式です。
「数字列」は、数字 0 から 9 と文字 X の並びです。
2 桁以上の「数字列」の左端の数字は 0 ではないものとします。
X は、数式全体の中で必ず 1 つ以上含まれます。
結果
覆面算の答えです。数式が成り立つ様な X の値で 0 ~ 9 のどれか 1 つです。2 つ以上の答えはないものとします。
答えがない場合、結果は“NA”としてください。
Input
複数のデータセットが与えられます。各データセットとして、X を 1 つ以上含む足し算式(空白を含まない 126 文字以内の文字列) が１行に与えられます。データセットの数は 150 を超えません。
Output
各データセットについて、覆面算の結果を１行に出力してください。数字 0 ~ 9 または NA を出力してください。
Sample Input
123+4X6=X79
12X+4X6=X79
XX22+89=X2XX
Output for the Sample Input
5
NA
1",Python,"import sys

def solve(equation):
    parts = equation.split('=')
    left_parts = parts[0].split('+')
    num1 = left_parts[0]
    num2 = left_parts[1]
    result = parts[1]
    
    for digit in range(10):
        digit_str = str(digit)
        
        # Replace X with the digit
        n1 = num1.replace('X', digit_str)
        n2 = num2.replace('X', digit_str)
        res = result.replace('X', digit_str)
        
        # Check for leading zeros (except for single digit numbers)
        if len(n1) > 1 and n1[0] == '0':
            continue
        if len(n2) > 1 and n2[0] == '0':
            continue
        if len(res) > 1 and res[0] == '0':
            continue
        
        # Check if the equation holds
        try:
            if int(n1) + int(n2) == int(res):
                return digit_str
        except:
            continue
    
    return ""NA""

for line in sys.stdin:
    line = line.strip()
    if line:
        print(solve(line))
",0
p00110,"覆面算
数式の一部を隠してしまって、隠した数字を探す問題を覆面算といいます。今回は、数式の中のある数字のいくつかを X で隠してしまった式を扱います。以下の数式を入力して、結果を出力するプログラムを作成してください。
数式
「数字列 + 数字列 = 数字列」の形で、1 行の単純な足し算式です。
「数字列」は、数字 0 から 9 と文字 X の並びです。
2 桁以上の「数字列」の左端の数字は 0 ではないものとします。
X は、数式全体の中で必ず 1 つ以上含まれます。
結果
覆面算の答えです。数式が成り立つ様な X の値で 0 ~ 9 のどれか 1 つです。2 つ以上の答えはないものとします。
答えがない場合、結果は“NA”としてください。
Input
複数のデータセットが与えられます。各データセットとして、X を 1 つ以上含む足し算式(空白を含まない 126 文字以内の文字列) が１行に与えられます。データセットの数は 150 を超えません。
Output
各データセットについて、覆面算の結果を１行に出力してください。数字 0 ~ 9 または NA を出力してください。
Sample Input
123+4X6=X79
12X+4X6=X79
XX22+89=X2XX
Output for the Sample Input
5
NA
1",Python,"while True:
    try:
        string = raw_input()
    except EOFError:
        break
    for i in range(10):
        translated = string.replace(""X"",str(i))
        left,right = translated.split(""="")
        first,second = left.split(""+"")
        if i == 0 and any((first[0]==""0"",second[0]==""0"",right[0]==""0"")):
            continue
        elif int(first) + int(second) == int(right):
            print i
            break
    else:
        print ""NA""",1
p00111,"博士の暗号
博  士 : ?D-C'KOPUA
ピーター : どうしたんですか、デビッド博士? わけのわからないことを叫ぶのにはもう慣れましたが、
        今日は文章にすらなっていませんよ。
博  士 : ほれ。
ピーター : なんですか? この表は......ああ、予選の問題にこんなのがありました。表を使って文字を置き換え
       ると文字数が減るんですよね。まさか予選と本選で同じ問題を出して手を抜こうって気じゃないでし
       ょうね。
博  士 : 逆じゃよ。
ピーター : 逆? なるほど、今度は短くした文字列を元に戻そうって問題ですか。ということは「?D-C'KOPUA」の
      文字を、この表を使って「文字」から「符号」に置きかえるんですね......できましたよ。
11111 00011 11101 00010 11110 01010 01110 01111 10100 00000
博  士 : うむ。次はこれじゃ。
ピーター : そうそう、こんな表もありましたね。これを逆に使うんだから「符号」から「文字」に置き換えればいい
          んですね。でも、最初は「11111」ですが表にありませんよ?
博     士 : そういうときは、もっと短くするか、後ろとつなげるかしてみるのだよ。
ピ ー タ ー : じゃあ短くして......あ、 「111」ならあります。じゃあ最初は「P」ですね。そうすると残りは「11」ですが、
            これはぴったり合うのがないから次の「00011」から 1 文字借りて「110」にすればいいんですね。
博     士 : そうそう。つまり「E」だね。
ピ ー タ ー : それで残るのが「0011」なので、これも次から借りて「00111」にして「T」と......。全部できました。最
          後の「0000」は捨てちゃえばいいんですよね?
博     士 : そうじゃ、よろしい。次はこれじゃ。
?D-C'?-C'-LMGZN?FNJKN- WEYN?P'QMRWLPZLKKTPOVRGDI
博     士 : さらにこれじゃ。
?P'QNPY?IXX?IXXK.BI -G?R'RPP'RPOVWDMW?SWUVG'-LCMGQ
博     士 : 仕上げにこうじゃ。
?P'QMDUEQ GADKOQ ?SWUVG'-LCMG?X?IGX,PUL.?UL.VNQQI
ピ ー タ ー : しっかし面倒だなあ。博士、今度は自分でプログラムを作って下さいよ。
ということで、博士のかわりに、上の文章を置き換えるプログラムを作成してください。
Input
複数のデータセットが与えられます。各データセットとして、１つの文字列（表に含まれる文字からなる 200 文字以下の文字列）が１行に与えられます。入力の終わりまで処理してください。データセットの数は 200 を超えません。
Output
各データセットごとに、変換後の文字列を１行に出力してください。
Sample Input
?D-C'KOPUA
Output for the Sample Input
PETER POTTER",C,"#include <stdio.h>
#include <string.h>
#include <stdlib.h>

char* char_to_code[] = {
    ""00000"", ""10000"", ""01000"", ""00100"", ""00010"", ""11000"", ""10100"", ""01100"",
    ""00110"", ""10010"", ""01010"", ""11100"", ""10110"", ""01110"", ""11010"", ""11110"",
    ""00001"", ""10001"", ""01001"", ""00101"", ""10101"", ""01101"", ""11001"", ""10011"",
    ""01011"", ""11101"", ""10111"", ""01111"", ""11011"", ""11111"", ""00011"", ""00111""
};

char chars[] = "" ABCDEFGHIJKLMNOPQRSTUVWXYZ'-.,?"";

char* code_to_char[] = {
    ""0"", ""100"", ""10"", ""1"", ""1010"", ""10100"", ""101000"", ""101"",
    ""110"", ""1100"", ""11"", ""10101"", ""101010"", ""10110"", ""101011"", ""101100"",
    ""1011"", ""10111"", ""1000"", ""1001"", ""100100"", ""100101"", ""10010"", ""100110"",
    ""100111"", ""10011"", ""101000"", ""101001"", ""101010"", ""101011"", ""11"", ""111""
};

int main() {
    char input[256];
    
    while (fgets(input, sizeof(input), stdin)) {
        int len = strlen(input);
        if (len > 0 && input[len-1] == '\n') {
            input[len-1] = '\0';
            len--;
        }
        
        char binary[10000] = """";
        
        for (int i = 0; i < len; i++) {
            char c = input[i];
            int found = 0;
            for (int j = 0; j < 32; j++) {
                if (chars[j] == c) {
                    strcat(binary, char_to_code[j]);
                    found = 1;
                    break;
                }
            }
        }
        
        char result[1000] = """";
        int pos = 0;
        int binlen = strlen(binary);
        
        while (pos < binlen) {
            int found = 0;
            for (int trylen = 1; trylen <= binlen - pos && trylen <= 10; trylen++) {
                char temp[20];
                strncpy(temp, binary + pos, trylen);
                temp[trylen] = '\0';
                
                for (int j = 0; j < 32; j++) {
                    if (strcmp(code_to_char[j], temp) == 0) {
                        int resultlen = strlen(result);
                        result[resultlen] = chars[j];
                        result[resultlen + 1] = '\0';
                        pos += trylen;
                        found = 1;
                        break;
                    }
                }
                if (found) break;
            }
            
            if (!found) {
                pos++;
            }
        }
        
        printf(""%s\n"", result);
    }
    
    return 0;
}
",0
p00111,"博士の暗号
博  士 : ?D-C'KOPUA
ピーター : どうしたんですか、デビッド博士? わけのわからないことを叫ぶのにはもう慣れましたが、
        今日は文章にすらなっていませんよ。
博  士 : ほれ。
ピーター : なんですか? この表は......ああ、予選の問題にこんなのがありました。表を使って文字を置き換え
       ると文字数が減るんですよね。まさか予選と本選で同じ問題を出して手を抜こうって気じゃないでし
       ょうね。
博  士 : 逆じゃよ。
ピーター : 逆? なるほど、今度は短くした文字列を元に戻そうって問題ですか。ということは「?D-C'KOPUA」の
      文字を、この表を使って「文字」から「符号」に置きかえるんですね......できましたよ。
11111 00011 11101 00010 11110 01010 01110 01111 10100 00000
博  士 : うむ。次はこれじゃ。
ピーター : そうそう、こんな表もありましたね。これを逆に使うんだから「符号」から「文字」に置き換えればいい
          んですね。でも、最初は「11111」ですが表にありませんよ?
博     士 : そういうときは、もっと短くするか、後ろとつなげるかしてみるのだよ。
ピ ー タ ー : じゃあ短くして......あ、 「111」ならあります。じゃあ最初は「P」ですね。そうすると残りは「11」ですが、
            これはぴったり合うのがないから次の「00011」から 1 文字借りて「110」にすればいいんですね。
博     士 : そうそう。つまり「E」だね。
ピ ー タ ー : それで残るのが「0011」なので、これも次から借りて「00111」にして「T」と......。全部できました。最
          後の「0000」は捨てちゃえばいいんですよね?
博     士 : そうじゃ、よろしい。次はこれじゃ。
?D-C'?-C'-LMGZN?FNJKN- WEYN?P'QMRWLPZLKKTPOVRGDI
博     士 : さらにこれじゃ。
?P'QNPY?IXX?IXXK.BI -G?R'RPP'RPOVWDMW?SWUVG'-LCMGQ
博     士 : 仕上げにこうじゃ。
?P'QMDUEQ GADKOQ ?SWUVG'-LCMG?X?IGX,PUL.?UL.VNQQI
ピ ー タ ー : しっかし面倒だなあ。博士、今度は自分でプログラムを作って下さいよ。
ということで、博士のかわりに、上の文章を置き換えるプログラムを作成してください。
Input
複数のデータセットが与えられます。各データセットとして、１つの文字列（表に含まれる文字からなる 200 文字以下の文字列）が１行に与えられます。入力の終わりまで処理してください。データセットの数は 200 を超えません。
Output
各データセットごとに、変換後の文字列を１行に出力してください。
Sample Input
?D-C'KOPUA
Output for the Sample Input
PETER POTTER",C,"#include <stdio.h>
#include <string.h>
#include <stdlib.h>

int i,stk,x[3];
char tex[1000000],code[1000000];
char encode[64][6]={
""11010"",
"""",
"""",
"""",
"""",
"""",
"""",
""11110"",
"""",
"""",
"""",
"""",
""11100"",
""11101"",
""11011"",
"""",
"""",
"""",
"""",
"""",
"""",
"""",
"""",
"""",
"""",
"""",
"""",
"""",
"""",
"""",
"""",
""11111"",
"""",
""00000"",
""00001"",
""00010"",
""00011"",
""00100"",
""00101"",
""00110"",
""00111"",
""01000"",
""01001"",
""01010"",
""01011"",
""01100"",
""01101"",
""01110"",
""01111"",
""10000"",
""10001"",
""10010"",
""10011"",
""10100"",
""10101"",
""10110"",
""10111"",
""11000"",
""11001"",
"""",
"""",
"""",
"""",
""""}
,decode[100000000];

int main(){
	decode[212]=' ';
	decode[111111]='\'';
	decode[111122]=',';
	decode[21121112]='-';
	decode[121112]='.';
	decode[111112]='?';
	decode[211212]='A';
	decode[21122121]='B';
	decode[1212]='C';
	decode[1112]='D';
	decode[221]='E';
	decode[12112]='F';
	decode[21122122]='G';
	decode[121111]='H';
	decode[1222]='I';
	decode[21122111]='J';
	decode[1221]='K';
	decode[11211]='L';
	decode[21122112]='M';
	decode[21122221]='N';
	decode[11212]='O';
	decode[222]='P';
	decode[21122222]='Q';
	decode[2111]='R';
	decode[11221]='S';
	decode[11222]='T';
	decode[21122211]='U';
	decode[21122212]='V';
	decode[111121]='W';
	decode[21121121]='X';
	decode[21121122]='Y';
	decode[21121111]='Z';

	while(fgets(tex,900000,stdin)!=NULL){
		strcpy(code,"""");
		for(i=0;i<strlen(tex);i++){
			strcat(code,encode[tex[i]-' ']);
		}
		stk=0;
		for(i=0;i<strlen(code);i++){
			stk=stk*10+code[i]-'0'+1;
			if(decode[stk]>0){
				printf(""%c"",decode[stk]);
				stk=0;
			}
		}
		printf(""%\n"");
	}
	return 0;
}",1
p00111,"博士の暗号
博  士 : ?D-C'KOPUA
ピーター : どうしたんですか、デビッド博士? わけのわからないことを叫ぶのにはもう慣れましたが、
        今日は文章にすらなっていませんよ。
博  士 : ほれ。
ピーター : なんですか? この表は......ああ、予選の問題にこんなのがありました。表を使って文字を置き換え
       ると文字数が減るんですよね。まさか予選と本選で同じ問題を出して手を抜こうって気じゃないでし
       ょうね。
博  士 : 逆じゃよ。
ピーター : 逆? なるほど、今度は短くした文字列を元に戻そうって問題ですか。ということは「?D-C'KOPUA」の
      文字を、この表を使って「文字」から「符号」に置きかえるんですね......できましたよ。
11111 00011 11101 00010 11110 01010 01110 01111 10100 00000
博  士 : うむ。次はこれじゃ。
ピーター : そうそう、こんな表もありましたね。これを逆に使うんだから「符号」から「文字」に置き換えればいい
          んですね。でも、最初は「11111」ですが表にありませんよ?
博     士 : そういうときは、もっと短くするか、後ろとつなげるかしてみるのだよ。
ピ ー タ ー : じゃあ短くして......あ、 「111」ならあります。じゃあ最初は「P」ですね。そうすると残りは「11」ですが、
            これはぴったり合うのがないから次の「00011」から 1 文字借りて「110」にすればいいんですね。
博     士 : そうそう。つまり「E」だね。
ピ ー タ ー : それで残るのが「0011」なので、これも次から借りて「00111」にして「T」と......。全部できました。最
          後の「0000」は捨てちゃえばいいんですよね?
博     士 : そうじゃ、よろしい。次はこれじゃ。
?D-C'?-C'-LMGZN?FNJKN- WEYN?P'QMRWLPZLKKTPOVRGDI
博     士 : さらにこれじゃ。
?P'QNPY?IXX?IXXK.BI -G?R'RPP'RPOVWDMW?SWUVG'-LCMGQ
博     士 : 仕上げにこうじゃ。
?P'QMDUEQ GADKOQ ?SWUVG'-LCMG?X?IGX,PUL.?UL.VNQQI
ピ ー タ ー : しっかし面倒だなあ。博士、今度は自分でプログラムを作って下さいよ。
ということで、博士のかわりに、上の文章を置き換えるプログラムを作成してください。
Input
複数のデータセットが与えられます。各データセットとして、１つの文字列（表に含まれる文字からなる 200 文字以下の文字列）が１行に与えられます。入力の終わりまで処理してください。データセットの数は 200 を超えません。
Output
各データセットごとに、変換後の文字列を１行に出力してください。
Sample Input
?D-C'KOPUA
Output for the Sample Input
PETER POTTER",Java,"import java.util.*;

public class Main {
    static Map<Character, String> charToCode = new HashMap<>();
    static Map<String, Character> codeToChar = new HashMap<>();
    
    static {
        // First table (char to code)
        charToCode.put('A', ""00000"");
        charToCode.put('B', ""0001"");
        charToCode.put('C', ""0010"");
        charToCode.put('D', ""0011"");
        charToCode.put('E', ""110"");
        charToCode.put('F', ""1000"");
        charToCode.put('G', ""1001"");
        charToCode.put('H', ""1010"");
        charToCode.put('I', ""1011"");
        charToCode.put('J', ""0100"");
        charToCode.put('K', ""0101"");
        charToCode.put('L', ""0110"");
        charToCode.put('M', ""0111"");
        charToCode.put('N', ""10000"");
        charToCode.put('O', ""10001"");
        charToCode.put('P', ""111"");
        charToCode.put('Q', ""10010"");
        charToCode.put('R', ""10011"");
        charToCode.put('S', ""10100"");
        charToCode.put('T', ""10101"");
        charToCode.put('U', ""10110"");
        charToCode.put('V', ""10111"");
        charToCode.put('W', ""11000"");
        charToCode.put('X', ""11001"");
        charToCode.put('Y', ""11010"");
        charToCode.put('Z', ""11011"");
        charToCode.put(' ', ""11100"");
        charToCode.put('.', ""11101"");
        charToCode.put(',', ""11110"");
        charToCode.put('-', ""11111"");
        charToCode.put('\'', ""01010"");
        charToCode.put('?', ""01011"");
        
        // Second table (code to char)
        codeToChar.put(""00"", 'A');
        codeToChar.put(""0100"", 'B');
        codeToChar.put(""0101"", 'C');
        codeToChar.put(""0110"", 'D');
        codeToChar.put(""110"", 'E');
        codeToChar.put(""01110"", 'F');
        codeToChar.put(""01111"", 'G');
        codeToChar.put(""1000"", 'H');
        codeToChar.put(""1001"", 'I');
        codeToChar.put(""10100"", 'J');
        codeToChar.put(""10101"", 'K');
        codeToChar.put(""10110"", 'L');
        codeToChar.put(""10111"", 'M');
        codeToChar.put(""1011"", 'N');
        codeToChar.put(""01010"", 'O');
        codeToChar.put(""111"", 'P');
        codeToChar.put(""01011"", 'Q');
        codeToChar.put(""1100"", 'R');
        codeToChar.put(""1101"", 'S');
        codeToChar.put(""00111"", 'T');
        codeToChar.put(""1110"", 'U');
        codeToChar.put(""11110"", 'V');
        codeToChar.put(""11111"", 'W');
        codeToChar.put(""10010"", 'X');
        codeToChar.put(""10011"", 'Y');
        codeToChar.put(""01000"", 'Z');
        codeToChar.put(""01001"", ' ');
        codeToChar.put(""10000"", '.');
        codeToChar.put(""10001"", ',');
        codeToChar.put(""0010"", '-');
        codeToChar.put(""0011"", '\'');
    }
    
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        while (sc.hasNextLine()) {
            String line = sc.nextLine();
            if (line.isEmpty()) break;
            
            // Step 1: Convert each character to code
            StringBuilder binary = new StringBuilder();
            for (char c : line.toCharArray()) {
                if (charToCode.containsKey(c)) {
                    binary.append(charToCode.get(c));
                }
            }
            
            // Step 2: Decode using second table
            StringBuilder result = new StringBuilder();
            int i = 0;
            while (i < binary.length()) {
                boolean found = false;
                for (int len = 1; len <= 5 && i + len <= binary.length(); len++) {
                    String sub = binary.substring(i, i + len);
                    if (codeToChar.containsKey(sub)) {
                        result.append(codeToChar.get(sub));
                        i += len;
                        found = true;
                        break;
                    }
                }
                if (!found) {
                    i++;
                }
            }
            
            System.out.println(result.toString());
        }
        sc.close();
    }
}
",0
p00111,"博士の暗号
博  士 : ?D-C'KOPUA
ピーター : どうしたんですか、デビッド博士? わけのわからないことを叫ぶのにはもう慣れましたが、
        今日は文章にすらなっていませんよ。
博  士 : ほれ。
ピーター : なんですか? この表は......ああ、予選の問題にこんなのがありました。表を使って文字を置き換え
       ると文字数が減るんですよね。まさか予選と本選で同じ問題を出して手を抜こうって気じゃないでし
       ょうね。
博  士 : 逆じゃよ。
ピーター : 逆? なるほど、今度は短くした文字列を元に戻そうって問題ですか。ということは「?D-C'KOPUA」の
      文字を、この表を使って「文字」から「符号」に置きかえるんですね......できましたよ。
11111 00011 11101 00010 11110 01010 01110 01111 10100 00000
博  士 : うむ。次はこれじゃ。
ピーター : そうそう、こんな表もありましたね。これを逆に使うんだから「符号」から「文字」に置き換えればいい
          んですね。でも、最初は「11111」ですが表にありませんよ?
博     士 : そういうときは、もっと短くするか、後ろとつなげるかしてみるのだよ。
ピ ー タ ー : じゃあ短くして......あ、 「111」ならあります。じゃあ最初は「P」ですね。そうすると残りは「11」ですが、
            これはぴったり合うのがないから次の「00011」から 1 文字借りて「110」にすればいいんですね。
博     士 : そうそう。つまり「E」だね。
ピ ー タ ー : それで残るのが「0011」なので、これも次から借りて「00111」にして「T」と......。全部できました。最
          後の「0000」は捨てちゃえばいいんですよね?
博     士 : そうじゃ、よろしい。次はこれじゃ。
?D-C'?-C'-LMGZN?FNJKN- WEYN?P'QMRWLPZLKKTPOVRGDI
博     士 : さらにこれじゃ。
?P'QNPY?IXX?IXXK.BI -G?R'RPP'RPOVWDMW?SWUVG'-LCMGQ
博     士 : 仕上げにこうじゃ。
?P'QMDUEQ GADKOQ ?SWUVG'-LCMG?X?IGX,PUL.?UL.VNQQI
ピ ー タ ー : しっかし面倒だなあ。博士、今度は自分でプログラムを作って下さいよ。
ということで、博士のかわりに、上の文章を置き換えるプログラムを作成してください。
Input
複数のデータセットが与えられます。各データセットとして、１つの文字列（表に含まれる文字からなる 200 文字以下の文字列）が１行に与えられます。入力の終わりまで処理してください。データセットの数は 200 を超えません。
Output
各データセットごとに、変換後の文字列を１行に出力してください。
Sample Input
?D-C'KOPUA
Output for the Sample Input
PETER POTTER",Java,"import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.HashMap;

public class Main {

	static final HashMap<Character, String> c1 = new HashMap<Character, String>(32) {
		{
			put('A', ""00000"");
			put('B', ""00001"");
			put('C', ""00010"");
			put('D', ""00011"");
			put('E', ""00100"");
			put('F', ""00101"");
			put('G', ""00110"");
			put('H', ""00111"");
			put('I', ""01000"");
			put('J', ""01001"");
			put('K', ""01010"");
			put('L', ""01011"");
			put('M', ""01100"");
			put('N', ""01101"");
			put('O', ""01110"");
			put('P', ""01111"");
			put('Q', ""10000"");
			put('R', ""10001"");
			put('S', ""10010"");
			put('T', ""10011"");
			put('U', ""10100"");
			put('V', ""10101"");
			put('W', ""10110"");
			put('X', ""10111"");
			put('Y', ""11000"");
			put('Z', ""11001"");
			put(' ', ""11010"");
			put('.', ""11011"");
			put(',', ""11100"");
			put('-', ""11101"");
			put('\'', ""11110"");
			put('?', ""11111"");
		}
	};

	static final HashMap<String, Character> c2 = new HashMap<String, Character>(32) {
		{
			put(""101"", ' ');
			put(""000000"", '\'');
			put(""000011"", ',');
			put(""10010001"", '-');
			put(""010001"", '.');
			put(""000001"", '?');
			put(""100101"", 'A');
			put(""10011010"", 'B');
			put(""0101"", 'C');
			put(""0001"", 'D');
			put(""110"", 'E');
			put(""01001"", 'F');
			put(""10011011"", 'G');
			put(""010000"", 'H');
			put(""0111"", 'I');
			put(""10011000"", 'J');
			put(""0110"", 'K');
			put(""00100"", 'L');
			put(""10011001"", 'M');
			put(""10011110"", 'N');
			put(""00101"", 'O');
			put(""111"", 'P');
			put(""10011111"", 'Q');
			put(""1000"", 'R');
			put(""00110"", 'S');
			put(""00111"", 'T');
			put(""10011100"", 'U');
			put(""10011101"", 'V');
			put(""000010"", 'W');
			put(""10010010"", 'X');
			put(""10010011"", 'Y');
			put(""10010000"", 'Z');
		}
	};

	public static void main(String[] args) throws IOException {

		BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
		String line = """";

		while ((line = br.readLine()) != null) {
			if (line.isEmpty()) {
				System.out.println("""");
				continue;
			}

			StringBuilder sb1, sb2;
			sb1 = new StringBuilder();
			sb2 = new StringBuilder();
			//
			for (char c : line.toCharArray()) {
				sb1.append(c1.get(c));
			}
			//
			String line2 = sb1.toString();
			for (int i = 0; ; ) {
				char c = 0;
				for (int j = 3; j < 9 && i + j < line2.length(); j++) {
					if (c2.containsKey(line2.substring(i, i + j))) {
						c = c2.get(line2.substring(i, i + j));
						sb2.append(c);
						i += j;
						break;
					}
				}
				if (c == 0) {
					break;
				}
			}
			System.out.println(sb2.toString());
		}
	}
}",1
p00111,"博士の暗号
博  士 : ?D-C'KOPUA
ピーター : どうしたんですか、デビッド博士? わけのわからないことを叫ぶのにはもう慣れましたが、
        今日は文章にすらなっていませんよ。
博  士 : ほれ。
ピーター : なんですか? この表は......ああ、予選の問題にこんなのがありました。表を使って文字を置き換え
       ると文字数が減るんですよね。まさか予選と本選で同じ問題を出して手を抜こうって気じゃないでし
       ょうね。
博  士 : 逆じゃよ。
ピーター : 逆? なるほど、今度は短くした文字列を元に戻そうって問題ですか。ということは「?D-C'KOPUA」の
      文字を、この表を使って「文字」から「符号」に置きかえるんですね......できましたよ。
11111 00011 11101 00010 11110 01010 01110 01111 10100 00000
博  士 : うむ。次はこれじゃ。
ピーター : そうそう、こんな表もありましたね。これを逆に使うんだから「符号」から「文字」に置き換えればいい
          んですね。でも、最初は「11111」ですが表にありませんよ?
博     士 : そういうときは、もっと短くするか、後ろとつなげるかしてみるのだよ。
ピ ー タ ー : じゃあ短くして......あ、 「111」ならあります。じゃあ最初は「P」ですね。そうすると残りは「11」ですが、
            これはぴったり合うのがないから次の「00011」から 1 文字借りて「110」にすればいいんですね。
博     士 : そうそう。つまり「E」だね。
ピ ー タ ー : それで残るのが「0011」なので、これも次から借りて「00111」にして「T」と......。全部できました。最
          後の「0000」は捨てちゃえばいいんですよね?
博     士 : そうじゃ、よろしい。次はこれじゃ。
?D-C'?-C'-LMGZN?FNJKN- WEYN?P'QMRWLPZLKKTPOVRGDI
博     士 : さらにこれじゃ。
?P'QNPY?IXX?IXXK.BI -G?R'RPP'RPOVWDMW?SWUVG'-LCMGQ
博     士 : 仕上げにこうじゃ。
?P'QMDUEQ GADKOQ ?SWUVG'-LCMG?X?IGX,PUL.?UL.VNQQI
ピ ー タ ー : しっかし面倒だなあ。博士、今度は自分でプログラムを作って下さいよ。
ということで、博士のかわりに、上の文章を置き換えるプログラムを作成してください。
Input
複数のデータセットが与えられます。各データセットとして、１つの文字列（表に含まれる文字からなる 200 文字以下の文字列）が１行に与えられます。入力の終わりまで処理してください。データセットの数は 200 を超えません。
Output
各データセットごとに、変換後の文字列を１行に出力してください。
Sample Input
?D-C'KOPUA
Output for the Sample Input
PETER POTTER",Python,"import sys

# First conversion table (character to code)
char_to_code = {
    'A': '00000', 'B': '10000', 'C': '01000', 'D': '00100', 'E': '00010',
    'F': '10100', 'G': '01100', 'H': '00110', 'I': '10010', 'J': '01010',
    'K': '00001', 'L': '10001', 'M': '01001', 'N': '00101', 'O': '10101',
    'P': '01101', 'Q': '00011', 'R': '10011', 'S': '01011', 'T': '11000',
    'U': '10110', 'V': '01110', 'W': '00111', 'X': '10111', 'Y': '01111',
    'Z': '11001', ""'"": '11010', ',': '11011', '-': '11100', '.': '11101',
    '?': '11110', ' ': '11111'
}

# Second conversion table (code to character)
code_to_char = {
    '00': 'A', '0100': 'B', '0000': 'C', '100': 'D', '110': 'E',
    '1000': 'F', '0110': 'G', '1110': 'H', '10': 'I', '0010': 'J',
    '0001': 'K', '1100': 'L', '0101': 'M', '01': 'N', '0011': 'O',
    '111': 'P', '1010': 'Q', '1001': 'R', '1101': 'S', '11': 'T',
    '1011': 'U', '0111': 'V', '011': 'W', '1111': 'X', '0001': 'Y',
    '10100': 'Z', '10101': ""'"", '10110': ',', '10111': '-', '11000': '.',
    '11001': '?', '0000': ' '
}

# Fix the duplicate keys issue - need to check which mapping is correct
code_to_char = {
    '00': 'A', '0100': 'B', '0000': 'C', '100': 'D', '110': 'E',
    '1000': 'F', '0110': 'G', '1110': 'H', '10': 'I', '0010': 'J',
    '0001': 'K', '1100': 'L', '0101': 'M', '01': 'N', '0011': 'O',
    '111': 'P', '1010': 'Q', '1001': 'R', '1101': 'S', '11': 'T',
    '1011': 'U', '0111': 'V', '011': 'W', '1111': 'X', '10100': 'Z',
    '10101': ""'"", '10110': ',', '10111': '-', '11000': '.', '11001': '?'
}

def decode(binary_str):
    result = []
    i = 0
    while i < len(binary_str):
        found = False
        # Try lengths from 2 to 5
        for length in range(2, 6):
            if i + length <= len(binary_str):
                substr = binary_str[i:i+length]
                if substr in code_to_char:
                    result.append(code_to_char[substr])
                    i += length
                    found = True
                    break
        if not found:
            i += 1
    return ''.join(result)

for line in sys.stdin:
    line = line.strip()
    if not line:
        continue
    
    # Step 1: Convert characters to binary using first table
    binary = ''
    for char in line:
        if char in char_to_code:
            binary += char_to_code[char]
    
    # Step 2: Convert binary to characters using second table
    result = decode(binary)
    print(result)
",0
p00111,"博士の暗号
博  士 : ?D-C'KOPUA
ピーター : どうしたんですか、デビッド博士? わけのわからないことを叫ぶのにはもう慣れましたが、
        今日は文章にすらなっていませんよ。
博  士 : ほれ。
ピーター : なんですか? この表は......ああ、予選の問題にこんなのがありました。表を使って文字を置き換え
       ると文字数が減るんですよね。まさか予選と本選で同じ問題を出して手を抜こうって気じゃないでし
       ょうね。
博  士 : 逆じゃよ。
ピーター : 逆? なるほど、今度は短くした文字列を元に戻そうって問題ですか。ということは「?D-C'KOPUA」の
      文字を、この表を使って「文字」から「符号」に置きかえるんですね......できましたよ。
11111 00011 11101 00010 11110 01010 01110 01111 10100 00000
博  士 : うむ。次はこれじゃ。
ピーター : そうそう、こんな表もありましたね。これを逆に使うんだから「符号」から「文字」に置き換えればいい
          んですね。でも、最初は「11111」ですが表にありませんよ?
博     士 : そういうときは、もっと短くするか、後ろとつなげるかしてみるのだよ。
ピ ー タ ー : じゃあ短くして......あ、 「111」ならあります。じゃあ最初は「P」ですね。そうすると残りは「11」ですが、
            これはぴったり合うのがないから次の「00011」から 1 文字借りて「110」にすればいいんですね。
博     士 : そうそう。つまり「E」だね。
ピ ー タ ー : それで残るのが「0011」なので、これも次から借りて「00111」にして「T」と......。全部できました。最
          後の「0000」は捨てちゃえばいいんですよね?
博     士 : そうじゃ、よろしい。次はこれじゃ。
?D-C'?-C'-LMGZN?FNJKN- WEYN?P'QMRWLPZLKKTPOVRGDI
博     士 : さらにこれじゃ。
?P'QNPY?IXX?IXXK.BI -G?R'RPP'RPOVWDMW?SWUVG'-LCMGQ
博     士 : 仕上げにこうじゃ。
?P'QMDUEQ GADKOQ ?SWUVG'-LCMG?X?IGX,PUL.?UL.VNQQI
ピ ー タ ー : しっかし面倒だなあ。博士、今度は自分でプログラムを作って下さいよ。
ということで、博士のかわりに、上の文章を置き換えるプログラムを作成してください。
Input
複数のデータセットが与えられます。各データセットとして、１つの文字列（表に含まれる文字からなる 200 文字以下の文字列）が１行に与えられます。入力の終わりまで処理してください。データセットの数は 200 を超えません。
Output
各データセットごとに、変換後の文字列を１行に出力してください。
Sample Input
?D-C'KOPUA
Output for the Sample Input
PETER POTTER",Python,"to_bin = dict(zip([chr(i) for i in range(ord(""A""), ord(""Z"") + 1)] + ["" "", ""."", "","", ""-"", ""'"", ""?""],
                  [bin(i)[2:7].zfill(5) for i in range(2 ** 5)]))
to_chr = {""101"":"" "", ""000000"":""'"", ""000011"":"","", ""10010001"":""-"", ""010001"":""."", ""000001"":""?"", ""100101"":""A"", ""10011010"":""B"",
          ""0101"":""C"", ""0001"":""D"", ""110"":""E"", ""01001"":""F"", ""10011011"":""G"", ""010000"":""H"", ""0111"":""I"", ""10011000"":""J"",
          ""0110"":""K"", ""00100"":""L"", ""10011001"":""M"", ""10011110"":""N"", ""00101"":""O"", ""111"":""P"", ""10011111"":""Q"", ""1000"":""R"",
          ""00110"":""S"", ""00111"":""T"", ""10011100"":""U"", ""10011101"":""V"", ""000010"":""W"", ""10010010"":""X"", ""10010011"":""Y"", ""10010000"":""Z""}

while True:
  try:
    s = input()
  except EOFError:
    break
  bs = """".join([to_bin[c] for c in s])
  ans = """"
  while True:
    length = 9
    for i in range(length):
      if bs[:i] in to_chr:
        ans = ans + to_chr[bs[:i]]
        bs = bs[i:]
        break
    else:
      break
  print(ans)
",1
p00112,"ミルクショップ
鈴木さんは会津地域に新しく搾りたてミルクの移動販売のお店を開きました。その日買い求めに来るお客さんは全員持ち帰るためのボトルを持って既にお店に並んでいて、それ以上増えないものとします。お客さんはそれぞれ1回だけしか注文しません。タンクの蛇口が一つしかないので、一人ずつ順番に販売しなければなりません。そこで、鈴木さんはなるべく並んでいるお客さんの待ち時間を少なくしたいと考えています。
お客さんの人数とお客さんが牛乳を注ぎきるのに要する時間が入力として与えられます。あなたはお客さんの「一人一人の待ち時間の合計」(以下「待ち時間の合計」とする)を最小にするための注文の順序を鈴木さんに代わって調べ、そのときの「待ち時間の合計」を出力して終了するプログラムを作成してください。ただし、お客さんは 10,000 人以下で 1 人あたりに要する時間は 60 分以下とします。
例えば、お客さんの人数が 5 人で、各お客さんが要する時間が順に 2,6,4,3,9 分の場合、そのままの順序だと「待ち時間の合計」は 37 分になります。次の例では、最初の列の順の 2 人目と 3 人目を入れ替えています。この場合、「待ち時間の合計」は 35 分になります。最適な順序だと 31 分で済みます。
待ち時間
1 人目 2 分
0 分
2 人目 6 分
2 分
3 人目 4 分
8 分
4 人目 3 分
12 分
5 人目 9 分
15 分
37 分
← 「待ち時間の合計」
2 人目と 3 人目を入れ替えた例
待ち時間
1 人目 2 分
0 分
2 人目 4 分
2 分
3 人目 6 分
6 分
4 人目 3 分
12 分
5 人目 9 分
15 分
35 分
← 「待ち時間の合計」
Input
複数のデータセットが与えられます。各データセットは以下の形式で与えられます。
n
t
1
t
2
:
t
n
1 行目にお客さんの人数
n
(
n
≤ 10,000) が与えられます。続く
n
行に
i
人目のお客さんが要する時間を表す整数
t
i
(0 ≤
t
i
≤ 60) がそれぞれ１行に与えられます。
入力は１つの 0 を含む行で終わります。データセットの数は 50 を超えません。
Output
各データセットごとに、待ち時間の合計(整数)を１行に出力してください。
Sample Input
5
2
6
4
3
9
0
Output for the Sample Input
31",C,"#include <stdio.h>
#include <stdlib.h>

int compare(const void *a, const void *b) {
    return (*(int*)a - *(int*)b);
}

int main() {
    int n;
    
    while(scanf(""%d"", &n) == 1 && n != 0) {
        int times[10000];
        
        for(int i = 0; i < n; i++) {
            scanf(""%d"", &times[i]);
        }
        
        qsort(times, n, sizeof(int), compare);
        
        long long total_wait = 0;
        long long cumulative = 0;
        
        for(int i = 0; i < n; i++) {
            total_wait += cumulative;
            cumulative += times[i];
        }
        
        printf(""%lld\n"", total_wait);
    }
    
    return 0;
}
",0
p00112,"ミルクショップ
鈴木さんは会津地域に新しく搾りたてミルクの移動販売のお店を開きました。その日買い求めに来るお客さんは全員持ち帰るためのボトルを持って既にお店に並んでいて、それ以上増えないものとします。お客さんはそれぞれ1回だけしか注文しません。タンクの蛇口が一つしかないので、一人ずつ順番に販売しなければなりません。そこで、鈴木さんはなるべく並んでいるお客さんの待ち時間を少なくしたいと考えています。
お客さんの人数とお客さんが牛乳を注ぎきるのに要する時間が入力として与えられます。あなたはお客さんの「一人一人の待ち時間の合計」(以下「待ち時間の合計」とする)を最小にするための注文の順序を鈴木さんに代わって調べ、そのときの「待ち時間の合計」を出力して終了するプログラムを作成してください。ただし、お客さんは 10,000 人以下で 1 人あたりに要する時間は 60 分以下とします。
例えば、お客さんの人数が 5 人で、各お客さんが要する時間が順に 2,6,4,3,9 分の場合、そのままの順序だと「待ち時間の合計」は 37 分になります。次の例では、最初の列の順の 2 人目と 3 人目を入れ替えています。この場合、「待ち時間の合計」は 35 分になります。最適な順序だと 31 分で済みます。
待ち時間
1 人目 2 分
0 分
2 人目 6 分
2 分
3 人目 4 分
8 分
4 人目 3 分
12 分
5 人目 9 分
15 分
37 分
← 「待ち時間の合計」
2 人目と 3 人目を入れ替えた例
待ち時間
1 人目 2 分
0 分
2 人目 4 分
2 分
3 人目 6 分
6 分
4 人目 3 分
12 分
5 人目 9 分
15 分
35 分
← 「待ち時間の合計」
Input
複数のデータセットが与えられます。各データセットは以下の形式で与えられます。
n
t
1
t
2
:
t
n
1 行目にお客さんの人数
n
(
n
≤ 10,000) が与えられます。続く
n
行に
i
人目のお客さんが要する時間を表す整数
t
i
(0 ≤
t
i
≤ 60) がそれぞれ１行に与えられます。
入力は１つの 0 を含む行で終わります。データセットの数は 50 を超えません。
Output
各データセットごとに、待ち時間の合計(整数)を１行に出力してください。
Sample Input
5
2
6
4
3
9
0
Output for the Sample Input
31",C,"#include <stdio.h>

int main(){
  long long int time[10001] = {}, wtime[10001] = {}, min, sum;
  int j, k, n;
  while(scanf(""%d"", &n) && n){
    for(j = 0;j < n;j++)
      scanf(""%lld"", &time[j]);

    for(j = 0;j < n - 1;j++){
      min = j;
      for(k = j + 1;k < n;k++)
	min = time[min] < time[k] ? min : k;
      if(min != j){
	time[min] += time[j];
	time[j] = time[min] - time[j];
	time[min] -= time[j];
      }
    }
    sum = 0;
    for(j = 1;j < n;j++){
      wtime[j] = wtime[j - 1] + time[j - 1];
      sum += wtime[j];
    }
    
    printf(""%lld\n"", sum);
  }
  return 0;
}",1
p00112,"ミルクショップ
鈴木さんは会津地域に新しく搾りたてミルクの移動販売のお店を開きました。その日買い求めに来るお客さんは全員持ち帰るためのボトルを持って既にお店に並んでいて、それ以上増えないものとします。お客さんはそれぞれ1回だけしか注文しません。タンクの蛇口が一つしかないので、一人ずつ順番に販売しなければなりません。そこで、鈴木さんはなるべく並んでいるお客さんの待ち時間を少なくしたいと考えています。
お客さんの人数とお客さんが牛乳を注ぎきるのに要する時間が入力として与えられます。あなたはお客さんの「一人一人の待ち時間の合計」(以下「待ち時間の合計」とする)を最小にするための注文の順序を鈴木さんに代わって調べ、そのときの「待ち時間の合計」を出力して終了するプログラムを作成してください。ただし、お客さんは 10,000 人以下で 1 人あたりに要する時間は 60 分以下とします。
例えば、お客さんの人数が 5 人で、各お客さんが要する時間が順に 2,6,4,3,9 分の場合、そのままの順序だと「待ち時間の合計」は 37 分になります。次の例では、最初の列の順の 2 人目と 3 人目を入れ替えています。この場合、「待ち時間の合計」は 35 分になります。最適な順序だと 31 分で済みます。
待ち時間
1 人目 2 分
0 分
2 人目 6 分
2 分
3 人目 4 分
8 分
4 人目 3 分
12 分
5 人目 9 分
15 分
37 分
← 「待ち時間の合計」
2 人目と 3 人目を入れ替えた例
待ち時間
1 人目 2 分
0 分
2 人目 4 分
2 分
3 人目 6 分
6 分
4 人目 3 分
12 分
5 人目 9 分
15 分
35 分
← 「待ち時間の合計」
Input
複数のデータセットが与えられます。各データセットは以下の形式で与えられます。
n
t
1
t
2
:
t
n
1 行目にお客さんの人数
n
(
n
≤ 10,000) が与えられます。続く
n
行に
i
人目のお客さんが要する時間を表す整数
t
i
(0 ≤
t
i
≤ 60) がそれぞれ１行に与えられます。
入力は１つの 0 を含む行で終わります。データセットの数は 50 を超えません。
Output
各データセットごとに、待ち時間の合計(整数)を１行に出力してください。
Sample Input
5
2
6
4
3
9
0
Output for the Sample Input
31",Java,"import java.util.*;

public class Main {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        
        while (true) {
            int n = sc.nextInt();
            if (n == 0) break;
            
            int[] times = new int[n];
            for (int i = 0; i < n; i++) {
                times[i] = sc.nextInt();
            }
            
            Arrays.sort(times);
            
            int totalWaitTime = 0;
            int currentTime = 0;
            
            for (int i = 0; i < n; i++) {
                totalWaitTime += currentTime;
                currentTime += times[i];
            }
            
            System.out.println(totalWaitTime);
        }
        
        sc.close();
    }
}
",0
p00112,"ミルクショップ
鈴木さんは会津地域に新しく搾りたてミルクの移動販売のお店を開きました。その日買い求めに来るお客さんは全員持ち帰るためのボトルを持って既にお店に並んでいて、それ以上増えないものとします。お客さんはそれぞれ1回だけしか注文しません。タンクの蛇口が一つしかないので、一人ずつ順番に販売しなければなりません。そこで、鈴木さんはなるべく並んでいるお客さんの待ち時間を少なくしたいと考えています。
お客さんの人数とお客さんが牛乳を注ぎきるのに要する時間が入力として与えられます。あなたはお客さんの「一人一人の待ち時間の合計」(以下「待ち時間の合計」とする)を最小にするための注文の順序を鈴木さんに代わって調べ、そのときの「待ち時間の合計」を出力して終了するプログラムを作成してください。ただし、お客さんは 10,000 人以下で 1 人あたりに要する時間は 60 分以下とします。
例えば、お客さんの人数が 5 人で、各お客さんが要する時間が順に 2,6,4,3,9 分の場合、そのままの順序だと「待ち時間の合計」は 37 分になります。次の例では、最初の列の順の 2 人目と 3 人目を入れ替えています。この場合、「待ち時間の合計」は 35 分になります。最適な順序だと 31 分で済みます。
待ち時間
1 人目 2 分
0 分
2 人目 6 分
2 分
3 人目 4 分
8 分
4 人目 3 分
12 分
5 人目 9 分
15 分
37 分
← 「待ち時間の合計」
2 人目と 3 人目を入れ替えた例
待ち時間
1 人目 2 分
0 分
2 人目 4 分
2 分
3 人目 6 分
6 分
4 人目 3 分
12 分
5 人目 9 分
15 分
35 分
← 「待ち時間の合計」
Input
複数のデータセットが与えられます。各データセットは以下の形式で与えられます。
n
t
1
t
2
:
t
n
1 行目にお客さんの人数
n
(
n
≤ 10,000) が与えられます。続く
n
行に
i
人目のお客さんが要する時間を表す整数
t
i
(0 ≤
t
i
≤ 60) がそれぞれ１行に与えられます。
入力は１つの 0 を含む行で終わります。データセットの数は 50 を超えません。
Output
各データセットごとに、待ち時間の合計(整数)を１行に出力してください。
Sample Input
5
2
6
4
3
9
0
Output for the Sample Input
31",Java,"
import java.util.*;
public class Main {
	
	private void doit(){
		Scanner sc = new Scanner(System.in);
		while(true){
			int n = sc.nextInt();
			if(n == 0) break;
			int [] data = new int[n];
			for(int i = 0; i < n; i++){
				data[i] = sc.nextInt();
			
			}
			Arrays.sort(data);
			int [] data2 = new int[n];
			int sum = 0;
			data2[0] = 0;
			for(int i = 1; i < n; i++){
				data2[i] = data2[i-1] + data[i-1];
			}
			
			for(int i = 0; i < n; i++){
				sum += data2[i];
			}
			System.out.println(sum);
		}
	}

	public static void main(String[] args) {
		Main obj = new Main();
		obj.doit();
	}
}",1
p00112,"ミルクショップ
鈴木さんは会津地域に新しく搾りたてミルクの移動販売のお店を開きました。その日買い求めに来るお客さんは全員持ち帰るためのボトルを持って既にお店に並んでいて、それ以上増えないものとします。お客さんはそれぞれ1回だけしか注文しません。タンクの蛇口が一つしかないので、一人ずつ順番に販売しなければなりません。そこで、鈴木さんはなるべく並んでいるお客さんの待ち時間を少なくしたいと考えています。
お客さんの人数とお客さんが牛乳を注ぎきるのに要する時間が入力として与えられます。あなたはお客さんの「一人一人の待ち時間の合計」(以下「待ち時間の合計」とする)を最小にするための注文の順序を鈴木さんに代わって調べ、そのときの「待ち時間の合計」を出力して終了するプログラムを作成してください。ただし、お客さんは 10,000 人以下で 1 人あたりに要する時間は 60 分以下とします。
例えば、お客さんの人数が 5 人で、各お客さんが要する時間が順に 2,6,4,3,9 分の場合、そのままの順序だと「待ち時間の合計」は 37 分になります。次の例では、最初の列の順の 2 人目と 3 人目を入れ替えています。この場合、「待ち時間の合計」は 35 分になります。最適な順序だと 31 分で済みます。
待ち時間
1 人目 2 分
0 分
2 人目 6 分
2 分
3 人目 4 分
8 分
4 人目 3 分
12 分
5 人目 9 分
15 分
37 分
← 「待ち時間の合計」
2 人目と 3 人目を入れ替えた例
待ち時間
1 人目 2 分
0 分
2 人目 4 分
2 分
3 人目 6 分
6 分
4 人目 3 分
12 分
5 人目 9 分
15 分
35 分
← 「待ち時間の合計」
Input
複数のデータセットが与えられます。各データセットは以下の形式で与えられます。
n
t
1
t
2
:
t
n
1 行目にお客さんの人数
n
(
n
≤ 10,000) が与えられます。続く
n
行に
i
人目のお客さんが要する時間を表す整数
t
i
(0 ≤
t
i
≤ 60) がそれぞれ１行に与えられます。
入力は１つの 0 を含む行で終わります。データセットの数は 50 を超えません。
Output
各データセットごとに、待ち時間の合計(整数)を１行に出力してください。
Sample Input
5
2
6
4
3
9
0
Output for the Sample Input
31",Python,"while True:
    n = int(input())
    if n == 0:
        break
    
    times = []
    for _ in range(n):
        times.append(int(input()))
    
    times.sort()
    
    total_wait = 0
    cumulative_time = 0
    
    for t in times:
        total_wait += cumulative_time
        cumulative_time += t
    
    print(total_wait)
",0
p00112,"ミルクショップ
鈴木さんは会津地域に新しく搾りたてミルクの移動販売のお店を開きました。その日買い求めに来るお客さんは全員持ち帰るためのボトルを持って既にお店に並んでいて、それ以上増えないものとします。お客さんはそれぞれ1回だけしか注文しません。タンクの蛇口が一つしかないので、一人ずつ順番に販売しなければなりません。そこで、鈴木さんはなるべく並んでいるお客さんの待ち時間を少なくしたいと考えています。
お客さんの人数とお客さんが牛乳を注ぎきるのに要する時間が入力として与えられます。あなたはお客さんの「一人一人の待ち時間の合計」(以下「待ち時間の合計」とする)を最小にするための注文の順序を鈴木さんに代わって調べ、そのときの「待ち時間の合計」を出力して終了するプログラムを作成してください。ただし、お客さんは 10,000 人以下で 1 人あたりに要する時間は 60 分以下とします。
例えば、お客さんの人数が 5 人で、各お客さんが要する時間が順に 2,6,4,3,9 分の場合、そのままの順序だと「待ち時間の合計」は 37 分になります。次の例では、最初の列の順の 2 人目と 3 人目を入れ替えています。この場合、「待ち時間の合計」は 35 分になります。最適な順序だと 31 分で済みます。
待ち時間
1 人目 2 分
0 分
2 人目 6 分
2 分
3 人目 4 分
8 分
4 人目 3 分
12 分
5 人目 9 分
15 分
37 分
← 「待ち時間の合計」
2 人目と 3 人目を入れ替えた例
待ち時間
1 人目 2 分
0 分
2 人目 4 分
2 分
3 人目 6 分
6 分
4 人目 3 分
12 分
5 人目 9 分
15 分
35 分
← 「待ち時間の合計」
Input
複数のデータセットが与えられます。各データセットは以下の形式で与えられます。
n
t
1
t
2
:
t
n
1 行目にお客さんの人数
n
(
n
≤ 10,000) が与えられます。続く
n
行に
i
人目のお客さんが要する時間を表す整数
t
i
(0 ≤
t
i
≤ 60) がそれぞれ１行に与えられます。
入力は１つの 0 を含む行で終わります。データセットの数は 50 を超えません。
Output
各データセットごとに、待ち時間の合計(整数)を１行に出力してください。
Sample Input
5
2
6
4
3
9
0
Output for the Sample Input
31",Python,"n = int(input())
t = []
s = 0
sum = 0

if n == 0:
    print(n)

else:
    for i in range(n):
        s = int(input())
        if s == 0:
            break
        else:
            t.append(i)
            t[i] = s
            t.sort()

    for m in range(n):
        sum = sum + t[m]*(n-m-1)

    print(sum)

",1
p00113,"循環小数
2 つの正の整数
p
,
q
を入力し、
p
/
q
を小数として正確に表現することを考えます。(ただし、0 <
p
<
q
< 10
6
とします。)
このとき、結果は
有限の桁で正確に表現できる。
ある桁の範囲を繰り返す循環小数となる。
のいずれかとなります。筆算と同じ手順で1桁ずつ小数部を求めていくと、
割り切れた(余りが 0 になった)なら、そこまでの桁で正確に表現できた。
1度出てきた余りが、再び現れたなら、循環した。
と区別できます。
2 つの整数
p
,
q
を入力すると、
p
/
q
を小数で表した時の、小数部を出力するプログラムを作成してください。 ただし、
結果が有限の桁で正確に表現できる時は、数値だけを 1 行に出力してください。
結果が循環小数になる時は次のように 2 行に出力してください。
最初の行に、循環する部分までの数字を出力してください。
次の行には、循環しない部分の下には空白を出力し、循環する部分の下には「^」を出力してください。
いずれの場合も数字列は 80 文字を超えることはないものとします。
Input
入力は複数のデータセットからなります。各データセットとして、
p
,
q
が空白区切りで１行に与えられます。データセットの数は 250 を超えません。
Output
データセットごとに、循環しない小数の場合は数値の小数部分を(この場合 1 行)、循環小数の場合は循環するまでの数字と循環する部分を示す記号「^」(この場合 2 行) を出力してください。
Sample Input
1 12
10000 32768
1 11100
1 459550
Output for the Sample Input
083
  ^
30517578125
00009
  ^^^
00000217604178
  ^^^^^^^^^^^^",C,"#include <stdio.h>
#include <string.h>

int main() {
    int p, q;
    
    while (scanf(""%d %d"", &p, &q) == 2) {
        char digits[85];
        int remainders[1000005];
        int positions[1000005];
        
        memset(remainders, -1, sizeof(remainders));
        memset(positions, -1, sizeof(positions));
        
        int remainder = p % q;
        int pos = 0;
        int cycle_start = -1;
        
        while (remainder != 0) {
            if (remainders[remainder] != -1) {
                cycle_start = remainders[remainder];
                break;
            }
            
            remainders[remainder] = pos;
            positions[pos] = remainder;
            
            remainder *= 10;
            digits[pos] = (remainder / q) + '0';
            remainder = remainder % q;
            pos++;
        }
        
        digits[pos] = '\0';
        
        if (cycle_start == -1) {
            // Non-repeating
            printf(""%s\n"", digits);
        } else {
            // Repeating
            printf(""%s\n"", digits);
            for (int i = 0; i < cycle_start; i++) {
                printf("" "");
            }
            for (int i = cycle_start; i < pos; i++) {
                printf(""^"");
            }
            printf(""\n"");
        }
    }
    
    return 0;
}
",0
p00113,"循環小数
2 つの正の整数
p
,
q
を入力し、
p
/
q
を小数として正確に表現することを考えます。(ただし、0 <
p
<
q
< 10
6
とします。)
このとき、結果は
有限の桁で正確に表現できる。
ある桁の範囲を繰り返す循環小数となる。
のいずれかとなります。筆算と同じ手順で1桁ずつ小数部を求めていくと、
割り切れた(余りが 0 になった)なら、そこまでの桁で正確に表現できた。
1度出てきた余りが、再び現れたなら、循環した。
と区別できます。
2 つの整数
p
,
q
を入力すると、
p
/
q
を小数で表した時の、小数部を出力するプログラムを作成してください。 ただし、
結果が有限の桁で正確に表現できる時は、数値だけを 1 行に出力してください。
結果が循環小数になる時は次のように 2 行に出力してください。
最初の行に、循環する部分までの数字を出力してください。
次の行には、循環しない部分の下には空白を出力し、循環する部分の下には「^」を出力してください。
いずれの場合も数字列は 80 文字を超えることはないものとします。
Input
入力は複数のデータセットからなります。各データセットとして、
p
,
q
が空白区切りで１行に与えられます。データセットの数は 250 を超えません。
Output
データセットごとに、循環しない小数の場合は数値の小数部分を(この場合 1 行)、循環小数の場合は循環するまでの数字と循環する部分を示す記号「^」(この場合 2 行) を出力してください。
Sample Input
1 12
10000 32768
1 11100
1 459550
Output for the Sample Input
083
  ^
30517578125
00009
  ^^^
00000217604178
  ^^^^^^^^^^^^",C,"char S[99];
int G(x,y){return y?G(y,x%y):x;}
main(g,X,Y,x,y,z,t,T,f){for(;~scanf(""%d%d"",&x,&y);){
for(g=0,X=x,Y=y;g<90;g++)S[g]=X*10/Y+'0',X=X*10%y;
sprintf(S,""%.97f"",x/(double)y);
g=G(x,y);x/=g;y/=g;
for(z=0;y%2==0;y/=2)z++;
for(f=0;y%5==0;y/=5)f++;
if(y==1)t=0;else{x=1;t=0;do{x=x*10%y;t++;}while(x!=1);}
if(z>f)f=z;
S[f+t+2]=0;puts(S+2);
if(t){
	for(;f>0;f--)putchar(' ');
	for(;t>0;t--)putchar('^');
	puts("""");
}
}exit(0);}",1
p00113,"循環小数
2 つの正の整数
p
,
q
を入力し、
p
/
q
を小数として正確に表現することを考えます。(ただし、0 <
p
<
q
< 10
6
とします。)
このとき、結果は
有限の桁で正確に表現できる。
ある桁の範囲を繰り返す循環小数となる。
のいずれかとなります。筆算と同じ手順で1桁ずつ小数部を求めていくと、
割り切れた(余りが 0 になった)なら、そこまでの桁で正確に表現できた。
1度出てきた余りが、再び現れたなら、循環した。
と区別できます。
2 つの整数
p
,
q
を入力すると、
p
/
q
を小数で表した時の、小数部を出力するプログラムを作成してください。 ただし、
結果が有限の桁で正確に表現できる時は、数値だけを 1 行に出力してください。
結果が循環小数になる時は次のように 2 行に出力してください。
最初の行に、循環する部分までの数字を出力してください。
次の行には、循環しない部分の下には空白を出力し、循環する部分の下には「^」を出力してください。
いずれの場合も数字列は 80 文字を超えることはないものとします。
Input
入力は複数のデータセットからなります。各データセットとして、
p
,
q
が空白区切りで１行に与えられます。データセットの数は 250 を超えません。
Output
データセットごとに、循環しない小数の場合は数値の小数部分を(この場合 1 行)、循環小数の場合は循環するまでの数字と循環する部分を示す記号「^」(この場合 2 行) を出力してください。
Sample Input
1 12
10000 32768
1 11100
1 459550
Output for the Sample Input
083
  ^
30517578125
00009
  ^^^
00000217604178
  ^^^^^^^^^^^^",Java,"import java.util.*;

public class Main {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        
        while (sc.hasNext()) {
            int p = sc.nextInt();
            int q = sc.nextInt();
            
            StringBuilder decimal = new StringBuilder();
            Map<Integer, Integer> remainderPos = new HashMap<>();
            
            int remainder = p % q;
            int position = 0;
            
            while (remainder != 0 && !remainderPos.containsKey(remainder)) {
                remainderPos.put(remainder, position);
                remainder *= 10;
                int digit = remainder / q;
                decimal.append(digit);
                remainder = remainder % q;
                position++;
            }
            
            if (remainder == 0) {
                // Terminates
                System.out.println(decimal.toString());
            } else {
                // Repeating
                int cycleStart = remainderPos.get(remainder);
                System.out.println(decimal.toString());
                
                StringBuilder marker = new StringBuilder();
                for (int i = 0; i < cycleStart; i++) {
                    marker.append(' ');
                }
                for (int i = cycleStart; i < decimal.length(); i++) {
                    marker.append('^');
                }
                System.out.println(marker.toString());
            }
        }
        
        sc.close();
    }
}
",0
p00113,"循環小数
2 つの正の整数
p
,
q
を入力し、
p
/
q
を小数として正確に表現することを考えます。(ただし、0 <
p
<
q
< 10
6
とします。)
このとき、結果は
有限の桁で正確に表現できる。
ある桁の範囲を繰り返す循環小数となる。
のいずれかとなります。筆算と同じ手順で1桁ずつ小数部を求めていくと、
割り切れた(余りが 0 になった)なら、そこまでの桁で正確に表現できた。
1度出てきた余りが、再び現れたなら、循環した。
と区別できます。
2 つの整数
p
,
q
を入力すると、
p
/
q
を小数で表した時の、小数部を出力するプログラムを作成してください。 ただし、
結果が有限の桁で正確に表現できる時は、数値だけを 1 行に出力してください。
結果が循環小数になる時は次のように 2 行に出力してください。
最初の行に、循環する部分までの数字を出力してください。
次の行には、循環しない部分の下には空白を出力し、循環する部分の下には「^」を出力してください。
いずれの場合も数字列は 80 文字を超えることはないものとします。
Input
入力は複数のデータセットからなります。各データセットとして、
p
,
q
が空白区切りで１行に与えられます。データセットの数は 250 を超えません。
Output
データセットごとに、循環しない小数の場合は数値の小数部分を(この場合 1 行)、循環小数の場合は循環するまでの数字と循環する部分を示す記号「^」(この場合 2 行) を出力してください。
Sample Input
1 12
10000 32768
1 11100
1 459550
Output for the Sample Input
083
  ^
30517578125
00009
  ^^^
00000217604178
  ^^^^^^^^^^^^",Java,"import java.util.Arrays;
import java.util.Scanner;


public class Main {
	
	public static void main(String[] args) {
		Scanner sc = new Scanner(System.in);
		
		while(true){
			final int p = sc.nextInt();
			final int q = sc.nextInt();
			
			if(p == 0 && q == 0){
				break;
			}
			
			int[] mods = new int[q];
			Arrays.fill(mods, -1);
			
			int cur = p * 10;
			int rep_start = -1;
			int rep_end = 0;
			while(true){
				final int m = cur % q;
				System.out.print(cur / q);
				
				
				if(m == 0){
					rep_start = rep_end;
					break;
				}else if(mods[m] >= 0){
					rep_start = mods[m];
					break;
				}else{
					mods[m] = rep_end;
				}
				
				rep_end++;
				cur = m * 10;
			}
			System.out.println();
			if(rep_start != rep_end){
				for(int i = 0; i <= rep_end;i++){
					if(i <= rep_start){
						System.out.print("" "");
					}else{
						System.out.print(""^"");
					}
				}
				System.out.println();
			}
		}

	}

}",1
p00113,"循環小数
2 つの正の整数
p
,
q
を入力し、
p
/
q
を小数として正確に表現することを考えます。(ただし、0 <
p
<
q
< 10
6
とします。)
このとき、結果は
有限の桁で正確に表現できる。
ある桁の範囲を繰り返す循環小数となる。
のいずれかとなります。筆算と同じ手順で1桁ずつ小数部を求めていくと、
割り切れた(余りが 0 になった)なら、そこまでの桁で正確に表現できた。
1度出てきた余りが、再び現れたなら、循環した。
と区別できます。
2 つの整数
p
,
q
を入力すると、
p
/
q
を小数で表した時の、小数部を出力するプログラムを作成してください。 ただし、
結果が有限の桁で正確に表現できる時は、数値だけを 1 行に出力してください。
結果が循環小数になる時は次のように 2 行に出力してください。
最初の行に、循環する部分までの数字を出力してください。
次の行には、循環しない部分の下には空白を出力し、循環する部分の下には「^」を出力してください。
いずれの場合も数字列は 80 文字を超えることはないものとします。
Input
入力は複数のデータセットからなります。各データセットとして、
p
,
q
が空白区切りで１行に与えられます。データセットの数は 250 を超えません。
Output
データセットごとに、循環しない小数の場合は数値の小数部分を(この場合 1 行)、循環小数の場合は循環するまでの数字と循環する部分を示す記号「^」(この場合 2 行) を出力してください。
Sample Input
1 12
10000 32768
1 11100
1 459550
Output for the Sample Input
083
  ^
30517578125
00009
  ^^^
00000217604178
  ^^^^^^^^^^^^",Python,"import sys

def solve(p, q):
    # Calculate decimal representation of p/q
    decimal_digits = []
    remainders = {}
    remainder = p % q
    position = 0
    
    while remainder != 0 and remainder not in remainders:
        remainders[remainder] = position
        remainder *= 10
        digit = remainder // q
        decimal_digits.append(str(digit))
        remainder = remainder % q
        position += 1
    
    if remainder == 0:
        # Terminating decimal
        print(''.join(decimal_digits))
    else:
        # Repeating decimal
        cycle_start = remainders[remainder]
        print(''.join(decimal_digits))
        
        # Second line with spaces and carets
        line2 = []
        for i in range(len(decimal_digits)):
            if i < cycle_start:
                line2.append(' ')
            else:
                line2.append('^')
        print(''.join(line2))

for line in sys.stdin:
    p, q = map(int, line.strip().split())
    solve(p, q)
",0
p00113,"循環小数
2 つの正の整数
p
,
q
を入力し、
p
/
q
を小数として正確に表現することを考えます。(ただし、0 <
p
<
q
< 10
6
とします。)
このとき、結果は
有限の桁で正確に表現できる。
ある桁の範囲を繰り返す循環小数となる。
のいずれかとなります。筆算と同じ手順で1桁ずつ小数部を求めていくと、
割り切れた(余りが 0 になった)なら、そこまでの桁で正確に表現できた。
1度出てきた余りが、再び現れたなら、循環した。
と区別できます。
2 つの整数
p
,
q
を入力すると、
p
/
q
を小数で表した時の、小数部を出力するプログラムを作成してください。 ただし、
結果が有限の桁で正確に表現できる時は、数値だけを 1 行に出力してください。
結果が循環小数になる時は次のように 2 行に出力してください。
最初の行に、循環する部分までの数字を出力してください。
次の行には、循環しない部分の下には空白を出力し、循環する部分の下には「^」を出力してください。
いずれの場合も数字列は 80 文字を超えることはないものとします。
Input
入力は複数のデータセットからなります。各データセットとして、
p
,
q
が空白区切りで１行に与えられます。データセットの数は 250 を超えません。
Output
データセットごとに、循環しない小数の場合は数値の小数部分を(この場合 1 行)、循環小数の場合は循環するまでの数字と循環する部分を示す記号「^」(この場合 2 行) を出力してください。
Sample Input
1 12
10000 32768
1 11100
1 459550
Output for the Sample Input
083
  ^
30517578125
00009
  ^^^
00000217604178
  ^^^^^^^^^^^^",Python,"from decimal import *
import re
def solve2(m, n):
    maxlen = 85
    #PREC=200
    PREC=300
    getcontext().prec = PREC
    x = Decimal(m) / Decimal(n)
    s = x.to_eng_string()
    if len(s) < PREC:
        return(s[2:],'')
    rep = 1
    while True:
        r = r'(.{%d})\1{%d,}' % (rep, int(PREC/rep)-1)
                                         #ex. '(.{6})\\1{12,}'
        a=re.search(r, s)
        if a:
            break
        rep += 1
        if rep > maxlen:
            raise ValueError('This cannot happen.')

    u = s[2:a.start()+len(a.group(1))]
    v = (' '*PREC + '^'*len(a.group(1)))[-len(u):]
    return(u,v)

while True:
    try:
        m,n = map(int, input().strip().split())
        s,t = solve2(m, n)
        print(s)
        if t!='':
            print(t)
    except EOFError:
        break",1
p00114,"電子蝿
ある計算機学者が電子空間に棲息する電子蝿という奇妙な生命体を見つけました。電子蝿の行動を観察しているうちに、この空間の (
x
,
y
,
z
) 地点にいる電子蝿は、次に以下の規則で示される (
x'
,
y'
,
z'
)に移動することが分かりました。
ただし、
a
1
,
m
1
,
a
2
,
m
2
,
a
3
,
m
3
は電子蝿の個体ごとに定まる正の整数です。
A
mod
B
は正の整数
A
を正の整数
B
で割ったときの余りです。
さらに観察をすると、ある種の電子蝿は (1,1,1) に置いてからしばらくすると、必ず (1,1,1) に戻ってくることがわかりました。このような蝿を戻り蝿と名付けました
(1)
。
戻り蝿のデータを入力とし、(1,1,1) に戻ってくる最小の移動回数 (>0) を出力するプログラムを作成してください。なお 1<
a
1
,
m
1
,
a
2
,
m
2
,
a
3
,
m
3
< 2
15
とします。
(1)
a
1
と
m
1
,
a
2
と
m
2
,
a
3
と
m
3
がそれぞれ互いに素 (公約数が 1) である時に戻ります。
Input
複数のデータセットが与えられます。各データセットは以下の形式で与えられます。
a
1
m
1
a
2
m
2
a
3
m
3
入力は６つの 0 を含む行で終わります。データセットの数は 50 を超えません。
Output
各データセットごとに、(1,1,1) に戻ってくる最小の移動回数(整数)を１行に出力してください。
Sample Input
2 5 3 7 6 13
517 1024 746 6561 4303 3125
0 0 0 0 0 0
Output for the Sample Input
12
116640000",C,"#include <stdio.h>

long long gcd(long long a, long long b) {
    while (b != 0) {
        long long temp = b;
        b = a % b;
        a = temp;
    }
    return a;
}

long long lcm(long long a, long long b) {
    return a / gcd(a, b) * b;
}

long long find_period(long long a, long long m) {
    long long x = 1;
    long long period = 0;
    
    do {
        x = (x * a) % m;
        period++;
    } while (x != 1);
    
    return period;
}

int main() {
    long long a1, m1, a2, m2, a3, m3;
    
    while (1) {
        scanf(""%lld %lld %lld %lld %lld %lld"", &a1, &m1, &a2, &m2, &a3, &m3);
        
        if (a1 == 0 && m1 == 0 && a2 == 0 && m2 == 0 && a3 == 0 && m3 == 0) {
            break;
        }
        
        long long period1 = find_period(a1, m1);
        long long period2 = find_period(a2, m2);
        long long period3 = find_period(a3, m3);
        
        long long result = lcm(period1, lcm(period2, period3));
        
        printf(""%lld\n"", result);
    }
    
    return 0;
}
",0
p00114,"電子蝿
ある計算機学者が電子空間に棲息する電子蝿という奇妙な生命体を見つけました。電子蝿の行動を観察しているうちに、この空間の (
x
,
y
,
z
) 地点にいる電子蝿は、次に以下の規則で示される (
x'
,
y'
,
z'
)に移動することが分かりました。
ただし、
a
1
,
m
1
,
a
2
,
m
2
,
a
3
,
m
3
は電子蝿の個体ごとに定まる正の整数です。
A
mod
B
は正の整数
A
を正の整数
B
で割ったときの余りです。
さらに観察をすると、ある種の電子蝿は (1,1,1) に置いてからしばらくすると、必ず (1,1,1) に戻ってくることがわかりました。このような蝿を戻り蝿と名付けました
(1)
。
戻り蝿のデータを入力とし、(1,1,1) に戻ってくる最小の移動回数 (>0) を出力するプログラムを作成してください。なお 1<
a
1
,
m
1
,
a
2
,
m
2
,
a
3
,
m
3
< 2
15
とします。
(1)
a
1
と
m
1
,
a
2
と
m
2
,
a
3
と
m
3
がそれぞれ互いに素 (公約数が 1) である時に戻ります。
Input
複数のデータセットが与えられます。各データセットは以下の形式で与えられます。
a
1
m
1
a
2
m
2
a
3
m
3
入力は６つの 0 を含む行で終わります。データセットの数は 50 を超えません。
Output
各データセットごとに、(1,1,1) に戻ってくる最小の移動回数(整数)を１行に出力してください。
Sample Input
2 5 3 7 6 13
517 1024 746 6561 4303 3125
0 0 0 0 0 0
Output for the Sample Input
12
116640000",C,"int G(x,y){return y?G(y,x%y):x;}
int L(x,y){return x>y?(x/G(x,y)*y):(y/G(y,x)*x);}
n[3],a[3],m[3];main(i,x){
	for(;scanf(""%d%d%d%d%d%d"",a,m,a+1,m+1,a+2,m+2),*m;){
		for(i=3;i--;)for(x=n[i]=1;(x=a[i]*x%m[i])>1;n[i]++);
		printf(""%d\n"",L(n[0],L(n[1],n[2])));
	}
}",1
p00114,"電子蝿
ある計算機学者が電子空間に棲息する電子蝿という奇妙な生命体を見つけました。電子蝿の行動を観察しているうちに、この空間の (
x
,
y
,
z
) 地点にいる電子蝿は、次に以下の規則で示される (
x'
,
y'
,
z'
)に移動することが分かりました。
ただし、
a
1
,
m
1
,
a
2
,
m
2
,
a
3
,
m
3
は電子蝿の個体ごとに定まる正の整数です。
A
mod
B
は正の整数
A
を正の整数
B
で割ったときの余りです。
さらに観察をすると、ある種の電子蝿は (1,1,1) に置いてからしばらくすると、必ず (1,1,1) に戻ってくることがわかりました。このような蝿を戻り蝿と名付けました
(1)
。
戻り蝿のデータを入力とし、(1,1,1) に戻ってくる最小の移動回数 (>0) を出力するプログラムを作成してください。なお 1<
a
1
,
m
1
,
a
2
,
m
2
,
a
3
,
m
3
< 2
15
とします。
(1)
a
1
と
m
1
,
a
2
と
m
2
,
a
3
と
m
3
がそれぞれ互いに素 (公約数が 1) である時に戻ります。
Input
複数のデータセットが与えられます。各データセットは以下の形式で与えられます。
a
1
m
1
a
2
m
2
a
3
m
3
入力は６つの 0 を含む行で終わります。データセットの数は 50 を超えません。
Output
各データセットごとに、(1,1,1) に戻ってくる最小の移動回数(整数)を１行に出力してください。
Sample Input
2 5 3 7 6 13
517 1024 746 6561 4303 3125
0 0 0 0 0 0
Output for the Sample Input
12
116640000",Java,"import java.util.*;

public class Main {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        
        while (true) {
            long a1 = sc.nextLong();
            long m1 = sc.nextLong();
            long a2 = sc.nextLong();
            long m2 = sc.nextLong();
            long a3 = sc.nextLong();
            long m3 = sc.nextLong();
            
            if (a1 == 0 && m1 == 0 && a2 == 0 && m2 == 0 && a3 == 0 && m3 == 0) {
                break;
            }
            
            long period1 = findPeriod(a1, m1);
            long period2 = findPeriod(a2, m2);
            long period3 = findPeriod(a3, m3);
            
            long result = lcm(lcm(period1, period2), period3);
            
            System.out.println(result);
        }
        
        sc.close();
    }
    
    private static long findPeriod(long a, long m) {
        long x = 1;
        long period = 0;
        
        do {
            x = (a * x) % m;
            period++;
        } while (x != 1);
        
        return period;
    }
    
    private static long gcd(long a, long b) {
        while (b != 0) {
            long temp = b;
            b = a % b;
            a = temp;
        }
        return a;
    }
    
    private static long lcm(long a, long b) {
        return a / gcd(a, b) * b;
    }
}
",0
p00114,"電子蝿
ある計算機学者が電子空間に棲息する電子蝿という奇妙な生命体を見つけました。電子蝿の行動を観察しているうちに、この空間の (
x
,
y
,
z
) 地点にいる電子蝿は、次に以下の規則で示される (
x'
,
y'
,
z'
)に移動することが分かりました。
ただし、
a
1
,
m
1
,
a
2
,
m
2
,
a
3
,
m
3
は電子蝿の個体ごとに定まる正の整数です。
A
mod
B
は正の整数
A
を正の整数
B
で割ったときの余りです。
さらに観察をすると、ある種の電子蝿は (1,1,1) に置いてからしばらくすると、必ず (1,1,1) に戻ってくることがわかりました。このような蝿を戻り蝿と名付けました
(1)
。
戻り蝿のデータを入力とし、(1,1,1) に戻ってくる最小の移動回数 (>0) を出力するプログラムを作成してください。なお 1<
a
1
,
m
1
,
a
2
,
m
2
,
a
3
,
m
3
< 2
15
とします。
(1)
a
1
と
m
1
,
a
2
と
m
2
,
a
3
と
m
3
がそれぞれ互いに素 (公約数が 1) である時に戻ります。
Input
複数のデータセットが与えられます。各データセットは以下の形式で与えられます。
a
1
m
1
a
2
m
2
a
3
m
3
入力は６つの 0 を含む行で終わります。データセットの数は 50 を超えません。
Output
各データセットごとに、(1,1,1) に戻ってくる最小の移動回数(整数)を１行に出力してください。
Sample Input
2 5 3 7 6 13
517 1024 746 6561 4303 3125
0 0 0 0 0 0
Output for the Sample Input
12
116640000",Java,"
import java.io.*;
import java.util.*;


// æ­Ôá¤Æ±ëB
// âè¶É¢ÄÈ­ÄàâèZbgÍ¡Åæªª0ÅI¹Å éB
// âèZbgÌJèÔµÉú»Rê

// 2011/10/18

//@0114 
public class Main {

	
	long gcm(long a, long b) {
		
		while(b != 0) {
			long t = a % b;
			a = b;
			b = t;
		}
		return a;
	}
	
	long lcm(long a, long b) {
		return a * b / gcm(a, b);
	}
	
	// C return falseÅ¨µÜ¢
	boolean main() throws IOException {

		int[] ri = readIntArray();
		int a1 = ri[0];
		int m1 = ri[1];
		int a2 = ri[2];
		int m2 = ri[3];
		int a3 = ri[4];
		int m3 = ri[5];
		if (a1 == 0 && m1 == 0 && a2 == 0 && m2 == 0 && a3 == 0 && m3 == 0) 
			return false; // ¨µÜ¢

		int i;
		int x = 1;
		for(i = 1;; i++) {
			x = (a1 * x) % m1;
			if (x == 1)
				break;
		}
		long v1 = i;
		x = 1;
		for(i = 1;; i++) {
			x = (a2 * x) % m2;
			if (x == 1)
				break;
		}
		long v2 = i;
		x = 1;
		for(i = 1;; i++) {
			x = (a3 * x) % m3;
			if (x == 1)
				break;
		}
		long v3 = i;
		long r = lcm(lcm(v1, v2), v3);
		
		
		// ðÌ\¦
		System.out.printf(""%d\n"", r);
		
		return true; // ³íI¹ Ö
	}
	

//	private final static boolean DEBUG = true;  // debug
	private final static boolean DEBUG = false; // release

	public static void main(String[] args) throws IOException {

		if (DEBUG) {
			log = System.out;
			
			String inputStr = ""1 459550\n"";

			reader = new BufferedReader(new StringReader(inputStr)); 

		}
		else {
			log = new PrintStream(new OutputStream() { public void write(int b) {} } ); // «ÌÄ
			reader = new BufferedReader(new InputStreamReader(System.in)); // R\[©ç
		}
		
		//int N = readIntArray()[0];

		for(int i = 0; /*i < N*/; i++) {
			boolean b = new Main().main();
			if (!b)
				break;
		}		
		
		reader.close();
	}

	
	static PrintStream log;
	static BufferedReader reader;
	

	// WüÍæè1sªÌXy[XæØèÌ®lðÇÞ
	// EOFÌêÍnullðÔ·
	private static int[] readIntArray() throws IOException {
		
		String s = reader.readLine();
		if (s == null)
			return null;
		String[] sp = s.split("" "");
		int[] a = new int[sp.length];
		for(int i = 0; i < sp.length; i++) {
			a[i] = Integer.parseInt(sp[i]);
		}
		return a;
	}
		
}",1
p00114,"電子蝿
ある計算機学者が電子空間に棲息する電子蝿という奇妙な生命体を見つけました。電子蝿の行動を観察しているうちに、この空間の (
x
,
y
,
z
) 地点にいる電子蝿は、次に以下の規則で示される (
x'
,
y'
,
z'
)に移動することが分かりました。
ただし、
a
1
,
m
1
,
a
2
,
m
2
,
a
3
,
m
3
は電子蝿の個体ごとに定まる正の整数です。
A
mod
B
は正の整数
A
を正の整数
B
で割ったときの余りです。
さらに観察をすると、ある種の電子蝿は (1,1,1) に置いてからしばらくすると、必ず (1,1,1) に戻ってくることがわかりました。このような蝿を戻り蝿と名付けました
(1)
。
戻り蝿のデータを入力とし、(1,1,1) に戻ってくる最小の移動回数 (>0) を出力するプログラムを作成してください。なお 1<
a
1
,
m
1
,
a
2
,
m
2
,
a
3
,
m
3
< 2
15
とします。
(1)
a
1
と
m
1
,
a
2
と
m
2
,
a
3
と
m
3
がそれぞれ互いに素 (公約数が 1) である時に戻ります。
Input
複数のデータセットが与えられます。各データセットは以下の形式で与えられます。
a
1
m
1
a
2
m
2
a
3
m
3
入力は６つの 0 を含む行で終わります。データセットの数は 50 を超えません。
Output
各データセットごとに、(1,1,1) に戻ってくる最小の移動回数(整数)を１行に出力してください。
Sample Input
2 5 3 7 6 13
517 1024 746 6561 4303 3125
0 0 0 0 0 0
Output for the Sample Input
12
116640000",Python,"import math
from functools import reduce

def gcd(a, b):
    while b:
        a, b = b, a % b
    return a

def lcm(a, b):
    return a * b // gcd(a, b)

def order_mod(a, m):
    """"""Find the multiplicative order of a modulo m""""""
    if gcd(a, m) != 1:
        return -1
    
    order = 1
    current = a % m
    while current != 1:
        current = (current * a) % m
        order += 1
    return order

while True:
    line = list(map(int, input().split()))
    if line == [0, 0, 0, 0, 0, 0]:
        break
    
    a1, m1, a2, m2, a3, m3 = line
    
    # Find the order of each coordinate
    order1 = order_mod(a1, m1)
    order2 = order_mod(a2, m2)
    order3 = order_mod(a3, m3)
    
    # The minimum number of moves is the LCM of the three orders
    result = lcm(lcm(order1, order2), order3)
    print(result)
",0
p00114,"電子蝿
ある計算機学者が電子空間に棲息する電子蝿という奇妙な生命体を見つけました。電子蝿の行動を観察しているうちに、この空間の (
x
,
y
,
z
) 地点にいる電子蝿は、次に以下の規則で示される (
x'
,
y'
,
z'
)に移動することが分かりました。
ただし、
a
1
,
m
1
,
a
2
,
m
2
,
a
3
,
m
3
は電子蝿の個体ごとに定まる正の整数です。
A
mod
B
は正の整数
A
を正の整数
B
で割ったときの余りです。
さらに観察をすると、ある種の電子蝿は (1,1,1) に置いてからしばらくすると、必ず (1,1,1) に戻ってくることがわかりました。このような蝿を戻り蝿と名付けました
(1)
。
戻り蝿のデータを入力とし、(1,1,1) に戻ってくる最小の移動回数 (>0) を出力するプログラムを作成してください。なお 1<
a
1
,
m
1
,
a
2
,
m
2
,
a
3
,
m
3
< 2
15
とします。
(1)
a
1
と
m
1
,
a
2
と
m
2
,
a
3
と
m
3
がそれぞれ互いに素 (公約数が 1) である時に戻ります。
Input
複数のデータセットが与えられます。各データセットは以下の形式で与えられます。
a
1
m
1
a
2
m
2
a
3
m
3
入力は６つの 0 を含む行で終わります。データセットの数は 50 を超えません。
Output
各データセットごとに、(1,1,1) に戻ってくる最小の移動回数(整数)を１行に出力してください。
Sample Input
2 5 3 7 6 13
517 1024 746 6561 4303 3125
0 0 0 0 0 0
Output for the Sample Input
12
116640000",Python,"# AOJ 0114: Electro-Fly
# Python3 2018.6.18 bal4u

from math import gcd

while True:
	a1, m1, a2, m2, a3, m3 = list(map(int, input().split()))
	if a1 == 0: break
	n = 0
	b1, b2, b3 = 1, 1, 1
	a, b, c = 0, 0, 0
	while True:
		if a == 0: b1 = (b1 * a1) % m1
		if b == 0: b2 = (b2 * a2) % m2
		if c == 0: b3 = (b3 * a3) % m3
		n += 1
		if a == 0 and b1 == 1: a = n
		if b == 0 and b2 == 1: b = n
		if c == 0 and b3 == 1: c = n
		if a != 0 and b != 0 and c != 0: break
	
	ans = a // gcd(a,b) * b
	ans = ans // gcd(ans, c) * c
	print(ans)

",1
p00116,"長方形探索
縦に
H
行、横に
W
列並べられた、合計
W × H
のマス目があります。いくつかのマス目には印がついています。各マス目の印の状態を読み込み、印のついていないマス目だけからなる最大の長方形の面積を出力するプログラムを作成してください。
入力データは 1 行
W
文字から構成され、
H
行が与えられます。たとえば以下のようなデータが与えられます。
..*....**.
..........
**....***.
....*.....
..*.......
...**.....
.*.*......
..........
..**......
.*..*.....
入力データの一行が、一行のマス目を表現します。入力データの文字列のうち、. (ピリオド) は印のついていないマス目、* (アスタリスク) は印のついているマス目を示しています。入力データの文字列には、ピリオド、アスタリスク、改行以外の文字は含まれません。
上記の例では、下図の 0 で示される長方形が最大となります。
..*....**.
..........
**....***.
....*00000
..*..00000
...**00000
.*.*.00000
.....00000
..**.00000
.*..*00000
よって、35 と出力すれば正解になります。なお、すべてのマス目に印がついている場合には、0 を出力してください。
Input
複数のデータセットが与えられます。各データセットはスペースで区切られた
H
と
W
からなる行から始まり、つづいて
H × W
の長方形が与えられます。
H, W
はともに 500　以下とします。
入力は２つの 0 を含む行で終わります。データセットの数は 20 を超えません。
Output
各データセットごとに、最大の長方形の面積を１行に出力してください。
Sample Input
10 10
...*....**
..........
**....**..
........*.
..*.......
**........
.*........
..........
....*..***
.*....*...
10 10
..*....*..
.*.*...*..
*****..*..
*...*..*..
*...*..*..
..........
****.*...*
..*..*...*
.*...*...*
****..***.
2 3
...
...
0 0
Output for the Sample Input
28
12
6",C,"#include <stdio.h>
#include <string.h>

int main() {
    int H, W;
    char grid[505][505];
    int height[505][505];
    
    while (scanf(""%d %d"", &H, &W) == 2 && (H || W)) {
        for (int i = 0; i < H; i++) {
            scanf(""%s"", grid[i]);
        }
        
        // Calculate height array
        memset(height, 0, sizeof(height));
        for (int i = 0; i < H; i++) {
            for (int j = 0; j < W; j++) {
                if (grid[i][j] == '.') {
                    if (i == 0) {
                        height[i][j] = 1;
                    } else {
                        height[i][j] = height[i-1][j] + 1;
                    }
                } else {
                    height[i][j] = 0;
                }
            }
        }
        
        int maxArea = 0;
        
        // For each row, find largest rectangle in histogram
        for (int i = 0; i < H; i++) {
            // For each column as left boundary
            for (int left = 0; left < W; left++) {
                if (height[i][left] == 0) continue;
                
                int minHeight = height[i][left];
                for (int right = left; right < W; right++) {
                    if (height[i][right] == 0) break;
                    
                    if (height[i][right] < minHeight) {
                        minHeight = height[i][right];
                    }
                    
                    int width = right - left + 1;
                    int area = minHeight * width;
                    if (area > maxArea) {
                        maxArea = area;
                    }
                }
            }
        }
        
        printf(""%d\n"", maxArea);
    }
    
    return 0;
}
",0
p00116,"長方形探索
縦に
H
行、横に
W
列並べられた、合計
W × H
のマス目があります。いくつかのマス目には印がついています。各マス目の印の状態を読み込み、印のついていないマス目だけからなる最大の長方形の面積を出力するプログラムを作成してください。
入力データは 1 行
W
文字から構成され、
H
行が与えられます。たとえば以下のようなデータが与えられます。
..*....**.
..........
**....***.
....*.....
..*.......
...**.....
.*.*......
..........
..**......
.*..*.....
入力データの一行が、一行のマス目を表現します。入力データの文字列のうち、. (ピリオド) は印のついていないマス目、* (アスタリスク) は印のついているマス目を示しています。入力データの文字列には、ピリオド、アスタリスク、改行以外の文字は含まれません。
上記の例では、下図の 0 で示される長方形が最大となります。
..*....**.
..........
**....***.
....*00000
..*..00000
...**00000
.*.*.00000
.....00000
..**.00000
.*..*00000
よって、35 と出力すれば正解になります。なお、すべてのマス目に印がついている場合には、0 を出力してください。
Input
複数のデータセットが与えられます。各データセットはスペースで区切られた
H
と
W
からなる行から始まり、つづいて
H × W
の長方形が与えられます。
H, W
はともに 500　以下とします。
入力は２つの 0 を含む行で終わります。データセットの数は 20 を超えません。
Output
各データセットごとに、最大の長方形の面積を１行に出力してください。
Sample Input
10 10
...*....**
..........
**....**..
........*.
..*.......
**........
.*........
..........
....*..***
.*....*...
10 10
..*....*..
.*.*...*..
*****..*..
*...*..*..
*...*..*..
..........
****.*...*
..*..*...*
.*...*...*
****..***.
2 3
...
...
0 0
Output for the Sample Input
28
12
6",C,"#include <stdio.h>
#include <string.h>
#include <stdlib.h>

int i,j,k,h,w,min,ans,mat[700][700],max[700][700];
char c;

int main(){
	while(scanf(""%d %d"",&h,&w)*h*w){
		for(i=0;i<h;i++){
			k=0;
			scanf(""\n"");
			for(j=0;j<w;j++){
				scanf(""%c"",&c);
				if(c=='.')k++; else k=0;
				mat[i][j]=k;
			}
		}

		ans=0;
		for(j=w-1;j>=0;j--){
			for(k=h-1;k>=0;k--){
				min=mat[k][j];
				for(i=1;i+k<h;i++){
					if(min>mat[i+k][j])min=mat[i+k][j];
					if(min==0)break;
					if(min*(i+1)>ans)ans=min*(i+1);
				}
			}
		}
		printf(""%d\n"",ans);
	}
	return 0;
}",1
p00116,"長方形探索
縦に
H
行、横に
W
列並べられた、合計
W × H
のマス目があります。いくつかのマス目には印がついています。各マス目の印の状態を読み込み、印のついていないマス目だけからなる最大の長方形の面積を出力するプログラムを作成してください。
入力データは 1 行
W
文字から構成され、
H
行が与えられます。たとえば以下のようなデータが与えられます。
..*....**.
..........
**....***.
....*.....
..*.......
...**.....
.*.*......
..........
..**......
.*..*.....
入力データの一行が、一行のマス目を表現します。入力データの文字列のうち、. (ピリオド) は印のついていないマス目、* (アスタリスク) は印のついているマス目を示しています。入力データの文字列には、ピリオド、アスタリスク、改行以外の文字は含まれません。
上記の例では、下図の 0 で示される長方形が最大となります。
..*....**.
..........
**....***.
....*00000
..*..00000
...**00000
.*.*.00000
.....00000
..**.00000
.*..*00000
よって、35 と出力すれば正解になります。なお、すべてのマス目に印がついている場合には、0 を出力してください。
Input
複数のデータセットが与えられます。各データセットはスペースで区切られた
H
と
W
からなる行から始まり、つづいて
H × W
の長方形が与えられます。
H, W
はともに 500　以下とします。
入力は２つの 0 を含む行で終わります。データセットの数は 20 を超えません。
Output
各データセットごとに、最大の長方形の面積を１行に出力してください。
Sample Input
10 10
...*....**
..........
**....**..
........*.
..*.......
**........
.*........
..........
....*..***
.*....*...
10 10
..*....*..
.*.*...*..
*****..*..
*...*..*..
*...*..*..
..........
****.*...*
..*..*...*
.*...*...*
****..***.
2 3
...
...
0 0
Output for the Sample Input
28
12
6",Java,"import java.util.*;

public class Main {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        
        while (true) {
            int H = sc.nextInt();
            int W = sc.nextInt();
            
            if (H == 0 && W == 0) break;
            
            sc.nextLine();
            char[][] grid = new char[H][W];
            
            for (int i = 0; i < H; i++) {
                String line = sc.nextLine();
                for (int j = 0; j < W; j++) {
                    grid[i][j] = line.charAt(j);
                }
            }
            
            int[][] height = new int[H][W];
            
            for (int j = 0; j < W; j++) {
                for (int i = 0; i < H; i++) {
                    if (grid[i][j] == '*') {
                        height[i][j] = 0;
                    } else {
                        if (i == 0) {
                            height[i][j] = 1;
                        } else {
                            height[i][j] = height[i-1][j] + 1;
                        }
                    }
                }
            }
            
            int maxArea = 0;
            
            for (int i = 0; i < H; i++) {
                maxArea = Math.max(maxArea, largestRectangleInHistogram(height[i]));
            }
            
            System.out.println(maxArea);
        }
        
        sc.close();
    }
    
    static int largestRectangleInHistogram(int[] heights) {
        Stack<Integer> stack = new Stack<>();
        int maxArea = 0;
        int n = heights.length;
        
        for (int i = 0; i < n; i++) {
            while (!stack.isEmpty() && heights[i] < heights[stack.peek()]) {
                int h = heights[stack.pop()];
                int w = stack.isEmpty() ? i : i - stack.peek() - 1;
                maxArea = Math.max(maxArea, h * w);
            }
            stack.push(i);
        }
        
        while (!stack.isEmpty()) {
            int h = heights[stack.pop()];
            int w = stack.isEmpty() ? n : n - stack.peek() - 1;
            maxArea = Math.max(maxArea, h * w);
        }
        
        return maxArea;
    }
}
",0
p00116,"長方形探索
縦に
H
行、横に
W
列並べられた、合計
W × H
のマス目があります。いくつかのマス目には印がついています。各マス目の印の状態を読み込み、印のついていないマス目だけからなる最大の長方形の面積を出力するプログラムを作成してください。
入力データは 1 行
W
文字から構成され、
H
行が与えられます。たとえば以下のようなデータが与えられます。
..*....**.
..........
**....***.
....*.....
..*.......
...**.....
.*.*......
..........
..**......
.*..*.....
入力データの一行が、一行のマス目を表現します。入力データの文字列のうち、. (ピリオド) は印のついていないマス目、* (アスタリスク) は印のついているマス目を示しています。入力データの文字列には、ピリオド、アスタリスク、改行以外の文字は含まれません。
上記の例では、下図の 0 で示される長方形が最大となります。
..*....**.
..........
**....***.
....*00000
..*..00000
...**00000
.*.*.00000
.....00000
..**.00000
.*..*00000
よって、35 と出力すれば正解になります。なお、すべてのマス目に印がついている場合には、0 を出力してください。
Input
複数のデータセットが与えられます。各データセットはスペースで区切られた
H
と
W
からなる行から始まり、つづいて
H × W
の長方形が与えられます。
H, W
はともに 500　以下とします。
入力は２つの 0 を含む行で終わります。データセットの数は 20 を超えません。
Output
各データセットごとに、最大の長方形の面積を１行に出力してください。
Sample Input
10 10
...*....**
..........
**....**..
........*.
..*.......
**........
.*........
..........
....*..***
.*....*...
10 10
..*....*..
.*.*...*..
*****..*..
*...*..*..
*...*..*..
..........
****.*...*
..*..*...*
.*...*...*
****..***.
2 3
...
...
0 0
Output for the Sample Input
28
12
6",Java,"import java.util.Scanner;

//Rectangular Searching
public class Main{

	public static void main(String[] args) {
		Scanner sc = new Scanner(System.in);
		while(true){
			int h = sc.nextInt();
			int w = sc.nextInt();
			if((h|w)==0)break;
			char[][] m = new char[h][w];
			for(int i=0;i<h;i++)m[i]=sc.next().toCharArray();
			int[][] c = new int[h][w];
			for(int i=0;i<h;i++){
				int x = 1;
				for(int j=w-1;j>=0;j--){
					if(m[i][j]=='.'){
						c[i][j] = x++;
					}
					else{
						c[i][j] = 0;
						x = 1;
					}
				}
			}
			int max = 0;
			for(int i=0;i<h;i++){
				for(int j=0;j<w;j++){
					if(0<i&&c[i][j]==c[i-1][j]||c[i][j]==0)continue;
					int k = 1;
					int min = c[i][j];
					max = Math.max(max, k*min);
					while(i+k<h&&c[i+k][j]>0){
						min = Math.min(min, c[i+k][j]);
						k++;
						max = Math.max(max, k*min);
					}
				}
			}
			System.out.println(max);
		}
	}
}",1
p00116,"長方形探索
縦に
H
行、横に
W
列並べられた、合計
W × H
のマス目があります。いくつかのマス目には印がついています。各マス目の印の状態を読み込み、印のついていないマス目だけからなる最大の長方形の面積を出力するプログラムを作成してください。
入力データは 1 行
W
文字から構成され、
H
行が与えられます。たとえば以下のようなデータが与えられます。
..*....**.
..........
**....***.
....*.....
..*.......
...**.....
.*.*......
..........
..**......
.*..*.....
入力データの一行が、一行のマス目を表現します。入力データの文字列のうち、. (ピリオド) は印のついていないマス目、* (アスタリスク) は印のついているマス目を示しています。入力データの文字列には、ピリオド、アスタリスク、改行以外の文字は含まれません。
上記の例では、下図の 0 で示される長方形が最大となります。
..*....**.
..........
**....***.
....*00000
..*..00000
...**00000
.*.*.00000
.....00000
..**.00000
.*..*00000
よって、35 と出力すれば正解になります。なお、すべてのマス目に印がついている場合には、0 を出力してください。
Input
複数のデータセットが与えられます。各データセットはスペースで区切られた
H
と
W
からなる行から始まり、つづいて
H × W
の長方形が与えられます。
H, W
はともに 500　以下とします。
入力は２つの 0 を含む行で終わります。データセットの数は 20 を超えません。
Output
各データセットごとに、最大の長方形の面積を１行に出力してください。
Sample Input
10 10
...*....**
..........
**....**..
........*.
..*.......
**........
.*........
..........
....*..***
.*....*...
10 10
..*....*..
.*.*...*..
*****..*..
*...*..*..
*...*..*..
..........
****.*...*
..*..*...*
.*...*...*
****..***.
2 3
...
...
0 0
Output for the Sample Input
28
12
6",Python,"def maximal_rectangle(matrix):
    if not matrix or not matrix[0]:
        return 0
    
    H = len(matrix)
    W = len(matrix[0])
    
    # Build height matrix
    heights = [[0] * W for _ in range(H)]
    
    for j in range(W):
        for i in range(H):
            if matrix[i][j] == '.':
                if i == 0:
                    heights[i][j] = 1
                else:
                    heights[i][j] = heights[i-1][j] + 1
            else:
                heights[i][j] = 0
    
    # Find max rectangle for each row using histogram method
    max_area = 0
    
    for i in range(H):
        max_area = max(max_area, largest_rectangle_in_histogram(heights[i]))
    
    return max_area

def largest_rectangle_in_histogram(heights):
    stack = []
    max_area = 0
    index = 0
    
    while index < len(heights):
        if not stack or heights[index] >= heights[stack[-1]]:
            stack.append(index)
            index += 1
        else:
            top = stack.pop()
            width = index if not stack else index - stack[-1] - 1
            area = heights[top] * width
            max_area = max(max_area, area)
    
    while stack:
        top = stack.pop()
        width = index if not stack else index - stack[-1] - 1
        area = heights[top] * width
        max_area = max(max_area, area)
    
    return max_area

while True:
    line = input().split()
    H, W = int(line[0]), int(line[1])
    
    if H == 0 and W == 0:
        break
    
    matrix = []
    for _ in range(H):
        row = input().strip()
        matrix.append(row)
    
    result = maximal_rectangle(matrix)
    print(result)
",0
p00116,"長方形探索
縦に
H
行、横に
W
列並べられた、合計
W × H
のマス目があります。いくつかのマス目には印がついています。各マス目の印の状態を読み込み、印のついていないマス目だけからなる最大の長方形の面積を出力するプログラムを作成してください。
入力データは 1 行
W
文字から構成され、
H
行が与えられます。たとえば以下のようなデータが与えられます。
..*....**.
..........
**....***.
....*.....
..*.......
...**.....
.*.*......
..........
..**......
.*..*.....
入力データの一行が、一行のマス目を表現します。入力データの文字列のうち、. (ピリオド) は印のついていないマス目、* (アスタリスク) は印のついているマス目を示しています。入力データの文字列には、ピリオド、アスタリスク、改行以外の文字は含まれません。
上記の例では、下図の 0 で示される長方形が最大となります。
..*....**.
..........
**....***.
....*00000
..*..00000
...**00000
.*.*.00000
.....00000
..**.00000
.*..*00000
よって、35 と出力すれば正解になります。なお、すべてのマス目に印がついている場合には、0 を出力してください。
Input
複数のデータセットが与えられます。各データセットはスペースで区切られた
H
と
W
からなる行から始まり、つづいて
H × W
の長方形が与えられます。
H, W
はともに 500　以下とします。
入力は２つの 0 を含む行で終わります。データセットの数は 20 を超えません。
Output
各データセットごとに、最大の長方形の面積を１行に出力してください。
Sample Input
10 10
...*....**
..........
**....**..
........*.
..*.......
**........
.*........
..........
....*..***
.*....*...
10 10
..*....*..
.*.*...*..
*****..*..
*...*..*..
*...*..*..
..........
****.*...*
..*..*...*
.*...*...*
****..***.
2 3
...
...
0 0
Output for the Sample Input
28
12
6",Python,"from itertools import product
while(True):
    H,W = map(int,input().split())
    if not H: break
    ma = 0
    for i in range(H):
        ma |= (int(input().replace(""."",""0"").replace(""*"",""1""),2) << ((H-i-1)*W))
    flag = False
    hw = [[h,w] for h,w in product(range(H,0,-1),range(W,0,-1))]
    hw = sorted(hw,key=lambda x: -x[1]*x[0])
    ans = 0
    for h,w in hw:
        for i,j in product(range(H-h+1),range(W-w+1)):
            b = (sum([((2**w-1) << j) << k*W for k in range(h)]) ) << i*W
            c = ma&b
            if not c :flag = True; ans = max(ans,h*w); break
        else:
            continue
        if flag: break
    print(ans)

",1
p00117,"大工の褒美
ある日、殿様は一人の大工に、「台風や地震が来たときに町人が避難できる、頑丈で大きな建物を造りなさい。」と命じました。しかし、その頑丈で大きな建物を完成させるには、大きな太い柱が必要です。町にそんな大きな柱はありません。そこで、大工は遠くの山里まで大きな柱を調達しに行くことになりました（大工は町から里山に行って、町に戻ってくる必要があります）。
大工の褒美は、殿様から受け取ったお金から柱の代金と交通費を差し引いた余りです。下の地図のように、山里に行くには、いろいろな町を通るたくさんの街道があり、2つの町をつなぐ街道はそれぞれ交通費が違います。大工の褒美を最大にするにはどのように街道をたどり調達すればよいでしょうか。最大となる大工の褒美を出力するプログラムを作成してください。ただし、町の数を
n
とすれば、各町は 1 から
n
までの整数で識別されます。2 つの町を直接つなぐ街道は 2 本以上ありません。
※ 矢印上の数字は、その方向に行くための交通費を示します。
Input
入力は以下の形式で与えられます。
n
m
a
1
,
b
1
,
c
1
,
d
1
a
2
,
b
2
,
c
2
,
d
2
:
a
m
,
b
m
,
c
m
,
d
m
s
,
g
,
V
,
P
1 行目に町の総数
n
（
n
≤ 20）、2 行目に街道の総数
m
(
m
≤ 100) が与えられます。続く
m
行に
i
番目の街道の情報
a
i
,
b
i
,
c
i
,
d
i
(1 ≤
a
i
,
b
i
≤
n
,  0 ≤
c
i
,
d
i
≤ 1,000) が与えられます。
a
i
,
b
i
は街道
i
がつないでいる町の番号、
c
i
は
a
i
から
b
i
への交通費、
d
i
は
b
i
から
a
i
への交通費を表します。
最終行に大工が出発する町の番号
s
、柱のある山里の番号
g
、殿様から大工が受け取ったお金
V
、柱の代金
P
が与えられます。
Output
大工の褒美（整数）を１行に出力してください。
Sample Input
6
8
1,2,2,2 
1,3,4,3 
1,4,4,2 
2,5,3,2 
3,4,4,2 
3,6,1,2 
4,6,1,1 
5,6,1,2 
2,4,50,30
Output for the Sample Input
11",C,"#include <stdio.h>
#include <string.h>
#include <limits.h>

#define MAX_N 21
#define INF INT_MAX

int n, m;
int cost[MAX_N][MAX_N];
int dist[MAX_N];
int visited[MAX_N];

void dijkstra(int start) {
    for (int i = 1; i <= n; i++) {
        dist[i] = INF;
        visited[i] = 0;
    }
    dist[start] = 0;
    
    for (int i = 0; i < n; i++) {
        int u = -1;
        int minDist = INF;
        for (int j = 1; j <= n; j++) {
            if (!visited[j] && dist[j] < minDist) {
                minDist = dist[j];
                u = j;
            }
        }
        
        if (u == -1) break;
        visited[u] = 1;
        
        for (int v = 1; v <= n; v++) {
            if (cost[u][v] != INF && dist[u] != INF) {
                if (dist[u] + cost[u][v] < dist[v]) {
                    dist[v] = dist[u] + cost[u][v];
                }
            }
        }
    }
}

int main() {
    scanf(""%d"", &n);
    scanf(""%d"", &m);
    
    for (int i = 1; i <= n; i++) {
        for (int j = 1; j <= n; j++) {
            cost[i][j] = INF;
        }
    }
    
    for (int i = 0; i < m; i++) {
        int a, b, c, d;
        scanf(""%d,%d,%d,%d"", &a, &b, &c, &d);
        cost[a][b] = c;
        cost[b][a] = d;
    }
    
    int s, g, V, P;
    scanf(""%d,%d,%d,%d"", &s, &g, &V, &P);
    
    dijkstra(s);
    int costToG = dist[g];
    
    dijkstra(g);
    int costFromG = dist[s];
    
    int totalCost = costToG + costFromG + P;
    int reward = V - totalCost;
    
    printf(""%d\n"", reward);
    
    return 0;
}
",0
p00117,"大工の褒美
ある日、殿様は一人の大工に、「台風や地震が来たときに町人が避難できる、頑丈で大きな建物を造りなさい。」と命じました。しかし、その頑丈で大きな建物を完成させるには、大きな太い柱が必要です。町にそんな大きな柱はありません。そこで、大工は遠くの山里まで大きな柱を調達しに行くことになりました（大工は町から里山に行って、町に戻ってくる必要があります）。
大工の褒美は、殿様から受け取ったお金から柱の代金と交通費を差し引いた余りです。下の地図のように、山里に行くには、いろいろな町を通るたくさんの街道があり、2つの町をつなぐ街道はそれぞれ交通費が違います。大工の褒美を最大にするにはどのように街道をたどり調達すればよいでしょうか。最大となる大工の褒美を出力するプログラムを作成してください。ただし、町の数を
n
とすれば、各町は 1 から
n
までの整数で識別されます。2 つの町を直接つなぐ街道は 2 本以上ありません。
※ 矢印上の数字は、その方向に行くための交通費を示します。
Input
入力は以下の形式で与えられます。
n
m
a
1
,
b
1
,
c
1
,
d
1
a
2
,
b
2
,
c
2
,
d
2
:
a
m
,
b
m
,
c
m
,
d
m
s
,
g
,
V
,
P
1 行目に町の総数
n
（
n
≤ 20）、2 行目に街道の総数
m
(
m
≤ 100) が与えられます。続く
m
行に
i
番目の街道の情報
a
i
,
b
i
,
c
i
,
d
i
(1 ≤
a
i
,
b
i
≤
n
,  0 ≤
c
i
,
d
i
≤ 1,000) が与えられます。
a
i
,
b
i
は街道
i
がつないでいる町の番号、
c
i
は
a
i
から
b
i
への交通費、
d
i
は
b
i
から
a
i
への交通費を表します。
最終行に大工が出発する町の番号
s
、柱のある山里の番号
g
、殿様から大工が受け取ったお金
V
、柱の代金
P
が与えられます。
Output
大工の褒美（整数）を１行に出力してください。
Sample Input
6
8
1,2,2,2 
1,3,4,3 
1,4,4,2 
2,5,3,2 
3,4,4,2 
3,6,1,2 
4,6,1,1 
5,6,1,2 
2,4,50,30
Output for the Sample Input
11",C,"#include<stdio.h>
#define rep(i,n) for(i=0;i<n;i++)
int min(int a,int b){return a<b?a:b;}
int main(void)
{
  int n,m,mat[20][20],i,j,k,a,b,c,d;
  scanf(""%d%d"",&n,&m);
  rep(i,n)rep(j,n)mat[i][j]=i-j?1<<21:0;
  rep(i,m){
    scanf(""%d,%d,%d,%d"",&a,&b,&c,&d);a--,b--;
    mat[a][b]=c;mat[b][a]=d;
  }
  rep(i,n)rep(j,n)rep(k,n)mat[j][k]=min(mat[j][k],mat[j][i]+mat[i][k]);
  scanf(""%d,%d,%d,%d"",&a,&b,&c,&d);a--,b--;
  printf(""%d\n"",c-mat[a][b]-mat[b][a]-d);
  return 0;
}",1
p00117,"大工の褒美
ある日、殿様は一人の大工に、「台風や地震が来たときに町人が避難できる、頑丈で大きな建物を造りなさい。」と命じました。しかし、その頑丈で大きな建物を完成させるには、大きな太い柱が必要です。町にそんな大きな柱はありません。そこで、大工は遠くの山里まで大きな柱を調達しに行くことになりました（大工は町から里山に行って、町に戻ってくる必要があります）。
大工の褒美は、殿様から受け取ったお金から柱の代金と交通費を差し引いた余りです。下の地図のように、山里に行くには、いろいろな町を通るたくさんの街道があり、2つの町をつなぐ街道はそれぞれ交通費が違います。大工の褒美を最大にするにはどのように街道をたどり調達すればよいでしょうか。最大となる大工の褒美を出力するプログラムを作成してください。ただし、町の数を
n
とすれば、各町は 1 から
n
までの整数で識別されます。2 つの町を直接つなぐ街道は 2 本以上ありません。
※ 矢印上の数字は、その方向に行くための交通費を示します。
Input
入力は以下の形式で与えられます。
n
m
a
1
,
b
1
,
c
1
,
d
1
a
2
,
b
2
,
c
2
,
d
2
:
a
m
,
b
m
,
c
m
,
d
m
s
,
g
,
V
,
P
1 行目に町の総数
n
（
n
≤ 20）、2 行目に街道の総数
m
(
m
≤ 100) が与えられます。続く
m
行に
i
番目の街道の情報
a
i
,
b
i
,
c
i
,
d
i
(1 ≤
a
i
,
b
i
≤
n
,  0 ≤
c
i
,
d
i
≤ 1,000) が与えられます。
a
i
,
b
i
は街道
i
がつないでいる町の番号、
c
i
は
a
i
から
b
i
への交通費、
d
i
は
b
i
から
a
i
への交通費を表します。
最終行に大工が出発する町の番号
s
、柱のある山里の番号
g
、殿様から大工が受け取ったお金
V
、柱の代金
P
が与えられます。
Output
大工の褒美（整数）を１行に出力してください。
Sample Input
6
8
1,2,2,2 
1,3,4,3 
1,4,4,2 
2,5,3,2 
3,4,4,2 
3,6,1,2 
4,6,1,1 
5,6,1,2 
2,4,50,30
Output for the Sample Input
11",Java,"import java.util.*;

public class Main {
    static class Edge {
        int to;
        int cost;
        
        Edge(int to, int cost) {
            this.to = to;
            this.cost = cost;
        }
    }
    
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        
        int n = sc.nextInt();
        int m = sc.nextInt();
        sc.nextLine();
        
        List<List<Edge>> graph = new ArrayList<>();
        for (int i = 0; i <= n; i++) {
            graph.add(new ArrayList<>());
        }
        
        for (int i = 0; i < m; i++) {
            String line = sc.nextLine();
            String[] parts = line.split("","");
            int a = Integer.parseInt(parts[0]);
            int b = Integer.parseInt(parts[1]);
            int c = Integer.parseInt(parts[2]);
            int d = Integer.parseInt(parts[3]);
            
            graph.get(a).add(new Edge(b, c));
            graph.get(b).add(new Edge(a, d));
        }
        
        String[] lastLine = sc.nextLine().split("","");
        int s = Integer.parseInt(lastLine[0]);
        int g = Integer.parseInt(lastLine[1]);
        int V = Integer.parseInt(lastLine[2]);
        int P = Integer.parseInt(lastLine[3]);
        
        int[] distToG = dijkstra(graph, n, s, g);
        int[] distFromG = dijkstra(graph, n, g, s);
        
        int minCost = distToG[g] + distFromG[s];
        int reward = V - P - minCost;
        
        System.out.println(reward);
        
        sc.close();
    }
    
    static int[] dijkstra(List<List<Edge>> graph, int n, int start, int end) {
        int[] dist = new int[n + 1];
        Arrays.fill(dist, Integer.MAX_VALUE);
        dist[start] = 0;
        
        PriorityQueue<int[]> pq = new PriorityQueue<>((a, b) -> a[1] - b[1]);
        pq.offer(new int[]{start, 0});
        
        while (!pq.isEmpty()) {
            int[] curr = pq.poll();
            int u = curr[0];
            int d = curr[1];
            
            if (d > dist[u]) continue;
            
            for (Edge edge : graph.get(u)) {
                int v = edge.to;
                int newDist = dist[u] + edge.cost;
                
                if (newDist < dist[v]) {
                    dist[v] = newDist;
                    pq.offer(new int[]{v, newDist});
                }
            }
        }
        
        return dist;
    }
}
",0
p00117,"大工の褒美
ある日、殿様は一人の大工に、「台風や地震が来たときに町人が避難できる、頑丈で大きな建物を造りなさい。」と命じました。しかし、その頑丈で大きな建物を完成させるには、大きな太い柱が必要です。町にそんな大きな柱はありません。そこで、大工は遠くの山里まで大きな柱を調達しに行くことになりました（大工は町から里山に行って、町に戻ってくる必要があります）。
大工の褒美は、殿様から受け取ったお金から柱の代金と交通費を差し引いた余りです。下の地図のように、山里に行くには、いろいろな町を通るたくさんの街道があり、2つの町をつなぐ街道はそれぞれ交通費が違います。大工の褒美を最大にするにはどのように街道をたどり調達すればよいでしょうか。最大となる大工の褒美を出力するプログラムを作成してください。ただし、町の数を
n
とすれば、各町は 1 から
n
までの整数で識別されます。2 つの町を直接つなぐ街道は 2 本以上ありません。
※ 矢印上の数字は、その方向に行くための交通費を示します。
Input
入力は以下の形式で与えられます。
n
m
a
1
,
b
1
,
c
1
,
d
1
a
2
,
b
2
,
c
2
,
d
2
:
a
m
,
b
m
,
c
m
,
d
m
s
,
g
,
V
,
P
1 行目に町の総数
n
（
n
≤ 20）、2 行目に街道の総数
m
(
m
≤ 100) が与えられます。続く
m
行に
i
番目の街道の情報
a
i
,
b
i
,
c
i
,
d
i
(1 ≤
a
i
,
b
i
≤
n
,  0 ≤
c
i
,
d
i
≤ 1,000) が与えられます。
a
i
,
b
i
は街道
i
がつないでいる町の番号、
c
i
は
a
i
から
b
i
への交通費、
d
i
は
b
i
から
a
i
への交通費を表します。
最終行に大工が出発する町の番号
s
、柱のある山里の番号
g
、殿様から大工が受け取ったお金
V
、柱の代金
P
が与えられます。
Output
大工の褒美（整数）を１行に出力してください。
Sample Input
6
8
1,2,2,2 
1,3,4,3 
1,4,4,2 
2,5,3,2 
3,4,4,2 
3,6,1,2 
4,6,1,1 
5,6,1,2 
2,4,50,30
Output for the Sample Input
11",Java,"import java.util.Arrays;
import java.util.Scanner;

public class Main {

	/**
	 * @param args
	 */
	public static final int INF = Integer.MAX_VALUE;
	public static void main(String[] args) {
		doIt();
	}
	
	public static void doIt(){
		Scanner sc = new Scanner(System.in);
		int n = sc.nextInt();
		//int[][] d = new int[n][n]; 
		int m = sc.nextInt();
		int[][] road = new int[m][4];
		for(int i = 0; i < m; i++){
			String s = sc.next();
			String[] ss = s.split("","");
			for(int j = 0; j < 4; j++){
				road[i][j] = Integer.parseInt(ss[j]);
			}
		}
		int[] input = new int[4];
		String s = sc.next();
		String[] ss = s.split("","");
		for(int j = 0; j < 4; j++){
			input[j] = Integer.parseInt(ss[j]);
		}
		int start = input[0];
		int goal = input[1];
		//startからgoalの最短距離を求める
		//startからの距離
		int[] d = new int[n];
		Arrays.fill(d, INF);
		d[start - 1] = 0;
		while(true){
			boolean bChange = false;
			//道を見ていく
			for(int i = 0; i < m; i++){
				int from = road[i][0];
				int to = road[i][1];
				int cost = road[i][2];
				if(d[from - 1] != INF && d[from - 1] + cost < d[to - 1]){
					d[to - 1] = d[from - 1] + cost;
					bChange = true;
				}
				
				
				from = road[i][1];
				to = road[i][0];
				cost = road[i][3];
				if(d[from - 1] != INF && d[from - 1] + cost < d[to - 1]){
					d[to - 1] = d[from - 1] + cost;
					bChange = true;
				}
			}
			//print(d);
			if(bChange == false) break;
		}
		int sum = d[goal - 1];
		
		//今度はゴールからスタートまでの最短距離
		start = input[1];
		goal = input[0];
		Arrays.fill(d, INF);
		d[start - 1] = 0;
		while(true){
			boolean bChange = false;
			//道を見ていく
			for(int i = 0; i < m; i++){
				int from = road[i][0];
				int to = road[i][1];
				int cost = road[i][2];
				if(d[from - 1] != INF && d[from - 1] + cost < d[to - 1]){
					d[to - 1] = d[from - 1] + cost;
					bChange = true;
				}
				
				
				from = road[i][1];
				to = road[i][0];
				cost = road[i][3];
				if(d[from - 1] != INF && d[from - 1] + cost < d[to - 1]){
					d[to - 1] = d[from - 1] + cost;
					bChange = true;
				}
			}
			//print(d);
			if(bChange == false) break;
		}
		//System.out.println(d[goal - 1]);
		sum += d[goal - 1];
		
		System.out.println(input[2] - input[3] - sum);
		
	}
	
	public static void print(int[] d){
		for(int a : d){
			System.out.print(a + "" "");
		}
		System.out.println();
	}

}",1
p00117,"大工の褒美
ある日、殿様は一人の大工に、「台風や地震が来たときに町人が避難できる、頑丈で大きな建物を造りなさい。」と命じました。しかし、その頑丈で大きな建物を完成させるには、大きな太い柱が必要です。町にそんな大きな柱はありません。そこで、大工は遠くの山里まで大きな柱を調達しに行くことになりました（大工は町から里山に行って、町に戻ってくる必要があります）。
大工の褒美は、殿様から受け取ったお金から柱の代金と交通費を差し引いた余りです。下の地図のように、山里に行くには、いろいろな町を通るたくさんの街道があり、2つの町をつなぐ街道はそれぞれ交通費が違います。大工の褒美を最大にするにはどのように街道をたどり調達すればよいでしょうか。最大となる大工の褒美を出力するプログラムを作成してください。ただし、町の数を
n
とすれば、各町は 1 から
n
までの整数で識別されます。2 つの町を直接つなぐ街道は 2 本以上ありません。
※ 矢印上の数字は、その方向に行くための交通費を示します。
Input
入力は以下の形式で与えられます。
n
m
a
1
,
b
1
,
c
1
,
d
1
a
2
,
b
2
,
c
2
,
d
2
:
a
m
,
b
m
,
c
m
,
d
m
s
,
g
,
V
,
P
1 行目に町の総数
n
（
n
≤ 20）、2 行目に街道の総数
m
(
m
≤ 100) が与えられます。続く
m
行に
i
番目の街道の情報
a
i
,
b
i
,
c
i
,
d
i
(1 ≤
a
i
,
b
i
≤
n
,  0 ≤
c
i
,
d
i
≤ 1,000) が与えられます。
a
i
,
b
i
は街道
i
がつないでいる町の番号、
c
i
は
a
i
から
b
i
への交通費、
d
i
は
b
i
から
a
i
への交通費を表します。
最終行に大工が出発する町の番号
s
、柱のある山里の番号
g
、殿様から大工が受け取ったお金
V
、柱の代金
P
が与えられます。
Output
大工の褒美（整数）を１行に出力してください。
Sample Input
6
8
1,2,2,2 
1,3,4,3 
1,4,4,2 
2,5,3,2 
3,4,4,2 
3,6,1,2 
4,6,1,1 
5,6,1,2 
2,4,50,30
Output for the Sample Input
11",Python,"import sys
from collections import defaultdict
import heapq

def dijkstra(graph, start, n):
    dist = [float('inf')] * (n + 1)
    dist[start] = 0
    pq = [(0, start)]
    
    while pq:
        d, u = heapq.heappop(pq)
        if d > dist[u]:
            continue
        for v, cost in graph[u]:
            if dist[u] + cost < dist[v]:
                dist[v] = dist[u] + cost
                heapq.heappush(pq, (dist[v], v))
    
    return dist

n = int(input())
m = int(input())

graph_forward = defaultdict(list)
graph_backward = defaultdict(list)

for _ in range(m):
    line = input().strip()
    parts = line.split(',')
    a = int(parts[0])
    b = int(parts[1])
    c = int(parts[2])
    d = int(parts[3])
    
    graph_forward[a].append((b, c))
    graph_backward[b].append((a, d))

last_line = input().strip()
parts = last_line.split(',')
s = int(parts[0])
g = int(parts[1])
V = int(parts[2])
P = int(parts[3])

dist_from_s = dijkstra(graph_forward, s, n)
dist_from_g = dijkstra(graph_backward, g, n)

total_cost = dist_from_s[g] + dist_from_g[s] + P
reward = V - total_cost

print(reward)
",0
p00117,"大工の褒美
ある日、殿様は一人の大工に、「台風や地震が来たときに町人が避難できる、頑丈で大きな建物を造りなさい。」と命じました。しかし、その頑丈で大きな建物を完成させるには、大きな太い柱が必要です。町にそんな大きな柱はありません。そこで、大工は遠くの山里まで大きな柱を調達しに行くことになりました（大工は町から里山に行って、町に戻ってくる必要があります）。
大工の褒美は、殿様から受け取ったお金から柱の代金と交通費を差し引いた余りです。下の地図のように、山里に行くには、いろいろな町を通るたくさんの街道があり、2つの町をつなぐ街道はそれぞれ交通費が違います。大工の褒美を最大にするにはどのように街道をたどり調達すればよいでしょうか。最大となる大工の褒美を出力するプログラムを作成してください。ただし、町の数を
n
とすれば、各町は 1 から
n
までの整数で識別されます。2 つの町を直接つなぐ街道は 2 本以上ありません。
※ 矢印上の数字は、その方向に行くための交通費を示します。
Input
入力は以下の形式で与えられます。
n
m
a
1
,
b
1
,
c
1
,
d
1
a
2
,
b
2
,
c
2
,
d
2
:
a
m
,
b
m
,
c
m
,
d
m
s
,
g
,
V
,
P
1 行目に町の総数
n
（
n
≤ 20）、2 行目に街道の総数
m
(
m
≤ 100) が与えられます。続く
m
行に
i
番目の街道の情報
a
i
,
b
i
,
c
i
,
d
i
(1 ≤
a
i
,
b
i
≤
n
,  0 ≤
c
i
,
d
i
≤ 1,000) が与えられます。
a
i
,
b
i
は街道
i
がつないでいる町の番号、
c
i
は
a
i
から
b
i
への交通費、
d
i
は
b
i
から
a
i
への交通費を表します。
最終行に大工が出発する町の番号
s
、柱のある山里の番号
g
、殿様から大工が受け取ったお金
V
、柱の代金
P
が与えられます。
Output
大工の褒美（整数）を１行に出力してください。
Sample Input
6
8
1,2,2,2 
1,3,4,3 
1,4,4,2 
2,5,3,2 
3,4,4,2 
3,6,1,2 
4,6,1,1 
5,6,1,2 
2,4,50,30
Output for the Sample Input
11",Python,"def floyd(P,m):
    for k in range(m):
        for i in range(m):
            for j in range(m):
                P[i][j]=min(P[i][j],P[i][k]+P[k][j])

n=input()
m=input()
INF=1e10
C=[[INF]*n for i in range(n)]
for i in range(n):
    C[i][i]=0
for i in range(m):
    a1,b1,c1,d1=map(int,raw_input().split("",""))
    C[a1-1][b1-1]=c1
    C[b1-1][a1-1]=d1
floyd(C,n)
x1,x2,y1,y2=map(int,raw_input().split("",""))
print y1-y2-C[x1-1][x2-1]-C[x2-1][x1-1]",1
p00118,"Property Distribution
タナカ氏が
HW
アールの果樹園を残して亡くなりました。果樹園は東西南北方向に
H × W
の区画に分けられ、区画ごとにリンゴ、カキ、ミカンが植えられています。タナカ氏はこんな遺言を残していました。
果樹園は区画単位でできるだけ多くの血縁者に分けること。ただし、ある区画の東西南北どれかの方向にとなりあう区画に同じ種類の果物が植えられていた場合は、区画の境界が分からないのでそれらは 1 つの大きな区画として扱うこと。
例えば次のような 3 × 10 の区画であれば ('リ'はリンゴ、'カ'はカキ、'ミ'はミカンを表す)
同じ樹がある区画の間の境界を消すと次のようになり、
結局 10 個の区画、つまり 10 人で分けられることになります。
雪が降って区画の境界が見えなくなる前に分配を終えなくてはなりません。あなたの仕事は果樹園の地図をもとに分配する区画の数を決めることです。
果樹園の地図を読み込み、分配を受けられる血縁者の人数を出力するプログラムを作成してください。
Input
複数のデータセットが与えられます。各データセットは空白で区切られた
H
,
W
(
H, W
≤ 100) を含む行から始まり、続いて
H × W
の文字からなる
H
行の文字列が与えられます。この文字列には、リンゴを表す '
@
'、カキを表す '
#
'、ミカンを表す '
*
'、の 3 文字しか現れません。
入力はゼロが２つの行で終わります。データセットの数は 20 を超えません。
Output
各データセットごとに、分配を受ける人数を１行に出力してください。
Sample Input
10 10
####*****@
@#@@@@#*#*
@##***@@@*
#****#*@**
##@*#@@*##
*@@@@*@@@#
***#@*@##*
*@@@*@@##@
*@*#*@##**
@****#@@#@
0 0
Output for the Sample Input
33",C,"#include <stdio.h>
#include <string.h>

char grid[100][101];
int visited[100][100];
int H, W;

void dfs(int i, int j, char c) {
    if (i < 0 || i >= H || j < 0 || j >= W) return;
    if (visited[i][j]) return;
    if (grid[i][j] != c) return;
    
    visited[i][j] = 1;
    
    dfs(i-1, j, c);
    dfs(i+1, j, c);
    dfs(i, j-1, c);
    dfs(i, j+1, c);
}

int main() {
    while (1) {
        scanf(""%d %d"", &H, &W);
        if (H == 0 && W == 0) break;
        
        for (int i = 0; i < H; i++) {
            scanf(""%s"", grid[i]);
        }
        
        memset(visited, 0, sizeof(visited));
        
        int count = 0;
        for (int i = 0; i < H; i++) {
            for (int j = 0; j < W; j++) {
                if (!visited[i][j]) {
                    dfs(i, j, grid[i][j]);
                    count++;
                }
            }
        }
        
        printf(""%d\n"", count);
    }
    
    return 0;
}
",0
p00118,"Property Distribution
タナカ氏が
HW
アールの果樹園を残して亡くなりました。果樹園は東西南北方向に
H × W
の区画に分けられ、区画ごとにリンゴ、カキ、ミカンが植えられています。タナカ氏はこんな遺言を残していました。
果樹園は区画単位でできるだけ多くの血縁者に分けること。ただし、ある区画の東西南北どれかの方向にとなりあう区画に同じ種類の果物が植えられていた場合は、区画の境界が分からないのでそれらは 1 つの大きな区画として扱うこと。
例えば次のような 3 × 10 の区画であれば ('リ'はリンゴ、'カ'はカキ、'ミ'はミカンを表す)
同じ樹がある区画の間の境界を消すと次のようになり、
結局 10 個の区画、つまり 10 人で分けられることになります。
雪が降って区画の境界が見えなくなる前に分配を終えなくてはなりません。あなたの仕事は果樹園の地図をもとに分配する区画の数を決めることです。
果樹園の地図を読み込み、分配を受けられる血縁者の人数を出力するプログラムを作成してください。
Input
複数のデータセットが与えられます。各データセットは空白で区切られた
H
,
W
(
H, W
≤ 100) を含む行から始まり、続いて
H × W
の文字からなる
H
行の文字列が与えられます。この文字列には、リンゴを表す '
@
'、カキを表す '
#
'、ミカンを表す '
*
'、の 3 文字しか現れません。
入力はゼロが２つの行で終わります。データセットの数は 20 を超えません。
Output
各データセットごとに、分配を受ける人数を１行に出力してください。
Sample Input
10 10
####*****@
@#@@@@#*#*
@##***@@@*
#****#*@**
##@*#@@*##
*@@@@*@@@#
***#@*@##*
*@@@*@@##@
*@*#*@##**
@****#@@#@
0 0
Output for the Sample Input
33",C,"#include<stdio.h>

#define MAX 100
char farm[MAX][MAX];

void divide(int i, int j, int H, int W, char moji)
{
    if( farm[i][j] == moji ){
        farm[i][j] = '+';
        if( j + 1 < W ) divide(i, j + 1, H, W, moji);
        if( i + 1 < H ) divide(i + 1, j, H, W, moji);
        if( j - 1 >= 0 )divide(i, j - 1, H, W, moji);
        if( i - 1 >= 0 )divide(i - 1, j, H, W, moji);
    }
}

int main()
{
    int H, W, i, j, cnt;
    while(1){
        cnt = 0;
        scanf(""%d %d"", &H, &W);
        if(H == 0 && W == 0) break;

        for(i = 0; i < H; i++){
            scanf(""%s"", farm[i]);
        }
        for(i = 0; i < H; i++ ){
            for(j = 0; j < W; j++){
                if(farm[i][j] == '+') continue;
                cnt++;
                divide(i, j, H, W, farm[i][j]);
            }
        }
        printf(""%d\n"", cnt);
    }
    return 0;
}",1
p00118,"Property Distribution
タナカ氏が
HW
アールの果樹園を残して亡くなりました。果樹園は東西南北方向に
H × W
の区画に分けられ、区画ごとにリンゴ、カキ、ミカンが植えられています。タナカ氏はこんな遺言を残していました。
果樹園は区画単位でできるだけ多くの血縁者に分けること。ただし、ある区画の東西南北どれかの方向にとなりあう区画に同じ種類の果物が植えられていた場合は、区画の境界が分からないのでそれらは 1 つの大きな区画として扱うこと。
例えば次のような 3 × 10 の区画であれば ('リ'はリンゴ、'カ'はカキ、'ミ'はミカンを表す)
同じ樹がある区画の間の境界を消すと次のようになり、
結局 10 個の区画、つまり 10 人で分けられることになります。
雪が降って区画の境界が見えなくなる前に分配を終えなくてはなりません。あなたの仕事は果樹園の地図をもとに分配する区画の数を決めることです。
果樹園の地図を読み込み、分配を受けられる血縁者の人数を出力するプログラムを作成してください。
Input
複数のデータセットが与えられます。各データセットは空白で区切られた
H
,
W
(
H, W
≤ 100) を含む行から始まり、続いて
H × W
の文字からなる
H
行の文字列が与えられます。この文字列には、リンゴを表す '
@
'、カキを表す '
#
'、ミカンを表す '
*
'、の 3 文字しか現れません。
入力はゼロが２つの行で終わります。データセットの数は 20 を超えません。
Output
各データセットごとに、分配を受ける人数を１行に出力してください。
Sample Input
10 10
####*****@
@#@@@@#*#*
@##***@@@*
#****#*@**
##@*#@@*##
*@@@@*@@@#
***#@*@##*
*@@@*@@##@
*@*#*@##**
@****#@@#@
0 0
Output for the Sample Input
33",Java,"import java.util.*;

public class Main {
    static int H, W;
    static char[][] grid;
    static boolean[][] visited;
    static int[] dx = {-1, 1, 0, 0};
    static int[] dy = {0, 0, -1, 1};
    
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        
        while (true) {
            H = sc.nextInt();
            W = sc.nextInt();
            
            if (H == 0 && W == 0) break;
            
            grid = new char[H][W];
            visited = new boolean[H][W];
            
            for (int i = 0; i < H; i++) {
                String line = sc.next();
                for (int j = 0; j < W; j++) {
                    grid[i][j] = line.charAt(j);
                }
            }
            
            int count = 0;
            for (int i = 0; i < H; i++) {
                for (int j = 0; j < W; j++) {
                    if (!visited[i][j]) {
                        dfs(i, j, grid[i][j]);
                        count++;
                    }
                }
            }
            
            System.out.println(count);
        }
        
        sc.close();
    }
    
    static void dfs(int x, int y, char fruit) {
        if (x < 0 || x >= H || y < 0 || y >= W) return;
        if (visited[x][y]) return;
        if (grid[x][y] != fruit) return;
        
        visited[x][y] = true;
        
        for (int i = 0; i < 4; i++) {
            int nx = x + dx[i];
            int ny = y + dy[i];
            dfs(nx, ny, fruit);
        }
    }
}
",0
p00118,"Property Distribution
タナカ氏が
HW
アールの果樹園を残して亡くなりました。果樹園は東西南北方向に
H × W
の区画に分けられ、区画ごとにリンゴ、カキ、ミカンが植えられています。タナカ氏はこんな遺言を残していました。
果樹園は区画単位でできるだけ多くの血縁者に分けること。ただし、ある区画の東西南北どれかの方向にとなりあう区画に同じ種類の果物が植えられていた場合は、区画の境界が分からないのでそれらは 1 つの大きな区画として扱うこと。
例えば次のような 3 × 10 の区画であれば ('リ'はリンゴ、'カ'はカキ、'ミ'はミカンを表す)
同じ樹がある区画の間の境界を消すと次のようになり、
結局 10 個の区画、つまり 10 人で分けられることになります。
雪が降って区画の境界が見えなくなる前に分配を終えなくてはなりません。あなたの仕事は果樹園の地図をもとに分配する区画の数を決めることです。
果樹園の地図を読み込み、分配を受けられる血縁者の人数を出力するプログラムを作成してください。
Input
複数のデータセットが与えられます。各データセットは空白で区切られた
H
,
W
(
H, W
≤ 100) を含む行から始まり、続いて
H × W
の文字からなる
H
行の文字列が与えられます。この文字列には、リンゴを表す '
@
'、カキを表す '
#
'、ミカンを表す '
*
'、の 3 文字しか現れません。
入力はゼロが２つの行で終わります。データセットの数は 20 を超えません。
Output
各データセットごとに、分配を受ける人数を１行に出力してください。
Sample Input
10 10
####*****@
@#@@@@#*#*
@##***@@@*
#****#*@**
##@*#@@*##
*@@@@*@@@#
***#@*@##*
*@@@*@@##@
*@*#*@##**
@****#@@#@
0 0
Output for the Sample Input
33",Java,"import java.io.*;
import java.util.*;

public class Main{
	public static void main(String args[]){
		try{
			new Main();
		}catch(IOException err){
			err.printStackTrace();
		}
	}
	
	int[][] offset = new int[][]{
			{-1, 0}, {1, 0}, {0, -1}, {0, 1}
	};


	public Main() throws IOException, StackOverflowError{
		BufferedReader in = new BufferedReader(new InputStreamReader(System.in));
		List<Integer> Ans = new ArrayList<Integer>();
		String line = in.readLine();
		String[] dst = line.split("" "");
		Integer.parseInt(dst[0]);

		
	}

	public void grouping(int[][] data, int[][] label, int x, int y){
		List<point> cue = new ArrayList<point>();
		cue.add(new point(x, y));
		while(cue.size() != 0){
			point p = cue.get(0);
			cue.remove(0);
			for(int d=0; d<4; d++){
				int xx = p.x + offset[d][0];
				int yy = p.y + offset[d][1];
				if(label[yy][xx] == 0 && data[yy][xx] == data[p.y][p.x]){
					label[yy][xx] = label[p.y][p.x];
					cue.add(new point(xx, yy));
				}
			}
		}
	}
}

class point{
	int x;
	int y;
	
	public point(int x, int y){
		this.x = x;
		this.y = y;
	}
}",1
p00118,"Property Distribution
タナカ氏が
HW
アールの果樹園を残して亡くなりました。果樹園は東西南北方向に
H × W
の区画に分けられ、区画ごとにリンゴ、カキ、ミカンが植えられています。タナカ氏はこんな遺言を残していました。
果樹園は区画単位でできるだけ多くの血縁者に分けること。ただし、ある区画の東西南北どれかの方向にとなりあう区画に同じ種類の果物が植えられていた場合は、区画の境界が分からないのでそれらは 1 つの大きな区画として扱うこと。
例えば次のような 3 × 10 の区画であれば ('リ'はリンゴ、'カ'はカキ、'ミ'はミカンを表す)
同じ樹がある区画の間の境界を消すと次のようになり、
結局 10 個の区画、つまり 10 人で分けられることになります。
雪が降って区画の境界が見えなくなる前に分配を終えなくてはなりません。あなたの仕事は果樹園の地図をもとに分配する区画の数を決めることです。
果樹園の地図を読み込み、分配を受けられる血縁者の人数を出力するプログラムを作成してください。
Input
複数のデータセットが与えられます。各データセットは空白で区切られた
H
,
W
(
H, W
≤ 100) を含む行から始まり、続いて
H × W
の文字からなる
H
行の文字列が与えられます。この文字列には、リンゴを表す '
@
'、カキを表す '
#
'、ミカンを表す '
*
'、の 3 文字しか現れません。
入力はゼロが２つの行で終わります。データセットの数は 20 を超えません。
Output
各データセットごとに、分配を受ける人数を１行に出力してください。
Sample Input
10 10
####*****@
@#@@@@#*#*
@##***@@@*
#****#*@**
##@*#@@*##
*@@@@*@@@#
***#@*@##*
*@@@*@@##@
*@*#*@##**
@****#@@#@
0 0
Output for the Sample Input
33",Python,"def count_regions(H, W, grid):
    visited = [[False] * W for _ in range(H)]
    count = 0
    
    def dfs(i, j, fruit_type):
        if i < 0 or i >= H or j < 0 or j >= W:
            return
        if visited[i][j]:
            return
        if grid[i][j] != fruit_type:
            return
        
        visited[i][j] = True
        dfs(i-1, j, fruit_type)
        dfs(i+1, j, fruit_type)
        dfs(i, j-1, fruit_type)
        dfs(i, j+1, fruit_type)
    
    for i in range(H):
        for j in range(W):
            if not visited[i][j]:
                dfs(i, j, grid[i][j])
                count += 1
    
    return count

while True:
    line = input().split()
    H, W = int(line[0]), int(line[1])
    
    if H == 0 and W == 0:
        break
    
    grid = []
    for _ in range(H):
        grid.append(input().strip())
    
    result = count_regions(H, W, grid)
    print(result)
",0
p00118,"Property Distribution
タナカ氏が
HW
アールの果樹園を残して亡くなりました。果樹園は東西南北方向に
H × W
の区画に分けられ、区画ごとにリンゴ、カキ、ミカンが植えられています。タナカ氏はこんな遺言を残していました。
果樹園は区画単位でできるだけ多くの血縁者に分けること。ただし、ある区画の東西南北どれかの方向にとなりあう区画に同じ種類の果物が植えられていた場合は、区画の境界が分からないのでそれらは 1 つの大きな区画として扱うこと。
例えば次のような 3 × 10 の区画であれば ('リ'はリンゴ、'カ'はカキ、'ミ'はミカンを表す)
同じ樹がある区画の間の境界を消すと次のようになり、
結局 10 個の区画、つまり 10 人で分けられることになります。
雪が降って区画の境界が見えなくなる前に分配を終えなくてはなりません。あなたの仕事は果樹園の地図をもとに分配する区画の数を決めることです。
果樹園の地図を読み込み、分配を受けられる血縁者の人数を出力するプログラムを作成してください。
Input
複数のデータセットが与えられます。各データセットは空白で区切られた
H
,
W
(
H, W
≤ 100) を含む行から始まり、続いて
H × W
の文字からなる
H
行の文字列が与えられます。この文字列には、リンゴを表す '
@
'、カキを表す '
#
'、ミカンを表す '
*
'、の 3 文字しか現れません。
入力はゼロが２つの行で終わります。データセットの数は 20 を超えません。
Output
各データセットごとに、分配を受ける人数を１行に出力してください。
Sample Input
10 10
####*****@
@#@@@@#*#*
@##***@@@*
#****#*@**
##@*#@@*##
*@@@@*@@@#
***#@*@##*
*@@@*@@##@
*@*#*@##**
@****#@@#@
0 0
Output for the Sample Input
33",Python,"def wa(h, w, f):
    if not (0 <= h <= H-1 and 0 <= w <= W-1):
        return
    elif mapp[h][w] != f:
        return
    else:
        mapp[h][w] = '$'
        wa(h, w+1, f)
        wa(h-1, w, f)
        wa(h, w-1, f)
        wa(h+1, w, f)

while True:
    H, W = map(int, raw_input().split(' '))
    if H == 0: break
    mapp = [list(raw_input()) for i in range(H)]
    count = 0
    for h in range(H):
        for w in range(W):
            if mapp[h][w] == '@':
                wa(h, w, '@')
            elif mapp[h][w] == '#':
                wa(h, w, '#')
            elif mapp[h][w] == '*':
                wa(h, w, '*')
            else:
                continue
            count += 1
    else:
        print count",1
p00119,"太郎君の執念
まんじゅう好きの太郎くんの家でたいへんな事件がおきました。和室の仏壇に供えてあった3つのまんじゅうのうち1つが無くなっていたのです。いつかはおやつにいただこうと狙っていた太郎くんが犯人を見つけるため捜査を始めると、その日、和室に入った人が何人もいることが分かりました。そこで、これらの容疑者が部屋に入った順序を調べるため、全員に次のような形式の証言をしてもらうことにました。
容疑者 A の証言 「私は容疑者 B より先に部屋に入った。」
容疑者の一人(?)は三毛猫のタマなので証言はできませんが、幸運にも最後に部屋に入ったところを太郎くんは見ていました。
太郎くんはこれらの証言から、部屋に入った順番を推測して捜査に役立てることにしました。
例えば、6 人の容疑者がいてタマを容疑者 2 とした場合、以下のような証言が得られたとします。
容疑者 5 の証言 「私は 2 より先に部屋に入った。」
容疑者 1 の証言 「私は 4 より先に部屋に入った。」
容疑者 3 の証言 「私は 5 より先に部屋に入った。」
容疑者 4 の証言 「私は 2 より先に部屋に入った。」
容疑者 1 の証言 「私は 6 より先に部屋に入った。」
容疑者 6 の証言 「私は 4 より先に部屋に入った。」
容疑者 3 の証言 「私は 4 より先に部屋に入った。」
この証言をつなぎ合わせると、部屋に入った順序は
3→5→1→6→4→2
1→6→3→4→5→2
3→1→6→5→4→2
など、何通りかの可能性に絞り込むことができます。
タマ (容疑者 2) 以外の容疑者全員の証言から、部屋に入った順番を推測し、可能性のある順番の 1 つを出力するプログラムを作成してください。ただし、複数の証言をする容疑者がいるかもしれませんが、どの証言も真実であり矛盾していないものとします。
Input
入力は以下の形式で与えられます。
m
n
x
1
y
1
x
2
y
2
:
x
n
y
n
1 行目に容疑者の人数
m
(
m
≤ 20)、2 行目に証言の数
n
(
n
≤ 100) が与えられます。
続く
n
行に
i
個目の証言の内容
x
i
,
y
i
がそれぞれ１行に与えられます。
x
i
y
i
は「容疑者
x
i
(私)は容疑者
y
i
より先に入った」という証言を表します。
Output
最初に部屋に入った容疑者の番号、2 番目に部屋に入った容疑者の番号、...、
m
番目に部屋に入った容疑者の番号をそれぞれ１行に順番に出力してください。
Sample Input
6
7
5 2
1 4
3 5
4 2
1 6
6 4
3 4
Output for the Sample Input
3
5
1
6
4
2",C,"#include <stdio.h>
#include <stdlib.h>
#include <string.h>

int main() {
    int m, n;
    scanf(""%d"", &m);
    scanf(""%d"", &n);
    
    int adj[21][21] = {0};
    int indegree[21] = {0};
    
    for (int i = 0; i < n; i++) {
        int x, y;
        scanf(""%d %d"", &x, &y);
        if (!adj[x][y]) {
            adj[x][y] = 1;
            indegree[y]++;
        }
    }
    
    int result[21];
    int used[21] = {0};
    int pos = 0;
    
    while (pos < m) {
        for (int i = 1; i <= m; i++) {
            if (used[i]) continue;
            if (indegree[i] == 0) {
                result[pos++] = i;
                used[i] = 1;
                for (int j = 1; j <= m; j++) {
                    if (adj[i][j]) {
                        indegree[j]--;
                    }
                }
                break;
            }
        }
    }
    
    for (int i = 0; i < m; i++) {
        printf(""%d\n"", result[i]);
    }
    
    return 0;
}
",0
p00119,"太郎君の執念
まんじゅう好きの太郎くんの家でたいへんな事件がおきました。和室の仏壇に供えてあった3つのまんじゅうのうち1つが無くなっていたのです。いつかはおやつにいただこうと狙っていた太郎くんが犯人を見つけるため捜査を始めると、その日、和室に入った人が何人もいることが分かりました。そこで、これらの容疑者が部屋に入った順序を調べるため、全員に次のような形式の証言をしてもらうことにました。
容疑者 A の証言 「私は容疑者 B より先に部屋に入った。」
容疑者の一人(?)は三毛猫のタマなので証言はできませんが、幸運にも最後に部屋に入ったところを太郎くんは見ていました。
太郎くんはこれらの証言から、部屋に入った順番を推測して捜査に役立てることにしました。
例えば、6 人の容疑者がいてタマを容疑者 2 とした場合、以下のような証言が得られたとします。
容疑者 5 の証言 「私は 2 より先に部屋に入った。」
容疑者 1 の証言 「私は 4 より先に部屋に入った。」
容疑者 3 の証言 「私は 5 より先に部屋に入った。」
容疑者 4 の証言 「私は 2 より先に部屋に入った。」
容疑者 1 の証言 「私は 6 より先に部屋に入った。」
容疑者 6 の証言 「私は 4 より先に部屋に入った。」
容疑者 3 の証言 「私は 4 より先に部屋に入った。」
この証言をつなぎ合わせると、部屋に入った順序は
3→5→1→6→4→2
1→6→3→4→5→2
3→1→6→5→4→2
など、何通りかの可能性に絞り込むことができます。
タマ (容疑者 2) 以外の容疑者全員の証言から、部屋に入った順番を推測し、可能性のある順番の 1 つを出力するプログラムを作成してください。ただし、複数の証言をする容疑者がいるかもしれませんが、どの証言も真実であり矛盾していないものとします。
Input
入力は以下の形式で与えられます。
m
n
x
1
y
1
x
2
y
2
:
x
n
y
n
1 行目に容疑者の人数
m
(
m
≤ 20)、2 行目に証言の数
n
(
n
≤ 100) が与えられます。
続く
n
行に
i
個目の証言の内容
x
i
,
y
i
がそれぞれ１行に与えられます。
x
i
y
i
は「容疑者
x
i
(私)は容疑者
y
i
より先に入った」という証言を表します。
Output
最初に部屋に入った容疑者の番号、2 番目に部屋に入った容疑者の番号、...、
m
番目に部屋に入った容疑者の番号をそれぞれ１行に順番に出力してください。
Sample Input
6
7
5 2
1 4
3 5
4 2
1 6
6 4
3 4
Output for the Sample Input
3
5
1
6
4
2",C,"/*
AizuOnline A0119
Title Taro's obsession
*/
#include <stdio.h>
// Select Below
//#include <stdlib.h>
//#include <string.h>
//#include <float.h>
//#include <math.h>
//#include <limits.h>
//Global data section
#define SHOUGENNO 100
#define NINZUU 20
int n,m;
int x[SHOUGENNO],y[SHOUGENNO];
int flag[NINZUU+1];
//
void show()
{
  int i;
  for(i=1;i<=n;i++)
    printf(""%d:"",flag[i]);
  printf(""\n"");
}
main()
{
  int i,cnt;

  scanf(""%d "",&n);
  scanf(""%d "",&m);
  for(i=0;i<m;i++)
    scanf(""%d %d"",&x[i],&y[i]);
  for(i=0;i<n;i++)
    flag[i]=0;

  cnt=n;

  while(cnt>1)
    {
      for(i=1;i<=n;i++)
	if(flag[i]>0)
	  flag[i]=0;
      //show();
      for(i=0;i<m;i++)
	if(flag[x[i]]!=-1)
	  flag[y[i]]=1;
      for(i=1;i<=n;i++)
	{
	  if(flag[i]==0 && i!=2)
	    {
	      printf(""%d\n"",i);
	      cnt--;
	      flag[i]=-1;
	    }
	}
      //show();
    }
  printf(""2\n"");
return(0);
}",1
p00119,"太郎君の執念
まんじゅう好きの太郎くんの家でたいへんな事件がおきました。和室の仏壇に供えてあった3つのまんじゅうのうち1つが無くなっていたのです。いつかはおやつにいただこうと狙っていた太郎くんが犯人を見つけるため捜査を始めると、その日、和室に入った人が何人もいることが分かりました。そこで、これらの容疑者が部屋に入った順序を調べるため、全員に次のような形式の証言をしてもらうことにました。
容疑者 A の証言 「私は容疑者 B より先に部屋に入った。」
容疑者の一人(?)は三毛猫のタマなので証言はできませんが、幸運にも最後に部屋に入ったところを太郎くんは見ていました。
太郎くんはこれらの証言から、部屋に入った順番を推測して捜査に役立てることにしました。
例えば、6 人の容疑者がいてタマを容疑者 2 とした場合、以下のような証言が得られたとします。
容疑者 5 の証言 「私は 2 より先に部屋に入った。」
容疑者 1 の証言 「私は 4 より先に部屋に入った。」
容疑者 3 の証言 「私は 5 より先に部屋に入った。」
容疑者 4 の証言 「私は 2 より先に部屋に入った。」
容疑者 1 の証言 「私は 6 より先に部屋に入った。」
容疑者 6 の証言 「私は 4 より先に部屋に入った。」
容疑者 3 の証言 「私は 4 より先に部屋に入った。」
この証言をつなぎ合わせると、部屋に入った順序は
3→5→1→6→4→2
1→6→3→4→5→2
3→1→6→5→4→2
など、何通りかの可能性に絞り込むことができます。
タマ (容疑者 2) 以外の容疑者全員の証言から、部屋に入った順番を推測し、可能性のある順番の 1 つを出力するプログラムを作成してください。ただし、複数の証言をする容疑者がいるかもしれませんが、どの証言も真実であり矛盾していないものとします。
Input
入力は以下の形式で与えられます。
m
n
x
1
y
1
x
2
y
2
:
x
n
y
n
1 行目に容疑者の人数
m
(
m
≤ 20)、2 行目に証言の数
n
(
n
≤ 100) が与えられます。
続く
n
行に
i
個目の証言の内容
x
i
,
y
i
がそれぞれ１行に与えられます。
x
i
y
i
は「容疑者
x
i
(私)は容疑者
y
i
より先に入った」という証言を表します。
Output
最初に部屋に入った容疑者の番号、2 番目に部屋に入った容疑者の番号、...、
m
番目に部屋に入った容疑者の番号をそれぞれ１行に順番に出力してください。
Sample Input
6
7
5 2
1 4
3 5
4 2
1 6
6 4
3 4
Output for the Sample Input
3
5
1
6
4
2",Java,"import java.util.*;

public class Main {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int m = sc.nextInt();
        int n = sc.nextInt();
        
        List<List<Integer>> graph = new ArrayList<>();
        int[] indegree = new int[m + 1];
        
        for (int i = 0; i <= m; i++) {
            graph.add(new ArrayList<>());
        }
        
        for (int i = 0; i < n; i++) {
            int x = sc.nextInt();
            int y = sc.nextInt();
            graph.get(x).add(y);
            indegree[y]++;
        }
        
        Queue<Integer> queue = new LinkedList<>();
        for (int i = 1; i <= m; i++) {
            if (indegree[i] == 0) {
                queue.offer(i);
            }
        }
        
        List<Integer> result = new ArrayList<>();
        while (!queue.isEmpty()) {
            int current = queue.poll();
            result.add(current);
            
            for (int next : graph.get(current)) {
                indegree[next]--;
                if (indegree[next] == 0) {
                    queue.offer(next);
                }
            }
        }
        
        for (int suspect : result) {
            System.out.println(suspect);
        }
        
        sc.close();
    }
}
",0
p00119,"太郎君の執念
まんじゅう好きの太郎くんの家でたいへんな事件がおきました。和室の仏壇に供えてあった3つのまんじゅうのうち1つが無くなっていたのです。いつかはおやつにいただこうと狙っていた太郎くんが犯人を見つけるため捜査を始めると、その日、和室に入った人が何人もいることが分かりました。そこで、これらの容疑者が部屋に入った順序を調べるため、全員に次のような形式の証言をしてもらうことにました。
容疑者 A の証言 「私は容疑者 B より先に部屋に入った。」
容疑者の一人(?)は三毛猫のタマなので証言はできませんが、幸運にも最後に部屋に入ったところを太郎くんは見ていました。
太郎くんはこれらの証言から、部屋に入った順番を推測して捜査に役立てることにしました。
例えば、6 人の容疑者がいてタマを容疑者 2 とした場合、以下のような証言が得られたとします。
容疑者 5 の証言 「私は 2 より先に部屋に入った。」
容疑者 1 の証言 「私は 4 より先に部屋に入った。」
容疑者 3 の証言 「私は 5 より先に部屋に入った。」
容疑者 4 の証言 「私は 2 より先に部屋に入った。」
容疑者 1 の証言 「私は 6 より先に部屋に入った。」
容疑者 6 の証言 「私は 4 より先に部屋に入った。」
容疑者 3 の証言 「私は 4 より先に部屋に入った。」
この証言をつなぎ合わせると、部屋に入った順序は
3→5→1→6→4→2
1→6→3→4→5→2
3→1→6→5→4→2
など、何通りかの可能性に絞り込むことができます。
タマ (容疑者 2) 以外の容疑者全員の証言から、部屋に入った順番を推測し、可能性のある順番の 1 つを出力するプログラムを作成してください。ただし、複数の証言をする容疑者がいるかもしれませんが、どの証言も真実であり矛盾していないものとします。
Input
入力は以下の形式で与えられます。
m
n
x
1
y
1
x
2
y
2
:
x
n
y
n
1 行目に容疑者の人数
m
(
m
≤ 20)、2 行目に証言の数
n
(
n
≤ 100) が与えられます。
続く
n
行に
i
個目の証言の内容
x
i
,
y
i
がそれぞれ１行に与えられます。
x
i
y
i
は「容疑者
x
i
(私)は容疑者
y
i
より先に入った」という証言を表します。
Output
最初に部屋に入った容疑者の番号、2 番目に部屋に入った容疑者の番号、...、
m
番目に部屋に入った容疑者の番号をそれぞれ１行に順番に出力してください。
Sample Input
6
7
5 2
1 4
3 5
4 2
1 6
6 4
3 4
Output for the Sample Input
3
5
1
6
4
2",Java,"import java.util.Arrays;
import java.util.Comparator;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Map;
import java.util.Scanner;
import java.util.Set;
    
public class Main {
    public static void main(String[] args) {
        (new Main()).execute();
    }
    private void execute() {
        Scanner sc = new Scanner(System.in);

        int m = sc.nextInt();
        int n = sc.nextInt();

        ObsessionComparator comp = new ObsessionComparator(m);
        for(int i = 0 ; i < n ; i++) {comp.add(sc.nextInt(), sc.nextInt());}
        
        Integer[] list = new Integer[m];
        for(int i = 0 ; i < m ; i++) {list[i] = Integer.valueOf(i+1);}
        
        Arrays.sort(list, comp);
        
        for(Integer i : list){System.out.println(i);}
        sc.close();
    }
    
    private class ObsessionComparator implements Comparator<Integer> {
    	private Map<Integer, Set<Integer>> sortMap = new HashMap<Integer, Set<Integer>>();
    	private ObsessionComparator(int count) {
    		for(int i = 1 ; i <= count ; i++) {
    			sortMap.put(Integer.valueOf(i), new HashSet<Integer>());
    		}
    	}

    	private void add(Integer x, Integer y) {
    		sortMap.get(x).add(y);
    	}
    	private boolean isSorted(Integer x, Integer y) {
    		if(sortMap.get(x).contains(y)) {
    			return true;
    		} else if(sortMap.get(x).isEmpty()) {
    			return false;
    		} else {
    			for(Integer next : sortMap.get(x)) {
    				if(isSorted(next, y)){
    					return true;
    				}
    			}
    			return false;
    		}
    	}
    	
    	@Override
		public int compare(Integer arg0, Integer arg1) {
    		return isSorted(arg0, arg1) ? -1 : 1;
		}
    }
}",1
p00119,"太郎君の執念
まんじゅう好きの太郎くんの家でたいへんな事件がおきました。和室の仏壇に供えてあった3つのまんじゅうのうち1つが無くなっていたのです。いつかはおやつにいただこうと狙っていた太郎くんが犯人を見つけるため捜査を始めると、その日、和室に入った人が何人もいることが分かりました。そこで、これらの容疑者が部屋に入った順序を調べるため、全員に次のような形式の証言をしてもらうことにました。
容疑者 A の証言 「私は容疑者 B より先に部屋に入った。」
容疑者の一人(?)は三毛猫のタマなので証言はできませんが、幸運にも最後に部屋に入ったところを太郎くんは見ていました。
太郎くんはこれらの証言から、部屋に入った順番を推測して捜査に役立てることにしました。
例えば、6 人の容疑者がいてタマを容疑者 2 とした場合、以下のような証言が得られたとします。
容疑者 5 の証言 「私は 2 より先に部屋に入った。」
容疑者 1 の証言 「私は 4 より先に部屋に入った。」
容疑者 3 の証言 「私は 5 より先に部屋に入った。」
容疑者 4 の証言 「私は 2 より先に部屋に入った。」
容疑者 1 の証言 「私は 6 より先に部屋に入った。」
容疑者 6 の証言 「私は 4 より先に部屋に入った。」
容疑者 3 の証言 「私は 4 より先に部屋に入った。」
この証言をつなぎ合わせると、部屋に入った順序は
3→5→1→6→4→2
1→6→3→4→5→2
3→1→6→5→4→2
など、何通りかの可能性に絞り込むことができます。
タマ (容疑者 2) 以外の容疑者全員の証言から、部屋に入った順番を推測し、可能性のある順番の 1 つを出力するプログラムを作成してください。ただし、複数の証言をする容疑者がいるかもしれませんが、どの証言も真実であり矛盾していないものとします。
Input
入力は以下の形式で与えられます。
m
n
x
1
y
1
x
2
y
2
:
x
n
y
n
1 行目に容疑者の人数
m
(
m
≤ 20)、2 行目に証言の数
n
(
n
≤ 100) が与えられます。
続く
n
行に
i
個目の証言の内容
x
i
,
y
i
がそれぞれ１行に与えられます。
x
i
y
i
は「容疑者
x
i
(私)は容疑者
y
i
より先に入った」という証言を表します。
Output
最初に部屋に入った容疑者の番号、2 番目に部屋に入った容疑者の番号、...、
m
番目に部屋に入った容疑者の番号をそれぞれ１行に順番に出力してください。
Sample Input
6
7
5 2
1 4
3 5
4 2
1 6
6 4
3 4
Output for the Sample Input
3
5
1
6
4
2",Python,"from collections import defaultdict, deque

def topological_sort(m, edges):
    # Build adjacency list and in-degree count
    graph = defaultdict(list)
    in_degree = [0] * (m + 1)
    
    for x, y in edges:
        graph[x].append(y)
        in_degree[y] += 1
    
    # Find all nodes with in-degree 0
    queue = deque()
    for i in range(1, m + 1):
        if in_degree[i] == 0:
            queue.append(i)
    
    result = []
    while queue:
        # Pick the smallest numbered node (for consistency)
        queue = deque(sorted(queue))
        node = queue.popleft()
        result.append(node)
        
        # Reduce in-degree for neighbors
        for neighbor in graph[node]:
            in_degree[neighbor] -= 1
            if in_degree[neighbor] == 0:
                queue.append(neighbor)
    
    return result

# Read input
m = int(input())
n = int(input())
edges = []
for _ in range(n):
    x = int(input())
    y = int(input())
    edges.append((x, y))

# Perform topological sort
order = topological_sort(m, edges)

# Output result
for suspect in order:
    print(suspect)
",0
p00119,"太郎君の執念
まんじゅう好きの太郎くんの家でたいへんな事件がおきました。和室の仏壇に供えてあった3つのまんじゅうのうち1つが無くなっていたのです。いつかはおやつにいただこうと狙っていた太郎くんが犯人を見つけるため捜査を始めると、その日、和室に入った人が何人もいることが分かりました。そこで、これらの容疑者が部屋に入った順序を調べるため、全員に次のような形式の証言をしてもらうことにました。
容疑者 A の証言 「私は容疑者 B より先に部屋に入った。」
容疑者の一人(?)は三毛猫のタマなので証言はできませんが、幸運にも最後に部屋に入ったところを太郎くんは見ていました。
太郎くんはこれらの証言から、部屋に入った順番を推測して捜査に役立てることにしました。
例えば、6 人の容疑者がいてタマを容疑者 2 とした場合、以下のような証言が得られたとします。
容疑者 5 の証言 「私は 2 より先に部屋に入った。」
容疑者 1 の証言 「私は 4 より先に部屋に入った。」
容疑者 3 の証言 「私は 5 より先に部屋に入った。」
容疑者 4 の証言 「私は 2 より先に部屋に入った。」
容疑者 1 の証言 「私は 6 より先に部屋に入った。」
容疑者 6 の証言 「私は 4 より先に部屋に入った。」
容疑者 3 の証言 「私は 4 より先に部屋に入った。」
この証言をつなぎ合わせると、部屋に入った順序は
3→5→1→6→4→2
1→6→3→4→5→2
3→1→6→5→4→2
など、何通りかの可能性に絞り込むことができます。
タマ (容疑者 2) 以外の容疑者全員の証言から、部屋に入った順番を推測し、可能性のある順番の 1 つを出力するプログラムを作成してください。ただし、複数の証言をする容疑者がいるかもしれませんが、どの証言も真実であり矛盾していないものとします。
Input
入力は以下の形式で与えられます。
m
n
x
1
y
1
x
2
y
2
:
x
n
y
n
1 行目に容疑者の人数
m
(
m
≤ 20)、2 行目に証言の数
n
(
n
≤ 100) が与えられます。
続く
n
行に
i
個目の証言の内容
x
i
,
y
i
がそれぞれ１行に与えられます。
x
i
y
i
は「容疑者
x
i
(私)は容疑者
y
i
より先に入った」という証言を表します。
Output
最初に部屋に入った容疑者の番号、2 番目に部屋に入った容疑者の番号、...、
m
番目に部屋に入った容疑者の番号をそれぞれ１行に順番に出力してください。
Sample Input
6
7
5 2
1 4
3 5
4 2
1 6
6 4
3 4
Output for the Sample Input
3
5
1
6
4
2",Python,"def solve(a):
	if len(a) == m: return a
	for i in M-set(a):
		for x,y in xy:
			if x == i and y not in a: break
		else:
			r = solve([i]+a)
			if r: return r
m = input()
M = set(range(1,m+1))
xy = [map(int,raw_input().split()) for i in range(input())]
for i in solve([]): print i",1
p00120,"パティシエ
ケーキ屋さんが、まちまちな大きさのロールケーキをたくさん作りました。あなたは、このケーキを箱に並べる仕事を任されました。
ロールケーキはとてもやわらかいので、他のロールケーキが上に乗るとつぶれてしまいます。ですから、図(a) のように全てのロールケーキは必ず箱の底面に接しているように並べなければなりません。並べ替えると必要な幅も変わります。
図(a)
図(b)
n
個のロールケーキの半径
r
1
,
r
2
, ...,
r
n
と箱の長さを読み込み、それぞれについて、箱の中にうまく収まるかどうか判定し、並べる順番を工夫すると箱に入る場合は ""OK""、どう並べても入らない場合には ""NA""を出力するプログラムを作成してください。
ロールケーキの断面は円であり、箱の壁の高さは十分に高いものとします。 ただし、ロールケーキの半径は 3 以上 10 以下の整数とします。つまり、ケーキの半径に極端な差はなく、図(b) のように大きなケーキの間に小さなケーキがはまり込んでしまうことはありません。
Input
入力は複数のデータセットからなります。各データセットは以下の形式で与えられます。
W
r
1
r
2
...
r
n
最初に箱の長さを表す整数
W
(1 ≤
W
≤ 1,000) が与えられます。 続いて、空白区切りで各ロールケーキの半径を表す整数
r
i
(3 ≤
r
i
≤ 10) が与えられます。ケーキの個数
n
は 12 以下です。
データセットの数は 50 を超えません。
Output
データセットごとに OK または NA を１行に出力してください。
Sample Input
30 4 5 6
30 5 5 5
50 3 3 3 10 10
49 3 3 3 10 10
Output for the Sample Input
OK
OK
OK
NA",C,"#include <stdio.h>
#include <stdlib.h>
#include <math.h>
#include <string.h>

int n;
int r[12];
int perm[12];
int used[12];
double W;

double calc_width(int *order, int len) {
    if (len == 0) return 0;
    if (len == 1) return 2.0 * r[order[0]];
    
    double pos[12];
    pos[0] = r[order[0]];
    
    for (int i = 1; i < len; i++) {
        double max_pos = r[order[i]];
        
        for (int j = 0; j < i; j++) {
            double ri = r[order[i]];
            double rj = r[order[j]];
            double d = 2.0 * sqrt(ri * rj);
            double candidate = pos[j] + d;
            if (candidate > max_pos) {
                max_pos = candidate;
            }
        }
        
        pos[i] = max_pos;
    }
    
    double max_right = 0;
    for (int i = 0; i < len; i++) {
        double right = pos[i] + r[order[i]];
        if (right > max_right) {
            max_right = right;
        }
    }
    
    return max_right;
}

int try_permutation(int depth) {
    if (depth == n) {
        double width = calc_width(perm, n);
        return width <= W + 1e-9;
    }
    
    for (int i = 0; i < n; i++) {
        if (!used[i]) {
            used[i] = 1;
            perm[depth] = i;
            if (try_permutation(depth + 1)) {
                return 1;
            }
            used[i] = 0;
        }
    }
    
    return 0;
}

int main() {
    char line[1000];
    
    while (fgets(line, sizeof(line), stdin)) {
        n = 0;
        char *token = strtok(line, "" \n"");
        W = atof(token);
        
        while ((token = strtok(NULL, "" \n"")) != NULL) {
            r[n++] = atoi(token);
        }
        
        if (n == 0) continue;
        
        memset(used, 0, sizeof(used));
        
        if (try_permutation(0)) {
            printf(""OK\n"");
        } else {
            printf(""NA\n"");
        }
    }
    
    return 0;
}
",0
p00120,"パティシエ
ケーキ屋さんが、まちまちな大きさのロールケーキをたくさん作りました。あなたは、このケーキを箱に並べる仕事を任されました。
ロールケーキはとてもやわらかいので、他のロールケーキが上に乗るとつぶれてしまいます。ですから、図(a) のように全てのロールケーキは必ず箱の底面に接しているように並べなければなりません。並べ替えると必要な幅も変わります。
図(a)
図(b)
n
個のロールケーキの半径
r
1
,
r
2
, ...,
r
n
と箱の長さを読み込み、それぞれについて、箱の中にうまく収まるかどうか判定し、並べる順番を工夫すると箱に入る場合は ""OK""、どう並べても入らない場合には ""NA""を出力するプログラムを作成してください。
ロールケーキの断面は円であり、箱の壁の高さは十分に高いものとします。 ただし、ロールケーキの半径は 3 以上 10 以下の整数とします。つまり、ケーキの半径に極端な差はなく、図(b) のように大きなケーキの間に小さなケーキがはまり込んでしまうことはありません。
Input
入力は複数のデータセットからなります。各データセットは以下の形式で与えられます。
W
r
1
r
2
...
r
n
最初に箱の長さを表す整数
W
(1 ≤
W
≤ 1,000) が与えられます。 続いて、空白区切りで各ロールケーキの半径を表す整数
r
i
(3 ≤
r
i
≤ 10) が与えられます。ケーキの個数
n
は 12 以下です。
データセットの数は 50 を超えません。
Output
データセットごとに OK または NA を１行に出力してください。
Sample Input
30 4 5 6
30 5 5 5
50 3 3 3 10 10
49 3 3 3 10 10
Output for the Sample Input
OK
OK
OK
NA",C,"#include <stdio.h>
#include <string.h>
#include <math.h>

#define SQ(x) ((x) * (x))
#define INF (100000000)
#define EPS (1e-5)

double len;
double cake[12];
double dp[1 << 12][12];
int n;

double min(double a, double b)
{
    return (b > a ? a : b);
}

double tsp(int bit, int now)
{
    int i;
    double res;
    
    if (dp[bit][now] >= 0){
        return (dp[bit][now]);
    }
    
    if (bit == (1 << n) - 1 && now == 0){
        return (dp[bit][now] = 0);
    }
    
    res = INF;
    for (i = 0; i < n; i++){
        if (!((bit >> i) & 1)){
            res = min(res, tsp(bit | (1 << i), i) + sqrt(SQ(cake[i] + cake[now]) - SQ(cake[i] - cake[now])));
        }
    }
    
    return (dp[bit][now] = res);
}

int main(void)
{
    int i, j;
    
    while (scanf(""%lf"", &len) != EOF){
        getchar();
        n = 0;
        while (1){
            scanf(""%lf"", &cake[n++]);
            
            if (getchar() == '\n'){
                break;
            }
        }
        
        for (i = 0; i < (1 << 12); i++){
            for (j = 0; j < 12; j++){
                dp[i][j] = -1 * INF;
            }
        }
        
        if (tsp(0, 0) < len + EPS){
            printf(""OK\n"");
        }
        else {
            printf(""NA\n"");
        }
    }
    
    return (0);
}",1
p00120,"パティシエ
ケーキ屋さんが、まちまちな大きさのロールケーキをたくさん作りました。あなたは、このケーキを箱に並べる仕事を任されました。
ロールケーキはとてもやわらかいので、他のロールケーキが上に乗るとつぶれてしまいます。ですから、図(a) のように全てのロールケーキは必ず箱の底面に接しているように並べなければなりません。並べ替えると必要な幅も変わります。
図(a)
図(b)
n
個のロールケーキの半径
r
1
,
r
2
, ...,
r
n
と箱の長さを読み込み、それぞれについて、箱の中にうまく収まるかどうか判定し、並べる順番を工夫すると箱に入る場合は ""OK""、どう並べても入らない場合には ""NA""を出力するプログラムを作成してください。
ロールケーキの断面は円であり、箱の壁の高さは十分に高いものとします。 ただし、ロールケーキの半径は 3 以上 10 以下の整数とします。つまり、ケーキの半径に極端な差はなく、図(b) のように大きなケーキの間に小さなケーキがはまり込んでしまうことはありません。
Input
入力は複数のデータセットからなります。各データセットは以下の形式で与えられます。
W
r
1
r
2
...
r
n
最初に箱の長さを表す整数
W
(1 ≤
W
≤ 1,000) が与えられます。 続いて、空白区切りで各ロールケーキの半径を表す整数
r
i
(3 ≤
r
i
≤ 10) が与えられます。ケーキの個数
n
は 12 以下です。
データセットの数は 50 を超えません。
Output
データセットごとに OK または NA を１行に出力してください。
Sample Input
30 4 5 6
30 5 5 5
50 3 3 3 10 10
49 3 3 3 10 10
Output for the Sample Input
OK
OK
OK
NA",Java,"import java.util.*;
import java.io.*;

public class Main {
    static double EPS = 1e-9;
    
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        
        while (sc.hasNext()) {
            String line = sc.nextLine().trim();
            if (line.isEmpty()) continue;
            
            String[] parts = line.split(""\\s+"");
            int W = Integer.parseInt(parts[0]);
            
            List<Integer> radii = new ArrayList<>();
            for (int i = 1; i < parts.length; i++) {
                radii.add(Integer.parseInt(parts[i]));
            }
            
            int n = radii.size();
            if (n == 0) {
                System.out.println(""OK"");
                continue;
            }
            
            boolean found = false;
            int[] perm = new int[n];
            for (int i = 0; i < n; i++) {
                perm[i] = i;
            }
            
            do {
                double width = calculateWidth(radii, perm);
                if (width <= W + EPS) {
                    found = true;
                    break;
                }
            } while (nextPermutation(perm));
            
            System.out.println(found ? ""OK"" : ""NA"");
        }
        
        sc.close();
    }
    
    static double calculateWidth(List<Integer> radii, int[] perm) {
        int n = perm.length;
        if (n == 0) return 0;
        if (n == 1) return 2.0 * radii.get(perm[0]);
        
        double[] positions = new double[n];
        positions[0] = radii.get(perm[0]);
        
        for (int i = 1; i < n; i++) {
            double maxPos = radii.get(perm[i]);
            
            for (int j = 0; j < i; j++) {
                double r1 = radii.get(perm[j]);
                double r2 = radii.get(perm[i]);
                double dist = 2.0 * Math.sqrt(r1 * r2);
                double pos = positions[j] + dist;
                maxPos = Math.max(maxPos, pos);
            }
            
            positions[i] = maxPos;
        }
        
        double minX = Double.MAX_VALUE;
        double maxX = -Double.MAX_VALUE;
        
        for (int i = 0; i < n; i++) {
            double r = radii.get(perm[i]);
            minX = Math.min(minX, positions[i] - r);
            maxX = Math.max(maxX, positions[i] + r);
        }
        
        return maxX - minX;
    }
    
    static boolean nextPermutation(int[] array) {
        int i = array.length - 2;
        while (i >= 0 && array[i] >= array[i + 1]) {
            i--;
        }
        
        if (i < 0) {
            return false;
        }
        
        int j = array.length - 1;
        while (array[j] <= array[i]) {
            j--;
        }
        
        swap(array, i, j);
        reverse(array, i + 1, array.length - 1);
        
        return true;
    }
    
    static void swap(int[] array, int i, int j) {
        int temp = array[i];
        array[i] = array[j];
        array[j] = temp;
    }
    
    static void reverse(int[] array, int start, int end) {
        while (start < end) {
            swap(array, start, end);
            start++;
            end--;
        }
    }
}
",0
p00120,"パティシエ
ケーキ屋さんが、まちまちな大きさのロールケーキをたくさん作りました。あなたは、このケーキを箱に並べる仕事を任されました。
ロールケーキはとてもやわらかいので、他のロールケーキが上に乗るとつぶれてしまいます。ですから、図(a) のように全てのロールケーキは必ず箱の底面に接しているように並べなければなりません。並べ替えると必要な幅も変わります。
図(a)
図(b)
n
個のロールケーキの半径
r
1
,
r
2
, ...,
r
n
と箱の長さを読み込み、それぞれについて、箱の中にうまく収まるかどうか判定し、並べる順番を工夫すると箱に入る場合は ""OK""、どう並べても入らない場合には ""NA""を出力するプログラムを作成してください。
ロールケーキの断面は円であり、箱の壁の高さは十分に高いものとします。 ただし、ロールケーキの半径は 3 以上 10 以下の整数とします。つまり、ケーキの半径に極端な差はなく、図(b) のように大きなケーキの間に小さなケーキがはまり込んでしまうことはありません。
Input
入力は複数のデータセットからなります。各データセットは以下の形式で与えられます。
W
r
1
r
2
...
r
n
最初に箱の長さを表す整数
W
(1 ≤
W
≤ 1,000) が与えられます。 続いて、空白区切りで各ロールケーキの半径を表す整数
r
i
(3 ≤
r
i
≤ 10) が与えられます。ケーキの個数
n
は 12 以下です。
データセットの数は 50 を超えません。
Output
データセットごとに OK または NA を１行に出力してください。
Sample Input
30 4 5 6
30 5 5 5
50 3 3 3 10 10
49 3 3 3 10 10
Output for the Sample Input
OK
OK
OK
NA",Java,"import java.io.*;
import java.util.*;

public class Main{
	public static void main(String args[]){
		try{
			new Main();
		}catch(IOException err){
			err.printStackTrace();
		}
	}

	public Main() throws IOException{
		BufferedReader in = new BufferedReader(new InputStreamReader(System.in));
		ArrayList<String> Ans = new ArrayList<String>();
		String line;

		while((line = in.readLine()) != null){
			String[] dst = line.split("" "");
			int size = Integer.parseInt(dst[0]);

			if(size == 0) break;
			int[] seq = new int[dst.length-1];
			int[] radius = new int[dst.length-1];
			for(int i=1; i<dst.length; i++){
				radius[i-1] = Integer.parseInt(dst[i]);
			}

			for(int i=0; i<dst.length-1; i++){
				seq[i] = i;
			}

			int ok = 0;
			do{
//				for(int i=0; i<seq.length; i++){
//					System.out.print(seq[i]);
//				}
//				System.out.println();

				double cakes = calcSize(radius, seq);
				if(size >= cakes){
					Ans.add(""OK"");
					ok = 1;
					break;
				}
			}while(nextArray(seq));

			if(ok == 0){
				Ans.add(""NA"");
			}
		}

		for(int n=0; n<Ans.size(); n++){
			System.out.println(Ans.get(n));
		}
	}

	public boolean nextArray(int[] seq){
		int s = seq.length-1;
		while(true){
			if(seq[s] > seq[s-1]){
				int min = seq[s];
				int index = s;
				for(int n=s+1; n<seq.length; n++){
					if(min > seq[n] && seq[n] > seq[s-1]){
						min = seq[n];
						index = n;
					}
				}

				seq[index] = seq[s-1];
				seq[s-1] = min;
				Arrays.sort(seq, s, seq.length-1);
				return true;

			}else{
				s--;
			}

			if(s == 0){
				return false;
			}
		}
	}

	public double calcSize(int[] data, int[] seq){
		double sum = 0.0;
		
		
		return sum;
	}
}",1
p00120,"パティシエ
ケーキ屋さんが、まちまちな大きさのロールケーキをたくさん作りました。あなたは、このケーキを箱に並べる仕事を任されました。
ロールケーキはとてもやわらかいので、他のロールケーキが上に乗るとつぶれてしまいます。ですから、図(a) のように全てのロールケーキは必ず箱の底面に接しているように並べなければなりません。並べ替えると必要な幅も変わります。
図(a)
図(b)
n
個のロールケーキの半径
r
1
,
r
2
, ...,
r
n
と箱の長さを読み込み、それぞれについて、箱の中にうまく収まるかどうか判定し、並べる順番を工夫すると箱に入る場合は ""OK""、どう並べても入らない場合には ""NA""を出力するプログラムを作成してください。
ロールケーキの断面は円であり、箱の壁の高さは十分に高いものとします。 ただし、ロールケーキの半径は 3 以上 10 以下の整数とします。つまり、ケーキの半径に極端な差はなく、図(b) のように大きなケーキの間に小さなケーキがはまり込んでしまうことはありません。
Input
入力は複数のデータセットからなります。各データセットは以下の形式で与えられます。
W
r
1
r
2
...
r
n
最初に箱の長さを表す整数
W
(1 ≤
W
≤ 1,000) が与えられます。 続いて、空白区切りで各ロールケーキの半径を表す整数
r
i
(3 ≤
r
i
≤ 10) が与えられます。ケーキの個数
n
は 12 以下です。
データセットの数は 50 を超えません。
Output
データセットごとに OK または NA を１行に出力してください。
Sample Input
30 4 5 6
30 5 5 5
50 3 3 3 10 10
49 3 3 3 10 10
Output for the Sample Input
OK
OK
OK
NA",Python,"import sys
import math
from itertools import permutations

def calc_distance(r1, r2):
    # Distance between centers of two circles touching each other and both touching the bottom
    return 2 * math.sqrt(r1 * r2)

def calc_width(radii):
    if len(radii) == 0:
        return 0
    if len(radii) == 1:
        return 2 * radii[0]
    
    # Position circles one by one
    positions = [radii[0]]  # x-coordinate of center of each circle
    
    for i in range(1, len(radii)):
        # Find the rightmost position where circle i can be placed
        min_x = radii[i]  # At least this far from left wall
        
        for j in range(i):
            # Must be at least calc_distance away from circle j
            required_dist = calc_distance(radii[i], radii[j])
            min_x = max(min_x, positions[j] + required_dist)
        
        positions.append(min_x)
    
    # Total width is rightmost position + its radius
    return positions[-1] + radii[-1]

def solve(W, radii):
    n = len(radii)
    
    if n == 0:
        return ""OK""
    
    # Try all permutations
    for perm in permutations(radii):
        width = calc_width(list(perm))
        if width <= W:
            return ""OK""
    
    return ""NA""

for line in sys.stdin:
    parts = list(map(int, line.strip().split()))
    W = parts[0]
    radii = parts[1:]
    print(solve(W, radii))
",0
p00120,"パティシエ
ケーキ屋さんが、まちまちな大きさのロールケーキをたくさん作りました。あなたは、このケーキを箱に並べる仕事を任されました。
ロールケーキはとてもやわらかいので、他のロールケーキが上に乗るとつぶれてしまいます。ですから、図(a) のように全てのロールケーキは必ず箱の底面に接しているように並べなければなりません。並べ替えると必要な幅も変わります。
図(a)
図(b)
n
個のロールケーキの半径
r
1
,
r
2
, ...,
r
n
と箱の長さを読み込み、それぞれについて、箱の中にうまく収まるかどうか判定し、並べる順番を工夫すると箱に入る場合は ""OK""、どう並べても入らない場合には ""NA""を出力するプログラムを作成してください。
ロールケーキの断面は円であり、箱の壁の高さは十分に高いものとします。 ただし、ロールケーキの半径は 3 以上 10 以下の整数とします。つまり、ケーキの半径に極端な差はなく、図(b) のように大きなケーキの間に小さなケーキがはまり込んでしまうことはありません。
Input
入力は複数のデータセットからなります。各データセットは以下の形式で与えられます。
W
r
1
r
2
...
r
n
最初に箱の長さを表す整数
W
(1 ≤
W
≤ 1,000) が与えられます。 続いて、空白区切りで各ロールケーキの半径を表す整数
r
i
(3 ≤
r
i
≤ 10) が与えられます。ケーキの個数
n
は 12 以下です。
データセットの数は 50 を超えません。
Output
データセットごとに OK または NA を１行に出力してください。
Sample Input
30 4 5 6
30 5 5 5
50 3 3 3 10 10
49 3 3 3 10 10
Output for the Sample Input
OK
OK
OK
NA",Python,"# -*- coding: utf-8 -*-
""""""
http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=0120

""""""
import sys
from sys import stdin
input = stdin.readline


def calc_width(cakes):
    # ??±????????????????????????(?????????)????????????????????????????????????????¨??????????
    if len(cakes) == 1:
        return cakes[0]*2

    prev_r = cakes[0]
    width = prev_r

    for r in cakes[1:]:
        h_diff = abs(prev_r - r)
        w = ((prev_r + r)**2 - h_diff**2)**0.5
        width += w
        prev_r = r
    width += cakes[-1]

    return width


def main(args):
    for line in sys.stdin:
        data = [int(x) for x in line.strip().split()]
        box_size = data[0]
        temp = data[1:]
        temp.sort()

        # ??±??????????????????????????????????????????????????????????????????????????????
        min_width = float('inf')

        cakes = [temp[0]]
        temp = temp[1:]
        pick_large = True
        while temp:
            if pick_large:
                pick = temp[-1]
                temp = temp[:-1]
                pick_large = False
                diff_front = abs(pick - cakes[0])
                diff_rear = abs(pick - cakes[-1])
                if diff_front > diff_rear:
                    cakes.insert(0, pick)
                else:
                    cakes.append(pick)
            else:
                pick = temp[0]
                temp = temp[1:]
                pick_large = True
                diff_front = abs(pick - cakes[0])
                diff_rear = abs(pick - cakes[-1])
                if diff_front > diff_rear:
                    cakes.insert(0, pick)
                else:
                    cakes.append(pick)

        result = calc_width(cakes)
        min_width = min(result, min_width)

        if min_width <= box_size:
            print('OK')
        else:
            print('NA')


if __name__ == '__main__':
    main(sys.argv[1:])
    ",1
p00121,"7 パズル
7 パズルは 8 つの正方形のカードとこれらのカードがぴたりと収まる枠で構成されています。それぞれのカードには、互いに区別できるように 0, 1, 2, ..., 7 と番号がつけられています。枠には、縦に 2 個、横に 4 個のカードを並べることができます。
7 パズルを始めるときには、まず枠にすべてのカードを入れます。枠のなかで 0 のカードだけは、上下左右に隣接するカードと位置を交換することができます。たとえば、枠の状態が図(a) のときに、0 のカードの右に隣接した、7 のカードと位置を交換すれば、図(b) の状態になります。あるいは、図(a) の状態から 0 のカードの下に隣接した 2 のカードと位置を交換すれば図(c) の状態になります。図(a) の状態で 0 のカードと上下左右に隣接するカードは 7 と 2 のカードだけなので、これ以外の位置の入れ替えは許されません。
ゲームの目的は、カードをきれいに整列して図(d) の状態にすることです。最初の状態を入力とし、カードをきれいに整列するまでに、必要な最小手数を出力するプログラムを作成してください。ただし、入力されたカードの状態からは図(d) の状態に移ることは可能であるとします。
入力データは、1 行に 8 つの数字が空白区切りで与えられます。これらは、最初の状態のカードの並びを表します。例えば、図(a) の数字表現は
0 7 3 4 2 5 1 6
に、図(c) は
2 7 3 4 0 5 1 6
となります。
図(a)
0 7 3 4 2 5 1 6
の場合
図(b)
7 0 3 4 2 5 1 6
の場合
図(c)
2 7 3 4 0 5 1 6
の場合
図(d)
0 1 2 3 4 5 6 7
(最終状態)
Input
上記形式で複数のパズルが与えられます。入力の最後まで処理してください。
与えられるパズルの数は 1,000 以下です。
Output
各パズルについて、最終状態へ移行する最小手数を１行に出力してください。
Sample Input
0 1 2 3 4 5 6 7
1 0 2 3 4 5 6 7
7 6 5 4 3 2 1 0
Output for the Sample Input
0
1
28",C,"#include <stdio.h>
#include <string.h>
#include <stdlib.h>

#define MAX_STATES 362880

typedef struct {
    int state[8];
    int dist;
} Node;

int visited[MAX_STATES];
Node queue[MAX_STATES];
int front, rear;

int encode(int state[8]) {
    int code = 0;
    int base = 1;
    for (int i = 7; i >= 0; i--) {
        int digit = state[i];
        for (int j = i + 1; j < 8; j++) {
            if (state[j] < state[i]) digit--;
        }
        code += digit * base;
        base *= (8 - i);
    }
    return code;
}

int bfs(int start[8]) {
    memset(visited, -1, sizeof(visited));
    front = rear = 0;
    
    memcpy(queue[rear].state, start, sizeof(int) * 8);
    queue[rear].dist = 0;
    rear++;
    
    int start_code = encode(start);
    visited[start_code] = 0;
    
    int goal[8] = {0, 1, 2, 3, 4, 5, 6, 7};
    int goal_code = encode(goal);
    
    if (start_code == goal_code) return 0;
    
    while (front < rear) {
        Node current = queue[front++];
        
        int pos0 = -1;
        for (int i = 0; i < 8; i++) {
            if (current.state[i] == 0) {
                pos0 = i;
                break;
            }
        }
        
        int row = pos0 / 4;
        int col = pos0 % 4;
        
        int dr[] = {-1, 1, 0, 0};
        int dc[] = {0, 0, -1, 1};
        
        for (int d = 0; d < 4; d++) {
            int new_row = row + dr[d];
            int new_col = col + dc[d];
            
            if (new_row >= 0 && new_row < 2 && new_col >= 0 && new_col < 4) {
                int new_pos = new_row * 4 + new_col;
                
                int new_state[8];
                memcpy(new_state, current.state, sizeof(int) * 8);
                
                int temp = new_state[pos0];
                new_state[pos0] = new_state[new_pos];
                new_state[new_pos] = temp;
                
                int new_code = encode(new_state);
                
                if (visited[new_code] == -1) {
                    visited[new_code] = current.dist + 1;
                    
                    if (new_code == goal_code) {
                        return current.dist + 1;
                    }
                    
                    memcpy(queue[rear].state, new_state, sizeof(int) * 8);
                    queue[rear].dist = current.dist + 1;
                    rear++;
                }
            }
        }
    }
    
    return -1;
}

int main() {
    int state[8];
    
    while (scanf(""%d"", &state[0]) == 1) {
        for (int i = 1; i < 8; i++) {
            scanf(""%d"", &state[i]);
        }
        
        int result = bfs(state);
        printf(""%d\n"", result);
    }
    
    return 0;
}
",0
p00121,"7 パズル
7 パズルは 8 つの正方形のカードとこれらのカードがぴたりと収まる枠で構成されています。それぞれのカードには、互いに区別できるように 0, 1, 2, ..., 7 と番号がつけられています。枠には、縦に 2 個、横に 4 個のカードを並べることができます。
7 パズルを始めるときには、まず枠にすべてのカードを入れます。枠のなかで 0 のカードだけは、上下左右に隣接するカードと位置を交換することができます。たとえば、枠の状態が図(a) のときに、0 のカードの右に隣接した、7 のカードと位置を交換すれば、図(b) の状態になります。あるいは、図(a) の状態から 0 のカードの下に隣接した 2 のカードと位置を交換すれば図(c) の状態になります。図(a) の状態で 0 のカードと上下左右に隣接するカードは 7 と 2 のカードだけなので、これ以外の位置の入れ替えは許されません。
ゲームの目的は、カードをきれいに整列して図(d) の状態にすることです。最初の状態を入力とし、カードをきれいに整列するまでに、必要な最小手数を出力するプログラムを作成してください。ただし、入力されたカードの状態からは図(d) の状態に移ることは可能であるとします。
入力データは、1 行に 8 つの数字が空白区切りで与えられます。これらは、最初の状態のカードの並びを表します。例えば、図(a) の数字表現は
0 7 3 4 2 5 1 6
に、図(c) は
2 7 3 4 0 5 1 6
となります。
図(a)
0 7 3 4 2 5 1 6
の場合
図(b)
7 0 3 4 2 5 1 6
の場合
図(c)
2 7 3 4 0 5 1 6
の場合
図(d)
0 1 2 3 4 5 6 7
(最終状態)
Input
上記形式で複数のパズルが与えられます。入力の最後まで処理してください。
与えられるパズルの数は 1,000 以下です。
Output
各パズルについて、最終状態へ移行する最小手数を１行に出力してください。
Sample Input
0 1 2 3 4 5 6 7
1 0 2 3 4 5 6 7
7 6 5 4 3 2 1 0
Output for the Sample Input
0
1
28",C,"#include<iostream>
#include<cstdio>
#include<queue>
#include<algorithm>
#include<string>
#include<vector>
#include<cstdlib>

using namespace std;

#define maxn 305

int map[3][5];

int main()
{
	int i,j;
cin>>i;
cout<<1<<endl;


	return 0;
}

",1
p00121,"7 パズル
7 パズルは 8 つの正方形のカードとこれらのカードがぴたりと収まる枠で構成されています。それぞれのカードには、互いに区別できるように 0, 1, 2, ..., 7 と番号がつけられています。枠には、縦に 2 個、横に 4 個のカードを並べることができます。
7 パズルを始めるときには、まず枠にすべてのカードを入れます。枠のなかで 0 のカードだけは、上下左右に隣接するカードと位置を交換することができます。たとえば、枠の状態が図(a) のときに、0 のカードの右に隣接した、7 のカードと位置を交換すれば、図(b) の状態になります。あるいは、図(a) の状態から 0 のカードの下に隣接した 2 のカードと位置を交換すれば図(c) の状態になります。図(a) の状態で 0 のカードと上下左右に隣接するカードは 7 と 2 のカードだけなので、これ以外の位置の入れ替えは許されません。
ゲームの目的は、カードをきれいに整列して図(d) の状態にすることです。最初の状態を入力とし、カードをきれいに整列するまでに、必要な最小手数を出力するプログラムを作成してください。ただし、入力されたカードの状態からは図(d) の状態に移ることは可能であるとします。
入力データは、1 行に 8 つの数字が空白区切りで与えられます。これらは、最初の状態のカードの並びを表します。例えば、図(a) の数字表現は
0 7 3 4 2 5 1 6
に、図(c) は
2 7 3 4 0 5 1 6
となります。
図(a)
0 7 3 4 2 5 1 6
の場合
図(b)
7 0 3 4 2 5 1 6
の場合
図(c)
2 7 3 4 0 5 1 6
の場合
図(d)
0 1 2 3 4 5 6 7
(最終状態)
Input
上記形式で複数のパズルが与えられます。入力の最後まで処理してください。
与えられるパズルの数は 1,000 以下です。
Output
各パズルについて、最終状態へ移行する最小手数を１行に出力してください。
Sample Input
0 1 2 3 4 5 6 7
1 0 2 3 4 5 6 7
7 6 5 4 3 2 1 0
Output for the Sample Input
0
1
28",Java,"import java.util.*;

public class Main {
    static final int[] TARGET = {0, 1, 2, 3, 4, 5, 6, 7};
    static final int[][] MOVES = {{1}, {0, 2}, {1, 3}, {2}, {5}, {4, 6}, {5, 7}, {6}};
    
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        
        while (sc.hasNextLine()) {
            String line = sc.nextLine().trim();
            if (line.isEmpty()) break;
            
            String[] parts = line.split(""\\s+"");
            int[] initial = new int[8];
            for (int i = 0; i < 8; i++) {
                initial[i] = Integer.parseInt(parts[i]);
            }
            
            System.out.println(bfs(initial));
        }
        sc.close();
    }
    
    static int bfs(int[] initial) {
        if (Arrays.equals(initial, TARGET)) {
            return 0;
        }
        
        Queue<State> queue = new LinkedList<>();
        Set<String> visited = new HashSet<>();
        
        State start = new State(initial, 0);
        queue.offer(start);
        visited.add(stateToString(initial));
        
        while (!queue.isEmpty()) {
            State current = queue.poll();
            
            int zeroPos = -1;
            for (int i = 0; i < 8; i++) {
                if (current.board[i] == 0) {
                    zeroPos = i;
                    break;
                }
            }
            
            for (int nextPos : MOVES[zeroPos]) {
                int[] newBoard = current.board.clone();
                newBoard[zeroPos] = newBoard[nextPos];
                newBoard[nextPos] = 0;
                
                if (Arrays.equals(newBoard, TARGET)) {
                    return current.moves + 1;
                }
                
                String stateStr = stateToString(newBoard);
                if (!visited.contains(stateStr)) {
                    visited.add(stateStr);
                    queue.offer(new State(newBoard, current.moves + 1));
                }
            }
        }
        
        return -1;
    }
    
    static String stateToString(int[] board) {
        StringBuilder sb = new StringBuilder();
        for (int i = 0; i < 8; i++) {
            sb.append(board[i]);
        }
        return sb.toString();
    }
    
    static class State {
        int[] board;
        int moves;
        
        State(int[] board, int moves) {
            this.board = board;
            this.moves = moves;
        }
    }
}
",0
p00121,"7 パズル
7 パズルは 8 つの正方形のカードとこれらのカードがぴたりと収まる枠で構成されています。それぞれのカードには、互いに区別できるように 0, 1, 2, ..., 7 と番号がつけられています。枠には、縦に 2 個、横に 4 個のカードを並べることができます。
7 パズルを始めるときには、まず枠にすべてのカードを入れます。枠のなかで 0 のカードだけは、上下左右に隣接するカードと位置を交換することができます。たとえば、枠の状態が図(a) のときに、0 のカードの右に隣接した、7 のカードと位置を交換すれば、図(b) の状態になります。あるいは、図(a) の状態から 0 のカードの下に隣接した 2 のカードと位置を交換すれば図(c) の状態になります。図(a) の状態で 0 のカードと上下左右に隣接するカードは 7 と 2 のカードだけなので、これ以外の位置の入れ替えは許されません。
ゲームの目的は、カードをきれいに整列して図(d) の状態にすることです。最初の状態を入力とし、カードをきれいに整列するまでに、必要な最小手数を出力するプログラムを作成してください。ただし、入力されたカードの状態からは図(d) の状態に移ることは可能であるとします。
入力データは、1 行に 8 つの数字が空白区切りで与えられます。これらは、最初の状態のカードの並びを表します。例えば、図(a) の数字表現は
0 7 3 4 2 5 1 6
に、図(c) は
2 7 3 4 0 5 1 6
となります。
図(a)
0 7 3 4 2 5 1 6
の場合
図(b)
7 0 3 4 2 5 1 6
の場合
図(c)
2 7 3 4 0 5 1 6
の場合
図(d)
0 1 2 3 4 5 6 7
(最終状態)
Input
上記形式で複数のパズルが与えられます。入力の最後まで処理してください。
与えられるパズルの数は 1,000 以下です。
Output
各パズルについて、最終状態へ移行する最小手数を１行に出力してください。
Sample Input
0 1 2 3 4 5 6 7
1 0 2 3 4 5 6 7
7 6 5 4 3 2 1 0
Output for the Sample Input
0
1
28",Java,"import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashMap;
import java.util.HashSet;
import java.util.LinkedList;
import java.util.Scanner;

public class Main {
	MyScanner sc = new MyScanner();
	Scanner sc2 = new Scanner(System.in);

	void run() {
		HashMap<ArrayList<Integer>, Integer> hm = new HashMap<ArrayList<Integer>, Integer>();
		ArrayList<Integer> list = new ArrayList<Integer>();
		for (int i = 0; i < 8; i++) {
			list.add(i);
		}
		int cnt = 0;
		hm.put(list, cnt);

		LinkedList<ArrayList<Integer>> queue = new LinkedList<ArrayList<Integer>>();
		queue.add(list);
		while (!queue.isEmpty()) {
			int size = queue.size();
			for (int i = 0; i < size; i++) {
				ArrayList<Integer> l = queue.poll();
				int zeroIndex = 0;
				for (int j = 0; j < 8; j++) {
					if (l.get(j) == 0) {
						zeroIndex = j;
					}
				}
				if (zeroIndex - 1 >= 0 && zeroIndex != 4) {
					ArrayList<Integer> add = new ArrayList<Integer>(l);
					int t = l.get(zeroIndex);
					int r = l.get(zeroIndex - 1);
					add.set(zeroIndex, r);
					add.set(zeroIndex - 1, t);
					if (!hm.containsKey(add)) {
						hm.put(add, cnt + 1);
						queue.add(add);
					}
				}
				if (zeroIndex + 1 < 8 && zeroIndex != 3) {
					ArrayList<Integer> add = new ArrayList<Integer>(l);
					int t = l.get(zeroIndex);
					int r = l.get(zeroIndex + 1);
					add.set(zeroIndex, r);
					add.set(zeroIndex + 1, t);
					if (!hm.containsKey(add)) {
						hm.put(add, cnt + 1);
						queue.add(add);
					}
				}
				ArrayList<Integer> add = new ArrayList<Integer>(l);
				int t = l.get(zeroIndex);
				int r = l.get((zeroIndex + 4) % 8);
				add.set(zeroIndex, r);
				add.set((zeroIndex + 4) % 8, t);
				if (!hm.containsKey(add)) {
					hm.put(add, cnt + 1);
					queue.add(add);
				}
			}
			cnt++;
		}
		while (sc2.hasNext()) {
			String input[] = sc2.nextLine().split("" "");
			ArrayList<Integer> in = new ArrayList<Integer>();
			for (int i = 0; i < 8; i++) {
				in.add(Integer.valueOf(input[i]));
			}
			System.out.println(hm.get(in));
		}
	}

	boolean check(ArrayList<Integer> list) {
		boolean judge = true;
		for (int i = 0; i < 8; i++) {
			if (list.get(i) != i) {
				judge = false;
			}
		}
		return judge;
	}

	public static void main(String[] args) {
		new Main().run();
	}

	void debug(Object... o) {
		System.out.println(Arrays.deepToString(o));
	}

	void debug2(int[][] array) {
		for (int i = 0; i < array.length; i++) {
			for (int j = 0; j < array[i].length; j++) {
				System.out.print(array[i][j]);
			}
			System.out.println();
		}
	}

	class MyScanner {
		int nextInt() {
			try {
				int c = System.in.read();
				while (c != '-' && (c < '0' || '9' < c))
					c = System.in.read();
				if (c == '-')
					return -nextInt();
				int res = 0;
				do {
					res *= 10;
					res += c - '0';
					c = System.in.read();
				} while ('0' <= c && c <= '9');
				return res;
			} catch (Exception e) {
				return -1;
			}
		}

		double nextDouble() {
			return Double.parseDouble(next());
		}

		String next() {
			try {
				StringBuilder res = new StringBuilder("""");
				int c = System.in.read();
				while (Character.isWhitespace(c))
					c = System.in.read();
				do {
					res.append((char) c);
				} while (!Character.isWhitespace(c = System.in.read()));
				return res.toString();
			} catch (Exception e) {
				return null;
			}
		}
	}
}",1
p00121,"7 パズル
7 パズルは 8 つの正方形のカードとこれらのカードがぴたりと収まる枠で構成されています。それぞれのカードには、互いに区別できるように 0, 1, 2, ..., 7 と番号がつけられています。枠には、縦に 2 個、横に 4 個のカードを並べることができます。
7 パズルを始めるときには、まず枠にすべてのカードを入れます。枠のなかで 0 のカードだけは、上下左右に隣接するカードと位置を交換することができます。たとえば、枠の状態が図(a) のときに、0 のカードの右に隣接した、7 のカードと位置を交換すれば、図(b) の状態になります。あるいは、図(a) の状態から 0 のカードの下に隣接した 2 のカードと位置を交換すれば図(c) の状態になります。図(a) の状態で 0 のカードと上下左右に隣接するカードは 7 と 2 のカードだけなので、これ以外の位置の入れ替えは許されません。
ゲームの目的は、カードをきれいに整列して図(d) の状態にすることです。最初の状態を入力とし、カードをきれいに整列するまでに、必要な最小手数を出力するプログラムを作成してください。ただし、入力されたカードの状態からは図(d) の状態に移ることは可能であるとします。
入力データは、1 行に 8 つの数字が空白区切りで与えられます。これらは、最初の状態のカードの並びを表します。例えば、図(a) の数字表現は
0 7 3 4 2 5 1 6
に、図(c) は
2 7 3 4 0 5 1 6
となります。
図(a)
0 7 3 4 2 5 1 6
の場合
図(b)
7 0 3 4 2 5 1 6
の場合
図(c)
2 7 3 4 0 5 1 6
の場合
図(d)
0 1 2 3 4 5 6 7
(最終状態)
Input
上記形式で複数のパズルが与えられます。入力の最後まで処理してください。
与えられるパズルの数は 1,000 以下です。
Output
各パズルについて、最終状態へ移行する最小手数を１行に出力してください。
Sample Input
0 1 2 3 4 5 6 7
1 0 2 3 4 5 6 7
7 6 5 4 3 2 1 0
Output for the Sample Input
0
1
28",Python,"from collections import deque
import sys

def solve(start):
    goal = tuple(range(8))
    if start == goal:
        return 0
    
    visited = {start}
    queue = deque([(start, 0)])
    
    while queue:
        state, dist = queue.popleft()
        
        # Find position of 0
        pos = state.index(0)
        row = pos // 4
        col = pos % 4
        
        # Try all 4 directions
        moves = []
        if col > 0:  # left
            moves.append(pos - 1)
        if col < 3:  # right
            moves.append(pos + 1)
        if row > 0:  # up
            moves.append(pos - 4)
        if row < 1:  # down
            moves.append(pos + 4)
        
        for new_pos in moves:
            new_state = list(state)
            new_state[pos], new_state[new_pos] = new_state[new_pos], new_state[pos]
            new_state = tuple(new_state)
            
            if new_state == goal:
                return dist + 1
            
            if new_state not in visited:
                visited.add(new_state)
                queue.append((new_state, dist + 1))
    
    return -1

for line in sys.stdin:
    line = line.strip()
    if line:
        nums = tuple(map(int, line.split()))
        print(solve(nums))
",0
p00121,"7 パズル
7 パズルは 8 つの正方形のカードとこれらのカードがぴたりと収まる枠で構成されています。それぞれのカードには、互いに区別できるように 0, 1, 2, ..., 7 と番号がつけられています。枠には、縦に 2 個、横に 4 個のカードを並べることができます。
7 パズルを始めるときには、まず枠にすべてのカードを入れます。枠のなかで 0 のカードだけは、上下左右に隣接するカードと位置を交換することができます。たとえば、枠の状態が図(a) のときに、0 のカードの右に隣接した、7 のカードと位置を交換すれば、図(b) の状態になります。あるいは、図(a) の状態から 0 のカードの下に隣接した 2 のカードと位置を交換すれば図(c) の状態になります。図(a) の状態で 0 のカードと上下左右に隣接するカードは 7 と 2 のカードだけなので、これ以外の位置の入れ替えは許されません。
ゲームの目的は、カードをきれいに整列して図(d) の状態にすることです。最初の状態を入力とし、カードをきれいに整列するまでに、必要な最小手数を出力するプログラムを作成してください。ただし、入力されたカードの状態からは図(d) の状態に移ることは可能であるとします。
入力データは、1 行に 8 つの数字が空白区切りで与えられます。これらは、最初の状態のカードの並びを表します。例えば、図(a) の数字表現は
0 7 3 4 2 5 1 6
に、図(c) は
2 7 3 4 0 5 1 6
となります。
図(a)
0 7 3 4 2 5 1 6
の場合
図(b)
7 0 3 4 2 5 1 6
の場合
図(c)
2 7 3 4 0 5 1 6
の場合
図(d)
0 1 2 3 4 5 6 7
(最終状態)
Input
上記形式で複数のパズルが与えられます。入力の最後まで処理してください。
与えられるパズルの数は 1,000 以下です。
Output
各パズルについて、最終状態へ移行する最小手数を１行に出力してください。
Sample Input
0 1 2 3 4 5 6 7
1 0 2 3 4 5 6 7
7 6 5 4 3 2 1 0
Output for the Sample Input
0
1
28",Python,"from collections import deque

dic = {}
dic[(0,1,2,3,4,5,6,7)] = 0


swap_dic = {0:(1, 4), 1:(0, 2, 5), 2:(1, 3, 6), 3:(2, 7),
            4:(0, 5), 5:(1, 4, 6), 6:(2, 5, 7), 7:(3, 6)}

def swap(puz, i, j):
  new = [k for k in puz]
  new[i], new[j] = new[j], new[i]
  return tuple(new)

que = deque()
que.append((0, (0,1,2,3,4,5,6,7)))
while que:
  score, puz = que.popleft()
  score += 1
  z_ind = puz.index(0)

  for swap_ind in swap_dic[z_ind]:
    new_puz = swap(puz, z_ind, swap_ind)
    if not new_puz in dic:
      dic[new_puz] = score
      que.append((score, new_puz))

while True:
  try:
    print(dic[tuple(map(int, input().split()))])
  except EOFError:
    break
",1
p00122,"ぴょん吉の夏
会津大学には一面芝生で覆われた公園があり、日差しを遮る木や建物がありません。日差しの強い夏の日には、公園内に設置されたスプリンクラーが作動して芝生に散水しています。この公園にはカエルのぴょん吉が住み着いています。ぴょん吉は暑いのが苦手で、日差しが強い夏の日には常にスプリンクラーの水に当たっていないと干からびて死んでしまいます。公園に設置されたスプリンクラーは、節水のため一度に一つだけ散水することになっているので、ぴょん吉はスプリンクラーの作動に合わせて移動しなくてはなりません。
(a) 公園の地図
(b) ぴょん吉のジャンプ範囲
(c) スプリンクラーの散水範囲
公園は上図の(a)のとおりで、公園内の場所は縦横それぞれ 0~9 の座標で表し、黒い●がスプリンクラーで、その番号が作動する順番を表しています。これは一例で各スプリンクラーの場所と作動順序は日々変わります。
ぴょん吉は不器用なので、移動するにも決まった距離をジャンプすることしかできません。ぴょん吉のジャンプできる範囲は上図(b)のとおりで、それ以外の場所に移動することはできません。しかも、一回のジャンプで相当体力を消耗するため、しばらく水に当たって休まなくてはなりません。
スプリンクラーが散水できる範囲は上図(c)のとおりで、スプリンクラー自身の座標も含みます。各スプリンクラーは一定時間散水すると停止し、すぐに次のスプリンクラーが作動を開始します。ぴょん吉はこの時に一回だけジャンプするものとし、次に散水が停止するまでジャンプしないものとします。また、公園の四方は灼熱のアスファルトで囲まれているので公園の外にでてしまうような方向にはジャンプしないものとします。
猛暑となったこの夏。果たしてぴょん吉は生き延びることができたのでしょうか? ある日のぴょん吉の初期位置、スプリンクラーの位置と作動順序を読み込み、ぴょん吉が生き延びられる移動経路が存在している場合は”OK”、どう頑張っても死んでしまう場合は”NA”を出力するプログラムを作成してください。ただし、スプリンクラーの数は最大 10 個とし、ぴょん吉は一番目のスプリンクラーの作動と同時に初期位置からジャンプすることとします。
Input
複数のデータセットが与えられます。各データセットは以下の形式で与えられます。
px
py
n
x
1
y
1
x
2
y
2
...
x
n
y
n
1 行目にぴょん吉の初期位置の横座標
px
と縦座標
py
が与えられます。
2 行目にスプリンクラーの数
n
が与えられます。
3 行目に
i
番目に動作するスプリンクラーの横座標
x
i
と縦座標
y
i
が与えられます。
入力はゼロ２つの行で終わります。データセットの数は 20 を超えません。
Output
各データセットについて、生存の場合は OK、そうでない場合は NA を１行に出力してください。
Sample Input
6 1
10
6 4 3 3 1 2 0 5 4 6 1 8 5 9 7 7 8 6 8 3
6 1
10
6 4 3 3 1 2 0 5 4 6 1 8 5 9 7 7 8 6 9 0
0 0
Output for the Sample Input
OK
NA",C,"#include <stdio.h>
#include <stdlib.h>

int can_reach(int fx, int fy, int sx, int sy) {
    int dx = abs(fx - sx);
    int dy = abs(fy - sy);
    
    if ((dx == 2 && dy == 2) || (dx == 0 && dy == 3) || (dx == 3 && dy == 0)) {
        return 1;
    }
    return 0;
}

int in_spray(int x, int y, int sx, int sy) {
    int dx = abs(x - sx);
    int dy = abs(y - sy);
    
    if (dx <= 1 && dy <= 1) {
        return 1;
    }
    return 0;
}

int in_bounds(int x, int y) {
    return x >= 0 && x <= 9 && y >= 0 && y <= 9;
}

int solve(int px, int py, int n, int sx[], int sy[]) {
    int possible[10][10];
    int next_possible[10][10];
    
    for (int i = 0; i < 10; i++) {
        for (int j = 0; j < 10; j++) {
            possible[i][j] = 0;
        }
    }
    
    for (int x = 0; x < 10; x++) {
        for (int y = 0; y < 10; y++) {
            if (can_reach(px, py, x, y) && in_bounds(x, y) && in_spray(x, y, sx[0], sy[0])) {
                possible[x][y] = 1;
            }
        }
    }
    
    for (int i = 1; i < n; i++) {
        for (int x = 0; x < 10; x++) {
            for (int y = 0; y < 10; y++) {
                next_possible[x][y] = 0;
            }
        }
        
        for (int fx = 0; fx < 10; fx++) {
            for (int fy = 0; fy < 10; fy++) {
                if (possible[fx][fy]) {
                    for (int tx = 0; tx < 10; tx++) {
                        for (int ty = 0; ty < 10; ty++) {
                            if (can_reach(fx, fy, tx, ty) && in_bounds(tx, ty) && in_spray(tx, ty, sx[i], sy[i])) {
                                next_possible[tx][ty] = 1;
                            }
                        }
                    }
                }
            }
        }
        
        for (int x = 0; x < 10; x++) {
            for (int y = 0; y < 10; y++) {
                possible[x][y] = next_possible[x][y];
            }
        }
    }
    
    for (int x = 0; x < 10; x++) {
        for (int y = 0; y < 10; y++) {
            if (possible[x][y]) {
                return 1;
            }
        }
    }
    
    return 0;
}

int main() {
    int px, py;
    
    while (scanf(""%d %d"", &px, &py) == 2) {
        if (px == 0 && py == 0) {
            break;
        }
        
        int n;
        scanf(""%d"", &n);
        
        int sx[10], sy[10];
        for (int i = 0; i < n; i++) {
            scanf(""%d %d"", &sx[i], &sy[i]);
        }
        
        if (solve(px, py, n, sx, sy)) {
            printf(""OK\n"");
        } else {
            printf(""NA\n"");
        }
    }
    
    return 0;
}
",0
p00122,"ぴょん吉の夏
会津大学には一面芝生で覆われた公園があり、日差しを遮る木や建物がありません。日差しの強い夏の日には、公園内に設置されたスプリンクラーが作動して芝生に散水しています。この公園にはカエルのぴょん吉が住み着いています。ぴょん吉は暑いのが苦手で、日差しが強い夏の日には常にスプリンクラーの水に当たっていないと干からびて死んでしまいます。公園に設置されたスプリンクラーは、節水のため一度に一つだけ散水することになっているので、ぴょん吉はスプリンクラーの作動に合わせて移動しなくてはなりません。
(a) 公園の地図
(b) ぴょん吉のジャンプ範囲
(c) スプリンクラーの散水範囲
公園は上図の(a)のとおりで、公園内の場所は縦横それぞれ 0~9 の座標で表し、黒い●がスプリンクラーで、その番号が作動する順番を表しています。これは一例で各スプリンクラーの場所と作動順序は日々変わります。
ぴょん吉は不器用なので、移動するにも決まった距離をジャンプすることしかできません。ぴょん吉のジャンプできる範囲は上図(b)のとおりで、それ以外の場所に移動することはできません。しかも、一回のジャンプで相当体力を消耗するため、しばらく水に当たって休まなくてはなりません。
スプリンクラーが散水できる範囲は上図(c)のとおりで、スプリンクラー自身の座標も含みます。各スプリンクラーは一定時間散水すると停止し、すぐに次のスプリンクラーが作動を開始します。ぴょん吉はこの時に一回だけジャンプするものとし、次に散水が停止するまでジャンプしないものとします。また、公園の四方は灼熱のアスファルトで囲まれているので公園の外にでてしまうような方向にはジャンプしないものとします。
猛暑となったこの夏。果たしてぴょん吉は生き延びることができたのでしょうか? ある日のぴょん吉の初期位置、スプリンクラーの位置と作動順序を読み込み、ぴょん吉が生き延びられる移動経路が存在している場合は”OK”、どう頑張っても死んでしまう場合は”NA”を出力するプログラムを作成してください。ただし、スプリンクラーの数は最大 10 個とし、ぴょん吉は一番目のスプリンクラーの作動と同時に初期位置からジャンプすることとします。
Input
複数のデータセットが与えられます。各データセットは以下の形式で与えられます。
px
py
n
x
1
y
1
x
2
y
2
...
x
n
y
n
1 行目にぴょん吉の初期位置の横座標
px
と縦座標
py
が与えられます。
2 行目にスプリンクラーの数
n
が与えられます。
3 行目に
i
番目に動作するスプリンクラーの横座標
x
i
と縦座標
y
i
が与えられます。
入力はゼロ２つの行で終わります。データセットの数は 20 を超えません。
Output
各データセットについて、生存の場合は OK、そうでない場合は NA を１行に出力してください。
Sample Input
6 1
10
6 4 3 3 1 2 0 5 4 6 1 8 5 9 7 7 8 6 8 3
6 1
10
6 4 3 3 1 2 0 5 4 6 1 8 5 9 7 7 8 6 9 0
0 0
Output for the Sample Input
OK
NA",C,"#include <stdio.h>          // printf(), scanf()
#include <stdbool.h>

#define MAX_N 10
#define MAX_M 10
#define MAX_G 9

int sx, sy;
int n;
int scx[MAX_N], scy[MAX_N];

bool
b_survival()
{
	bool field[MAX_M][MAX_M];
	int px[MAX_G], py[MAX_G];
	static const int dx2[12] = {-1, 0, 1, 2, 2, 2,-1, 0, 1,-2,-2,-2};
	static const int dy2[12] = {-2,-2,-2,-1, 0, 1, 2, 2, 2,-1, 0, 1};

	int ix = 0;
	px[ix] = sx, py[ix] = sy;
	ix++;

	for (int u = 0; u < n; ++u)
	{
		for (int dy = -1; dy <= 1; ++dy)
		{
			for (int dx = -1; dx <= 1; ++dx)
			{
				int nx = scx[u] + dx, ny = scy[u] + dy;
				if (0 <= nx && nx < MAX_M && 0 <= ny && ny < MAX_M)
					field[ny][nx] = false;
			}
		}

		for (int i = 0; i < ix; ++i)
		{
			for (int j = 0; j < 12; ++j)
			{
				int nx = px[i] + dx2[j], ny = py[i] + dy2[j];
				if (0 <= nx && nx < MAX_M && 0 <= ny && ny < MAX_M)
					field[ny][nx] = true;
			}
		}

		ix = 0;
		for (int dy = -1; dy <= 1; ++dy)
		{
			for (int dx = -1; dx <= 1; ++dx)
			{
				int nx = scx[u] + dx, ny = scy[u] + dy;
				if (0 <= nx && nx < MAX_M && 0 <= ny && ny < MAX_M && field[ny][nx])
				{
					px[ix] = nx;
					py[ix] = ny;
					ix++;
				}
			}
		}

		if (ix == 0)
			return false;
	}

	return true;
}

int
main(int argc, char **argv)
{
	int lineno = 0;
	while (true)
	{
		lineno++;
		scanf(""%d%d"", &sx, &sy);
		if (sx == 0 && sy == 0)
			break;

		lineno++;
		scanf(""%d"", &n);

		lineno++;
		for (int i = 0; i < n; ++i)
			scanf(""%d%d"", &scx[i], &scy[i]);

		printf(""%s\n"", b_survival() ? ""OK"" : ""NA"");
	}

	return 0;
}",1
p00122,"ぴょん吉の夏
会津大学には一面芝生で覆われた公園があり、日差しを遮る木や建物がありません。日差しの強い夏の日には、公園内に設置されたスプリンクラーが作動して芝生に散水しています。この公園にはカエルのぴょん吉が住み着いています。ぴょん吉は暑いのが苦手で、日差しが強い夏の日には常にスプリンクラーの水に当たっていないと干からびて死んでしまいます。公園に設置されたスプリンクラーは、節水のため一度に一つだけ散水することになっているので、ぴょん吉はスプリンクラーの作動に合わせて移動しなくてはなりません。
(a) 公園の地図
(b) ぴょん吉のジャンプ範囲
(c) スプリンクラーの散水範囲
公園は上図の(a)のとおりで、公園内の場所は縦横それぞれ 0~9 の座標で表し、黒い●がスプリンクラーで、その番号が作動する順番を表しています。これは一例で各スプリンクラーの場所と作動順序は日々変わります。
ぴょん吉は不器用なので、移動するにも決まった距離をジャンプすることしかできません。ぴょん吉のジャンプできる範囲は上図(b)のとおりで、それ以外の場所に移動することはできません。しかも、一回のジャンプで相当体力を消耗するため、しばらく水に当たって休まなくてはなりません。
スプリンクラーが散水できる範囲は上図(c)のとおりで、スプリンクラー自身の座標も含みます。各スプリンクラーは一定時間散水すると停止し、すぐに次のスプリンクラーが作動を開始します。ぴょん吉はこの時に一回だけジャンプするものとし、次に散水が停止するまでジャンプしないものとします。また、公園の四方は灼熱のアスファルトで囲まれているので公園の外にでてしまうような方向にはジャンプしないものとします。
猛暑となったこの夏。果たしてぴょん吉は生き延びることができたのでしょうか? ある日のぴょん吉の初期位置、スプリンクラーの位置と作動順序を読み込み、ぴょん吉が生き延びられる移動経路が存在している場合は”OK”、どう頑張っても死んでしまう場合は”NA”を出力するプログラムを作成してください。ただし、スプリンクラーの数は最大 10 個とし、ぴょん吉は一番目のスプリンクラーの作動と同時に初期位置からジャンプすることとします。
Input
複数のデータセットが与えられます。各データセットは以下の形式で与えられます。
px
py
n
x
1
y
1
x
2
y
2
...
x
n
y
n
1 行目にぴょん吉の初期位置の横座標
px
と縦座標
py
が与えられます。
2 行目にスプリンクラーの数
n
が与えられます。
3 行目に
i
番目に動作するスプリンクラーの横座標
x
i
と縦座標
y
i
が与えられます。
入力はゼロ２つの行で終わります。データセットの数は 20 を超えません。
Output
各データセットについて、生存の場合は OK、そうでない場合は NA を１行に出力してください。
Sample Input
6 1
10
6 4 3 3 1 2 0 5 4 6 1 8 5 9 7 7 8 6 8 3
6 1
10
6 4 3 3 1 2 0 5 4 6 1 8 5 9 7 7 8 6 9 0
0 0
Output for the Sample Input
OK
NA",Java,"import java.util.*;

public class Main {
    static int[][] jumpOffsets = {
        {-2, -1}, {-2, 1}, {-1, -2}, {-1, 2},
        {1, -2}, {1, 2}, {2, -1}, {2, 1}
    };
    
    static int[][] waterOffsets = {
        {-1, -1}, {-1, 0}, {-1, 1},
        {0, -1}, {0, 0}, {0, 1},
        {1, -1}, {1, 0}, {1, 1}
    };
    
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        
        while (true) {
            int px = sc.nextInt();
            int py = sc.nextInt();
            
            if (px == 0 && py == 0) break;
            
            int n = sc.nextInt();
            int[][] sprinklers = new int[n][2];
            
            for (int i = 0; i < n; i++) {
                sprinklers[i][0] = sc.nextInt();
                sprinklers[i][1] = sc.nextInt();
            }
            
            if (canSurvive(px, py, sprinklers)) {
                System.out.println(""OK"");
            } else {
                System.out.println(""NA"");
            }
        }
        
        sc.close();
    }
    
    static boolean canSurvive(int px, int py, int[][] sprinklers) {
        Set<String> currentPositions = new HashSet<>();
        currentPositions.add(px + "","" + py);
        
        for (int i = 0; i < sprinklers.length; i++) {
            int sx = sprinklers[i][0];
            int sy = sprinklers[i][1];
            
            Set<String> nextPositions = new HashSet<>();
            
            for (String posStr : currentPositions) {
                String[] parts = posStr.split("","");
                int x = Integer.parseInt(parts[0]);
                int y = Integer.parseInt(parts[1]);
                
                for (int[] offset : jumpOffsets) {
                    int nx = x + offset[0];
                    int ny = y + offset[1];
                    
                    if (nx >= 0 && nx <= 9 && ny >= 0 && ny <= 9) {
                        if (isInWaterRange(nx, ny, sx, sy)) {
                            nextPositions.add(nx + "","" + ny);
                        }
                    }
                }
            }
            
            if (nextPositions.isEmpty()) {
                return false;
            }
            
            currentPositions = nextPositions;
        }
        
        return true;
    }
    
    static boolean isInWaterRange(int x, int y, int sx, int sy) {
        for (int[] offset : waterOffsets) {
            if (sx + offset[0] == x && sy + offset[1] == y) {
                return true;
            }
        }
        return false;
    }
}
",0
p00122,"ぴょん吉の夏
会津大学には一面芝生で覆われた公園があり、日差しを遮る木や建物がありません。日差しの強い夏の日には、公園内に設置されたスプリンクラーが作動して芝生に散水しています。この公園にはカエルのぴょん吉が住み着いています。ぴょん吉は暑いのが苦手で、日差しが強い夏の日には常にスプリンクラーの水に当たっていないと干からびて死んでしまいます。公園に設置されたスプリンクラーは、節水のため一度に一つだけ散水することになっているので、ぴょん吉はスプリンクラーの作動に合わせて移動しなくてはなりません。
(a) 公園の地図
(b) ぴょん吉のジャンプ範囲
(c) スプリンクラーの散水範囲
公園は上図の(a)のとおりで、公園内の場所は縦横それぞれ 0~9 の座標で表し、黒い●がスプリンクラーで、その番号が作動する順番を表しています。これは一例で各スプリンクラーの場所と作動順序は日々変わります。
ぴょん吉は不器用なので、移動するにも決まった距離をジャンプすることしかできません。ぴょん吉のジャンプできる範囲は上図(b)のとおりで、それ以外の場所に移動することはできません。しかも、一回のジャンプで相当体力を消耗するため、しばらく水に当たって休まなくてはなりません。
スプリンクラーが散水できる範囲は上図(c)のとおりで、スプリンクラー自身の座標も含みます。各スプリンクラーは一定時間散水すると停止し、すぐに次のスプリンクラーが作動を開始します。ぴょん吉はこの時に一回だけジャンプするものとし、次に散水が停止するまでジャンプしないものとします。また、公園の四方は灼熱のアスファルトで囲まれているので公園の外にでてしまうような方向にはジャンプしないものとします。
猛暑となったこの夏。果たしてぴょん吉は生き延びることができたのでしょうか? ある日のぴょん吉の初期位置、スプリンクラーの位置と作動順序を読み込み、ぴょん吉が生き延びられる移動経路が存在している場合は”OK”、どう頑張っても死んでしまう場合は”NA”を出力するプログラムを作成してください。ただし、スプリンクラーの数は最大 10 個とし、ぴょん吉は一番目のスプリンクラーの作動と同時に初期位置からジャンプすることとします。
Input
複数のデータセットが与えられます。各データセットは以下の形式で与えられます。
px
py
n
x
1
y
1
x
2
y
2
...
x
n
y
n
1 行目にぴょん吉の初期位置の横座標
px
と縦座標
py
が与えられます。
2 行目にスプリンクラーの数
n
が与えられます。
3 行目に
i
番目に動作するスプリンクラーの横座標
x
i
と縦座標
y
i
が与えられます。
入力はゼロ２つの行で終わります。データセットの数は 20 を超えません。
Output
各データセットについて、生存の場合は OK、そうでない場合は NA を１行に出力してください。
Sample Input
6 1
10
6 4 3 3 1 2 0 5 4 6 1 8 5 9 7 7 8 6 8 3
6 1
10
6 4 3 3 1 2 0 5 4 6 1 8 5 9 7 7 8 6 9 0
0 0
Output for the Sample Input
OK
NA",Java,"
import java.util.ArrayDeque;
import java.util.Deque;
import java.util.Scanner;

public class Main {
	static int[] fy = { -2, -2, -2, -1, -1, 0, 0, 1, 1, 2, 2, 2 };
	static int[] fx = { -1, 0, 1, -2, 2, -2, 2, -2, 2, -1, 0, 1 };

	public static void main(String[] args) {
		Scanner scanner = new Scanner(System.in);
		while (true) {
			int kx = scanner.nextInt();
			int ky = scanner.nextInt();
			if (ky == 0 && kx == 0)
				break;
			int n = scanner.nextInt();
			int[][] num = new int[n][2];
			for (int i = 0; i < n; i++) {
				num[i][0] = scanner.nextInt();
				num[i][1] = scanner.nextInt();
			}
			Deque<int[]> deque = new ArrayDeque<int[]>();
			deque.offer(new int[] { ky, kx });
			boolean flag = true;
			loop: for (int i = 0; i < n; i++) {
				int size = deque.size();
				Deque<int[]> dequetmp = new ArrayDeque<int[]>();
				while (size-- > 0) {
					int[] m = deque.pop();
					slove(m, num[i], dequetmp);
				}
				if (dequetmp.isEmpty()) {
					flag = false;
					break loop;
				}
				deque = dequetmp;
			}
			System.out.println(flag ? ""OK"" : ""NA"");
		}

	}

	private static void slove(int[] m, int[] num, Deque<int[]> dequetmp) {
		boolean[][] map = new boolean[14][14];
		for (int i = 1; i < 4; i++) {
			for (int j = 1; j < 4; j++) {
				int y = num[1] + i;
				int x = num[0] + j;
				if (2 <= y && y <= 12 && 2 <= x && x <= 12)
					map[y][x] = true;
			}
		}
		for (int i = 0; i < fy.length; i++) {
			int py = m[0] + fy[i] + 2;
			int px = m[1] + fx[i] + 2;
			if (map[py][px]) {
				py -= 2;
				px -= 2;
				boolean flag = true;
				for (int[] t : dequetmp) {
					if (t[0] == py && t[1] == px) {
						flag = false;
						break;
					}
				}
				if (flag) {
					dequetmp.push(new int[] { py, px });
				}
			}
		}
	}
}",1
p00122,"ぴょん吉の夏
会津大学には一面芝生で覆われた公園があり、日差しを遮る木や建物がありません。日差しの強い夏の日には、公園内に設置されたスプリンクラーが作動して芝生に散水しています。この公園にはカエルのぴょん吉が住み着いています。ぴょん吉は暑いのが苦手で、日差しが強い夏の日には常にスプリンクラーの水に当たっていないと干からびて死んでしまいます。公園に設置されたスプリンクラーは、節水のため一度に一つだけ散水することになっているので、ぴょん吉はスプリンクラーの作動に合わせて移動しなくてはなりません。
(a) 公園の地図
(b) ぴょん吉のジャンプ範囲
(c) スプリンクラーの散水範囲
公園は上図の(a)のとおりで、公園内の場所は縦横それぞれ 0~9 の座標で表し、黒い●がスプリンクラーで、その番号が作動する順番を表しています。これは一例で各スプリンクラーの場所と作動順序は日々変わります。
ぴょん吉は不器用なので、移動するにも決まった距離をジャンプすることしかできません。ぴょん吉のジャンプできる範囲は上図(b)のとおりで、それ以外の場所に移動することはできません。しかも、一回のジャンプで相当体力を消耗するため、しばらく水に当たって休まなくてはなりません。
スプリンクラーが散水できる範囲は上図(c)のとおりで、スプリンクラー自身の座標も含みます。各スプリンクラーは一定時間散水すると停止し、すぐに次のスプリンクラーが作動を開始します。ぴょん吉はこの時に一回だけジャンプするものとし、次に散水が停止するまでジャンプしないものとします。また、公園の四方は灼熱のアスファルトで囲まれているので公園の外にでてしまうような方向にはジャンプしないものとします。
猛暑となったこの夏。果たしてぴょん吉は生き延びることができたのでしょうか? ある日のぴょん吉の初期位置、スプリンクラーの位置と作動順序を読み込み、ぴょん吉が生き延びられる移動経路が存在している場合は”OK”、どう頑張っても死んでしまう場合は”NA”を出力するプログラムを作成してください。ただし、スプリンクラーの数は最大 10 個とし、ぴょん吉は一番目のスプリンクラーの作動と同時に初期位置からジャンプすることとします。
Input
複数のデータセットが与えられます。各データセットは以下の形式で与えられます。
px
py
n
x
1
y
1
x
2
y
2
...
x
n
y
n
1 行目にぴょん吉の初期位置の横座標
px
と縦座標
py
が与えられます。
2 行目にスプリンクラーの数
n
が与えられます。
3 行目に
i
番目に動作するスプリンクラーの横座標
x
i
と縦座標
y
i
が与えられます。
入力はゼロ２つの行で終わります。データセットの数は 20 を超えません。
Output
各データセットについて、生存の場合は OK、そうでない場合は NA を１行に出力してください。
Sample Input
6 1
10
6 4 3 3 1 2 0 5 4 6 1 8 5 9 7 7 8 6 8 3
6 1
10
6 4 3 3 1 2 0 5 4 6 1 8 5 9 7 7 8 6 9 0
0 0
Output for the Sample Input
OK
NA",Python,"import sys
from collections import deque

def get_jump_positions(x, y):
    """"""Returns all valid positions that can be reached from (x, y) with one jump""""""
    jumps = [
        (-2, -1), (-2, 1), (2, -1), (2, 1),
        (-1, -2), (-1, 2), (1, -2), (1, 2)
    ]
    positions = []
    for dx, dy in jumps:
        nx, ny = x + dx, y + dy
        if 0 <= nx <= 9 and 0 <= ny <= 9:
            positions.append((nx, ny))
    return positions

def get_water_positions(x, y):
    """"""Returns all positions covered by water from sprinkler at (x, y)""""""
    positions = set()
    for dx in range(-2, 3):
        for dy in range(-2, 3):
            if abs(dx) + abs(dy) <= 2:
                nx, ny = x + dx, y + dy
                if 0 <= nx <= 9 and 0 <= ny <= 9:
                    positions.add((nx, ny))
    return positions

def solve(px, py, sprinklers):
    n = len(sprinklers)
    
    # BFS to find if there's a path
    # State: (current_position, sprinkler_index)
    # We start by jumping from initial position when first sprinkler activates
    
    if n == 0:
        return ""NA""
    
    # Get all positions reachable from initial position
    initial_jumps = get_jump_positions(px, py)
    
    # Check which of these positions are covered by first sprinkler
    first_sprinkler_water = get_water_positions(sprinklers[0][0], sprinklers[0][1])
    
    # Queue: (position, sprinkler_index)
    queue = deque()
    visited = set()
    
    for pos in initial_jumps:
        if pos in first_sprinkler_water:
            queue.append((pos, 0))
            visited.add((pos, 0))
    
    # If we reach the last sprinkler, we survived
    while queue:
        (x, y), spr_idx = queue.popleft()
        
        # If we're at the last sprinkler, we survived
        if spr_idx == n - 1:
            return ""OK""
        
        # Try to jump to next sprinkler's water area
        next_spr_idx = spr_idx + 1
        next_water = get_water_positions(sprinklers[next_spr_idx][0], sprinklers[next_spr_idx][1])
        
        # Get all positions we can jump to
        jump_positions = get_jump_positions(x, y)
        
        for next_pos in jump_positions:
            if next_pos in next_water:
                state = (next_pos, next_spr_idx)
                if state not in visited:
                    visited.add(state)
                    queue.append(state)
    
    return ""NA""

# Read input
while True:
    line = input().split()
    px, py = int(line[0]), int(line[1])
    
    if px == 0 and py == 0:
        break
    
    n = int(input())
    coords = list(map(int, input().split()))
    
    sprinklers = []
    for i in range(n):
        x = coords[2 * i]
        y = coords[2 * i + 1]
        sprinklers.append((x, y))
    
    result = solve(px, py, sprinklers)
    print(result)
",0
p00122,"ぴょん吉の夏
会津大学には一面芝生で覆われた公園があり、日差しを遮る木や建物がありません。日差しの強い夏の日には、公園内に設置されたスプリンクラーが作動して芝生に散水しています。この公園にはカエルのぴょん吉が住み着いています。ぴょん吉は暑いのが苦手で、日差しが強い夏の日には常にスプリンクラーの水に当たっていないと干からびて死んでしまいます。公園に設置されたスプリンクラーは、節水のため一度に一つだけ散水することになっているので、ぴょん吉はスプリンクラーの作動に合わせて移動しなくてはなりません。
(a) 公園の地図
(b) ぴょん吉のジャンプ範囲
(c) スプリンクラーの散水範囲
公園は上図の(a)のとおりで、公園内の場所は縦横それぞれ 0~9 の座標で表し、黒い●がスプリンクラーで、その番号が作動する順番を表しています。これは一例で各スプリンクラーの場所と作動順序は日々変わります。
ぴょん吉は不器用なので、移動するにも決まった距離をジャンプすることしかできません。ぴょん吉のジャンプできる範囲は上図(b)のとおりで、それ以外の場所に移動することはできません。しかも、一回のジャンプで相当体力を消耗するため、しばらく水に当たって休まなくてはなりません。
スプリンクラーが散水できる範囲は上図(c)のとおりで、スプリンクラー自身の座標も含みます。各スプリンクラーは一定時間散水すると停止し、すぐに次のスプリンクラーが作動を開始します。ぴょん吉はこの時に一回だけジャンプするものとし、次に散水が停止するまでジャンプしないものとします。また、公園の四方は灼熱のアスファルトで囲まれているので公園の外にでてしまうような方向にはジャンプしないものとします。
猛暑となったこの夏。果たしてぴょん吉は生き延びることができたのでしょうか? ある日のぴょん吉の初期位置、スプリンクラーの位置と作動順序を読み込み、ぴょん吉が生き延びられる移動経路が存在している場合は”OK”、どう頑張っても死んでしまう場合は”NA”を出力するプログラムを作成してください。ただし、スプリンクラーの数は最大 10 個とし、ぴょん吉は一番目のスプリンクラーの作動と同時に初期位置からジャンプすることとします。
Input
複数のデータセットが与えられます。各データセットは以下の形式で与えられます。
px
py
n
x
1
y
1
x
2
y
2
...
x
n
y
n
1 行目にぴょん吉の初期位置の横座標
px
と縦座標
py
が与えられます。
2 行目にスプリンクラーの数
n
が与えられます。
3 行目に
i
番目に動作するスプリンクラーの横座標
x
i
と縦座標
y
i
が与えられます。
入力はゼロ２つの行で終わります。データセットの数は 20 を超えません。
Output
各データセットについて、生存の場合は OK、そうでない場合は NA を１行に出力してください。
Sample Input
6 1
10
6 4 3 3 1 2 0 5 4 6 1 8 5 9 7 7 8 6 8 3
6 1
10
6 4 3 3 1 2 0 5 4 6 1 8 5 9 7 7 8 6 9 0
0 0
Output for the Sample Input
OK
NA",Python,"R1=range(-2,3)
R2=range(-1,2)
A1=[(x,y) for x in R1 for y in R1 if 3<x**2+y**2<6]
A2=[(x,y) for x in R2 for y in R2]
def fi(): return map(int,raw_input().split("" ""))
def f(p,i):
  x,y=p
  A=[A1,A2][i>0]
  return set([(x+dx,y+dy) for dx,dy in A if 0<=x+dx<10 and 0<=y+dy<10])

while 1:
  xf,yf=fi()
  if yf==xf==0: break
  raw_input()
  tmp=fi()
  PA=zip(tmp[0::2],tmp[1::2])
  FA=set([(xf,yf)])
  for ps in PA:
    SA=f(ps,1)
    tmp=set([])
    for pf in FA: tmp=tmp|(SA&f(pf,0))
    FA=tmp
  print [""NA"",""OK""][len(FA)>0]",1
p00123,"スピードスケートバッジテスト
スピードスケートバッジテストでは、2 種類の距離で規定されたタイムを上回った場合に級が認定されます。例えば A 級になるには 500 M で 40.0 秒未満、かつ 1000 M で 1 分 23 秒未満であることが求められます。
スピードスケート大会 (500 M と 1000 M) で記録したタイムを入力とし、スピードスケートバッジテストで何級に相当するかを出力するプログラムを作成して下さい。500 M と1000 M のバッジテスト規定タイムは下表のとおりです。 E 級に満たなかった場合には、NA と出力してください。
500 M
1000 M
AAA 級
35 秒 50
1 分 11 秒 00
AA 級
37 秒 50
1 分 17 秒 00
A 級
40 秒 00
1 分 23 秒 00
B 級
43 秒 00
1 分 29 秒 00
C 級
50 秒 00
1 分 45 秒 00
D 級
55 秒 00
1 分 56 秒 00
E 級
1分10 秒 00
2 分 28 秒 00
Input
複数のデータセットが与えられます。各データセットとして、500 M タイムと 1000 M タイムをそれぞれ表す実数
t
1
,
t
2
(8.0 ≤
t
1
,
t
2
≤ 360.0) が空白区切りで与えられます。
t
1
,
t
2
は秒単位で小数点以下最大 2 桁までの数字を含む実数で与えられます。
データセットの数は 100 を超えません。
Output
各データセットごとに、判定結果 AAA ~ E または NA を１行に出力してください。
Sample Input
40.0 70.0
72.5 140.51
Output for the Sample Input
B
NA",C,"#include <stdio.h>

int main() {
    double t1, t2;
    
    while (scanf(""%lf %lf"", &t1, &t2) == 2) {
        if (t1 < 35.50 && t2 < 71.00) {
            printf(""AAA\n"");
        } else if (t1 < 37.50 && t2 < 77.00) {
            printf(""AA\n"");
        } else if (t1 < 40.00 && t2 < 83.00) {
            printf(""A\n"");
        } else if (t1 < 43.00 && t2 < 89.00) {
            printf(""B\n"");
        } else if (t1 < 50.00 && t2 < 105.00) {
            printf(""C\n"");
        } else if (t1 < 55.00 && t2 < 116.00) {
            printf(""D\n"");
        } else if (t1 < 70.00 && t2 < 148.00) {
            printf(""E\n"");
        } else {
            printf(""NA\n"");
        }
    }
    
    return 0;
}
",0
p00123,"スピードスケートバッジテスト
スピードスケートバッジテストでは、2 種類の距離で規定されたタイムを上回った場合に級が認定されます。例えば A 級になるには 500 M で 40.0 秒未満、かつ 1000 M で 1 分 23 秒未満であることが求められます。
スピードスケート大会 (500 M と 1000 M) で記録したタイムを入力とし、スピードスケートバッジテストで何級に相当するかを出力するプログラムを作成して下さい。500 M と1000 M のバッジテスト規定タイムは下表のとおりです。 E 級に満たなかった場合には、NA と出力してください。
500 M
1000 M
AAA 級
35 秒 50
1 分 11 秒 00
AA 級
37 秒 50
1 分 17 秒 00
A 級
40 秒 00
1 分 23 秒 00
B 級
43 秒 00
1 分 29 秒 00
C 級
50 秒 00
1 分 45 秒 00
D 級
55 秒 00
1 分 56 秒 00
E 級
1分10 秒 00
2 分 28 秒 00
Input
複数のデータセットが与えられます。各データセットとして、500 M タイムと 1000 M タイムをそれぞれ表す実数
t
1
,
t
2
(8.0 ≤
t
1
,
t
2
≤ 360.0) が空白区切りで与えられます。
t
1
,
t
2
は秒単位で小数点以下最大 2 桁までの数字を含む実数で与えられます。
データセットの数は 100 を超えません。
Output
各データセットごとに、判定結果 AAA ~ E または NA を１行に出力してください。
Sample Input
40.0 70.0
72.5 140.51
Output for the Sample Input
B
NA",C,"#include<stdio.h>

int main(){
  float x,y;
  
  while(scanf(""%f%f"",&x,&y)!=EOF){   
    if(x<35.5&&y<71)
      puts(""AAA"");
    else if(x<37.5&&y<77)
      puts(""AA"");
    else if(x<40&&y<83)
      puts(""A"");
    else if(x<43&&y<89)
      puts(""B"");
    else if(x<50&&y<105)
      puts(""C"");
    else if(x<55&&y<116)
      puts(""D"");
    else if(x<70&&y<148)
      puts(""E"");
    else
      puts(""NA"");
  }
  return 0;
}",1
p00123,"スピードスケートバッジテスト
スピードスケートバッジテストでは、2 種類の距離で規定されたタイムを上回った場合に級が認定されます。例えば A 級になるには 500 M で 40.0 秒未満、かつ 1000 M で 1 分 23 秒未満であることが求められます。
スピードスケート大会 (500 M と 1000 M) で記録したタイムを入力とし、スピードスケートバッジテストで何級に相当するかを出力するプログラムを作成して下さい。500 M と1000 M のバッジテスト規定タイムは下表のとおりです。 E 級に満たなかった場合には、NA と出力してください。
500 M
1000 M
AAA 級
35 秒 50
1 分 11 秒 00
AA 級
37 秒 50
1 分 17 秒 00
A 級
40 秒 00
1 分 23 秒 00
B 級
43 秒 00
1 分 29 秒 00
C 級
50 秒 00
1 分 45 秒 00
D 級
55 秒 00
1 分 56 秒 00
E 級
1分10 秒 00
2 分 28 秒 00
Input
複数のデータセットが与えられます。各データセットとして、500 M タイムと 1000 M タイムをそれぞれ表す実数
t
1
,
t
2
(8.0 ≤
t
1
,
t
2
≤ 360.0) が空白区切りで与えられます。
t
1
,
t
2
は秒単位で小数点以下最大 2 桁までの数字を含む実数で与えられます。
データセットの数は 100 を超えません。
Output
各データセットごとに、判定結果 AAA ~ E または NA を１行に出力してください。
Sample Input
40.0 70.0
72.5 140.51
Output for the Sample Input
B
NA",Java,"import java.util.Scanner;

public class Main {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        
        while (sc.hasNext()) {
            double t1 = sc.nextDouble();
            double t2 = sc.nextDouble();
            
            String result = ""NA"";
            
            if (t1 < 35.50 && t2 < 71.00) {
                result = ""AAA"";
            } else if (t1 < 37.50 && t2 < 77.00) {
                result = ""AA"";
            } else if (t1 < 40.00 && t2 < 83.00) {
                result = ""A"";
            } else if (t1 < 43.00 && t2 < 89.00) {
                result = ""B"";
            } else if (t1 < 50.00 && t2 < 105.00) {
                result = ""C"";
            } else if (t1 < 55.00 && t2 < 116.00) {
                result = ""D"";
            } else if (t1 < 70.00 && t2 < 148.00) {
                result = ""E"";
            }
            
            System.out.println(result);
        }
        
        sc.close();
    }
}
",0
p00123,"スピードスケートバッジテスト
スピードスケートバッジテストでは、2 種類の距離で規定されたタイムを上回った場合に級が認定されます。例えば A 級になるには 500 M で 40.0 秒未満、かつ 1000 M で 1 分 23 秒未満であることが求められます。
スピードスケート大会 (500 M と 1000 M) で記録したタイムを入力とし、スピードスケートバッジテストで何級に相当するかを出力するプログラムを作成して下さい。500 M と1000 M のバッジテスト規定タイムは下表のとおりです。 E 級に満たなかった場合には、NA と出力してください。
500 M
1000 M
AAA 級
35 秒 50
1 分 11 秒 00
AA 級
37 秒 50
1 分 17 秒 00
A 級
40 秒 00
1 分 23 秒 00
B 級
43 秒 00
1 分 29 秒 00
C 級
50 秒 00
1 分 45 秒 00
D 級
55 秒 00
1 分 56 秒 00
E 級
1分10 秒 00
2 分 28 秒 00
Input
複数のデータセットが与えられます。各データセットとして、500 M タイムと 1000 M タイムをそれぞれ表す実数
t
1
,
t
2
(8.0 ≤
t
1
,
t
2
≤ 360.0) が空白区切りで与えられます。
t
1
,
t
2
は秒単位で小数点以下最大 2 桁までの数字を含む実数で与えられます。
データセットの数は 100 を超えません。
Output
各データセットごとに、判定結果 AAA ~ E または NA を１行に出力してください。
Sample Input
40.0 70.0
72.5 140.51
Output for the Sample Input
B
NA",Java,"import java.util.Scanner;

public class Main {

	public static void main(String[] args) {
		Scanner sc=new Scanner(System.in);
		double eps=0.000000000000000001;
		while(sc.hasNext()){
			double n=sc.nextDouble();
			double m=sc.nextDouble();
			if(n<35.5-eps && m<71.0-eps){
				System.out.println(""AAA"");
			}
			else if(n<37.5-eps && m<77.0-eps){
				System.out.println(""AA"");
			}
			else if(n<40.0-eps && m<83.0-eps){
				System.out.println(""A"");
			}
			else if(n<43.0-eps && m<89.0-eps){
				System.out.println(""B"");
			}
			else if(n<50.0-eps && m<105.0-eps){
				System.out.println(""C"");
			}
			else if(n<55.0-eps && m<116.0-eps){
				System.out.println(""D"");
			}
			else if(n<70.0-eps && m<148.0-eps){
				System.out.println(""E"");
			}
			else{
				System.out.println(""NA"");
			}
		}
	}

}",1
p00123,"スピードスケートバッジテスト
スピードスケートバッジテストでは、2 種類の距離で規定されたタイムを上回った場合に級が認定されます。例えば A 級になるには 500 M で 40.0 秒未満、かつ 1000 M で 1 分 23 秒未満であることが求められます。
スピードスケート大会 (500 M と 1000 M) で記録したタイムを入力とし、スピードスケートバッジテストで何級に相当するかを出力するプログラムを作成して下さい。500 M と1000 M のバッジテスト規定タイムは下表のとおりです。 E 級に満たなかった場合には、NA と出力してください。
500 M
1000 M
AAA 級
35 秒 50
1 分 11 秒 00
AA 級
37 秒 50
1 分 17 秒 00
A 級
40 秒 00
1 分 23 秒 00
B 級
43 秒 00
1 分 29 秒 00
C 級
50 秒 00
1 分 45 秒 00
D 級
55 秒 00
1 分 56 秒 00
E 級
1分10 秒 00
2 分 28 秒 00
Input
複数のデータセットが与えられます。各データセットとして、500 M タイムと 1000 M タイムをそれぞれ表す実数
t
1
,
t
2
(8.0 ≤
t
1
,
t
2
≤ 360.0) が空白区切りで与えられます。
t
1
,
t
2
は秒単位で小数点以下最大 2 桁までの数字を含む実数で与えられます。
データセットの数は 100 を超えません。
Output
各データセットごとに、判定結果 AAA ~ E または NA を１行に出力してください。
Sample Input
40.0 70.0
72.5 140.51
Output for the Sample Input
B
NA",Python,"import sys

grades = [
    (""AAA"", 35.50, 71.00),
    (""AA"", 37.50, 77.00),
    (""A"", 40.00, 83.00),
    (""B"", 43.00, 89.00),
    (""C"", 50.00, 105.00),
    (""D"", 55.00, 116.00),
    (""E"", 70.00, 148.00)
]

for line in sys.stdin:
    t1, t2 = map(float, line.strip().split())
    
    result = ""NA""
    for grade, time_500, time_1000 in grades:
        if t1 < time_500 and t2 < time_1000:
            result = grade
            break
    
    print(result)
",0
p00123,"スピードスケートバッジテスト
スピードスケートバッジテストでは、2 種類の距離で規定されたタイムを上回った場合に級が認定されます。例えば A 級になるには 500 M で 40.0 秒未満、かつ 1000 M で 1 分 23 秒未満であることが求められます。
スピードスケート大会 (500 M と 1000 M) で記録したタイムを入力とし、スピードスケートバッジテストで何級に相当するかを出力するプログラムを作成して下さい。500 M と1000 M のバッジテスト規定タイムは下表のとおりです。 E 級に満たなかった場合には、NA と出力してください。
500 M
1000 M
AAA 級
35 秒 50
1 分 11 秒 00
AA 級
37 秒 50
1 分 17 秒 00
A 級
40 秒 00
1 分 23 秒 00
B 級
43 秒 00
1 分 29 秒 00
C 級
50 秒 00
1 分 45 秒 00
D 級
55 秒 00
1 分 56 秒 00
E 級
1分10 秒 00
2 分 28 秒 00
Input
複数のデータセットが与えられます。各データセットとして、500 M タイムと 1000 M タイムをそれぞれ表す実数
t
1
,
t
2
(8.0 ≤
t
1
,
t
2
≤ 360.0) が空白区切りで与えられます。
t
1
,
t
2
は秒単位で小数点以下最大 2 桁までの数字を含む実数で与えられます。
データセットの数は 100 を超えません。
Output
各データセットごとに、判定結果 AAA ~ E または NA を１行に出力してください。
Sample Input
40.0 70.0
72.5 140.51
Output for the Sample Input
B
NA",Python,"
# 500 M	1000 M
# AAA 級	35 秒 50	1 分 11 秒 00
# AA 級	37 秒 50	1 分 17 秒 00
# A 級	40 秒 00	1 分 23 秒 00
# B 級	43 秒 00	1 分 29 秒 00
# C 級	50 秒 00	1 分 45 秒 00
# D 級	55 秒 00	1 分 56 秒 00
# E 級	1分10 秒 00	2 分 28 秒 00

ranks = [""AAA"",""AA"",""A"",""B"",""C"",""D"",""E"",""NA""]
timesA = [35.50,37.50,40,43,50,55,70]
timesB = [71,77,83,89,105,116,148]

while(1):
    try:
        a,b = (float(x) for x in input().split())
        rankA = rankB = 7
        # checkA
        for i in range(0,7):
            if timesA[i] > a:
                rankA = i
                break
        # checkB
        for i in range(rankA,7):
            if timesB[i] > b:
                rankB = max(rankA,i)
                break
        print(ranks[rankB])
    except:
        break
",1
p00124,"リーグ戦のスコアシート
スポーツの大会にはリーグ戦とトーナメント戦があります。サッカーのリーグ戦では勝・負・引分にそれぞれ点数を付け、その勝ち点で順位を競います。勝ち点はそれぞれ勝(3点)、負(0点)、引分(1点)です。
チーム数とリーグ戦の成績を入力とし、成績の良い順(勝ち点の多い順)に並べ替え、チーム名と勝ち点を出力するプログラムを作成してください。勝ち点が同点の場合は入力順に出力してください。
Input
複数のデータセットが与えられます。各データセットは以下の形式で与えられます。
n
name
1
w
1
l
1
d
1
name
2
w
2
l
2
d
2
:
name
n
w
n
l
n
d
n
１行目にチーム数
n
(
n
≤ 10) が与えられます。続く
n
行にチーム
i
の名前
name
i
(20文字以内のアルファベット)、勝の数
w
i
、負の数
l
i
、引分の数
d
i
(0 ≤
w
i
,
l
i
,
d
i
≤ 9) が空白区切りで与えられます。
チーム数が 0 のとき、入力の終了とします。データセットの数は 50 を超えません。
Output
データセットごとに、並べ替えたチームのリストを出力してください。
i
行目に
i
番目のチームの名前と勝ち点をカンマで区切って出力してください。
データセットの間に１つの空行を入れてください。
Sample Input
4
Japan 1 0 2
Egypt 1 2 0
Canada 0 2 1
Spain 2 0 1
3
India 0 2 0
Poland 1 0 1
Italy 1 0 1
0
Output for the Sample Input
Spain,7
Japan,5
Egypt,3
Canada,1

Poland,4
Italy,4
India,0",C,"#include <stdio.h>
#include <string.h>

typedef struct {
    char name[21];
    int points;
    int order;
} Team;

int main() {
    int n;
    int first = 1;
    
    while (1) {
        scanf(""%d"", &n);
        if (n == 0) break;
        
        if (!first) {
            printf(""\n"");
        }
        first = 0;
        
        Team teams[10];
        
        for (int i = 0; i < n; i++) {
            int w, l, d;
            scanf(""%s %d %d %d"", teams[i].name, &w, &l, &d);
            teams[i].points = w * 3 + d * 1;
            teams[i].order = i;
        }
        
        // Bubble sort
        for (int i = 0; i < n - 1; i++) {
            for (int j = 0; j < n - 1 - i; j++) {
                if (teams[j].points < teams[j + 1].points ||
                    (teams[j].points == teams[j + 1].points && teams[j].order > teams[j + 1].order)) {
                    Team temp = teams[j];
                    teams[j] = teams[j + 1];
                    teams[j + 1] = temp;
                }
            }
        }
        
        for (int i = 0; i < n; i++) {
            printf(""%s,%d\n"", teams[i].name, teams[i].points);
        }
    }
    
    return 0;
}
",0
p00124,"リーグ戦のスコアシート
スポーツの大会にはリーグ戦とトーナメント戦があります。サッカーのリーグ戦では勝・負・引分にそれぞれ点数を付け、その勝ち点で順位を競います。勝ち点はそれぞれ勝(3点)、負(0点)、引分(1点)です。
チーム数とリーグ戦の成績を入力とし、成績の良い順(勝ち点の多い順)に並べ替え、チーム名と勝ち点を出力するプログラムを作成してください。勝ち点が同点の場合は入力順に出力してください。
Input
複数のデータセットが与えられます。各データセットは以下の形式で与えられます。
n
name
1
w
1
l
1
d
1
name
2
w
2
l
2
d
2
:
name
n
w
n
l
n
d
n
１行目にチーム数
n
(
n
≤ 10) が与えられます。続く
n
行にチーム
i
の名前
name
i
(20文字以内のアルファベット)、勝の数
w
i
、負の数
l
i
、引分の数
d
i
(0 ≤
w
i
,
l
i
,
d
i
≤ 9) が空白区切りで与えられます。
チーム数が 0 のとき、入力の終了とします。データセットの数は 50 を超えません。
Output
データセットごとに、並べ替えたチームのリストを出力してください。
i
行目に
i
番目のチームの名前と勝ち点をカンマで区切って出力してください。
データセットの間に１つの空行を入れてください。
Sample Input
4
Japan 1 0 2
Egypt 1 2 0
Canada 0 2 1
Spain 2 0 1
3
India 0 2 0
Poland 1 0 1
Italy 1 0 1
0
Output for the Sample Input
Spain,7
Japan,5
Egypt,3
Canada,1

Poland,4
Italy,4
India,0",C,"#include<stdio.h>
typedef struct{
  char name[20];
  int point;
}P;
main(){
  int a,b,c,n,i,j,flag=0;
  while(1){

    scanf(""%d"",&n);
    if(n==0)break;
    if(flag!=0)printf(""\n"");
    flag=1;
    P temp[n];
    P flg;
    for(i=0;i<n;i++){
      scanf(""%s %d %d %d"",temp[i].name,&a,&b,&c);
      temp[i].point=a*3+c;
    }

    for(i=0;i<n-1;i++){
      for(j=n-1;j>i;j--){
	if(temp[j].point>temp[j-1].point){
	  flg=temp[j];
	  temp[j]=temp[j-1];
	  temp[j-1]=flg;
	}
      }
    }
    for(i=0;i<n;i++)printf(""%s,%d\n"",temp[i].name,temp[i].point);}
    
  return 0;
}",1
p00124,"リーグ戦のスコアシート
スポーツの大会にはリーグ戦とトーナメント戦があります。サッカーのリーグ戦では勝・負・引分にそれぞれ点数を付け、その勝ち点で順位を競います。勝ち点はそれぞれ勝(3点)、負(0点)、引分(1点)です。
チーム数とリーグ戦の成績を入力とし、成績の良い順(勝ち点の多い順)に並べ替え、チーム名と勝ち点を出力するプログラムを作成してください。勝ち点が同点の場合は入力順に出力してください。
Input
複数のデータセットが与えられます。各データセットは以下の形式で与えられます。
n
name
1
w
1
l
1
d
1
name
2
w
2
l
2
d
2
:
name
n
w
n
l
n
d
n
１行目にチーム数
n
(
n
≤ 10) が与えられます。続く
n
行にチーム
i
の名前
name
i
(20文字以内のアルファベット)、勝の数
w
i
、負の数
l
i
、引分の数
d
i
(0 ≤
w
i
,
l
i
,
d
i
≤ 9) が空白区切りで与えられます。
チーム数が 0 のとき、入力の終了とします。データセットの数は 50 を超えません。
Output
データセットごとに、並べ替えたチームのリストを出力してください。
i
行目に
i
番目のチームの名前と勝ち点をカンマで区切って出力してください。
データセットの間に１つの空行を入れてください。
Sample Input
4
Japan 1 0 2
Egypt 1 2 0
Canada 0 2 1
Spain 2 0 1
3
India 0 2 0
Poland 1 0 1
Italy 1 0 1
0
Output for the Sample Input
Spain,7
Japan,5
Egypt,3
Canada,1

Poland,4
Italy,4
India,0",Java,"import java.util.*;

public class Main {
    static class Team {
        String name;
        int points;
        int order;
        
        Team(String name, int points, int order) {
            this.name = name;
            this.points = points;
            this.order = order;
        }
    }
    
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        boolean first = true;
        
        while (true) {
            int n = sc.nextInt();
            if (n == 0) break;
            
            if (!first) {
                System.out.println();
            }
            first = false;
            
            List<Team> teams = new ArrayList<>();
            
            for (int i = 0; i < n; i++) {
                String name = sc.next();
                int w = sc.nextInt();
                int l = sc.nextInt();
                int d = sc.nextInt();
                
                int points = w * 3 + d * 1;
                teams.add(new Team(name, points, i));
            }
            
            teams.sort((a, b) -> {
                if (a.points != b.points) {
                    return b.points - a.points;
                }
                return a.order - b.order;
            });
            
            for (Team team : teams) {
                System.out.println(team.name + "","" + team.points);
            }
        }
        
        sc.close();
    }
}
",0
p00124,"リーグ戦のスコアシート
スポーツの大会にはリーグ戦とトーナメント戦があります。サッカーのリーグ戦では勝・負・引分にそれぞれ点数を付け、その勝ち点で順位を競います。勝ち点はそれぞれ勝(3点)、負(0点)、引分(1点)です。
チーム数とリーグ戦の成績を入力とし、成績の良い順(勝ち点の多い順)に並べ替え、チーム名と勝ち点を出力するプログラムを作成してください。勝ち点が同点の場合は入力順に出力してください。
Input
複数のデータセットが与えられます。各データセットは以下の形式で与えられます。
n
name
1
w
1
l
1
d
1
name
2
w
2
l
2
d
2
:
name
n
w
n
l
n
d
n
１行目にチーム数
n
(
n
≤ 10) が与えられます。続く
n
行にチーム
i
の名前
name
i
(20文字以内のアルファベット)、勝の数
w
i
、負の数
l
i
、引分の数
d
i
(0 ≤
w
i
,
l
i
,
d
i
≤ 9) が空白区切りで与えられます。
チーム数が 0 のとき、入力の終了とします。データセットの数は 50 を超えません。
Output
データセットごとに、並べ替えたチームのリストを出力してください。
i
行目に
i
番目のチームの名前と勝ち点をカンマで区切って出力してください。
データセットの間に１つの空行を入れてください。
Sample Input
4
Japan 1 0 2
Egypt 1 2 0
Canada 0 2 1
Spain 2 0 1
3
India 0 2 0
Poland 1 0 1
Italy 1 0 1
0
Output for the Sample Input
Spain,7
Japan,5
Egypt,3
Canada,1

Poland,4
Italy,4
India,0",Java,"import java.util.*;

class Main {
  public static void main (String[] args) {
    Scanner scanner = new Scanner(System.in);
    String out = """";
    while (scanner.hasNext()) {
      int n = scanner.nextInt();
      if (n == 0) {
        break;
      }
      List<String> ts = new ArrayList<String>();
      for (int ii = 0; ii < n; ii++) {
        String t = scanner.next();
        int w = scanner.nextInt();
        int l = scanner.nextInt();
        int d = scanner.nextInt();
        String wp = ""0000"" + (w * 3 + d);
        wp = wp.substring(wp.length() - 5);
        String idx = ""00"" + (n - ii);
        idx = idx.substring(idx.length() - 3);
        ts.add(wp + "","" + idx + "","" + t);
      }
      Collections.sort(ts);
      Collections.reverse(ts);
      for (String el : ts) {
        String[] works = el.split("","");
        int wp = Integer.parseInt(works[0]);
        out += works[2] + "","" + wp + ""\n"";
      }
      out += ""\n"";
    }
    System.out.print(out.substring(0, out.length() - 1));
  }
}",1
p00124,"リーグ戦のスコアシート
スポーツの大会にはリーグ戦とトーナメント戦があります。サッカーのリーグ戦では勝・負・引分にそれぞれ点数を付け、その勝ち点で順位を競います。勝ち点はそれぞれ勝(3点)、負(0点)、引分(1点)です。
チーム数とリーグ戦の成績を入力とし、成績の良い順(勝ち点の多い順)に並べ替え、チーム名と勝ち点を出力するプログラムを作成してください。勝ち点が同点の場合は入力順に出力してください。
Input
複数のデータセットが与えられます。各データセットは以下の形式で与えられます。
n
name
1
w
1
l
1
d
1
name
2
w
2
l
2
d
2
:
name
n
w
n
l
n
d
n
１行目にチーム数
n
(
n
≤ 10) が与えられます。続く
n
行にチーム
i
の名前
name
i
(20文字以内のアルファベット)、勝の数
w
i
、負の数
l
i
、引分の数
d
i
(0 ≤
w
i
,
l
i
,
d
i
≤ 9) が空白区切りで与えられます。
チーム数が 0 のとき、入力の終了とします。データセットの数は 50 を超えません。
Output
データセットごとに、並べ替えたチームのリストを出力してください。
i
行目に
i
番目のチームの名前と勝ち点をカンマで区切って出力してください。
データセットの間に１つの空行を入れてください。
Sample Input
4
Japan 1 0 2
Egypt 1 2 0
Canada 0 2 1
Spain 2 0 1
3
India 0 2 0
Poland 1 0 1
Italy 1 0 1
0
Output for the Sample Input
Spain,7
Japan,5
Egypt,3
Canada,1

Poland,4
Italy,4
India,0",Python,"results = []
while True:
    n = int(input())
    if n == 0:
        break
    
    teams = []
    for i in range(n):
        parts = input().split()
        name = parts[0]
        w = int(parts[1])
        l = int(parts[2])
        d = int(parts[3])
        points = w * 3 + d * 1
        teams.append((name, points, i))
    
    teams.sort(key=lambda x: (-x[1], x[2]))
    
    result = []
    for team in teams:
        result.append(f""{team[0]},{team[1]}"")
    
    results.append(result)

for i, result in enumerate(results):
    for line in result:
        print(line)
    if i < len(results) - 1:
        print()
",0
p00124,"リーグ戦のスコアシート
スポーツの大会にはリーグ戦とトーナメント戦があります。サッカーのリーグ戦では勝・負・引分にそれぞれ点数を付け、その勝ち点で順位を競います。勝ち点はそれぞれ勝(3点)、負(0点)、引分(1点)です。
チーム数とリーグ戦の成績を入力とし、成績の良い順(勝ち点の多い順)に並べ替え、チーム名と勝ち点を出力するプログラムを作成してください。勝ち点が同点の場合は入力順に出力してください。
Input
複数のデータセットが与えられます。各データセットは以下の形式で与えられます。
n
name
1
w
1
l
1
d
1
name
2
w
2
l
2
d
2
:
name
n
w
n
l
n
d
n
１行目にチーム数
n
(
n
≤ 10) が与えられます。続く
n
行にチーム
i
の名前
name
i
(20文字以内のアルファベット)、勝の数
w
i
、負の数
l
i
、引分の数
d
i
(0 ≤
w
i
,
l
i
,
d
i
≤ 9) が空白区切りで与えられます。
チーム数が 0 のとき、入力の終了とします。データセットの数は 50 を超えません。
Output
データセットごとに、並べ替えたチームのリストを出力してください。
i
行目に
i
番目のチームの名前と勝ち点をカンマで区切って出力してください。
データセットの間に１つの空行を入れてください。
Sample Input
4
Japan 1 0 2
Egypt 1 2 0
Canada 0 2 1
Spain 2 0 1
3
India 0 2 0
Poland 1 0 1
Italy 1 0 1
0
Output for the Sample Input
Spain,7
Japan,5
Egypt,3
Canada,1

Poland,4
Italy,4
India,0",Python,"isPrint = False

while True:

    inputCount = int(input())

    if inputCount == 0:
        break

    if isPrint:
        print()
    else:
        isPrint = True

    matchList = []

    for lp in range(inputCount):

        name, win, lose, draw = [item for item in input().split("" "")]
        score = int(win) * 3 + int(draw)

        matchList.append([name, score])

    matchList.sort(key=lambda item: -item[1])

    for name, score in matchList:
        print(name + "","" + str(score))

",1
p00125,"日数
2 つの日付を入力とし、その 2 つの日付けの間の日数を出力するプログラムを作成してください。
日付 1 (
y
1
, m
1
, d
1
) は日付 2 (
y
2
, m
2
, d
2
) と同じか、あるいはそれ以前の日付とします。日付 1 は日数に含め、日付 2 は含めません。また、うるう年を考慮にいれて計算してください。うるう年の条件は次のとおりとします。
西暦年が 4 で割り切れる年であること。
ただし、100 で割り切れる年はうるう年としない。
しかし、400 で割り切れる年はうるう年である。
Input
複数のデータセットが与えられます。各データセットの形式は以下のとおりです：
y
1
m
1
d
1
y
2
m
2
d
2
y
1
,
m
1
,
d
1
,
y
2
,
m
2
,
d
2
のいずれかが負の数のとき入力の終わりとします。
データセットの数は 50 を超えません。
Output
データセットごとに、日数を１行に出力してください。
Sample Input
2006 9 2 2006 9 3
2006 9 2 2006 11 11
2004 1 1 2005 1 1
2000 1 1 2006 1 1
2000 1 1 2101 1 1
-1 -1 -1 -1 -1 -1
Output for the Sample Input
1
70
366
2192
36890",C,"#include <stdio.h>

int is_leap(int year) {
    if (year % 400 == 0) return 1;
    if (year % 100 == 0) return 0;
    if (year % 4 == 0) return 1;
    return 0;
}

int days_in_month(int year, int month) {
    int days[] = {0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};
    if (month == 2 && is_leap(year)) {
        return 29;
    }
    return days[month];
}

int days_from_epoch(int year, int month, int day) {
    int total = 0;
    
    // Add days for complete years from year 1
    for (int y = 1; y < year; y++) {
        if (is_leap(y)) {
            total += 366;
        } else {
            total += 365;
        }
    }
    
    // Add days for complete months in the current year
    for (int m = 1; m < month; m++) {
        total += days_in_month(year, m);
    }
    
    // Add the days
    total += day;
    
    return total;
}

int main() {
    int y1, m1, d1, y2, m2, d2;
    
    while (scanf(""%d %d %d %d %d %d"", &y1, &m1, &d1, &y2, &m2, &d2) == 6) {
        if (y1 < 0 || m1 < 0 || d1 < 0 || y2 < 0 || m2 < 0 || d2 < 0) {
            break;
        }
        
        int days1 = days_from_epoch(y1, m1, d1);
        int days2 = days_from_epoch(y2, m2, d2);
        
        printf(""%d\n"", days2 - days1);
    }
    
    return 0;
}
",0
p00125,"日数
2 つの日付を入力とし、その 2 つの日付けの間の日数を出力するプログラムを作成してください。
日付 1 (
y
1
, m
1
, d
1
) は日付 2 (
y
2
, m
2
, d
2
) と同じか、あるいはそれ以前の日付とします。日付 1 は日数に含め、日付 2 は含めません。また、うるう年を考慮にいれて計算してください。うるう年の条件は次のとおりとします。
西暦年が 4 で割り切れる年であること。
ただし、100 で割り切れる年はうるう年としない。
しかし、400 で割り切れる年はうるう年である。
Input
複数のデータセットが与えられます。各データセットの形式は以下のとおりです：
y
1
m
1
d
1
y
2
m
2
d
2
y
1
,
m
1
,
d
1
,
y
2
,
m
2
,
d
2
のいずれかが負の数のとき入力の終わりとします。
データセットの数は 50 を超えません。
Output
データセットごとに、日数を１行に出力してください。
Sample Input
2006 9 2 2006 9 3
2006 9 2 2006 11 11
2004 1 1 2005 1 1
2000 1 1 2006 1 1
2000 1 1 2101 1 1
-1 -1 -1 -1 -1 -1
Output for the Sample Input
1
70
366
2192
36890",C,"#include<stdio.h>
#include<time.h>
#include<string.h>
int main(void) {
	time_t tim1,tim2;
	struct tm d;
	double diff;
	int year1, year2, month1, month2, day1, day2;
	while (1) {
		scanf(""%d %d %d %d %d %d"",&year1,&month1,&day1,&year2,&month2,&day2);
		if (month1 == -1 || year1 == -1 || day1 == -1 ||month2 == -1 || year2 == -1 || day2 == -1) break;
		memset(&d,0,sizeof(d));
		d.tm_year = year1 - 1900;
		d.tm_mon = month1 - 1;
		d.tm_mday = day1;
		tim1 = mktime(&d);
		d.tm_year = year2 - 1900;
		d.tm_mon = month2 - 1;
		d.tm_mday = day2;
		tim2 = mktime(&d);

		diff = difftime(tim2, tim1);

		printf(""%d\n"",(int)(diff/60/60/24+0.5));
	}
	return 0;
}",1
p00125,"日数
2 つの日付を入力とし、その 2 つの日付けの間の日数を出力するプログラムを作成してください。
日付 1 (
y
1
, m
1
, d
1
) は日付 2 (
y
2
, m
2
, d
2
) と同じか、あるいはそれ以前の日付とします。日付 1 は日数に含め、日付 2 は含めません。また、うるう年を考慮にいれて計算してください。うるう年の条件は次のとおりとします。
西暦年が 4 で割り切れる年であること。
ただし、100 で割り切れる年はうるう年としない。
しかし、400 で割り切れる年はうるう年である。
Input
複数のデータセットが与えられます。各データセットの形式は以下のとおりです：
y
1
m
1
d
1
y
2
m
2
d
2
y
1
,
m
1
,
d
1
,
y
2
,
m
2
,
d
2
のいずれかが負の数のとき入力の終わりとします。
データセットの数は 50 を超えません。
Output
データセットごとに、日数を１行に出力してください。
Sample Input
2006 9 2 2006 9 3
2006 9 2 2006 11 11
2004 1 1 2005 1 1
2000 1 1 2006 1 1
2000 1 1 2101 1 1
-1 -1 -1 -1 -1 -1
Output for the Sample Input
1
70
366
2192
36890",Java,"import java.util.Scanner;

public class Main {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        
        while (true) {
            int y1 = sc.nextInt();
            int m1 = sc.nextInt();
            int d1 = sc.nextInt();
            int y2 = sc.nextInt();
            int m2 = sc.nextInt();
            int d2 = sc.nextInt();
            
            if (y1 < 0 || m1 < 0 || d1 < 0 || y2 < 0 || m2 < 0 || d2 < 0) {
                break;
            }
            
            int days = countDays(y1, m1, d1, y2, m2, d2);
            System.out.println(days);
        }
        
        sc.close();
    }
    
    static int countDays(int y1, int m1, int d1, int y2, int m2, int d2) {
        int days1 = toDays(y1, m1, d1);
        int days2 = toDays(y2, m2, d2);
        return days2 - days1;
    }
    
    static int toDays(int year, int month, int day) {
        int days = 0;
        
        // Count days for complete years from year 1
        for (int y = 1; y < year; y++) {
            if (isLeapYear(y)) {
                days += 366;
            } else {
                days += 365;
            }
        }
        
        // Count days for complete months in the current year
        for (int m = 1; m < month; m++) {
            days += getDaysInMonth(year, m);
        }
        
        // Add remaining days
        days += day;
        
        return days;
    }
    
    static boolean isLeapYear(int year) {
        if (year % 400 == 0) {
            return true;
        }
        if (year % 100 == 0) {
            return false;
        }
        if (year % 4 == 0) {
            return true;
        }
        return false;
    }
    
    static int getDaysInMonth(int year, int month) {
        int[] days = {0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};
        
        if (month == 2 && isLeapYear(year)) {
            return 29;
        }
        
        return days[month];
    }
}
",0
p00125,"日数
2 つの日付を入力とし、その 2 つの日付けの間の日数を出力するプログラムを作成してください。
日付 1 (
y
1
, m
1
, d
1
) は日付 2 (
y
2
, m
2
, d
2
) と同じか、あるいはそれ以前の日付とします。日付 1 は日数に含め、日付 2 は含めません。また、うるう年を考慮にいれて計算してください。うるう年の条件は次のとおりとします。
西暦年が 4 で割り切れる年であること。
ただし、100 で割り切れる年はうるう年としない。
しかし、400 で割り切れる年はうるう年である。
Input
複数のデータセットが与えられます。各データセットの形式は以下のとおりです：
y
1
m
1
d
1
y
2
m
2
d
2
y
1
,
m
1
,
d
1
,
y
2
,
m
2
,
d
2
のいずれかが負の数のとき入力の終わりとします。
データセットの数は 50 を超えません。
Output
データセットごとに、日数を１行に出力してください。
Sample Input
2006 9 2 2006 9 3
2006 9 2 2006 11 11
2004 1 1 2005 1 1
2000 1 1 2006 1 1
2000 1 1 2101 1 1
-1 -1 -1 -1 -1 -1
Output for the Sample Input
1
70
366
2192
36890",Java,"import java.util.Scanner;


public class Main {

	final int DAY_MONTH[]={0, 31, 28, 31, 30, 31, 30, 31, 31, 30 ,31, 30 ,31};
	
	Scanner sc;
	
	int isLeap(int y){
		if(y%4==0){
			if(y%100==0){
				if(y%400==0){
					return 1;
				}
				else{
					return 0;
				}
			}
			else{
				return 1;
			}
		}
		else{
			return 0;
		}
	}
	
	int dayCount(int y, int m1, int d1, int m2, int d2){
		int days=-d1;
		for(int m=m1;m<=m2;++m){
			days+=DAY_MONTH[m];
			if(m==2) days+=isLeap(y);
		}
		days-=DAY_MONTH[m2]+(m2==2?isLeap(y):0)-d2;
		return days;
	}
	
	int solve(int y1, int m1, int d1, int y2, int m2, int d2){
		int days=0;
		if(y2-y1>=2){
			for(int y=y1+1;y<y2;++y){
				days+=365+isLeap(y);
			}
		}
		if(y2-y1>=1){
			days+=dayCount(y1, m1, d1, 12, 31)+dayCount(y2, 1, 1, m2, d2)+1;
		}
		else{
			days=dayCount(y1, m1, d1, m2, d2);
		}
		return days;
	}
	
	int ni(){
		return sc.nextInt();
	}
	
	void io(){
		sc=new Scanner(System.in);
		
		while(true){
			int y1=ni(), m1=ni(), d1=ni(), y2=ni(), m2=ni(), d2=ni();
			if(y1<0||m1<0||d1<0||y2<0||m2<0||d2<0) break;
			
			System.out.println(solve(y1, m1, d1, y2, m2, d2));
		}
		
		sc.close();
	}
	
	public static void main(String[] args) {
		// TODO Auto-generated method stub
		new Main().io();
	}

}",1
p00125,"日数
2 つの日付を入力とし、その 2 つの日付けの間の日数を出力するプログラムを作成してください。
日付 1 (
y
1
, m
1
, d
1
) は日付 2 (
y
2
, m
2
, d
2
) と同じか、あるいはそれ以前の日付とします。日付 1 は日数に含め、日付 2 は含めません。また、うるう年を考慮にいれて計算してください。うるう年の条件は次のとおりとします。
西暦年が 4 で割り切れる年であること。
ただし、100 で割り切れる年はうるう年としない。
しかし、400 で割り切れる年はうるう年である。
Input
複数のデータセットが与えられます。各データセットの形式は以下のとおりです：
y
1
m
1
d
1
y
2
m
2
d
2
y
1
,
m
1
,
d
1
,
y
2
,
m
2
,
d
2
のいずれかが負の数のとき入力の終わりとします。
データセットの数は 50 を超えません。
Output
データセットごとに、日数を１行に出力してください。
Sample Input
2006 9 2 2006 9 3
2006 9 2 2006 11 11
2004 1 1 2005 1 1
2000 1 1 2006 1 1
2000 1 1 2101 1 1
-1 -1 -1 -1 -1 -1
Output for the Sample Input
1
70
366
2192
36890",Python,"def is_leap_year(year):
    if year % 400 == 0:
        return True
    if year % 100 == 0:
        return False
    if year % 4 == 0:
        return True
    return False

def days_in_month(year, month):
    if month in [1, 3, 5, 7, 8, 10, 12]:
        return 31
    elif month in [4, 6, 9, 11]:
        return 30
    elif month == 2:
        return 29 if is_leap_year(year) else 28

def days_from_epoch(year, month, day):
    # Calculate days from year 0
    days = 0
    
    # Add days for complete years
    for y in range(1, year):
        if is_leap_year(y):
            days += 366
        else:
            days += 365
    
    # Add days for complete months in the current year
    for m in range(1, month):
        days += days_in_month(year, m)
    
    # Add remaining days
    days += day
    
    return days

while True:
    line = list(map(int, input().split()))
    y1, m1, d1, y2, m2, d2 = line
    
    if y1 < 0 or m1 < 0 or d1 < 0 or y2 < 0 or m2 < 0 or d2 < 0:
        break
    
    days1 = days_from_epoch(y1, m1, d1)
    days2 = days_from_epoch(y2, m2, d2)
    
    print(days2 - days1)
",0
p00125,"日数
2 つの日付を入力とし、その 2 つの日付けの間の日数を出力するプログラムを作成してください。
日付 1 (
y
1
, m
1
, d
1
) は日付 2 (
y
2
, m
2
, d
2
) と同じか、あるいはそれ以前の日付とします。日付 1 は日数に含め、日付 2 は含めません。また、うるう年を考慮にいれて計算してください。うるう年の条件は次のとおりとします。
西暦年が 4 で割り切れる年であること。
ただし、100 で割り切れる年はうるう年としない。
しかし、400 で割り切れる年はうるう年である。
Input
複数のデータセットが与えられます。各データセットの形式は以下のとおりです：
y
1
m
1
d
1
y
2
m
2
d
2
y
1
,
m
1
,
d
1
,
y
2
,
m
2
,
d
2
のいずれかが負の数のとき入力の終わりとします。
データセットの数は 50 を超えません。
Output
データセットごとに、日数を１行に出力してください。
Sample Input
2006 9 2 2006 9 3
2006 9 2 2006 11 11
2004 1 1 2005 1 1
2000 1 1 2006 1 1
2000 1 1 2101 1 1
-1 -1 -1 -1 -1 -1
Output for the Sample Input
1
70
366
2192
36890",Python,"def f1():
    if y1 == y2 and m1 == m2:
        return d2- d1
    
    a = 0
    if y1 % 400 == 0 or (y1 % 4 == 0 and y1 % 100 != 0):
        a = 29
    else:
        a = 28
    
    t = 0
    if m1 in [4,6,9,11]:
        t += (30 - d1 + 1)
    elif m1 in [1,3,5,7,8,10,12]:
        t += (31 - d1 + 1)
    else:
        t += (a - d1 + 1)
        
        
    if y1 == y2:
        return f3(t, m1+1)
    else:
        for m in range(m1+1, 13):
            if m in [4,6,9,11]:
                t += 30
            elif m in [1,3,5,7,8,10,12]:
                t += 31
            else:
                t += a
            
        return f2(t)
    
def f2(t):
    for y in range(y1+1, y2):
        if y % 400 == 0 or (y % 4 == 0 and y % 100 != 0):
            t += 366
        else:
            t += 365
    
    return f3(t, 1)
    
def f3(t, s):
    a = 0
    if y2 % 400 == 0 or (y2 % 4 == 0 and y2 % 100 != 0):
        a = 29
    else:
        a = 28
        
    for m in range(s, m2):
        if m in [4,6,9,11]:
            t += 30
        elif m in [1,3,5,7,8,10,12]:
            t += 31
        else:
            t += a
            
    t += (d2 - 1)
            
    return t
            
while True:
    y1, m1, d1, y2, m2, d2 = map(int, raw_input().split())
    if y1 < 0 or m1 < 0 or d1 < 0 or y2 < 0 or m2 < 0 or d2 < 0:
        break
    print f1()",1
p00126,"パズル
たろう君は 9 × 9 のマス目に 1〜9 の数字を配置するパズルで遊んでいます。このパズルでは以下の規則で数字を配置しなければいけません。
同じ列に 1 つの数字はちょうど 1 回だけ現われる
同じ行に 1 つの数字はちょうど 1 回だけ現われる
二重線で区切られた 3 × 3 の各範囲には、1 つの数字はちょうど 1 回だけ現われる
例えば、下の図 1 はそのような規則を満たした配置の一つです。しかしたろう君は、図 2 のようによく規則に反した配置を作ってしまいます。左端の列に「2」が 2 回現われて、「1」が 1 回も現われず、左から2 番目の列に「1」が 2 回現われて、「2」が 1 回も現われていません。
図 1
図 2
たろう君を助けるために、数字の配置を読み込んで、その配置が規則を満たしているかどうかを調べ、規則に反していたらその場所を出力するプログラムを作成してください。3 つの規則に照らして誤っている (2 回以上現れている) 数字の前には * (半角アスタリスク)を、誤っていない数字の前には空白を表示してください。
Input
複数のデータセットが与えられます。最初の行にデータセットの数
n
(
n
≤ 20) が与えられます。各データセットとして、パズルの状態を示す 1 行 9 文字、9 行からなる数字列が与えられます。
Output
各データセットについて以下を出力してください。
与えられた数字と * (半角アスタリスク)と空白。誤っている数字の前には *、誤っていない数字の前には半角空白を付加する。
データセットの間に 1 行の空行を入れてください。
Sample Input
2
2 1 3 4 5 6 7 8 9
4 5 6 7 8 9 1 2 3
7 8 9 1 2 3 4 5 6
2 3 4 5 6 7 8 9 1
5 6 7 8 9 1 2 3 4
8 9 1 2 3 4 5 6 7
3 4 5 6 7 8 9 1 2
6 7 8 9 1 2 3 4 5
9 1 2 3 4 5 6 7 8
2 1 3 4 5 6 7 8 9
4 5 6 7 8 9 1 2 3
7 8 9 1 2 3 4 5 6
2 3 4 5 6 7 8 9 1
5 6 7 8 9 1 2 3 4
8 9 1 2 3 4 5 6 7
3 4 5 6 7 8 9 1 2
6 7 8 9 1 2 3 4 5
9 1 2 3 4 5 6 7 8
Output for the Sample Input
*2*1 3 4 5 6 7 8 9
 4 5 6 7 8 9 1 2 3
 7 8 9 1 2 3 4 5 6
*2 3 4 5 6 7 8 9 1
 5 6 7 8 9 1 2 3 4
 8 9 1 2 3 4 5 6 7
 3 4 5 6 7 8 9 1 2
 6 7 8 9 1 2 3 4 5
 9*1 2 3 4 5 6 7 8

*2*1 3 4 5 6 7 8 9
 4 5 6 7 8 9 1 2 3
 7 8 9 1 2 3 4 5 6
*2 3 4 5 6 7 8 9 1
 5 6 7 8 9 1 2 3 4
 8 9 1 2 3 4 5 6 7
 3 4 5 6 7 8 9 1 2
 6 7 8 9 1 2 3 4 5
 9*1 2 3 4 5 6 7 8",C,"#include <stdio.h>
#include <string.h>

int main() {
    int n;
    scanf(""%d"", &n);
    
    for (int dataset = 0; dataset < n; dataset++) {
        int grid[9][9];
        int error[9][9];
        
        // Read input
        for (int i = 0; i < 9; i++) {
            for (int j = 0; j < 9; j++) {
                scanf(""%d"", &grid[i][j]);
                error[i][j] = 0;
            }
        }
        
        // Check rows
        for (int i = 0; i < 9; i++) {
            int count[10] = {0};
            for (int j = 0; j < 9; j++) {
                count[grid[i][j]]++;
            }
            for (int j = 0; j < 9; j++) {
                if (count[grid[i][j]] > 1) {
                    error[i][j] = 1;
                }
            }
        }
        
        // Check columns
        for (int j = 0; j < 9; j++) {
            int count[10] = {0};
            for (int i = 0; i < 9; i++) {
                count[grid[i][j]]++;
            }
            for (int i = 0; i < 9; i++) {
                if (count[grid[i][j]] > 1) {
                    error[i][j] = 1;
                }
            }
        }
        
        // Check 3x3 blocks
        for (int block_i = 0; block_i < 3; block_i++) {
            for (int block_j = 0; block_j < 3; block_j++) {
                int count[10] = {0};
                for (int i = block_i * 3; i < block_i * 3 + 3; i++) {
                    for (int j = block_j * 3; j < block_j * 3 + 3; j++) {
                        count[grid[i][j]]++;
                    }
                }
                for (int i = block_i * 3; i < block_i * 3 + 3; i++) {
                    for (int j = block_j * 3; j < block_j * 3 + 3; j++) {
                        if (count[grid[i][j]] > 1) {
                            error[i][j] = 1;
                        }
                    }
                }
            }
        }
        
        // Output
        for (int i = 0; i < 9; i++) {
            for (int j = 0; j < 9; j++) {
                if (error[i][j]) {
                    printf(""*%d"", grid[i][j]);
                } else {
                    printf("" %d"", grid[i][j]);
                }
                if (j < 8) printf("" "");
            }
            printf(""\n"");
        }
        
        if (dataset < n - 1) {
            printf(""\n"");
        }
    }
    
    return 0;
}
",0
p00126,"パズル
たろう君は 9 × 9 のマス目に 1〜9 の数字を配置するパズルで遊んでいます。このパズルでは以下の規則で数字を配置しなければいけません。
同じ列に 1 つの数字はちょうど 1 回だけ現われる
同じ行に 1 つの数字はちょうど 1 回だけ現われる
二重線で区切られた 3 × 3 の各範囲には、1 つの数字はちょうど 1 回だけ現われる
例えば、下の図 1 はそのような規則を満たした配置の一つです。しかしたろう君は、図 2 のようによく規則に反した配置を作ってしまいます。左端の列に「2」が 2 回現われて、「1」が 1 回も現われず、左から2 番目の列に「1」が 2 回現われて、「2」が 1 回も現われていません。
図 1
図 2
たろう君を助けるために、数字の配置を読み込んで、その配置が規則を満たしているかどうかを調べ、規則に反していたらその場所を出力するプログラムを作成してください。3 つの規則に照らして誤っている (2 回以上現れている) 数字の前には * (半角アスタリスク)を、誤っていない数字の前には空白を表示してください。
Input
複数のデータセットが与えられます。最初の行にデータセットの数
n
(
n
≤ 20) が与えられます。各データセットとして、パズルの状態を示す 1 行 9 文字、9 行からなる数字列が与えられます。
Output
各データセットについて以下を出力してください。
与えられた数字と * (半角アスタリスク)と空白。誤っている数字の前には *、誤っていない数字の前には半角空白を付加する。
データセットの間に 1 行の空行を入れてください。
Sample Input
2
2 1 3 4 5 6 7 8 9
4 5 6 7 8 9 1 2 3
7 8 9 1 2 3 4 5 6
2 3 4 5 6 7 8 9 1
5 6 7 8 9 1 2 3 4
8 9 1 2 3 4 5 6 7
3 4 5 6 7 8 9 1 2
6 7 8 9 1 2 3 4 5
9 1 2 3 4 5 6 7 8
2 1 3 4 5 6 7 8 9
4 5 6 7 8 9 1 2 3
7 8 9 1 2 3 4 5 6
2 3 4 5 6 7 8 9 1
5 6 7 8 9 1 2 3 4
8 9 1 2 3 4 5 6 7
3 4 5 6 7 8 9 1 2
6 7 8 9 1 2 3 4 5
9 1 2 3 4 5 6 7 8
Output for the Sample Input
*2*1 3 4 5 6 7 8 9
 4 5 6 7 8 9 1 2 3
 7 8 9 1 2 3 4 5 6
*2 3 4 5 6 7 8 9 1
 5 6 7 8 9 1 2 3 4
 8 9 1 2 3 4 5 6 7
 3 4 5 6 7 8 9 1 2
 6 7 8 9 1 2 3 4 5
 9*1 2 3 4 5 6 7 8

*2*1 3 4 5 6 7 8 9
 4 5 6 7 8 9 1 2 3
 7 8 9 1 2 3 4 5 6
*2 3 4 5 6 7 8 9 1
 5 6 7 8 9 1 2 3 4
 8 9 1 2 3 4 5 6 7
 3 4 5 6 7 8 9 1 2
 6 7 8 9 1 2 3 4 5
 9*1 2 3 4 5 6 7 8",C,"v[81],e[81];
B(p,s0,s1){
	int f[10]={0},i,j;
	for(i=0;i<3;i++){
		for(j=0;j<3;j++){
			if(f[v[p]])
				e[~f[v[p]]]=e[p]=1;
			else
				f[v[p]]=~p;
			p+=s0;
		}
		p+=s1-3*s0;
	}
}
main(i,f){
	scanf(""%*d\n"");
	for(f=i=0;~scanf(""%d"",v+i);){
		if(++i==81){
			memset(e,0,sizeof(e));
			for(i=0;i<9;i++){
				B(0+i*9,1+0*9,3+0*9);
				B(i+0*9,0+1*9,0+3*9);
				B(i%3*3+i/3*3*9,1+0*9,0+1*9);
			}
			if(f++)
				puts("""");
			for(i=0;i<81;i++){
				printf(""%c%d"",e[i]?'*':' ',v[i]);
				if(i%9==8)
					puts("""");
			}
			i=0;
		}
	}
}",1
p00126,"パズル
たろう君は 9 × 9 のマス目に 1〜9 の数字を配置するパズルで遊んでいます。このパズルでは以下の規則で数字を配置しなければいけません。
同じ列に 1 つの数字はちょうど 1 回だけ現われる
同じ行に 1 つの数字はちょうど 1 回だけ現われる
二重線で区切られた 3 × 3 の各範囲には、1 つの数字はちょうど 1 回だけ現われる
例えば、下の図 1 はそのような規則を満たした配置の一つです。しかしたろう君は、図 2 のようによく規則に反した配置を作ってしまいます。左端の列に「2」が 2 回現われて、「1」が 1 回も現われず、左から2 番目の列に「1」が 2 回現われて、「2」が 1 回も現われていません。
図 1
図 2
たろう君を助けるために、数字の配置を読み込んで、その配置が規則を満たしているかどうかを調べ、規則に反していたらその場所を出力するプログラムを作成してください。3 つの規則に照らして誤っている (2 回以上現れている) 数字の前には * (半角アスタリスク)を、誤っていない数字の前には空白を表示してください。
Input
複数のデータセットが与えられます。最初の行にデータセットの数
n
(
n
≤ 20) が与えられます。各データセットとして、パズルの状態を示す 1 行 9 文字、9 行からなる数字列が与えられます。
Output
各データセットについて以下を出力してください。
与えられた数字と * (半角アスタリスク)と空白。誤っている数字の前には *、誤っていない数字の前には半角空白を付加する。
データセットの間に 1 行の空行を入れてください。
Sample Input
2
2 1 3 4 5 6 7 8 9
4 5 6 7 8 9 1 2 3
7 8 9 1 2 3 4 5 6
2 3 4 5 6 7 8 9 1
5 6 7 8 9 1 2 3 4
8 9 1 2 3 4 5 6 7
3 4 5 6 7 8 9 1 2
6 7 8 9 1 2 3 4 5
9 1 2 3 4 5 6 7 8
2 1 3 4 5 6 7 8 9
4 5 6 7 8 9 1 2 3
7 8 9 1 2 3 4 5 6
2 3 4 5 6 7 8 9 1
5 6 7 8 9 1 2 3 4
8 9 1 2 3 4 5 6 7
3 4 5 6 7 8 9 1 2
6 7 8 9 1 2 3 4 5
9 1 2 3 4 5 6 7 8
Output for the Sample Input
*2*1 3 4 5 6 7 8 9
 4 5 6 7 8 9 1 2 3
 7 8 9 1 2 3 4 5 6
*2 3 4 5 6 7 8 9 1
 5 6 7 8 9 1 2 3 4
 8 9 1 2 3 4 5 6 7
 3 4 5 6 7 8 9 1 2
 6 7 8 9 1 2 3 4 5
 9*1 2 3 4 5 6 7 8

*2*1 3 4 5 6 7 8 9
 4 5 6 7 8 9 1 2 3
 7 8 9 1 2 3 4 5 6
*2 3 4 5 6 7 8 9 1
 5 6 7 8 9 1 2 3 4
 8 9 1 2 3 4 5 6 7
 3 4 5 6 7 8 9 1 2
 6 7 8 9 1 2 3 4 5
 9*1 2 3 4 5 6 7 8",Java,"import java.util.*;

public class Main {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int n = sc.nextInt();
        sc.nextLine();
        
        for (int t = 0; t < n; t++) {
            if (t > 0) {
                System.out.println();
            }
            
            int[][] grid = new int[9][9];
            for (int i = 0; i < 9; i++) {
                String line = sc.nextLine();
                String[] tokens = line.trim().split(""\\s+"");
                for (int j = 0; j < 9; j++) {
                    grid[i][j] = Integer.parseInt(tokens[j]);
                }
            }
            
            boolean[][] error = new boolean[9][9];
            
            // Check rows
            for (int i = 0; i < 9; i++) {
                int[] count = new int[10];
                for (int j = 0; j < 9; j++) {
                    count[grid[i][j]]++;
                }
                for (int j = 0; j < 9; j++) {
                    if (count[grid[i][j]] > 1) {
                        error[i][j] = true;
                    }
                }
            }
            
            // Check columns
            for (int j = 0; j < 9; j++) {
                int[] count = new int[10];
                for (int i = 0; i < 9; i++) {
                    count[grid[i][j]]++;
                }
                for (int i = 0; i < 9; i++) {
                    if (count[grid[i][j]] > 1) {
                        error[i][j] = true;
                    }
                }
            }
            
            // Check 3x3 blocks
            for (int blockRow = 0; blockRow < 3; blockRow++) {
                for (int blockCol = 0; blockCol < 3; blockCol++) {
                    int[] count = new int[10];
                    for (int i = blockRow * 3; i < blockRow * 3 + 3; i++) {
                        for (int j = blockCol * 3; j < blockCol * 3 + 3; j++) {
                            count[grid[i][j]]++;
                        }
                    }
                    for (int i = blockRow * 3; i < blockRow * 3 + 3; i++) {
                        for (int j = blockCol * 3; j < blockCol * 3 + 3; j++) {
                            if (count[grid[i][j]] > 1) {
                                error[i][j] = true;
                            }
                        }
                    }
                }
            }
            
            // Output
            for (int i = 0; i < 9; i++) {
                for (int j = 0; j < 9; j++) {
                    if (error[i][j]) {
                        System.out.print(""*"");
                    } else {
                        System.out.print("" "");
                    }
                    System.out.print(grid[i][j]);
                }
                System.out.println();
            }
        }
        
        sc.close();
    }
}
",0
p00126,"パズル
たろう君は 9 × 9 のマス目に 1〜9 の数字を配置するパズルで遊んでいます。このパズルでは以下の規則で数字を配置しなければいけません。
同じ列に 1 つの数字はちょうど 1 回だけ現われる
同じ行に 1 つの数字はちょうど 1 回だけ現われる
二重線で区切られた 3 × 3 の各範囲には、1 つの数字はちょうど 1 回だけ現われる
例えば、下の図 1 はそのような規則を満たした配置の一つです。しかしたろう君は、図 2 のようによく規則に反した配置を作ってしまいます。左端の列に「2」が 2 回現われて、「1」が 1 回も現われず、左から2 番目の列に「1」が 2 回現われて、「2」が 1 回も現われていません。
図 1
図 2
たろう君を助けるために、数字の配置を読み込んで、その配置が規則を満たしているかどうかを調べ、規則に反していたらその場所を出力するプログラムを作成してください。3 つの規則に照らして誤っている (2 回以上現れている) 数字の前には * (半角アスタリスク)を、誤っていない数字の前には空白を表示してください。
Input
複数のデータセットが与えられます。最初の行にデータセットの数
n
(
n
≤ 20) が与えられます。各データセットとして、パズルの状態を示す 1 行 9 文字、9 行からなる数字列が与えられます。
Output
各データセットについて以下を出力してください。
与えられた数字と * (半角アスタリスク)と空白。誤っている数字の前には *、誤っていない数字の前には半角空白を付加する。
データセットの間に 1 行の空行を入れてください。
Sample Input
2
2 1 3 4 5 6 7 8 9
4 5 6 7 8 9 1 2 3
7 8 9 1 2 3 4 5 6
2 3 4 5 6 7 8 9 1
5 6 7 8 9 1 2 3 4
8 9 1 2 3 4 5 6 7
3 4 5 6 7 8 9 1 2
6 7 8 9 1 2 3 4 5
9 1 2 3 4 5 6 7 8
2 1 3 4 5 6 7 8 9
4 5 6 7 8 9 1 2 3
7 8 9 1 2 3 4 5 6
2 3 4 5 6 7 8 9 1
5 6 7 8 9 1 2 3 4
8 9 1 2 3 4 5 6 7
3 4 5 6 7 8 9 1 2
6 7 8 9 1 2 3 4 5
9 1 2 3 4 5 6 7 8
Output for the Sample Input
*2*1 3 4 5 6 7 8 9
 4 5 6 7 8 9 1 2 3
 7 8 9 1 2 3 4 5 6
*2 3 4 5 6 7 8 9 1
 5 6 7 8 9 1 2 3 4
 8 9 1 2 3 4 5 6 7
 3 4 5 6 7 8 9 1 2
 6 7 8 9 1 2 3 4 5
 9*1 2 3 4 5 6 7 8

*2*1 3 4 5 6 7 8 9
 4 5 6 7 8 9 1 2 3
 7 8 9 1 2 3 4 5 6
*2 3 4 5 6 7 8 9 1
 5 6 7 8 9 1 2 3 4
 8 9 1 2 3 4 5 6 7
 3 4 5 6 7 8 9 1 2
 6 7 8 9 1 2 3 4 5
 9*1 2 3 4 5 6 7 8",Java,"import java.io.IOException;
import java.io.BufferedReader;
import java.io.InputStreamReader;

class Main {
    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        int n = Integer.parseInt(br.readLine());
        for (int i = 0; i < n; i++) {
            int[][] map = new int[9][9];
            boolean[][] ok = new boolean[9][9];
            for (int j = 0; j < 9; j++) {
                String[] input = br.readLine().split("" "");
                for (int k = 0; k < 9; k++) {
                    map[j][k] = Integer.parseInt(input[k]);
                }
            }

            // horizontal check
            for (int j = 0; j < 9; j++) {
                boolean[] oneToNine = new boolean[10]; // index0は使わない
                for (int k = 0; k < 9; k++) {
                    if (!oneToNine[map[j][k]]) {
                        oneToNine[map[j][k]] = true;
                    } else {
                        ok[j][k] = true;
                        for (int l = 0; l < k; l++) {
                            if (map[j][l] == map[j][k]) {
                                ok[j][l] = true;
                                break;
                            }
                        }
                    }
                }
            }

            // vertical check
            for (int j = 0; j < 9; j++) {
                boolean[] oneToNine = new boolean[10];
                for (int k = 0; k < 9; k++) {
                    if (!oneToNine[map[k][j]]) {
                        oneToNine[map[k][j]] = true;
                    } else {
                        ok[k][j] = true;
                        for (int l = 0; l < k; l++) {
                            if (map[l][j] == map[k][j]) {
                                ok[l][j] = true;
                                break;
                            }
                        }
                    }
                }
            }

            // display
            for (int j = 0; j < 9; j++) {
                for (int k = 0; k < 9; k++) {
                    if (ok[j][k])
                        System.out.print(""*"");
                    else
                        System.out.print("" "");

                    System.out.print(map[j][k]);
                }
                System.out.println();
            }

        }
    }
}
",1
p00126,"パズル
たろう君は 9 × 9 のマス目に 1〜9 の数字を配置するパズルで遊んでいます。このパズルでは以下の規則で数字を配置しなければいけません。
同じ列に 1 つの数字はちょうど 1 回だけ現われる
同じ行に 1 つの数字はちょうど 1 回だけ現われる
二重線で区切られた 3 × 3 の各範囲には、1 つの数字はちょうど 1 回だけ現われる
例えば、下の図 1 はそのような規則を満たした配置の一つです。しかしたろう君は、図 2 のようによく規則に反した配置を作ってしまいます。左端の列に「2」が 2 回現われて、「1」が 1 回も現われず、左から2 番目の列に「1」が 2 回現われて、「2」が 1 回も現われていません。
図 1
図 2
たろう君を助けるために、数字の配置を読み込んで、その配置が規則を満たしているかどうかを調べ、規則に反していたらその場所を出力するプログラムを作成してください。3 つの規則に照らして誤っている (2 回以上現れている) 数字の前には * (半角アスタリスク)を、誤っていない数字の前には空白を表示してください。
Input
複数のデータセットが与えられます。最初の行にデータセットの数
n
(
n
≤ 20) が与えられます。各データセットとして、パズルの状態を示す 1 行 9 文字、9 行からなる数字列が与えられます。
Output
各データセットについて以下を出力してください。
与えられた数字と * (半角アスタリスク)と空白。誤っている数字の前には *、誤っていない数字の前には半角空白を付加する。
データセットの間に 1 行の空行を入れてください。
Sample Input
2
2 1 3 4 5 6 7 8 9
4 5 6 7 8 9 1 2 3
7 8 9 1 2 3 4 5 6
2 3 4 5 6 7 8 9 1
5 6 7 8 9 1 2 3 4
8 9 1 2 3 4 5 6 7
3 4 5 6 7 8 9 1 2
6 7 8 9 1 2 3 4 5
9 1 2 3 4 5 6 7 8
2 1 3 4 5 6 7 8 9
4 5 6 7 8 9 1 2 3
7 8 9 1 2 3 4 5 6
2 3 4 5 6 7 8 9 1
5 6 7 8 9 1 2 3 4
8 9 1 2 3 4 5 6 7
3 4 5 6 7 8 9 1 2
6 7 8 9 1 2 3 4 5
9 1 2 3 4 5 6 7 8
Output for the Sample Input
*2*1 3 4 5 6 7 8 9
 4 5 6 7 8 9 1 2 3
 7 8 9 1 2 3 4 5 6
*2 3 4 5 6 7 8 9 1
 5 6 7 8 9 1 2 3 4
 8 9 1 2 3 4 5 6 7
 3 4 5 6 7 8 9 1 2
 6 7 8 9 1 2 3 4 5
 9*1 2 3 4 5 6 7 8

*2*1 3 4 5 6 7 8 9
 4 5 6 7 8 9 1 2 3
 7 8 9 1 2 3 4 5 6
*2 3 4 5 6 7 8 9 1
 5 6 7 8 9 1 2 3 4
 8 9 1 2 3 4 5 6 7
 3 4 5 6 7 8 9 1 2
 6 7 8 9 1 2 3 4 5
 9*1 2 3 4 5 6 7 8",Python,"def solve():
    n = int(input())
    
    for dataset_idx in range(n):
        grid = []
        for _ in range(9):
            row = list(map(int, input().split()))
            grid.append(row)
        
        # Mark errors
        errors = [[False] * 9 for _ in range(9)]
        
        # Check rows
        for i in range(9):
            counts = {}
            for j in range(9):
                val = grid[i][j]
                if val not in counts:
                    counts[val] = []
                counts[val].append(j)
            
            for val, positions in counts.items():
                if len(positions) > 1:
                    for j in positions:
                        errors[i][j] = True
        
        # Check columns
        for j in range(9):
            counts = {}
            for i in range(9):
                val = grid[i][j]
                if val not in counts:
                    counts[val] = []
                counts[val].append(i)
            
            for val, positions in counts.items():
                if len(positions) > 1:
                    for i in positions:
                        errors[i][j] = True
        
        # Check 3x3 blocks
        for block_row in range(3):
            for block_col in range(3):
                counts = {}
                for i in range(block_row * 3, block_row * 3 + 3):
                    for j in range(block_col * 3, block_col * 3 + 3):
                        val = grid[i][j]
                        if val not in counts:
                            counts[val] = []
                        counts[val].append((i, j))
                
                for val, positions in counts.items():
                    if len(positions) > 1:
                        for i, j in positions:
                            errors[i][j] = True
        
        # Output
        for i in range(9):
            output = []
            for j in range(9):
                if errors[i][j]:
                    output.append('*' + str(grid[i][j]))
                else:
                    output.append(' ' + str(grid[i][j]))
            print(''.join(output))
        
        if dataset_idx < n - 1:
            print()

solve()
",0
p00126,"パズル
たろう君は 9 × 9 のマス目に 1〜9 の数字を配置するパズルで遊んでいます。このパズルでは以下の規則で数字を配置しなければいけません。
同じ列に 1 つの数字はちょうど 1 回だけ現われる
同じ行に 1 つの数字はちょうど 1 回だけ現われる
二重線で区切られた 3 × 3 の各範囲には、1 つの数字はちょうど 1 回だけ現われる
例えば、下の図 1 はそのような規則を満たした配置の一つです。しかしたろう君は、図 2 のようによく規則に反した配置を作ってしまいます。左端の列に「2」が 2 回現われて、「1」が 1 回も現われず、左から2 番目の列に「1」が 2 回現われて、「2」が 1 回も現われていません。
図 1
図 2
たろう君を助けるために、数字の配置を読み込んで、その配置が規則を満たしているかどうかを調べ、規則に反していたらその場所を出力するプログラムを作成してください。3 つの規則に照らして誤っている (2 回以上現れている) 数字の前には * (半角アスタリスク)を、誤っていない数字の前には空白を表示してください。
Input
複数のデータセットが与えられます。最初の行にデータセットの数
n
(
n
≤ 20) が与えられます。各データセットとして、パズルの状態を示す 1 行 9 文字、9 行からなる数字列が与えられます。
Output
各データセットについて以下を出力してください。
与えられた数字と * (半角アスタリスク)と空白。誤っている数字の前には *、誤っていない数字の前には半角空白を付加する。
データセットの間に 1 行の空行を入れてください。
Sample Input
2
2 1 3 4 5 6 7 8 9
4 5 6 7 8 9 1 2 3
7 8 9 1 2 3 4 5 6
2 3 4 5 6 7 8 9 1
5 6 7 8 9 1 2 3 4
8 9 1 2 3 4 5 6 7
3 4 5 6 7 8 9 1 2
6 7 8 9 1 2 3 4 5
9 1 2 3 4 5 6 7 8
2 1 3 4 5 6 7 8 9
4 5 6 7 8 9 1 2 3
7 8 9 1 2 3 4 5 6
2 3 4 5 6 7 8 9 1
5 6 7 8 9 1 2 3 4
8 9 1 2 3 4 5 6 7
3 4 5 6 7 8 9 1 2
6 7 8 9 1 2 3 4 5
9 1 2 3 4 5 6 7 8
Output for the Sample Input
*2*1 3 4 5 6 7 8 9
 4 5 6 7 8 9 1 2 3
 7 8 9 1 2 3 4 5 6
*2 3 4 5 6 7 8 9 1
 5 6 7 8 9 1 2 3 4
 8 9 1 2 3 4 5 6 7
 3 4 5 6 7 8 9 1 2
 6 7 8 9 1 2 3 4 5
 9*1 2 3 4 5 6 7 8

*2*1 3 4 5 6 7 8 9
 4 5 6 7 8 9 1 2 3
 7 8 9 1 2 3 4 5 6
*2 3 4 5 6 7 8 9 1
 5 6 7 8 9 1 2 3 4
 8 9 1 2 3 4 5 6 7
 3 4 5 6 7 8 9 1 2
 6 7 8 9 1 2 3 4 5
 9*1 2 3 4 5 6 7 8",Python,"R=range(9)
def f1(M):
  global F
  for y in R:
    A=M[y]
    if len(set(A))==9: continue
    for x in R:
      if A.count(A[x])>=2: F[y][x]=""*""
  return
def f2(M):
  global F
  for x in R:
    A=[M[y][x] for y in R]
    if len(set(A))==9: continue
    for y in R:
      if A.count(A[y])>=2: F[y][x]=""*""
  return
def f3(M):
  global F
  for i in R:
    x=i%3*3
    y=i/3*3
    A=M[y][x:x+3]+M[y+1][x:x+3]+M[y+2][x:x+3]
    if len(set(A))==9: continue
    for j in R:
      if A.count(A[j])>=2: F[y+j/3][x+j%3]=""*""
  return

n=input()
while n:
  M=[]
  F=[["" "" for _ in [0]*9] for _ in [0]*9]
  M=[map(int,raw_input().split()) for _ in [0]*9]
  f1(M)
  f2(M)
  f3(M)
  for i in R:
    s=zip(F[i],map(str,M[i]))
    print """".join([a+b for a,b in s])
  if n>1: print
  n-=1",1
p00129,"かくれんぼう
たろう君はかくれんぼうが苦手です。隠れるとすぐ見つかっちゃうし、隠れている子をなかなか見つけることができません。見かねたお父さんは、超高性能位置探索システムを作ってくれました。これを使うと自分の位置を含めて、友達の位置を正確に知ることができます。鬼になったら、隠れている子を探すことが簡単にできるようになりました。
たろう君はさらにこのシステムを進化させ、鬼から自分が見えるか否かを判定する機能を付加することを思いつきました。これができれば、「もういいかい」と言われても、見える位置にいれば「まあだだよ」だし、見えない位置にいれば「もういいよ」ですね。いつも遊んでいる公園には大小さまざまな円筒形の壁があります。この壁は外からは中は見えないし、中から外も見えません。鬼と一緒に中に入ると別の壁がなければ見えちゃいます。
たろう君はアイデアはいいのですが、ソフトを作るのが苦手です。そこで親友のあなたはたろう君に代わって、「鬼から見えないこと確認システム」のソフトウェアを作ることになりました。公園の壁は固定されていますが、たろう君と鬼のいろいろな位置情報に対して見えるか否かを判定する必要があります。
公園にある壁の情報(中心の座標 (
wx
,
wy
) と 半径
r
) とたろう君と鬼の位置情報(たろう君の位置の座標 (
tx
,
ty
) と鬼の位置の座標 (
sx
,
sy
) ) を入力とし、その位置で鬼からたろう君が見えるか否かを判定するプログラムを作成してください。
なお、鬼からたろう君が見える場合には Danger、見えない場合には Safe と出力してください。鬼とたろう君の位置を結んだ線分上に壁がある場合には見えないものとし、鬼もたろう君も壁の上にはいないものとします。
Input
複数のデータセットが与えられます。各データセットは以下の形式で与えられます。
n
wx
1
wy
1
r
1
wx
2
wy
2
r
2
:
wx
n
wy
n
r
n
m
tx
1
ty
1
sx
1
sy
1
tx
2
ty
2
sx
2
sy
2
:
tx
m
ty
m
sx
m
sy
m
1 行目に円筒形の壁の数
n
(0 ≤
n
≤ 100)、続く
n
行に壁
i
の中心の座標を表す整数
wx
i
,
wy
i
(0 ≤
wx
i
,
wy
i
≤ 255) と半径を表す整数
r
i
(1 ≤
r
i
≤ 255) が与えられます。
続く行にたろう君と鬼の位置情報の個数
m
(m ≤ 100)、続く
m
行に位置情報
i
のたろう君の位置の座標を表す整数
tx
i
,
ty
i
(0 ≤
tx
i
,
ty
i
≤ 255) と鬼の位置の座標を表す整数
sx
i
,
sy
i
(0 ≤
sx
i
,
sy
i
≤ 255)  が与えられます。
また、円筒形の壁の一部だけが公園にあるということはなく、全ての壁は円筒として、公園の内部に入っています。
n
が 0 のとき入力の終わりを示します。データセットの数は 20 を超えません。
Output
各データセットについて、位置情報
i
の判定結果 Danger または Safe を
i
行目に出力してください。
Sample Input
3
6 6 3
19 7 4
21 8 1
6
5 4 2 11
12 4 2 11
11 9 2 11
14 3 20 5
17 9 20 5
20 10 20 5
0
Output for the Sample Input
Safe
Safe
Danger
Safe
Danger
Safe",C,"#include <stdio.h>
#include <math.h>

typedef struct {
    double x, y;
} Point;

typedef struct {
    Point center;
    double radius;
} Circle;

int isInsideCircle(Point p, Circle c) {
    double dx = p.x - c.center.x;
    double dy = p.y - c.center.y;
    return (dx * dx + dy * dy) < (c.radius * c.radius);
}

int lineSegmentIntersectsCircle(Point p1, Point p2, Circle c) {
    // Check if either endpoint is inside the circle
    if (isInsideCircle(p1, c) || isInsideCircle(p2, c)) {
        return 1;
    }
    
    // Vector from p1 to p2
    double dx = p2.x - p1.x;
    double dy = p2.y - p1.y;
    
    // Vector from p1 to circle center
    double fx = c.center.x - p1.x;
    double fy = c.center.y - p1.y;
    
    // Project circle center onto line segment
    double len_sq = dx * dx + dy * dy;
    double t = (fx * dx + fy * dy) / len_sq;
    
    // Clamp t to [0, 1] to stay on segment
    if (t < 0) t = 0;
    if (t > 1) t = 1;
    
    // Find closest point on segment
    double closest_x = p1.x + t * dx;
    double closest_y = p1.y + t * dy;
    
    // Check distance from closest point to circle center
    double dist_x = c.center.x - closest_x;
    double dist_y = c.center.y - closest_y;
    double dist_sq = dist_x * dist_x + dist_y * dist_y;
    
    return dist_sq < (c.radius * c.radius);
}

int isBlocked(Point taro, Point oni, Circle walls[], int n) {
    // Check if Taro and Oni are both inside the same circle
    for (int i = 0; i < n; i++) {
        if (isInsideCircle(taro, walls[i]) && isInsideCircle(oni, walls[i])) {
            // Both inside same wall, check if blocked by another wall
            int blocked = 0;
            for (int j = 0; j < n; j++) {
                if (i != j && lineSegmentIntersectsCircle(taro, oni, walls[j])) {
                    blocked = 1;
                    break;
                }
            }
            if (!blocked) {
                return 0; // They can see each other
            }
        }
    }
    
    // Check if line segment intersects any wall
    for (int i = 0; i < n; i++) {
        int taroInside = isInsideCircle(taro, walls[i]);
        int oniInside = isInsideCircle(oni, walls[i]);
        
        // If one is inside and one is outside, blocked
        if (taroInside != oniInside) {
            return 1;
        }
        
        // If both outside, check if line intersects wall
        if (!taroInside && !oniInside) {
            if (lineSegmentIntersectsCircle(taro, oni, walls[i])) {
                return 1;
            }
        }
    }
    
    return 0;
}

int main() {
    int n;
    while (scanf(""%d"", &n) == 1 && n != 0) {
        Circle walls[100];
        for (int i = 0; i < n; i++) {
            scanf(""%lf %lf %lf"", &walls[i].center.x, &walls[i].center.y, &walls[i].radius);
        }
        
        int m;
        scanf(""%d"", &m);
        
        for (int i = 0; i < m; i++) {
            Point taro, oni;
            scanf(""%lf %lf %lf %lf"", &taro.x, &taro.y, &oni.x, &oni.y);
            
            if (isBlocked(taro, oni, walls, n)) {
                printf(""Safe\n"");
            } else {
                printf(""Danger\n"");
            }
        }
    }
    
    return 0;
}
",0
p00129,"かくれんぼう
たろう君はかくれんぼうが苦手です。隠れるとすぐ見つかっちゃうし、隠れている子をなかなか見つけることができません。見かねたお父さんは、超高性能位置探索システムを作ってくれました。これを使うと自分の位置を含めて、友達の位置を正確に知ることができます。鬼になったら、隠れている子を探すことが簡単にできるようになりました。
たろう君はさらにこのシステムを進化させ、鬼から自分が見えるか否かを判定する機能を付加することを思いつきました。これができれば、「もういいかい」と言われても、見える位置にいれば「まあだだよ」だし、見えない位置にいれば「もういいよ」ですね。いつも遊んでいる公園には大小さまざまな円筒形の壁があります。この壁は外からは中は見えないし、中から外も見えません。鬼と一緒に中に入ると別の壁がなければ見えちゃいます。
たろう君はアイデアはいいのですが、ソフトを作るのが苦手です。そこで親友のあなたはたろう君に代わって、「鬼から見えないこと確認システム」のソフトウェアを作ることになりました。公園の壁は固定されていますが、たろう君と鬼のいろいろな位置情報に対して見えるか否かを判定する必要があります。
公園にある壁の情報(中心の座標 (
wx
,
wy
) と 半径
r
) とたろう君と鬼の位置情報(たろう君の位置の座標 (
tx
,
ty
) と鬼の位置の座標 (
sx
,
sy
) ) を入力とし、その位置で鬼からたろう君が見えるか否かを判定するプログラムを作成してください。
なお、鬼からたろう君が見える場合には Danger、見えない場合には Safe と出力してください。鬼とたろう君の位置を結んだ線分上に壁がある場合には見えないものとし、鬼もたろう君も壁の上にはいないものとします。
Input
複数のデータセットが与えられます。各データセットは以下の形式で与えられます。
n
wx
1
wy
1
r
1
wx
2
wy
2
r
2
:
wx
n
wy
n
r
n
m
tx
1
ty
1
sx
1
sy
1
tx
2
ty
2
sx
2
sy
2
:
tx
m
ty
m
sx
m
sy
m
1 行目に円筒形の壁の数
n
(0 ≤
n
≤ 100)、続く
n
行に壁
i
の中心の座標を表す整数
wx
i
,
wy
i
(0 ≤
wx
i
,
wy
i
≤ 255) と半径を表す整数
r
i
(1 ≤
r
i
≤ 255) が与えられます。
続く行にたろう君と鬼の位置情報の個数
m
(m ≤ 100)、続く
m
行に位置情報
i
のたろう君の位置の座標を表す整数
tx
i
,
ty
i
(0 ≤
tx
i
,
ty
i
≤ 255) と鬼の位置の座標を表す整数
sx
i
,
sy
i
(0 ≤
sx
i
,
sy
i
≤ 255)  が与えられます。
また、円筒形の壁の一部だけが公園にあるということはなく、全ての壁は円筒として、公園の内部に入っています。
n
が 0 のとき入力の終わりを示します。データセットの数は 20 を超えません。
Output
各データセットについて、位置情報
i
の判定結果 Danger または Safe を
i
行目に出力してください。
Sample Input
3
6 6 3
19 7 4
21 8 1
6
5 4 2 11
12 4 2 11
11 9 2 11
14 3 20 5
17 9 20 5
20 10 20 5
0
Output for the Sample Input
Safe
Safe
Danger
Safe
Danger
Safe",C,"#include <stdio.h>
#include <math.h>

#define EPS (1e-7)

typedef struct {
	int x,y,r;
} wall_t;

typedef struct {
	int tx,ty,sx,sy;
} query_t;

int hitcheck_circle(wall_t w,query_t q) {
	int in=0;
	int a,b,c;
	int minx,miny,maxx,maxy,temp;
	/* sieve */
	minx=q.tx;maxx=q.sx;
	if(minx>maxx){temp=minx;minx=maxx;maxx=temp;}
	miny=q.ty;maxy=q.sy;
	if(miny>maxy){temp=miny;miny=maxy;maxy=temp;}
	if(w.x+w.r<minx || maxx<w.x-w.r)return 0;
	if(w.y+w.r<miny || maxy<w.y-w.r)return 0;
	/* check if dist<=r */
	if((q.tx-w.x)*(q.tx-w.x)+(q.ty-w.y)*(q.ty-w.y)<=w.r*w.r)in++;
	if((q.sx-w.x)*(q.sx-w.x)+(q.sy-w.y)*(q.sy-w.y)<=w.r*w.r)in++;
	if(in==1)return 1;
	if(in==2)return 0;
	a=q.ty-q.sy;
	b=q.sx-q.tx;
	c=(q.tx-q.sx)*q.ty-(q.ty-q.sy)*q.tx;
	if((a*w.x+b*w.y+c)*(a*w.x+b*w.y+c)<=w.r*w.r*(a*a+b*b)) {
		/* check if really hit */
		c=-c; /* convert a*x+b*y+c=0 to a*x+b*y=c */
		if(b==0) {
			double yy=w.r*w.r-((double)c/a-w.x)*((double)c/a-w.x);
			double y1,y2;
			y1=sqrt(yy);y2=-y1;
			y1+=w.y;y2+=w.y;
			return (miny<y1+EPS && y1<maxy+EPS) || (miny<y2+EPS && y2<maxy+EPS);
		} else {
			double cb=(double)c/b;
			double ab=(double)a/b;
			double x2k,xk,tk;
			double x1,x2;
			x2k=1.0+ab*ab;
			xk=-2*w.x+2.0*(w.y-cb)*ab;
			tk=w.x*w.x+(w.y-cb)*(w.y-cb)-w.r*w.r;
			x1=(-xk+sqrt(xk*xk-4.0*x2k*tk))/(2.0*x2k);
			x2=(-xk-sqrt(xk*xk-4.0*x2k*tk))/(2.0*x2k);
			return (minx<x1+EPS && x1<maxx+EPS) || (minx<x2+EPS && x2<maxx+EPS);
		}
	}
	return 0;
}
int main(void) {
	int n;
	wall_t w[100];
	int m;
	int i;
	while(scanf(""%d"",&n)==1 && n>0) {
		for(i=0;i<n;i++)scanf(""%d%d%d"",&w[i].x,&w[i].y,&w[i].r);
		scanf(""%d"",&m);
		for(i=0;i<m;i++) {
			query_t q;
			int j;
			int hidden;
			scanf(""%d%d%d%d"",&q.tx,&q.ty,&q.sx,&q.sy);
			hidden=0;
			if(q.tx!=q.sx || q.ty!=q.sy) {
				for(j=0;j<n;j++) {
					if(hitcheck_circle(w[j],q)) {
						hidden=1;
						break;
					}
				}
			}
			puts(hidden?""Safe"":""Danger"");
		}
	}
	return 0;
}",1
p00129,"かくれんぼう
たろう君はかくれんぼうが苦手です。隠れるとすぐ見つかっちゃうし、隠れている子をなかなか見つけることができません。見かねたお父さんは、超高性能位置探索システムを作ってくれました。これを使うと自分の位置を含めて、友達の位置を正確に知ることができます。鬼になったら、隠れている子を探すことが簡単にできるようになりました。
たろう君はさらにこのシステムを進化させ、鬼から自分が見えるか否かを判定する機能を付加することを思いつきました。これができれば、「もういいかい」と言われても、見える位置にいれば「まあだだよ」だし、見えない位置にいれば「もういいよ」ですね。いつも遊んでいる公園には大小さまざまな円筒形の壁があります。この壁は外からは中は見えないし、中から外も見えません。鬼と一緒に中に入ると別の壁がなければ見えちゃいます。
たろう君はアイデアはいいのですが、ソフトを作るのが苦手です。そこで親友のあなたはたろう君に代わって、「鬼から見えないこと確認システム」のソフトウェアを作ることになりました。公園の壁は固定されていますが、たろう君と鬼のいろいろな位置情報に対して見えるか否かを判定する必要があります。
公園にある壁の情報(中心の座標 (
wx
,
wy
) と 半径
r
) とたろう君と鬼の位置情報(たろう君の位置の座標 (
tx
,
ty
) と鬼の位置の座標 (
sx
,
sy
) ) を入力とし、その位置で鬼からたろう君が見えるか否かを判定するプログラムを作成してください。
なお、鬼からたろう君が見える場合には Danger、見えない場合には Safe と出力してください。鬼とたろう君の位置を結んだ線分上に壁がある場合には見えないものとし、鬼もたろう君も壁の上にはいないものとします。
Input
複数のデータセットが与えられます。各データセットは以下の形式で与えられます。
n
wx
1
wy
1
r
1
wx
2
wy
2
r
2
:
wx
n
wy
n
r
n
m
tx
1
ty
1
sx
1
sy
1
tx
2
ty
2
sx
2
sy
2
:
tx
m
ty
m
sx
m
sy
m
1 行目に円筒形の壁の数
n
(0 ≤
n
≤ 100)、続く
n
行に壁
i
の中心の座標を表す整数
wx
i
,
wy
i
(0 ≤
wx
i
,
wy
i
≤ 255) と半径を表す整数
r
i
(1 ≤
r
i
≤ 255) が与えられます。
続く行にたろう君と鬼の位置情報の個数
m
(m ≤ 100)、続く
m
行に位置情報
i
のたろう君の位置の座標を表す整数
tx
i
,
ty
i
(0 ≤
tx
i
,
ty
i
≤ 255) と鬼の位置の座標を表す整数
sx
i
,
sy
i
(0 ≤
sx
i
,
sy
i
≤ 255)  が与えられます。
また、円筒形の壁の一部だけが公園にあるということはなく、全ての壁は円筒として、公園の内部に入っています。
n
が 0 のとき入力の終わりを示します。データセットの数は 20 を超えません。
Output
各データセットについて、位置情報
i
の判定結果 Danger または Safe を
i
行目に出力してください。
Sample Input
3
6 6 3
19 7 4
21 8 1
6
5 4 2 11
12 4 2 11
11 9 2 11
14 3 20 5
17 9 20 5
20 10 20 5
0
Output for the Sample Input
Safe
Safe
Danger
Safe
Danger
Safe",Java,"import java.util.*;
import java.io.*;

public class Main {
    static class Circle {
        double x, y, r;
        Circle(double x, double y, double r) {
            this.x = x;
            this.y = y;
            this.r = r;
        }
    }
    
    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        String line;
        
        while ((line = br.readLine()) != null) {
            int n = Integer.parseInt(line.trim());
            if (n == 0) break;
            
            Circle[] walls = new Circle[n];
            for (int i = 0; i < n; i++) {
                String[] parts = br.readLine().trim().split(""\\s+"");
                double wx = Double.parseDouble(parts[0]);
                double wy = Double.parseDouble(parts[1]);
                double r = Double.parseDouble(parts[2]);
                walls[i] = new Circle(wx, wy, r);
            }
            
            int m = Integer.parseInt(br.readLine().trim());
            for (int i = 0; i < m; i++) {
                String[] parts = br.readLine().trim().split(""\\s+"");
                double tx = Double.parseDouble(parts[0]);
                double ty = Double.parseDouble(parts[1]);
                double sx = Double.parseDouble(parts[2]);
                double sy = Double.parseDouble(parts[3]);
                
                boolean visible = isVisible(tx, ty, sx, sy, walls);
                System.out.println(visible ? ""Danger"" : ""Safe"");
            }
        }
    }
    
    static boolean isVisible(double tx, double ty, double sx, double sy, Circle[] walls) {
        // Check if both points are inside the same wall
        for (Circle wall : walls) {
            boolean tInside = isInside(tx, ty, wall);
            boolean sInside = isInside(sx, sy, wall);
            
            if (tInside && sInside) {
                // Both inside same wall - check if line segment intersects any other wall
                boolean blocked = false;
                for (Circle other : walls) {
                    if (other == wall) continue;
                    if (lineIntersectsCircle(tx, ty, sx, sy, other)) {
                        blocked = true;
                        break;
                    }
                }
                if (!blocked) return true;
            } else if (tInside || sInside) {
                // One inside, one outside - not visible
                return false;
            }
        }
        
        // Both outside all walls - check if line segment intersects any wall
        for (Circle wall : walls) {
            if (lineIntersectsCircle(tx, ty, sx, sy, wall)) {
                return false;
            }
        }
        
        return true;
    }
    
    static boolean isInside(double px, double py, Circle circle) {
        double dx = px - circle.x;
        double dy = py - circle.y;
        return dx * dx + dy * dy < circle.r * circle.r;
    }
    
    static boolean lineIntersectsCircle(double x1, double y1, double x2, double y2, Circle circle) {
        double dx = x2 - x1;
        double dy = y2 - y1;
        double fx = x1 - circle.x;
        double fy = y1 - circle.y;
        
        double a = dx * dx + dy * dy;
        double b = 2 * (fx * dx + fy * dy);
        double c = fx * fx + fy * fy - circle.r * circle.r;
        
        double discriminant = b * b - 4 * a * c;
        
        if (discriminant < 0) {
            return false;
        }
        
        double sqrtDisc = Math.sqrt(discriminant);
        double t1 = (-b - sqrtDisc) / (2 * a);
        double t2 = (-b + sqrtDisc) / (2 * a);
        
        // Check if intersection points are within the line segment
        if ((t1 >= 0 && t1 <= 1) || (t2 >= 0 && t2 <= 1)) {
            return true;
        }
        
        // Check if the segment is completely inside the circle
        if (t1 < 0 && t2 > 1) {
            return true;
        }
        
        return false;
    }
}
",0
p00129,"かくれんぼう
たろう君はかくれんぼうが苦手です。隠れるとすぐ見つかっちゃうし、隠れている子をなかなか見つけることができません。見かねたお父さんは、超高性能位置探索システムを作ってくれました。これを使うと自分の位置を含めて、友達の位置を正確に知ることができます。鬼になったら、隠れている子を探すことが簡単にできるようになりました。
たろう君はさらにこのシステムを進化させ、鬼から自分が見えるか否かを判定する機能を付加することを思いつきました。これができれば、「もういいかい」と言われても、見える位置にいれば「まあだだよ」だし、見えない位置にいれば「もういいよ」ですね。いつも遊んでいる公園には大小さまざまな円筒形の壁があります。この壁は外からは中は見えないし、中から外も見えません。鬼と一緒に中に入ると別の壁がなければ見えちゃいます。
たろう君はアイデアはいいのですが、ソフトを作るのが苦手です。そこで親友のあなたはたろう君に代わって、「鬼から見えないこと確認システム」のソフトウェアを作ることになりました。公園の壁は固定されていますが、たろう君と鬼のいろいろな位置情報に対して見えるか否かを判定する必要があります。
公園にある壁の情報(中心の座標 (
wx
,
wy
) と 半径
r
) とたろう君と鬼の位置情報(たろう君の位置の座標 (
tx
,
ty
) と鬼の位置の座標 (
sx
,
sy
) ) を入力とし、その位置で鬼からたろう君が見えるか否かを判定するプログラムを作成してください。
なお、鬼からたろう君が見える場合には Danger、見えない場合には Safe と出力してください。鬼とたろう君の位置を結んだ線分上に壁がある場合には見えないものとし、鬼もたろう君も壁の上にはいないものとします。
Input
複数のデータセットが与えられます。各データセットは以下の形式で与えられます。
n
wx
1
wy
1
r
1
wx
2
wy
2
r
2
:
wx
n
wy
n
r
n
m
tx
1
ty
1
sx
1
sy
1
tx
2
ty
2
sx
2
sy
2
:
tx
m
ty
m
sx
m
sy
m
1 行目に円筒形の壁の数
n
(0 ≤
n
≤ 100)、続く
n
行に壁
i
の中心の座標を表す整数
wx
i
,
wy
i
(0 ≤
wx
i
,
wy
i
≤ 255) と半径を表す整数
r
i
(1 ≤
r
i
≤ 255) が与えられます。
続く行にたろう君と鬼の位置情報の個数
m
(m ≤ 100)、続く
m
行に位置情報
i
のたろう君の位置の座標を表す整数
tx
i
,
ty
i
(0 ≤
tx
i
,
ty
i
≤ 255) と鬼の位置の座標を表す整数
sx
i
,
sy
i
(0 ≤
sx
i
,
sy
i
≤ 255)  が与えられます。
また、円筒形の壁の一部だけが公園にあるということはなく、全ての壁は円筒として、公園の内部に入っています。
n
が 0 のとき入力の終わりを示します。データセットの数は 20 を超えません。
Output
各データセットについて、位置情報
i
の判定結果 Danger または Safe を
i
行目に出力してください。
Sample Input
3
6 6 3
19 7 4
21 8 1
6
5 4 2 11
12 4 2 11
11 9 2 11
14 3 20 5
17 9 20 5
20 10 20 5
0
Output for the Sample Input
Safe
Safe
Danger
Safe
Danger
Safe",Java,"import java.io.*;
import java.util.*;

public class Main{
	public static void main(String args[]){
		try{
			new Main();
		}catch(IOException e){
			e.printStackTrace();
		}
	}

	public Main() throws IOException{
		BufferedReader in = new BufferedReader(new InputStreamReader(System.in));
		List<Integer> Ans = new ArrayList<Integer>();
		String line;

		while((line = in.readLine()) != null){
			int nTube = Integer.parseInt(line);

			if(nTube==0) break;

			Tube[] tubes = new Tube[nTube];
			for(int n=0; n<nTube; n++){
				line = in.readLine();
				String[] dst = line.split("" "");
				int x = Integer.parseInt(dst[0]);
				int y = Integer.parseInt(dst[1]);
				int r = Integer.parseInt(dst[2]);
				tubes[n] = new Tube(x, y, r);
			}

			line = in.readLine();
			int nSet = Integer.parseInt(line);
			for(int n=0; n<nSet; n++){
				line = in.readLine();
				String[] dst = line.split("" "");
				double x1 = Double.parseDouble(dst[0]);
				double y1 = Double.parseDouble(dst[1]);
				double x2 = Double.parseDouble(dst[2]);
				double y2 = Double.parseDouble(dst[3]);

				int hide = 0;
				for(int m=0; m<tubes.length; m++){
					double a, b, c, d, e1, e2, x0, min, max;
					if(x1 != x2){
						double p = (y1 - y2) / (x1 - x2);
						double q = y1 - p * x1;
						a = p * p + 1.0;
						b = 2.0 * p * (q - tubes[m].y) - 2.0 * tubes[m].x;
						c = Math.pow(tubes[m].x, 2.0) + Math.pow(q - tubes[m].y, 2.0) - Math.pow(tubes[m].r, 2.0);
						d = b * b - 4.0 * a * c;
						e1 = a * x1 * x1 + b * x1 + c;
						e2 = a * x2 * x2 + b * x2 + c;
						x0 = - b / (2.0 * a);
						min = Math.min(x1, x2);
						max = Math.max(x1, x2);
					}
					else{
						a = 1.0;
						b = -2.0 * tubes[m].y;
						c = Math.pow(tubes[m].y, 2.0) + Math.pow(x1 - tubes[m].x, 2.0) - Math.pow(tubes[m].r, 2.0);
						d = b * b - 4.0 * a * c;
						e1 = a * y1 * y1 + b * y1 + c;
						e2 = a * y2 * y2 + b * y2 + c;
						x0 = - b / (2.0 * a);
						min = Math.min(y1, y2);
						max = Math.max(y1, y2);
					}

					if(x0 >= min && x0 <= max){
						if(d*e1 >= 0 || d*e2 >= 0){
							Ans.add(1);
							hide = 1;
							break;
						}
					}
					else{
						if(e1 * e2 <= 0){
							Ans.add(1);
							hide = 1;
							break;
						}
					}
				}

				if(hide == 0){
					Ans.add(-1);
				}
			}
		}

		for(int n=0; n<Ans.size(); n++){
			int i = Ans.get(n);
			if(i==1){
				System.out.println(""Safe"");
			}else{
				System.out.println(""Danger"");
			}
		}
	}
}

class Tube{
	double x;
	double y;
	double r;

	public Tube(int x, int y, int r){
		this.x = (double)x;
		this.y = (double)y;
		this.r = (double)r;
	}
}",1
p00129,"かくれんぼう
たろう君はかくれんぼうが苦手です。隠れるとすぐ見つかっちゃうし、隠れている子をなかなか見つけることができません。見かねたお父さんは、超高性能位置探索システムを作ってくれました。これを使うと自分の位置を含めて、友達の位置を正確に知ることができます。鬼になったら、隠れている子を探すことが簡単にできるようになりました。
たろう君はさらにこのシステムを進化させ、鬼から自分が見えるか否かを判定する機能を付加することを思いつきました。これができれば、「もういいかい」と言われても、見える位置にいれば「まあだだよ」だし、見えない位置にいれば「もういいよ」ですね。いつも遊んでいる公園には大小さまざまな円筒形の壁があります。この壁は外からは中は見えないし、中から外も見えません。鬼と一緒に中に入ると別の壁がなければ見えちゃいます。
たろう君はアイデアはいいのですが、ソフトを作るのが苦手です。そこで親友のあなたはたろう君に代わって、「鬼から見えないこと確認システム」のソフトウェアを作ることになりました。公園の壁は固定されていますが、たろう君と鬼のいろいろな位置情報に対して見えるか否かを判定する必要があります。
公園にある壁の情報(中心の座標 (
wx
,
wy
) と 半径
r
) とたろう君と鬼の位置情報(たろう君の位置の座標 (
tx
,
ty
) と鬼の位置の座標 (
sx
,
sy
) ) を入力とし、その位置で鬼からたろう君が見えるか否かを判定するプログラムを作成してください。
なお、鬼からたろう君が見える場合には Danger、見えない場合には Safe と出力してください。鬼とたろう君の位置を結んだ線分上に壁がある場合には見えないものとし、鬼もたろう君も壁の上にはいないものとします。
Input
複数のデータセットが与えられます。各データセットは以下の形式で与えられます。
n
wx
1
wy
1
r
1
wx
2
wy
2
r
2
:
wx
n
wy
n
r
n
m
tx
1
ty
1
sx
1
sy
1
tx
2
ty
2
sx
2
sy
2
:
tx
m
ty
m
sx
m
sy
m
1 行目に円筒形の壁の数
n
(0 ≤
n
≤ 100)、続く
n
行に壁
i
の中心の座標を表す整数
wx
i
,
wy
i
(0 ≤
wx
i
,
wy
i
≤ 255) と半径を表す整数
r
i
(1 ≤
r
i
≤ 255) が与えられます。
続く行にたろう君と鬼の位置情報の個数
m
(m ≤ 100)、続く
m
行に位置情報
i
のたろう君の位置の座標を表す整数
tx
i
,
ty
i
(0 ≤
tx
i
,
ty
i
≤ 255) と鬼の位置の座標を表す整数
sx
i
,
sy
i
(0 ≤
sx
i
,
sy
i
≤ 255)  が与えられます。
また、円筒形の壁の一部だけが公園にあるということはなく、全ての壁は円筒として、公園の内部に入っています。
n
が 0 のとき入力の終わりを示します。データセットの数は 20 を超えません。
Output
各データセットについて、位置情報
i
の判定結果 Danger または Safe を
i
行目に出力してください。
Sample Input
3
6 6 3
19 7 4
21 8 1
6
5 4 2 11
12 4 2 11
11 9 2 11
14 3 20 5
17 9 20 5
20 10 20 5
0
Output for the Sample Input
Safe
Safe
Danger
Safe
Danger
Safe",Python,"import math

def point_in_circle(px, py, cx, cy, r):
    dist_sq = (px - cx) ** 2 + (py - cy) ** 2
    return dist_sq < r ** 2

def line_segment_intersects_circle(x1, y1, x2, y2, cx, cy, r):
    # Check if either endpoint is inside the circle
    if point_in_circle(x1, y1, cx, cy, r) or point_in_circle(x2, y2, cx, cy, r):
        return True
    
    # Vector from point 1 to point 2
    dx = x2 - x1
    dy = y2 - y1
    
    # Vector from point 1 to circle center
    fx = x1 - cx
    fy = y1 - cy
    
    # Quadratic equation coefficients for line-circle intersection
    a = dx * dx + dy * dy
    b = 2 * (fx * dx + fy * dy)
    c = fx * fx + fy * fy - r * r
    
    discriminant = b * b - 4 * a * c
    
    if discriminant < 0:
        return False
    
    # Check if intersection points are within the line segment
    sqrt_discriminant = math.sqrt(discriminant)
    t1 = (-b - sqrt_discriminant) / (2 * a)
    t2 = (-b + sqrt_discriminant) / (2 * a)
    
    # Check if any t is in [0, 1]
    if (0 <= t1 <= 1) or (0 <= t2 <= 1):
        return True
    
    return False

def is_visible(tx, ty, sx, sy, walls):
    # Check if both Taro and Oni are inside the same wall
    taro_walls = []
    oni_walls = []
    
    for wx, wy, r in walls:
        if point_in_circle(tx, ty, wx, wy, r):
            taro_walls.append((wx, wy, r))
        if point_in_circle(sx, sy, wx, wy, r):
            oni_walls.append((wx, wy, r))
    
    # If they are both inside the same wall
    for tw in taro_walls:
        if tw in oni_walls:
            # They are in the same wall, check if any other wall blocks
            for wx, wy, r in walls:
                if (wx, wy, r) != tw:
                    if line_segment_intersects_circle(tx, ty, sx, sy, wx, wy, r):
                        return False
            return True
    
    # If one is inside a wall and the other is not, they can't see each other
    if len(taro_walls) > 0 or len(oni_walls) > 0:
        return False
    
    # Both are outside all walls, check if any wall blocks the line of sight
    for wx, wy, r in walls:
        if line_segment_intersects_circle(tx, ty, sx, sy, wx, wy, r):
            return False
    
    return True

while True:
    n = int(input())
    if n == 0:
        break
    
    walls = []
    for _ in range(n):
        wx, wy, r = map(int, input().split())
        walls.append((wx, wy, r))
    
    m = int(input())
    for _ in range(m):
        tx, ty, sx, sy = map(int, input().split())
        if is_visible(tx, ty, sx, sy, walls):
            print(""Danger"")
        else:
            print(""Safe"")
",0
p00129,"かくれんぼう
たろう君はかくれんぼうが苦手です。隠れるとすぐ見つかっちゃうし、隠れている子をなかなか見つけることができません。見かねたお父さんは、超高性能位置探索システムを作ってくれました。これを使うと自分の位置を含めて、友達の位置を正確に知ることができます。鬼になったら、隠れている子を探すことが簡単にできるようになりました。
たろう君はさらにこのシステムを進化させ、鬼から自分が見えるか否かを判定する機能を付加することを思いつきました。これができれば、「もういいかい」と言われても、見える位置にいれば「まあだだよ」だし、見えない位置にいれば「もういいよ」ですね。いつも遊んでいる公園には大小さまざまな円筒形の壁があります。この壁は外からは中は見えないし、中から外も見えません。鬼と一緒に中に入ると別の壁がなければ見えちゃいます。
たろう君はアイデアはいいのですが、ソフトを作るのが苦手です。そこで親友のあなたはたろう君に代わって、「鬼から見えないこと確認システム」のソフトウェアを作ることになりました。公園の壁は固定されていますが、たろう君と鬼のいろいろな位置情報に対して見えるか否かを判定する必要があります。
公園にある壁の情報(中心の座標 (
wx
,
wy
) と 半径
r
) とたろう君と鬼の位置情報(たろう君の位置の座標 (
tx
,
ty
) と鬼の位置の座標 (
sx
,
sy
) ) を入力とし、その位置で鬼からたろう君が見えるか否かを判定するプログラムを作成してください。
なお、鬼からたろう君が見える場合には Danger、見えない場合には Safe と出力してください。鬼とたろう君の位置を結んだ線分上に壁がある場合には見えないものとし、鬼もたろう君も壁の上にはいないものとします。
Input
複数のデータセットが与えられます。各データセットは以下の形式で与えられます。
n
wx
1
wy
1
r
1
wx
2
wy
2
r
2
:
wx
n
wy
n
r
n
m
tx
1
ty
1
sx
1
sy
1
tx
2
ty
2
sx
2
sy
2
:
tx
m
ty
m
sx
m
sy
m
1 行目に円筒形の壁の数
n
(0 ≤
n
≤ 100)、続く
n
行に壁
i
の中心の座標を表す整数
wx
i
,
wy
i
(0 ≤
wx
i
,
wy
i
≤ 255) と半径を表す整数
r
i
(1 ≤
r
i
≤ 255) が与えられます。
続く行にたろう君と鬼の位置情報の個数
m
(m ≤ 100)、続く
m
行に位置情報
i
のたろう君の位置の座標を表す整数
tx
i
,
ty
i
(0 ≤
tx
i
,
ty
i
≤ 255) と鬼の位置の座標を表す整数
sx
i
,
sy
i
(0 ≤
sx
i
,
sy
i
≤ 255)  が与えられます。
また、円筒形の壁の一部だけが公園にあるということはなく、全ての壁は円筒として、公園の内部に入っています。
n
が 0 のとき入力の終わりを示します。データセットの数は 20 を超えません。
Output
各データセットについて、位置情報
i
の判定結果 Danger または Safe を
i
行目に出力してください。
Sample Input
3
6 6 3
19 7 4
21 8 1
6
5 4 2 11
12 4 2 11
11 9 2 11
14 3 20 5
17 9 20 5
20 10 20 5
0
Output for the Sample Input
Safe
Safe
Danger
Safe
Danger
Safe",Python,"import math as M
def R(A): return (A[0]**2+A[1]**2)**.5
def I(i): return [map(int,raw_input().split()) for _ in [0]*i]
def C(a,b): return a>b or abs(a-b)<1e-6
def f(e1):
  tx,ty,sx,sy=e1
  x=[]
  for e2 in WP:
    wx,wy,r=e2
    wt=[tx-wx,ty-wy]; rwt=R(wt)
    sw=[wx-sx,wy-sy]; rsw=R(sw)
    st=[tx-sx,ty-sy]; rst=R(st)
    F=[rwt<r,rsw<r]
    if rst==0: c=1
    elif F==[1,1]: c=1
    elif F==[1,0] or F==[0,1]: c=0
    elif F==[0,0]:
      c=0
      a=M.pi/2-M.acos(r/rsw)
      b=M.acos((sw[0]*st[0]+sw[1]*st[1])/rsw/rst)
#      if C(a,b) and C(rst**2,rsw**2-r**2): c=0
#      else: c=1
    x.append(c)
  return all(x)

while 1:
  n=input()
  if n==0: break
  WP=I(n)
  P=I(input())
  for e in P: print [""Safe"",""Danger""][f(e)]",1
p00130,"列車
26 両以下の編成の列車があります。それぞれの車両には、英小文字の a から z までの識別記号が付いています。同じ記号が付いている車両はありません。ただし、車両を連結する順番は自由とします。列車の中を車掌が巡回します。車掌は、列車の中を行ったり来たりして巡回するので、同じ車両を何度も通ることがあります。ただし、すべての車両を最低一回は巡回するものとします。また、巡回をはじめる車両や巡回を終える車両が列車の一番端の車両とは限りません。
ある車掌が乗ったすべての列車の巡回記録があります。そこから分かる各列車の編成を先頭車両から出力するプログラムを作成してください。巡回記録は 1 行が 1 つの列車に対応します。各行は、英小文字を 1 文字ずつ
<-
または
->
で区切った文字列でできています。
<-
は前方の車両への移動、
->
は後方の車両への移動を表します。
例えば、
a->b<-a<-c
は車両 a から後方の車両である b に移り、b から前方の a に移り、a から前方の c へ移ったことを表します。この場合の列車の編成は先頭車両から
cab
となります。
Input
１行目に巡回記録の個数
n
(
n
≤ 50)、続く
n
行に巡回記録
i
を表す文字列
s
i
(1024文字までの半角文字列) が与えられます。
Output
巡回記録
i
について、先頭車両からの列車の編成を現す文字列を
i
行目に出力してください。
Sample Input
4
a->e->c->b->d
b<-c<-a<-d<-e
b->a->c<-a->c->d<-c<-a<-b->a->c->d->e<-d
a->e<-a<-d->a->e<-a<-d<-c->d->a<-d<-c<-b->c->d<-c
Output for the Sample Input
aecbd
edacb
bacde
bcdae",C,"#include <stdio.h>
#include <string.h>
#include <stdlib.h>

int main() {
    int n;
    scanf(""%d"", &n);
    getchar();
    
    for (int i = 0; i < n; i++) {
        char line[1025];
        fgets(line, 1025, stdin);
        
        // Parse the movements
        char cars[26];
        int carCount = 0;
        int carPos[26]; // Position of each car (a-z)
        for (int j = 0; j < 26; j++) {
            carPos[j] = -1;
        }
        
        // Parse first car
        char currentCar = line[0];
        cars[carCount] = currentCar;
        carPos[currentCar - 'a'] = carCount;
        carCount++;
        
        int pos = 0;
        int minPos = 0, maxPos = 0;
        
        // Parse movements
        int idx = 1;
        while (line[idx] != '\0' && line[idx] != '\n') {
            // Read direction
            char dir[3];
            dir[0] = line[idx];
            dir[1] = line[idx + 1];
            dir[2] = '\0';
            idx += 2;
            
            // Read next car
            char nextCar = line[idx];
            idx++;
            
            int nextCarIdx = nextCar - 'a';
            
            if (strcmp(dir, ""->"") == 0) {
                // Moving to next car (right)
                if (carPos[nextCarIdx] == -1) {
                    // New car on the right
                    pos++;
                    carPos[nextCarIdx] = pos;
                    if (pos > maxPos) maxPos = pos;
                } else {
                    pos = carPos[nextCarIdx];
                }
            } else { // ""<-""
                // Moving to previous car (left)
                if (carPos[nextCarIdx] == -1) {
                    // New car on the left
                    pos--;
                    carPos[nextCarIdx] = pos;
                    if (pos < minPos) minPos = pos;
                } else {
                    pos = carPos[nextCarIdx];
                }
            }
        }
        
        // Build result string
        int length = maxPos - minPos + 1;
        char result[27];
        for (int j = 0; j < length; j++) {
            result[j] = ' ';
        }
        result[length] = '\0';
        
        for (int j = 0; j < 26; j++) {
            if (carPos[j] != -1) {
                int actualPos = carPos[j] - minPos;
                result[actualPos] = 'a' + j;
            }
        }
        
        printf(""%s\n"", result);
    }
    
    return 0;
}
",0
p00130,"列車
26 両以下の編成の列車があります。それぞれの車両には、英小文字の a から z までの識別記号が付いています。同じ記号が付いている車両はありません。ただし、車両を連結する順番は自由とします。列車の中を車掌が巡回します。車掌は、列車の中を行ったり来たりして巡回するので、同じ車両を何度も通ることがあります。ただし、すべての車両を最低一回は巡回するものとします。また、巡回をはじめる車両や巡回を終える車両が列車の一番端の車両とは限りません。
ある車掌が乗ったすべての列車の巡回記録があります。そこから分かる各列車の編成を先頭車両から出力するプログラムを作成してください。巡回記録は 1 行が 1 つの列車に対応します。各行は、英小文字を 1 文字ずつ
<-
または
->
で区切った文字列でできています。
<-
は前方の車両への移動、
->
は後方の車両への移動を表します。
例えば、
a->b<-a<-c
は車両 a から後方の車両である b に移り、b から前方の a に移り、a から前方の c へ移ったことを表します。この場合の列車の編成は先頭車両から
cab
となります。
Input
１行目に巡回記録の個数
n
(
n
≤ 50)、続く
n
行に巡回記録
i
を表す文字列
s
i
(1024文字までの半角文字列) が与えられます。
Output
巡回記録
i
について、先頭車両からの列車の編成を現す文字列を
i
行目に出力してください。
Sample Input
4
a->e->c->b->d
b<-c<-a<-d<-e
b->a->c<-a->c->d<-c<-a<-b->a->c->d->e<-d
a->e<-a<-d->a->e<-a<-d<-c->d->a<-d<-c<-b->c->d<-c
Output for the Sample Input
aecbd
edacb
bacde
bcdae",C,"#include<stdio.h>
#include<string.h>
int n,i,j,p;
char c,t,l[27];
int main()
{
	scanf(""%d"",&n);
	getchar();
	for(i=0;i<n;i++)
	{
		p=13;
		memset(l,0,27);
		for(;scanf(""%c"",&l[p])!=-1;)
		{
			~scanf(""%c"",&c);
			if(c=='-'||c=='<')
				getchar(),c=='-'?p++:p--;
			else
				break;
		}
		for(j=0;!l[j];j++);
		puts(l+j);
	}
	return 0;
}",1
p00130,"列車
26 両以下の編成の列車があります。それぞれの車両には、英小文字の a から z までの識別記号が付いています。同じ記号が付いている車両はありません。ただし、車両を連結する順番は自由とします。列車の中を車掌が巡回します。車掌は、列車の中を行ったり来たりして巡回するので、同じ車両を何度も通ることがあります。ただし、すべての車両を最低一回は巡回するものとします。また、巡回をはじめる車両や巡回を終える車両が列車の一番端の車両とは限りません。
ある車掌が乗ったすべての列車の巡回記録があります。そこから分かる各列車の編成を先頭車両から出力するプログラムを作成してください。巡回記録は 1 行が 1 つの列車に対応します。各行は、英小文字を 1 文字ずつ
<-
または
->
で区切った文字列でできています。
<-
は前方の車両への移動、
->
は後方の車両への移動を表します。
例えば、
a->b<-a<-c
は車両 a から後方の車両である b に移り、b から前方の a に移り、a から前方の c へ移ったことを表します。この場合の列車の編成は先頭車両から
cab
となります。
Input
１行目に巡回記録の個数
n
(
n
≤ 50)、続く
n
行に巡回記録
i
を表す文字列
s
i
(1024文字までの半角文字列) が与えられます。
Output
巡回記録
i
について、先頭車両からの列車の編成を現す文字列を
i
行目に出力してください。
Sample Input
4
a->e->c->b->d
b<-c<-a<-d<-e
b->a->c<-a->c->d<-c<-a<-b->a->c->d->e<-d
a->e<-a<-d->a->e<-a<-d<-c->d->a<-d<-c<-b->c->d<-c
Output for the Sample Input
aecbd
edacb
bacde
bcdae",Java,"import java.util.*;

public class Main {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int n = sc.nextInt();
        sc.nextLine();
        
        for (int i = 0; i < n; i++) {
            String line = sc.nextLine();
            System.out.println(solve(line));
        }
        sc.close();
    }
    
    static String solve(String record) {
        String[] tokens = record.split(""(<-|->)"");
        String[] directions = record.split(""[a-z]"");
        
        Map<Character, Set<Character>> next = new HashMap<>();
        Map<Character, Set<Character>> prev = new HashMap<>();
        Set<Character> cars = new HashSet<>();
        
        for (String token : tokens) {
            if (!token.isEmpty()) {
                char c = token.charAt(0);
                cars.add(c);
                next.putIfAbsent(c, new HashSet<>());
                prev.putIfAbsent(c, new HashSet<>());
            }
        }
        
        for (int i = 0; i < tokens.length - 1; i++) {
            char from = tokens[i].charAt(0);
            char to = tokens[i + 1].charAt(0);
            String dir = directions[i + 1];
            
            if (dir.equals(""->"")) {
                next.get(from).add(to);
                prev.get(to).add(from);
            } else {
                prev.get(from).add(to);
                next.get(to).add(from);
            }
        }
        
        // Build the train
        List<Character> train = new ArrayList<>();
        
        // Find a starting car (one with no prev or just one end)
        char start = ' ';
        for (char c : cars) {
            Set<Character> p = prev.get(c);
            Set<Character> n = next.get(c);
            
            // Remove inconsistencies
            p.removeAll(n);
            n.removeAll(p);
            
            if (p.isEmpty()) {
                start = c;
                break;
            }
        }
        
        if (start == ' ') {
            start = cars.iterator().next();
        }
        
        // Build forward
        Set<Character> visited = new HashSet<>();
        char current = start;
        train.add(current);
        visited.add(current);
        
        while (true) {
            Set<Character> nextCars = next.get(current);
            nextCars.removeAll(prev.get(current));
            
            char nextCar = ' ';
            for (char c : nextCars) {
                if (!visited.contains(c)) {
                    nextCar = c;
                    break;
                }
            }
            
            if (nextCar == ' ') break;
            
            train.add(nextCar);
            visited.add(nextCar);
            current = nextCar;
        }
        
        // Build backward from start
        current = start;
        while (true) {
            Set<Character> prevCars = prev.get(current);
            prevCars.removeAll(next.get(current));
            
            char prevCar = ' ';
            for (char c : prevCars) {
                if (!visited.contains(c)) {
                    prevCar = c;
                    break;
                }
            }
            
            if (prevCar == ' ') break;
            
            train.add(0, prevCar);
            visited.add(prevCar);
            current = prevCar;
        }
        
        StringBuilder result = new StringBuilder();
        for (char c : train) {
            result.append(c);
        }
        
        return result.toString();
    }
}
",0
p00130,"列車
26 両以下の編成の列車があります。それぞれの車両には、英小文字の a から z までの識別記号が付いています。同じ記号が付いている車両はありません。ただし、車両を連結する順番は自由とします。列車の中を車掌が巡回します。車掌は、列車の中を行ったり来たりして巡回するので、同じ車両を何度も通ることがあります。ただし、すべての車両を最低一回は巡回するものとします。また、巡回をはじめる車両や巡回を終える車両が列車の一番端の車両とは限りません。
ある車掌が乗ったすべての列車の巡回記録があります。そこから分かる各列車の編成を先頭車両から出力するプログラムを作成してください。巡回記録は 1 行が 1 つの列車に対応します。各行は、英小文字を 1 文字ずつ
<-
または
->
で区切った文字列でできています。
<-
は前方の車両への移動、
->
は後方の車両への移動を表します。
例えば、
a->b<-a<-c
は車両 a から後方の車両である b に移り、b から前方の a に移り、a から前方の c へ移ったことを表します。この場合の列車の編成は先頭車両から
cab
となります。
Input
１行目に巡回記録の個数
n
(
n
≤ 50)、続く
n
行に巡回記録
i
を表す文字列
s
i
(1024文字までの半角文字列) が与えられます。
Output
巡回記録
i
について、先頭車両からの列車の編成を現す文字列を
i
行目に出力してください。
Sample Input
4
a->e->c->b->d
b<-c<-a<-d<-e
b->a->c<-a->c->d<-c<-a<-b->a->c->d->e<-d
a->e<-a<-d->a->e<-a<-d<-c->d->a<-d<-c<-b->c->d<-c
Output for the Sample Input
aecbd
edacb
bacde
bcdae",Java,"package jp.ac.saburou.volume1;

import java.util.Scanner;

class p130 {
	public static void main(String[] args) {
		Scanner s = new Scanner(System.in);
		int n = s.nextInt();
		int[][] result = null;
		for (int t = 0; t < n; t++) {
			char[] train = s.next().toCharArray();
			if (train.length > 1) {
				result = createTrainGraph(train);
				/* 先頭車両を決定する */
				int next = NO_CONNECTION;
				for (int i = 0; i < result.length; i++) {
					if (result[i][0] == NO_CONNECTION
							&& result[i][1] != NO_CONNECTION) {
						next = i;
					}
				}
				/* 出力 */
				while (next != -1) {
					System.out.printf(""%c"", next + 'a');
					next = result[next][REAR];
				}
				System.out.println();
			} else {
				System.out.println(train[0]);
			}
		}
	}

	static final int FRONT = 0;
	static final int REAR = 1;
	static final int NO_CONNECTION = -1;

	static int[][] createTrainGraph(char[] input) {
		int[][] train = new int[26][2];
		for (int i = 0; i < train.length; i++) {
			for (int j = 0; j < train[0].length; j++) {
				train[i][j] = NO_CONNECTION;
			}
		}
		boolean front = false;
		int before = input[0];
		for (int i = 1; i < input.length; i++) {
			int current = input[i];
			if ('a' <= current && current <= 'z') {
				if (front) {
					train[before - 'a'][FRONT] = current - 'a';
					train[current - 'a'][REAR] = before - 'a';
				} else {
					train[before - 'a'][REAR] = current - 'a';
					train[current - 'a'][FRONT] = before - 'a';
				}
				before = current;
			} else if (current == '>') {
				front = false;
			} else if (current == '<') {
				front = true;
			}
		}
		return train;
	}
}",1
p00130,"列車
26 両以下の編成の列車があります。それぞれの車両には、英小文字の a から z までの識別記号が付いています。同じ記号が付いている車両はありません。ただし、車両を連結する順番は自由とします。列車の中を車掌が巡回します。車掌は、列車の中を行ったり来たりして巡回するので、同じ車両を何度も通ることがあります。ただし、すべての車両を最低一回は巡回するものとします。また、巡回をはじめる車両や巡回を終える車両が列車の一番端の車両とは限りません。
ある車掌が乗ったすべての列車の巡回記録があります。そこから分かる各列車の編成を先頭車両から出力するプログラムを作成してください。巡回記録は 1 行が 1 つの列車に対応します。各行は、英小文字を 1 文字ずつ
<-
または
->
で区切った文字列でできています。
<-
は前方の車両への移動、
->
は後方の車両への移動を表します。
例えば、
a->b<-a<-c
は車両 a から後方の車両である b に移り、b から前方の a に移り、a から前方の c へ移ったことを表します。この場合の列車の編成は先頭車両から
cab
となります。
Input
１行目に巡回記録の個数
n
(
n
≤ 50)、続く
n
行に巡回記録
i
を表す文字列
s
i
(1024文字までの半角文字列) が与えられます。
Output
巡回記録
i
について、先頭車両からの列車の編成を現す文字列を
i
行目に出力してください。
Sample Input
4
a->e->c->b->d
b<-c<-a<-d<-e
b->a->c<-a->c->d<-c<-a<-b->a->c->d->e<-d
a->e<-a<-d->a->e<-a<-d<-c->d->a<-d<-c<-b->c->d<-c
Output for the Sample Input
aecbd
edacb
bacde
bcdae",Python,"def solve(s):
    # Parse the movements
    tokens = s.replace('<-', ' <- ').replace('->', ' -> ').split()
    
    # Build adjacency relationships
    cars = set()
    neighbors = {}
    
    current = tokens[0]
    cars.add(current)
    
    i = 1
    while i < len(tokens):
        direction = tokens[i]
        next_car = tokens[i + 1]
        cars.add(next_car)
        
        if current not in neighbors:
            neighbors[current] = set()
        if next_car not in neighbors:
            neighbors[next_car] = set()
        
        neighbors[current].add(next_car)
        neighbors[next_car].add(current)
        
        current = next_car
        i += 2
    
    # Find the train composition (it forms a path)
    # Find cars with degree 1 (endpoints)
    endpoints = []
    for car in cars:
        if car not in neighbors or len(neighbors[car]) == 1:
            endpoints.append(car)
    
    # If no endpoints found (circular), pick any car
    if not endpoints:
        endpoints = [list(cars)[0]]
    
    # Build the path from one endpoint
    start = endpoints[0]
    path = [start]
    visited = {start}
    current = start
    
    while True:
        if current not in neighbors:
            break
        next_found = False
        for next_car in neighbors[current]:
            if next_car not in visited:
                path.append(next_car)
                visited.add(next_car)
                current = next_car
                next_found = True
                break
        if not next_found:
            break
    
    return ''.join(path)

n = int(input())
for _ in range(n):
    s = input().strip()
    print(solve(s))
",0
p00130,"列車
26 両以下の編成の列車があります。それぞれの車両には、英小文字の a から z までの識別記号が付いています。同じ記号が付いている車両はありません。ただし、車両を連結する順番は自由とします。列車の中を車掌が巡回します。車掌は、列車の中を行ったり来たりして巡回するので、同じ車両を何度も通ることがあります。ただし、すべての車両を最低一回は巡回するものとします。また、巡回をはじめる車両や巡回を終える車両が列車の一番端の車両とは限りません。
ある車掌が乗ったすべての列車の巡回記録があります。そこから分かる各列車の編成を先頭車両から出力するプログラムを作成してください。巡回記録は 1 行が 1 つの列車に対応します。各行は、英小文字を 1 文字ずつ
<-
または
->
で区切った文字列でできています。
<-
は前方の車両への移動、
->
は後方の車両への移動を表します。
例えば、
a->b<-a<-c
は車両 a から後方の車両である b に移り、b から前方の a に移り、a から前方の c へ移ったことを表します。この場合の列車の編成は先頭車両から
cab
となります。
Input
１行目に巡回記録の個数
n
(
n
≤ 50)、続く
n
行に巡回記録
i
を表す文字列
s
i
(1024文字までの半角文字列) が与えられます。
Output
巡回記録
i
について、先頭車両からの列車の編成を現す文字列を
i
行目に出力してください。
Sample Input
4
a->e->c->b->d
b<-c<-a<-d<-e
b->a->c<-a->c->d<-c<-a<-b->a->c->d->e<-d
a->e<-a<-d->a->e<-a<-d<-c->d->a<-d<-c<-b->c->d<-c
Output for the Sample Input
aecbd
edacb
bacde
bcdae",Python,"# AOJ 0130 Train
# Python3 2018.6.19 bal4u

for _ in range(int(input())):
	s = list(input())
	ans = []
	dir = '>'
	for i in range(len(s)):
		if s[i].isalpha():
			if dir == '>':
				if s[i] not in ans: ans.append(s[i])
			else:
				if s[i] not in ans: ans.insert(0, s[i])
		elif s[i] == '>' or s[i] == '<': dir = s[i]
	print(*ans, sep='')
",1
p00131,"博士の光電管
博士 :   ピーター君。やったよ。
ピーター : またですか。今度はどんなくだらない発明ですか。
博士 :   あの幻の素粒子アキシオンの検出器を発明したんじゃ。
ピーター : アキシオンといえば、欧州合同原子核研究機構 (CERN) をはじめとする研究者たちが血眼で追っかけているという、あれですよね。本当ですかぁ?
博士 :   本当だってばよ。細かい説明は省くが、非常に強力な磁場を内蔵する特殊な光電管が光ることによって、通過するアキシオンを検出する。
ピーター : 他 に先んじて検出すれば、小柴先生のニュートリノ検出に匹敵するノーベル賞級の研究ですよ。
       これで役立たずの研究ばかりしている「ダメ研究室」などという汚名も返上できますね。
博士 :   そうだとも。小柴先生の「スーパーカミオカンデ」にあやかって、この装置を、(悪口言ったら)「タダジャオカンデ」と命名した。
ピーター : ちょっと苦しいって言うか、卑屈って言うか・・・。
博士 :   それはいいとして、この装置ちょっとした癖があるんじゃよ。
       アキシオン粒子がある光電管を通過すると、感度の関係でその光電管と隣接する上下左右の光電管が反応する。
図1
図2
★
●
●
●
●
●
●
●
★
●
●
●
●
●
●
●
●
●
●
●
●
●
★
●
●
→
○
○
●
○
●
○
●
○
○
○
●
●
●
○
●
●
●
○
●
●
●
○
○
○
●
●
○
○
●
○
○
★
★
○
☆
●
●
○
●
●
○
●
●
○
●
●
○
○
○
●
→
●
●
●
●
●
●
●
●
○
●
●
○
●
●
○
○
●
●
○
●
●
○
○
○
●
ピーター : つまり、図1の左側★印の光電管を粒子が通過した場合、
       右側のように点灯すると言うことですね。
       (図は 5 × 5 の例。黒は消灯・白は点灯状態。以下同じ。)
博士 :   また反応とは、光電管の状態が反転する。つまり消えている光電管は光り、
       光っている光電管は消える。
ピーター : つまり、図2の左側の★印や☆印を粒子が通過した場合、右側のような状態になると。
博士 :   これを正方形になんと 100 個 (10 × 10) 配置して待ち受けるわけだ。
ピーター : これだけの大発明、ノーベル賞選考委員会も「ホッチャオカンデ」なんて。
博士 :   おぉピーター君、君も我が研究室の作風になじんできたようだね。いい感じだ。
       では、早速実験を始めよう。まずはこの装置、現在ランダムに光電管が点いているので、
       実験が始められるように全部消えた状態にリセットしてくれたまえ。
       なあに、どの光電管にアキシオン粒子を当てれば全部消えるか考えればいいだけじゃよ。
       簡単だろう?
ピーター : 考えるのはいいんですが博士。当てるためには、
       幻のアキシオン粒子を発生させて打ち込める装置がないといけないんじゃないですか。
博士 :   ・・・。
博士とピータ      (同時に)コリャアカンデ!だははは・・・・。
ー:
ということで、本日も和気あいあいと暮れてゆく博士の研究室ですが、例によって話は全く進みそうもありません。しょうがないので、ピーター君に代わってプログラムを作成してあげてください。
プログラムは次のようなものになります。
A. 装置の光電管の状態を 10 × 10 の配列として入力します。0は消灯中、1は点灯中を表します。
    0 と 1 以外のデータは含まれません。
B. 入力した装置の状態をすべて消灯にするために、アキシオン粒子を通過させる位置を計算して出力します。これは、入力と同じ 10 × 10の配列で光電管の位置を表します。「0 は通過させない」、「1 は通過させる」ことを表します。すべてを消灯する方法は必ず 1 通りだけ存在するものとします。
Input
複数のデータセットが与えられます。１行目にデータセットの数
n
(
n
≤ 20) が与えられます。各データセットは以下の形式で与えられます。
a
1,1
a
1,2
...
a
1,10
a
2,1
a
2,2
...
a
2,10
:
a
10,1
a
10,2
...
a
10,10
a
i,j
は装置の
i
行目
j
列目の光電管の状態を示す整数 (0 または 1) を表します。
Output
各データセットについて、粒子を通過させる位置を以下の形式で出力してください。
b
1,1
b
1,2
...
b
1,10
b
2,1
b
2,2
...
b
2,10
:
b
10,1
b
10,2
...
b
10,10
b
i,j
は装置の
i
行目
j
列目の光電管に粒子を通過させるかいなかを示す整数 (0 または 1) を表します。
Sample Input
1
0 1 0 0 0 0 0 0 0 0
1 1 1 0 0 0 0 0 0 0
0 1 0 0 0 0 0 0 0 0
0 0 0 0 1 1 0 0 0 0
0 0 0 1 0 0 1 0 0 0
0 0 0 0 1 1 0 0 0 0
0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 1 0
0 0 0 0 0 0 0 1 1 1
0 0 0 0 0 0 0 0 1 0
Output for the Sample Input
0 0 0 0 0 0 0 0 0 0
0 1 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0
0 0 0 0 1 1 0 0 0 0
0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 1 0
0 0 0 0 0 0 0 0 0 0",C,"#include <stdio.h>

int main() {
    int n;
    scanf(""%d"", &n);
    
    while (n--) {
        int grid[10][10];
        int solution[10][10] = {0};
        
        // Read input
        for (int i = 0; i < 10; i++) {
            for (int j = 0; j < 10; j++) {
                scanf(""%d"", &grid[i][j]);
            }
        }
        
        // Solve using Gaussian elimination in GF(2)
        // Each cell (i,j) being hit affects itself and neighbors
        // We need to solve: A*x = b where A is the effect matrix
        
        // Create augmented matrix
        int matrix[100][101];
        for (int i = 0; i < 100; i++) {
            for (int j = 0; j <= 100; j++) {
                matrix[i][j] = 0;
            }
        }
        
        // Build the system of equations
        for (int row = 0; row < 10; row++) {
            for (int col = 0; col < 10; col++) {
                int eq = row * 10 + col;
                matrix[eq][100] = grid[row][col];
                
                // Check which positions affect this cell
                for (int r = 0; r < 10; r++) {
                    for (int c = 0; c < 10; c++) {
                        int var = r * 10 + c;
                        // Position (r,c) affects (row,col) if:
                        // - (r,c) == (row,col) or
                        // - (r,c) is adjacent to (row,col)
                        if ((r == row && c == col) ||
                            (r == row && (c == col-1 || c == col+1)) ||
                            (c == col && (r == row-1 || r == row+1))) {
                            matrix[eq][var] = 1;
                        }
                    }
                }
            }
        }
        
        // Gaussian elimination in GF(2)
        for (int col = 0; col < 100; col++) {
            // Find pivot
            int pivot = -1;
            for (int row = col; row < 100; row++) {
                if (matrix[row][col] == 1) {
                    pivot = row;
                    break;
                }
            }
            
            if (pivot == -1) continue;
            
            // Swap rows
            if (pivot != col) {
                for (int j = 0; j <= 100; j++) {
                    int temp = matrix[col][j];
                    matrix[col][j] = matrix[pivot][j];
                    matrix[pivot][j] = temp;
                }
            }
            
            // Eliminate
            for (int row = 0; row < 100; row++) {
                if (row != col && matrix[row][col] == 1) {
                    for (int j = 0; j <= 100; j++) {
                        matrix[row][j] ^= matrix[col][j];
                    }
                }
            }
        }
        
        // Back substitution to get solution
        int result[100] = {0};
        for (int i = 0; i < 100; i++) {
            result[i] = matrix[i][100];
        }
        
        // Convert to 2D and output
        for (int i = 0; i < 10; i++) {
            for (int j = 0; j < 10; j++) {
                if (j > 0) printf("" "");
                printf(""%d"", result[i * 10 + j]);
            }
            printf(""\n"");
        }
    }
    
    return 0;
}
",0
p00131,"博士の光電管
博士 :   ピーター君。やったよ。
ピーター : またですか。今度はどんなくだらない発明ですか。
博士 :   あの幻の素粒子アキシオンの検出器を発明したんじゃ。
ピーター : アキシオンといえば、欧州合同原子核研究機構 (CERN) をはじめとする研究者たちが血眼で追っかけているという、あれですよね。本当ですかぁ?
博士 :   本当だってばよ。細かい説明は省くが、非常に強力な磁場を内蔵する特殊な光電管が光ることによって、通過するアキシオンを検出する。
ピーター : 他 に先んじて検出すれば、小柴先生のニュートリノ検出に匹敵するノーベル賞級の研究ですよ。
       これで役立たずの研究ばかりしている「ダメ研究室」などという汚名も返上できますね。
博士 :   そうだとも。小柴先生の「スーパーカミオカンデ」にあやかって、この装置を、(悪口言ったら)「タダジャオカンデ」と命名した。
ピーター : ちょっと苦しいって言うか、卑屈って言うか・・・。
博士 :   それはいいとして、この装置ちょっとした癖があるんじゃよ。
       アキシオン粒子がある光電管を通過すると、感度の関係でその光電管と隣接する上下左右の光電管が反応する。
図1
図2
★
●
●
●
●
●
●
●
★
●
●
●
●
●
●
●
●
●
●
●
●
●
★
●
●
→
○
○
●
○
●
○
●
○
○
○
●
●
●
○
●
●
●
○
●
●
●
○
○
○
●
●
○
○
●
○
○
★
★
○
☆
●
●
○
●
●
○
●
●
○
●
●
○
○
○
●
→
●
●
●
●
●
●
●
●
○
●
●
○
●
●
○
○
●
●
○
●
●
○
○
○
●
ピーター : つまり、図1の左側★印の光電管を粒子が通過した場合、
       右側のように点灯すると言うことですね。
       (図は 5 × 5 の例。黒は消灯・白は点灯状態。以下同じ。)
博士 :   また反応とは、光電管の状態が反転する。つまり消えている光電管は光り、
       光っている光電管は消える。
ピーター : つまり、図2の左側の★印や☆印を粒子が通過した場合、右側のような状態になると。
博士 :   これを正方形になんと 100 個 (10 × 10) 配置して待ち受けるわけだ。
ピーター : これだけの大発明、ノーベル賞選考委員会も「ホッチャオカンデ」なんて。
博士 :   おぉピーター君、君も我が研究室の作風になじんできたようだね。いい感じだ。
       では、早速実験を始めよう。まずはこの装置、現在ランダムに光電管が点いているので、
       実験が始められるように全部消えた状態にリセットしてくれたまえ。
       なあに、どの光電管にアキシオン粒子を当てれば全部消えるか考えればいいだけじゃよ。
       簡単だろう?
ピーター : 考えるのはいいんですが博士。当てるためには、
       幻のアキシオン粒子を発生させて打ち込める装置がないといけないんじゃないですか。
博士 :   ・・・。
博士とピータ      (同時に)コリャアカンデ!だははは・・・・。
ー:
ということで、本日も和気あいあいと暮れてゆく博士の研究室ですが、例によって話は全く進みそうもありません。しょうがないので、ピーター君に代わってプログラムを作成してあげてください。
プログラムは次のようなものになります。
A. 装置の光電管の状態を 10 × 10 の配列として入力します。0は消灯中、1は点灯中を表します。
    0 と 1 以外のデータは含まれません。
B. 入力した装置の状態をすべて消灯にするために、アキシオン粒子を通過させる位置を計算して出力します。これは、入力と同じ 10 × 10の配列で光電管の位置を表します。「0 は通過させない」、「1 は通過させる」ことを表します。すべてを消灯する方法は必ず 1 通りだけ存在するものとします。
Input
複数のデータセットが与えられます。１行目にデータセットの数
n
(
n
≤ 20) が与えられます。各データセットは以下の形式で与えられます。
a
1,1
a
1,2
...
a
1,10
a
2,1
a
2,2
...
a
2,10
:
a
10,1
a
10,2
...
a
10,10
a
i,j
は装置の
i
行目
j
列目の光電管の状態を示す整数 (0 または 1) を表します。
Output
各データセットについて、粒子を通過させる位置を以下の形式で出力してください。
b
1,1
b
1,2
...
b
1,10
b
2,1
b
2,2
...
b
2,10
:
b
10,1
b
10,2
...
b
10,10
b
i,j
は装置の
i
行目
j
列目の光電管に粒子を通過させるかいなかを示す整数 (0 または 1) を表します。
Sample Input
1
0 1 0 0 0 0 0 0 0 0
1 1 1 0 0 0 0 0 0 0
0 1 0 0 0 0 0 0 0 0
0 0 0 0 1 1 0 0 0 0
0 0 0 1 0 0 1 0 0 0
0 0 0 0 1 1 0 0 0 0
0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 1 0
0 0 0 0 0 0 0 1 1 1
0 0 0 0 0 0 0 0 1 0
Output for the Sample Input
0 0 0 0 0 0 0 0 0 0
0 1 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0
0 0 0 0 1 1 0 0 0 0
0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 1 0
0 0 0 0 0 0 0 0 0 0",C,"#include<stdio.h>
#include<string.h>
int main(){
	int i,j,n,s[12][12],a[12][12];
	scanf(""%d"",&n);
	while(n--){
		for(i=0;i<10;i++)for(j=0;j<10;j++)scanf(""%d"",&s[i][j]);
		memset(a,0,sizeof(a));
		for(i=0;i<9;i++){
			for(j=0;j<10;j++){
				if(s[i][j]%2==1){
					a[i+1][j]=1;
					s[i][j]++;
					s[i+1][j]++;
					s[i+1][j-1]++;
					s[i+1][j+1]++;
					s[i+2][j]++;
				}
			}
		}
		for(i=0;i<10;i++){for(j=0;j<10;j++)printf(""%d "",a[i][j]);printf(""\n"");}
	}
	return 0;
}",1
p00131,"博士の光電管
博士 :   ピーター君。やったよ。
ピーター : またですか。今度はどんなくだらない発明ですか。
博士 :   あの幻の素粒子アキシオンの検出器を発明したんじゃ。
ピーター : アキシオンといえば、欧州合同原子核研究機構 (CERN) をはじめとする研究者たちが血眼で追っかけているという、あれですよね。本当ですかぁ?
博士 :   本当だってばよ。細かい説明は省くが、非常に強力な磁場を内蔵する特殊な光電管が光ることによって、通過するアキシオンを検出する。
ピーター : 他 に先んじて検出すれば、小柴先生のニュートリノ検出に匹敵するノーベル賞級の研究ですよ。
       これで役立たずの研究ばかりしている「ダメ研究室」などという汚名も返上できますね。
博士 :   そうだとも。小柴先生の「スーパーカミオカンデ」にあやかって、この装置を、(悪口言ったら)「タダジャオカンデ」と命名した。
ピーター : ちょっと苦しいって言うか、卑屈って言うか・・・。
博士 :   それはいいとして、この装置ちょっとした癖があるんじゃよ。
       アキシオン粒子がある光電管を通過すると、感度の関係でその光電管と隣接する上下左右の光電管が反応する。
図1
図2
★
●
●
●
●
●
●
●
★
●
●
●
●
●
●
●
●
●
●
●
●
●
★
●
●
→
○
○
●
○
●
○
●
○
○
○
●
●
●
○
●
●
●
○
●
●
●
○
○
○
●
●
○
○
●
○
○
★
★
○
☆
●
●
○
●
●
○
●
●
○
●
●
○
○
○
●
→
●
●
●
●
●
●
●
●
○
●
●
○
●
●
○
○
●
●
○
●
●
○
○
○
●
ピーター : つまり、図1の左側★印の光電管を粒子が通過した場合、
       右側のように点灯すると言うことですね。
       (図は 5 × 5 の例。黒は消灯・白は点灯状態。以下同じ。)
博士 :   また反応とは、光電管の状態が反転する。つまり消えている光電管は光り、
       光っている光電管は消える。
ピーター : つまり、図2の左側の★印や☆印を粒子が通過した場合、右側のような状態になると。
博士 :   これを正方形になんと 100 個 (10 × 10) 配置して待ち受けるわけだ。
ピーター : これだけの大発明、ノーベル賞選考委員会も「ホッチャオカンデ」なんて。
博士 :   おぉピーター君、君も我が研究室の作風になじんできたようだね。いい感じだ。
       では、早速実験を始めよう。まずはこの装置、現在ランダムに光電管が点いているので、
       実験が始められるように全部消えた状態にリセットしてくれたまえ。
       なあに、どの光電管にアキシオン粒子を当てれば全部消えるか考えればいいだけじゃよ。
       簡単だろう?
ピーター : 考えるのはいいんですが博士。当てるためには、
       幻のアキシオン粒子を発生させて打ち込める装置がないといけないんじゃないですか。
博士 :   ・・・。
博士とピータ      (同時に)コリャアカンデ!だははは・・・・。
ー:
ということで、本日も和気あいあいと暮れてゆく博士の研究室ですが、例によって話は全く進みそうもありません。しょうがないので、ピーター君に代わってプログラムを作成してあげてください。
プログラムは次のようなものになります。
A. 装置の光電管の状態を 10 × 10 の配列として入力します。0は消灯中、1は点灯中を表します。
    0 と 1 以外のデータは含まれません。
B. 入力した装置の状態をすべて消灯にするために、アキシオン粒子を通過させる位置を計算して出力します。これは、入力と同じ 10 × 10の配列で光電管の位置を表します。「0 は通過させない」、「1 は通過させる」ことを表します。すべてを消灯する方法は必ず 1 通りだけ存在するものとします。
Input
複数のデータセットが与えられます。１行目にデータセットの数
n
(
n
≤ 20) が与えられます。各データセットは以下の形式で与えられます。
a
1,1
a
1,2
...
a
1,10
a
2,1
a
2,2
...
a
2,10
:
a
10,1
a
10,2
...
a
10,10
a
i,j
は装置の
i
行目
j
列目の光電管の状態を示す整数 (0 または 1) を表します。
Output
各データセットについて、粒子を通過させる位置を以下の形式で出力してください。
b
1,1
b
1,2
...
b
1,10
b
2,1
b
2,2
...
b
2,10
:
b
10,1
b
10,2
...
b
10,10
b
i,j
は装置の
i
行目
j
列目の光電管に粒子を通過させるかいなかを示す整数 (0 または 1) を表します。
Sample Input
1
0 1 0 0 0 0 0 0 0 0
1 1 1 0 0 0 0 0 0 0
0 1 0 0 0 0 0 0 0 0
0 0 0 0 1 1 0 0 0 0
0 0 0 1 0 0 1 0 0 0
0 0 0 0 1 1 0 0 0 0
0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 1 0
0 0 0 0 0 0 0 1 1 1
0 0 0 0 0 0 0 0 1 0
Output for the Sample Input
0 0 0 0 0 0 0 0 0 0
0 1 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0
0 0 0 0 1 1 0 0 0 0
0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 1 0
0 0 0 0 0 0 0 0 0 0",Java,"import java.util.*;

public class Main {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int n = sc.nextInt();
        
        for (int t = 0; t < n; t++) {
            int[][] grid = new int[10][10];
            for (int i = 0; i < 10; i++) {
                for (int j = 0; j < 10; j++) {
                    grid[i][j] = sc.nextInt();
                }
            }
            
            int[][] result = solve(grid);
            
            for (int i = 0; i < 10; i++) {
                for (int j = 0; j < 10; j++) {
                    if (j > 0) System.out.print("" "");
                    System.out.print(result[i][j]);
                }
                System.out.println();
            }
        }
        sc.close();
    }
    
    static int[][] solve(int[][] grid) {
        // Use Gaussian elimination over GF(2)
        // Each cell (i,j) can be toggled, affecting itself and neighbors
        // We need to solve for which cells to toggle to turn all lights off
        
        int[][] solution = new int[10][10];
        
        // Create augmented matrix for the system
        // 100 variables (one for each cell), 100 equations (one for each cell)
        int size = 100;
        int[][] matrix = new int[size][size + 1];
        
        // Build the system of equations
        for (int i = 0; i < 10; i++) {
            for (int j = 0; j < 10; j++) {
                int row = i * 10 + j;
                
                // Check which toggles affect cell (i,j)
                for (int ti = 0; ti < 10; ti++) {
                    for (int tj = 0; tj < 10; tj++) {
                        int col = ti * 10 + tj;
                        
                        // Cell (ti,tj) affects (i,j) if they are adjacent
                        if ((ti == i && tj == j) ||
                            (ti == i && Math.abs(tj - j) == 1) ||
                            (tj == j && Math.abs(ti - i) == 1)) {
                            matrix[row][col] = 1;
                        }
                    }
                }
                
                // Right side: current state of cell (i,j)
                matrix[row][size] = grid[i][j];
            }
        }
        
        // Gaussian elimination in GF(2)
        for (int col = 0; col < size; col++) {
            // Find pivot
            int pivot = -1;
            for (int row = col; row < size; row++) {
                if (matrix[row][col] == 1) {
                    pivot = row;
                    break;
                }
            }
            
            if (pivot == -1) continue;
            
            // Swap rows
            if (pivot != col) {
                int[] temp = matrix[col];
                matrix[col] = matrix[pivot];
                matrix[pivot] = temp;
            }
            
            // Eliminate
            for (int row = 0; row < size; row++) {
                if (row != col && matrix[row][col] == 1) {
                    for (int c = 0; c <= size; c++) {
                        matrix[row][c] ^= matrix[col][c];
                    }
                }
            }
        }
        
        // Back substitution
        int[] vars = new int[size];
        for (int i = 0; i < size; i++) {
            vars[i] = matrix[i][size];
        }
        
        // Convert to 2D array
        for (int i = 0; i < 10; i++) {
            for (int j = 0; j < 10; j++) {
                solution[i][j] = vars[i * 10 + j];
            }
        }
        
        return solution;
    }
}
",0
p00131,"博士の光電管
博士 :   ピーター君。やったよ。
ピーター : またですか。今度はどんなくだらない発明ですか。
博士 :   あの幻の素粒子アキシオンの検出器を発明したんじゃ。
ピーター : アキシオンといえば、欧州合同原子核研究機構 (CERN) をはじめとする研究者たちが血眼で追っかけているという、あれですよね。本当ですかぁ?
博士 :   本当だってばよ。細かい説明は省くが、非常に強力な磁場を内蔵する特殊な光電管が光ることによって、通過するアキシオンを検出する。
ピーター : 他 に先んじて検出すれば、小柴先生のニュートリノ検出に匹敵するノーベル賞級の研究ですよ。
       これで役立たずの研究ばかりしている「ダメ研究室」などという汚名も返上できますね。
博士 :   そうだとも。小柴先生の「スーパーカミオカンデ」にあやかって、この装置を、(悪口言ったら)「タダジャオカンデ」と命名した。
ピーター : ちょっと苦しいって言うか、卑屈って言うか・・・。
博士 :   それはいいとして、この装置ちょっとした癖があるんじゃよ。
       アキシオン粒子がある光電管を通過すると、感度の関係でその光電管と隣接する上下左右の光電管が反応する。
図1
図2
★
●
●
●
●
●
●
●
★
●
●
●
●
●
●
●
●
●
●
●
●
●
★
●
●
→
○
○
●
○
●
○
●
○
○
○
●
●
●
○
●
●
●
○
●
●
●
○
○
○
●
●
○
○
●
○
○
★
★
○
☆
●
●
○
●
●
○
●
●
○
●
●
○
○
○
●
→
●
●
●
●
●
●
●
●
○
●
●
○
●
●
○
○
●
●
○
●
●
○
○
○
●
ピーター : つまり、図1の左側★印の光電管を粒子が通過した場合、
       右側のように点灯すると言うことですね。
       (図は 5 × 5 の例。黒は消灯・白は点灯状態。以下同じ。)
博士 :   また反応とは、光電管の状態が反転する。つまり消えている光電管は光り、
       光っている光電管は消える。
ピーター : つまり、図2の左側の★印や☆印を粒子が通過した場合、右側のような状態になると。
博士 :   これを正方形になんと 100 個 (10 × 10) 配置して待ち受けるわけだ。
ピーター : これだけの大発明、ノーベル賞選考委員会も「ホッチャオカンデ」なんて。
博士 :   おぉピーター君、君も我が研究室の作風になじんできたようだね。いい感じだ。
       では、早速実験を始めよう。まずはこの装置、現在ランダムに光電管が点いているので、
       実験が始められるように全部消えた状態にリセットしてくれたまえ。
       なあに、どの光電管にアキシオン粒子を当てれば全部消えるか考えればいいだけじゃよ。
       簡単だろう?
ピーター : 考えるのはいいんですが博士。当てるためには、
       幻のアキシオン粒子を発生させて打ち込める装置がないといけないんじゃないですか。
博士 :   ・・・。
博士とピータ      (同時に)コリャアカンデ!だははは・・・・。
ー:
ということで、本日も和気あいあいと暮れてゆく博士の研究室ですが、例によって話は全く進みそうもありません。しょうがないので、ピーター君に代わってプログラムを作成してあげてください。
プログラムは次のようなものになります。
A. 装置の光電管の状態を 10 × 10 の配列として入力します。0は消灯中、1は点灯中を表します。
    0 と 1 以外のデータは含まれません。
B. 入力した装置の状態をすべて消灯にするために、アキシオン粒子を通過させる位置を計算して出力します。これは、入力と同じ 10 × 10の配列で光電管の位置を表します。「0 は通過させない」、「1 は通過させる」ことを表します。すべてを消灯する方法は必ず 1 通りだけ存在するものとします。
Input
複数のデータセットが与えられます。１行目にデータセットの数
n
(
n
≤ 20) が与えられます。各データセットは以下の形式で与えられます。
a
1,1
a
1,2
...
a
1,10
a
2,1
a
2,2
...
a
2,10
:
a
10,1
a
10,2
...
a
10,10
a
i,j
は装置の
i
行目
j
列目の光電管の状態を示す整数 (0 または 1) を表します。
Output
各データセットについて、粒子を通過させる位置を以下の形式で出力してください。
b
1,1
b
1,2
...
b
1,10
b
2,1
b
2,2
...
b
2,10
:
b
10,1
b
10,2
...
b
10,10
b
i,j
は装置の
i
行目
j
列目の光電管に粒子を通過させるかいなかを示す整数 (0 または 1) を表します。
Sample Input
1
0 1 0 0 0 0 0 0 0 0
1 1 1 0 0 0 0 0 0 0
0 1 0 0 0 0 0 0 0 0
0 0 0 0 1 1 0 0 0 0
0 0 0 1 0 0 1 0 0 0
0 0 0 0 1 1 0 0 0 0
0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 1 0
0 0 0 0 0 0 0 1 1 1
0 0 0 0 0 0 0 0 1 0
Output for the Sample Input
0 0 0 0 0 0 0 0 0 0
0 1 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0
0 0 0 0 1 1 0 0 0 0
0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 1 0
0 0 0 0 0 0 0 0 0 0",Java,"import java.util.Scanner;

public class Main {
	static byte ans[][];

	public static boolean f(int a[][], int s[], int n) {
		if (10 <= n) {
			int b[][] = new int[10][10];
			ans = new byte[10][10];
			for (int i = 0; i < 10; i++) {
				for (int j = 0; j < 10; j++) {
					b[i][j] = a[i][j];
				}
			}
			for (int i = 0; i < 10; i++) {
				if (s[i] == 1) {
					reverse(b, 0, i);
					ans[0][i] = 1;
				}
			}
			for (int i = 1; i < 10; i++) {
				for (int j = 0; j < 10; j++) {
					if (b[i - 1][j] == 1) {
						reverse(b, i, j);
						ans[i][j] = 1;
					}
				}
			}
			if (check(b)) {
				return true;
			}
		} else {
			s[n] = 0;
			if (f(a, s, n + 1)) {
				return true;
			}
			s[n] = 1;
			if (f(a, s, n + 1)) {
				return true;
			}
		}
		return false;
	}

	public static void reverse(int a[][], int i, int j) {
		a[i][j] = (a[i][j] + 1) % 2;
		if (0 <= i - 1) {
			a[i - 1][j] = (a[i - 1][j] + 1) % 2;
		}
		if (i + 1 < 10) {
			a[i + 1][j] = (a[i + 1][j] + 1) % 2;
		}
		if (0 <= j - 1) {
			a[i][j - 1] = (a[i][j - 1] + 1) % 2;
		}
		if (j + 1 < 10) {
			a[i][j + 1] = (a[i][j + 1] + 1) % 2;
		}
	}

	public static boolean check(int a[][]) {
		for (int i = 0; i < 10; i++) {
			for (int j = 0; j < 10; j++) {
				if (a[i][j] == 1) {
					return false;
				}
			}
		}
		return true;
	}

	public static void main(String args[]) {
		Scanner sc = new Scanner(System.in);
		int n;
		int a[][];

		n = sc.nextInt();
		for (int i = 0; i < n; i++) {
			a = new int[10][10];
			for (int j = 0; j < 10; j++) {
				for (int k = 0; k < 10; k++) {
					a[j][k] = sc.nextInt();
				}
			}
			f(a, new int[10], 0);
			for (int j = 0; j < 10; j++) {
				String s = """";
				for (int k = 0; k < 10; k++) {
					System.out.print(s + ans[j][k]);
					s = "" "";
				}
				System.out.println();
			}
		}
	}
}",1
p00131,"博士の光電管
博士 :   ピーター君。やったよ。
ピーター : またですか。今度はどんなくだらない発明ですか。
博士 :   あの幻の素粒子アキシオンの検出器を発明したんじゃ。
ピーター : アキシオンといえば、欧州合同原子核研究機構 (CERN) をはじめとする研究者たちが血眼で追っかけているという、あれですよね。本当ですかぁ?
博士 :   本当だってばよ。細かい説明は省くが、非常に強力な磁場を内蔵する特殊な光電管が光ることによって、通過するアキシオンを検出する。
ピーター : 他 に先んじて検出すれば、小柴先生のニュートリノ検出に匹敵するノーベル賞級の研究ですよ。
       これで役立たずの研究ばかりしている「ダメ研究室」などという汚名も返上できますね。
博士 :   そうだとも。小柴先生の「スーパーカミオカンデ」にあやかって、この装置を、(悪口言ったら)「タダジャオカンデ」と命名した。
ピーター : ちょっと苦しいって言うか、卑屈って言うか・・・。
博士 :   それはいいとして、この装置ちょっとした癖があるんじゃよ。
       アキシオン粒子がある光電管を通過すると、感度の関係でその光電管と隣接する上下左右の光電管が反応する。
図1
図2
★
●
●
●
●
●
●
●
★
●
●
●
●
●
●
●
●
●
●
●
●
●
★
●
●
→
○
○
●
○
●
○
●
○
○
○
●
●
●
○
●
●
●
○
●
●
●
○
○
○
●
●
○
○
●
○
○
★
★
○
☆
●
●
○
●
●
○
●
●
○
●
●
○
○
○
●
→
●
●
●
●
●
●
●
●
○
●
●
○
●
●
○
○
●
●
○
●
●
○
○
○
●
ピーター : つまり、図1の左側★印の光電管を粒子が通過した場合、
       右側のように点灯すると言うことですね。
       (図は 5 × 5 の例。黒は消灯・白は点灯状態。以下同じ。)
博士 :   また反応とは、光電管の状態が反転する。つまり消えている光電管は光り、
       光っている光電管は消える。
ピーター : つまり、図2の左側の★印や☆印を粒子が通過した場合、右側のような状態になると。
博士 :   これを正方形になんと 100 個 (10 × 10) 配置して待ち受けるわけだ。
ピーター : これだけの大発明、ノーベル賞選考委員会も「ホッチャオカンデ」なんて。
博士 :   おぉピーター君、君も我が研究室の作風になじんできたようだね。いい感じだ。
       では、早速実験を始めよう。まずはこの装置、現在ランダムに光電管が点いているので、
       実験が始められるように全部消えた状態にリセットしてくれたまえ。
       なあに、どの光電管にアキシオン粒子を当てれば全部消えるか考えればいいだけじゃよ。
       簡単だろう?
ピーター : 考えるのはいいんですが博士。当てるためには、
       幻のアキシオン粒子を発生させて打ち込める装置がないといけないんじゃないですか。
博士 :   ・・・。
博士とピータ      (同時に)コリャアカンデ!だははは・・・・。
ー:
ということで、本日も和気あいあいと暮れてゆく博士の研究室ですが、例によって話は全く進みそうもありません。しょうがないので、ピーター君に代わってプログラムを作成してあげてください。
プログラムは次のようなものになります。
A. 装置の光電管の状態を 10 × 10 の配列として入力します。0は消灯中、1は点灯中を表します。
    0 と 1 以外のデータは含まれません。
B. 入力した装置の状態をすべて消灯にするために、アキシオン粒子を通過させる位置を計算して出力します。これは、入力と同じ 10 × 10の配列で光電管の位置を表します。「0 は通過させない」、「1 は通過させる」ことを表します。すべてを消灯する方法は必ず 1 通りだけ存在するものとします。
Input
複数のデータセットが与えられます。１行目にデータセットの数
n
(
n
≤ 20) が与えられます。各データセットは以下の形式で与えられます。
a
1,1
a
1,2
...
a
1,10
a
2,1
a
2,2
...
a
2,10
:
a
10,1
a
10,2
...
a
10,10
a
i,j
は装置の
i
行目
j
列目の光電管の状態を示す整数 (0 または 1) を表します。
Output
各データセットについて、粒子を通過させる位置を以下の形式で出力してください。
b
1,1
b
1,2
...
b
1,10
b
2,1
b
2,2
...
b
2,10
:
b
10,1
b
10,2
...
b
10,10
b
i,j
は装置の
i
行目
j
列目の光電管に粒子を通過させるかいなかを示す整数 (0 または 1) を表します。
Sample Input
1
0 1 0 0 0 0 0 0 0 0
1 1 1 0 0 0 0 0 0 0
0 1 0 0 0 0 0 0 0 0
0 0 0 0 1 1 0 0 0 0
0 0 0 1 0 0 1 0 0 0
0 0 0 0 1 1 0 0 0 0
0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 1 0
0 0 0 0 0 0 0 1 1 1
0 0 0 0 0 0 0 0 1 0
Output for the Sample Input
0 0 0 0 0 0 0 0 0 0
0 1 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0
0 0 0 0 1 1 0 0 0 0
0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 1 0
0 0 0 0 0 0 0 0 0 0",Python,"def solve_lights_out(grid):
    # This is a lights-out puzzle problem over GF(2)
    # We need to solve a system of linear equations in GF(2)
    
    # Create the coefficient matrix
    # For a 10x10 grid, we have 100 variables and 100 equations
    n = 10
    size = n * n
    
    # Build the augmented matrix [A|b]
    # A[i][j] = 1 if pressing button j affects light i
    A = [[0] * size for _ in range(size)]
    b = [0] * size
    
    # Fill the coefficient matrix
    for i in range(n):
        for j in range(n):
            light_idx = i * n + j
            b[light_idx] = grid[i][j]
            
            # Pressing button at (r, c) affects lights at (r, c) and adjacent cells
            for r in range(n):
                for c in range(n):
                    button_idx = r * n + c
                    
                    # Check if pressing button (r,c) affects light (i,j)
                    if (r == i and c == j):
                        continue  # The button itself doesn't light up
                    
                    # Check if (i,j) is adjacent to (r,c)
                    if (abs(r - i) + abs(c - j)) == 1:
                        A[light_idx][button_idx] = 1
    
    # Gaussian elimination in GF(2)
    augmented = [A[i] + [b[i]] for i in range(size)]
    
    # Forward elimination
    for col in range(size):
        # Find pivot
        pivot_row = -1
        for row in range(col, size):
            if augmented[row][col] == 1:
                pivot_row = row
                break
        
        if pivot_row == -1:
            continue
        
        # Swap rows
        augmented[col], augmented[pivot_row] = augmented[pivot_row], augmented[col]
        
        # Eliminate
        for row in range(size):
            if row != col and augmented[row][col] == 1:
                for k in range(size + 1):
                    augmented[row][k] ^= augmented[col][k]
    
    # Back substitution
    solution = [0] * size
    for i in range(size):
        if augmented[i][i] == 1:
            solution[i] = augmented[i][size]
    
    # Convert solution to 2D grid
    result = [[0] * n for _ in range(n)]
    for i in range(n):
        for j in range(n):
            result[i][j] = solution[i * n + j]
    
    return result

# Read input
n_datasets = int(input())
for _ in range(n_datasets):
    grid = []
    for i in range(10):
        row = list(map(int, input().split()))
        grid.append(row)
    
    result = solve_lights_out(grid)
    
    for row in result:
        print(' '.join(map(str, row)))
",0
p00131,"博士の光電管
博士 :   ピーター君。やったよ。
ピーター : またですか。今度はどんなくだらない発明ですか。
博士 :   あの幻の素粒子アキシオンの検出器を発明したんじゃ。
ピーター : アキシオンといえば、欧州合同原子核研究機構 (CERN) をはじめとする研究者たちが血眼で追っかけているという、あれですよね。本当ですかぁ?
博士 :   本当だってばよ。細かい説明は省くが、非常に強力な磁場を内蔵する特殊な光電管が光ることによって、通過するアキシオンを検出する。
ピーター : 他 に先んじて検出すれば、小柴先生のニュートリノ検出に匹敵するノーベル賞級の研究ですよ。
       これで役立たずの研究ばかりしている「ダメ研究室」などという汚名も返上できますね。
博士 :   そうだとも。小柴先生の「スーパーカミオカンデ」にあやかって、この装置を、(悪口言ったら)「タダジャオカンデ」と命名した。
ピーター : ちょっと苦しいって言うか、卑屈って言うか・・・。
博士 :   それはいいとして、この装置ちょっとした癖があるんじゃよ。
       アキシオン粒子がある光電管を通過すると、感度の関係でその光電管と隣接する上下左右の光電管が反応する。
図1
図2
★
●
●
●
●
●
●
●
★
●
●
●
●
●
●
●
●
●
●
●
●
●
★
●
●
→
○
○
●
○
●
○
●
○
○
○
●
●
●
○
●
●
●
○
●
●
●
○
○
○
●
●
○
○
●
○
○
★
★
○
☆
●
●
○
●
●
○
●
●
○
●
●
○
○
○
●
→
●
●
●
●
●
●
●
●
○
●
●
○
●
●
○
○
●
●
○
●
●
○
○
○
●
ピーター : つまり、図1の左側★印の光電管を粒子が通過した場合、
       右側のように点灯すると言うことですね。
       (図は 5 × 5 の例。黒は消灯・白は点灯状態。以下同じ。)
博士 :   また反応とは、光電管の状態が反転する。つまり消えている光電管は光り、
       光っている光電管は消える。
ピーター : つまり、図2の左側の★印や☆印を粒子が通過した場合、右側のような状態になると。
博士 :   これを正方形になんと 100 個 (10 × 10) 配置して待ち受けるわけだ。
ピーター : これだけの大発明、ノーベル賞選考委員会も「ホッチャオカンデ」なんて。
博士 :   おぉピーター君、君も我が研究室の作風になじんできたようだね。いい感じだ。
       では、早速実験を始めよう。まずはこの装置、現在ランダムに光電管が点いているので、
       実験が始められるように全部消えた状態にリセットしてくれたまえ。
       なあに、どの光電管にアキシオン粒子を当てれば全部消えるか考えればいいだけじゃよ。
       簡単だろう?
ピーター : 考えるのはいいんですが博士。当てるためには、
       幻のアキシオン粒子を発生させて打ち込める装置がないといけないんじゃないですか。
博士 :   ・・・。
博士とピータ      (同時に)コリャアカンデ!だははは・・・・。
ー:
ということで、本日も和気あいあいと暮れてゆく博士の研究室ですが、例によって話は全く進みそうもありません。しょうがないので、ピーター君に代わってプログラムを作成してあげてください。
プログラムは次のようなものになります。
A. 装置の光電管の状態を 10 × 10 の配列として入力します。0は消灯中、1は点灯中を表します。
    0 と 1 以外のデータは含まれません。
B. 入力した装置の状態をすべて消灯にするために、アキシオン粒子を通過させる位置を計算して出力します。これは、入力と同じ 10 × 10の配列で光電管の位置を表します。「0 は通過させない」、「1 は通過させる」ことを表します。すべてを消灯する方法は必ず 1 通りだけ存在するものとします。
Input
複数のデータセットが与えられます。１行目にデータセットの数
n
(
n
≤ 20) が与えられます。各データセットは以下の形式で与えられます。
a
1,1
a
1,2
...
a
1,10
a
2,1
a
2,2
...
a
2,10
:
a
10,1
a
10,2
...
a
10,10
a
i,j
は装置の
i
行目
j
列目の光電管の状態を示す整数 (0 または 1) を表します。
Output
各データセットについて、粒子を通過させる位置を以下の形式で出力してください。
b
1,1
b
1,2
...
b
1,10
b
2,1
b
2,2
...
b
2,10
:
b
10,1
b
10,2
...
b
10,10
b
i,j
は装置の
i
行目
j
列目の光電管に粒子を通過させるかいなかを示す整数 (0 または 1) を表します。
Sample Input
1
0 1 0 0 0 0 0 0 0 0
1 1 1 0 0 0 0 0 0 0
0 1 0 0 0 0 0 0 0 0
0 0 0 0 1 1 0 0 0 0
0 0 0 1 0 0 1 0 0 0
0 0 0 0 1 1 0 0 0 0
0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 1 0
0 0 0 0 0 0 0 1 1 1
0 0 0 0 0 0 0 0 1 0
Output for the Sample Input
0 0 0 0 0 0 0 0 0 0
0 1 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0
0 0 0 0 1 1 0 0 0 0
0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 1 0
0 0 0 0 0 0 0 0 0 0",Python,"def attack(table, i, j):
    table[i][j] = 1 - table[i][j]
    table[i-1][j] = 1 - table[i-1][j]
    table[i+1][j] = 1 - table[i+1][j]
    table[i][j-1] = 1 - table[i][j-1]
    table[i][j+1] = 1 - table[i][j+1]

def printans(ans):
    for i in range(1, 11):
        for j in range(1, 11):
            print(ans[i][j], end="""")
            if j < 10:
                print("" "", end="""")
        print("""")

def solve(table, i, j, ans):

    #print(i,j)
    if i == 11:
        flag = True
        for k in range(1,11):
            if table[10][k] == 1:
                flag = False
                break
        if flag:
            printans(ans)
        return

    if table[i-1][j] == 1:
        ans[i][j] = 1
        attack(table, i, j)
        if j == 10:
            solve(table, i+1, 1, ans)
        else:
            solve(table, i, j+1, ans)
        attack(table, i, j)
        ans[i][j] = 0
    else:
        ans[i][j] = 0
        if j == 10:
            solve(table, i+1, 1, ans)
        else:
            solve(table, i, j+1, ans)


def check(table, i, ans):

    if i == 11:
        solve(table, 2, 1, ans)
        return

    ans[1][i] = 0
    check(table, i+1, ans)

    ans[1][i] = 1
    attack(table, 1, i)
    check(table, i+1, ans)
    attack(table, 1, i)

N = int(input())

for l in range(N):
    table= [[0 for i in range(12)] for j in range(12)]
    ans= [[0 for i in range(12)] for j in range(12)]
    for i in range(1, 11):
        nums = [int(k) for k in input().split()]
        for j in range(1, 11):
            table[i][j] = nums[j-1]

    check(table, 1, ans)
",1
p00132,"ジグソーパズル
子供から大人まで脳トレ系パズルゲームが流行しています。我々も遅れを取らぬよう、パズルゲームを作ってみんなで遊ぶことにしました。
我々が考えたのはジグソーパズルのゲームで、未完成の部分を埋めるのに必要なピースを選ぶというものです。図 1 (a) はパズルの枠の例です。黒が埋まっている部分、白が未完成の部分です。このパズルを完成するのに使えるピースが図 1 (b) のように与えられます。この中から、枠の白い部分を埋めることができる黒いピースを 1 つ以上選択します。例えば、図 2 の選択例 1 のような組み合わせなら正解となります。一方、選択例 2 のような組み合わせではパズルは完成しないので不正解となります。また、選択したピースが余ってしまう場合も不正解です。このように、プレイヤーは適切なピースを選択することでゲームをクリアします。
そこでこのパズルゲームで用いる判定プログラムを開発することになりました。未完成のパズル、ピースの候補、そしてプレイヤーが選んだピースの組み合わせを入力とし、プレイヤーが適切なピースを選ぶことができていれば YES を、そうでなければ NO と出力するプログラムを作成してください。
この問題では、パズルの枠は
H × W
の配列で表し、未完成の部分を . (半角ピリオド)、完成している部分を # (半角シャープ)によって与えます。パズルの枠の大きさは最大
20 × 20
とします。また、各ピースは
h × w
の配列で表し、ピースを構成する部分を # 、そうでない部分を . によって与えます。与えられる各ピースは、元の状態から 90 度、180 度、270 度だけ回転することができます。また、各ピースの大きさは最大
20 × 20
とし、与えられるピースの数
n
は最大 10 とします。
Input
複数のデータセットが与えられます。各データセットは以下の形式で与えられます。
H
W
g
1,1
g
1,2
...
g
1,W
g
2,1
g
2,2
...
g
2,W
:
g
H,1
g
H,2
...
g
H,W
n
h
1
w
1
c1
1,1
c1
1,2
...
c1
1,w
1
c1
2,1
c1
2,2
...
c1
2,w
1
:
c1
h
1
,1
c1
h
1
,2
...
c1
h
1
,w
1
:
:
h
n
w
n
cn
1,1
cn
1,2
...
cn
1,w
n
cn
2,1
cn
2,2
...
cn
2,w
n
:
cn
h
n
,1
cn
h
n
,2
...
cn
h
n
,w
n
p
k
1
t
1
t
2
...
t
k
1
k
2
t
1
t
2
...
t
k
2
:
k
p
t
1
t
2
...
t
k
p
1 行目に、パズルの枠の大きさ
H
(縦) と
W
(横) が与えられます。
2 行目に、文字
g
i,j
(
.
または
#
) からなりパズルの盤面を表す 1 行
W
文字の文字列が
H
行与えられます。
続いてピースの数
n
、
n
個のピースの情報が与えられます。各ピースの情報として、
l
番目のピースの配列のサイズ
h
l
(縦) と
w
l
(横)、
l
番目のピースの配列が与えられます。
l
番目のピースの配列として文字
cl
i,j
(
.
または
#
) からなる 1 行
w
l
文字の文字列が
h
l
行与えられます。
続いてプレイヤーの人数
p
、
i
番目のプレイヤーの選択したピースの数
k
i
と選択したピースの番号
t
j
が与えられます。
入力は２つの 0 を含む行で終了します。データセットの数は 10 を超えません。
Output
各データセットごとに、
i
番目のプレイヤーが選択したピースの正否 YES または NO を
i
行目に出力してください。
Sample Input
14 20
####################
###.............####
####..........######
#######.....########
########.....#######
###..###......######
###..####......#####
#########......#####
###########.....####
############.....###
###.########......##
###.#######...###.##
##...###....#####.##
####################
10
12 15
#############..
.##########....
....#####......
.....#####.....
.....######....
......######...
......######...
........#####..
.........#####.
.........######
........###...#
.....####.....#
3 3
#..
###
#..
2 2
##
##
4 10
....#####.
....######
...###...#
####.....#
6 5
....#
..###
#####
##.##
#..##
#..#.
6 4
...#
.###
####
##.#
##.#
#...
2 6
######
.#####
2 7
..#####
#######
2 13
#############
.##########..
6 9
#####....
.######..
.######..
..######.
...#####.
....#####
8
3 1 2 3
4 1 2 3 4
7 2 3 4 5 6 7 8
5 2 3 10 7 8
6 2 3 9 5 6 4
8 2 3 4 6 9 5 4 10
4 4 5 6 9
5 10 2 3 4 9
0 0
Output for the Sample Input
YES
NO
YES
NO
YES
NO
NO
YES",C,"#include <stdio.h>
#include <string.h>
#include <stdlib.h>

#define MAX_SIZE 20
#define MAX_PIECES 10

char grid[MAX_SIZE][MAX_SIZE+1];
char pieces[MAX_PIECES][MAX_SIZE][MAX_SIZE+1];
int piece_h[MAX_PIECES], piece_w[MAX_PIECES];
int H, W, n;

typedef struct {
    char data[MAX_SIZE][MAX_SIZE+1];
    int h, w;
} Piece;

void rotate90(Piece *src, Piece *dst) {
    dst->h = src->w;
    dst->w = src->h;
    for (int i = 0; i < dst->h; i++) {
        for (int j = 0; j < dst->w; j++) {
            dst->data[i][j] = src->data[src->h - 1 - j][i];
        }
        dst->data[i][dst->w] = '\0';
    }
}

int canPlace(char board[MAX_SIZE][MAX_SIZE+1], Piece *p, int y, int x) {
    for (int i = 0; i < p->h; i++) {
        for (int j = 0; j < p->w; j++) {
            if (p->data[i][j] == '#') {
                if (y + i >= H || x + j >= W || board[y+i][x+j] != '.') {
                    return 0;
                }
            }
        }
    }
    return 1;
}

void place(char board[MAX_SIZE][MAX_SIZE+1], Piece *p, int y, int x) {
    for (int i = 0; i < p->h; i++) {
        for (int j = 0; j < p->w; j++) {
            if (p->data[i][j] == '#') {
                board[y+i][x+j] = '#';
            }
        }
    }
}

void unplace(char board[MAX_SIZE][MAX_SIZE+1], Piece *p, int y, int x) {
    for (int i = 0; i < p->h; i++) {
        for (int j = 0; j < p->w; j++) {
            if (p->data[i][j] == '#') {
                board[y+i][x+j] = '.';
            }
        }
    }
}

int isComplete(char board[MAX_SIZE][MAX_SIZE+1]) {
    for (int i = 0; i < H; i++) {
        for (int j = 0; j < W; j++) {
            if (board[i][j] == '.') return 0;
        }
    }
    return 1;
}

int solve(char board[MAX_SIZE][MAX_SIZE+1], Piece rotations[][4], int selected[], int k, int used[], int idx) {
    if (isComplete(board)) {
        for (int i = 0; i < k; i++) {
            if (!used[i]) return 0;
        }
        return 1;
    }
    
    if (idx >= k) return 0;
    
    for (int pi = 0; pi < k; pi++) {
        if (used[pi]) continue;
        
        for (int rot = 0; rot < 4; rot++) {
            for (int y = 0; y < H; y++) {
                for (int x = 0; x < W; x++) {
                    if (canPlace(board, &rotations[pi][rot], y, x)) {
                        place(board, &rotations[pi][rot], y, x);
                        used[pi] = 1;
                        if (solve(board, rotations, selected, k, used, idx + 1)) {
                            return 1;
                        }
                        used[pi] = 0;
                        unplace(board, &rotations[pi][rot], y, x);
                    }
                }
            }
        }
    }
    
    return 0;
}

int checkPlayer(int selected[], int k) {
    char board[MAX_SIZE][MAX_SIZE+1];
    for (int i = 0; i < H; i++) {
        strcpy(board[i], grid[i]);
    }
    
    Piece rotations[MAX_PIECES][4];
    for (int i = 0; i < k; i++) {
        int idx = selected[i] - 1;
        rotations[i][0].h = piece_h[idx];
        rotations[i][0].w = piece_w[idx];
        for (int r = 0; r < piece_h[idx]; r++) {
            strcpy(rotations[i][0].data[r], pieces[idx][r]);
        }
        
        rotate90(&rotations[i][0], &rotations[i][1]);
        rotate90(&rotations[i][1], &rotations[i][2]);
        rotate90(&rotations[i][2], &rotations[i][3]);
    }
    
    int used[MAX_PIECES] = {0};
    return solve(board, rotations, selected, k, used, 0);
}

int main() {
    while (1) {
        scanf(""%d %d"", &H, &W);
        if (H == 0 && W == 0) break;
        
        for (int i = 0; i < H; i++) {
            scanf(""%s"", grid[i]);
        }
        
        scanf(""%d"", &n);
        for (int i = 0; i < n; i++) {
            scanf(""%d %d"", &piece_h[i], &piece_w[i]);
            for (int j = 0; j < piece_h[i]; j++) {
                scanf(""%s"", pieces[i][j]);
            }
        }
        
        int p;
        scanf(""%d"", &p);
        for (int i = 0; i < p; i++) {
            int k;
            scanf(""%d"", &k);
            int selected[MAX_PIECES];
            for (int j = 0; j < k; j++) {
                scanf(""%d"", &selected[j]);
            }
            
            if (checkPlayer(selected, k)) {
                printf(""YES\n"");
            } else {
                printf(""NO\n"");
            }
        }
    }
    
    return 0;
}
",0
p00132,"ジグソーパズル
子供から大人まで脳トレ系パズルゲームが流行しています。我々も遅れを取らぬよう、パズルゲームを作ってみんなで遊ぶことにしました。
我々が考えたのはジグソーパズルのゲームで、未完成の部分を埋めるのに必要なピースを選ぶというものです。図 1 (a) はパズルの枠の例です。黒が埋まっている部分、白が未完成の部分です。このパズルを完成するのに使えるピースが図 1 (b) のように与えられます。この中から、枠の白い部分を埋めることができる黒いピースを 1 つ以上選択します。例えば、図 2 の選択例 1 のような組み合わせなら正解となります。一方、選択例 2 のような組み合わせではパズルは完成しないので不正解となります。また、選択したピースが余ってしまう場合も不正解です。このように、プレイヤーは適切なピースを選択することでゲームをクリアします。
そこでこのパズルゲームで用いる判定プログラムを開発することになりました。未完成のパズル、ピースの候補、そしてプレイヤーが選んだピースの組み合わせを入力とし、プレイヤーが適切なピースを選ぶことができていれば YES を、そうでなければ NO と出力するプログラムを作成してください。
この問題では、パズルの枠は
H × W
の配列で表し、未完成の部分を . (半角ピリオド)、完成している部分を # (半角シャープ)によって与えます。パズルの枠の大きさは最大
20 × 20
とします。また、各ピースは
h × w
の配列で表し、ピースを構成する部分を # 、そうでない部分を . によって与えます。与えられる各ピースは、元の状態から 90 度、180 度、270 度だけ回転することができます。また、各ピースの大きさは最大
20 × 20
とし、与えられるピースの数
n
は最大 10 とします。
Input
複数のデータセットが与えられます。各データセットは以下の形式で与えられます。
H
W
g
1,1
g
1,2
...
g
1,W
g
2,1
g
2,2
...
g
2,W
:
g
H,1
g
H,2
...
g
H,W
n
h
1
w
1
c1
1,1
c1
1,2
...
c1
1,w
1
c1
2,1
c1
2,2
...
c1
2,w
1
:
c1
h
1
,1
c1
h
1
,2
...
c1
h
1
,w
1
:
:
h
n
w
n
cn
1,1
cn
1,2
...
cn
1,w
n
cn
2,1
cn
2,2
...
cn
2,w
n
:
cn
h
n
,1
cn
h
n
,2
...
cn
h
n
,w
n
p
k
1
t
1
t
2
...
t
k
1
k
2
t
1
t
2
...
t
k
2
:
k
p
t
1
t
2
...
t
k
p
1 行目に、パズルの枠の大きさ
H
(縦) と
W
(横) が与えられます。
2 行目に、文字
g
i,j
(
.
または
#
) からなりパズルの盤面を表す 1 行
W
文字の文字列が
H
行与えられます。
続いてピースの数
n
、
n
個のピースの情報が与えられます。各ピースの情報として、
l
番目のピースの配列のサイズ
h
l
(縦) と
w
l
(横)、
l
番目のピースの配列が与えられます。
l
番目のピースの配列として文字
cl
i,j
(
.
または
#
) からなる 1 行
w
l
文字の文字列が
h
l
行与えられます。
続いてプレイヤーの人数
p
、
i
番目のプレイヤーの選択したピースの数
k
i
と選択したピースの番号
t
j
が与えられます。
入力は２つの 0 を含む行で終了します。データセットの数は 10 を超えません。
Output
各データセットごとに、
i
番目のプレイヤーが選択したピースの正否 YES または NO を
i
行目に出力してください。
Sample Input
14 20
####################
###.............####
####..........######
#######.....########
########.....#######
###..###......######
###..####......#####
#########......#####
###########.....####
############.....###
###.########......##
###.#######...###.##
##...###....#####.##
####################
10
12 15
#############..
.##########....
....#####......
.....#####.....
.....######....
......######...
......######...
........#####..
.........#####.
.........######
........###...#
.....####.....#
3 3
#..
###
#..
2 2
##
##
4 10
....#####.
....######
...###...#
####.....#
6 5
....#
..###
#####
##.##
#..##
#..#.
6 4
...#
.###
####
##.#
##.#
#...
2 6
######
.#####
2 7
..#####
#######
2 13
#############
.##########..
6 9
#####....
.######..
.######..
..######.
...#####.
....#####
8
3 1 2 3
4 1 2 3 4
7 2 3 4 5 6 7 8
5 2 3 10 7 8
6 2 3 9 5 6 4
8 2 3 4 6 9 5 4 10
4 4 5 6 9
5 10 2 3 4 9
0 0
Output for the Sample Input
YES
NO
YES
NO
YES
NO
NO
YES",C,"#include <stdio.h>          // printf(), scanf()
#include <stdlib.h>         // qsort()
#include <string.h>         // memset(), memcpy(), strchr()
#include <stdbool.h>

// #define DEBUG 1

#define MAX_W 20
#define MAX_H 20
#define MAX_N 10

typedef struct order_tbl
{
	int s;
	int bx;
	int by;
	int angle;
	double rate;
} order_t;

const char NUL = '\0';

#ifdef DEBUG
static int O = 0;
#endif

int H, W;
char field[MAX_H][MAX_W + 1];
char puzzle[MAX_H][MAX_W + 1];
int n;
int h0[MAX_N][4];
int w0[MAX_N][4];
char piece[MAX_N][4][MAX_H][MAX_W + 1];
int k;
int t[MAX_N];

void
bury(order_t *u)
{
	int s = u->s;
	int a = u->angle;
	int h = h0[s][a];
	int w = w0[s][a];

	for (int y = 0; y < h; ++y)
	{
		for (int x = 0; x < w; ++x)
		{
			if (piece[s][a][y][x] == '#')
				field[u->by + y][u->bx + x] = '*';
		}
	}
}

double
fitin(order_t *u, int a, int bx, int by)
{
	int s = u->s;
	int h = h0[s][a];
	int w = w0[s][a];

	int dx[4] = { 0, 1, 0,-1};
	int dy[4] = { 1, 0,-1, 0};

	int count = 0;
	int total = 0;
	for (int x = -1; x <= w; ++x)
	{
		int nx = bx + x;
		for (int y = -1; y <= h; ++y)
		{
			int ny = by + y;
			if (0 <= x && x < w && 0 <= y && y < h && piece[s][a][y][x] == '#')
			{
				if (0 <= nx && nx < W && 0 <= ny && ny < H && field[ny][nx] != '.')
					return -100.0;
			}
			else // piece[s][a][y][x] == '.' ?
			{
				int i;
				for (i = 0; i < 4; ++i)
				{
					int tx = x + dx[i], ty = y + dy[i];
					if (0 <= tx && tx < w && 0 <= ty && ty < h && piece[s][a][ty][tx] == '#')
						break;
				}

				if (i < 4)
				{
					total++;
					if (nx < 0 || W <= nx || ny < 0 || H <= ny || field[ny][nx] != '.')
						count++;
				}
			}
		}
	}

	return count * 100.0 / total;
}

void
probe(order_t *u)
{
	int s = u->s;
	for (int a = 0; a < 4; ++a)
	{
		int h = h0[s][a];
		int w = w0[s][a];

		int fx = strchr(piece[s][a][0], '#') - piece[s][a][0];
		for (int by = 0; by + h <= H; ++by)
		{
			for (int bx = 0; bx + w <= W; ++bx)
			{
				if (field[by][bx + fx] == '.')
				{
#ifdef DEBUG
					O++;
#endif
					double r = fitin(u, a, bx, by);
					if (r > u->rate)
					{
						u->rate = r;
						u->bx = bx;
						u->by = by;
						u->angle = a;

						if (u->rate >= 100.0)
						{
							bury(u);
							return;
						}
					}
				}
			}
		}
	}
}

int
cmp_func(const void *l_, const void *r_)
{
	const order_t *l = (const order_t*) l_;
	const order_t *r = (const order_t*) r_;

	if (l->rate < r->rate)
		return 1;

	if (l->rate > r->rate)
		return -1;

	return 0;
}

bool
solve()
{
	order_t u;
	order_t order[MAX_N];
	int memo[MAX_N];
	int ix, ix2;

	memcpy(field, puzzle, sizeof(field));
	ix = 0;
	for (int i = 0; i < k; ++i)
		memo[ix++] = t[i];

	while (ix != 0)
	{
		ix2 = 0;
		for (int i = 0; i < ix; ++i)
		{
#ifdef DEBUG
			memset(&u, 0x00, sizeof(u));
#endif
			u.s = memo[i];
			u.rate = -100.0;
			probe(&u);
			if (u.rate != 100.0)
				order[ix2++] = u;
		}

		if (ix2 == 0)
			break;

		qsort(order, ix2, sizeof(order_t), cmp_func);
		if (order[0].rate == -100.0)
			return false;

		bury(&order[0]);

		ix = 0;
		for (int i = 1; i < ix2; ++i)
			memo[ix++] = order[i].s;
	}

	for (int y = 0; y < H; ++y)
	{
		for (int x = 0; x < W; ++x)
		{
			if (field[y][x] == '.')
				return false;
		}
	}

	return true;
}

int
main(int argc, char **argv)
{
	while (true)
	{
		scanf(""%d%d\n"", &H, &W);
		if (H == 0 && W == 0)
			break;

		for (int i = 0; i < H; ++i)
			scanf(""%s"", &puzzle[i][0]);

		scanf(""%d"", &n);
		for (int s = 0; s < n; ++s)
		{
			scanf(""%d%d\n"", &h0[s][0], &w0[s][0]);
			int h = h0[s][0];
			int w = w0[s][0];

			for (int y = 0; y < h; ++y)
				scanf(""%s"", &piece[s][0][y][0]);

			h0[s][1] = w;
			w0[s][1] = h;
			for (int y = 0; y < h; ++y)
			{
				for (int x = 0; x < w; ++x)
					piece[s][1][x][h - y - 1] = piece[s][0][y][x];
			}

#ifdef DEBUG
			for (int x = 0; x < w; ++x)
				piece[s][1][x][h] = NUL;
#endif

			h0[s][2] = h;
			w0[s][2] = w;
			for (int y = 0; y < h; ++y)
			{
				for (int x = 0; x < w; ++x)
					piece[s][2][h - 1 - y][w - 1 - x] = piece[s][0][y][x];

#ifdef DEBUG
				piece[s][2][h - 1 - y][w] = NUL;
#endif
			}

			w0[s][3] = h;
			h0[s][3] = w;
			for (int y = 0; y < h; ++y)
			{
				for (int x = 0; x < w; ++x)
					piece[s][3][w - 1 - x][y] = piece[s][0][y][x];
			}

#ifdef DEBUG
			for (int x = 0; x < w; ++x)
				piece[s][3][x][h] = NUL;
#endif
		}

		int p;
		scanf(""%d"", &p);
		for (int i = 0; i < p; ++i)
		{
			scanf(""%d"", &k);
			for (int j = 0; j < k; ++j)
			{
				scanf(""%d"", &t[j]);
				t[j]--;
			}

			printf(""%s\n"", solve() ? ""YES"" : ""NO"");
		}
	}

#ifdef DEBUG
	fprintf(stderr, ""O:%d\n"", O);
#endif
	return 0;
}",1
p00132,"ジグソーパズル
子供から大人まで脳トレ系パズルゲームが流行しています。我々も遅れを取らぬよう、パズルゲームを作ってみんなで遊ぶことにしました。
我々が考えたのはジグソーパズルのゲームで、未完成の部分を埋めるのに必要なピースを選ぶというものです。図 1 (a) はパズルの枠の例です。黒が埋まっている部分、白が未完成の部分です。このパズルを完成するのに使えるピースが図 1 (b) のように与えられます。この中から、枠の白い部分を埋めることができる黒いピースを 1 つ以上選択します。例えば、図 2 の選択例 1 のような組み合わせなら正解となります。一方、選択例 2 のような組み合わせではパズルは完成しないので不正解となります。また、選択したピースが余ってしまう場合も不正解です。このように、プレイヤーは適切なピースを選択することでゲームをクリアします。
そこでこのパズルゲームで用いる判定プログラムを開発することになりました。未完成のパズル、ピースの候補、そしてプレイヤーが選んだピースの組み合わせを入力とし、プレイヤーが適切なピースを選ぶことができていれば YES を、そうでなければ NO と出力するプログラムを作成してください。
この問題では、パズルの枠は
H × W
の配列で表し、未完成の部分を . (半角ピリオド)、完成している部分を # (半角シャープ)によって与えます。パズルの枠の大きさは最大
20 × 20
とします。また、各ピースは
h × w
の配列で表し、ピースを構成する部分を # 、そうでない部分を . によって与えます。与えられる各ピースは、元の状態から 90 度、180 度、270 度だけ回転することができます。また、各ピースの大きさは最大
20 × 20
とし、与えられるピースの数
n
は最大 10 とします。
Input
複数のデータセットが与えられます。各データセットは以下の形式で与えられます。
H
W
g
1,1
g
1,2
...
g
1,W
g
2,1
g
2,2
...
g
2,W
:
g
H,1
g
H,2
...
g
H,W
n
h
1
w
1
c1
1,1
c1
1,2
...
c1
1,w
1
c1
2,1
c1
2,2
...
c1
2,w
1
:
c1
h
1
,1
c1
h
1
,2
...
c1
h
1
,w
1
:
:
h
n
w
n
cn
1,1
cn
1,2
...
cn
1,w
n
cn
2,1
cn
2,2
...
cn
2,w
n
:
cn
h
n
,1
cn
h
n
,2
...
cn
h
n
,w
n
p
k
1
t
1
t
2
...
t
k
1
k
2
t
1
t
2
...
t
k
2
:
k
p
t
1
t
2
...
t
k
p
1 行目に、パズルの枠の大きさ
H
(縦) と
W
(横) が与えられます。
2 行目に、文字
g
i,j
(
.
または
#
) からなりパズルの盤面を表す 1 行
W
文字の文字列が
H
行与えられます。
続いてピースの数
n
、
n
個のピースの情報が与えられます。各ピースの情報として、
l
番目のピースの配列のサイズ
h
l
(縦) と
w
l
(横)、
l
番目のピースの配列が与えられます。
l
番目のピースの配列として文字
cl
i,j
(
.
または
#
) からなる 1 行
w
l
文字の文字列が
h
l
行与えられます。
続いてプレイヤーの人数
p
、
i
番目のプレイヤーの選択したピースの数
k
i
と選択したピースの番号
t
j
が与えられます。
入力は２つの 0 を含む行で終了します。データセットの数は 10 を超えません。
Output
各データセットごとに、
i
番目のプレイヤーが選択したピースの正否 YES または NO を
i
行目に出力してください。
Sample Input
14 20
####################
###.............####
####..........######
#######.....########
########.....#######
###..###......######
###..####......#####
#########......#####
###########.....####
############.....###
###.########......##
###.#######...###.##
##...###....#####.##
####################
10
12 15
#############..
.##########....
....#####......
.....#####.....
.....######....
......######...
......######...
........#####..
.........#####.
.........######
........###...#
.....####.....#
3 3
#..
###
#..
2 2
##
##
4 10
....#####.
....######
...###...#
####.....#
6 5
....#
..###
#####
##.##
#..##
#..#.
6 4
...#
.###
####
##.#
##.#
#...
2 6
######
.#####
2 7
..#####
#######
2 13
#############
.##########..
6 9
#####....
.######..
.######..
..######.
...#####.
....#####
8
3 1 2 3
4 1 2 3 4
7 2 3 4 5 6 7 8
5 2 3 10 7 8
6 2 3 9 5 6 4
8 2 3 4 6 9 5 4 10
4 4 5 6 9
5 10 2 3 4 9
0 0
Output for the Sample Input
YES
NO
YES
NO
YES
NO
NO
YES",Java,"import java.util.*;
import java.io.*;

public class Main {
    static char[][] grid;
    static List<char[][]> pieces;
    static int H, W;
    
    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        String line;
        
        while ((line = br.readLine()) != null) {
            String[] hw = line.trim().split(""\\s+"");
            H = Integer.parseInt(hw[0]);
            W = Integer.parseInt(hw[1]);
            
            if (H == 0 && W == 0) break;
            
            grid = new char[H][W];
            for (int i = 0; i < H; i++) {
                String row = br.readLine();
                grid[i] = row.toCharArray();
            }
            
            int n = Integer.parseInt(br.readLine().trim());
            pieces = new ArrayList<>();
            
            for (int i = 0; i < n; i++) {
                String[] size = br.readLine().trim().split(""\\s+"");
                int h = Integer.parseInt(size[0]);
                int w = Integer.parseInt(size[1]);
                char[][] piece = new char[h][w];
                for (int j = 0; j < h; j++) {
                    String row = br.readLine();
                    piece[j] = row.toCharArray();
                }
                pieces.add(piece);
            }
            
            int p = Integer.parseInt(br.readLine().trim());
            
            for (int i = 0; i < p; i++) {
                String[] selection = br.readLine().trim().split(""\\s+"");
                int k = Integer.parseInt(selection[0]);
                List<Integer> selected = new ArrayList<>();
                for (int j = 1; j <= k; j++) {
                    selected.add(Integer.parseInt(selection[j]) - 1);
                }
                
                if (canSolve(selected)) {
                    System.out.println(""YES"");
                } else {
                    System.out.println(""NO"");
                }
            }
        }
    }
    
    static boolean canSolve(List<Integer> selected) {
        char[][] testGrid = new char[H][W];
        for (int i = 0; i < H; i++) {
            for (int j = 0; j < W; j++) {
                testGrid[i][j] = grid[i][j];
            }
        }
        
        return tryPlace(testGrid, selected, 0);
    }
    
    static boolean tryPlace(char[][] testGrid, List<Integer> selected, int idx) {
        if (idx == selected.size()) {
            return isComplete(testGrid);
        }
        
        int pieceIdx = selected.get(idx);
        char[][] piece = pieces.get(pieceIdx);
        
        for (int rot = 0; rot < 4; rot++) {
            char[][] rotated = rotate(piece, rot);
            for (int i = 0; i <= H - rotated.length; i++) {
                for (int j = 0; j <= W - rotated[0].length; j++) {
                    if (canPlace(testGrid, rotated, i, j)) {
                        char[][] backup = copyGrid(testGrid);
                        place(testGrid, rotated, i, j);
                        if (tryPlace(testGrid, selected, idx + 1)) {
                            return true;
                        }
                        restoreGrid(testGrid, backup);
                    }
                }
            }
        }
        
        return false;
    }
    
    static boolean canPlace(char[][] testGrid, char[][] piece, int r, int c) {
        for (int i = 0; i < piece.length; i++) {
            for (int j = 0; j < piece[0].length; j++) {
                if (piece[i][j] == '#') {
                    if (testGrid[r + i][c + j] != '.') {
                        return false;
                    }
                }
            }
        }
        return true;
    }
    
    static void place(char[][] testGrid, char[][] piece, int r, int c) {
        for (int i = 0; i < piece.length; i++) {
            for (int j = 0; j < piece[0].length; j++) {
                if (piece[i][j] == '#') {
                    testGrid[r + i][c + j] = '#';
                }
            }
        }
    }
    
    static boolean isComplete(char[][] testGrid) {
        for (int i = 0; i < H; i++) {
            for (int j = 0; j < W; j++) {
                if (testGrid[i][j] == '.') {
                    return false;
                }
            }
        }
        return true;
    }
    
    static char[][] rotate(char[][] piece, int times) {
        char[][] result = piece;
        for (int t = 0; t < times; t++) {
            int h = result.length;
            int w = result[0].length;
            char[][] newPiece = new char[w][h];
            for (int i = 0; i < h; i++) {
                for (int j = 0; j < w; j++) {
                    newPiece[j][h - 1 - i] = result[i][j];
                }
            }
            result = newPiece;
        }
        return result;
    }
    
    static char[][] copyGrid(char[][] grid) {
        char[][] copy = new char[grid.length][grid[0].length];
        for (int i = 0; i < grid.length; i++) {
            for (int j = 0; j < grid[0].length; j++) {
                copy[i][j] = grid[i][j];
            }
        }
        return copy;
    }
    
    static void restoreGrid(char[][] grid, char[][] backup) {
        for (int i = 0; i < grid.length; i++) {
            for (int j = 0; j < grid[0].length; j++) {
                grid[i][j] = backup[i][j];
            }
        }
    }
}
",0
p00132,"ジグソーパズル
子供から大人まで脳トレ系パズルゲームが流行しています。我々も遅れを取らぬよう、パズルゲームを作ってみんなで遊ぶことにしました。
我々が考えたのはジグソーパズルのゲームで、未完成の部分を埋めるのに必要なピースを選ぶというものです。図 1 (a) はパズルの枠の例です。黒が埋まっている部分、白が未完成の部分です。このパズルを完成するのに使えるピースが図 1 (b) のように与えられます。この中から、枠の白い部分を埋めることができる黒いピースを 1 つ以上選択します。例えば、図 2 の選択例 1 のような組み合わせなら正解となります。一方、選択例 2 のような組み合わせではパズルは完成しないので不正解となります。また、選択したピースが余ってしまう場合も不正解です。このように、プレイヤーは適切なピースを選択することでゲームをクリアします。
そこでこのパズルゲームで用いる判定プログラムを開発することになりました。未完成のパズル、ピースの候補、そしてプレイヤーが選んだピースの組み合わせを入力とし、プレイヤーが適切なピースを選ぶことができていれば YES を、そうでなければ NO と出力するプログラムを作成してください。
この問題では、パズルの枠は
H × W
の配列で表し、未完成の部分を . (半角ピリオド)、完成している部分を # (半角シャープ)によって与えます。パズルの枠の大きさは最大
20 × 20
とします。また、各ピースは
h × w
の配列で表し、ピースを構成する部分を # 、そうでない部分を . によって与えます。与えられる各ピースは、元の状態から 90 度、180 度、270 度だけ回転することができます。また、各ピースの大きさは最大
20 × 20
とし、与えられるピースの数
n
は最大 10 とします。
Input
複数のデータセットが与えられます。各データセットは以下の形式で与えられます。
H
W
g
1,1
g
1,2
...
g
1,W
g
2,1
g
2,2
...
g
2,W
:
g
H,1
g
H,2
...
g
H,W
n
h
1
w
1
c1
1,1
c1
1,2
...
c1
1,w
1
c1
2,1
c1
2,2
...
c1
2,w
1
:
c1
h
1
,1
c1
h
1
,2
...
c1
h
1
,w
1
:
:
h
n
w
n
cn
1,1
cn
1,2
...
cn
1,w
n
cn
2,1
cn
2,2
...
cn
2,w
n
:
cn
h
n
,1
cn
h
n
,2
...
cn
h
n
,w
n
p
k
1
t
1
t
2
...
t
k
1
k
2
t
1
t
2
...
t
k
2
:
k
p
t
1
t
2
...
t
k
p
1 行目に、パズルの枠の大きさ
H
(縦) と
W
(横) が与えられます。
2 行目に、文字
g
i,j
(
.
または
#
) からなりパズルの盤面を表す 1 行
W
文字の文字列が
H
行与えられます。
続いてピースの数
n
、
n
個のピースの情報が与えられます。各ピースの情報として、
l
番目のピースの配列のサイズ
h
l
(縦) と
w
l
(横)、
l
番目のピースの配列が与えられます。
l
番目のピースの配列として文字
cl
i,j
(
.
または
#
) からなる 1 行
w
l
文字の文字列が
h
l
行与えられます。
続いてプレイヤーの人数
p
、
i
番目のプレイヤーの選択したピースの数
k
i
と選択したピースの番号
t
j
が与えられます。
入力は２つの 0 を含む行で終了します。データセットの数は 10 を超えません。
Output
各データセットごとに、
i
番目のプレイヤーが選択したピースの正否 YES または NO を
i
行目に出力してください。
Sample Input
14 20
####################
###.............####
####..........######
#######.....########
########.....#######
###..###......######
###..####......#####
#########......#####
###########.....####
############.....###
###.########......##
###.#######...###.##
##...###....#####.##
####################
10
12 15
#############..
.##########....
....#####......
.....#####.....
.....######....
......######...
......######...
........#####..
.........#####.
.........######
........###...#
.....####.....#
3 3
#..
###
#..
2 2
##
##
4 10
....#####.
....######
...###...#
####.....#
6 5
....#
..###
#####
##.##
#..##
#..#.
6 4
...#
.###
####
##.#
##.#
#...
2 6
######
.#####
2 7
..#####
#######
2 13
#############
.##########..
6 9
#####....
.######..
.######..
..######.
...#####.
....#####
8
3 1 2 3
4 1 2 3 4
7 2 3 4 5 6 7 8
5 2 3 10 7 8
6 2 3 9 5 6 4
8 2 3 4 6 9 5 4 10
4 4 5 6 9
5 10 2 3 4 9
0 0
Output for the Sample Input
YES
NO
YES
NO
YES
NO
NO
YES",Java,"import java.io.IOException;
import java.io.InputStream;
import java.io.PrintWriter;
import java.util.*;
import java.util.Calendar.Builder;

import javax.jws.soap.SOAPBinding.Use;



public class Main {
	static int H;
	static int W;
	static int[] map;
	static Piece[] p;
	public static void main(String[] args) {	
		FastScanner sc = new FastScanner();
		//Scanner sc = new Scanner(System.in);
		PrintWriter out = new PrintWriter(System.out);
		while(true) {
			H = sc.nextInt();
			W = sc.nextInt();
			if(H == 0 && W == 0) break;
			map = new int[H];
			int mapCount = 0;
			for(int i = 0; i < H; i++) {
				String in = sc.next();
				in = in.replace('.', '0');
				in = in.replace('#', '1');
				int bin = Integer.parseInt(in,2);
				map[i] = bin;
				mapCount += W - Integer.bitCount(bin);
			}
			int n = sc.nextInt();
			p = new Piece[n];
			for(int i = 0; i < n; i++) {
				int h = sc.nextInt();
				int w = sc.nextInt();
				String[] map = new String[h];
				for(int j = 0; j < h; j++) {
					String in = sc.next();
					map[j] = in;
				}
				p[i] = new Piece(h,w,map);
			}
			
			int p = sc.nextInt();
			for(int i = 0; i < p; i++) {
				int k = sc.nextInt();
				int[] t = new int[k];
				for(int j = 0; j < k; j++) {
					t[j] = sc.nextInt()-1;
				}
				int bitCount = 0;
				for(int j = 0; j < k; j++) {
					for(int l = 0; l < Main.p[t[j]].h[0]; l++) {
						bitCount += Integer.bitCount(Main.p[t[j]].map[0][l]);
					}
				}
				boolean ans = false;
				if(bitCount == mapCount) {
					ans = check(new boolean[k],t,map,0,0,0);
				}
				if(ans) System.out.println(""YES"");
				else System.out.println(""NO"");
			}
		}
	}
	static boolean check(boolean[] used, int[] use, int[] map, int y, int x,int c) {
		if(x == W) return check(used,use,map,y+1,0,c);
		if(y == H && c == use.length) {
			return true;
		}
		else if(y == H) return false;
		if((map[y] & (1 << (W - x - 1))) == 0) {
			for(int i = 0; i < use.length; i++) {
				if(used[i]) continue;
				int sel = use[i];
				for(int j = 0; j < 4; j++) {
					int xx = x - p[sel].vw[j];
					if(xx < 0) continue;
					boolean cf = checkCanFill(y,xx,j,map,p[sel]);
					if(!cf) continue;
					fill(y,xx,j,map,p[sel]);
					used[i] = true;
					boolean rt = check(used,use,map,y,x+1,c+1);
					if(rt) {
						used[i] = false;
						fill(y,xx,j,map,p[sel]);
						return true;
					}
					used[i] = false;
					fill(y,xx,j,map,p[sel]);
				}
			}
			return false;
		}
		else {
			return check(used,use,map,y,x+1,c);
		}
	}
	static boolean checkCanFill(int A, int B, int C,int[] map, Piece p) {
		if(p.h[C] + A > H) return false;
		if(p.w[C] + B > W || W - p.w[C] - B < 0) return false;
		for(int i = 0; i < p.h[C]; i++) {
			if((map[i + A] & (p.map[C][i] << (W - p.w[C] - B))) != 0) return false;
		}
		return true;
	}
	static void fill(int A, int B, int C, int[] map, Piece p) {
		for(int i = 0; i < p.h[C]; i++) {
			map[i + A] ^= (p.map[C][i] << (W - p.w[C] - B));
		}
	}
	static boolean checkFill(int[] map) {
		for(int i = 0; i < H; i++) {
			if(map[i] != (1 << W)-1) return false;
		}
		return true;
	}
	
	static String[] rotate(String[] map) {
		char[][] in = new char[map.length][];
		for(int i = 0; i < map.length; i++) {
			in[i] = map[i].toCharArray();
		}
		char[][] ret = new char[in[0].length][in.length];
		for(int i = 0; i < in[0].length; i++) {
			for(int j = 0; j < in.length; j++) {
				ret[i][j] = in[in.length - j - 1][i];
			}
		}
		String[] retu = new String[ret.length];
		for(int i = 0; i < ret.length; i++) {
			retu[i] = String.valueOf(ret[i]);
		}
		return retu;
		
	}
	
	
	static class Piece {
		int[] h;
		int[] w;
		int[][] map;
		int[] vw;
		Piece(int a, int b, String[] c) {
			h = new int[4];
			w = new int[4];
			vw = new int[4];
			map = new int[4][];
			for(int i = 0; i < 4; i++) {
				h[i] = a;
				w[i] = b;
				map[i] = new int[h[i]];
				for(int j = 0; j < w[i]; j++) {
					if(c[0].charAt(j) == '#') {
						vw[i] = j;
						break;
					}
				}
				for(int j = 0; j < h[i]; j++) {
					String in = c[j];
					in = in.replace('.', '0');
					in = in.replace('#', '1');
					int bin = Integer.parseInt(in,2);
					map[i][j] = bin;
				}
				int tmp = a;
				a = b;
				b = tmp;
				c = rotate(c);
			}
		}
	}

}

class FastScanner {
    private final InputStream in = System.in;
    private final byte[] buffer = new byte[1024];
    private int ptr = 0;
    private int buflen = 0;
    private boolean hasNextByte() {
        if (ptr < buflen) {
            return true;
        }else{
            ptr = 0;
            try {
                buflen = in.read(buffer);
            } catch (IOException e) {
                e.printStackTrace();
            }
            if (buflen <= 0) {
                return false;
            }
        }
        return true;
    }
    private int readByte() { if (hasNextByte()) return buffer[ptr++]; else return -1;}
    private static boolean isPrintableChar(int c) { return 33 <= c && c <= 126;}
    private void skipUnprintable() { while(hasNextByte() && !isPrintableChar(buffer[ptr])) ptr++;}
    public boolean hasNext() { skipUnprintable(); return hasNextByte();}
    public String next() {
        if (!hasNext()) throw new NoSuchElementException();
        StringBuilder sb = new StringBuilder();
        int b = readByte();
        while(isPrintableChar(b)) {
            sb.appendCodePoint(b);
            b = readByte();
        }
        return sb.toString();
    }
    public long nextLong() {
        if (!hasNext()) throw new NoSuchElementException();
        long n = 0;
        boolean minus = false;
        int b = readByte();
        if (b == '-') {
            minus = true;
            b = readByte();
        }
        if (b < '0' || '9' < b) {
            throw new NumberFormatException();
        }
        while(true){
            if ('0' <= b && b <= '9') {
                n *= 10;
                n += b - '0';
            }else if(b == -1 || !isPrintableChar(b)){
                return minus ? -n : n;
            }else{
                throw new NumberFormatException();
            }
            b = readByte();
        }
    }
    public int nextInt() {
        if (!hasNext()) throw new NoSuchElementException();
        int n = 0;
        boolean minus = false;
        int b = readByte();
        if (b == '-') {
            minus = true;
            b = readByte();
        }
        if (b < '0' || '9' < b) {
            throw new NumberFormatException();
        }
        while(true){
            if ('0' <= b && b <= '9') {
                n *= 10;
                n += b - '0';
            }else if(b == -1 || !isPrintableChar(b)){
                return minus ? -n : n;
            }else{
                throw new NumberFormatException();
            }
            b = readByte();
        }
    }
}",1
p00132,"ジグソーパズル
子供から大人まで脳トレ系パズルゲームが流行しています。我々も遅れを取らぬよう、パズルゲームを作ってみんなで遊ぶことにしました。
我々が考えたのはジグソーパズルのゲームで、未完成の部分を埋めるのに必要なピースを選ぶというものです。図 1 (a) はパズルの枠の例です。黒が埋まっている部分、白が未完成の部分です。このパズルを完成するのに使えるピースが図 1 (b) のように与えられます。この中から、枠の白い部分を埋めることができる黒いピースを 1 つ以上選択します。例えば、図 2 の選択例 1 のような組み合わせなら正解となります。一方、選択例 2 のような組み合わせではパズルは完成しないので不正解となります。また、選択したピースが余ってしまう場合も不正解です。このように、プレイヤーは適切なピースを選択することでゲームをクリアします。
そこでこのパズルゲームで用いる判定プログラムを開発することになりました。未完成のパズル、ピースの候補、そしてプレイヤーが選んだピースの組み合わせを入力とし、プレイヤーが適切なピースを選ぶことができていれば YES を、そうでなければ NO と出力するプログラムを作成してください。
この問題では、パズルの枠は
H × W
の配列で表し、未完成の部分を . (半角ピリオド)、完成している部分を # (半角シャープ)によって与えます。パズルの枠の大きさは最大
20 × 20
とします。また、各ピースは
h × w
の配列で表し、ピースを構成する部分を # 、そうでない部分を . によって与えます。与えられる各ピースは、元の状態から 90 度、180 度、270 度だけ回転することができます。また、各ピースの大きさは最大
20 × 20
とし、与えられるピースの数
n
は最大 10 とします。
Input
複数のデータセットが与えられます。各データセットは以下の形式で与えられます。
H
W
g
1,1
g
1,2
...
g
1,W
g
2,1
g
2,2
...
g
2,W
:
g
H,1
g
H,2
...
g
H,W
n
h
1
w
1
c1
1,1
c1
1,2
...
c1
1,w
1
c1
2,1
c1
2,2
...
c1
2,w
1
:
c1
h
1
,1
c1
h
1
,2
...
c1
h
1
,w
1
:
:
h
n
w
n
cn
1,1
cn
1,2
...
cn
1,w
n
cn
2,1
cn
2,2
...
cn
2,w
n
:
cn
h
n
,1
cn
h
n
,2
...
cn
h
n
,w
n
p
k
1
t
1
t
2
...
t
k
1
k
2
t
1
t
2
...
t
k
2
:
k
p
t
1
t
2
...
t
k
p
1 行目に、パズルの枠の大きさ
H
(縦) と
W
(横) が与えられます。
2 行目に、文字
g
i,j
(
.
または
#
) からなりパズルの盤面を表す 1 行
W
文字の文字列が
H
行与えられます。
続いてピースの数
n
、
n
個のピースの情報が与えられます。各ピースの情報として、
l
番目のピースの配列のサイズ
h
l
(縦) と
w
l
(横)、
l
番目のピースの配列が与えられます。
l
番目のピースの配列として文字
cl
i,j
(
.
または
#
) からなる 1 行
w
l
文字の文字列が
h
l
行与えられます。
続いてプレイヤーの人数
p
、
i
番目のプレイヤーの選択したピースの数
k
i
と選択したピースの番号
t
j
が与えられます。
入力は２つの 0 を含む行で終了します。データセットの数は 10 を超えません。
Output
各データセットごとに、
i
番目のプレイヤーが選択したピースの正否 YES または NO を
i
行目に出力してください。
Sample Input
14 20
####################
###.............####
####..........######
#######.....########
########.....#######
###..###......######
###..####......#####
#########......#####
###########.....####
############.....###
###.########......##
###.#######...###.##
##...###....#####.##
####################
10
12 15
#############..
.##########....
....#####......
.....#####.....
.....######....
......######...
......######...
........#####..
.........#####.
.........######
........###...#
.....####.....#
3 3
#..
###
#..
2 2
##
##
4 10
....#####.
....######
...###...#
####.....#
6 5
....#
..###
#####
##.##
#..##
#..#.
6 4
...#
.###
####
##.#
##.#
#...
2 6
######
.#####
2 7
..#####
#######
2 13
#############
.##########..
6 9
#####....
.######..
.######..
..######.
...#####.
....#####
8
3 1 2 3
4 1 2 3 4
7 2 3 4 5 6 7 8
5 2 3 10 7 8
6 2 3 9 5 6 4
8 2 3 4 6 9 5 4 10
4 4 5 6 9
5 10 2 3 4 9
0 0
Output for the Sample Input
YES
NO
YES
NO
YES
NO
NO
YES",Python,"import sys
from copy import deepcopy

def read_input():
    datasets = []
    while True:
        line = sys.stdin.readline()
        if not line:
            break
        parts = line.strip().split()
        if len(parts) == 2:
            H, W = int(parts[0]), int(parts[1])
            if H == 0 and W == 0:
                break
            
            # Read puzzle grid
            grid = []
            for _ in range(H):
                grid.append(sys.stdin.readline().strip())
            
            # Read number of pieces
            n = int(sys.stdin.readline().strip())
            
            # Read pieces
            pieces = []
            for _ in range(n):
                h = int(sys.stdin.readline().strip())
                w = int(sys.stdin.readline().strip())
                piece = []
                for _ in range(h):
                    piece.append(sys.stdin.readline().strip())
                pieces.append(piece)
            
            # Read players
            p = int(sys.stdin.readline().strip())
            players = []
            for _ in range(p):
                line = sys.stdin.readline().strip().split()
                k = int(line[0])
                selected = [int(line[i+1]) - 1 for i in range(k)]
                players.append(selected)
            
            datasets.append((H, W, grid, pieces, players))
    
    return datasets

def rotate_90(piece):
    h = len(piece)
    w = len(piece[0])
    rotated = []
    for j in range(w):
        row = """"
        for i in range(h-1, -1, -1):
            row += piece[i][j]
        rotated.append(row)
    return rotated

def get_rotations(piece):
    rotations = [piece]
    current = piece
    for _ in range(3):
        current = rotate_90(current)
        rotations.append(current)
    return rotations

def get_piece_coords(piece):
    coords = []
    for i in range(len(piece)):
        for j in range(len(piece[i])):
            if piece[i][j] == '#':
                coords.append((i, j))
    return coords

def try_place(grid, H, W, piece, start_r, start_c):
    piece_coords = get_piece_coords(piece)
    placed = []
    for dr, dc in piece_coords:
        r = start_r + dr
        c = start_c + dc
        if r < 0 or r >= H or c < 0 or c >= W:
            return None
        if grid[r][c] != '.':
            return None
        placed.append((r, c))
    return placed

def solve(H, W, grid, selected_pieces):
    # Create a mutable grid
    target = []
    for i in range(H):
        row = list(grid[i])
        target.append(row)
    
    # Get all rotations for each piece
    all_rotations = []
    for piece in selected_pieces:
        all_rotations.append(get_rotations(piece))
    
    def backtrack(piece_idx):
        if piece_idx == len(selected_pieces):
            # Check if all '.' are filled
            for i in range(H):
                for j in range(W):
                    if target[i][j] == '.':
                        return False
            return True
        
        piece_rotations = all_rotations[piece_idx]
        
        for rotation in piece_rotations:
            # Try all possible positions
            for start_r in range(-19, H+20):
                for start_c in range(-19, W+20):
                    placed = try_place(target, H, W, rotation, start_r, start_c)
                    if placed:
                        # Mark cells
                        for r, c in placed:
                            target[r][c] = '#'
                        
                        if backtrack(piece_idx + 1):
                            return True
                        
                        # Unmark cells
                        for r, c in placed:
                            target[r][c] = '.'
        
        return False
    
    return backtrack(0)

def main():
    datasets = read_input()
    
    for H, W, grid, pieces, players in datasets:
        for selected_indices in players:
            selected_pieces = [pieces[i] for i in selected_indices]
            if solve(H, W, grid, selected_pieces):
                print(""YES"")
            else:
                print(""NO"")

if __name__ == ""__main__"":
    main()
",0
p00132,"ジグソーパズル
子供から大人まで脳トレ系パズルゲームが流行しています。我々も遅れを取らぬよう、パズルゲームを作ってみんなで遊ぶことにしました。
我々が考えたのはジグソーパズルのゲームで、未完成の部分を埋めるのに必要なピースを選ぶというものです。図 1 (a) はパズルの枠の例です。黒が埋まっている部分、白が未完成の部分です。このパズルを完成するのに使えるピースが図 1 (b) のように与えられます。この中から、枠の白い部分を埋めることができる黒いピースを 1 つ以上選択します。例えば、図 2 の選択例 1 のような組み合わせなら正解となります。一方、選択例 2 のような組み合わせではパズルは完成しないので不正解となります。また、選択したピースが余ってしまう場合も不正解です。このように、プレイヤーは適切なピースを選択することでゲームをクリアします。
そこでこのパズルゲームで用いる判定プログラムを開発することになりました。未完成のパズル、ピースの候補、そしてプレイヤーが選んだピースの組み合わせを入力とし、プレイヤーが適切なピースを選ぶことができていれば YES を、そうでなければ NO と出力するプログラムを作成してください。
この問題では、パズルの枠は
H × W
の配列で表し、未完成の部分を . (半角ピリオド)、完成している部分を # (半角シャープ)によって与えます。パズルの枠の大きさは最大
20 × 20
とします。また、各ピースは
h × w
の配列で表し、ピースを構成する部分を # 、そうでない部分を . によって与えます。与えられる各ピースは、元の状態から 90 度、180 度、270 度だけ回転することができます。また、各ピースの大きさは最大
20 × 20
とし、与えられるピースの数
n
は最大 10 とします。
Input
複数のデータセットが与えられます。各データセットは以下の形式で与えられます。
H
W
g
1,1
g
1,2
...
g
1,W
g
2,1
g
2,2
...
g
2,W
:
g
H,1
g
H,2
...
g
H,W
n
h
1
w
1
c1
1,1
c1
1,2
...
c1
1,w
1
c1
2,1
c1
2,2
...
c1
2,w
1
:
c1
h
1
,1
c1
h
1
,2
...
c1
h
1
,w
1
:
:
h
n
w
n
cn
1,1
cn
1,2
...
cn
1,w
n
cn
2,1
cn
2,2
...
cn
2,w
n
:
cn
h
n
,1
cn
h
n
,2
...
cn
h
n
,w
n
p
k
1
t
1
t
2
...
t
k
1
k
2
t
1
t
2
...
t
k
2
:
k
p
t
1
t
2
...
t
k
p
1 行目に、パズルの枠の大きさ
H
(縦) と
W
(横) が与えられます。
2 行目に、文字
g
i,j
(
.
または
#
) からなりパズルの盤面を表す 1 行
W
文字の文字列が
H
行与えられます。
続いてピースの数
n
、
n
個のピースの情報が与えられます。各ピースの情報として、
l
番目のピースの配列のサイズ
h
l
(縦) と
w
l
(横)、
l
番目のピースの配列が与えられます。
l
番目のピースの配列として文字
cl
i,j
(
.
または
#
) からなる 1 行
w
l
文字の文字列が
h
l
行与えられます。
続いてプレイヤーの人数
p
、
i
番目のプレイヤーの選択したピースの数
k
i
と選択したピースの番号
t
j
が与えられます。
入力は２つの 0 を含む行で終了します。データセットの数は 10 を超えません。
Output
各データセットごとに、
i
番目のプレイヤーが選択したピースの正否 YES または NO を
i
行目に出力してください。
Sample Input
14 20
####################
###.............####
####..........######
#######.....########
########.....#######
###..###......######
###..####......#####
#########......#####
###########.....####
############.....###
###.########......##
###.#######...###.##
##...###....#####.##
####################
10
12 15
#############..
.##########....
....#####......
.....#####.....
.....######....
......######...
......######...
........#####..
.........#####.
.........######
........###...#
.....####.....#
3 3
#..
###
#..
2 2
##
##
4 10
....#####.
....######
...###...#
####.....#
6 5
....#
..###
#####
##.##
#..##
#..#.
6 4
...#
.###
####
##.#
##.#
#...
2 6
######
.#####
2 7
..#####
#######
2 13
#############
.##########..
6 9
#####....
.######..
.######..
..######.
...#####.
....#####
8
3 1 2 3
4 1 2 3 4
7 2 3 4 5 6 7 8
5 2 3 10 7 8
6 2 3 9 5 6 4
8 2 3 4 6 9 5 4 10
4 4 5 6 9
5 10 2 3 4 9
0 0
Output for the Sample Input
YES
NO
YES
NO
YES
NO
NO
YES",Python,"import copy
def rot90(A):
  return zip(*A[::-1])

def count_board(Board):
  X = [[0 for _ in [0]*(Width+1)] for _ in [0]*(Height+1)]
  for i in range(Height)[::-1]:
    for j in range(Width)[::-1]:
      X[i][j] = X[i+1][j] + X[i][j+1] - X[i+1][j+1] + (Board[i][j]=='.')
  return X

def check_sum(TRIALS):
  return sum([B[e] for e in TRIALS]) != DOTS[0][0]

def tmp_put(Board, piece, y, x):
  N = range(len(piece[0]))
  for i in range(len(piece)):
    tmp = piece[i]
    BoardRow = Board[y+i]
    for j in N:
      if tmp[j]=='#' and BoardRow[x+j]!='.': return 0
  return 1

def get_put(Board, piece, y, x, mode):
  c = '#.'[mode]
  W = range(len(piece[0]))
  for i in range(len(piece)):
    tmp = piece[i]
    Y = y+i
    for j in W:
      if tmp[j]=='#': Board[Y][x+j]=c
  return Board

def PrintBoard(Board):
  for e in Board:
    print """".join(e)
  print
  return

def PrintDots(DOTS):
  for e in DOTS:
    print e
  print
  return

def solve(TRIALS, Board):
  if TRIALS==[]: return 1
  n = TRIALS[0]
  DOTS = count_board(Board)
  for direction in C[n]:
    P = PIECE[(n, direction)]
    h = len(P)
    w = len(P[0])
    s = B[n]
    POS=[]
    H = range(Height-h+1)
    W = range(Width-w+1)
    for i in H:
      A1 = DOTS[i]
      A2 = DOTS[i+h]
      for j in W:
        tmp = A1[j] - A2[j] - A1[j+w] + A2[j+w]
        if tmp>=s and tmp_put(Board, P, i, j):
          Board = get_put(Board, P, i, j, 0)
          if solve(TRIALS[1:], Board): return 1
          Board = get_put(Board, P, i, j, 1)
  return 0

def CheckPieceType(i):
  def f(x1, x2):
    for j in range(len(PIECE[i, x1])):
      if """".join(PIECE[i, x1][j])!="""".join(PIECE[i, x2][j]): return 0
    return 1
  flg = [0,1,2,3]
  for a, b in [[0,1], [1,3], [0,2]]:
    if f(a, b): flg[b] = flg[a]
  return list(set(flg))

while 1:
  Height, Width = map(int,raw_input().split())
  if Height*Width==0: break
  try: Board = [list(raw_input()) for _ in [0]*Height]
  except: break
  DOTS = count_board(Board)
  PIECE = {}
  n = input()
  B = [0] * n
  C = [[0, 0, 0, 0] for _ in [0] * n]
  for i in range(n):
    height, width = map(int, raw_input().split())
    tmp = [list(raw_input()) for _ in [0] * height]
    B[i] = sum([e.count('#') for e in tmp])
    for direction in [0, 1, 2, 3]:
      PIECE[(i, direction)] = tmp
      tmp = rot90(tmp)
    C[i] = CheckPieceType(i)
  for _ in [0]*input():
    a = map(int, raw_input().split())[1:]
    a = sorted([[B[e-1], e-1] for e in a], key = lambda x:{-x[0]})
    TRIALS = list(zip(*a)[1])
    if check_sum(TRIALS): print ""NO""
    else: print [""NO"", ""YES""][solve(TRIALS, copy.deepcopy(Board))]",1
p00133,"パターンの回転
8 文字 × 8 行のパターンを右回りに 90 度、180 度、270 度回転させて出力するプログラムを作成してください。
Input
8 文字 × 8 行からなるパターンが与えられます。文字は、英数字、半角シャープ '#' 、アスタリスク '*' からなります。
Output
次の形式で、回転させたパターンを出力してください。
90（半角数字固定）
90度回転させたパターン
180（半角数字固定）
180度回転させたパターン
270（半角数字固定）
270度回転させたパターン
Sample Input
#*******
#*******
#*******
#*******
#*******
#*******
#*******
########
Output for the Sample Input
90
########
#*******
#*******
#*******
#*******
#*******
#*******
#*******
180
########
*******#
*******#
*******#
*******#
*******#
*******#
*******#
270
*******#
*******#
*******#
*******#
*******#
*******#
*******#
########",C,"#include <stdio.h>

int main() {
    char pattern[8][9];
    int i, j;
    
    // Read input
    for (i = 0; i < 8; i++) {
        scanf(""%s"", pattern[i]);
    }
    
    // 90 degrees
    printf(""90\n"");
    for (i = 0; i < 8; i++) {
        for (j = 7; j >= 0; j--) {
            printf(""%c"", pattern[j][i]);
        }
        printf(""\n"");
    }
    
    // 180 degrees
    printf(""180\n"");
    for (i = 7; i >= 0; i--) {
        for (j = 7; j >= 0; j--) {
            printf(""%c"", pattern[i][j]);
        }
        printf(""\n"");
    }
    
    // 270 degrees
    printf(""270\n"");
    for (i = 7; i >= 0; i--) {
        for (j = 0; j < 8; j++) {
            printf(""%c"", pattern[j][i]);
        }
        printf(""\n"");
    }
    
    return 0;
}
",0
p00133,"パターンの回転
8 文字 × 8 行のパターンを右回りに 90 度、180 度、270 度回転させて出力するプログラムを作成してください。
Input
8 文字 × 8 行からなるパターンが与えられます。文字は、英数字、半角シャープ '#' 、アスタリスク '*' からなります。
Output
次の形式で、回転させたパターンを出力してください。
90（半角数字固定）
90度回転させたパターン
180（半角数字固定）
180度回転させたパターン
270（半角数字固定）
270度回転させたパターン
Sample Input
#*******
#*******
#*******
#*******
#*******
#*******
#*******
########
Output for the Sample Input
90
########
#*******
#*******
#*******
#*******
#*******
#*******
#*******
180
########
*******#
*******#
*******#
*******#
*******#
*******#
*******#
270
*******#
*******#
*******#
*******#
*******#
*******#
*******#
########",C,"#include <stdio.h>
#include <string.h>

int rotate(char pat[8][9]) {
	char buf[8][9];
	int x,y;
	for(y=0;y<8;y++) {
		for(x=0;x<8;x++) {
			buf[x][7-y]=pat[y][x];
		}
	}
	memcpy(pat,buf,sizeof(pat));
}

int main(void) {
	char buf[8][9];
	int i;
	for(i=0;i<8;i++)scanf(""%s"",buf[i]);
	rotate(buf);
	puts(""90"");
	for(i=0;i<8;i++)printf(""%s\n"",buf[i]);
	rotate(buf);
	puts(""180"");
	for(i=0;i<8;i++)printf(""%s\n"",buf[i]);
	rotate(buf);
	puts(""270"");
	for(i=0;i<8;i++)printf(""%s\n"",buf[i]);
	return 0;
}",1
p00133,"パターンの回転
8 文字 × 8 行のパターンを右回りに 90 度、180 度、270 度回転させて出力するプログラムを作成してください。
Input
8 文字 × 8 行からなるパターンが与えられます。文字は、英数字、半角シャープ '#' 、アスタリスク '*' からなります。
Output
次の形式で、回転させたパターンを出力してください。
90（半角数字固定）
90度回転させたパターン
180（半角数字固定）
180度回転させたパターン
270（半角数字固定）
270度回転させたパターン
Sample Input
#*******
#*******
#*******
#*******
#*******
#*******
#*******
########
Output for the Sample Input
90
########
#*******
#*******
#*******
#*******
#*******
#*******
#*******
180
########
*******#
*******#
*******#
*******#
*******#
*******#
*******#
270
*******#
*******#
*******#
*******#
*******#
*******#
*******#
########",Java,"import java.util.Scanner;

public class Main {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        char[][] pattern = new char[8][8];
        
        for (int i = 0; i < 8; i++) {
            String line = sc.nextLine();
            for (int j = 0; j < 8; j++) {
                pattern[i][j] = line.charAt(j);
            }
        }
        
        // 90 degrees
        System.out.println(""90"");
        char[][] rotated90 = rotate90(pattern);
        printPattern(rotated90);
        
        // 180 degrees
        System.out.println(""180"");
        char[][] rotated180 = rotate90(rotated90);
        printPattern(rotated180);
        
        // 270 degrees
        System.out.println(""270"");
        char[][] rotated270 = rotate90(rotated180);
        printPattern(rotated270);
        
        sc.close();
    }
    
    private static char[][] rotate90(char[][] pattern) {
        char[][] result = new char[8][8];
        for (int i = 0; i < 8; i++) {
            for (int j = 0; j < 8; j++) {
                result[i][j] = pattern[7 - j][i];
            }
        }
        return result;
    }
    
    private static void printPattern(char[][] pattern) {
        for (int i = 0; i < 8; i++) {
            for (int j = 0; j < 8; j++) {
                System.out.print(pattern[i][j]);
            }
            System.out.println();
        }
    }
}
",0
p00133,"パターンの回転
8 文字 × 8 行のパターンを右回りに 90 度、180 度、270 度回転させて出力するプログラムを作成してください。
Input
8 文字 × 8 行からなるパターンが与えられます。文字は、英数字、半角シャープ '#' 、アスタリスク '*' からなります。
Output
次の形式で、回転させたパターンを出力してください。
90（半角数字固定）
90度回転させたパターン
180（半角数字固定）
180度回転させたパターン
270（半角数字固定）
270度回転させたパターン
Sample Input
#*******
#*******
#*******
#*******
#*******
#*******
#*******
########
Output for the Sample Input
90
########
#*******
#*******
#*******
#*******
#*******
#*******
#*******
180
########
*******#
*******#
*******#
*******#
*******#
*******#
*******#
270
*******#
*******#
*******#
*******#
*******#
*******#
*******#
########",Java,"import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;

public class Main {

	public static void main(String[] args) throws IOException {
		BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
		String line = """";

		char[][] pattern = new char[8][8];
		for (int i = 0; i < 8; i++) {
			line = br.readLine();
			for (int j = 0; j < 8; j++) {
				pattern[i][j] = line.charAt(j);
			}
		}
		for (int i = 1; i <= 3; i++) {
			pattern = rotate(pattern);
			System.out.println(i * 90);
			for (int j = 0; j < 8; j++) {
				System.out.println(new String(pattern[j]));
			}
		}
	}

	static char[][] rotate(char[][] pattern) {
		char[][] rotate = new char[8][8];
		for (int i = 0; i < 8; i++) {
			for (int j = 0; j < 8; j++) {
				rotate[j][7 - i] = pattern[i][j];
			}
		}
		return rotate;
	}
}",1
p00133,"パターンの回転
8 文字 × 8 行のパターンを右回りに 90 度、180 度、270 度回転させて出力するプログラムを作成してください。
Input
8 文字 × 8 行からなるパターンが与えられます。文字は、英数字、半角シャープ '#' 、アスタリスク '*' からなります。
Output
次の形式で、回転させたパターンを出力してください。
90（半角数字固定）
90度回転させたパターン
180（半角数字固定）
180度回転させたパターン
270（半角数字固定）
270度回転させたパターン
Sample Input
#*******
#*******
#*******
#*******
#*******
#*******
#*******
########
Output for the Sample Input
90
########
#*******
#*******
#*******
#*******
#*******
#*******
#*******
180
########
*******#
*******#
*******#
*******#
*******#
*******#
*******#
270
*******#
*******#
*******#
*******#
*******#
*******#
*******#
########",Python,"# Read input
pattern = []
for _ in range(8):
    pattern.append(input())

# 90 degree rotation (clockwise)
rotated_90 = []
for col in range(8):
    row_str = """"
    for row in range(7, -1, -1):
        row_str += pattern[row][col]
    rotated_90.append(row_str)

# 180 degree rotation
rotated_180 = []
for row in range(7, -1, -1):
    rotated_180.append(pattern[row][::-1])

# 270 degree rotation (clockwise)
rotated_270 = []
for col in range(7, -1, -1):
    row_str = """"
    for row in range(8):
        row_str += pattern[row][col]
    rotated_270.append(row_str)

# Output
print(""90"")
for row in rotated_90:
    print(row)
print(""180"")
for row in rotated_180:
    print(row)
print(""270"")
for row in rotated_270:
    print(row)
",0
p00133,"パターンの回転
8 文字 × 8 行のパターンを右回りに 90 度、180 度、270 度回転させて出力するプログラムを作成してください。
Input
8 文字 × 8 行からなるパターンが与えられます。文字は、英数字、半角シャープ '#' 、アスタリスク '*' からなります。
Output
次の形式で、回転させたパターンを出力してください。
90（半角数字固定）
90度回転させたパターン
180（半角数字固定）
180度回転させたパターン
270（半角数字固定）
270度回転させたパターン
Sample Input
#*******
#*******
#*******
#*******
#*******
#*******
#*******
########
Output for the Sample Input
90
########
#*******
#*******
#*******
#*******
#*******
#*******
#*******
180
########
*******#
*******#
*******#
*******#
*******#
*******#
*******#
270
*******#
*******#
*******#
*******#
*******#
*******#
*******#
########",Python,"d=[list(raw_input()) for i in range(8)]
p=[d,[],[],[]]
for r in range(3):
	print 90*(r+1)
	for j in range(8):
		p[r+1].append([p[r][i][j] for i in range(7,-1,-1)])
		print """".join(p[r+1][j])",1
p00134,"出口調査
あるデパートで買い物金額の出口調査を行いました。買い物金額のデータを入力とし、1 人あたりの平均買い物金額を計算し、出力するプログラムを作成してください。調査人数は、10 万人以下とし、一人あたりの買い物金額は 100 万円を超えないものとします。
Input
入力は以下の形式で与えられます。
n
v
1
v
2
:
v
n
1 行目に調査人数
n
、続く
n
行に
i
人目の買い物金額を表す整数
v
i
が与えられます。
Output
平均買い物金額（整数：小数点以下は切り捨て）を１行に出力してください。
Sample Input
6
12300
5600
33800
0
26495
52000
Output for the Sample Input
21699",C,"#include <stdio.h>

int main() {
    int n;
    scanf(""%d"", &n);
    
    long long sum = 0;
    for (int i = 0; i < n; i++) {
        int v;
        scanf(""%d"", &v);
        sum += v;
    }
    
    printf(""%lld\n"", sum / n);
    
    return 0;
}
",0
p00134,"出口調査
あるデパートで買い物金額の出口調査を行いました。買い物金額のデータを入力とし、1 人あたりの平均買い物金額を計算し、出力するプログラムを作成してください。調査人数は、10 万人以下とし、一人あたりの買い物金額は 100 万円を超えないものとします。
Input
入力は以下の形式で与えられます。
n
v
1
v
2
:
v
n
1 行目に調査人数
n
、続く
n
行に
i
人目の買い物金額を表す整数
v
i
が与えられます。
Output
平均買い物金額（整数：小数点以下は切り捨て）を１行に出力してください。
Sample Input
6
12300
5600
33800
0
26495
52000
Output for the Sample Input
21699",C,"#include<stdio.h>

int main(){

  int n, sum, in, i;

  sum = 0;

  scanf(""%d"",&n);

  for(i = 0; i < n; i++){
    scanf(""%d"",&in);
    sum += in;
  }

  printf(""%d\n"",sum/n);

  return 0;

}",1
p00134,"出口調査
あるデパートで買い物金額の出口調査を行いました。買い物金額のデータを入力とし、1 人あたりの平均買い物金額を計算し、出力するプログラムを作成してください。調査人数は、10 万人以下とし、一人あたりの買い物金額は 100 万円を超えないものとします。
Input
入力は以下の形式で与えられます。
n
v
1
v
2
:
v
n
1 行目に調査人数
n
、続く
n
行に
i
人目の買い物金額を表す整数
v
i
が与えられます。
Output
平均買い物金額（整数：小数点以下は切り捨て）を１行に出力してください。
Sample Input
6
12300
5600
33800
0
26495
52000
Output for the Sample Input
21699",Java,"import java.util.Scanner;

public class Main {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int n = sc.nextInt();
        long sum = 0;
        for (int i = 0; i < n; i++) {
            sum += sc.nextInt();
        }
        System.out.println(sum / n);
        sc.close();
    }
}
",0
p00134,"出口調査
あるデパートで買い物金額の出口調査を行いました。買い物金額のデータを入力とし、1 人あたりの平均買い物金額を計算し、出力するプログラムを作成してください。調査人数は、10 万人以下とし、一人あたりの買い物金額は 100 万円を超えないものとします。
Input
入力は以下の形式で与えられます。
n
v
1
v
2
:
v
n
1 行目に調査人数
n
、続く
n
行に
i
人目の買い物金額を表す整数
v
i
が与えられます。
Output
平均買い物金額（整数：小数点以下は切り捨て）を１行に出力してください。
Sample Input
6
12300
5600
33800
0
26495
52000
Output for the Sample Input
21699",Java,"import java.io.IOException;
import java.io.InputStream;
import java.io.PrintWriter;
import java.util.Arrays;
import java.util.InputMismatchException;
import java.util.LinkedList;


 
public class Main {
  public static void main(String[] args) {
    InputReader sc = new InputReader(System.in);
 
    int n = sc.nextInt();
    long sum = 0;
    for(int i = 0; i < n; i++){
      sum += sc.nextInt();
    }
    System.out.println(sum/n);


  }
 
  
 
  static class InputReader {
      private InputStream stream;
      private byte[] buf = new byte[1024];
      private int curChar;
      private int numChars;
      private SpaceCharFilter filter;

      public InputReader(InputStream stream) {
          this.stream = stream;
      }
 
      public int next() {
          if (numChars == -1)
              throw new InputMismatchException();
          if (curChar >= numChars) {
              curChar = 0;
              try {
                  numChars = stream.read(buf);
              } catch (IOException e) {
                  throw new InputMismatchException();
              }
              if (numChars <= 0)
                  return -1;
          }
          return buf[curChar++];
      }
 
      public String nextStr() {
        int c = next();
        while(isSpaceChar(c)){c = next();}
        StringBuffer str = new StringBuffer();
        do{
          str.append((char)c);
          c = next();
        }while(!isSpaceChar(c));
        return str.toString();
      }

      public int nextInt() {
          int c = next();
          while (isSpaceChar(c))
              c = next();
          int sgn = 1;
          if (c == '-') {
              sgn = -1;
              c = next();
          }
          int res = 0;
          do {
              if (c < '0' || c > '9')
                  throw new InputMismatchException();
              res *= 10;
              res += c - '0';
              c = next();
          } while (!isSpaceChar(c));
          return res * sgn;
      }
 
      public boolean isSpaceChar(int c) {
          if (filter != null)
              return filter.isSpaceChar(c);
          return c == ' ' || c == '\n' || c == '\r' || c == '\t' || c == -1;
      }
 
      public interface SpaceCharFilter {
          public boolean isSpaceChar(int ch);
      }
  }
}",1
p00134,"出口調査
あるデパートで買い物金額の出口調査を行いました。買い物金額のデータを入力とし、1 人あたりの平均買い物金額を計算し、出力するプログラムを作成してください。調査人数は、10 万人以下とし、一人あたりの買い物金額は 100 万円を超えないものとします。
Input
入力は以下の形式で与えられます。
n
v
1
v
2
:
v
n
1 行目に調査人数
n
、続く
n
行に
i
人目の買い物金額を表す整数
v
i
が与えられます。
Output
平均買い物金額（整数：小数点以下は切り捨て）を１行に出力してください。
Sample Input
6
12300
5600
33800
0
26495
52000
Output for the Sample Input
21699",Python,"n = int(input())
total = 0
for _ in range(n):
    total += int(input())
print(total // n)
",0
p00134,"出口調査
あるデパートで買い物金額の出口調査を行いました。買い物金額のデータを入力とし、1 人あたりの平均買い物金額を計算し、出力するプログラムを作成してください。調査人数は、10 万人以下とし、一人あたりの買い物金額は 100 万円を超えないものとします。
Input
入力は以下の形式で与えられます。
n
v
1
v
2
:
v
n
1 行目に調査人数
n
、続く
n
行に
i
人目の買い物金額を表す整数
v
i
が与えられます。
Output
平均買い物金額（整数：小数点以下は切り捨て）を１行に出力してください。
Sample Input
6
12300
5600
33800
0
26495
52000
Output for the Sample Input
21699",Python,"def main():
    n = int(input())
    a = 0
    for _ in range(n):
        a += int(input())
    ans = a // n
    print(ans)


if __name__ == ""__main__"":
    main()",1
p00135,"時計の短い針と長い針
原始スローライフ主義組織「アカルイダ」から、いたずらの予告状が届きました。アカルイダといえば、要人の顔面にパイを投げつけたりするいたずらで有名ですが、最近では火薬を用いてレセプション会場にネズミ花火をまき散らすなど、より過激化してきました。予告状は次の文面です。
---パソコン ヒトの時間を奪う。良くない。
時計の短い針と長い針 出会うころ、アカルイダ 正義行う。
スローライフ 偉大なり。
たどたどしくてよく解らないのですが、時計の短針と長針とが重なったころにいたずらを決行するという意味のようです。
このいたずらを警戒するため、時刻を入力として、短針と長針が近い場合は ""alert""、遠い場合は ""safe""、それ以外の場合は ""warning"" と出力するプログラムを作成してください。ただし、「近い」とは短針と長針の角度が 0° 以上 30° 未満の場合をいい、「遠い」とは 90° 以上 180° 以下の場合をいいます。なお、時刻は 00:00 以上 11:59 以下とします。
Input
入力は以下の形式で与えられます。
n
hh
1
:
mm
1
hh
2
:
mm
2
:
hh
n
:
mm
n
1 行目に判定する時刻の個数
n
（1 ≤
n
≤ 10000）、2 行目以降に
i
番目の時刻
hh
i
:
mm
i
がそれぞれ１行に与えられます。
Output
i
番目の時刻の判定結果 safe、warning、または alert を順番にそれぞれ１行に出力してください。
Sample Input
4
02:15
06:01
11:55
10:40
Output for the Sample Input
alert
safe
alert
warning",C,"#include <stdio.h>
#include <stdlib.h>

int main() {
    int n;
    scanf(""%d"", &n);
    
    for (int i = 0; i < n; i++) {
        int hh, mm;
        scanf(""%d:%d"", &hh, &mm);
        
        // Calculate angle of minute hand (6 degrees per minute)
        double minute_angle = mm * 6.0;
        
        // Calculate angle of hour hand (30 degrees per hour + 0.5 degrees per minute)
        double hour_angle = (hh % 12) * 30.0 + mm * 0.5;
        
        // Calculate the absolute difference
        double diff = abs(hour_angle - minute_angle);
        if (diff > 180.0) {
            diff = 360.0 - diff;
        }
        
        // Determine the output
        if (diff >= 0 && diff < 30) {
            printf(""alert\n"");
        } else if (diff >= 90 && diff <= 180) {
            printf(""safe\n"");
        } else {
            printf(""warning\n"");
        }
    }
    
    return 0;
}
",0
p00135,"時計の短い針と長い針
原始スローライフ主義組織「アカルイダ」から、いたずらの予告状が届きました。アカルイダといえば、要人の顔面にパイを投げつけたりするいたずらで有名ですが、最近では火薬を用いてレセプション会場にネズミ花火をまき散らすなど、より過激化してきました。予告状は次の文面です。
---パソコン ヒトの時間を奪う。良くない。
時計の短い針と長い針 出会うころ、アカルイダ 正義行う。
スローライフ 偉大なり。
たどたどしくてよく解らないのですが、時計の短針と長針とが重なったころにいたずらを決行するという意味のようです。
このいたずらを警戒するため、時刻を入力として、短針と長針が近い場合は ""alert""、遠い場合は ""safe""、それ以外の場合は ""warning"" と出力するプログラムを作成してください。ただし、「近い」とは短針と長針の角度が 0° 以上 30° 未満の場合をいい、「遠い」とは 90° 以上 180° 以下の場合をいいます。なお、時刻は 00:00 以上 11:59 以下とします。
Input
入力は以下の形式で与えられます。
n
hh
1
:
mm
1
hh
2
:
mm
2
:
hh
n
:
mm
n
1 行目に判定する時刻の個数
n
（1 ≤
n
≤ 10000）、2 行目以降に
i
番目の時刻
hh
i
:
mm
i
がそれぞれ１行に与えられます。
Output
i
番目の時刻の判定結果 safe、warning、または alert を順番にそれぞれ１行に出力してください。
Sample Input
4
02:15
06:01
11:55
10:40
Output for the Sample Input
alert
safe
alert
warning",C,"#include <stdio.h>

int main(void)
{
    int n;
    int h, m;
    int i;
    double angle;
    
    scanf(""%d"", &n);
    for (i = 0; i < n; i++){
        scanf(""%d:%d"", &h, &m);
        
        angle = h * 360 / 12 + 360 / 12 * m / 60.0;
        angle -= (360 / 60 * m);
        
        if (angle > 180){
            angle -= 360;
        }
        
        if (-30 < angle && angle < 30){
            printf(""alert\n"");
        }
        else if (-90 < angle && angle < 90){
            printf(""warning\n"");
        }
        else {
            printf(""safe\n"");
        }
    }
    return (0);
}",1
p00135,"時計の短い針と長い針
原始スローライフ主義組織「アカルイダ」から、いたずらの予告状が届きました。アカルイダといえば、要人の顔面にパイを投げつけたりするいたずらで有名ですが、最近では火薬を用いてレセプション会場にネズミ花火をまき散らすなど、より過激化してきました。予告状は次の文面です。
---パソコン ヒトの時間を奪う。良くない。
時計の短い針と長い針 出会うころ、アカルイダ 正義行う。
スローライフ 偉大なり。
たどたどしくてよく解らないのですが、時計の短針と長針とが重なったころにいたずらを決行するという意味のようです。
このいたずらを警戒するため、時刻を入力として、短針と長針が近い場合は ""alert""、遠い場合は ""safe""、それ以外の場合は ""warning"" と出力するプログラムを作成してください。ただし、「近い」とは短針と長針の角度が 0° 以上 30° 未満の場合をいい、「遠い」とは 90° 以上 180° 以下の場合をいいます。なお、時刻は 00:00 以上 11:59 以下とします。
Input
入力は以下の形式で与えられます。
n
hh
1
:
mm
1
hh
2
:
mm
2
:
hh
n
:
mm
n
1 行目に判定する時刻の個数
n
（1 ≤
n
≤ 10000）、2 行目以降に
i
番目の時刻
hh
i
:
mm
i
がそれぞれ１行に与えられます。
Output
i
番目の時刻の判定結果 safe、warning、または alert を順番にそれぞれ１行に出力してください。
Sample Input
4
02:15
06:01
11:55
10:40
Output for the Sample Input
alert
safe
alert
warning",Java,"import java.util.*;

public class Main {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int n = sc.nextInt();
        sc.nextLine();
        
        for (int i = 0; i < n; i++) {
            String time = sc.nextLine();
            String[] parts = time.split("":"");
            int hh = Integer.parseInt(parts[0]);
            int mm = Integer.parseInt(parts[1]);
            
            // Calculate angle of hour hand from 12 o'clock
            // Hour hand moves 30 degrees per hour and 0.5 degrees per minute
            double hourAngle = (hh % 12) * 30.0 + mm * 0.5;
            
            // Calculate angle of minute hand from 12 o'clock
            // Minute hand moves 6 degrees per minute
            double minuteAngle = mm * 6.0;
            
            // Calculate the difference
            double diff = Math.abs(hourAngle - minuteAngle);
            
            // The angle should be the smaller one (between 0 and 180)
            if (diff > 180) {
                diff = 360 - diff;
            }
            
            if (diff >= 0 && diff < 30) {
                System.out.println(""alert"");
            } else if (diff >= 90 && diff <= 180) {
                System.out.println(""safe"");
            } else {
                System.out.println(""warning"");
            }
        }
        
        sc.close();
    }
}
",0
p00135,"時計の短い針と長い針
原始スローライフ主義組織「アカルイダ」から、いたずらの予告状が届きました。アカルイダといえば、要人の顔面にパイを投げつけたりするいたずらで有名ですが、最近では火薬を用いてレセプション会場にネズミ花火をまき散らすなど、より過激化してきました。予告状は次の文面です。
---パソコン ヒトの時間を奪う。良くない。
時計の短い針と長い針 出会うころ、アカルイダ 正義行う。
スローライフ 偉大なり。
たどたどしくてよく解らないのですが、時計の短針と長針とが重なったころにいたずらを決行するという意味のようです。
このいたずらを警戒するため、時刻を入力として、短針と長針が近い場合は ""alert""、遠い場合は ""safe""、それ以外の場合は ""warning"" と出力するプログラムを作成してください。ただし、「近い」とは短針と長針の角度が 0° 以上 30° 未満の場合をいい、「遠い」とは 90° 以上 180° 以下の場合をいいます。なお、時刻は 00:00 以上 11:59 以下とします。
Input
入力は以下の形式で与えられます。
n
hh
1
:
mm
1
hh
2
:
mm
2
:
hh
n
:
mm
n
1 行目に判定する時刻の個数
n
（1 ≤
n
≤ 10000）、2 行目以降に
i
番目の時刻
hh
i
:
mm
i
がそれぞれ１行に与えられます。
Output
i
番目の時刻の判定結果 safe、warning、または alert を順番にそれぞれ１行に出力してください。
Sample Input
4
02:15
06:01
11:55
10:40
Output for the Sample Input
alert
safe
alert
warning",Java,"import java.util.Scanner;

class Main{
    public static void main(String[] args) {
        Scanner sc=new Scanner(System.in);
        int n=sc.nextInt();
        for(int i=0;i<n;i++) {
           String[] s=sc.next().split("":"");
           int a=Integer.parseInt(s[0])*60;
           int b=Integer.parseInt(s[1]);
           int d=Math.abs((a+b)/2-b*6);
           System.out.println(d<30||d>330?""alert"":d<90||d>270?""warning"":""safe"");
        }
    }
}
",1
p00135,"時計の短い針と長い針
原始スローライフ主義組織「アカルイダ」から、いたずらの予告状が届きました。アカルイダといえば、要人の顔面にパイを投げつけたりするいたずらで有名ですが、最近では火薬を用いてレセプション会場にネズミ花火をまき散らすなど、より過激化してきました。予告状は次の文面です。
---パソコン ヒトの時間を奪う。良くない。
時計の短い針と長い針 出会うころ、アカルイダ 正義行う。
スローライフ 偉大なり。
たどたどしくてよく解らないのですが、時計の短針と長針とが重なったころにいたずらを決行するという意味のようです。
このいたずらを警戒するため、時刻を入力として、短針と長針が近い場合は ""alert""、遠い場合は ""safe""、それ以外の場合は ""warning"" と出力するプログラムを作成してください。ただし、「近い」とは短針と長針の角度が 0° 以上 30° 未満の場合をいい、「遠い」とは 90° 以上 180° 以下の場合をいいます。なお、時刻は 00:00 以上 11:59 以下とします。
Input
入力は以下の形式で与えられます。
n
hh
1
:
mm
1
hh
2
:
mm
2
:
hh
n
:
mm
n
1 行目に判定する時刻の個数
n
（1 ≤
n
≤ 10000）、2 行目以降に
i
番目の時刻
hh
i
:
mm
i
がそれぞれ１行に与えられます。
Output
i
番目の時刻の判定結果 safe、warning、または alert を順番にそれぞれ１行に出力してください。
Sample Input
4
02:15
06:01
11:55
10:40
Output for the Sample Input
alert
safe
alert
warning",Python,"n = int(input())
for _ in range(n):
    time = input().strip()
    hh, mm = map(int, time.split(':'))
    
    # Calculate hour hand angle (from 12 o'clock)
    hour_angle = (hh % 12) * 30 + mm * 0.5
    
    # Calculate minute hand angle (from 12 o'clock)
    minute_angle = mm * 6
    
    # Calculate the difference
    diff = abs(hour_angle - minute_angle)
    
    # Take the smaller angle
    if diff > 180:
        diff = 360 - diff
    
    # Determine the status
    if 0 <= diff < 30:
        print(""alert"")
    elif 90 <= diff <= 180:
        print(""safe"")
    else:
        print(""warning"")
",0
p00135,"時計の短い針と長い針
原始スローライフ主義組織「アカルイダ」から、いたずらの予告状が届きました。アカルイダといえば、要人の顔面にパイを投げつけたりするいたずらで有名ですが、最近では火薬を用いてレセプション会場にネズミ花火をまき散らすなど、より過激化してきました。予告状は次の文面です。
---パソコン ヒトの時間を奪う。良くない。
時計の短い針と長い針 出会うころ、アカルイダ 正義行う。
スローライフ 偉大なり。
たどたどしくてよく解らないのですが、時計の短針と長針とが重なったころにいたずらを決行するという意味のようです。
このいたずらを警戒するため、時刻を入力として、短針と長針が近い場合は ""alert""、遠い場合は ""safe""、それ以外の場合は ""warning"" と出力するプログラムを作成してください。ただし、「近い」とは短針と長針の角度が 0° 以上 30° 未満の場合をいい、「遠い」とは 90° 以上 180° 以下の場合をいいます。なお、時刻は 00:00 以上 11:59 以下とします。
Input
入力は以下の形式で与えられます。
n
hh
1
:
mm
1
hh
2
:
mm
2
:
hh
n
:
mm
n
1 行目に判定する時刻の個数
n
（1 ≤
n
≤ 10000）、2 行目以降に
i
番目の時刻
hh
i
:
mm
i
がそれぞれ１行に与えられます。
Output
i
番目の時刻の判定結果 safe、warning、または alert を順番にそれぞれ１行に出力してください。
Sample Input
4
02:15
06:01
11:55
10:40
Output for the Sample Input
alert
safe
alert
warning",Python,"N = int(input())
for i in range(N):
    h, m = map(int, input().split("":""))
    d = abs(60*h - 11*m)
    v = min(d, 720 - d)
    if v < 60:
        print(""alert"")
    elif v < 180:
        print(""warning"")
    else:
        print(""safe"")

",1
p00138,"陸上競技大会
陸上競技大会 200M の準決勝 3 組のレースが行われました。それぞれの組に 8 名（計 24 名）の選手が出場します。各組上位 2 位までの選手と、各組の 3 位以下の全選手の中から上位 2 名の計 8 名が決勝に進出します。
選手番号とタイムを入力とし、決勝進出者 8 名の番号とそのタイムを出力するプログラムを作成してください。
Input
入力は以下の形式で与えられます。
p
1
t
1
p
2
t
2
:
p
24
t
24
1 行目から 8 行目に１組目の選手番号
p
i
(整数、1 ≤
p
i
≤ 10000) とタイム
t
i
(1/100 まで計測した実数、1 ≤
t
i
≤ 100)、9 行目から 16 行目に２組目の選手番号
p
i
とタイム
t
i
、17 行目から 24 行目に３組目の選手番号
p
i
とタイム
t
i
が与えられます。同じ選手番号の選手、同タイムの選手はいないものとします。
Output
以下の順番で、決勝進出者の選手番号とタイムを空白区切りでそれぞれ１行に出力してください。
1 組目の 1 位の選手
1 組目の 2 位の選手
2 組目の 1 位の選手
2 組目の 2 位の選手
3 組目の 1 位の選手
3 組目の 2 位の選手
各組で 3 位以下の選手の中でタイムが 1 位の選手
各組で 3 位以下の選手の中でタイムが 2 位の選手
Sample Input
18 25.46
16 26.23
3 23.00
10 24.79
5 22.88
11 23.87
19 23.90
1 25.11
23 23.88
4 23.46
7 24.12
12 22.91
13 21.99
14 22.86
21 23.12
9 24.09
17 22.51
22 23.49
6 23.02
20 22.23
24 21.89
15 24.14
8 23.77
2 23.42
Output for the Sample Input
5 22.88
3 23.00
13 21.99
14 22.86
24 21.89
20 22.23
17 22.51
12 22.91",C,"#include <stdio.h>
#include <stdlib.h>

typedef struct {
    int player;
    double time;
} Record;

int compare(const void *a, const void *b) {
    Record *r1 = (Record *)a;
    Record *r2 = (Record *)b;
    if (r1->time < r2->time) return -1;
    if (r1->time > r2->time) return 1;
    return 0;
}

int main() {
    Record groups[3][8];
    Record qualifiers[8];
    Record others[18];
    int others_count = 0;
    
    // Read input
    for (int i = 0; i < 3; i++) {
        for (int j = 0; j < 8; j++) {
            scanf(""%d %lf"", &groups[i][j].player, &groups[i][j].time);
        }
    }
    
    // Sort each group by time
    for (int i = 0; i < 3; i++) {
        qsort(groups[i], 8, sizeof(Record), compare);
    }
    
    // First 2 from each group
    qualifiers[0] = groups[0][0];
    qualifiers[1] = groups[0][1];
    qualifiers[2] = groups[1][0];
    qualifiers[3] = groups[1][1];
    qualifiers[4] = groups[2][0];
    qualifiers[5] = groups[2][1];
    
    // Collect 3rd place and below from all groups
    for (int i = 0; i < 3; i++) {
        for (int j = 2; j < 8; j++) {
            others[others_count++] = groups[i][j];
        }
    }
    
    // Sort others by time
    qsort(others, others_count, sizeof(Record), compare);
    
    // Top 2 from others
    qualifiers[6] = others[0];
    qualifiers[7] = others[1];
    
    // Output
    for (int i = 0; i < 8; i++) {
        printf(""%d %.2f\n"", qualifiers[i].player, qualifiers[i].time);
    }
    
    return 0;
}
",0
p00138,"陸上競技大会
陸上競技大会 200M の準決勝 3 組のレースが行われました。それぞれの組に 8 名（計 24 名）の選手が出場します。各組上位 2 位までの選手と、各組の 3 位以下の全選手の中から上位 2 名の計 8 名が決勝に進出します。
選手番号とタイムを入力とし、決勝進出者 8 名の番号とそのタイムを出力するプログラムを作成してください。
Input
入力は以下の形式で与えられます。
p
1
t
1
p
2
t
2
:
p
24
t
24
1 行目から 8 行目に１組目の選手番号
p
i
(整数、1 ≤
p
i
≤ 10000) とタイム
t
i
(1/100 まで計測した実数、1 ≤
t
i
≤ 100)、9 行目から 16 行目に２組目の選手番号
p
i
とタイム
t
i
、17 行目から 24 行目に３組目の選手番号
p
i
とタイム
t
i
が与えられます。同じ選手番号の選手、同タイムの選手はいないものとします。
Output
以下の順番で、決勝進出者の選手番号とタイムを空白区切りでそれぞれ１行に出力してください。
1 組目の 1 位の選手
1 組目の 2 位の選手
2 組目の 1 位の選手
2 組目の 2 位の選手
3 組目の 1 位の選手
3 組目の 2 位の選手
各組で 3 位以下の選手の中でタイムが 1 位の選手
各組で 3 位以下の選手の中でタイムが 2 位の選手
Sample Input
18 25.46
16 26.23
3 23.00
10 24.79
5 22.88
11 23.87
19 23.90
1 25.11
23 23.88
4 23.46
7 24.12
12 22.91
13 21.99
14 22.86
21 23.12
9 24.09
17 22.51
22 23.49
6 23.02
20 22.23
24 21.89
15 24.14
8 23.77
2 23.42
Output for the Sample Input
5 22.88
3 23.00
13 21.99
14 22.86
24 21.89
20 22.23
17 22.51
12 22.91",C,"#include<stdio.h>
int main(void)
{
	int i,j,num[24+1],temp01;
	float time[24+1],temp02;
	for(i=0;i<24;i++) {
		scanf(""%d %f"",&num[i],&time[i]);
	}
	for(i=0;i<8-1;i++) {
		for(j=i+1;j<8;j++) {
			if(time[i]>time[j]) {
				temp01=num[i];
				num[i]=num[j];
				num[j]=temp01;
				temp02=time[i];
				time[i]=time[j];
				time[j]=temp02;
			}
		}
	}
	for(i=8;i<16-1;i++) {
		for(j=i+1;j<16;j++) {
			if(time[i]>time[j]) {
				temp01=num[i];
				num[i]=num[j];
				num[j]=temp01;
				temp02=time[i];
				time[i]=time[j];
				time[j]=temp02;
			}
		}
	}
	for(i=16;i<24-1;i++) {
		for(j=i+1;j<24;j++) {
			if(time[i]>time[j]) {
				temp01=num[i];
				num[i]=num[j];
				num[j]=temp01;
				temp02=time[i];
				time[i]=time[j];
				time[j]=temp02;
			}
		}
	}
	for(i=0;i<2;i++) {
		printf(""%d %f\n"",num[i],time[i]);
		time[i]=100.00;
	}
	for(i=8;i<10;i++) {
		printf(""%d %f\n"",num[i],time[i]);
		time[i]=100.00;
	}
	for(i=16;i<18;i++) {
		printf(""%d %f\n"",num[i],time[i]);
		time[i]=100.00;
	}
	for(i=0;i<24-1;i++) {
		for(j=i+1;j<24;j++) {
			if(time[i]>time[j]) {
				temp01=num[i];
				num[i]=num[j];
				num[j]=temp01;
				temp02=time[i];
				time[i]=time[j];
				time[j]=temp02;
			}
		}
	}
	for(i=0;i<2;i++) {
		printf(""%d %f\n"",num[i],time[i]);
	}
	return 0;
}",1
p00138,"陸上競技大会
陸上競技大会 200M の準決勝 3 組のレースが行われました。それぞれの組に 8 名（計 24 名）の選手が出場します。各組上位 2 位までの選手と、各組の 3 位以下の全選手の中から上位 2 名の計 8 名が決勝に進出します。
選手番号とタイムを入力とし、決勝進出者 8 名の番号とそのタイムを出力するプログラムを作成してください。
Input
入力は以下の形式で与えられます。
p
1
t
1
p
2
t
2
:
p
24
t
24
1 行目から 8 行目に１組目の選手番号
p
i
(整数、1 ≤
p
i
≤ 10000) とタイム
t
i
(1/100 まで計測した実数、1 ≤
t
i
≤ 100)、9 行目から 16 行目に２組目の選手番号
p
i
とタイム
t
i
、17 行目から 24 行目に３組目の選手番号
p
i
とタイム
t
i
が与えられます。同じ選手番号の選手、同タイムの選手はいないものとします。
Output
以下の順番で、決勝進出者の選手番号とタイムを空白区切りでそれぞれ１行に出力してください。
1 組目の 1 位の選手
1 組目の 2 位の選手
2 組目の 1 位の選手
2 組目の 2 位の選手
3 組目の 1 位の選手
3 組目の 2 位の選手
各組で 3 位以下の選手の中でタイムが 1 位の選手
各組で 3 位以下の選手の中でタイムが 2 位の選手
Sample Input
18 25.46
16 26.23
3 23.00
10 24.79
5 22.88
11 23.87
19 23.90
1 25.11
23 23.88
4 23.46
7 24.12
12 22.91
13 21.99
14 22.86
21 23.12
9 24.09
17 22.51
22 23.49
6 23.02
20 22.23
24 21.89
15 24.14
8 23.77
2 23.42
Output for the Sample Input
5 22.88
3 23.00
13 21.99
14 22.86
24 21.89
20 22.23
17 22.51
12 22.91",Java,"import java.util.*;

public class Main {
    static class Athlete implements Comparable<Athlete> {
        int number;
        double time;
        
        Athlete(int number, double time) {
            this.number = number;
            this.time = time;
        }
        
        @Override
        public int compareTo(Athlete other) {
            return Double.compare(this.time, other.time);
        }
    }
    
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        
        List<Athlete>[] groups = new List[3];
        for (int i = 0; i < 3; i++) {
            groups[i] = new ArrayList<>();
        }
        
        // Read input
        for (int i = 0; i < 24; i++) {
            int number = sc.nextInt();
            double time = sc.nextDouble();
            int group = i / 8;
            groups[group].add(new Athlete(number, time));
        }
        
        // Sort each group by time
        for (int i = 0; i < 3; i++) {
            Collections.sort(groups[i]);
        }
        
        // Output top 2 from each group
        List<Athlete> finalists = new ArrayList<>();
        for (int i = 0; i < 3; i++) {
            finalists.add(groups[i].get(0));
            finalists.add(groups[i].get(1));
        }
        
        // Get 3rd place and below from all groups
        List<Athlete> remaining = new ArrayList<>();
        for (int i = 0; i < 3; i++) {
            for (int j = 2; j < groups[i].size(); j++) {
                remaining.add(groups[i].get(j));
            }
        }
        
        // Sort remaining athletes and get top 2
        Collections.sort(remaining);
        finalists.add(remaining.get(0));
        finalists.add(remaining.get(1));
        
        // Output all finalists
        for (Athlete a : finalists) {
            System.out.println(a.number + "" "" + a.time);
        }
        
        sc.close();
    }
}
",0
p00138,"陸上競技大会
陸上競技大会 200M の準決勝 3 組のレースが行われました。それぞれの組に 8 名（計 24 名）の選手が出場します。各組上位 2 位までの選手と、各組の 3 位以下の全選手の中から上位 2 名の計 8 名が決勝に進出します。
選手番号とタイムを入力とし、決勝進出者 8 名の番号とそのタイムを出力するプログラムを作成してください。
Input
入力は以下の形式で与えられます。
p
1
t
1
p
2
t
2
:
p
24
t
24
1 行目から 8 行目に１組目の選手番号
p
i
(整数、1 ≤
p
i
≤ 10000) とタイム
t
i
(1/100 まで計測した実数、1 ≤
t
i
≤ 100)、9 行目から 16 行目に２組目の選手番号
p
i
とタイム
t
i
、17 行目から 24 行目に３組目の選手番号
p
i
とタイム
t
i
が与えられます。同じ選手番号の選手、同タイムの選手はいないものとします。
Output
以下の順番で、決勝進出者の選手番号とタイムを空白区切りでそれぞれ１行に出力してください。
1 組目の 1 位の選手
1 組目の 2 位の選手
2 組目の 1 位の選手
2 組目の 2 位の選手
3 組目の 1 位の選手
3 組目の 2 位の選手
各組で 3 位以下の選手の中でタイムが 1 位の選手
各組で 3 位以下の選手の中でタイムが 2 位の選手
Sample Input
18 25.46
16 26.23
3 23.00
10 24.79
5 22.88
11 23.87
19 23.90
1 25.11
23 23.88
4 23.46
7 24.12
12 22.91
13 21.99
14 22.86
21 23.12
9 24.09
17 22.51
22 23.49
6 23.02
20 22.23
24 21.89
15 24.14
8 23.77
2 23.42
Output for the Sample Input
5 22.88
3 23.00
13 21.99
14 22.86
24 21.89
20 22.23
17 22.51
12 22.91",Java,"import java.util.Arrays;
import java.util.Scanner;
class Player implements Comparable<Player>{
	int party;
	int num;
	String time;
	Player(int p,int n,String t){
		this.party = p;
		this.num = n;
		this.time = t;
	}
	/*@Override
	public int compareTo(Player p) {
		return this.time.compareTo(p.num);
	}
	*/
	@Override
	public int compareTo(Player o) {
		// TODO Auto-generated method stub
		return this.time.compareTo(o.time);
	}
	
}

public class Main{
	public static void main(String[] args){
		Scanner sc = new Scanner(System.in);
		Player[] person = new Player[24];
		int[][] rank = new int[3][8];
		int[] cnt = new int[3]; 
		int cnt1 = 0;
		int cnt2 = 0;
		int cnt3 = 0;
		for(int i = 0;i < 3;i++){
			for(int j = 0;j < 8;j++){
				person[i*8+j] = new Player(i,sc.nextInt(),sc.next());
			}
		}
		Arrays.sort(person);
		for(int i = 0;i < 24;i++){
			rank[person[i].party][cnt[person[i].party]] = i;
			cnt[person[i].party]++;
		}
		for(int i = 0;i < 3;i++){
			for(int j = 0;j < 2;j++){
				System.out.println(person[rank[i][j]].num+"" ""+person[rank[i][j]].time);
				person[rank[i][j]].time = ""999"";
			}
		}
		Arrays.sort(person);
		for(int j = 0;j < 2;j++){
			System.out.println(person[j].num+"" ""+person[j].time);
		}
		
	}
}",1
p00138,"陸上競技大会
陸上競技大会 200M の準決勝 3 組のレースが行われました。それぞれの組に 8 名（計 24 名）の選手が出場します。各組上位 2 位までの選手と、各組の 3 位以下の全選手の中から上位 2 名の計 8 名が決勝に進出します。
選手番号とタイムを入力とし、決勝進出者 8 名の番号とそのタイムを出力するプログラムを作成してください。
Input
入力は以下の形式で与えられます。
p
1
t
1
p
2
t
2
:
p
24
t
24
1 行目から 8 行目に１組目の選手番号
p
i
(整数、1 ≤
p
i
≤ 10000) とタイム
t
i
(1/100 まで計測した実数、1 ≤
t
i
≤ 100)、9 行目から 16 行目に２組目の選手番号
p
i
とタイム
t
i
、17 行目から 24 行目に３組目の選手番号
p
i
とタイム
t
i
が与えられます。同じ選手番号の選手、同タイムの選手はいないものとします。
Output
以下の順番で、決勝進出者の選手番号とタイムを空白区切りでそれぞれ１行に出力してください。
1 組目の 1 位の選手
1 組目の 2 位の選手
2 組目の 1 位の選手
2 組目の 2 位の選手
3 組目の 1 位の選手
3 組目の 2 位の選手
各組で 3 位以下の選手の中でタイムが 1 位の選手
各組で 3 位以下の選手の中でタイムが 2 位の選手
Sample Input
18 25.46
16 26.23
3 23.00
10 24.79
5 22.88
11 23.87
19 23.90
1 25.11
23 23.88
4 23.46
7 24.12
12 22.91
13 21.99
14 22.86
21 23.12
9 24.09
17 22.51
22 23.49
6 23.02
20 22.23
24 21.89
15 24.14
8 23.77
2 23.42
Output for the Sample Input
5 22.88
3 23.00
13 21.99
14 22.86
24 21.89
20 22.23
17 22.51
12 22.91",Python,"# Read all 24 runners
runners = []
for i in range(24):
    line = input().split()
    p = int(line[0])
    t = float(line[1])
    runners.append((p, t))

# Split into 3 groups
group1 = runners[0:8]
group2 = runners[8:16]
group3 = runners[16:24]

# Sort each group by time
group1.sort(key=lambda x: x[1])
group2.sort(key=lambda x: x[1])
group3.sort(key=lambda x: x[1])

# Top 2 from each group
qualifiers = []
qualifiers.append(group1[0])
qualifiers.append(group1[1])
qualifiers.append(group2[0])
qualifiers.append(group2[1])
qualifiers.append(group3[0])
qualifiers.append(group3[1])

# Collect 3rd place and below from all groups
remaining = []
remaining.extend(group1[2:])
remaining.extend(group2[2:])
remaining.extend(group3[2:])

# Sort remaining by time and take top 2
remaining.sort(key=lambda x: x[1])
qualifiers.append(remaining[0])
qualifiers.append(remaining[1])

# Output
for p, t in qualifiers:
    print(f""{p} {t:.2f}"")
",0
p00138,"陸上競技大会
陸上競技大会 200M の準決勝 3 組のレースが行われました。それぞれの組に 8 名（計 24 名）の選手が出場します。各組上位 2 位までの選手と、各組の 3 位以下の全選手の中から上位 2 名の計 8 名が決勝に進出します。
選手番号とタイムを入力とし、決勝進出者 8 名の番号とそのタイムを出力するプログラムを作成してください。
Input
入力は以下の形式で与えられます。
p
1
t
1
p
2
t
2
:
p
24
t
24
1 行目から 8 行目に１組目の選手番号
p
i
(整数、1 ≤
p
i
≤ 10000) とタイム
t
i
(1/100 まで計測した実数、1 ≤
t
i
≤ 100)、9 行目から 16 行目に２組目の選手番号
p
i
とタイム
t
i
、17 行目から 24 行目に３組目の選手番号
p
i
とタイム
t
i
が与えられます。同じ選手番号の選手、同タイムの選手はいないものとします。
Output
以下の順番で、決勝進出者の選手番号とタイムを空白区切りでそれぞれ１行に出力してください。
1 組目の 1 位の選手
1 組目の 2 位の選手
2 組目の 1 位の選手
2 組目の 2 位の選手
3 組目の 1 位の選手
3 組目の 2 位の選手
各組で 3 位以下の選手の中でタイムが 1 位の選手
各組で 3 位以下の選手の中でタイムが 2 位の選手
Sample Input
18 25.46
16 26.23
3 23.00
10 24.79
5 22.88
11 23.87
19 23.90
1 25.11
23 23.88
4 23.46
7 24.12
12 22.91
13 21.99
14 22.86
21 23.12
9 24.09
17 22.51
22 23.49
6 23.02
20 22.23
24 21.89
15 24.14
8 23.77
2 23.42
Output for the Sample Input
5 22.88
3 23.00
13 21.99
14 22.86
24 21.89
20 22.23
17 22.51
12 22.91",Python,"l1,l2,l3=[],[],[]
final=[]
count=0
for i in range(24):
    p,t=map(float,input().split())
    if count<=7:l1.append([t,p])
    elif 7<count<=15:l2.append([t,p])
    elif 15<count<=23:l3.append([t,p])
    count +=1
l1=sorted(l1)
l2=sorted(l2)
l3=sorted(l3)
final +=[l1[0],l1[1],l2[0],l2[1],l3[0],l3[1]]
del l1[0],l1[0],l2[0],l2[0],l3[0],l3[0]
third=sorted(l1+l2+l3)
final +=[third[0],third[1]]
for i in range(8):print(int(final[i][1]),final[i][0])
",1
p00139,"ヘビ
ある世界には，文字だけでできた不思議なヘビが住んでいます。このヘビには現在A種とB種の2種類が確認されていますが、それ以外の種類がいる可能性もあります。
A種は，"">'""の後に""=""が1個以上並んだ後、""#""が来て、さらに前と同じ個数の""=""が来た後、""~""（半角チルダ）で終わります。
B種は，"">^""の後に ""Q=""が1個以上並んだ後、""~~""で終わります。
A種の例： >'====#====~        >'==#==~
B種の例： >^Q=Q=Q=Q=~~        >^Q=Q=~~
ヘビを文字列データとして受け取り、それがどんな種類であるかを判別して、A種の場合は「A」、B種の場合は「B」、それ以外の種類の場合は「NA」を出力するプログラムを作成してください。
Input
入力は以下の形式で与えられます。
n
S
1
S
2
:
S
n
1 行目に判別されるヘビの数
n
（1 ≤
n
≤ 10000）、続く
n
行に
i
匹目のヘビを表す文字列
S
i
(200文字以下の、空白を含まない文字列) がそれぞれ１行に与えられます。
Output
i
行目に
i
匹目のヘビの種類 A、B または NA を出力してください。
Sample Input
3
>'======#======~
>^Q=Q=Q=Q=Q=Q=Q=Q=Q=~~
>'===#====~
Output for the Sample Input
A
B
NA",C,"#include <stdio.h>
#include <string.h>

int checkA(char *s) {
    int len = strlen(s);
    if (len < 6) return 0;
    if (s[0] != '>' || s[1] != '\'') return 0;
    if (s[len-1] != '~') return 0;
    
    int i = 2;
    int count1 = 0;
    while (i < len && s[i] == '=') {
        count1++;
        i++;
    }
    
    if (count1 == 0) return 0;
    if (i >= len || s[i] != '#') return 0;
    i++;
    
    int count2 = 0;
    while (i < len && s[i] == '=') {
        count2++;
        i++;
    }
    
    if (count2 != count1) return 0;
    if (i != len - 1) return 0;
    if (s[i] != '~') return 0;
    
    return 1;
}

int checkB(char *s) {
    int len = strlen(s);
    if (len < 6) return 0;
    if (s[0] != '>' || s[1] != '^') return 0;
    if (len < 2 || s[len-1] != '~' || s[len-2] != '~') return 0;
    
    int i = 2;
    int count = 0;
    while (i < len - 2) {
        if (s[i] == 'Q' && i + 1 < len - 2 && s[i+1] == '=') {
            count++;
            i += 2;
        } else {
            return 0;
        }
    }
    
    if (count == 0) return 0;
    if (i != len - 2) return 0;
    
    return 1;
}

int main() {
    int n;
    scanf(""%d"", &n);
    
    for (int i = 0; i < n; i++) {
        char s[201];
        scanf(""%s"", s);
        
        if (checkA(s)) {
            printf(""A\n"");
        } else if (checkB(s)) {
            printf(""B\n"");
        } else {
            printf(""NA\n"");
        }
    }
    
    return 0;
}
",0
p00139,"ヘビ
ある世界には，文字だけでできた不思議なヘビが住んでいます。このヘビには現在A種とB種の2種類が確認されていますが、それ以外の種類がいる可能性もあります。
A種は，"">'""の後に""=""が1個以上並んだ後、""#""が来て、さらに前と同じ個数の""=""が来た後、""~""（半角チルダ）で終わります。
B種は，"">^""の後に ""Q=""が1個以上並んだ後、""~~""で終わります。
A種の例： >'====#====~        >'==#==~
B種の例： >^Q=Q=Q=Q=~~        >^Q=Q=~~
ヘビを文字列データとして受け取り、それがどんな種類であるかを判別して、A種の場合は「A」、B種の場合は「B」、それ以外の種類の場合は「NA」を出力するプログラムを作成してください。
Input
入力は以下の形式で与えられます。
n
S
1
S
2
:
S
n
1 行目に判別されるヘビの数
n
（1 ≤
n
≤ 10000）、続く
n
行に
i
匹目のヘビを表す文字列
S
i
(200文字以下の、空白を含まない文字列) がそれぞれ１行に与えられます。
Output
i
行目に
i
匹目のヘビの種類 A、B または NA を出力してください。
Sample Input
3
>'======#======~
>^Q=Q=Q=Q=Q=Q=Q=Q=Q=~~
>'===#====~
Output for the Sample Input
A
B
NA",C,"#include<stdio.h>

int main(void){
  char w[201];
  int a,i,j,k;
  scanf(""%d"",&a);
  for(j=0;j<a;j++){
    scanf(""%s"",w);
    if(w[0]!='>'){printf(""NA\n"");continue;}
    if(w[1]=='\''){
      for(i=2;w[i]!='#';i++){
	if(w[i]!='='){printf(""NA\n"");continue;}
      }
      int t=i-1;
      for(k=t;t>0;t--){
	if(w[i++]!='='){printf(""NA\n"");continue;}
      }
      if(w[i++]!='~'){printf(""NA\n"");continue;}
      if(w[i]!='\0'){printf(""NA\n"");continue;}
      printf(""A\n"");
    }
    if(w[1]=='^'){
      for(i=2;w[i]=='~';i+=2){
	if(w[i]!='Q'){printf(""NA\n"");continue;}
	if(w[i+1]!='='){printf(""NA\n"");continue;}
      }
      if(w[i]!='~'){printf(""NA\n"");continue;}
      if(w[i+1]!='~'){printf(""NA\n"");continue;}
      if(w[i+2]!='\0'){printf(""NA\n"");continue;}
      printf(""B\n"");
    }
  }
return 0;
}",1
p00139,"ヘビ
ある世界には，文字だけでできた不思議なヘビが住んでいます。このヘビには現在A種とB種の2種類が確認されていますが、それ以外の種類がいる可能性もあります。
A種は，"">'""の後に""=""が1個以上並んだ後、""#""が来て、さらに前と同じ個数の""=""が来た後、""~""（半角チルダ）で終わります。
B種は，"">^""の後に ""Q=""が1個以上並んだ後、""~~""で終わります。
A種の例： >'====#====~        >'==#==~
B種の例： >^Q=Q=Q=Q=~~        >^Q=Q=~~
ヘビを文字列データとして受け取り、それがどんな種類であるかを判別して、A種の場合は「A」、B種の場合は「B」、それ以外の種類の場合は「NA」を出力するプログラムを作成してください。
Input
入力は以下の形式で与えられます。
n
S
1
S
2
:
S
n
1 行目に判別されるヘビの数
n
（1 ≤
n
≤ 10000）、続く
n
行に
i
匹目のヘビを表す文字列
S
i
(200文字以下の、空白を含まない文字列) がそれぞれ１行に与えられます。
Output
i
行目に
i
匹目のヘビの種類 A、B または NA を出力してください。
Sample Input
3
>'======#======~
>^Q=Q=Q=Q=Q=Q=Q=Q=Q=~~
>'===#====~
Output for the Sample Input
A
B
NA",Java,"import java.util.*;

public class Main {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int n = sc.nextInt();
        sc.nextLine();
        
        for (int i = 0; i < n; i++) {
            String s = sc.nextLine();
            System.out.println(classify(s));
        }
        sc.close();
    }
    
    static String classify(String s) {
        if (isTypeA(s)) {
            return ""A"";
        } else if (isTypeB(s)) {
            return ""B"";
        } else {
            return ""NA"";
        }
    }
    
    static boolean isTypeA(String s) {
        // Pattern: >'=+#=+~
        // Must start with >'
        if (!s.startsWith("">'"")) {
            return false;
        }
        
        // Must end with ~
        if (!s.endsWith(""~"")) {
            return false;
        }
        
        // Find # position
        int hashPos = s.indexOf('#');
        if (hashPos == -1) {
            return false;
        }
        
        // Check if there's only one #
        if (s.indexOf('#', hashPos + 1) != -1) {
            return false;
        }
        
        // Extract parts
        String beforeHash = s.substring(2, hashPos);
        String afterHash = s.substring(hashPos + 1, s.length() - 1);
        
        // Both parts must be non-empty and consist only of '='
        if (beforeHash.length() == 0 || afterHash.length() == 0) {
            return false;
        }
        
        // Both parts must have same length and only contain '='
        if (beforeHash.length() != afterHash.length()) {
            return false;
        }
        
        for (char c : beforeHash.toCharArray()) {
            if (c != '=') {
                return false;
            }
        }
        
        for (char c : afterHash.toCharArray()) {
            if (c != '=') {
                return false;
            }
        }
        
        return true;
    }
    
    static boolean isTypeB(String s) {
        // Pattern: >^(Q=)+~~
        // Must start with >^
        if (!s.startsWith("">^"")) {
            return false;
        }
        
        // Must end with ~~
        if (!s.endsWith(""~~"")) {
            return false;
        }
        
        // Extract middle part
        String middle = s.substring(2, s.length() - 2);
        
        // Middle must be non-empty
        if (middle.length() == 0) {
            return false;
        }
        
        // Middle must be repetitions of ""Q=""
        if (middle.length() % 2 != 0) {
            return false;
        }
        
        for (int i = 0; i < middle.length(); i += 2) {
            if (middle.charAt(i) != 'Q' || middle.charAt(i + 1) != '=') {
                return false;
            }
        }
        
        return true;
    }
}
",0
p00139,"ヘビ
ある世界には，文字だけでできた不思議なヘビが住んでいます。このヘビには現在A種とB種の2種類が確認されていますが、それ以外の種類がいる可能性もあります。
A種は，"">'""の後に""=""が1個以上並んだ後、""#""が来て、さらに前と同じ個数の""=""が来た後、""~""（半角チルダ）で終わります。
B種は，"">^""の後に ""Q=""が1個以上並んだ後、""~~""で終わります。
A種の例： >'====#====~        >'==#==~
B種の例： >^Q=Q=Q=Q=~~        >^Q=Q=~~
ヘビを文字列データとして受け取り、それがどんな種類であるかを判別して、A種の場合は「A」、B種の場合は「B」、それ以外の種類の場合は「NA」を出力するプログラムを作成してください。
Input
入力は以下の形式で与えられます。
n
S
1
S
2
:
S
n
1 行目に判別されるヘビの数
n
（1 ≤
n
≤ 10000）、続く
n
行に
i
匹目のヘビを表す文字列
S
i
(200文字以下の、空白を含まない文字列) がそれぞれ１行に与えられます。
Output
i
行目に
i
匹目のヘビの種類 A、B または NA を出力してください。
Sample Input
3
>'======#======~
>^Q=Q=Q=Q=Q=Q=Q=Q=Q=~~
>'===#====~
Output for the Sample Input
A
B
NA",Java,"import java.io.*;
import java.util.*;

public class Main{
	public static void main(String[] args){
		try{
			new Main();
		}catch(IOException e){
			e.printStackTrace();
		}
	}
	
	public Main() throws IOException{
		BufferedReader in = new BufferedReader(new InputStreamReader(System.in));
		List<String> Ans = new ArrayList<String>();
		String line = in.readLine();
		
		int size = Integer.parseInt(line);
		for(int n=0; n<size; n++){
			line = in.readLine();
			int type = 0;
			
			String c = line.substring(0, 2);
			if(c.equals("">'"")){
				int count = 0;
				int sharp = 0;
				for(int i=2; i<line.length(); i++){
					c = line.substring(i, i+1);
					if(c.equals(""="")){
						count++;
					}
					else if(c.equals(""#"")){
						if(count > 0){
							count = -count;
							sharp = 1;
						}
						else{
							type = -1;
							break;
						}
					}
					else if(c.equals(""~"")){
						if(i != line.length()-1){
							type = -1;
							break;
						}
						
						if(count==0 && sharp==1){
							type = 1;
							break;
						}
						else{
							type = -1;
							break;
						}
					}
					else{
						type = -1;
						break;
					}
				}
			}
			else if(c.equals("">^"")){
				int count = 0;
				for(int i=2; i<line.length(); i++){
					c = line.substring(i, i+1);
					if(count%2==0 && count>=2 && c.equals(""~"")){
						if(i==line.length()-1){
							type = -1;
							break;
						}
						
						c = line.substring(i+1, i+2);
						if(c.equals(""~"")){
							type = 2;
							break;
						}
						else{
							type = -1;
							break;
						}
					}
					if(i%2==0){
						if(!c.equals(""Q"")){
							type = -1;
							break;
						}
						count++;
					}
					if(i%2==1){
						if(!c.equals(""="")){
							type = -1;
							break;
						}
						count++;
					}
					
					if(!c.equals(""Q"") && !c.equals(""="") && !c.equals(""~"")){
						type = -1;
						break;
					}
				}
			}
			else{
				type = -1;
			}
			
			switch(type){
				case 1:
					Ans.add(""A"");
					break;
					
				case 2:
					Ans.add(""B"");
					break;
					
				default:
					Ans.add(""NA"");
			}
		}
		
		for(int n=0; n<Ans.size(); n++){
			System.out.println(Ans.get(n));
		}
	}
}",1
p00139,"ヘビ
ある世界には，文字だけでできた不思議なヘビが住んでいます。このヘビには現在A種とB種の2種類が確認されていますが、それ以外の種類がいる可能性もあります。
A種は，"">'""の後に""=""が1個以上並んだ後、""#""が来て、さらに前と同じ個数の""=""が来た後、""~""（半角チルダ）で終わります。
B種は，"">^""の後に ""Q=""が1個以上並んだ後、""~~""で終わります。
A種の例： >'====#====~        >'==#==~
B種の例： >^Q=Q=Q=Q=~~        >^Q=Q=~~
ヘビを文字列データとして受け取り、それがどんな種類であるかを判別して、A種の場合は「A」、B種の場合は「B」、それ以外の種類の場合は「NA」を出力するプログラムを作成してください。
Input
入力は以下の形式で与えられます。
n
S
1
S
2
:
S
n
1 行目に判別されるヘビの数
n
（1 ≤
n
≤ 10000）、続く
n
行に
i
匹目のヘビを表す文字列
S
i
(200文字以下の、空白を含まない文字列) がそれぞれ１行に与えられます。
Output
i
行目に
i
匹目のヘビの種類 A、B または NA を出力してください。
Sample Input
3
>'======#======~
>^Q=Q=Q=Q=Q=Q=Q=Q=Q=~~
>'===#====~
Output for the Sample Input
A
B
NA",Python,"import re

n = int(input())
for _ in range(n):
    s = input().strip()
    
    # Check for Type A: >'=+#=+~
    match_a = re.match(r""^>\'(=+)#\1~$"", s)
    if match_a:
        print(""A"")
        continue
    
    # Check for Type B: >^(Q=)+~~
    match_b = re.match(r""^>\^(Q=)+~~$"", s)
    if match_b:
        print(""B"")
        continue
    
    print(""NA"")
",0
p00139,"ヘビ
ある世界には，文字だけでできた不思議なヘビが住んでいます。このヘビには現在A種とB種の2種類が確認されていますが、それ以外の種類がいる可能性もあります。
A種は，"">'""の後に""=""が1個以上並んだ後、""#""が来て、さらに前と同じ個数の""=""が来た後、""~""（半角チルダ）で終わります。
B種は，"">^""の後に ""Q=""が1個以上並んだ後、""~~""で終わります。
A種の例： >'====#====~        >'==#==~
B種の例： >^Q=Q=Q=Q=~~        >^Q=Q=~~
ヘビを文字列データとして受け取り、それがどんな種類であるかを判別して、A種の場合は「A」、B種の場合は「B」、それ以外の種類の場合は「NA」を出力するプログラムを作成してください。
Input
入力は以下の形式で与えられます。
n
S
1
S
2
:
S
n
1 行目に判別されるヘビの数
n
（1 ≤
n
≤ 10000）、続く
n
行に
i
匹目のヘビを表す文字列
S
i
(200文字以下の、空白を含まない文字列) がそれぞれ１行に与えられます。
Output
i
行目に
i
匹目のヘビの種類 A、B または NA を出力してください。
Sample Input
3
>'======#======~
>^Q=Q=Q=Q=Q=Q=Q=Q=Q=~~
>'===#====~
Output for the Sample Input
A
B
NA",Python,"# -*- coding: utf-8 -*-

import sys
import os

N = int(input())

def is_A(s):
    if s[0:2] != "">'"":
        return False

    if s[-1] != '~':
        return False

    body = s[2:-1]

    if len(body) % 2 == 0:
        return False

    # body = '==#=='
    center_index = len(body) // 2
    if body[center_index] != '#':
        return False

    if body.count('#') != 1:
        return False

    lst = body.split('#')
    if len(lst) != 2:
        return False

    if len(lst[0]) > 0 and lst[0] == lst[1] and len(lst[0]) == lst[0].count('='):
        return True
    else:
        return False

def is_B(s):
    if s[0:2] != "">^"":
        return False

    if s[-2:] != '~~':
        return False

    body = s[2:-2]

    if len(body) % 2 != 0:
        return False
    elif body.count('Q=') > 0 and body.count('Q=') == len(body) // 2:
        return True
    else:
        return False

for s in sys.stdin:
    s = s.strip()

    if is_A(s):
        print('A')
    elif is_B(s):
        print('B')
    else:
        print('NA')",1
p00140,"バス路線
図 1のようなバス路線があります。停留所は 10 箇所で、それぞれ 0〜9 の番号がついています。バスは停留所 0 では折り返しますが、反対側は循環路線になっており、図のように 5→6→7→8→9→5 の順で循環します。
このバス路線について、乗車する停留所と降車する停留所を入力とし、乗車から降車までに通る停留所の番号を出力するプログラムを作成してください。
ただし、1〜5 の停留所では 2 方向のバスに乗車できますが、より短い経路で降車停留所に到着するバスに乗車することとします。例えば、停留所 4 から停留所 2 へ行く場合、左方向に進むバスに乗り「4→3→2」の経路を通ります。また、一度バスに乗車したら途中下車はしないものとします。同じ停留所を乗車停留所、降車停留所に指定することはありません。
Input
複数のデータセットが与えられます。一行目にデータセット数
n
(
n
≤ 20 ) が与えられます。各データセットとして、乗車する停留所番号と降車する停留所番号が空白区切りで１行に与えられます。
Output
各データセットに対して、通過する停留所番号の並びを空白区切りで１行に出力してください。
Sample Input
2
2 4
4 2
Output for the Sample Input
2 3 4
4 3 2",C,"#include <stdio.h>

int main() {
    int n;
    scanf(""%d"", &n);
    
    while (n--) {
        int start, end;
        scanf(""%d %d"", &start, &end);
        
        // Calculate distances for different routes
        int dist_forward = 0;
        int dist_backward = 0;
        
        // Going forward (clockwise direction)
        if (start <= 5 && end <= 5) {
            if (end > start) {
                dist_forward = end - start;
            } else {
                // Need to go through the loop
                dist_forward = (5 - start) + 1 + (9 - 5) + 1 + (5 - end);
            }
        } else if (start <= 5 && end > 5) {
            // From main line to loop
            if (start <= 5) {
                dist_forward = (5 - start) + (end - 5);
            }
        } else if (start > 5 && end <= 5) {
            // From loop to main line
            if (end <= 5) {
                if (start == 9) dist_forward = 1 + end;
                else if (start == 8) dist_forward = 2 + end;
                else if (start == 7) dist_forward = 3 + end;
                else if (start == 6) dist_forward = 4 + end;
            }
        } else {
            // Both in loop
            if (end > start) {
                dist_forward = end - start;
            } else {
                dist_forward = (9 - start) + 1 + (end - 5);
            }
        }
        
        // Going backward (counter-clockwise)
        if (start <= 5 && end <= 5) {
            if (end < start) {
                dist_backward = start - end;
            } else {
                // Need to go through the loop
                dist_backward = start + 1 + (9 - 5) + 1 + (5 - end);
            }
        } else if (start <= 5 && end > 5) {
            // From main line to loop through 0
            dist_backward = start + 1 + (9 - end) + 1;
        } else if (start > 5 && end <= 5) {
            // From loop to main line
            if (start == 6) dist_backward = 1 + (5 - end);
            else if (start == 7) dist_backward = 2 + (5 - end);
            else if (start == 8) dist_backward = 3 + (5 - end);
            else if (start == 9) dist_backward = 4 + (5 - end);
        } else {
            // Both in loop
            if (end < start) {
                dist_backward = start - end;
            } else {
                dist_backward = (start - 5) + 1 + (9 - end) + 1;
            }
        }
        
        // Choose the shorter route
        int go_forward = (dist_forward <= dist_backward);
        
        int pos = start;
        printf(""%d"", pos);
        
        while (pos != end) {
            if (go_forward) {
                if (pos < 5) {
                    pos++;
                } else if (pos == 5) {
                    if (end > 5 || end == 0) {
                        pos = 6;
                    } else {
                        pos--;
                    }
                } else if (pos >= 6 && pos <= 8) {
                    pos++;
                } else if (pos == 9) {
                    pos = 5;
                }
            } else {
                if (pos > 0 && pos <= 5) {
                    pos--;
                } else if (pos == 6) {
                    pos = 5;
                } else if (pos >= 7 && pos <= 9) {
                    pos--;
                } else if (pos == 0) {
                    pos = 1;
                }
            }
            printf("" %d"", pos);
        }
        printf(""\n"");
    }
    
    return 0;
}
",0
p00140,"バス路線
図 1のようなバス路線があります。停留所は 10 箇所で、それぞれ 0〜9 の番号がついています。バスは停留所 0 では折り返しますが、反対側は循環路線になっており、図のように 5→6→7→8→9→5 の順で循環します。
このバス路線について、乗車する停留所と降車する停留所を入力とし、乗車から降車までに通る停留所の番号を出力するプログラムを作成してください。
ただし、1〜5 の停留所では 2 方向のバスに乗車できますが、より短い経路で降車停留所に到着するバスに乗車することとします。例えば、停留所 4 から停留所 2 へ行く場合、左方向に進むバスに乗り「4→3→2」の経路を通ります。また、一度バスに乗車したら途中下車はしないものとします。同じ停留所を乗車停留所、降車停留所に指定することはありません。
Input
複数のデータセットが与えられます。一行目にデータセット数
n
(
n
≤ 20 ) が与えられます。各データセットとして、乗車する停留所番号と降車する停留所番号が空白区切りで１行に与えられます。
Output
各データセットに対して、通過する停留所番号の並びを空白区切りで１行に出力してください。
Sample Input
2
2 4
4 2
Output for the Sample Input
2 3 4
4 3 2",C,"#include <stdio.h>
int main(){
	char tei[15]={0,1,2,3,4,5,6,7,8,9,5,4,3,2,1},ans[1000][20];
	int n,i,to,from,j;
	scanf(""%d"",&n);
	for(i=0;i<n;i++){
		scanf(""%d %d"",&from,&to);
		if(from<to){
				for(j=from;j<to;j++){
					printf(""%d "",j);
				}
				printf(""%d\n"",to);
		}else if(to==5){
			for(j=from;j<=9;j++){
				printf(""%d "",j);
			}
			puts(""5"");
		}else if(from>to){
			if(from>=6&&from<=9){
				for(j=from;j<=9;j++){
					printf(""%d "",j);
				}
				for(j=5;j>to;j--){
					printf(""%d "",j);
				}
				printf(""%d\n"",to);
			}else{
				for(j=from;j>to;j--){
					printf(""%d "",j);
				}
				printf(""%d\n"",to);
			}
		}
	}
	
	return 0;
}",1
p00140,"バス路線
図 1のようなバス路線があります。停留所は 10 箇所で、それぞれ 0〜9 の番号がついています。バスは停留所 0 では折り返しますが、反対側は循環路線になっており、図のように 5→6→7→8→9→5 の順で循環します。
このバス路線について、乗車する停留所と降車する停留所を入力とし、乗車から降車までに通る停留所の番号を出力するプログラムを作成してください。
ただし、1〜5 の停留所では 2 方向のバスに乗車できますが、より短い経路で降車停留所に到着するバスに乗車することとします。例えば、停留所 4 から停留所 2 へ行く場合、左方向に進むバスに乗り「4→3→2」の経路を通ります。また、一度バスに乗車したら途中下車はしないものとします。同じ停留所を乗車停留所、降車停留所に指定することはありません。
Input
複数のデータセットが与えられます。一行目にデータセット数
n
(
n
≤ 20 ) が与えられます。各データセットとして、乗車する停留所番号と降車する停留所番号が空白区切りで１行に与えられます。
Output
各データセットに対して、通過する停留所番号の並びを空白区切りで１行に出力してください。
Sample Input
2
2 4
4 2
Output for the Sample Input
2 3 4
4 3 2",Java,"import java.util.*;

public class Main {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int n = sc.nextInt();
        
        for (int i = 0; i < n; i++) {
            int start = sc.nextInt();
            int end = sc.nextInt();
            
            List<Integer> path = findPath(start, end);
            
            for (int j = 0; j < path.size(); j++) {
                if (j > 0) System.out.print("" "");
                System.out.print(path.get(j));
            }
            System.out.println();
        }
        
        sc.close();
    }
    
    static List<Integer> findPath(int start, int end) {
        List<Integer> path = new ArrayList<>();
        
        // Calculate distances for both directions
        int dist1 = distanceClockwise(start, end);
        int dist2 = distanceCounterClockwise(start, end);
        
        if (dist1 <= dist2) {
            // Go clockwise
            int current = start;
            path.add(current);
            while (current != end) {
                current = next(current);
                path.add(current);
            }
        } else {
            // Go counterclockwise
            int current = start;
            path.add(current);
            while (current != end) {
                current = prev(current);
                path.add(current);
            }
        }
        
        return path;
    }
    
    static int distanceClockwise(int start, int end) {
        int dist = 0;
        int current = start;
        while (current != end) {
            current = next(current);
            dist++;
            if (dist > 20) return Integer.MAX_VALUE; // Safety check
        }
        return dist;
    }
    
    static int distanceCounterClockwise(int start, int end) {
        int dist = 0;
        int current = start;
        while (current != end) {
            current = prev(current);
            dist++;
            if (dist > 20) return Integer.MAX_VALUE; // Safety check
        }
        return dist;
    }
    
    static int next(int pos) {
        if (pos >= 0 && pos < 5) {
            return pos + 1;
        } else if (pos == 5) {
            return 6;
        } else if (pos == 6) {
            return 7;
        } else if (pos == 7) {
            return 8;
        } else if (pos == 8) {
            return 9;
        } else if (pos == 9) {
            return 5;
        }
        return -1;
    }
    
    static int prev(int pos) {
        if (pos >= 1 && pos <= 5) {
            return pos - 1;
        } else if (pos == 6) {
            return 5;
        } else if (pos == 7) {
            return 6;
        } else if (pos == 8) {
            return 7;
        } else if (pos == 9) {
            return 8;
        } else if (pos == 0) {
            return -1; // Can't go back from 0
        }
        return -1;
    }
}
",0
p00140,"バス路線
図 1のようなバス路線があります。停留所は 10 箇所で、それぞれ 0〜9 の番号がついています。バスは停留所 0 では折り返しますが、反対側は循環路線になっており、図のように 5→6→7→8→9→5 の順で循環します。
このバス路線について、乗車する停留所と降車する停留所を入力とし、乗車から降車までに通る停留所の番号を出力するプログラムを作成してください。
ただし、1〜5 の停留所では 2 方向のバスに乗車できますが、より短い経路で降車停留所に到着するバスに乗車することとします。例えば、停留所 4 から停留所 2 へ行く場合、左方向に進むバスに乗り「4→3→2」の経路を通ります。また、一度バスに乗車したら途中下車はしないものとします。同じ停留所を乗車停留所、降車停留所に指定することはありません。
Input
複数のデータセットが与えられます。一行目にデータセット数
n
(
n
≤ 20 ) が与えられます。各データセットとして、乗車する停留所番号と降車する停留所番号が空白区切りで１行に与えられます。
Output
各データセットに対して、通過する停留所番号の並びを空白区切りで１行に出力してください。
Sample Input
2
2 4
4 2
Output for the Sample Input
2 3 4
4 3 2",Java,"import java.io.*;
import java.util.*;
import java.math.*;
class Main{
    public static void main(String[] args){
	BufferedReader sc=new BufferedReader(new InputStreamReader(System.in));
	try {
	    int n = Integer.valueOf(sc.readLine());
	    ArrayList<Integer> road;
	    for(int i=0; i<n; i++){
		road = new ArrayList<Integer>();
		String[] st = sc.readLine().split("" "");
		int in = Integer.valueOf(st[0]), out = Integer.valueOf(st[1]);
		if(in<=5)
		    if(in>out)
			for(int j=in; j>=out; j--)
			    road.add(j);
		    else
			for(int j=in; j<=out; j++)
			    road.add(j);
		else{
		    if(out>in)
			for(int j=in; j<=out; j++)
			    road.add(j);
		    else{
			for(int j=in; j<=9; j++)
			    road.add(j);
			if(out>=5){
			    for(int j=5; j>=0; j--)
				road.add(j);
			    for(int j=1; j<=out; j++)
				road.add(j);
			}
			else
			    for(int j=5; j>=out; j--)
				road.add(j);
		    }
		}
		for(int j=0; j<road.size()-1; j++)
		    System.out.print(road.get(j)+"" "");
		System.out.println(road.get(road.size()-1));
	    }
	}catch(Exception e){
	    System.out.println(""Error"");
	}
    }
}",1
p00140,"バス路線
図 1のようなバス路線があります。停留所は 10 箇所で、それぞれ 0〜9 の番号がついています。バスは停留所 0 では折り返しますが、反対側は循環路線になっており、図のように 5→6→7→8→9→5 の順で循環します。
このバス路線について、乗車する停留所と降車する停留所を入力とし、乗車から降車までに通る停留所の番号を出力するプログラムを作成してください。
ただし、1〜5 の停留所では 2 方向のバスに乗車できますが、より短い経路で降車停留所に到着するバスに乗車することとします。例えば、停留所 4 から停留所 2 へ行く場合、左方向に進むバスに乗り「4→3→2」の経路を通ります。また、一度バスに乗車したら途中下車はしないものとします。同じ停留所を乗車停留所、降車停留所に指定することはありません。
Input
複数のデータセットが与えられます。一行目にデータセット数
n
(
n
≤ 20 ) が与えられます。各データセットとして、乗車する停留所番号と降車する停留所番号が空白区切りで１行に与えられます。
Output
各データセットに対して、通過する停留所番号の並びを空白区切りで１行に出力してください。
Sample Input
2
2 4
4 2
Output for the Sample Input
2 3 4
4 3 2",Python,"from collections import deque

def find_path(start, end):
    # BFS to find shortest path
    queue = deque([(start, [start])])
    visited = {start}
    
    while queue:
        current, path = queue.popleft()
        
        if current == end:
            return path
        
        # Get neighbors based on bus route structure
        neighbors = []
        
        if current == 0:
            neighbors = [1]
        elif current == 1:
            neighbors = [0, 2]
        elif current == 2:
            neighbors = [1, 3]
        elif current == 3:
            neighbors = [2, 4]
        elif current == 4:
            neighbors = [3, 5]
        elif current == 5:
            neighbors = [4, 6, 9]
        elif current == 6:
            neighbors = [5, 7]
        elif current == 7:
            neighbors = [6, 8]
        elif current == 8:
            neighbors = [7, 9]
        elif current == 9:
            neighbors = [8, 5]
        
        for neighbor in neighbors:
            if neighbor not in visited:
                visited.add(neighbor)
                queue.append((neighbor, path + [neighbor]))
    
    return []

n = int(input())
for _ in range(n):
    start, end = map(int, input().split())
    path = find_path(start, end)
    print(' '.join(map(str, path)))
",0
p00140,"バス路線
図 1のようなバス路線があります。停留所は 10 箇所で、それぞれ 0〜9 の番号がついています。バスは停留所 0 では折り返しますが、反対側は循環路線になっており、図のように 5→6→7→8→9→5 の順で循環します。
このバス路線について、乗車する停留所と降車する停留所を入力とし、乗車から降車までに通る停留所の番号を出力するプログラムを作成してください。
ただし、1〜5 の停留所では 2 方向のバスに乗車できますが、より短い経路で降車停留所に到着するバスに乗車することとします。例えば、停留所 4 から停留所 2 へ行く場合、左方向に進むバスに乗り「4→3→2」の経路を通ります。また、一度バスに乗車したら途中下車はしないものとします。同じ停留所を乗車停留所、降車停留所に指定することはありません。
Input
複数のデータセットが与えられます。一行目にデータセット数
n
(
n
≤ 20 ) が与えられます。各データセットとして、乗車する停留所番号と降車する停留所番号が空白区切りで１行に与えられます。
Output
各データセットに対して、通過する停留所番号の並びを空白区切りで１行に出力してください。
Sample Input
2
2 4
4 2
Output for the Sample Input
2 3 4
4 3 2",Python,"for _ in [0]*input():
  A = ""012345678954321""
  A += A
  a, b = raw_input().split()
  i1 = A.index(a)
  i2 = A.index(a,i1+1)
  i3 = A.index(b,i1)
  if i2<i3: i1=i2
  print "" "".join(A[i1:i3+1])",1
p00141,"ぐるぐる模様
「ぐるぐる模様」を表示するプログラムを作成することにしました。「ぐるぐる模様」は以下のようなものとします。
1 辺の長さが
n
の場合、
n
行
n
列の文字列として表示する。
左下隅を基点とし，時計回りに回転する渦状の模様とする。
線のある部分は #（半角シャープ）、空白部分は "" ""（半角空白）で表現する。
線と線の間は空白を置く。
整数
n
を入力とし，1 辺の長さが
n
の「ぐるぐる模様」を出力するプログラムを作成してください。
Input
入力は以下の形式で与えられます。
d
n
1
n
2
:
n
d
１行目にデータセットの数
d
(
d
≤ 20)、続く
d
行に
i
個目のぐるぐる模様の辺の長さ
n
i
(1 ≤
n
i
≤ 100) がそれぞれ１行に与えられます。
Output
データセットごとに、ぐるぐる模様を出力してください。データセットの間に１行の空行を入れてください。
Sample Input
2
5
6
Output for the Sample Input
#####
#   #
# # #
# # #
# ###

######
#    #
# ## #
# #  #
# #  #
# ####",C,"#include <stdio.h>
#include <string.h>

int main() {
    int d, n;
    scanf(""%d"", &d);
    
    for (int dataset = 0; dataset < d; dataset++) {
        scanf(""%d"", &n);
        
        char grid[100][100];
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < n; j++) {
                grid[i][j] = ' ';
            }
        }
        
        int minRow = 0, maxRow = n - 1;
        int minCol = 0, maxCol = n - 1;
        
        while (minRow <= maxRow && minCol <= maxCol) {
            // Bottom row (left to right)
            for (int j = minCol; j <= maxCol; j++) {
                grid[maxRow][j] = '#';
            }
            
            // Right column (bottom to top)
            for (int i = maxRow; i >= minRow; i--) {
                grid[i][maxCol] = '#';
            }
            
            // Top row (right to left)
            if (minRow < maxRow) {
                for (int j = maxCol; j >= minCol; j--) {
                    grid[minRow][j] = '#';
                }
            }
            
            // Left column (top to bottom)
            if (minCol < maxCol) {
                for (int i = minRow; i <= maxRow; i++) {
                    grid[i][minCol] = '#';
                }
            }
            
            minRow += 2;
            maxRow -= 2;
            minCol += 2;
            maxCol -= 2;
        }
        
        // Print grid
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < n; j++) {
                printf(""%c"", grid[i][j]);
            }
            printf(""\n"");
        }
        
        if (dataset < d - 1) {
            printf(""\n"");
        }
    }
    
    return 0;
}
",0
p00141,"ぐるぐる模様
「ぐるぐる模様」を表示するプログラムを作成することにしました。「ぐるぐる模様」は以下のようなものとします。
1 辺の長さが
n
の場合、
n
行
n
列の文字列として表示する。
左下隅を基点とし，時計回りに回転する渦状の模様とする。
線のある部分は #（半角シャープ）、空白部分は "" ""（半角空白）で表現する。
線と線の間は空白を置く。
整数
n
を入力とし，1 辺の長さが
n
の「ぐるぐる模様」を出力するプログラムを作成してください。
Input
入力は以下の形式で与えられます。
d
n
1
n
2
:
n
d
１行目にデータセットの数
d
(
d
≤ 20)、続く
d
行に
i
個目のぐるぐる模様の辺の長さ
n
i
(1 ≤
n
i
≤ 100) がそれぞれ１行に与えられます。
Output
データセットごとに、ぐるぐる模様を出力してください。データセットの間に１行の空行を入れてください。
Sample Input
2
5
6
Output for the Sample Input
#####
#   #
# # #
# # #
# ###

######
#    #
# ## #
# #  #
# #  #
# ####",C,"// Aizu Vol-1 0141:   Spiral Pattern
// 2017.8.4

#include <stdio.h>
#include <stdlib.h>
#include <string.h>

char *gets(char *);
char buf[100];

char a[105][105];
#define U 1
#define R 2
#define D 3
#define L 4

int main()
{
	int r, c, n, d, stop;
	int ci, cn;

	gets(buf);
	cn = atoi(buf);
	for (ci = 0; ci < cn; ci++) {
		gets(buf);
		n = atoi(buf);
		memset(a, ' ', sizeof(a));
		for (r = 0; r < n + 4; r += n + 3) {
			for (c = 0; c < n + 4; c++) a[r][c] = '#';
		}
		for (c = 0; c < n + 4; c += n + 3) {
			for (r = 0; r < n + 4; r++) a[r][c] = '#';
		}
		r = n + 1, c = 2, d = U, stop = 0, a[r][c] = '#';
		while (1) {
			if (stop >= 4) break;
			if (d == U) {
				if (a[r-2][c] == '#' || a[r-1][c] == '#' || a[r-1][c+1] == '#') d = R, stop++;
				else a[--r][c] = '#', stop = 0;
			}
			if (d == R) {
				if (a[r][c+2] == '#' || a[r][c+1] == '#' || a[r+1][c+1] == '#') d = D, stop++;
				else a[r][++c] = '#', stop = 0;
			}
			if (d == D) {
				if (a[r+2][c] == '#' || a[r+1][c] == '#' || a[r+1][c-1] == '#') d = L, stop++;
				else a[++r][c] = '#', stop = 0;
			}
			if (d == L){
				if (a[r][c-2] == '#' || a[r][c-1] == '#' || a[r-1][c-1] == '#') d = U, stop++;
				else a[r][--c] = '#', stop = 0;
			}
		}
		if (ci > 0) putchar('\n');
		for (r = 2; r < n + 2; r++) {
			a[r][n + 2] = 0;
			puts(a[r]+2);
		}
	}
	return 0;
}",1
p00141,"ぐるぐる模様
「ぐるぐる模様」を表示するプログラムを作成することにしました。「ぐるぐる模様」は以下のようなものとします。
1 辺の長さが
n
の場合、
n
行
n
列の文字列として表示する。
左下隅を基点とし，時計回りに回転する渦状の模様とする。
線のある部分は #（半角シャープ）、空白部分は "" ""（半角空白）で表現する。
線と線の間は空白を置く。
整数
n
を入力とし，1 辺の長さが
n
の「ぐるぐる模様」を出力するプログラムを作成してください。
Input
入力は以下の形式で与えられます。
d
n
1
n
2
:
n
d
１行目にデータセットの数
d
(
d
≤ 20)、続く
d
行に
i
個目のぐるぐる模様の辺の長さ
n
i
(1 ≤
n
i
≤ 100) がそれぞれ１行に与えられます。
Output
データセットごとに、ぐるぐる模様を出力してください。データセットの間に１行の空行を入れてください。
Sample Input
2
5
6
Output for the Sample Input
#####
#   #
# # #
# # #
# ###

######
#    #
# ## #
# #  #
# #  #
# ####",Java,"import java.util.*;

public class Main {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int d = sc.nextInt();
        
        for (int dataset = 0; dataset < d; dataset++) {
            int n = sc.nextInt();
            char[][] grid = new char[n][n];
            
            for (int i = 0; i < n; i++) {
                for (int j = 0; j < n; j++) {
                    grid[i][j] = ' ';
                }
            }
            
            int row = n - 1;
            int col = 0;
            int dir = 0; // 0: right, 1: up, 2: left, 3: down
            int[] dr = {0, -1, 0, 1};
            int[] dc = {1, 0, -1, 0};
            
            int steps = n;
            int currentSteps = 0;
            int dirChanges = 0;
            boolean placed = false;
            
            while (steps > 0) {
                for (int i = 0; i < steps; i++) {
                    if (row >= 0 && row < n && col >= 0 && col < n) {
                        grid[row][col] = '#';
                    }
                    if (i < steps - 1) {
                        row += dr[dir];
                        col += dc[dir];
                    }
                }
                
                row += dr[dir];
                col += dc[dir];
                
                dir = (dir + 1) % 4;
                dirChanges++;
                
                if (dirChanges % 2 == 0) {
                    steps--;
                }
            }
            
            for (int i = 0; i < n; i++) {
                System.out.println(new String(grid[i]));
            }
            
            if (dataset < d - 1) {
                System.out.println();
            }
        }
        
        sc.close();
    }
}
",0
p00141,"ぐるぐる模様
「ぐるぐる模様」を表示するプログラムを作成することにしました。「ぐるぐる模様」は以下のようなものとします。
1 辺の長さが
n
の場合、
n
行
n
列の文字列として表示する。
左下隅を基点とし，時計回りに回転する渦状の模様とする。
線のある部分は #（半角シャープ）、空白部分は "" ""（半角空白）で表現する。
線と線の間は空白を置く。
整数
n
を入力とし，1 辺の長さが
n
の「ぐるぐる模様」を出力するプログラムを作成してください。
Input
入力は以下の形式で与えられます。
d
n
1
n
2
:
n
d
１行目にデータセットの数
d
(
d
≤ 20)、続く
d
行に
i
個目のぐるぐる模様の辺の長さ
n
i
(1 ≤
n
i
≤ 100) がそれぞれ１行に与えられます。
Output
データセットごとに、ぐるぐる模様を出力してください。データセットの間に１行の空行を入れてください。
Sample Input
2
5
6
Output for the Sample Input
#####
#   #
# # #
# # #
# ###

######
#    #
# ## #
# #  #
# #  #
# ####",Java,"import java.util.Arrays;
import java.util.Scanner;

public class Main {
	MyScanner sc = new MyScanner();
	Scanner sc2 = new Scanner(System.in);
	int mod = 1000000007;
	int[] dx = { 1, 0, 0, -1 };
	int[] dy = { 0, 1, -1, 0 };

	void run() {
		int D = sc.nextInt();
		boolean first = true;
		while (D-- > 0) {
			if (!first) {
				System.out.println();
				first = false;
			}
			int n = sc.nextInt();
			char[][] field = new char[n][n];
			for (int i = 0; i < n; i++) {
				Arrays.fill(field[i], ' ');
			}
			for (int i = 0; i < n; i++) {
				field[i][0] = '#';
				field[0][i] = '#';
			}
			if (n < 3) {
				debug2(field);
			} else if (n == 3) {
				for (int i = 0; i < n; i++) {
					field[i][n - 1] = '#';
				}
				debug2(field);
			} else {
				for (int i = 0; i < n; i++) {
					field[i][n - 1] = '#';
				}
				int nowX = n - 1;
				int nowY = n - 1;
				boolean go = true;
				while (go) {
					go = false;
					while (nowX - 2 >= 0 && field[nowY - 1][nowX - 1] != '#'
							&& field[nowY][nowX - 2] != '#' && field[nowY][nowX-1] != '#') {
						field[nowY][--nowX] = '#';
						go = true;
					}
					while (nowY - 2 >= 0 && field[nowY - 1][nowX + 1] != '#'
							&& field[nowY - 2][nowX] != '#' && field[nowY-1][nowX] != '#') {
						field[--nowY][nowX] = '#';
						go = true;
					}
					while (nowX + 2 < n && field[nowY + 1][nowX + 1] != '#'
							&& field[nowY][nowX + 2] != '#' ) {
						field[nowY][++nowX] = '#';
						go = true;
					}
					while (nowY + 2 < n && field[nowY + 1][nowX - 1] != '#'
							&& field[nowY + 2][nowX] != '#' ) {
						field[++nowY][nowX] = '#';
						go = true;
					}
				}
				debug2(field);
			}
		}
	}

	public static void main(String[] args) {
		new Main().run();
	}

	void debug(Object... o) {
		System.out.println(Arrays.deepToString(o));
	}

	void debug2(char[][] array) {
		for (int i = 0; i < array.length; i++) {
			for (int j = 0; j < array[i].length; j++) {
				System.out.print(array[i][j]);
			}
			System.out.println();
		}
	}

	class MyScanner {
		int nextInt() {
			try {
				int c = System.in.read();
				while (c != '-' && (c < '0' || '9' < c))
					c = System.in.read();
				if (c == '-')
					return -nextInt();
				int res = 0;
				do {
					res *= 10;
					res += c - '0';
					c = System.in.read();
				} while ('0' <= c && c <= '9');
				return res;
			} catch (Exception e) {
				return -1;
			}
		}

		double nextDouble() {
			return Double.parseDouble(next());
		}

		String next() {
			try {
				StringBuilder res = new StringBuilder("""");
				int c = System.in.read();
				while (Character.isWhitespace(c))
					c = System.in.read();
				do {
					res.append((char) c);
				} while (!Character.isWhitespace(c = System.in.read()));
				return res.toString();
			} catch (Exception e) {
				return null;
			}
		}
	}
}",1
p00141,"ぐるぐる模様
「ぐるぐる模様」を表示するプログラムを作成することにしました。「ぐるぐる模様」は以下のようなものとします。
1 辺の長さが
n
の場合、
n
行
n
列の文字列として表示する。
左下隅を基点とし，時計回りに回転する渦状の模様とする。
線のある部分は #（半角シャープ）、空白部分は "" ""（半角空白）で表現する。
線と線の間は空白を置く。
整数
n
を入力とし，1 辺の長さが
n
の「ぐるぐる模様」を出力するプログラムを作成してください。
Input
入力は以下の形式で与えられます。
d
n
1
n
2
:
n
d
１行目にデータセットの数
d
(
d
≤ 20)、続く
d
行に
i
個目のぐるぐる模様の辺の長さ
n
i
(1 ≤
n
i
≤ 100) がそれぞれ１行に与えられます。
Output
データセットごとに、ぐるぐる模様を出力してください。データセットの間に１行の空行を入れてください。
Sample Input
2
5
6
Output for the Sample Input
#####
#   #
# # #
# # #
# ###

######
#    #
# ## #
# #  #
# #  #
# ####",Python,"def generate_spiral(n):
    grid = [[' ' for _ in range(n)] for _ in range(n)]
    
    # Start from bottom-left, go clockwise
    row, col = n - 1, 0
    dr, dc = 0, 1  # Start moving right
    
    visited = set()
    visited.add((row, col))
    grid[row][col] = '#'
    
    while True:
        # Try to move in current direction
        next_row, next_col = row + dr, col + dc
        
        # Check if we can continue in current direction
        can_continue = (0 <= next_row < n and 
                       0 <= next_col < n and 
                       (next_row, next_col) not in visited)
        
        if can_continue:
            row, col = next_row, next_col
            visited.add((row, col))
            grid[row][col] = '#'
        else:
            # Try to turn clockwise
            # Clockwise from bottom-left: right(0,1) -> up(-1,0) -> left(0,-1) -> down(1,0)
            if (dr, dc) == (0, 1):  # right -> up
                dr, dc = -1, 0
            elif (dr, dc) == (-1, 0):  # up -> left
                dr, dc = 0, -1
            elif (dr, dc) == (0, -1):  # left -> down
                dr, dc = 1, 0
            elif (dr, dc) == (1, 0):  # down -> right
                dr, dc = 0, 1
            
            next_row, next_col = row + dr, col + dc
            
            # Check if we can move after turning
            if (0 <= next_row < n and 
                0 <= next_col < n and 
                (next_row, next_col) not in visited):
                row, col = next_row, next_col
                visited.add((row, col))
                grid[row][col] = '#'
            else:
                # Can't move anywhere, done
                break
    
    return grid

d = int(input())
results = []

for i in range(d):
    n = int(input())
    grid = generate_spiral(n)
    results.append(grid)

for i, grid in enumerate(results):
    for row in grid:
        print(''.join(row))
    if i < len(results) - 1:
        print()
",0
p00141,"ぐるぐる模様
「ぐるぐる模様」を表示するプログラムを作成することにしました。「ぐるぐる模様」は以下のようなものとします。
1 辺の長さが
n
の場合、
n
行
n
列の文字列として表示する。
左下隅を基点とし，時計回りに回転する渦状の模様とする。
線のある部分は #（半角シャープ）、空白部分は "" ""（半角空白）で表現する。
線と線の間は空白を置く。
整数
n
を入力とし，1 辺の長さが
n
の「ぐるぐる模様」を出力するプログラムを作成してください。
Input
入力は以下の形式で与えられます。
d
n
1
n
2
:
n
d
１行目にデータセットの数
d
(
d
≤ 20)、続く
d
行に
i
個目のぐるぐる模様の辺の長さ
n
i
(1 ≤
n
i
≤ 100) がそれぞれ１行に与えられます。
Output
データセットごとに、ぐるぐる模様を出力してください。データセットの間に１行の空行を入れてください。
Sample Input
2
5
6
Output for the Sample Input
#####
#   #
# # #
# # #
# ###

######
#    #
# ## #
# #  #
# #  #
# ####",Python,"class Vector:

    def __init__(self, x, y):
        self.x = x
        self.y = y

    def move(self, offset):
        self.x += offset[0]
        self.y += offset[1]

    def move_offset(self, offset, multiple=1):
        x = self.x + offset[0] * multiple
        y = self.y + offset[1] * multiple
        return Vector(x, y)


class Pattern:
    NOTHING = "" ""
    EXIST = ""#""
    SENTINEL = ""?""

    MOVE = [
        [[-1, -1], [-1, +0], [-1, +1]],
        [[-1, +1], [-0, +1], [+1, +1]],
        [[+1, +1], [+1, +0], [+1, -1]],
        [[+1, -1], [+0, -1], [-1, -1]],
    ]

    @classmethod
    def create_area(cls, size):
        area = [[cls.SENTINEL] * 2 + [cls.NOTHING] * size + [cls.SENTINEL] * 2 for _ in range(size)]
        tmp = [[cls.SENTINEL] * size + [cls.SENTINEL] * 2 * 2]
        area = tmp * 2 + area + tmp * 2
        return area

    @classmethod
    def even_spiral_pattern(cls, area, point):
        move_index = 0
        area[point.x][point.y] = cls.EXIST

        while True:

            left, center, right = cls.MOVE[move_index]
            end1, end2 = point.move_offset(left), point.move_offset(right)
            offset, offset2 = point.move_offset(center), point.move_offset(center, 2)

            if area[end1.x][end1.y] == cls.EXIST or area[end2.x][end2.y] == cls.EXIST:
                return area
            elif area[offset.x][offset.y] == cls.NOTHING and area[offset2.x][offset2.y] != cls.EXIST:
                point.move(center)
                area[point.x][point.y] = cls.EXIST
            else:
                move_index += 1
                move_index %= 4

    @classmethod
    def odd_spiral_pattern(cls, area, point):
        move_index = 0
        is_end = False
        area[point.x][point.y] = cls.EXIST

        while True:

            left, center, right = cls.MOVE[move_index]
            offset, offset2 = point.move_offset(center), point.move_offset(center, 2)

            if area[offset.x][offset.y] == cls.NOTHING and area[offset2.x][offset2.y] != cls.EXIST:
                point.move(center)
                area[point.x][point.y] = cls.EXIST
                is_end = False
            else:
                if is_end:
                    return area
                else:
                    is_end = True

                move_index += 1
                move_index %= 4

    @classmethod
    def formater(cls, area):
        output = ["""".join(item[2:-2]) for item in area[2:-2]]
        output = ""\n"".join(output)
        return output

    @classmethod
    def solve(cls, size):
        area = cls.create_area(size)
        point = Vector(size - 1 + 2, 2)

        if size % 2 == 0:
            result = cls.even_spiral_pattern(area, point)
        else:
            result = cls.odd_spiral_pattern(area, point)

        return cls.formater(result)


sizes = [int(input()) for _ in range(int(input()))]
results = [Pattern.solve(num) for num in sizes]
print(""\n\n"".join(results))

",1
p00142,"素数の性質
4 で割ると 3 あまる素数
n
(11、19、23 など) には、面白い性質があります。1 以上
n
未満の自然数 (1, 2,... ,
n
- 1) を 2 乗したものを
n
で割ったあまりを計算した結果を並べると、同じ数になるものがあるため、互いに異なった数の個数は、(
n
- 1)/2 になります。
この様にして得られた数の集合には、特別な性質があります。得られた数の集合から、互いに異なる 2 つ
a
と
b
を選んでその差を計算します。差が負になったときは、その差に
n
を足します。さらに結果が (
n
- 1)/2 より大きいときは、その差を
n
から引きます。
例えば、
n = 11
のとき 1 と 9 の差は、
1 − 9 = −8
→
−8 + n = −8 + 11 = 3
になります。9 と 1 の差も
9 −1 = 8
→
n − 8 = 11 − 8 = 3
で、同じ値 3 になります。この差は、円周上に 0, 1, ・・・,
n
- 1 を書いて、二つの数字の間の短い方の円弧を考えるとわかりやすくなります。(下図参照)
こうして得られた数の「差」は、1, 2, . . ., (
n
- 1)/2 のいずれかであり、同じ回数出現します。
【例】
n = 11
の時は、以下のようになります。
1 から
n
-1 までの数を 2 乗したものを
n
で割った余りを計算します。
1
2
=    1   →   1
 2
2
=    4   →   4
 3
2
=    9   →   9
 4
2
=   16   →   5
 5
2
=   25   →   3
 6
2
=   36   →   3
 7
2
=   49   →   5
 8
2
=   64   →   9
 9
2
=   81   →   4
10
2
=  100   →   1
a
,
b
の「差」の計算
1 で得られた 1, 3, 4, 5, 9 について異なる数同士の差を計算します。
計算結果が負の場合、
n
= 11 を加算します。
さらに、計算結果が  (
n
-1)/2 = 5 より大きい場合
n
= 11 から減算します。
出現回数を求める
計算結果 1, 2, 3, 4, 5 の出現回数をそれぞれ数え上げます。
これらの計算結果から 1, 2, 3, 4, 5 の出現回数が 4 回であることがわかります。この性質は 4 で割ると 3 あまる素数特有の性質であり 4 で割ると 1 あまる素数ではこのようなことはおきません。このことを確認するため、10000 以下の奇数
n
を入力とし、例題にあるような計算 (
n
で割ったあまりの 2 乗の差の頻度を求める)を実行し、その出現回数を出力するプログラムを作成してください。
Input
複数のデータセットが与えられます。各データセットとして１つの整数
n
(
n
≤ 10000) が１行に与えられます。入力は 0 を１つ含む行でおわります。
Output
各データセットについて、出現頻度を以下の形式で出力してください。
剰余の平方の差が 1 である(
a, b
)の出現個数(整数)
剰余の平方の差が 2 である(
a, b
)の出現個数(整数)
   :
   :
剰余の平方の差が (
n
-1)/2 である(
a, b
)の出現個数(整数)
Sample Input
11
15
0
Output for the Sample Input
4
4
4
4
4
2
2
4
2
4
4
2",C,"#include <stdio.h>
#include <stdlib.h>

int main() {
    int n;
    
    while(1) {
        scanf(""%d"", &n);
        if(n == 0) break;
        
        int *squares = (int*)malloc(n * sizeof(int));
        int unique_count = 0;
        int *unique_squares = (int*)malloc(n * sizeof(int));
        
        // Calculate squares mod n
        for(int i = 1; i < n; i++) {
            squares[i] = (i * i) % n;
        }
        
        // Find unique squares
        for(int i = 1; i < n; i++) {
            int found = 0;
            for(int j = 0; j < unique_count; j++) {
                if(unique_squares[j] == squares[i]) {
                    found = 1;
                    break;
                }
            }
            if(!found) {
                unique_squares[unique_count++] = squares[i];
            }
        }
        
        int max_diff = (n - 1) / 2;
        int *count = (int*)calloc(max_diff + 1, sizeof(int));
        
        // Calculate differences
        for(int i = 0; i < unique_count; i++) {
            for(int j = 0; j < unique_count; j++) {
                if(i != j) {
                    int a = unique_squares[i];
                    int b = unique_squares[j];
                    int diff = a - b;
                    
                    // If negative, add n
                    if(diff < 0) {
                        diff += n;
                    }
                    
                    // If greater than (n-1)/2, subtract from n
                    if(diff > max_diff) {
                        diff = n - diff;
                    }
                    
                    if(diff >= 1 && diff <= max_diff) {
                        count[diff]++;
                    }
                }
            }
        }
        
        // Output counts
        for(int i = 1; i <= max_diff; i++) {
            printf(""%d\n"", count[i]);
        }
        
        free(squares);
        free(unique_squares);
        free(count);
    }
    
    return 0;
}
",0
p00142,"素数の性質
4 で割ると 3 あまる素数
n
(11、19、23 など) には、面白い性質があります。1 以上
n
未満の自然数 (1, 2,... ,
n
- 1) を 2 乗したものを
n
で割ったあまりを計算した結果を並べると、同じ数になるものがあるため、互いに異なった数の個数は、(
n
- 1)/2 になります。
この様にして得られた数の集合には、特別な性質があります。得られた数の集合から、互いに異なる 2 つ
a
と
b
を選んでその差を計算します。差が負になったときは、その差に
n
を足します。さらに結果が (
n
- 1)/2 より大きいときは、その差を
n
から引きます。
例えば、
n = 11
のとき 1 と 9 の差は、
1 − 9 = −8
→
−8 + n = −8 + 11 = 3
になります。9 と 1 の差も
9 −1 = 8
→
n − 8 = 11 − 8 = 3
で、同じ値 3 になります。この差は、円周上に 0, 1, ・・・,
n
- 1 を書いて、二つの数字の間の短い方の円弧を考えるとわかりやすくなります。(下図参照)
こうして得られた数の「差」は、1, 2, . . ., (
n
- 1)/2 のいずれかであり、同じ回数出現します。
【例】
n = 11
の時は、以下のようになります。
1 から
n
-1 までの数を 2 乗したものを
n
で割った余りを計算します。
1
2
=    1   →   1
 2
2
=    4   →   4
 3
2
=    9   →   9
 4
2
=   16   →   5
 5
2
=   25   →   3
 6
2
=   36   →   3
 7
2
=   49   →   5
 8
2
=   64   →   9
 9
2
=   81   →   4
10
2
=  100   →   1
a
,
b
の「差」の計算
1 で得られた 1, 3, 4, 5, 9 について異なる数同士の差を計算します。
計算結果が負の場合、
n
= 11 を加算します。
さらに、計算結果が  (
n
-1)/2 = 5 より大きい場合
n
= 11 から減算します。
出現回数を求める
計算結果 1, 2, 3, 4, 5 の出現回数をそれぞれ数え上げます。
これらの計算結果から 1, 2, 3, 4, 5 の出現回数が 4 回であることがわかります。この性質は 4 で割ると 3 あまる素数特有の性質であり 4 で割ると 1 あまる素数ではこのようなことはおきません。このことを確認するため、10000 以下の奇数
n
を入力とし、例題にあるような計算 (
n
で割ったあまりの 2 乗の差の頻度を求める)を実行し、その出現回数を出力するプログラムを作成してください。
Input
複数のデータセットが与えられます。各データセットとして１つの整数
n
(
n
≤ 10000) が１行に与えられます。入力は 0 を１つ含む行でおわります。
Output
各データセットについて、出現頻度を以下の形式で出力してください。
剰余の平方の差が 1 である(
a, b
)の出現個数(整数)
剰余の平方の差が 2 である(
a, b
)の出現個数(整数)
   :
   :
剰余の平方の差が (
n
-1)/2 である(
a, b
)の出現個数(整数)
Sample Input
11
15
0
Output for the Sample Input
4
4
4
4
4
2
2
4
2
4
4
2",C,"#include <stdio.h>
#include <string.h>
int main(){
  int exp[10001], n, i, j, mod[10001], a[10001], c, count[6000], h, d;

  for(i = 1; i < 10001; ++i) exp[i] = i * i;

  while(scanf(""%d"", &n) && n){
    memset(count , 0, sizeof(count));
    for(i = 1; i < n; ++i) mod[i] = exp[i] % n;
    c = 0;
    for(i = 1; i < n; ++i){
      for(j = 0; j < c; ++j)
	if(mod[i] == a[j]) break;
      if(j == c) a[c++] = mod[i];
    }
    h = (n - 1) / 2;
    for(i = 0; i < c; ++i){
      for(j = 0; j < c; ++j){
	if(a[i] != a[j]){
	  d = a[i] - a[j];
	  if(d < 0) d += n;
	  if(d > h) d = n - d;
	  count[d]++;
	}
      }
    }

    for(i = 1; i <= h; ++i) printf(""%d\n"", count[i]);  
  }
  return 0;
}",1
p00142,"素数の性質
4 で割ると 3 あまる素数
n
(11、19、23 など) には、面白い性質があります。1 以上
n
未満の自然数 (1, 2,... ,
n
- 1) を 2 乗したものを
n
で割ったあまりを計算した結果を並べると、同じ数になるものがあるため、互いに異なった数の個数は、(
n
- 1)/2 になります。
この様にして得られた数の集合には、特別な性質があります。得られた数の集合から、互いに異なる 2 つ
a
と
b
を選んでその差を計算します。差が負になったときは、その差に
n
を足します。さらに結果が (
n
- 1)/2 より大きいときは、その差を
n
から引きます。
例えば、
n = 11
のとき 1 と 9 の差は、
1 − 9 = −8
→
−8 + n = −8 + 11 = 3
になります。9 と 1 の差も
9 −1 = 8
→
n − 8 = 11 − 8 = 3
で、同じ値 3 になります。この差は、円周上に 0, 1, ・・・,
n
- 1 を書いて、二つの数字の間の短い方の円弧を考えるとわかりやすくなります。(下図参照)
こうして得られた数の「差」は、1, 2, . . ., (
n
- 1)/2 のいずれかであり、同じ回数出現します。
【例】
n = 11
の時は、以下のようになります。
1 から
n
-1 までの数を 2 乗したものを
n
で割った余りを計算します。
1
2
=    1   →   1
 2
2
=    4   →   4
 3
2
=    9   →   9
 4
2
=   16   →   5
 5
2
=   25   →   3
 6
2
=   36   →   3
 7
2
=   49   →   5
 8
2
=   64   →   9
 9
2
=   81   →   4
10
2
=  100   →   1
a
,
b
の「差」の計算
1 で得られた 1, 3, 4, 5, 9 について異なる数同士の差を計算します。
計算結果が負の場合、
n
= 11 を加算します。
さらに、計算結果が  (
n
-1)/2 = 5 より大きい場合
n
= 11 から減算します。
出現回数を求める
計算結果 1, 2, 3, 4, 5 の出現回数をそれぞれ数え上げます。
これらの計算結果から 1, 2, 3, 4, 5 の出現回数が 4 回であることがわかります。この性質は 4 で割ると 3 あまる素数特有の性質であり 4 で割ると 1 あまる素数ではこのようなことはおきません。このことを確認するため、10000 以下の奇数
n
を入力とし、例題にあるような計算 (
n
で割ったあまりの 2 乗の差の頻度を求める)を実行し、その出現回数を出力するプログラムを作成してください。
Input
複数のデータセットが与えられます。各データセットとして１つの整数
n
(
n
≤ 10000) が１行に与えられます。入力は 0 を１つ含む行でおわります。
Output
各データセットについて、出現頻度を以下の形式で出力してください。
剰余の平方の差が 1 である(
a, b
)の出現個数(整数)
剰余の平方の差が 2 である(
a, b
)の出現個数(整数)
   :
   :
剰余の平方の差が (
n
-1)/2 である(
a, b
)の出現個数(整数)
Sample Input
11
15
0
Output for the Sample Input
4
4
4
4
4
2
2
4
2
4
4
2",Java,"import java.util.*;

public class Main {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        
        while (true) {
            int n = sc.nextInt();
            if (n == 0) break;
            
            // Step 1: Calculate squares mod n
            Set<Integer> squares = new HashSet<>();
            for (int i = 1; i < n; i++) {
                int sq = (i * i) % n;
                squares.add(sq);
            }
            
            // Step 2: Calculate differences between all pairs
            List<Integer> squareList = new ArrayList<>(squares);
            int maxDiff = (n - 1) / 2;
            int[] frequency = new int[maxDiff + 1];
            
            for (int i = 0; i < squareList.size(); i++) {
                for (int j = i + 1; j < squareList.size(); j++) {
                    int a = squareList.get(i);
                    int b = squareList.get(j);
                    
                    // Calculate difference
                    int diff = a - b;
                    
                    // If negative, add n
                    if (diff < 0) {
                        diff += n;
                    }
                    
                    // If greater than (n-1)/2, subtract from n
                    if (diff > maxDiff) {
                        diff = n - diff;
                    }
                    
                    frequency[diff]++;
                }
            }
            
            // Step 3: Output frequencies for 1 to (n-1)/2
            for (int i = 1; i <= maxDiff; i++) {
                System.out.println(frequency[i]);
            }
        }
        
        sc.close();
    }
}
",0
p00142,"素数の性質
4 で割ると 3 あまる素数
n
(11、19、23 など) には、面白い性質があります。1 以上
n
未満の自然数 (1, 2,... ,
n
- 1) を 2 乗したものを
n
で割ったあまりを計算した結果を並べると、同じ数になるものがあるため、互いに異なった数の個数は、(
n
- 1)/2 になります。
この様にして得られた数の集合には、特別な性質があります。得られた数の集合から、互いに異なる 2 つ
a
と
b
を選んでその差を計算します。差が負になったときは、その差に
n
を足します。さらに結果が (
n
- 1)/2 より大きいときは、その差を
n
から引きます。
例えば、
n = 11
のとき 1 と 9 の差は、
1 − 9 = −8
→
−8 + n = −8 + 11 = 3
になります。9 と 1 の差も
9 −1 = 8
→
n − 8 = 11 − 8 = 3
で、同じ値 3 になります。この差は、円周上に 0, 1, ・・・,
n
- 1 を書いて、二つの数字の間の短い方の円弧を考えるとわかりやすくなります。(下図参照)
こうして得られた数の「差」は、1, 2, . . ., (
n
- 1)/2 のいずれかであり、同じ回数出現します。
【例】
n = 11
の時は、以下のようになります。
1 から
n
-1 までの数を 2 乗したものを
n
で割った余りを計算します。
1
2
=    1   →   1
 2
2
=    4   →   4
 3
2
=    9   →   9
 4
2
=   16   →   5
 5
2
=   25   →   3
 6
2
=   36   →   3
 7
2
=   49   →   5
 8
2
=   64   →   9
 9
2
=   81   →   4
10
2
=  100   →   1
a
,
b
の「差」の計算
1 で得られた 1, 3, 4, 5, 9 について異なる数同士の差を計算します。
計算結果が負の場合、
n
= 11 を加算します。
さらに、計算結果が  (
n
-1)/2 = 5 より大きい場合
n
= 11 から減算します。
出現回数を求める
計算結果 1, 2, 3, 4, 5 の出現回数をそれぞれ数え上げます。
これらの計算結果から 1, 2, 3, 4, 5 の出現回数が 4 回であることがわかります。この性質は 4 で割ると 3 あまる素数特有の性質であり 4 で割ると 1 あまる素数ではこのようなことはおきません。このことを確認するため、10000 以下の奇数
n
を入力とし、例題にあるような計算 (
n
で割ったあまりの 2 乗の差の頻度を求める)を実行し、その出現回数を出力するプログラムを作成してください。
Input
複数のデータセットが与えられます。各データセットとして１つの整数
n
(
n
≤ 10000) が１行に与えられます。入力は 0 を１つ含む行でおわります。
Output
各データセットについて、出現頻度を以下の形式で出力してください。
剰余の平方の差が 1 である(
a, b
)の出現個数(整数)
剰余の平方の差が 2 である(
a, b
)の出現個数(整数)
   :
   :
剰余の平方の差が (
n
-1)/2 である(
a, b
)の出現個数(整数)
Sample Input
11
15
0
Output for the Sample Input
4
4
4
4
4
2
2
4
2
4
4
2",Java,"import java.util.*;
import java.lang.*;
import java.math.*;
import java.io.*;

import static java.lang.Math.*;
import static java.util.Arrays.*;

public class Main{

	Scanner sc=new Scanner(System.in);

	int INF=1<<28;
	double EPS=1e-9;

	int n;

	void run(){
		for(;;){
			n=sc.nextInt();
			if(n==0){
				break;
			}
			solve();
		}
		System.out.flush();
	}

	void solve(){
		TreeSet<Integer> set=new TreeSet<Integer>();
		for(int i=1; i<n; i++){
			set.add(i*i%n);
		}
		int[] c=new int[n];
		for(int j : set){
			for(int i : set){
				if(i!=j){
					int a=i-j;
					if(a<0){
						a+=n;
					}
					if(a>(n-1)/2){
						a=n-a;
					}
					c[a]++;
				}
			}
		}
		// debug(set.toArray());
		// debug(c);
		for(int i=1; i<=(n-1)/2; i++){
			println(""""+c[i]);
		}
	}

	void debug(Object... os){
		System.err.println(Arrays.deepToString(os));
	}

	void print(String s){
		System.out.print(s);
	}

	void println(String s){
		System.out.println(s);
	}

	public static void main(String[] args){
		System.setOut(new PrintStream(new BufferedOutputStream(System.out)));
		new Main().run();
	}
}",1
p00142,"素数の性質
4 で割ると 3 あまる素数
n
(11、19、23 など) には、面白い性質があります。1 以上
n
未満の自然数 (1, 2,... ,
n
- 1) を 2 乗したものを
n
で割ったあまりを計算した結果を並べると、同じ数になるものがあるため、互いに異なった数の個数は、(
n
- 1)/2 になります。
この様にして得られた数の集合には、特別な性質があります。得られた数の集合から、互いに異なる 2 つ
a
と
b
を選んでその差を計算します。差が負になったときは、その差に
n
を足します。さらに結果が (
n
- 1)/2 より大きいときは、その差を
n
から引きます。
例えば、
n = 11
のとき 1 と 9 の差は、
1 − 9 = −8
→
−8 + n = −8 + 11 = 3
になります。9 と 1 の差も
9 −1 = 8
→
n − 8 = 11 − 8 = 3
で、同じ値 3 になります。この差は、円周上に 0, 1, ・・・,
n
- 1 を書いて、二つの数字の間の短い方の円弧を考えるとわかりやすくなります。(下図参照)
こうして得られた数の「差」は、1, 2, . . ., (
n
- 1)/2 のいずれかであり、同じ回数出現します。
【例】
n = 11
の時は、以下のようになります。
1 から
n
-1 までの数を 2 乗したものを
n
で割った余りを計算します。
1
2
=    1   →   1
 2
2
=    4   →   4
 3
2
=    9   →   9
 4
2
=   16   →   5
 5
2
=   25   →   3
 6
2
=   36   →   3
 7
2
=   49   →   5
 8
2
=   64   →   9
 9
2
=   81   →   4
10
2
=  100   →   1
a
,
b
の「差」の計算
1 で得られた 1, 3, 4, 5, 9 について異なる数同士の差を計算します。
計算結果が負の場合、
n
= 11 を加算します。
さらに、計算結果が  (
n
-1)/2 = 5 より大きい場合
n
= 11 から減算します。
出現回数を求める
計算結果 1, 2, 3, 4, 5 の出現回数をそれぞれ数え上げます。
これらの計算結果から 1, 2, 3, 4, 5 の出現回数が 4 回であることがわかります。この性質は 4 で割ると 3 あまる素数特有の性質であり 4 で割ると 1 あまる素数ではこのようなことはおきません。このことを確認するため、10000 以下の奇数
n
を入力とし、例題にあるような計算 (
n
で割ったあまりの 2 乗の差の頻度を求める)を実行し、その出現回数を出力するプログラムを作成してください。
Input
複数のデータセットが与えられます。各データセットとして１つの整数
n
(
n
≤ 10000) が１行に与えられます。入力は 0 を１つ含む行でおわります。
Output
各データセットについて、出現頻度を以下の形式で出力してください。
剰余の平方の差が 1 である(
a, b
)の出現個数(整数)
剰余の平方の差が 2 である(
a, b
)の出現個数(整数)
   :
   :
剰余の平方の差が (
n
-1)/2 である(
a, b
)の出現個数(整数)
Sample Input
11
15
0
Output for the Sample Input
4
4
4
4
4
2
2
4
2
4
4
2",Python,"def solve(n):
    # Calculate squares mod n
    squares = set()
    for i in range(1, n):
        squares.add((i * i) % n)
    
    squares = list(squares)
    
    # Calculate differences
    max_diff = (n - 1) // 2
    diff_count = [0] * (max_diff + 1)
    
    for i in range(len(squares)):
        for j in range(i + 1, len(squares)):
            a = squares[i]
            b = squares[j]
            
            # Calculate difference
            diff = a - b
            if diff < 0:
                diff += n
            if diff > max_diff:
                diff = n - diff
            
            diff_count[diff] += 1
    
    # Output frequencies for 1 to max_diff
    for i in range(1, max_diff + 1):
        print(diff_count[i])

while True:
    n = int(input())
    if n == 0:
        break
    solve(n)
",0
p00142,"素数の性質
4 で割ると 3 あまる素数
n
(11、19、23 など) には、面白い性質があります。1 以上
n
未満の自然数 (1, 2,... ,
n
- 1) を 2 乗したものを
n
で割ったあまりを計算した結果を並べると、同じ数になるものがあるため、互いに異なった数の個数は、(
n
- 1)/2 になります。
この様にして得られた数の集合には、特別な性質があります。得られた数の集合から、互いに異なる 2 つ
a
と
b
を選んでその差を計算します。差が負になったときは、その差に
n
を足します。さらに結果が (
n
- 1)/2 より大きいときは、その差を
n
から引きます。
例えば、
n = 11
のとき 1 と 9 の差は、
1 − 9 = −8
→
−8 + n = −8 + 11 = 3
になります。9 と 1 の差も
9 −1 = 8
→
n − 8 = 11 − 8 = 3
で、同じ値 3 になります。この差は、円周上に 0, 1, ・・・,
n
- 1 を書いて、二つの数字の間の短い方の円弧を考えるとわかりやすくなります。(下図参照)
こうして得られた数の「差」は、1, 2, . . ., (
n
- 1)/2 のいずれかであり、同じ回数出現します。
【例】
n = 11
の時は、以下のようになります。
1 から
n
-1 までの数を 2 乗したものを
n
で割った余りを計算します。
1
2
=    1   →   1
 2
2
=    4   →   4
 3
2
=    9   →   9
 4
2
=   16   →   5
 5
2
=   25   →   3
 6
2
=   36   →   3
 7
2
=   49   →   5
 8
2
=   64   →   9
 9
2
=   81   →   4
10
2
=  100   →   1
a
,
b
の「差」の計算
1 で得られた 1, 3, 4, 5, 9 について異なる数同士の差を計算します。
計算結果が負の場合、
n
= 11 を加算します。
さらに、計算結果が  (
n
-1)/2 = 5 より大きい場合
n
= 11 から減算します。
出現回数を求める
計算結果 1, 2, 3, 4, 5 の出現回数をそれぞれ数え上げます。
これらの計算結果から 1, 2, 3, 4, 5 の出現回数が 4 回であることがわかります。この性質は 4 で割ると 3 あまる素数特有の性質であり 4 で割ると 1 あまる素数ではこのようなことはおきません。このことを確認するため、10000 以下の奇数
n
を入力とし、例題にあるような計算 (
n
で割ったあまりの 2 乗の差の頻度を求める)を実行し、その出現回数を出力するプログラムを作成してください。
Input
複数のデータセットが与えられます。各データセットとして１つの整数
n
(
n
≤ 10000) が１行に与えられます。入力は 0 を１つ含む行でおわります。
Output
各データセットについて、出現頻度を以下の形式で出力してください。
剰余の平方の差が 1 である(
a, b
)の出現個数(整数)
剰余の平方の差が 2 である(
a, b
)の出現個数(整数)
   :
   :
剰余の平方の差が (
n
-1)/2 である(
a, b
)の出現個数(整数)
Sample Input
11
15
0
Output for the Sample Input
4
4
4
4
4
2
2
4
2
4
4
2",Python,"import itertools

r = 10001
s = int(r**0.5)
p = [1]*r
p[0] = 0
for i in range(1,s):
	if p[i]:
		p[2*i + 1::i + 1] = [0 for x in range(2*i + 1, r, i + 1)]

while 1:
	n = input()
	if n == 0: break
	m = (n - 1) / 2
	a = sorted(list(set([i**2%n for i in range(1,n)])))
	l = len(a)
	if n%4 == 3 and p[n - 1] == 1:
		ll = l*(l - 1) / m
		for i in range(m):
			print ll
		continue
	h = [0]*(m+1)
	for i,j in itertools.combinations(a,2):
		d = j - i
		h[min(d,n - d)] += 2
	for i in range(1,m+1):
		print h[i]",1
p00143,"牽牛と織女
織女は天帝の子供でしたが、父の言いつけであけてもくれても機を織っていました。
織女の織る雲錦という見事な布で仕立てた服を着るのが天帝の楽しみでした。雲錦は寿命が短くすぐに劣化してしまいますが、働き者の織女が毎日織ってくれるので、問題はありませんでした。織女は、父の言いつけを守り、毎日毎日雲錦を織り続けていたので、ボーイフレンドはいませんでした。かわいそうに思った父は、天の川の向こう岸に住む牽牛という働き者を紹介し、嫁入りさせました。
すると、織女は、結婚の楽しさに夢中になって、機織りなどそっちのけで、牽牛と遊び呆けています。天帝のお気に入りの雲錦の服も新しく仕立てられないためボロボロになってしまいました。
これには父も怒って、織女を宮殿に連れ戻したいと思いました。しかし人間である牽牛の前にボロボロの服で姿を現すわけにはいきません。遊び呆けている二人を 3 角形の壁で遮断し自分以外の全てのものが行き来できなくすることを考えました。そして、牽牛に見つからずに、織女に会って、まじめに機を織るか、さもなければ強制的に連れ帰ると宣言するというのです。
天帝はこの作戦を遂行するために 3 角形の壁生成装置を開発することにしました。3 角形の 3 頂点の位置
(xp
1
, yp
1
)
,
(xp
2
, yp
2
)
,
(xp
3
, yp
3
)
、牽牛の位置
(xk, yk)
、および織女の位置
(xs, ys)
、を入力とし、三角形が牽牛と織女を遮断しているか否かを判定し、遮断できている場合は OK、遮断できていない場合には NG を出力するプログラムを作成してください。ただし、遮断しているとは、牽牛と織女のいずれかが三角形の内側にあり、他方が外側にある場合を言います。牽牛と織女は三角形の頂点もしくは辺の上にはいないものとします。
織女と牽牛は時々刻々場所を変えるため、プログラムは様々な位置情報を入力し質問に答えなければなりません。
Input
入力は以下の形式で与えられます。
n
query
1
query
2
:
query
n
１行目に判別したい情報の個数
n
(
n
≤ 10000)、続く
n
行に
i
番目の質問
query
i
が与えられます。各質問は以下の形式で与えられます。
xp
1
yp
1
xp
2
yp
2
xp
3
yp
3
xk
yk
xs
ys
各質問として、3 角形の 3 頂点の位置、牽牛の位置、および織女の位置 (-1000 ≤
xp
1
,
yp
1
,
xp
2
,
yp
2
,
xp
3
,
yp
3
,
xk
,
yk
,
xs
,
ys
≤ 1000) が１行に与えられます。入力はすべて整数です。
Output
質問ごとに、判定結果 OK または NG を１行に出力してください。
Sample Input
5
2 5 9 2 8 9 2 11 6 5
2 5 9 2 8 9 2 11 12 6
2 5 9 2 8 9 2 11 11 9
14 1 25 7 17 12 17 9 20 5
14 1 25 7 17 12 22 13 20 5
Output for the Sample Input
OK
NG
NG
NG
OK",C,"#include <stdio.h>

int sign(double x) {
    if (x > 0) return 1;
    if (x < 0) return -1;
    return 0;
}

double cross_product(double x1, double y1, double x2, double y2, double x3, double y3) {
    return (x2 - x1) * (y3 - y1) - (y2 - y1) * (x3 - x1);
}

int point_in_triangle(double px, double py, double x1, double y1, double x2, double y2, double x3, double y3) {
    double d1 = cross_product(x1, y1, x2, y2, px, py);
    double d2 = cross_product(x2, y2, x3, y3, px, py);
    double d3 = cross_product(x3, y3, x1, y1, px, py);
    
    int s1 = sign(d1);
    int s2 = sign(d2);
    int s3 = sign(d3);
    
    int has_neg = (s1 < 0) || (s2 < 0) || (s3 < 0);
    int has_pos = (s1 > 0) || (s2 > 0) || (s3 > 0);
    
    return !(has_neg && has_pos);
}

int main() {
    int n;
    scanf(""%d"", &n);
    
    for (int i = 0; i < n; i++) {
        double xp1, yp1, xp2, yp2, xp3, yp3, xk, yk, xs, ys;
        scanf(""%lf %lf %lf %lf %lf %lf %lf %lf %lf %lf"",
              &xp1, &yp1, &xp2, &yp2, &xp3, &yp3, &xk, &yk, &xs, &ys);
        
        int k_inside = point_in_triangle(xk, yk, xp1, yp1, xp2, yp2, xp3, yp3);
        int s_inside = point_in_triangle(xs, ys, xp1, yp1, xp2, yp2, xp3, yp3);
        
        if (k_inside != s_inside) {
            printf(""OK\n"");
        } else {
            printf(""NG\n"");
        }
    }
    
    return 0;
}
",0
p00143,"牽牛と織女
織女は天帝の子供でしたが、父の言いつけであけてもくれても機を織っていました。
織女の織る雲錦という見事な布で仕立てた服を着るのが天帝の楽しみでした。雲錦は寿命が短くすぐに劣化してしまいますが、働き者の織女が毎日織ってくれるので、問題はありませんでした。織女は、父の言いつけを守り、毎日毎日雲錦を織り続けていたので、ボーイフレンドはいませんでした。かわいそうに思った父は、天の川の向こう岸に住む牽牛という働き者を紹介し、嫁入りさせました。
すると、織女は、結婚の楽しさに夢中になって、機織りなどそっちのけで、牽牛と遊び呆けています。天帝のお気に入りの雲錦の服も新しく仕立てられないためボロボロになってしまいました。
これには父も怒って、織女を宮殿に連れ戻したいと思いました。しかし人間である牽牛の前にボロボロの服で姿を現すわけにはいきません。遊び呆けている二人を 3 角形の壁で遮断し自分以外の全てのものが行き来できなくすることを考えました。そして、牽牛に見つからずに、織女に会って、まじめに機を織るか、さもなければ強制的に連れ帰ると宣言するというのです。
天帝はこの作戦を遂行するために 3 角形の壁生成装置を開発することにしました。3 角形の 3 頂点の位置
(xp
1
, yp
1
)
,
(xp
2
, yp
2
)
,
(xp
3
, yp
3
)
、牽牛の位置
(xk, yk)
、および織女の位置
(xs, ys)
、を入力とし、三角形が牽牛と織女を遮断しているか否かを判定し、遮断できている場合は OK、遮断できていない場合には NG を出力するプログラムを作成してください。ただし、遮断しているとは、牽牛と織女のいずれかが三角形の内側にあり、他方が外側にある場合を言います。牽牛と織女は三角形の頂点もしくは辺の上にはいないものとします。
織女と牽牛は時々刻々場所を変えるため、プログラムは様々な位置情報を入力し質問に答えなければなりません。
Input
入力は以下の形式で与えられます。
n
query
1
query
2
:
query
n
１行目に判別したい情報の個数
n
(
n
≤ 10000)、続く
n
行に
i
番目の質問
query
i
が与えられます。各質問は以下の形式で与えられます。
xp
1
yp
1
xp
2
yp
2
xp
3
yp
3
xk
yk
xs
ys
各質問として、3 角形の 3 頂点の位置、牽牛の位置、および織女の位置 (-1000 ≤
xp
1
,
yp
1
,
xp
2
,
yp
2
,
xp
3
,
yp
3
,
xk
,
yk
,
xs
,
ys
≤ 1000) が１行に与えられます。入力はすべて整数です。
Output
質問ごとに、判定結果 OK または NG を１行に出力してください。
Sample Input
5
2 5 9 2 8 9 2 11 6 5
2 5 9 2 8 9 2 11 12 6
2 5 9 2 8 9 2 11 11 9
14 1 25 7 17 12 17 9 20 5
14 1 25 7 17 12 22 13 20 5
Output for the Sample Input
OK
NG
NG
NG
OK",C,"// Aizu Vol-2 0143   Altair and Vega
// 2017.8.8

#include <stdio.h>

int atSameSide(int x1, int y1, int x2, int y2, int xa, int ya, int xb, int yb)
{
	int sa, sb;

	sa = (x2 - x1) * (ya - y1) + (y2 - y1) * (x1 - xa);
	sb = (x2 - x1) * (yb - y1) + (y2 - y1) * (x1 - xb);
//	if (sb == 0) return 0;  		 // xb,yb in line
	return (sa * sb >= 0);           // xa,ya xb,yb at same side
}

int main()
{
	int n;
	int x1, y1, x2, y2, x3, y3, xk, yk, xs, ys;
	int kin, sin;

	scanf(""%d"", &n);
	while (n-- > 0) {
		scanf(""%d%d%d%d%d%d%d%d%d%d"", &x1, &y1, &x2, &y2, &x3, &y3, &xk, &yk, &xs, &ys);
		kin = atSameSide(x1, y1, x2, y2, x3, y3, xk, yk) &&
			  atSameSide(x2, y2, x3, y3, x1, y1, xk, yk) &&
			  atSameSide(x3, y3, x1, y1, x2, y2, xk, yk);
		sin = atSameSide(x1, y1, x2, y2, x3, y3, xs, ys) &&
		  	  atSameSide(x2, y2, x3, y3, x1, y1, xs, ys) &&
			  atSameSide(x3, y3, x1, y1, x2, y2, xs, ys);
		puts(kin ^ sin ? ""OK"" : ""NG"");
	}
	return 0;
}",1
p00143,"牽牛と織女
織女は天帝の子供でしたが、父の言いつけであけてもくれても機を織っていました。
織女の織る雲錦という見事な布で仕立てた服を着るのが天帝の楽しみでした。雲錦は寿命が短くすぐに劣化してしまいますが、働き者の織女が毎日織ってくれるので、問題はありませんでした。織女は、父の言いつけを守り、毎日毎日雲錦を織り続けていたので、ボーイフレンドはいませんでした。かわいそうに思った父は、天の川の向こう岸に住む牽牛という働き者を紹介し、嫁入りさせました。
すると、織女は、結婚の楽しさに夢中になって、機織りなどそっちのけで、牽牛と遊び呆けています。天帝のお気に入りの雲錦の服も新しく仕立てられないためボロボロになってしまいました。
これには父も怒って、織女を宮殿に連れ戻したいと思いました。しかし人間である牽牛の前にボロボロの服で姿を現すわけにはいきません。遊び呆けている二人を 3 角形の壁で遮断し自分以外の全てのものが行き来できなくすることを考えました。そして、牽牛に見つからずに、織女に会って、まじめに機を織るか、さもなければ強制的に連れ帰ると宣言するというのです。
天帝はこの作戦を遂行するために 3 角形の壁生成装置を開発することにしました。3 角形の 3 頂点の位置
(xp
1
, yp
1
)
,
(xp
2
, yp
2
)
,
(xp
3
, yp
3
)
、牽牛の位置
(xk, yk)
、および織女の位置
(xs, ys)
、を入力とし、三角形が牽牛と織女を遮断しているか否かを判定し、遮断できている場合は OK、遮断できていない場合には NG を出力するプログラムを作成してください。ただし、遮断しているとは、牽牛と織女のいずれかが三角形の内側にあり、他方が外側にある場合を言います。牽牛と織女は三角形の頂点もしくは辺の上にはいないものとします。
織女と牽牛は時々刻々場所を変えるため、プログラムは様々な位置情報を入力し質問に答えなければなりません。
Input
入力は以下の形式で与えられます。
n
query
1
query
2
:
query
n
１行目に判別したい情報の個数
n
(
n
≤ 10000)、続く
n
行に
i
番目の質問
query
i
が与えられます。各質問は以下の形式で与えられます。
xp
1
yp
1
xp
2
yp
2
xp
3
yp
3
xk
yk
xs
ys
各質問として、3 角形の 3 頂点の位置、牽牛の位置、および織女の位置 (-1000 ≤
xp
1
,
yp
1
,
xp
2
,
yp
2
,
xp
3
,
yp
3
,
xk
,
yk
,
xs
,
ys
≤ 1000) が１行に与えられます。入力はすべて整数です。
Output
質問ごとに、判定結果 OK または NG を１行に出力してください。
Sample Input
5
2 5 9 2 8 9 2 11 6 5
2 5 9 2 8 9 2 11 12 6
2 5 9 2 8 9 2 11 11 9
14 1 25 7 17 12 17 9 20 5
14 1 25 7 17 12 22 13 20 5
Output for the Sample Input
OK
NG
NG
NG
OK",Java,"import java.util.Scanner;

public class Main {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int n = sc.nextInt();
        
        for (int i = 0; i < n; i++) {
            double xp1 = sc.nextDouble();
            double yp1 = sc.nextDouble();
            double xp2 = sc.nextDouble();
            double yp2 = sc.nextDouble();
            double xp3 = sc.nextDouble();
            double yp3 = sc.nextDouble();
            double xk = sc.nextDouble();
            double yk = sc.nextDouble();
            double xs = sc.nextDouble();
            double ys = sc.nextDouble();
            
            boolean kInside = isInside(xp1, yp1, xp2, yp2, xp3, yp3, xk, yk);
            boolean sInside = isInside(xp1, yp1, xp2, yp2, xp3, yp3, xs, ys);
            
            if (kInside != sInside) {
                System.out.println(""OK"");
            } else {
                System.out.println(""NG"");
            }
        }
        sc.close();
    }
    
    static boolean isInside(double x1, double y1, double x2, double y2, double x3, double y3, double px, double py) {
        double sign1 = sign(px, py, x1, y1, x2, y2);
        double sign2 = sign(px, py, x2, y2, x3, y3);
        double sign3 = sign(px, py, x3, y3, x1, y1);
        
        boolean hasNeg = (sign1 < 0) || (sign2 < 0) || (sign3 < 0);
        boolean hasPos = (sign1 > 0) || (sign2 > 0) || (sign3 > 0);
        
        return !(hasNeg && hasPos);
    }
    
    static double sign(double px, double py, double x1, double y1, double x2, double y2) {
        return (px - x2) * (y1 - y2) - (x1 - x2) * (py - y2);
    }
}
",0
p00143,"牽牛と織女
織女は天帝の子供でしたが、父の言いつけであけてもくれても機を織っていました。
織女の織る雲錦という見事な布で仕立てた服を着るのが天帝の楽しみでした。雲錦は寿命が短くすぐに劣化してしまいますが、働き者の織女が毎日織ってくれるので、問題はありませんでした。織女は、父の言いつけを守り、毎日毎日雲錦を織り続けていたので、ボーイフレンドはいませんでした。かわいそうに思った父は、天の川の向こう岸に住む牽牛という働き者を紹介し、嫁入りさせました。
すると、織女は、結婚の楽しさに夢中になって、機織りなどそっちのけで、牽牛と遊び呆けています。天帝のお気に入りの雲錦の服も新しく仕立てられないためボロボロになってしまいました。
これには父も怒って、織女を宮殿に連れ戻したいと思いました。しかし人間である牽牛の前にボロボロの服で姿を現すわけにはいきません。遊び呆けている二人を 3 角形の壁で遮断し自分以外の全てのものが行き来できなくすることを考えました。そして、牽牛に見つからずに、織女に会って、まじめに機を織るか、さもなければ強制的に連れ帰ると宣言するというのです。
天帝はこの作戦を遂行するために 3 角形の壁生成装置を開発することにしました。3 角形の 3 頂点の位置
(xp
1
, yp
1
)
,
(xp
2
, yp
2
)
,
(xp
3
, yp
3
)
、牽牛の位置
(xk, yk)
、および織女の位置
(xs, ys)
、を入力とし、三角形が牽牛と織女を遮断しているか否かを判定し、遮断できている場合は OK、遮断できていない場合には NG を出力するプログラムを作成してください。ただし、遮断しているとは、牽牛と織女のいずれかが三角形の内側にあり、他方が外側にある場合を言います。牽牛と織女は三角形の頂点もしくは辺の上にはいないものとします。
織女と牽牛は時々刻々場所を変えるため、プログラムは様々な位置情報を入力し質問に答えなければなりません。
Input
入力は以下の形式で与えられます。
n
query
1
query
2
:
query
n
１行目に判別したい情報の個数
n
(
n
≤ 10000)、続く
n
行に
i
番目の質問
query
i
が与えられます。各質問は以下の形式で与えられます。
xp
1
yp
1
xp
2
yp
2
xp
3
yp
3
xk
yk
xs
ys
各質問として、3 角形の 3 頂点の位置、牽牛の位置、および織女の位置 (-1000 ≤
xp
1
,
yp
1
,
xp
2
,
yp
2
,
xp
3
,
yp
3
,
xk
,
yk
,
xs
,
ys
≤ 1000) が１行に与えられます。入力はすべて整数です。
Output
質問ごとに、判定結果 OK または NG を１行に出力してください。
Sample Input
5
2 5 9 2 8 9 2 11 6 5
2 5 9 2 8 9 2 11 12 6
2 5 9 2 8 9 2 11 11 9
14 1 25 7 17 12 17 9 20 5
14 1 25 7 17 12 22 13 20 5
Output for the Sample Input
OK
NG
NG
NG
OK",Java,"import java.awt.geom.Point2D;
import java.util.Scanner;
public class Main {
	Scanner in = new Scanner(System.in);
	public static void main(String[] args) {
		new Main();
	}
	public Main() {
		int n = in.nextInt();
		for(int i=0;i<n;i++)new AOJ0143().doIt();
		
	}
	class AOJ0143{
		void doIt(){
			Point2D ps[] = new Point2D[3];
			for(int i=0;i<3;i++)ps[i] = new Point2D.Double(in.nextInt(),in.nextInt());;
			Point2D a = new Point2D.Double(in.nextInt(),in.nextInt());
			Point2D b = new Point2D.Double(in.nextInt(),in.nextInt());
			int c = contains(ps, a);
			int d = contains(ps, b);
//			System.out.println(c+"" ""+d);
			if(c==d)System.out.println(""NG"");
			else System.out.println(""OK"");
		}
		Point2D sub(Point2D p1,Point2D p2){
			return new Point2D.Double(p1.getX()-p2.getX(),p1.getY()-p2.getY());
		}
		double cross(Point2D p1,Point2D p2){
			return p1.getX()*p2.getY()-p1.getY()*p2.getX();
		}
		double dot(Point2D p1,Point2D p2){
			return p1.getX()*p2.getX()+p1.getY()*p2.getY();
		}
		private int contains(Point2D[] plist,Point2D p) {
			boolean isin = false;
			int n = plist.length;
			for(int i=0;i<n;i++){
				Point2D a = sub(plist[i], p);
				Point2D b = sub(plist[(i+1) % n], p);
				if(a.getY() > b.getY()){
					Point2D temp = (Point2D) a.clone();
					a = b;
					b = temp;
				}
				if(a.getY() <= 0 && 0 < b.getY()){
					if(cross(a,b) < 0) isin = ! isin;
				}
				if(cross(a,b) == 0 && dot(a, b) <= 0) return 0;
			}
			return isin ? 1 : -1;
		}
	}
}",1
p00143,"牽牛と織女
織女は天帝の子供でしたが、父の言いつけであけてもくれても機を織っていました。
織女の織る雲錦という見事な布で仕立てた服を着るのが天帝の楽しみでした。雲錦は寿命が短くすぐに劣化してしまいますが、働き者の織女が毎日織ってくれるので、問題はありませんでした。織女は、父の言いつけを守り、毎日毎日雲錦を織り続けていたので、ボーイフレンドはいませんでした。かわいそうに思った父は、天の川の向こう岸に住む牽牛という働き者を紹介し、嫁入りさせました。
すると、織女は、結婚の楽しさに夢中になって、機織りなどそっちのけで、牽牛と遊び呆けています。天帝のお気に入りの雲錦の服も新しく仕立てられないためボロボロになってしまいました。
これには父も怒って、織女を宮殿に連れ戻したいと思いました。しかし人間である牽牛の前にボロボロの服で姿を現すわけにはいきません。遊び呆けている二人を 3 角形の壁で遮断し自分以外の全てのものが行き来できなくすることを考えました。そして、牽牛に見つからずに、織女に会って、まじめに機を織るか、さもなければ強制的に連れ帰ると宣言するというのです。
天帝はこの作戦を遂行するために 3 角形の壁生成装置を開発することにしました。3 角形の 3 頂点の位置
(xp
1
, yp
1
)
,
(xp
2
, yp
2
)
,
(xp
3
, yp
3
)
、牽牛の位置
(xk, yk)
、および織女の位置
(xs, ys)
、を入力とし、三角形が牽牛と織女を遮断しているか否かを判定し、遮断できている場合は OK、遮断できていない場合には NG を出力するプログラムを作成してください。ただし、遮断しているとは、牽牛と織女のいずれかが三角形の内側にあり、他方が外側にある場合を言います。牽牛と織女は三角形の頂点もしくは辺の上にはいないものとします。
織女と牽牛は時々刻々場所を変えるため、プログラムは様々な位置情報を入力し質問に答えなければなりません。
Input
入力は以下の形式で与えられます。
n
query
1
query
2
:
query
n
１行目に判別したい情報の個数
n
(
n
≤ 10000)、続く
n
行に
i
番目の質問
query
i
が与えられます。各質問は以下の形式で与えられます。
xp
1
yp
1
xp
2
yp
2
xp
3
yp
3
xk
yk
xs
ys
各質問として、3 角形の 3 頂点の位置、牽牛の位置、および織女の位置 (-1000 ≤
xp
1
,
yp
1
,
xp
2
,
yp
2
,
xp
3
,
yp
3
,
xk
,
yk
,
xs
,
ys
≤ 1000) が１行に与えられます。入力はすべて整数です。
Output
質問ごとに、判定結果 OK または NG を１行に出力してください。
Sample Input
5
2 5 9 2 8 9 2 11 6 5
2 5 9 2 8 9 2 11 12 6
2 5 9 2 8 9 2 11 11 9
14 1 25 7 17 12 17 9 20 5
14 1 25 7 17 12 22 13 20 5
Output for the Sample Input
OK
NG
NG
NG
OK",Python,"def sign(p1, p2, p3):
    return (p1[0] - p3[0]) * (p2[1] - p3[1]) - (p2[0] - p3[0]) * (p1[1] - p3[1])

def point_in_triangle(pt, v1, v2, v3):
    d1 = sign(pt, v1, v2)
    d2 = sign(pt, v2, v3)
    d3 = sign(pt, v3, v1)
    
    has_neg = (d1 < 0) or (d2 < 0) or (d3 < 0)
    has_pos = (d1 > 0) or (d2 > 0) or (d3 > 0)
    
    return not (has_neg and has_pos)

n = int(input())
for _ in range(n):
    coords = list(map(int, input().split()))
    p1 = (coords[0], coords[1])
    p2 = (coords[2], coords[3])
    p3 = (coords[4], coords[5])
    k = (coords[6], coords[7])
    s = (coords[8], coords[9])
    
    k_inside = point_in_triangle(k, p1, p2, p3)
    s_inside = point_in_triangle(s, p1, p2, p3)
    
    if (k_inside and not s_inside) or (not k_inside and s_inside):
        print(""OK"")
    else:
        print(""NG"")
",0
p00143,"牽牛と織女
織女は天帝の子供でしたが、父の言いつけであけてもくれても機を織っていました。
織女の織る雲錦という見事な布で仕立てた服を着るのが天帝の楽しみでした。雲錦は寿命が短くすぐに劣化してしまいますが、働き者の織女が毎日織ってくれるので、問題はありませんでした。織女は、父の言いつけを守り、毎日毎日雲錦を織り続けていたので、ボーイフレンドはいませんでした。かわいそうに思った父は、天の川の向こう岸に住む牽牛という働き者を紹介し、嫁入りさせました。
すると、織女は、結婚の楽しさに夢中になって、機織りなどそっちのけで、牽牛と遊び呆けています。天帝のお気に入りの雲錦の服も新しく仕立てられないためボロボロになってしまいました。
これには父も怒って、織女を宮殿に連れ戻したいと思いました。しかし人間である牽牛の前にボロボロの服で姿を現すわけにはいきません。遊び呆けている二人を 3 角形の壁で遮断し自分以外の全てのものが行き来できなくすることを考えました。そして、牽牛に見つからずに、織女に会って、まじめに機を織るか、さもなければ強制的に連れ帰ると宣言するというのです。
天帝はこの作戦を遂行するために 3 角形の壁生成装置を開発することにしました。3 角形の 3 頂点の位置
(xp
1
, yp
1
)
,
(xp
2
, yp
2
)
,
(xp
3
, yp
3
)
、牽牛の位置
(xk, yk)
、および織女の位置
(xs, ys)
、を入力とし、三角形が牽牛と織女を遮断しているか否かを判定し、遮断できている場合は OK、遮断できていない場合には NG を出力するプログラムを作成してください。ただし、遮断しているとは、牽牛と織女のいずれかが三角形の内側にあり、他方が外側にある場合を言います。牽牛と織女は三角形の頂点もしくは辺の上にはいないものとします。
織女と牽牛は時々刻々場所を変えるため、プログラムは様々な位置情報を入力し質問に答えなければなりません。
Input
入力は以下の形式で与えられます。
n
query
1
query
2
:
query
n
１行目に判別したい情報の個数
n
(
n
≤ 10000)、続く
n
行に
i
番目の質問
query
i
が与えられます。各質問は以下の形式で与えられます。
xp
1
yp
1
xp
2
yp
2
xp
3
yp
3
xk
yk
xs
ys
各質問として、3 角形の 3 頂点の位置、牽牛の位置、および織女の位置 (-1000 ≤
xp
1
,
yp
1
,
xp
2
,
yp
2
,
xp
3
,
yp
3
,
xk
,
yk
,
xs
,
ys
≤ 1000) が１行に与えられます。入力はすべて整数です。
Output
質問ごとに、判定結果 OK または NG を１行に出力してください。
Sample Input
5
2 5 9 2 8 9 2 11 6 5
2 5 9 2 8 9 2 11 12 6
2 5 9 2 8 9 2 11 11 9
14 1 25 7 17 12 17 9 20 5
14 1 25 7 17 12 22 13 20 5
Output for the Sample Input
OK
NG
NG
NG
OK",Python,"class Vector:
    def __init__(self, x, y):
        self.x = x
        self.y = y

    def __sub__(self, other):
        return Vector(self.x - other.x, self.y - other.y)

    @staticmethod
    def cross_product(point1, point2):
        return point1.x * point2.y - point1.y * point2.x


class Triangle:
    def __init__(self, x1, y1, x2, y2, x3, y3):
        self.point1 = Vector(x1, y1)
        self.point2 = Vector(x2, y2)
        self.point3 = Vector(x3, y3)

    def is_contain(self, point):
        line1 = point - self.point1
        line2 = self.point2 - self.point1
        direct1 = Vector.cross_product(line1, line2)

        line1 = point - self.point2
        line2 = self.point3 - self.point2
        direct2 = Vector.cross_product(line1, line2)

        line1 = point - self.point3
        line2 = self.point1 - self.point3
        direct3 = Vector.cross_product(line1, line2)

        if 0 < direct1 and 0 < direct2 and 0 < direct3:
            return 1
        elif direct1 < 0 and direct2 < 0 and direct3 < 0:
            return 1
        else:
            return -1


for _ in range(int(input())):
    data = [int(item) for item in input().split("" "")]

    triangle = Triangle(data[0], data[1], data[2], data[3], data[4], data[5])
    altair_point = Vector(data[6], data[7])
    vega_point = Vector(data[8], data[9])

    is_contain1 = triangle.is_contain(altair_point)
    is_contain2 = triangle.is_contain(vega_point)
    result = is_contain1 * is_contain2

    if result == -1:
        print(""OK"")
    else:
        print(""NG"")

",1
p00144,"パケット転送
インターネットでは、データはパケットに分割され、パケットごとにルータと呼ばれる中継機器を介して宛先に転送されます。各ルータはパケットに記載された宛先から次に転送すべきルータを判断します。さらに、無限にルータ間を転送され続けることを防ぐため、パケットには TTL（Time To Live） という値が付加されています。ルータは受け取ったパケットの TTL を 1 減算し、その結果が 0 ならそのパケットを破棄し、それ以外なら次のルータに転送します。
そこで、ネットワークの設計を手助けするプログラムを作ることになりました。ネットワークの接続情報と送信パケットの情報を入力として、各パケットが宛先ルータに到着するまでに経由するルータの数のうち最小の値を表示するプログラムを作成してください。
ネットワークは図のように複数のルータとそれらを結ぶケーブルで構成されています。ただし、各接続（ケーブル）は単方向であることに注意してください。各ルータが直接つながっているルータの番号の配列がネットワークの接続の情報として与えられます。ルータの数を
n
とすれば、各ルータは 1 から
n
までの整数で識別されます。送信元から宛先ルータまでの経路が複数ある場合は、経由するルータの数が少ない方の値を出力してください。また、パケットが宛先に到達しない場合は NA と出力してください。
例えば、以下の図のようなネットワークで、送信元ルータが 6、宛先ルータが 5 の場合を考えます。最短経路は 6→1→5 であり経由するルータは 3 個です。この場合、TTL はルータ 6、1 でそれぞれ減算されるので、送信時の TTL が 3 以上であればパケットは到達できます。宛先ルータでは TTL を減算する必要はありません。また、送信元と宛先が同じルータになるようなパケットは無いものとします。
Input
入力は以下の形式で与えられます。
n
r
1
k
1
t
11
t
12
...
t
1k
1
r
2
k
2
t
21
t
22
...
t
2k
2
:
r
n
k
n
t
n1
t
n2
...
t
nk
n
p
s
1
d
1
v
1
s
2
d
2
v
2
:
s
p
d
p
v
p
1 行目にルータの総数
n
（
n
≤ 100）、続く
n
行に
i
番目のルータの接続情報が与えられます。接続情報として、
i
番目のルータの番号
r
i
、
i
番目のルータと直接接続しているルータの個数
k
i
、
i
番目のルータから送信できるルータの番号
t
i1
,
t
i2
, ...
t
ik
i
が与えられます。
続く行にパケットの個数
p
（
p
≤ 1000）、続く
p
行に
i
番目のパケットの情報が与えられます。パケットの情報として、 送信元ルータの番号
s
i
, 宛先ルータの番号
d
i
, TTL の値
v
i
(0 ≤
v
i
≤ 10000) が与えられます。
Output
各パケットごとに、経由するルータの個数または NA を１行に出力してください。
Sample Input
7
1 4 2 5 4 3
2 1 5
3 1 6
4 1 7
5 2 7 6
6 1 1
7 0
6
1 2 2
1 5 3
1 2 1
5 1 3
6 3 3
1 7 4
Output for the Sample Input
2
2
NA
3
3
3",C,"#include <stdio.h>
#include <string.h>
#include <limits.h>

#define MAX_N 101
#define INF INT_MAX

int adj[MAX_N][MAX_N];
int adjCount[MAX_N];
int dist[MAX_N];
int visited[MAX_N];

int bfs(int start, int end, int n) {
    int queue[MAX_N * MAX_N];
    int front = 0, rear = 0;
    
    for (int i = 1; i <= n; i++) {
        dist[i] = INF;
        visited[i] = 0;
    }
    
    queue[rear++] = start;
    dist[start] = 1;
    visited[start] = 1;
    
    while (front < rear) {
        int u = queue[front++];
        
        if (u == end) {
            return dist[end];
        }
        
        for (int i = 0; i < adjCount[u]; i++) {
            int v = adj[u][i];
            if (!visited[v]) {
                visited[v] = 1;
                dist[v] = dist[u] + 1;
                queue[rear++] = v;
            }
        }
    }
    
    return -1;
}

int main() {
    int n;
    scanf(""%d"", &n);
    
    for (int i = 1; i <= n; i++) {
        adjCount[i] = 0;
    }
    
    for (int i = 0; i < n; i++) {
        int r, k;
        scanf(""%d %d"", &r, &k);
        adjCount[r] = k;
        for (int j = 0; j < k; j++) {
            scanf(""%d"", &adj[r][j]);
        }
    }
    
    int p;
    scanf(""%d"", &p);
    
    for (int i = 0; i < p; i++) {
        int s, d, v;
        scanf(""%d %d %d"", &s, &d, &v);
        
        int minDist = bfs(s, d, n);
        
        if (minDist == -1) {
            printf(""NA\n"");
        } else {
            int hops = minDist - 1;
            if (v >= hops) {
                printf(""%d\n"", minDist);
            } else {
                printf(""NA\n"");
            }
        }
    }
    
    return 0;
}
",0
p00144,"パケット転送
インターネットでは、データはパケットに分割され、パケットごとにルータと呼ばれる中継機器を介して宛先に転送されます。各ルータはパケットに記載された宛先から次に転送すべきルータを判断します。さらに、無限にルータ間を転送され続けることを防ぐため、パケットには TTL（Time To Live） という値が付加されています。ルータは受け取ったパケットの TTL を 1 減算し、その結果が 0 ならそのパケットを破棄し、それ以外なら次のルータに転送します。
そこで、ネットワークの設計を手助けするプログラムを作ることになりました。ネットワークの接続情報と送信パケットの情報を入力として、各パケットが宛先ルータに到着するまでに経由するルータの数のうち最小の値を表示するプログラムを作成してください。
ネットワークは図のように複数のルータとそれらを結ぶケーブルで構成されています。ただし、各接続（ケーブル）は単方向であることに注意してください。各ルータが直接つながっているルータの番号の配列がネットワークの接続の情報として与えられます。ルータの数を
n
とすれば、各ルータは 1 から
n
までの整数で識別されます。送信元から宛先ルータまでの経路が複数ある場合は、経由するルータの数が少ない方の値を出力してください。また、パケットが宛先に到達しない場合は NA と出力してください。
例えば、以下の図のようなネットワークで、送信元ルータが 6、宛先ルータが 5 の場合を考えます。最短経路は 6→1→5 であり経由するルータは 3 個です。この場合、TTL はルータ 6、1 でそれぞれ減算されるので、送信時の TTL が 3 以上であればパケットは到達できます。宛先ルータでは TTL を減算する必要はありません。また、送信元と宛先が同じルータになるようなパケットは無いものとします。
Input
入力は以下の形式で与えられます。
n
r
1
k
1
t
11
t
12
...
t
1k
1
r
2
k
2
t
21
t
22
...
t
2k
2
:
r
n
k
n
t
n1
t
n2
...
t
nk
n
p
s
1
d
1
v
1
s
2
d
2
v
2
:
s
p
d
p
v
p
1 行目にルータの総数
n
（
n
≤ 100）、続く
n
行に
i
番目のルータの接続情報が与えられます。接続情報として、
i
番目のルータの番号
r
i
、
i
番目のルータと直接接続しているルータの個数
k
i
、
i
番目のルータから送信できるルータの番号
t
i1
,
t
i2
, ...
t
ik
i
が与えられます。
続く行にパケットの個数
p
（
p
≤ 1000）、続く
p
行に
i
番目のパケットの情報が与えられます。パケットの情報として、 送信元ルータの番号
s
i
, 宛先ルータの番号
d
i
, TTL の値
v
i
(0 ≤
v
i
≤ 10000) が与えられます。
Output
各パケットごとに、経由するルータの個数または NA を１行に出力してください。
Sample Input
7
1 4 2 5 4 3
2 1 5
3 1 6
4 1 7
5 2 7 6
6 1 1
7 0
6
1 2 2
1 5 3
1 2 1
5 1 3
6 3 3
1 7 4
Output for the Sample Input
2
2
NA
3
3
3",C,"#include <stdio.h>

int r[100][100];
int n;

int dijkstra(int start, int goal) {
  int i;
  int minimum, p;
  int d[100], f[100];

  for(i = 0; i < 100; i++) {
    d[i] = 100000;
    f[i] = 0;
  }
  d[start-1] = 1;
  while(1) {
    minimum = 100000;
    for(i = 0; i < n; i++) {
      if(d[i] < minimum && f[i] == 0) {
	minimum = d[i];
	p = i;
      }
    }
    if(minimum == 100000) break;
    f[p] = 1;

    for(i = 0; i < n; i++) {
      if(d[p] + r[p][i] < d[i]) {
	d[i] = d[p] + r[p][i];
      }
    }
  }

  return d[goal-1];
}

int main() {
  int i, j, r1, k1, p, s1, d1, v1, temp;

  for(i = 0; i < 100; i++)
    for(j = 0; j < 100; j++)
      r[i][j] = 100000;

  scanf(""%d"", &n);
  for(i = 0; i < n; i++) {
    scanf(""%d %d"", &r1, &k1);
    for(j = 0; j < k1; j++) {
      scanf(""%d"", &temp);
      r[r1-1][temp-1] = 1;
    }
  }
  scanf(""%d"", &p);
  for(i = 0; i < p; i++) {
    scanf(""%d %d %d"", &s1, &d1, &v1);
    temp = dijkstra(s1, d1);
    if(v1 - temp < 0) {
      printf(""NA\n"");
    } else {
      printf(""%d\n"", temp);
    }
  }
  return 0;
}",1
p00144,"パケット転送
インターネットでは、データはパケットに分割され、パケットごとにルータと呼ばれる中継機器を介して宛先に転送されます。各ルータはパケットに記載された宛先から次に転送すべきルータを判断します。さらに、無限にルータ間を転送され続けることを防ぐため、パケットには TTL（Time To Live） という値が付加されています。ルータは受け取ったパケットの TTL を 1 減算し、その結果が 0 ならそのパケットを破棄し、それ以外なら次のルータに転送します。
そこで、ネットワークの設計を手助けするプログラムを作ることになりました。ネットワークの接続情報と送信パケットの情報を入力として、各パケットが宛先ルータに到着するまでに経由するルータの数のうち最小の値を表示するプログラムを作成してください。
ネットワークは図のように複数のルータとそれらを結ぶケーブルで構成されています。ただし、各接続（ケーブル）は単方向であることに注意してください。各ルータが直接つながっているルータの番号の配列がネットワークの接続の情報として与えられます。ルータの数を
n
とすれば、各ルータは 1 から
n
までの整数で識別されます。送信元から宛先ルータまでの経路が複数ある場合は、経由するルータの数が少ない方の値を出力してください。また、パケットが宛先に到達しない場合は NA と出力してください。
例えば、以下の図のようなネットワークで、送信元ルータが 6、宛先ルータが 5 の場合を考えます。最短経路は 6→1→5 であり経由するルータは 3 個です。この場合、TTL はルータ 6、1 でそれぞれ減算されるので、送信時の TTL が 3 以上であればパケットは到達できます。宛先ルータでは TTL を減算する必要はありません。また、送信元と宛先が同じルータになるようなパケットは無いものとします。
Input
入力は以下の形式で与えられます。
n
r
1
k
1
t
11
t
12
...
t
1k
1
r
2
k
2
t
21
t
22
...
t
2k
2
:
r
n
k
n
t
n1
t
n2
...
t
nk
n
p
s
1
d
1
v
1
s
2
d
2
v
2
:
s
p
d
p
v
p
1 行目にルータの総数
n
（
n
≤ 100）、続く
n
行に
i
番目のルータの接続情報が与えられます。接続情報として、
i
番目のルータの番号
r
i
、
i
番目のルータと直接接続しているルータの個数
k
i
、
i
番目のルータから送信できるルータの番号
t
i1
,
t
i2
, ...
t
ik
i
が与えられます。
続く行にパケットの個数
p
（
p
≤ 1000）、続く
p
行に
i
番目のパケットの情報が与えられます。パケットの情報として、 送信元ルータの番号
s
i
, 宛先ルータの番号
d
i
, TTL の値
v
i
(0 ≤
v
i
≤ 10000) が与えられます。
Output
各パケットごとに、経由するルータの個数または NA を１行に出力してください。
Sample Input
7
1 4 2 5 4 3
2 1 5
3 1 6
4 1 7
5 2 7 6
6 1 1
7 0
6
1 2 2
1 5 3
1 2 1
5 1 3
6 3 3
1 7 4
Output for the Sample Input
2
2
NA
3
3
3",Java,"import java.util.*;

public class Main {
    static class Router {
        int id;
        List<Integer> connections;
        
        Router(int id) {
            this.id = id;
            this.connections = new ArrayList<>();
        }
    }
    
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        
        int n = sc.nextInt();
        Map<Integer, Router> routers = new HashMap<>();
        
        for (int i = 0; i < n; i++) {
            int routerId = sc.nextInt();
            Router router = new Router(routerId);
            int k = sc.nextInt();
            for (int j = 0; j < k; j++) {
                router.connections.add(sc.nextInt());
            }
            routers.put(routerId, router);
        }
        
        int p = sc.nextInt();
        for (int i = 0; i < p; i++) {
            int source = sc.nextInt();
            int dest = sc.nextInt();
            int ttl = sc.nextInt();
            
            int minHops = bfs(routers, source, dest);
            
            if (minHops == -1 || ttl < minHops - 1) {
                System.out.println(""NA"");
            } else {
                System.out.println(minHops);
            }
        }
        
        sc.close();
    }
    
    static int bfs(Map<Integer, Router> routers, int source, int dest) {
        Queue<Integer> queue = new LinkedList<>();
        Map<Integer, Integer> distance = new HashMap<>();
        
        queue.offer(source);
        distance.put(source, 1);
        
        while (!queue.isEmpty()) {
            int current = queue.poll();
            int currentDist = distance.get(current);
            
            if (current == dest) {
                return currentDist;
            }
            
            Router router = routers.get(current);
            if (router != null) {
                for (int next : router.connections) {
                    if (!distance.containsKey(next)) {
                        distance.put(next, currentDist + 1);
                        queue.offer(next);
                    }
                }
            }
        }
        
        return -1;
    }
}
",0
p00144,"パケット転送
インターネットでは、データはパケットに分割され、パケットごとにルータと呼ばれる中継機器を介して宛先に転送されます。各ルータはパケットに記載された宛先から次に転送すべきルータを判断します。さらに、無限にルータ間を転送され続けることを防ぐため、パケットには TTL（Time To Live） という値が付加されています。ルータは受け取ったパケットの TTL を 1 減算し、その結果が 0 ならそのパケットを破棄し、それ以外なら次のルータに転送します。
そこで、ネットワークの設計を手助けするプログラムを作ることになりました。ネットワークの接続情報と送信パケットの情報を入力として、各パケットが宛先ルータに到着するまでに経由するルータの数のうち最小の値を表示するプログラムを作成してください。
ネットワークは図のように複数のルータとそれらを結ぶケーブルで構成されています。ただし、各接続（ケーブル）は単方向であることに注意してください。各ルータが直接つながっているルータの番号の配列がネットワークの接続の情報として与えられます。ルータの数を
n
とすれば、各ルータは 1 から
n
までの整数で識別されます。送信元から宛先ルータまでの経路が複数ある場合は、経由するルータの数が少ない方の値を出力してください。また、パケットが宛先に到達しない場合は NA と出力してください。
例えば、以下の図のようなネットワークで、送信元ルータが 6、宛先ルータが 5 の場合を考えます。最短経路は 6→1→5 であり経由するルータは 3 個です。この場合、TTL はルータ 6、1 でそれぞれ減算されるので、送信時の TTL が 3 以上であればパケットは到達できます。宛先ルータでは TTL を減算する必要はありません。また、送信元と宛先が同じルータになるようなパケットは無いものとします。
Input
入力は以下の形式で与えられます。
n
r
1
k
1
t
11
t
12
...
t
1k
1
r
2
k
2
t
21
t
22
...
t
2k
2
:
r
n
k
n
t
n1
t
n2
...
t
nk
n
p
s
1
d
1
v
1
s
2
d
2
v
2
:
s
p
d
p
v
p
1 行目にルータの総数
n
（
n
≤ 100）、続く
n
行に
i
番目のルータの接続情報が与えられます。接続情報として、
i
番目のルータの番号
r
i
、
i
番目のルータと直接接続しているルータの個数
k
i
、
i
番目のルータから送信できるルータの番号
t
i1
,
t
i2
, ...
t
ik
i
が与えられます。
続く行にパケットの個数
p
（
p
≤ 1000）、続く
p
行に
i
番目のパケットの情報が与えられます。パケットの情報として、 送信元ルータの番号
s
i
, 宛先ルータの番号
d
i
, TTL の値
v
i
(0 ≤
v
i
≤ 10000) が与えられます。
Output
各パケットごとに、経由するルータの個数または NA を１行に出力してください。
Sample Input
7
1 4 2 5 4 3
2 1 5
3 1 6
4 1 7
5 2 7 6
6 1 1
7 0
6
1 2 2
1 5 3
1 2 1
5 1 3
6 3 3
1 7 4
Output for the Sample Input
2
2
NA
3
3
3",Java,"import java.io.*;
import java.util.*;

public class Main{
	public static void main(String args[]){
		try{
			new Main();
		}catch(IOException e){
			e.printStackTrace();
		}
	}
	
	public Main() throws IOException{
		BufferedReader in = new BufferedReader(new InputStreamReader(System.in));
		String line = in.readLine();
	
		int size = Integer.parseInt(line);
		Node[] nodes = new Node[size];
		for(int i=0; i<size; i++){
			line = in.readLine();
			String[] tmp = line.split("" "");
			int id = Integer.parseInt(tmp[0])-1;
			nodes[id] = new Node();
			int n_to = Integer.parseInt(tmp[1]);
			for(int j=2; j<2+n_to; j++){
				int to = Integer.parseInt(tmp[j])-1;
				nodes[id].add_edge(to, 1);
			}
		}
		
		line = in.readLine();
		size = Integer.parseInt(line);
		for(int i=0; i<size; i++){
			Node[] clone = deepClone(nodes);
			line = in.readLine();
			String[] tmp = line.split("" "");
			int s = Integer.parseInt(tmp[0])-1;
			int g = Integer.parseInt(tmp[1])-1;
			int ttl = Integer.parseInt(tmp[2]);
			int total = calcCost(clone, s, g);
			if(ttl >= total && total != -1){
				System.out.println(total);
			}else{
				System.out.println(""NA"");
			}
		}
	}
	
	public int calcCost(Node[] nodes, int s, int g){
		List<Node> que = new ArrayList<Node>();
		nodes[s].cost = 1;
		que.add(nodes[s]);
		Node done = null;
		while(que.size()!=0){
			done = que.get(0);
			que.remove(0);
			done.visited = true;
			for(int i=0; i<done.edge_to.size(); i++){
				int cost = done.cost + done.edge_cost.get(i);
				int to = done.edge_to.get(i);
				if(nodes[to].cost < 0 || cost < nodes[to].cost){
					nodes[to].cost = cost;
					if(!que.contains(nodes[to])){
						que.add(nodes[to]);
					}
				}
			}
		}
		return nodes[g].cost;
	}
	
	public Node[] deepClone(Node[] nodes){
		int m = nodes.length;
		Node[] clone = new Node[m];
		for(int i=0; i<m; i++){
			clone[i] = new Node(nodes[i]);
		}
		return clone;
	}
}

class Node{
	int cost;
	boolean visited;
	List<Integer> edge_to;
	List<Integer> edge_cost;
	
	public Node(){
		this.cost = -1;
		this.visited = false;
		this.edge_cost = new ArrayList<Integer>();
		this.edge_to = new ArrayList<Integer>();
	}
	
	public Node(Node n){
		this.cost = n.cost;
		this.visited = n.visited;
		this.edge_to = new ArrayList<Integer>(n.edge_to);
		this.edge_cost = new ArrayList<Integer>(n.edge_cost);
	}
	
	public void add_edge(int to, int cost){
		this.edge_cost.add(cost);
		this.edge_to.add(to);
	}
}",1
p00144,"パケット転送
インターネットでは、データはパケットに分割され、パケットごとにルータと呼ばれる中継機器を介して宛先に転送されます。各ルータはパケットに記載された宛先から次に転送すべきルータを判断します。さらに、無限にルータ間を転送され続けることを防ぐため、パケットには TTL（Time To Live） という値が付加されています。ルータは受け取ったパケットの TTL を 1 減算し、その結果が 0 ならそのパケットを破棄し、それ以外なら次のルータに転送します。
そこで、ネットワークの設計を手助けするプログラムを作ることになりました。ネットワークの接続情報と送信パケットの情報を入力として、各パケットが宛先ルータに到着するまでに経由するルータの数のうち最小の値を表示するプログラムを作成してください。
ネットワークは図のように複数のルータとそれらを結ぶケーブルで構成されています。ただし、各接続（ケーブル）は単方向であることに注意してください。各ルータが直接つながっているルータの番号の配列がネットワークの接続の情報として与えられます。ルータの数を
n
とすれば、各ルータは 1 から
n
までの整数で識別されます。送信元から宛先ルータまでの経路が複数ある場合は、経由するルータの数が少ない方の値を出力してください。また、パケットが宛先に到達しない場合は NA と出力してください。
例えば、以下の図のようなネットワークで、送信元ルータが 6、宛先ルータが 5 の場合を考えます。最短経路は 6→1→5 であり経由するルータは 3 個です。この場合、TTL はルータ 6、1 でそれぞれ減算されるので、送信時の TTL が 3 以上であればパケットは到達できます。宛先ルータでは TTL を減算する必要はありません。また、送信元と宛先が同じルータになるようなパケットは無いものとします。
Input
入力は以下の形式で与えられます。
n
r
1
k
1
t
11
t
12
...
t
1k
1
r
2
k
2
t
21
t
22
...
t
2k
2
:
r
n
k
n
t
n1
t
n2
...
t
nk
n
p
s
1
d
1
v
1
s
2
d
2
v
2
:
s
p
d
p
v
p
1 行目にルータの総数
n
（
n
≤ 100）、続く
n
行に
i
番目のルータの接続情報が与えられます。接続情報として、
i
番目のルータの番号
r
i
、
i
番目のルータと直接接続しているルータの個数
k
i
、
i
番目のルータから送信できるルータの番号
t
i1
,
t
i2
, ...
t
ik
i
が与えられます。
続く行にパケットの個数
p
（
p
≤ 1000）、続く
p
行に
i
番目のパケットの情報が与えられます。パケットの情報として、 送信元ルータの番号
s
i
, 宛先ルータの番号
d
i
, TTL の値
v
i
(0 ≤
v
i
≤ 10000) が与えられます。
Output
各パケットごとに、経由するルータの個数または NA を１行に出力してください。
Sample Input
7
1 4 2 5 4 3
2 1 5
3 1 6
4 1 7
5 2 7 6
6 1 1
7 0
6
1 2 2
1 5 3
1 2 1
5 1 3
6 3 3
1 7 4
Output for the Sample Input
2
2
NA
3
3
3",Python,"from collections import deque, defaultdict

def bfs(graph, start, end, n):
    if start == end:
        return 0
    
    visited = [False] * (n + 1)
    queue = deque([(start, 0)])
    visited[start] = True
    
    while queue:
        node, dist = queue.popleft()
        
        if node in graph:
            for neighbor in graph[node]:
                if not visited[neighbor]:
                    if neighbor == end:
                        return dist + 1
                    visited[neighbor] = True
                    queue.append((neighbor, dist + 1))
    
    return -1

n = int(input())
graph = defaultdict(list)

for _ in range(n):
    line = list(map(int, input().split()))
    router_id = line[0]
    k = line[1]
    if k > 0:
        connections = line[2:2+k]
        graph[router_id] = connections

p = int(input())

for _ in range(p):
    s, d, v = map(int, input().split())
    
    min_hops = bfs(graph, s, d, n)
    
    if min_hops == -1:
        print(""NA"")
    else:
        if v >= min_hops:
            print(min_hops + 1)
        else:
            print(""NA"")
",0
p00144,"パケット転送
インターネットでは、データはパケットに分割され、パケットごとにルータと呼ばれる中継機器を介して宛先に転送されます。各ルータはパケットに記載された宛先から次に転送すべきルータを判断します。さらに、無限にルータ間を転送され続けることを防ぐため、パケットには TTL（Time To Live） という値が付加されています。ルータは受け取ったパケットの TTL を 1 減算し、その結果が 0 ならそのパケットを破棄し、それ以外なら次のルータに転送します。
そこで、ネットワークの設計を手助けするプログラムを作ることになりました。ネットワークの接続情報と送信パケットの情報を入力として、各パケットが宛先ルータに到着するまでに経由するルータの数のうち最小の値を表示するプログラムを作成してください。
ネットワークは図のように複数のルータとそれらを結ぶケーブルで構成されています。ただし、各接続（ケーブル）は単方向であることに注意してください。各ルータが直接つながっているルータの番号の配列がネットワークの接続の情報として与えられます。ルータの数を
n
とすれば、各ルータは 1 から
n
までの整数で識別されます。送信元から宛先ルータまでの経路が複数ある場合は、経由するルータの数が少ない方の値を出力してください。また、パケットが宛先に到達しない場合は NA と出力してください。
例えば、以下の図のようなネットワークで、送信元ルータが 6、宛先ルータが 5 の場合を考えます。最短経路は 6→1→5 であり経由するルータは 3 個です。この場合、TTL はルータ 6、1 でそれぞれ減算されるので、送信時の TTL が 3 以上であればパケットは到達できます。宛先ルータでは TTL を減算する必要はありません。また、送信元と宛先が同じルータになるようなパケットは無いものとします。
Input
入力は以下の形式で与えられます。
n
r
1
k
1
t
11
t
12
...
t
1k
1
r
2
k
2
t
21
t
22
...
t
2k
2
:
r
n
k
n
t
n1
t
n2
...
t
nk
n
p
s
1
d
1
v
1
s
2
d
2
v
2
:
s
p
d
p
v
p
1 行目にルータの総数
n
（
n
≤ 100）、続く
n
行に
i
番目のルータの接続情報が与えられます。接続情報として、
i
番目のルータの番号
r
i
、
i
番目のルータと直接接続しているルータの個数
k
i
、
i
番目のルータから送信できるルータの番号
t
i1
,
t
i2
, ...
t
ik
i
が与えられます。
続く行にパケットの個数
p
（
p
≤ 1000）、続く
p
行に
i
番目のパケットの情報が与えられます。パケットの情報として、 送信元ルータの番号
s
i
, 宛先ルータの番号
d
i
, TTL の値
v
i
(0 ≤
v
i
≤ 10000) が与えられます。
Output
各パケットごとに、経由するルータの個数または NA を１行に出力してください。
Sample Input
7
1 4 2 5 4 3
2 1 5
3 1 6
4 1 7
5 2 7 6
6 1 1
7 0
6
1 2 2
1 5 3
1 2 1
5 1 3
6 3 3
1 7 4
Output for the Sample Input
2
2
NA
3
3
3",Python,"def solve(A):
  s,d,v = A
  C = [-1 for _ in [0]*(n+1)]
  c = 1
  C[s] = c
  SP = M[s]
  while 1:
    if SP==[]: return ""NA""
    c += 1
    X = []
    for p in SP:
      if C[p]>0: continue
      C[p] = c
      X += [e for e in M[p] if C[e]<0 and e not in SP]
      if p==d: return [C[d],""NA""][C[p]>v]
    SP = X

n = int(raw_input())
M = {}

for _ in [0]*n:
  x = map(int, raw_input().split())
  M[x[0]] = x[2:]
for _ in [0]*int(raw_input()):
  print solve(map(int,raw_input().split()))",1
p00145,"カード
正の整数が書かれた一組のカードがあります。カードを積んで山をいくつか作り、それらを横一列に並べます。その中から隣り合った 2 つのカードの山を選び、右側の山の上に左側の山をそのまま重ねます。この操作をカードの山が一つになるまで繰り返していきます。
2 つのカードの山を重ねる時にそれらの一番上と下のカードに書かれた数をすべて掛け合わせます。こうして得られた数をカードの重ね合わせのコストと呼ぶことにします。カードの山を一つにするためのコストはすべての重ね合わせのコストを足し合わせたものとします。
どのような順番でカードの山を重ねるかでコストは変わります。たとえば、3 つのカードの山がある場合を考えます。それらの一番上と下のカードに書かれた数が，左側の山から順にそれぞれ 3 と 5, 2 と 8, 5 と4 だったとします。このとき，はじめに左と真ん中の山を重ねたときのコストは、3 × 5 × 2 × 8 = 240 です。この重ね合わせによって、一番上のカードが 3 で一番下のカードが 8 である山ができます。
この山を右の山の上に重ねると、そのコストは 3 × 8 × 5 × 4 = 480 になります。したがって、この順番でカードの山を一つにまとめたときのコストは 240 + 480 = 720 です。（図1）
一方、はじめに真ん中と右の山を重ねてから最後に左の山を重ねることにすると、そのときのコストは 2 × 8 × 5 × 4 + 3 × 5 × 2 × 4 = 440 になります。したがって，後の場合のように重ねた方がコストが小さくなります。（図2）
カードの山の個数とそれぞれの山の一番上と下のカードに書かれた数を入力とし、カードの山を一つにまとめるのに必要な最小のコストを出力するプログラムを作成してください。ただし、山の個数は 100 個以下とし、入力されるデータはどのような順番でコストを計算しても 2
31
-1 を超えることはありません。
Input
入力は以下の形式で与えられます。
n
a
1
b
1
a
2
b
2
:
a
n
b
n
1 行目にカードの山の個数
n
(
n
≤ 100)、続く
n
行に左から
i
番目の山の 1 番上のカードに書かれた数
a
i
(1 ≤
a
i
≤ 200) と 1 番下のカードに書かれた数
b
i
(1 ≤
b
i
≤ 200) が与えられます。
Output
カードの山を一つにまとめるのに必要な最小のコストを１行に出力してください。
Sample Input
3
3 5
2 8
5 4
Output for the Sample Input
440",C,"#include <stdio.h>
#include <limits.h>

int n;
int a[101], b[101];
long long dp[101][101];

long long solve(int l, int r) {
    if (l == r) return 0;
    if (dp[l][r] != -1) return dp[l][r];
    
    long long min_cost = LLONG_MAX;
    
    for (int k = l; k < r; k++) {
        long long cost = solve(l, k) + solve(k + 1, r);
        cost += (long long)a[l] * b[k] * a[k + 1] * b[r];
        if (cost < min_cost) {
            min_cost = cost;
        }
    }
    
    dp[l][r] = min_cost;
    return min_cost;
}

int main() {
    scanf(""%d"", &n);
    
    for (int i = 1; i <= n; i++) {
        scanf(""%d %d"", &a[i], &b[i]);
    }
    
    for (int i = 0; i <= n; i++) {
        for (int j = 0; j <= n; j++) {
            dp[i][j] = -1;
        }
    }
    
    printf(""%lld\n"", solve(1, n));
    
    return 0;
}
",0
p00145,"カード
正の整数が書かれた一組のカードがあります。カードを積んで山をいくつか作り、それらを横一列に並べます。その中から隣り合った 2 つのカードの山を選び、右側の山の上に左側の山をそのまま重ねます。この操作をカードの山が一つになるまで繰り返していきます。
2 つのカードの山を重ねる時にそれらの一番上と下のカードに書かれた数をすべて掛け合わせます。こうして得られた数をカードの重ね合わせのコストと呼ぶことにします。カードの山を一つにするためのコストはすべての重ね合わせのコストを足し合わせたものとします。
どのような順番でカードの山を重ねるかでコストは変わります。たとえば、3 つのカードの山がある場合を考えます。それらの一番上と下のカードに書かれた数が，左側の山から順にそれぞれ 3 と 5, 2 と 8, 5 と4 だったとします。このとき，はじめに左と真ん中の山を重ねたときのコストは、3 × 5 × 2 × 8 = 240 です。この重ね合わせによって、一番上のカードが 3 で一番下のカードが 8 である山ができます。
この山を右の山の上に重ねると、そのコストは 3 × 8 × 5 × 4 = 480 になります。したがって、この順番でカードの山を一つにまとめたときのコストは 240 + 480 = 720 です。（図1）
一方、はじめに真ん中と右の山を重ねてから最後に左の山を重ねることにすると、そのときのコストは 2 × 8 × 5 × 4 + 3 × 5 × 2 × 4 = 440 になります。したがって，後の場合のように重ねた方がコストが小さくなります。（図2）
カードの山の個数とそれぞれの山の一番上と下のカードに書かれた数を入力とし、カードの山を一つにまとめるのに必要な最小のコストを出力するプログラムを作成してください。ただし、山の個数は 100 個以下とし、入力されるデータはどのような順番でコストを計算しても 2
31
-1 を超えることはありません。
Input
入力は以下の形式で与えられます。
n
a
1
b
1
a
2
b
2
:
a
n
b
n
1 行目にカードの山の個数
n
(
n
≤ 100)、続く
n
行に左から
i
番目の山の 1 番上のカードに書かれた数
a
i
(1 ≤
a
i
≤ 200) と 1 番下のカードに書かれた数
b
i
(1 ≤
b
i
≤ 200) が与えられます。
Output
カードの山を一つにまとめるのに必要な最小のコストを１行に出力してください。
Sample Input
3
3 5
2 8
5 4
Output for the Sample Input
440",C,"#include <stdio.h>

int main(){
  int c1[100],c2[100],i,j,k,n,s=0,a,amax=0,amaxi;

  scanf(""%d\n"",&n);
  for(i=0;i<n;i++) scanf(""%d %d\n"",&c1[i],&c2[i]);

  for(i=0;i<n-1;i++){
    for(j=0;j<n-i-1;j++){
      a=c2[j]*c1[j+1];
      if(a>amax || (a==amax && c1[j]*c2[j+1] < c1[amaxi]*c2[amaxi+1])){
        amax=a;
        amaxi=j;
      }
    }
    s+=c1[amaxi]*c2[amaxi]*c1[amaxi+1]*c2[amaxi+1];
    c2[amaxi]=c2[amaxi+1];
    for(j=amaxi+1;j<n-i;j++){
      c1[j]=c1[j+1];
      c2[j]=c2[j+1];
    }
    amax=0;
  }
  printf(""%d\n"",s);
  return 0;
}",1
p00145,"カード
正の整数が書かれた一組のカードがあります。カードを積んで山をいくつか作り、それらを横一列に並べます。その中から隣り合った 2 つのカードの山を選び、右側の山の上に左側の山をそのまま重ねます。この操作をカードの山が一つになるまで繰り返していきます。
2 つのカードの山を重ねる時にそれらの一番上と下のカードに書かれた数をすべて掛け合わせます。こうして得られた数をカードの重ね合わせのコストと呼ぶことにします。カードの山を一つにするためのコストはすべての重ね合わせのコストを足し合わせたものとします。
どのような順番でカードの山を重ねるかでコストは変わります。たとえば、3 つのカードの山がある場合を考えます。それらの一番上と下のカードに書かれた数が，左側の山から順にそれぞれ 3 と 5, 2 と 8, 5 と4 だったとします。このとき，はじめに左と真ん中の山を重ねたときのコストは、3 × 5 × 2 × 8 = 240 です。この重ね合わせによって、一番上のカードが 3 で一番下のカードが 8 である山ができます。
この山を右の山の上に重ねると、そのコストは 3 × 8 × 5 × 4 = 480 になります。したがって、この順番でカードの山を一つにまとめたときのコストは 240 + 480 = 720 です。（図1）
一方、はじめに真ん中と右の山を重ねてから最後に左の山を重ねることにすると、そのときのコストは 2 × 8 × 5 × 4 + 3 × 5 × 2 × 4 = 440 になります。したがって，後の場合のように重ねた方がコストが小さくなります。（図2）
カードの山の個数とそれぞれの山の一番上と下のカードに書かれた数を入力とし、カードの山を一つにまとめるのに必要な最小のコストを出力するプログラムを作成してください。ただし、山の個数は 100 個以下とし、入力されるデータはどのような順番でコストを計算しても 2
31
-1 を超えることはありません。
Input
入力は以下の形式で与えられます。
n
a
1
b
1
a
2
b
2
:
a
n
b
n
1 行目にカードの山の個数
n
(
n
≤ 100)、続く
n
行に左から
i
番目の山の 1 番上のカードに書かれた数
a
i
(1 ≤
a
i
≤ 200) と 1 番下のカードに書かれた数
b
i
(1 ≤
b
i
≤ 200) が与えられます。
Output
カードの山を一つにまとめるのに必要な最小のコストを１行に出力してください。
Sample Input
3
3 5
2 8
5 4
Output for the Sample Input
440",Java,"import java.util.*;

public class Main {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int n = sc.nextInt();
        int[][] cards = new int[n][2];
        
        for (int i = 0; i < n; i++) {
            cards[i][0] = sc.nextInt(); // top
            cards[i][1] = sc.nextInt(); // bottom
        }
        
        // dp[i][j] = minimum cost to merge piles from i to j into one pile
        long[][] dp = new long[n][n];
        // result[i][j][0] = top card after merging i to j
        // result[i][j][1] = bottom card after merging i to j
        int[][][] result = new int[n][n][2];
        
        // Initialize single piles
        for (int i = 0; i < n; i++) {
            dp[i][i] = 0;
            result[i][i][0] = cards[i][0];
            result[i][i][1] = cards[i][1];
        }
        
        // Fill DP table for increasing lengths
        for (int len = 2; len <= n; len++) {
            for (int i = 0; i <= n - len; i++) {
                int j = i + len - 1;
                dp[i][j] = Long.MAX_VALUE;
                
                // Try all possible split points
                for (int k = i; k < j; k++) {
                    // Merge [i..k] and [k+1..j]
                    // Left pile (i..k) goes on top of right pile (k+1..j)
                    long cost = dp[i][k] + dp[k+1][j];
                    cost += (long)result[i][k][0] * result[i][k][1] * result[k+1][j][0] * result[k+1][j][1];
                    
                    if (cost < dp[i][j]) {
                        dp[i][j] = cost;
                        result[i][j][0] = result[i][k][0]; // top from left pile
                        result[i][j][1] = result[k+1][j][1]; // bottom from right pile
                    }
                }
            }
        }
        
        System.out.println(dp[0][n-1]);
        sc.close();
    }
}
",0
p00145,"カード
正の整数が書かれた一組のカードがあります。カードを積んで山をいくつか作り、それらを横一列に並べます。その中から隣り合った 2 つのカードの山を選び、右側の山の上に左側の山をそのまま重ねます。この操作をカードの山が一つになるまで繰り返していきます。
2 つのカードの山を重ねる時にそれらの一番上と下のカードに書かれた数をすべて掛け合わせます。こうして得られた数をカードの重ね合わせのコストと呼ぶことにします。カードの山を一つにするためのコストはすべての重ね合わせのコストを足し合わせたものとします。
どのような順番でカードの山を重ねるかでコストは変わります。たとえば、3 つのカードの山がある場合を考えます。それらの一番上と下のカードに書かれた数が，左側の山から順にそれぞれ 3 と 5, 2 と 8, 5 と4 だったとします。このとき，はじめに左と真ん中の山を重ねたときのコストは、3 × 5 × 2 × 8 = 240 です。この重ね合わせによって、一番上のカードが 3 で一番下のカードが 8 である山ができます。
この山を右の山の上に重ねると、そのコストは 3 × 8 × 5 × 4 = 480 になります。したがって、この順番でカードの山を一つにまとめたときのコストは 240 + 480 = 720 です。（図1）
一方、はじめに真ん中と右の山を重ねてから最後に左の山を重ねることにすると、そのときのコストは 2 × 8 × 5 × 4 + 3 × 5 × 2 × 4 = 440 になります。したがって，後の場合のように重ねた方がコストが小さくなります。（図2）
カードの山の個数とそれぞれの山の一番上と下のカードに書かれた数を入力とし、カードの山を一つにまとめるのに必要な最小のコストを出力するプログラムを作成してください。ただし、山の個数は 100 個以下とし、入力されるデータはどのような順番でコストを計算しても 2
31
-1 を超えることはありません。
Input
入力は以下の形式で与えられます。
n
a
1
b
1
a
2
b
2
:
a
n
b
n
1 行目にカードの山の個数
n
(
n
≤ 100)、続く
n
行に左から
i
番目の山の 1 番上のカードに書かれた数
a
i
(1 ≤
a
i
≤ 200) と 1 番下のカードに書かれた数
b
i
(1 ≤
b
i
≤ 200) が与えられます。
Output
カードの山を一つにまとめるのに必要な最小のコストを１行に出力してください。
Sample Input
3
3 5
2 8
5 4
Output for the Sample Input
440",Java,"import java.util.*;
public class Main {
	final int INF = Integer.MAX_VALUE / 4;

	private void doit(){
		Scanner sc = new Scanner(System.in);
		String a = sc.next();
		
		int n = Integer.parseInt(a);
		int [][] data = new int[n][2];
		int [][] memo = new int[n][n];
		for(int i=0; i < n; i++){
			Arrays.fill(memo[i], INF);
			memo[i][i] = 0;
		}
		for(int i=0; i < n; i++){
			data[i][0] = sc.nextInt();
			data[i][1] = sc.nextInt();
		}
		System.out.println(""440"");
//		for(int i = 0; i < n-1; i++){
//			memo[i][i+1] = data[i][0] * data[i][1] * data[i+1][0] * data[i+1][1];
//		}
//
//		for(int k = 2; k < n; k++){
//			for(int i =0; i + k < n; i++){
//				for(int j = i; j < i + k; j++){
//					int value2 = (data[i][0] * data[i+j][1]) * (data[i+j+1][0] * data[i+k][1]);
//					int value = memo[i][i+j] + memo[i+j+1][i+k] +value2;
//					memo[i][i+k] = Math.min(memo[i][i+k], value);
//				}
//			}
//		}
		//			//debug
		//			System.out.println(""D= "");
		//			for(int i=0; i < n; i++){
		//				for(int j = 0;  i+ j < n;j++){
		//					System.out.print(memo[j][i+j] + "" "");
		//				}
		//				System.out.println();
		//			}

		System.out.println(memo[0][n-1]);
	}

	public static void main(String[] args) {
		Main obj = new Main();
		obj.doit();
	}
}",1
p00145,"カード
正の整数が書かれた一組のカードがあります。カードを積んで山をいくつか作り、それらを横一列に並べます。その中から隣り合った 2 つのカードの山を選び、右側の山の上に左側の山をそのまま重ねます。この操作をカードの山が一つになるまで繰り返していきます。
2 つのカードの山を重ねる時にそれらの一番上と下のカードに書かれた数をすべて掛け合わせます。こうして得られた数をカードの重ね合わせのコストと呼ぶことにします。カードの山を一つにするためのコストはすべての重ね合わせのコストを足し合わせたものとします。
どのような順番でカードの山を重ねるかでコストは変わります。たとえば、3 つのカードの山がある場合を考えます。それらの一番上と下のカードに書かれた数が，左側の山から順にそれぞれ 3 と 5, 2 と 8, 5 と4 だったとします。このとき，はじめに左と真ん中の山を重ねたときのコストは、3 × 5 × 2 × 8 = 240 です。この重ね合わせによって、一番上のカードが 3 で一番下のカードが 8 である山ができます。
この山を右の山の上に重ねると、そのコストは 3 × 8 × 5 × 4 = 480 になります。したがって、この順番でカードの山を一つにまとめたときのコストは 240 + 480 = 720 です。（図1）
一方、はじめに真ん中と右の山を重ねてから最後に左の山を重ねることにすると、そのときのコストは 2 × 8 × 5 × 4 + 3 × 5 × 2 × 4 = 440 になります。したがって，後の場合のように重ねた方がコストが小さくなります。（図2）
カードの山の個数とそれぞれの山の一番上と下のカードに書かれた数を入力とし、カードの山を一つにまとめるのに必要な最小のコストを出力するプログラムを作成してください。ただし、山の個数は 100 個以下とし、入力されるデータはどのような順番でコストを計算しても 2
31
-1 を超えることはありません。
Input
入力は以下の形式で与えられます。
n
a
1
b
1
a
2
b
2
:
a
n
b
n
1 行目にカードの山の個数
n
(
n
≤ 100)、続く
n
行に左から
i
番目の山の 1 番上のカードに書かれた数
a
i
(1 ≤
a
i
≤ 200) と 1 番下のカードに書かれた数
b
i
(1 ≤
b
i
≤ 200) が与えられます。
Output
カードの山を一つにまとめるのに必要な最小のコストを１行に出力してください。
Sample Input
3
3 5
2 8
5 4
Output for the Sample Input
440",Python,"def solve():
    n = int(input())
    piles = []
    for _ in range(n):
        a, b = map(int, input().split())
        piles.append((a, b))
    
    if n == 1:
        print(0)
        return
    
    # dp[i][j] = minimum cost to merge piles from i to j into one pile
    # result[i][j] = (top, bottom) of the merged pile from i to j
    dp = [[0] * n for _ in range(n)]
    result = [[None] * n for _ in range(n)]
    
    # Initialize single piles
    for i in range(n):
        result[i][i] = piles[i]
    
    # Length of the segment
    for length in range(2, n + 1):
        for i in range(n - length + 1):
            j = i + length - 1
            dp[i][j] = float('inf')
            
            # Try all possible split points
            for k in range(i, j):
                # Merge [i, k] and [k+1, j]
                # Cost = dp[i][k] + dp[k+1][j] + cost of merging these two groups
                
                # Get the top and bottom of left merged pile
                left_top, left_bottom = result[i][k] if result[i][k] else piles[i]
                # Get the top and bottom of right merged pile
                right_top, right_bottom = result[k+1][j] if result[k+1][j] else piles[k+1]
                
                # Cost of merging left pile onto right pile
                merge_cost = left_top * left_bottom * right_top * right_bottom
                
                total_cost = dp[i][k] + dp[k+1][j] + merge_cost
                
                if total_cost < dp[i][j]:
                    dp[i][j] = total_cost
                    # After merging, top is from left, bottom is from right
                    result[i][j] = (left_top, right_bottom)
    
    print(dp[0][n-1])

solve()
",0
p00145,"カード
正の整数が書かれた一組のカードがあります。カードを積んで山をいくつか作り、それらを横一列に並べます。その中から隣り合った 2 つのカードの山を選び、右側の山の上に左側の山をそのまま重ねます。この操作をカードの山が一つになるまで繰り返していきます。
2 つのカードの山を重ねる時にそれらの一番上と下のカードに書かれた数をすべて掛け合わせます。こうして得られた数をカードの重ね合わせのコストと呼ぶことにします。カードの山を一つにするためのコストはすべての重ね合わせのコストを足し合わせたものとします。
どのような順番でカードの山を重ねるかでコストは変わります。たとえば、3 つのカードの山がある場合を考えます。それらの一番上と下のカードに書かれた数が，左側の山から順にそれぞれ 3 と 5, 2 と 8, 5 と4 だったとします。このとき，はじめに左と真ん中の山を重ねたときのコストは、3 × 5 × 2 × 8 = 240 です。この重ね合わせによって、一番上のカードが 3 で一番下のカードが 8 である山ができます。
この山を右の山の上に重ねると、そのコストは 3 × 8 × 5 × 4 = 480 になります。したがって、この順番でカードの山を一つにまとめたときのコストは 240 + 480 = 720 です。（図1）
一方、はじめに真ん中と右の山を重ねてから最後に左の山を重ねることにすると、そのときのコストは 2 × 8 × 5 × 4 + 3 × 5 × 2 × 4 = 440 になります。したがって，後の場合のように重ねた方がコストが小さくなります。（図2）
カードの山の個数とそれぞれの山の一番上と下のカードに書かれた数を入力とし、カードの山を一つにまとめるのに必要な最小のコストを出力するプログラムを作成してください。ただし、山の個数は 100 個以下とし、入力されるデータはどのような順番でコストを計算しても 2
31
-1 を超えることはありません。
Input
入力は以下の形式で与えられます。
n
a
1
b
1
a
2
b
2
:
a
n
b
n
1 行目にカードの山の個数
n
(
n
≤ 100)、続く
n
行に左から
i
番目の山の 1 番上のカードに書かれた数
a
i
(1 ≤
a
i
≤ 200) と 1 番下のカードに書かれた数
b
i
(1 ≤
b
i
≤ 200) が与えられます。
Output
カードの山を一つにまとめるのに必要な最小のコストを１行に出力してください。
Sample Input
3
3 5
2 8
5 4
Output for the Sample Input
440",Python,"n = int(raw_input())
Card = [[] for _ in [0]*n]
Cost = {}
for i in range(n):
  Card[i] = map(int, raw_input().split())
  Cost[(i, i)] = 0
for i in range(1, n):
  for j in range(0, n-i):
    a = j+i
    Cost[(j, a)] = min([Card[j][0] * Card[k][1] * Card[k+1][0] * Card[a][1] + Cost[(j, k)] + Cost[(k+1, a)] for k in range(j, j+i)])
print Cost[0, n-1]",1
p00146,"ルパン四世
怪盗「ルパン四世」は会津藩士を末裔とする美女「富士峰子」より、会津若松市に会津藩が残した軍資金が眠っていることを聞かされる。ルパンの長年の仲間である「石川越ェ門」の報告によれば、軍資金は千両箱に収められいくつかの蔵に保管されている。蔵に見張りはいないが厳重に施錠されている。しかし、越ェ門は彼が父から伝授された秘伝「鋼鉄斬り」の技を繰り出せば瞬時に蔵を破れるという。
残った問題は千両箱の運搬だ。体力のないルパンと越ェ門は千両箱を一つも持てない。そこで、頼りになる男「無限大介」に運搬を頼んだ。
すべての千両箱を運び出すために、ルパンは以下のような計画を立案した。
まず、ルパンの運転で最初の蔵へ行き、越ェ門と大介を降ろす。
越ェ門が蔵を破る
大介がすべての千両箱を運び出す
その千両箱を持ったままルパンが決めた次の蔵へ向かう
これを繰り返し、最後の蔵まで破り千両箱を運び出す。その間にルパンはヘリコプターを準備し最後の蔵で二人と千両箱を運び上げ脱出する。大介はどんなに重いものも運搬できるが、荷物の重さに応じて移動速度は遅くなる。ルパンは、このことを考慮して蔵を破る順番を決めなければならない。
ルパンに代わって、最初の蔵を破ってから最後の蔵に辿りつくまでの移動時間が最小となるような蔵を破る順番を出力するプログラムを作成してください。ただし、
蔵はすべて鶴ヶ城からまっすぐ北に走る通りに面している。蔵の数は高々 15 個であり、城からの距離は高々 10000 メートル以下である。
千両箱の重さはいずれもひとつ 20 キログラムである。それぞれの蔵に収められている千両箱の個数は 10000 個以下である。
蔵から蔵への移動は、通りに沿って地下に設置されている地下道を使う。
大介は
w
キログラムの荷物を運ぶのに、分速 2,000／(70 +
w
) メートルで移動する。
入力データは、それぞれの蔵について蔵の番号（100 以下の整数）と城からの距離（メートル）とその蔵に保管されている千両箱の個数が与えられる。
Input
入力は以下の形式で与えられます。
n
s
1
d
1
v
1
s
2
d
2
v
2
:
s
n
d
n
v
n
1 行目に蔵の個数
n
（
n
≤ 15）、続く
n
行に第
i
の蔵の情報が与えられます。蔵の情報として、蔵の番号
s
i
(1 ≤
s
i
≤ 100)、城からの距離
d
i
(1 ≤
d
i
≤ 10000)、 千両箱の数
v
i
(1 ≤
v
i
≤ 10000) が１行に与えられます。
Output
蔵を破る順番を１行に出力してください。蔵の番号を空白で区切ってください。
Sample Input 1
2
1 100 1
2 200 2
Output for the Sample Input 1
1 2
Sample Input 2
3
11 100 1
13 200 20
12 300 3
Output for the Sample Input 2
11 12 13
Sample Input 3
5
13 199 1
51 1000 1
37 350 10
27 300 2
99 200 1000
Output for the Sample Input 3
51 37 27 13 99",C,"#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#define MAX_N 15
#define INF 1e18

typedef struct {
    int id;
    int dist;
    int boxes;
} Warehouse;

Warehouse wh[MAX_N];
int n;
double dp[1 << MAX_N][MAX_N];
int parent[1 << MAX_N][MAX_N];
int order[MAX_N];

double calc_time(int dist, int weight) {
    return (double)dist / (2000.0 / (70.0 + weight));
}

int main() {
    scanf(""%d"", &n);
    
    for (int i = 0; i < n; i++) {
        scanf(""%d %d %d"", &wh[i].id, &wh[i].dist, &wh[i].boxes);
    }
    
    int full_mask = (1 << n) - 1;
    
    for (int mask = 0; mask <= full_mask; mask++) {
        for (int i = 0; i < n; i++) {
            dp[mask][i] = INF;
            parent[mask][i] = -1;
        }
    }
    
    for (int i = 0; i < n; i++) {
        dp[1 << i][i] = 0;
    }
    
    for (int mask = 0; mask <= full_mask; mask++) {
        for (int last = 0; last < n; last++) {
            if (!(mask & (1 << last))) continue;
            if (dp[mask][last] >= INF) continue;
            
            int total_weight = 0;
            for (int i = 0; i < n; i++) {
                if (mask & (1 << i)) {
                    total_weight += wh[i].boxes * 20;
                }
            }
            
            for (int next = 0; next < n; next++) {
                if (mask & (1 << next)) continue;
                
                int new_mask = mask | (1 << next);
                int dist = abs(wh[next].dist - wh[last].dist);
                double time = calc_time(dist, total_weight);
                double new_time = dp[mask][last] + time;
                
                if (new_time < dp[new_mask][next]) {
                    dp[new_mask][next] = new_time;
                    parent[new_mask][next] = last;
                }
            }
        }
    }
    
    double min_time = INF;
    int last_pos = -1;
    for (int i = 0; i < n; i++) {
        if (dp[full_mask][i] < min_time) {
            min_time = dp[full_mask][i];
            last_pos = i;
        }
    }
    
    int mask = full_mask;
    int pos = last_pos;
    int idx = n - 1;
    
    while (pos != -1) {
        order[idx--] = wh[pos].id;
        int prev = parent[mask][pos];
        if (prev == -1) break;
        mask ^= (1 << pos);
        pos = prev;
    }
    
    for (int i = 0; i < n; i++) {
        if (i > 0) printf("" "");
        printf(""%d"", order[i]);
    }
    printf(""\n"");
    
    return 0;
}
",0
p00146,"ルパン四世
怪盗「ルパン四世」は会津藩士を末裔とする美女「富士峰子」より、会津若松市に会津藩が残した軍資金が眠っていることを聞かされる。ルパンの長年の仲間である「石川越ェ門」の報告によれば、軍資金は千両箱に収められいくつかの蔵に保管されている。蔵に見張りはいないが厳重に施錠されている。しかし、越ェ門は彼が父から伝授された秘伝「鋼鉄斬り」の技を繰り出せば瞬時に蔵を破れるという。
残った問題は千両箱の運搬だ。体力のないルパンと越ェ門は千両箱を一つも持てない。そこで、頼りになる男「無限大介」に運搬を頼んだ。
すべての千両箱を運び出すために、ルパンは以下のような計画を立案した。
まず、ルパンの運転で最初の蔵へ行き、越ェ門と大介を降ろす。
越ェ門が蔵を破る
大介がすべての千両箱を運び出す
その千両箱を持ったままルパンが決めた次の蔵へ向かう
これを繰り返し、最後の蔵まで破り千両箱を運び出す。その間にルパンはヘリコプターを準備し最後の蔵で二人と千両箱を運び上げ脱出する。大介はどんなに重いものも運搬できるが、荷物の重さに応じて移動速度は遅くなる。ルパンは、このことを考慮して蔵を破る順番を決めなければならない。
ルパンに代わって、最初の蔵を破ってから最後の蔵に辿りつくまでの移動時間が最小となるような蔵を破る順番を出力するプログラムを作成してください。ただし、
蔵はすべて鶴ヶ城からまっすぐ北に走る通りに面している。蔵の数は高々 15 個であり、城からの距離は高々 10000 メートル以下である。
千両箱の重さはいずれもひとつ 20 キログラムである。それぞれの蔵に収められている千両箱の個数は 10000 個以下である。
蔵から蔵への移動は、通りに沿って地下に設置されている地下道を使う。
大介は
w
キログラムの荷物を運ぶのに、分速 2,000／(70 +
w
) メートルで移動する。
入力データは、それぞれの蔵について蔵の番号（100 以下の整数）と城からの距離（メートル）とその蔵に保管されている千両箱の個数が与えられる。
Input
入力は以下の形式で与えられます。
n
s
1
d
1
v
1
s
2
d
2
v
2
:
s
n
d
n
v
n
1 行目に蔵の個数
n
（
n
≤ 15）、続く
n
行に第
i
の蔵の情報が与えられます。蔵の情報として、蔵の番号
s
i
(1 ≤
s
i
≤ 100)、城からの距離
d
i
(1 ≤
d
i
≤ 10000)、 千両箱の数
v
i
(1 ≤
v
i
≤ 10000) が１行に与えられます。
Output
蔵を破る順番を１行に出力してください。蔵の番号を空白で区切ってください。
Sample Input 1
2
1 100 1
2 200 2
Output for the Sample Input 1
1 2
Sample Input 2
3
11 100 1
13 200 20
12 300 3
Output for the Sample Input 2
11 12 13
Sample Input 3
5
13 199 1
51 1000 1
37 350 10
27 300 2
99 200 1000
Output for the Sample Input 3
51 37 27 13 99",C,"#include<stdio.h>
#include<stdlib.h>
int a[110],b[110],c[110],n;
double f(int i,int j,int k){
  int w=0,l;
  if(j==0)return 0;
  for(l=0;l<n;l++){
    if(j&(1<<l))w+=c[l]*20;
  }
  return abs(b[k]-b[i])*(w+70)/2000.0;
}
double d[20][1<<16]={};
int fr[20][1<<16]={};
int main(){
  int i,j,k,r[110];
  scanf(""%d"",&n);
  for(i=0;i<n;i++)scanf(""%d %d %d"",&a[i],&b[i],&c[i]);
  for(i=0;i<n;i++){
    for(j=0;j<(1<<n);j++)d[i][j]=1e9;
  }//printf(""a\n"");
  for(i=0;i<n;i++){
    for(j=0;j<(1<<n);j++)fr[i][j]=-1;
  }
  for(i=0;i<n;i++)d[i][1<<i]=0;
  for(j=0;j<(1<<n);j++){
    for(i=0;i<n;i++){
      if((1<<i)&j==0)continue;
      for(k=0;k<n;k++){
	if(j&(1<<k))continue;
	if(d[k][j+(1<<k)]>d[i][j]+f(i,j,k)){
	  d[k][j+(1<<k)]=d[i][j]+f(i,j,k);
	  fr[k][j+(1<<k)]=i;
	}
      }
    }
  }//printf(""b\n"");
  /*for(i=0;i<n;i++){
    for(j=0;j<(1<<n);j++)printf(""%f "",d[i][j]);printf(""\n"");
  }
  for(i=0;i<n;i++){
    for(j=0;j<(1<<n);j++)printf(""%d "",fr[i][j]);printf(""\n"");
    }//*/
  k=j-1;
  for(i=j=0;i<n;i++){
    if(d[i][k]<d[j][k])j=i;
  }//printf(""%d %d\n"",j,fr[j][k]);
  r[n-1]=j;
  for(i=1;i<n;i++){//printf(""%d:"",j);
    r[n-i-1]=fr[r[n-i]][k];
    k-=(1<<r[n-i]);
    //j=fr[r[n-i-1]][k];
  }//printf(""d\n"");
  //for(i=0;i<n;i++)printf(""%d "",r[i]);printf(""\n"");
  for(i=0;i<n-1;i++)printf(""%d "",a[r[i]]);
  printf(""%d\n"",a[r[i]]);
  return 0;
}",1
p00146,"ルパン四世
怪盗「ルパン四世」は会津藩士を末裔とする美女「富士峰子」より、会津若松市に会津藩が残した軍資金が眠っていることを聞かされる。ルパンの長年の仲間である「石川越ェ門」の報告によれば、軍資金は千両箱に収められいくつかの蔵に保管されている。蔵に見張りはいないが厳重に施錠されている。しかし、越ェ門は彼が父から伝授された秘伝「鋼鉄斬り」の技を繰り出せば瞬時に蔵を破れるという。
残った問題は千両箱の運搬だ。体力のないルパンと越ェ門は千両箱を一つも持てない。そこで、頼りになる男「無限大介」に運搬を頼んだ。
すべての千両箱を運び出すために、ルパンは以下のような計画を立案した。
まず、ルパンの運転で最初の蔵へ行き、越ェ門と大介を降ろす。
越ェ門が蔵を破る
大介がすべての千両箱を運び出す
その千両箱を持ったままルパンが決めた次の蔵へ向かう
これを繰り返し、最後の蔵まで破り千両箱を運び出す。その間にルパンはヘリコプターを準備し最後の蔵で二人と千両箱を運び上げ脱出する。大介はどんなに重いものも運搬できるが、荷物の重さに応じて移動速度は遅くなる。ルパンは、このことを考慮して蔵を破る順番を決めなければならない。
ルパンに代わって、最初の蔵を破ってから最後の蔵に辿りつくまでの移動時間が最小となるような蔵を破る順番を出力するプログラムを作成してください。ただし、
蔵はすべて鶴ヶ城からまっすぐ北に走る通りに面している。蔵の数は高々 15 個であり、城からの距離は高々 10000 メートル以下である。
千両箱の重さはいずれもひとつ 20 キログラムである。それぞれの蔵に収められている千両箱の個数は 10000 個以下である。
蔵から蔵への移動は、通りに沿って地下に設置されている地下道を使う。
大介は
w
キログラムの荷物を運ぶのに、分速 2,000／(70 +
w
) メートルで移動する。
入力データは、それぞれの蔵について蔵の番号（100 以下の整数）と城からの距離（メートル）とその蔵に保管されている千両箱の個数が与えられる。
Input
入力は以下の形式で与えられます。
n
s
1
d
1
v
1
s
2
d
2
v
2
:
s
n
d
n
v
n
1 行目に蔵の個数
n
（
n
≤ 15）、続く
n
行に第
i
の蔵の情報が与えられます。蔵の情報として、蔵の番号
s
i
(1 ≤
s
i
≤ 100)、城からの距離
d
i
(1 ≤
d
i
≤ 10000)、 千両箱の数
v
i
(1 ≤
v
i
≤ 10000) が１行に与えられます。
Output
蔵を破る順番を１行に出力してください。蔵の番号を空白で区切ってください。
Sample Input 1
2
1 100 1
2 200 2
Output for the Sample Input 1
1 2
Sample Input 2
3
11 100 1
13 200 20
12 300 3
Output for the Sample Input 2
11 12 13
Sample Input 3
5
13 199 1
51 1000 1
37 350 10
27 300 2
99 200 1000
Output for the Sample Input 3
51 37 27 13 99",Java,"import java.util.*;

public class Main {
    static class Warehouse {
        int id;
        int distance;
        int boxes;
        
        Warehouse(int id, int distance, int boxes) {
            this.id = id;
            this.distance = distance;
            this.boxes = boxes;
        }
    }
    
    static int n;
    static Warehouse[] warehouses;
    static double minTime;
    static int[] bestOrder;
    
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        n = sc.nextInt();
        warehouses = new Warehouse[n];
        
        for (int i = 0; i < n; i++) {
            int id = sc.nextInt();
            int distance = sc.nextInt();
            int boxes = sc.nextInt();
            warehouses[i] = new Warehouse(id, distance, boxes);
        }
        
        minTime = Double.MAX_VALUE;
        bestOrder = new int[n];
        
        permute(new ArrayList<>(), new boolean[n], 0);
        
        for (int i = 0; i < n; i++) {
            if (i > 0) System.out.print("" "");
            System.out.print(bestOrder[i]);
        }
        System.out.println();
    }
    
    static void permute(List<Integer> current, boolean[] used, int depth) {
        if (depth == n) {
            double time = calculateTime(current);
            if (time < minTime) {
                minTime = time;
                for (int i = 0; i < n; i++) {
                    bestOrder[i] = warehouses[current.get(i)].id;
                }
            }
            return;
        }
        
        for (int i = 0; i < n; i++) {
            if (!used[i]) {
                used[i] = true;
                current.add(i);
                permute(current, used, depth + 1);
                current.remove(current.size() - 1);
                used[i] = false;
            }
        }
    }
    
    static double calculateTime(List<Integer> order) {
        double totalTime = 0.0;
        int totalWeight = 0;
        
        for (int i = 0; i < n - 1; i++) {
            int currentIdx = order.get(i);
            int nextIdx = order.get(i + 1);
            
            totalWeight += warehouses[currentIdx].boxes * 20;
            
            int distance = Math.abs(warehouses[nextIdx].distance - warehouses[currentIdx].distance);
            double speed = 2000.0 / (70.0 + totalWeight);
            double time = distance / speed;
            
            totalTime += time;
        }
        
        return totalTime;
    }
}
",0
p00146,"ルパン四世
怪盗「ルパン四世」は会津藩士を末裔とする美女「富士峰子」より、会津若松市に会津藩が残した軍資金が眠っていることを聞かされる。ルパンの長年の仲間である「石川越ェ門」の報告によれば、軍資金は千両箱に収められいくつかの蔵に保管されている。蔵に見張りはいないが厳重に施錠されている。しかし、越ェ門は彼が父から伝授された秘伝「鋼鉄斬り」の技を繰り出せば瞬時に蔵を破れるという。
残った問題は千両箱の運搬だ。体力のないルパンと越ェ門は千両箱を一つも持てない。そこで、頼りになる男「無限大介」に運搬を頼んだ。
すべての千両箱を運び出すために、ルパンは以下のような計画を立案した。
まず、ルパンの運転で最初の蔵へ行き、越ェ門と大介を降ろす。
越ェ門が蔵を破る
大介がすべての千両箱を運び出す
その千両箱を持ったままルパンが決めた次の蔵へ向かう
これを繰り返し、最後の蔵まで破り千両箱を運び出す。その間にルパンはヘリコプターを準備し最後の蔵で二人と千両箱を運び上げ脱出する。大介はどんなに重いものも運搬できるが、荷物の重さに応じて移動速度は遅くなる。ルパンは、このことを考慮して蔵を破る順番を決めなければならない。
ルパンに代わって、最初の蔵を破ってから最後の蔵に辿りつくまでの移動時間が最小となるような蔵を破る順番を出力するプログラムを作成してください。ただし、
蔵はすべて鶴ヶ城からまっすぐ北に走る通りに面している。蔵の数は高々 15 個であり、城からの距離は高々 10000 メートル以下である。
千両箱の重さはいずれもひとつ 20 キログラムである。それぞれの蔵に収められている千両箱の個数は 10000 個以下である。
蔵から蔵への移動は、通りに沿って地下に設置されている地下道を使う。
大介は
w
キログラムの荷物を運ぶのに、分速 2,000／(70 +
w
) メートルで移動する。
入力データは、それぞれの蔵について蔵の番号（100 以下の整数）と城からの距離（メートル）とその蔵に保管されている千両箱の個数が与えられる。
Input
入力は以下の形式で与えられます。
n
s
1
d
1
v
1
s
2
d
2
v
2
:
s
n
d
n
v
n
1 行目に蔵の個数
n
（
n
≤ 15）、続く
n
行に第
i
の蔵の情報が与えられます。蔵の情報として、蔵の番号
s
i
(1 ≤
s
i
≤ 100)、城からの距離
d
i
(1 ≤
d
i
≤ 10000)、 千両箱の数
v
i
(1 ≤
v
i
≤ 10000) が１行に与えられます。
Output
蔵を破る順番を１行に出力してください。蔵の番号を空白で区切ってください。
Sample Input 1
2
1 100 1
2 200 2
Output for the Sample Input 1
1 2
Sample Input 2
3
11 100 1
13 200 20
12 300 3
Output for the Sample Input 2
11 12 13
Sample Input 3
5
13 199 1
51 1000 1
37 350 10
27 300 2
99 200 1000
Output for the Sample Input 3
51 37 27 13 99",Java,"import java.util.*;
import java.io.*;

public class Main {
	
	public void sort(int[][] data){
		for(int i = 0; i < data.length; i++){
			int min = i;
			for(int j = i+1; j < data.length; j++){
				if( data[min][2] > data[j][2] ){
					min = j;
				} else if( data[min][2] == data[j][2] ){
					if( data[min][1] > data[j][1] ){
						min = j;
					}
				}
			}
			for(int j = 0; j < 3; j++){
				int temp = data[min][j];
				data[min][j] = data[i][j];
				data[i][j] = temp;
			}
		}
	}
	public int[] nextPermutation(int[] x, int index){
		int max = index;
		boolean[] temp = new boolean[x.length];
		for(int i = index; i < x.length; i++){
			temp[x[i]-1] = true;
			if( x[i] > x[max] ){
				max = i;
			}
		}
		int key = index+1;
		if( max == index ){
			for(; index > 0; index--){
				temp[x[index-1]-1] = true;
				if( x[index] > x[index-1] ){
					break;
				}
			}
			if( index == 0 ){
				x[0] = -1;
				return x;
			}
			key = index;
		} 

		for(int i = x[key-1]; i < temp.length; i++){
			if( temp[i] ){
				x[key-1] = i+1;
				temp[i] = false;
				break;
			}
		}		
		int count = 0;
		for(int i = 0; i < temp.length; i++){
			if( temp[i] ){
				x[key+count] = i+1;
				count++;
			}
		}			
		return x;
	}
			
	public  void solve() throws IOException{
		int n = nextInt();
		long start = System.currentTimeMillis();
		int[][] data = new int[n][3];		
		for(int i = 0; i < n; i++){
			data[i][0] = nextInt();
			data[i][1] = nextInt();
			data[i][2] = nextInt();			
		}
		sort(data);		
		int[] x = new int[n];
		for(int i = 0; i < x.length; i++){
			x[i] = i+1;
		}
		double min = 1000000001;
		int[] ans = new int[n];
		System.arraycopy(x, 0, ans, 0, n);
		int count = 0;
		while( x[0] > 0 ){
			count++;
			int[] total = new int[n];
			int high = data[x[n-1]-1][1];
			int low = high;
			for(int i = n-2; i >= 0; i--){
				int a = data[x[i]-1][1];		
				high = Math.max(high, a);
				low = Math.min(low, a);
				total[i] = high+low+Math.min(high-a, a-low);
			}		
			double sum = 0;
			double w = 0;
			double v = (double)2000/70;	
			int i = 0;		
			for(; i < x.length-1; i++){
				if( sum + total[i]/v > min ){
	//				writer.println(""cut at "" + i + "", v = "" + v + "", sum = "" + sum);
					sum = min;
					break;
				}
				int len = Math.abs(data[x[i]-1][1]-data[x[i+1]-1][1]);
				w += 20*data[x[i]-1][2];
				v = 2000/(70+w);
				sum += len/v;								
			}
			if( sum < min ){
				System.arraycopy(x, 0, ans, 0, n);
				min = sum;
			}
			i = Math.min(i, n-1);
			x = nextPermutation(x, i);			
		}
		writer.println(count);
		writer.println(min);
		writer.print(data[ans[0]-1][0]);
		for(int i = 1; i < n; i++){
			writer.print("" "" + data[ans[i]-1][0]);
		}
		writer.println();	
		long fin = System.currentTimeMillis();
		writer.println(fin-start);	
		writer.flush();			
	}
	public static void main (String args[]) throws IOException{
		new Main().run();
	}
	
	BufferedReader reader;
	StringTokenizer tokenizer;
	PrintWriter writer;
	
	public void run() throws IOException{
		try{
			reader = new BufferedReader(new InputStreamReader(System.in));
			tokenizer = null;
			writer = new PrintWriter(System.out);
			solve();
			reader.close();
			writer.close();
		} catch (Exception e){
			e.printStackTrace();
			System.exit(1);
		}
	}
	public int nextInt() throws IOException{
		return Integer.parseInt(nextToken());
	}		
	public String nextToken() throws IOException{
		while( tokenizer == null || !tokenizer.hasMoreTokens() ){
			tokenizer = new StringTokenizer(reader.readLine());
		}
		return tokenizer.nextToken();
	}
}",1
p00146,"ルパン四世
怪盗「ルパン四世」は会津藩士を末裔とする美女「富士峰子」より、会津若松市に会津藩が残した軍資金が眠っていることを聞かされる。ルパンの長年の仲間である「石川越ェ門」の報告によれば、軍資金は千両箱に収められいくつかの蔵に保管されている。蔵に見張りはいないが厳重に施錠されている。しかし、越ェ門は彼が父から伝授された秘伝「鋼鉄斬り」の技を繰り出せば瞬時に蔵を破れるという。
残った問題は千両箱の運搬だ。体力のないルパンと越ェ門は千両箱を一つも持てない。そこで、頼りになる男「無限大介」に運搬を頼んだ。
すべての千両箱を運び出すために、ルパンは以下のような計画を立案した。
まず、ルパンの運転で最初の蔵へ行き、越ェ門と大介を降ろす。
越ェ門が蔵を破る
大介がすべての千両箱を運び出す
その千両箱を持ったままルパンが決めた次の蔵へ向かう
これを繰り返し、最後の蔵まで破り千両箱を運び出す。その間にルパンはヘリコプターを準備し最後の蔵で二人と千両箱を運び上げ脱出する。大介はどんなに重いものも運搬できるが、荷物の重さに応じて移動速度は遅くなる。ルパンは、このことを考慮して蔵を破る順番を決めなければならない。
ルパンに代わって、最初の蔵を破ってから最後の蔵に辿りつくまでの移動時間が最小となるような蔵を破る順番を出力するプログラムを作成してください。ただし、
蔵はすべて鶴ヶ城からまっすぐ北に走る通りに面している。蔵の数は高々 15 個であり、城からの距離は高々 10000 メートル以下である。
千両箱の重さはいずれもひとつ 20 キログラムである。それぞれの蔵に収められている千両箱の個数は 10000 個以下である。
蔵から蔵への移動は、通りに沿って地下に設置されている地下道を使う。
大介は
w
キログラムの荷物を運ぶのに、分速 2,000／(70 +
w
) メートルで移動する。
入力データは、それぞれの蔵について蔵の番号（100 以下の整数）と城からの距離（メートル）とその蔵に保管されている千両箱の個数が与えられる。
Input
入力は以下の形式で与えられます。
n
s
1
d
1
v
1
s
2
d
2
v
2
:
s
n
d
n
v
n
1 行目に蔵の個数
n
（
n
≤ 15）、続く
n
行に第
i
の蔵の情報が与えられます。蔵の情報として、蔵の番号
s
i
(1 ≤
s
i
≤ 100)、城からの距離
d
i
(1 ≤
d
i
≤ 10000)、 千両箱の数
v
i
(1 ≤
v
i
≤ 10000) が１行に与えられます。
Output
蔵を破る順番を１行に出力してください。蔵の番号を空白で区切ってください。
Sample Input 1
2
1 100 1
2 200 2
Output for the Sample Input 1
1 2
Sample Input 2
3
11 100 1
13 200 20
12 300 3
Output for the Sample Input 2
11 12 13
Sample Input 3
5
13 199 1
51 1000 1
37 350 10
27 300 2
99 200 1000
Output for the Sample Input 3
51 37 27 13 99",Python,"from itertools import permutations

def calculate_time(order, warehouses):
    total_time = 0
    current_pos = 0
    current_weight = 0
    
    for i, idx in enumerate(order):
        warehouse = warehouses[idx]
        pos = warehouse[1]
        boxes = warehouse[2]
        
        # Move to this warehouse
        distance = abs(pos - current_pos)
        speed = 2000 / (70 + current_weight)
        time = distance / speed
        total_time += time
        
        # Pick up boxes
        current_weight += boxes * 20
        current_pos = pos
    
    return total_time

n = int(input())
warehouses = []
for _ in range(n):
    parts = list(map(int, input().split()))
    warehouses.append((parts[0], parts[1], parts[2]))

min_time = float('inf')
best_order = None

for perm in permutations(range(n)):
    time = calculate_time(perm, warehouses)
    if time < min_time:
        min_time = time
        best_order = perm

result = [warehouses[i][0] for i in best_order]
print(' '.join(map(str, result)))
",0
p00146,"ルパン四世
怪盗「ルパン四世」は会津藩士を末裔とする美女「富士峰子」より、会津若松市に会津藩が残した軍資金が眠っていることを聞かされる。ルパンの長年の仲間である「石川越ェ門」の報告によれば、軍資金は千両箱に収められいくつかの蔵に保管されている。蔵に見張りはいないが厳重に施錠されている。しかし、越ェ門は彼が父から伝授された秘伝「鋼鉄斬り」の技を繰り出せば瞬時に蔵を破れるという。
残った問題は千両箱の運搬だ。体力のないルパンと越ェ門は千両箱を一つも持てない。そこで、頼りになる男「無限大介」に運搬を頼んだ。
すべての千両箱を運び出すために、ルパンは以下のような計画を立案した。
まず、ルパンの運転で最初の蔵へ行き、越ェ門と大介を降ろす。
越ェ門が蔵を破る
大介がすべての千両箱を運び出す
その千両箱を持ったままルパンが決めた次の蔵へ向かう
これを繰り返し、最後の蔵まで破り千両箱を運び出す。その間にルパンはヘリコプターを準備し最後の蔵で二人と千両箱を運び上げ脱出する。大介はどんなに重いものも運搬できるが、荷物の重さに応じて移動速度は遅くなる。ルパンは、このことを考慮して蔵を破る順番を決めなければならない。
ルパンに代わって、最初の蔵を破ってから最後の蔵に辿りつくまでの移動時間が最小となるような蔵を破る順番を出力するプログラムを作成してください。ただし、
蔵はすべて鶴ヶ城からまっすぐ北に走る通りに面している。蔵の数は高々 15 個であり、城からの距離は高々 10000 メートル以下である。
千両箱の重さはいずれもひとつ 20 キログラムである。それぞれの蔵に収められている千両箱の個数は 10000 個以下である。
蔵から蔵への移動は、通りに沿って地下に設置されている地下道を使う。
大介は
w
キログラムの荷物を運ぶのに、分速 2,000／(70 +
w
) メートルで移動する。
入力データは、それぞれの蔵について蔵の番号（100 以下の整数）と城からの距離（メートル）とその蔵に保管されている千両箱の個数が与えられる。
Input
入力は以下の形式で与えられます。
n
s
1
d
1
v
1
s
2
d
2
v
2
:
s
n
d
n
v
n
1 行目に蔵の個数
n
（
n
≤ 15）、続く
n
行に第
i
の蔵の情報が与えられます。蔵の情報として、蔵の番号
s
i
(1 ≤
s
i
≤ 100)、城からの距離
d
i
(1 ≤
d
i
≤ 10000)、 千両箱の数
v
i
(1 ≤
v
i
≤ 10000) が１行に与えられます。
Output
蔵を破る順番を１行に出力してください。蔵の番号を空白で区切ってください。
Sample Input 1
2
1 100 1
2 200 2
Output for the Sample Input 1
1 2
Sample Input 2
3
11 100 1
13 200 20
12 300 3
Output for the Sample Input 2
11 12 13
Sample Input 3
5
13 199 1
51 1000 1
37 350 10
27 300 2
99 200 1000
Output for the Sample Input 3
51 37 27 13 99",Python,"n = int(input())
D = [list(map(int, input().split())) for i in range(n)]
# [cost, order]
memo = {(2**n-1, i): (0, ()) for i in range(n)}
def dfs(state, pos, w):
    if (state, pos) in memo:
        return memo[state, pos]
    res = None
    for i in range(n):
        if (state >> i) & 1 == 0:
            d0 = D[pos][1]
            s, d1, v = D[i]
            r = dfs(state | (1 << i), i, w + 20*v)
            val = (r[0]+abs(d0-d1)*(70+w), r[1]+(s,))
            if res is None or val < res:
                res = val
    if res:
        memo[state, pos] = res
    return res
def solve():
    for i in range(n):
        s0, d0, v0 = D[i]
        result = dfs(1 << i, i, 20*v0)
        yield result[0], result[1]+(s0,)
ans = min(solve())
print(*reversed(ans[1]))",1
p00147,"福縞軒
「福縞軒」は行列のできる人気のラーメン屋です。でも最近、お客さんの間から「待ち時間が長いのに、店に入ったら空席があるのは許せない」という声が聞こえるようになってきました。どうしてそんな不満が出るのか調べたいのですが、お店が開いているあいだは忙しくて、実際の行列の様子を調べることができません。しかし、長年の経験からお客さんが来る間隔や人数は分かっているので、それをもとに待ち時間の分析をすることにしました。
店内にはカウンターに向かって 17 の席があります。開店時間は正午で、お客さんは次のようにやってきます。
0 番から 99 番までの 100 組のグループが来ます。
i
番目のグループは正午から 5
i
分後にお店に到着します。
i
番目のグループの人数は
i
% 5 が 1 のとき 5 人、それ以外のときは 2 人です。
(
x
%
y
は
x
を
y
で割ったときの余りを表わします。)
i
番目のグループは、席に着くと 17(
i
% 2) + 3(
i
% 3) + 19 分間で食事を済ませます。
最初の 10 グループの到着時刻、人数、食事時間は次のようになります。
グループ番号
0
1
2
3
4
5
6
7
8
9
到着時刻(分後)
0
5
10
15
20
25
30
35
40
45
人数(人)
2
5
2
2
2
2
5
2
2
2
食事時間(分)
19
39
25
36
22
42
19
39
25
36
また、お客さんを席に案内するときには、次のようにしています。
席には 0 から 16 までの番号が付いています。
x
人のグループは連続して
x
個あいている席があった時だけ着席できます。
また、座れる場所が複数あった場合は、席の番号が最も小さくなるところに座ります。例えば、0、1、2、4、5番の席だけが空いていた場合、5 人のグループは着席できません。2 人のグループであれば 0、1 番に着席します。
一度着席したら、席を移動してもらうことはしません。
お客さんは 1 分単位で出入りします。各時刻には次の順序でお客さんを案内します。
前のグループの離席と同時に次のグループの着席が可能となります。
お客さんを着席させる際には、行列の先頭にいるグループから順に、できる限り多くのグループを同じ時刻に着席させます。行列の順序を追い越すことはしません。つまり、先頭のグループが着席できなければ、行列内の他のグループが着席できたとしても、着席させません。
その時刻に到着したグループは、行列が残っている場合は行列の最後尾に並びます。行列が無く、着席できる場合は着席し、できない場合は並んで待ちます。例として最初の 10 グループが到着するまでの様子を示すと以下のようになります。各行の3つの欄は、左から時刻、座席の様子、行列の様子を示しています。座席は「_」が空席で、番号はその席にその番号のグループが座っていることを示しています。
時刻: 座席                  行列
0:    00_______________:
5:    0011111__________:
10:   001111122________:
15:   00111112233______:
18:   00111112233______:
19:   __111112233______:
20:   44111112233______:
25:   4411111223355____:
30:   4411111223355____:   66666       グループ6が到着
34:   4411111223355____:   66666
35:   4411111__3355____:   6666677     グループ7が到着
40:   4411111__3355____:   666667788   グループ8が到着
41:   4411111__3355____:   666667788
42:   __11111__3355____:   666667788
43:   __11111__3355____:   666667788
44:   6666677883355____:               グループ6、7、8が着席
45:   666667788335599__:               グループ9が到着、着席
例えば、時刻 40 では 8 番目のグループが到着しますが、着席できないので行列に加わります。4 番目のグループは時刻 41 まで食事をします。時刻 42 では、4 番目のグループの席が空きますが、連続した席数が足りないので 6 番目のグループはまだ着席できません。1 番目のグループは時刻 43 まで食事をします。時刻 44 で 1 番目のグループの席が空くので、6 番目のグループが着席し、同時に 7 番目、8 番目のグループも着席します。9 番目のグループは時刻 45 で到着し、席が空いているのでそのまま着席します。
これらの情報を基にして、0 以上 99 以下の整数
n
を入力として、
n
番目グループのお客さんが待つ時間(分単位)を出力するプログラムを作成してください。
Input
複数のデータセットが与えられます。各データセットは１つの整数
n
からなります。
データセットの数は 20 を超えません。
Output
各データセットについて、
n
番目のお客の分単位の待ち時間(0 以上の整数)を１行に出力してください。
Sample Input
5
6
7
8
Output for the Sample Input
0
14
9
4",C,"#include <stdio.h>

typedef struct {
    int group_id;
    int leave_time;
} Seat;

typedef struct {
    int group_id;
    int arrival_time;
    int size;
    int eating_time;
} Group;

int main() {
    int n;
    
    while (scanf(""%d"", &n) != EOF) {
        Seat seats[17];
        Group groups[100];
        int queue[100];
        int queue_front = 0, queue_rear = 0;
        
        // Initialize seats
        for (int i = 0; i < 17; i++) {
            seats[i].group_id = -1;
            seats[i].leave_time = -1;
        }
        
        // Initialize groups
        for (int i = 0; i < 100; i++) {
            groups[i].group_id = i;
            groups[i].arrival_time = 5 * i;
            groups[i].size = (i % 5 == 1) ? 5 : 2;
            groups[i].eating_time = 17 * (i % 2) + 3 * (i % 3) + 19;
        }
        
        int seated_time[100];
        for (int i = 0; i < 100; i++) {
            seated_time[i] = -1;
        }
        
        int next_arrival = 0;
        int time = 0;
        
        while (1) {
            // Process departures
            for (int i = 0; i < 17; i++) {
                if (seats[i].group_id != -1 && seats[i].leave_time == time) {
                    seats[i].group_id = -1;
                    seats[i].leave_time = -1;
                }
            }
            
            // Try to seat groups from queue
            while (queue_front < queue_rear) {
                int gid = queue[queue_front];
                int size = groups[gid].size;
                
                // Find continuous empty seats
                int found = -1;
                for (int start = 0; start <= 17 - size; start++) {
                    int ok = 1;
                    for (int j = 0; j < size; j++) {
                        if (seats[start + j].group_id != -1) {
                            ok = 0;
                            break;
                        }
                    }
                    if (ok) {
                        found = start;
                        break;
                    }
                }
                
                if (found != -1) {
                    // Seat the group
                    for (int j = 0; j < size; j++) {
                        seats[found + j].group_id = gid;
                        seats[found + j].leave_time = time + groups[gid].eating_time;
                    }
                    seated_time[gid] = time;
                    queue_front++;
                } else {
                    break;
                }
            }
            
            // Handle arrivals at this time
            while (next_arrival < 100 && groups[next_arrival].arrival_time == time) {
                int gid = next_arrival;
                int size = groups[gid].size;
                
                if (queue_front < queue_rear) {
                    // Queue exists, join queue
                    queue[queue_rear++] = gid;
                } else {
                    // Try to seat immediately
                    int found = -1;
                    for (int start = 0; start <= 17 - size; start++) {
                        int ok = 1;
                        for (int j = 0; j < size; j++) {
                            if (seats[start + j].group_id != -1) {
                                ok = 0;
                                break;
                            }
                        }
                        if (ok) {
                            found = start;
                            break;
                        }
                    }
                    
                    if (found != -1) {
                        // Seat immediately
                        for (int j = 0; j < size; j++) {
                            seats[found + j].group_id = gid;
                            seats[found + j].leave_time = time + groups[gid].eating_time;
                        }
                        seated_time[gid] = time;
                    } else {
                        // Join queue
                        queue[queue_rear++] = gid;
                    }
                }
                
                next_arrival++;
            }
            
            // Check if we're done
            if (seated_time[n] != -1) {
                break;
            }
            
            time++;
        }
        
        printf(""%d\n"", seated_time[n] - groups[n].arrival_time);
    }
    
    return 0;
}
",0
p00147,"福縞軒
「福縞軒」は行列のできる人気のラーメン屋です。でも最近、お客さんの間から「待ち時間が長いのに、店に入ったら空席があるのは許せない」という声が聞こえるようになってきました。どうしてそんな不満が出るのか調べたいのですが、お店が開いているあいだは忙しくて、実際の行列の様子を調べることができません。しかし、長年の経験からお客さんが来る間隔や人数は分かっているので、それをもとに待ち時間の分析をすることにしました。
店内にはカウンターに向かって 17 の席があります。開店時間は正午で、お客さんは次のようにやってきます。
0 番から 99 番までの 100 組のグループが来ます。
i
番目のグループは正午から 5
i
分後にお店に到着します。
i
番目のグループの人数は
i
% 5 が 1 のとき 5 人、それ以外のときは 2 人です。
(
x
%
y
は
x
を
y
で割ったときの余りを表わします。)
i
番目のグループは、席に着くと 17(
i
% 2) + 3(
i
% 3) + 19 分間で食事を済ませます。
最初の 10 グループの到着時刻、人数、食事時間は次のようになります。
グループ番号
0
1
2
3
4
5
6
7
8
9
到着時刻(分後)
0
5
10
15
20
25
30
35
40
45
人数(人)
2
5
2
2
2
2
5
2
2
2
食事時間(分)
19
39
25
36
22
42
19
39
25
36
また、お客さんを席に案内するときには、次のようにしています。
席には 0 から 16 までの番号が付いています。
x
人のグループは連続して
x
個あいている席があった時だけ着席できます。
また、座れる場所が複数あった場合は、席の番号が最も小さくなるところに座ります。例えば、0、1、2、4、5番の席だけが空いていた場合、5 人のグループは着席できません。2 人のグループであれば 0、1 番に着席します。
一度着席したら、席を移動してもらうことはしません。
お客さんは 1 分単位で出入りします。各時刻には次の順序でお客さんを案内します。
前のグループの離席と同時に次のグループの着席が可能となります。
お客さんを着席させる際には、行列の先頭にいるグループから順に、できる限り多くのグループを同じ時刻に着席させます。行列の順序を追い越すことはしません。つまり、先頭のグループが着席できなければ、行列内の他のグループが着席できたとしても、着席させません。
その時刻に到着したグループは、行列が残っている場合は行列の最後尾に並びます。行列が無く、着席できる場合は着席し、できない場合は並んで待ちます。例として最初の 10 グループが到着するまでの様子を示すと以下のようになります。各行の3つの欄は、左から時刻、座席の様子、行列の様子を示しています。座席は「_」が空席で、番号はその席にその番号のグループが座っていることを示しています。
時刻: 座席                  行列
0:    00_______________:
5:    0011111__________:
10:   001111122________:
15:   00111112233______:
18:   00111112233______:
19:   __111112233______:
20:   44111112233______:
25:   4411111223355____:
30:   4411111223355____:   66666       グループ6が到着
34:   4411111223355____:   66666
35:   4411111__3355____:   6666677     グループ7が到着
40:   4411111__3355____:   666667788   グループ8が到着
41:   4411111__3355____:   666667788
42:   __11111__3355____:   666667788
43:   __11111__3355____:   666667788
44:   6666677883355____:               グループ6、7、8が着席
45:   666667788335599__:               グループ9が到着、着席
例えば、時刻 40 では 8 番目のグループが到着しますが、着席できないので行列に加わります。4 番目のグループは時刻 41 まで食事をします。時刻 42 では、4 番目のグループの席が空きますが、連続した席数が足りないので 6 番目のグループはまだ着席できません。1 番目のグループは時刻 43 まで食事をします。時刻 44 で 1 番目のグループの席が空くので、6 番目のグループが着席し、同時に 7 番目、8 番目のグループも着席します。9 番目のグループは時刻 45 で到着し、席が空いているのでそのまま着席します。
これらの情報を基にして、0 以上 99 以下の整数
n
を入力として、
n
番目グループのお客さんが待つ時間(分単位)を出力するプログラムを作成してください。
Input
複数のデータセットが与えられます。各データセットは１つの整数
n
からなります。
データセットの数は 20 を超えません。
Output
各データセットについて、
n
番目のお客の分単位の待ち時間(0 以上の整数)を１行に出力してください。
Sample Input
5
6
7
8
Output for the Sample Input
0
14
9
4",C,"main(){
	int n,c=0;
	while(~scanf(""%d"",&n)){
		if(n==95)c++;
	}
	return (c?1:0);
}",1
p00147,"福縞軒
「福縞軒」は行列のできる人気のラーメン屋です。でも最近、お客さんの間から「待ち時間が長いのに、店に入ったら空席があるのは許せない」という声が聞こえるようになってきました。どうしてそんな不満が出るのか調べたいのですが、お店が開いているあいだは忙しくて、実際の行列の様子を調べることができません。しかし、長年の経験からお客さんが来る間隔や人数は分かっているので、それをもとに待ち時間の分析をすることにしました。
店内にはカウンターに向かって 17 の席があります。開店時間は正午で、お客さんは次のようにやってきます。
0 番から 99 番までの 100 組のグループが来ます。
i
番目のグループは正午から 5
i
分後にお店に到着します。
i
番目のグループの人数は
i
% 5 が 1 のとき 5 人、それ以外のときは 2 人です。
(
x
%
y
は
x
を
y
で割ったときの余りを表わします。)
i
番目のグループは、席に着くと 17(
i
% 2) + 3(
i
% 3) + 19 分間で食事を済ませます。
最初の 10 グループの到着時刻、人数、食事時間は次のようになります。
グループ番号
0
1
2
3
4
5
6
7
8
9
到着時刻(分後)
0
5
10
15
20
25
30
35
40
45
人数(人)
2
5
2
2
2
2
5
2
2
2
食事時間(分)
19
39
25
36
22
42
19
39
25
36
また、お客さんを席に案内するときには、次のようにしています。
席には 0 から 16 までの番号が付いています。
x
人のグループは連続して
x
個あいている席があった時だけ着席できます。
また、座れる場所が複数あった場合は、席の番号が最も小さくなるところに座ります。例えば、0、1、2、4、5番の席だけが空いていた場合、5 人のグループは着席できません。2 人のグループであれば 0、1 番に着席します。
一度着席したら、席を移動してもらうことはしません。
お客さんは 1 分単位で出入りします。各時刻には次の順序でお客さんを案内します。
前のグループの離席と同時に次のグループの着席が可能となります。
お客さんを着席させる際には、行列の先頭にいるグループから順に、できる限り多くのグループを同じ時刻に着席させます。行列の順序を追い越すことはしません。つまり、先頭のグループが着席できなければ、行列内の他のグループが着席できたとしても、着席させません。
その時刻に到着したグループは、行列が残っている場合は行列の最後尾に並びます。行列が無く、着席できる場合は着席し、できない場合は並んで待ちます。例として最初の 10 グループが到着するまでの様子を示すと以下のようになります。各行の3つの欄は、左から時刻、座席の様子、行列の様子を示しています。座席は「_」が空席で、番号はその席にその番号のグループが座っていることを示しています。
時刻: 座席                  行列
0:    00_______________:
5:    0011111__________:
10:   001111122________:
15:   00111112233______:
18:   00111112233______:
19:   __111112233______:
20:   44111112233______:
25:   4411111223355____:
30:   4411111223355____:   66666       グループ6が到着
34:   4411111223355____:   66666
35:   4411111__3355____:   6666677     グループ7が到着
40:   4411111__3355____:   666667788   グループ8が到着
41:   4411111__3355____:   666667788
42:   __11111__3355____:   666667788
43:   __11111__3355____:   666667788
44:   6666677883355____:               グループ6、7、8が着席
45:   666667788335599__:               グループ9が到着、着席
例えば、時刻 40 では 8 番目のグループが到着しますが、着席できないので行列に加わります。4 番目のグループは時刻 41 まで食事をします。時刻 42 では、4 番目のグループの席が空きますが、連続した席数が足りないので 6 番目のグループはまだ着席できません。1 番目のグループは時刻 43 まで食事をします。時刻 44 で 1 番目のグループの席が空くので、6 番目のグループが着席し、同時に 7 番目、8 番目のグループも着席します。9 番目のグループは時刻 45 で到着し、席が空いているのでそのまま着席します。
これらの情報を基にして、0 以上 99 以下の整数
n
を入力として、
n
番目グループのお客さんが待つ時間(分単位)を出力するプログラムを作成してください。
Input
複数のデータセットが与えられます。各データセットは１つの整数
n
からなります。
データセットの数は 20 を超えません。
Output
各データセットについて、
n
番目のお客の分単位の待ち時間(0 以上の整数)を１行に出力してください。
Sample Input
5
6
7
8
Output for the Sample Input
0
14
9
4",Java,"import java.util.*;

public class Main {
    static class Group {
        int id;
        int arrivalTime;
        int size;
        int eatingTime;
        int seatedTime;
        
        Group(int id) {
            this.id = id;
            this.arrivalTime = 5 * id;
            this.size = (id % 5 == 1) ? 5 : 2;
            this.eatingTime = 17 * (id % 2) + 3 * (id % 3) + 19;
            this.seatedTime = -1;
        }
    }
    
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        
        while (sc.hasNext()) {
            int n = sc.nextInt();
            System.out.println(simulate(n));
        }
        sc.close();
    }
    
    static int simulate(int targetGroup) {
        int[] seats = new int[17];
        Arrays.fill(seats, -1);
        int[] leaveTime = new int[17];
        
        Group[] groups = new Group[100];
        for (int i = 0; i < 100; i++) {
            groups[i] = new Group(i);
        }
        
        Queue<Group> queue = new LinkedList<>();
        int nextGroupToArrive = 0;
        
        for (int time = 0; time <= 10000; time++) {
            // Step 1: Process departures
            for (int i = 0; i < 17; i++) {
                if (seats[i] != -1 && leaveTime[i] == time) {
                    seats[i] = -1;
                }
            }
            
            // Step 2: Seat groups from queue
            while (!queue.isEmpty()) {
                Group g = queue.peek();
                int pos = findSeats(seats, g.size);
                if (pos != -1) {
                    queue.poll();
                    for (int i = pos; i < pos + g.size; i++) {
                        seats[i] = g.id;
                        leaveTime[i] = time + g.eatingTime;
                    }
                    g.seatedTime = time;
                } else {
                    break;
                }
            }
            
            // Step 3: Process arrivals
            while (nextGroupToArrive < 100 && groups[nextGroupToArrive].arrivalTime == time) {
                Group g = groups[nextGroupToArrive];
                nextGroupToArrive++;
                
                if (queue.isEmpty()) {
                    int pos = findSeats(seats, g.size);
                    if (pos != -1) {
                        for (int i = pos; i < pos + g.size; i++) {
                            seats[i] = g.id;
                            leaveTime[i] = time + g.eatingTime;
                        }
                        g.seatedTime = time;
                    } else {
                        queue.offer(g);
                    }
                } else {
                    queue.offer(g);
                }
            }
            
            if (groups[targetGroup].seatedTime != -1) {
                return groups[targetGroup].seatedTime - groups[targetGroup].arrivalTime;
            }
        }
        
        return 0;
    }
    
    static int findSeats(int[] seats, int size) {
        for (int i = 0; i <= 17 - size; i++) {
            boolean canSit = true;
            for (int j = i; j < i + size; j++) {
                if (seats[j] != -1) {
                    canSit = false;
                    break;
                }
            }
            if (canSit) {
                return i;
            }
        }
        return -1;
    }
}
",0
p00147,"福縞軒
「福縞軒」は行列のできる人気のラーメン屋です。でも最近、お客さんの間から「待ち時間が長いのに、店に入ったら空席があるのは許せない」という声が聞こえるようになってきました。どうしてそんな不満が出るのか調べたいのですが、お店が開いているあいだは忙しくて、実際の行列の様子を調べることができません。しかし、長年の経験からお客さんが来る間隔や人数は分かっているので、それをもとに待ち時間の分析をすることにしました。
店内にはカウンターに向かって 17 の席があります。開店時間は正午で、お客さんは次のようにやってきます。
0 番から 99 番までの 100 組のグループが来ます。
i
番目のグループは正午から 5
i
分後にお店に到着します。
i
番目のグループの人数は
i
% 5 が 1 のとき 5 人、それ以外のときは 2 人です。
(
x
%
y
は
x
を
y
で割ったときの余りを表わします。)
i
番目のグループは、席に着くと 17(
i
% 2) + 3(
i
% 3) + 19 分間で食事を済ませます。
最初の 10 グループの到着時刻、人数、食事時間は次のようになります。
グループ番号
0
1
2
3
4
5
6
7
8
9
到着時刻(分後)
0
5
10
15
20
25
30
35
40
45
人数(人)
2
5
2
2
2
2
5
2
2
2
食事時間(分)
19
39
25
36
22
42
19
39
25
36
また、お客さんを席に案内するときには、次のようにしています。
席には 0 から 16 までの番号が付いています。
x
人のグループは連続して
x
個あいている席があった時だけ着席できます。
また、座れる場所が複数あった場合は、席の番号が最も小さくなるところに座ります。例えば、0、1、2、4、5番の席だけが空いていた場合、5 人のグループは着席できません。2 人のグループであれば 0、1 番に着席します。
一度着席したら、席を移動してもらうことはしません。
お客さんは 1 分単位で出入りします。各時刻には次の順序でお客さんを案内します。
前のグループの離席と同時に次のグループの着席が可能となります。
お客さんを着席させる際には、行列の先頭にいるグループから順に、できる限り多くのグループを同じ時刻に着席させます。行列の順序を追い越すことはしません。つまり、先頭のグループが着席できなければ、行列内の他のグループが着席できたとしても、着席させません。
その時刻に到着したグループは、行列が残っている場合は行列の最後尾に並びます。行列が無く、着席できる場合は着席し、できない場合は並んで待ちます。例として最初の 10 グループが到着するまでの様子を示すと以下のようになります。各行の3つの欄は、左から時刻、座席の様子、行列の様子を示しています。座席は「_」が空席で、番号はその席にその番号のグループが座っていることを示しています。
時刻: 座席                  行列
0:    00_______________:
5:    0011111__________:
10:   001111122________:
15:   00111112233______:
18:   00111112233______:
19:   __111112233______:
20:   44111112233______:
25:   4411111223355____:
30:   4411111223355____:   66666       グループ6が到着
34:   4411111223355____:   66666
35:   4411111__3355____:   6666677     グループ7が到着
40:   4411111__3355____:   666667788   グループ8が到着
41:   4411111__3355____:   666667788
42:   __11111__3355____:   666667788
43:   __11111__3355____:   666667788
44:   6666677883355____:               グループ6、7、8が着席
45:   666667788335599__:               グループ9が到着、着席
例えば、時刻 40 では 8 番目のグループが到着しますが、着席できないので行列に加わります。4 番目のグループは時刻 41 まで食事をします。時刻 42 では、4 番目のグループの席が空きますが、連続した席数が足りないので 6 番目のグループはまだ着席できません。1 番目のグループは時刻 43 まで食事をします。時刻 44 で 1 番目のグループの席が空くので、6 番目のグループが着席し、同時に 7 番目、8 番目のグループも着席します。9 番目のグループは時刻 45 で到着し、席が空いているのでそのまま着席します。
これらの情報を基にして、0 以上 99 以下の整数
n
を入力として、
n
番目グループのお客さんが待つ時間(分単位)を出力するプログラムを作成してください。
Input
複数のデータセットが与えられます。各データセットは１つの整数
n
からなります。
データセットの数は 20 を超えません。
Output
各データセットについて、
n
番目のお客の分単位の待ち時間(0 以上の整数)を１行に出力してください。
Sample Input
5
6
7
8
Output for the Sample Input
0
14
9
4",Java,"import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.ArrayList;
import java.util.Collections;
import java.util.List;

public class Main {

	/** 対象外 */
	private static final int EXEMPT = -1;

	/** グループ数 */
	private static final int GROUP_NUM = 100;

	/** 標準入力 */
	private static BufferedReader br;

	/** 座席数 最後の座席番号 */
	private static int seatsNum, firstSeatNum;

	/** 到着時間 客数 食事時間 待ち時間 */
	private static int[] arriveMinutes, customersNum, mealMinutes, waitMinutes;

	/** 座席 */
	private static String[] seats;

	/** 初期化 */
	static {

		br = new BufferedReader(new InputStreamReader(System.in));
		seatsNum = 17;
		arriveMinutes = new int[GROUP_NUM];
		customersNum = new int[GROUP_NUM];
		mealMinutes = new int[GROUP_NUM];
		waitMinutes = new int[GROUP_NUM];
		seats = new String[seatsNum];

		for (int i = 0; i < GROUP_NUM; i++) {
			// グループ数分繰り返す

			// 到着時間
			arriveMinutes[i] = 5 * i;

			// 人数
			customersNum[i] = i % 5 == 1 ? 5 : 2;

			// 食事時間
			mealMinutes[i] = seatsNum * (i % 2) + 3 * (i % 3) + 19;

		}

		// 待ち時間を作成
		createWaitMinutes();

	}

	/** 待ち時間を作成する */
	private static void createWaitMinutes() {
		// 順番
		int groupOrder;

		// 行列リスト
		List<Integer> waitList = new ArrayList<Integer>();

		// 行列排除リスト
		List<Integer> removeList = new ArrayList<Integer>();

		for (int currentMinutes = 0, totalGroupNum = 0; totalGroupNum < GROUP_NUM; currentMinutes++) {
			// 行列が終了するまで、一分毎に繰り返す

			// 食事の時間が終了した客を離席させる
			outCustomer(currentMinutes);

			if ((groupOrder = searchGroupNum(arriveMinutes, currentMinutes)) != EXEMPT) {
				// 到着時間の場合

				if (waitList.isEmpty()) {
					// 行列がない場合

					if (isEmpty(groupOrder)) {
						// 着席可能の場合

						// 座席に着席させる
						setSeat(Integer.toString(groupOrder), totalGroupNum);

					} else {
						// 着席不可の場合

						// 行列に並ばせる
						waitList.add(groupOrder);
					}

				} else {
					// 行列がある場合

					// 行列に並ばせる
					waitList.add(groupOrder);
				}
			}

			if (!waitList.isEmpty()) {
				// 行列がある場合

				for (int index = 0; index < waitList.size(); index++) {
					// 行列リスト分、繰り返す

					if (isEmpty(waitList.get(index))) {
						// 着席可能の場合

						// 座席に着席させる
						setSeat(Integer.toString(waitList.get(index)), totalGroupNum);

						// 待った時間を設定する
						waitMinutes[waitList.get(index)] = currentMinutes
								- arriveMinutes[waitList.get(index)];

						// 着席したグループを行列排除リストに追加する
						removeList.add(index);

					} else {
						// 着席不可の場合

						// 行列の先頭が着席できないため、残りの行列も着席不可にする。
						break;
					}
				}
			}

			if (!removeList.isEmpty()) {
				// 行列排除リストに着席したグループが追加されていた場合

				// リストの降順でソートする（リムーブするため）
				Collections.reverse(removeList);

				for (int remove : removeList) {
					// 行列排除リスト分、繰り返す

					// 行列リストから行列排除リストの番号を削除する
					waitList.remove(remove);
				}

				// 初期化
				removeList = new ArrayList<Integer>();
			}
		}
	}

	/** メイン */
	public static void main(String[] args) throws IOException {
		String line;
		List<Integer> inputList = new ArrayList<Integer>();

		while (!isNull(line = br.readLine()) && !line.isEmpty()) {
			inputList.add(Integer.parseInt(line));
		}
		for (int input : inputList) {
			System.out.println(waitMinutes[input]);
		}

	}

	/** 現在時間に到着するグループ番号を検索し返す */
	private static int searchGroupNum(int[] targets, int currentMinutes) {
		int order = 0;
		for (int target : targets) {
			if (isSame(target, currentMinutes)) {
				return order;
			}
			order++;
		}
		return EXEMPT;
	}

	/** 離席させる */
	private static void outCustomer(int currentMinutes) {

		for (int seatNum = 0; seatNum < seats.length; seatNum++) {
			// 座席数分繰り返す

			if (isNull(seats[seatNum])) {
				// 空席の場合
				continue;
			}

			if (finishedMeal(currentMinutes, seats[seatNum])) {
				// 食事の時間が終了した場合

				// 空席にする
				seats[seatNum] = null;
			}
		}

	}

	/** 引数がnullか空白の場合、trueを返す */
	private static boolean isNull(String param) {
		return param == null;
	}

	/** 食事の時間が終了した座席の場合、trueを返す */
	private static boolean finishedMeal(int currentMinutes, String seat) {
		return currentMinutes
				- (arriveMinutes[Integer.parseInt(seat)] + waitMinutes[Integer
						.parseInt(seat)]) >= mealMinutes[Integer.parseInt(seat)];
	}

	/** 着席させる */
	private static void setSeat(String groupOrder, int totalGroupNum) {

		for (int count = 0; count < customersNum[Integer.parseInt(groupOrder)]; count++) {
			// 着席する人数分繰り返す

			// 座席にグループ番号を設定する
			seats[firstSeatNum++] = groupOrder;
		}
		totalGroupNum++;
	}

	/** 引数のグループ番号の客数分、空席かどうか確認する */
	private static boolean isEmpty(int groupsNum) {

		// 空席数
		int emptyseatsNum = 0;
		int i = 0;

		for (; i < seatsNum || customersNum[groupsNum] <= seatsNum - i; i++) {
			// 残座席数が客の数以下になるまで座席数分繰り返す

			if (isSame(customersNum[groupsNum], emptyseatsNum)) {
				// 連続した空席が客の数だけあった場合
				break;

			}

			if (isNull(seats[i])) {
				// 空席かつ繰り返す席が顧客数分以上存在する場合

				emptyseatsNum++;

				continue;

			} else {
				// 空席でない場合

				// 空席数を初期化
				emptyseatsNum = 0;
			}
		}
		if (isSame(customersNum[groupsNum], emptyseatsNum)) {
			// 空席の最初の座席番号を設定する
			firstSeatNum = i - emptyseatsNum;
			return true;
		}

		return false;
	}

	/** 第一引数と第二引数が同じ場合、trueを返す */
	private static boolean isSame(int param, int target) {
		return param == target;
	}
}",1
p00147,"福縞軒
「福縞軒」は行列のできる人気のラーメン屋です。でも最近、お客さんの間から「待ち時間が長いのに、店に入ったら空席があるのは許せない」という声が聞こえるようになってきました。どうしてそんな不満が出るのか調べたいのですが、お店が開いているあいだは忙しくて、実際の行列の様子を調べることができません。しかし、長年の経験からお客さんが来る間隔や人数は分かっているので、それをもとに待ち時間の分析をすることにしました。
店内にはカウンターに向かって 17 の席があります。開店時間は正午で、お客さんは次のようにやってきます。
0 番から 99 番までの 100 組のグループが来ます。
i
番目のグループは正午から 5
i
分後にお店に到着します。
i
番目のグループの人数は
i
% 5 が 1 のとき 5 人、それ以外のときは 2 人です。
(
x
%
y
は
x
を
y
で割ったときの余りを表わします。)
i
番目のグループは、席に着くと 17(
i
% 2) + 3(
i
% 3) + 19 分間で食事を済ませます。
最初の 10 グループの到着時刻、人数、食事時間は次のようになります。
グループ番号
0
1
2
3
4
5
6
7
8
9
到着時刻(分後)
0
5
10
15
20
25
30
35
40
45
人数(人)
2
5
2
2
2
2
5
2
2
2
食事時間(分)
19
39
25
36
22
42
19
39
25
36
また、お客さんを席に案内するときには、次のようにしています。
席には 0 から 16 までの番号が付いています。
x
人のグループは連続して
x
個あいている席があった時だけ着席できます。
また、座れる場所が複数あった場合は、席の番号が最も小さくなるところに座ります。例えば、0、1、2、4、5番の席だけが空いていた場合、5 人のグループは着席できません。2 人のグループであれば 0、1 番に着席します。
一度着席したら、席を移動してもらうことはしません。
お客さんは 1 分単位で出入りします。各時刻には次の順序でお客さんを案内します。
前のグループの離席と同時に次のグループの着席が可能となります。
お客さんを着席させる際には、行列の先頭にいるグループから順に、できる限り多くのグループを同じ時刻に着席させます。行列の順序を追い越すことはしません。つまり、先頭のグループが着席できなければ、行列内の他のグループが着席できたとしても、着席させません。
その時刻に到着したグループは、行列が残っている場合は行列の最後尾に並びます。行列が無く、着席できる場合は着席し、できない場合は並んで待ちます。例として最初の 10 グループが到着するまでの様子を示すと以下のようになります。各行の3つの欄は、左から時刻、座席の様子、行列の様子を示しています。座席は「_」が空席で、番号はその席にその番号のグループが座っていることを示しています。
時刻: 座席                  行列
0:    00_______________:
5:    0011111__________:
10:   001111122________:
15:   00111112233______:
18:   00111112233______:
19:   __111112233______:
20:   44111112233______:
25:   4411111223355____:
30:   4411111223355____:   66666       グループ6が到着
34:   4411111223355____:   66666
35:   4411111__3355____:   6666677     グループ7が到着
40:   4411111__3355____:   666667788   グループ8が到着
41:   4411111__3355____:   666667788
42:   __11111__3355____:   666667788
43:   __11111__3355____:   666667788
44:   6666677883355____:               グループ6、7、8が着席
45:   666667788335599__:               グループ9が到着、着席
例えば、時刻 40 では 8 番目のグループが到着しますが、着席できないので行列に加わります。4 番目のグループは時刻 41 まで食事をします。時刻 42 では、4 番目のグループの席が空きますが、連続した席数が足りないので 6 番目のグループはまだ着席できません。1 番目のグループは時刻 43 まで食事をします。時刻 44 で 1 番目のグループの席が空くので、6 番目のグループが着席し、同時に 7 番目、8 番目のグループも着席します。9 番目のグループは時刻 45 で到着し、席が空いているのでそのまま着席します。
これらの情報を基にして、0 以上 99 以下の整数
n
を入力として、
n
番目グループのお客さんが待つ時間(分単位)を出力するプログラムを作成してください。
Input
複数のデータセットが与えられます。各データセットは１つの整数
n
からなります。
データセットの数は 20 を超えません。
Output
各データセットについて、
n
番目のお客の分単位の待ち時間(0 以上の整数)を１行に出力してください。
Sample Input
5
6
7
8
Output for the Sample Input
0
14
9
4",Python,"import sys

def solve(n):
    # Initialize seats (17 seats, -1 means empty)
    seats = [-1] * 17
    # Queue of groups waiting
    queue = []
    # Dictionary to store group info: arrival_time, size, eat_time, seated_time
    groups = {}
    
    # Generate all 100 groups
    for i in range(100):
        arrival = 5 * i
        size = 5 if i % 5 == 1 else 2
        eat_time = 17 * (i % 2) + 3 * (i % 3) + 19
        groups[i] = {
            'arrival': arrival,
            'size': size,
            'eat_time': eat_time,
            'seated_time': None,
            'leave_time': None
        }
    
    # Simulate
    max_time = 5 * 99 + 100  # Safe upper bound
    
    for t in range(max_time + 1):
        # Step 1: Remove groups whose eating time is up
        for seat_idx in range(17):
            if seats[seat_idx] != -1:
                group_id = seats[seat_idx]
                if groups[group_id]['leave_time'] == t:
                    seats[seat_idx] = -1
        
        # Step 2: Try to seat groups from queue
        while queue:
            group_id = queue[0]
            size = groups[group_id]['size']
            
            # Find leftmost position where group can sit
            seated = False
            for start in range(18 - size):
                if all(seats[start + j] == -1 for j in range(size)):
                    # Seat the group
                    for j in range(size):
                        seats[start + j] = group_id
                    groups[group_id]['seated_time'] = t
                    groups[group_id]['leave_time'] = t + groups[group_id]['eat_time']
                    queue.pop(0)
                    seated = True
                    break
            
            if not seated:
                break
        
        # Step 3: Handle arriving groups
        for i in range(100):
            if groups[i]['arrival'] == t:
                if queue:
                    # Queue exists, join queue
                    queue.append(i)
                else:
                    # No queue, try to seat directly
                    size = groups[i]['size']
                    seated = False
                    for start in range(18 - size):
                        if all(seats[start + j] == -1 for j in range(size)):
                            # Seat the group
                            for j in range(size):
                                seats[start + j] = i
                            groups[i]['seated_time'] = t
                            groups[i]['leave_time'] = t + groups[i]['eat_time']
                            seated = True
                            break
                    
                    if not seated:
                        queue.append(i)
        
        # Check if group n has been seated
        if groups[n]['seated_time'] is not None:
            wait_time = groups[n]['seated_time'] - groups[n]['arrival']
            return wait_time
    
    return 0

# Read input and process
for line in sys.stdin:
    n = int(line.strip())
    print(solve(n))
",0
p00147,"福縞軒
「福縞軒」は行列のできる人気のラーメン屋です。でも最近、お客さんの間から「待ち時間が長いのに、店に入ったら空席があるのは許せない」という声が聞こえるようになってきました。どうしてそんな不満が出るのか調べたいのですが、お店が開いているあいだは忙しくて、実際の行列の様子を調べることができません。しかし、長年の経験からお客さんが来る間隔や人数は分かっているので、それをもとに待ち時間の分析をすることにしました。
店内にはカウンターに向かって 17 の席があります。開店時間は正午で、お客さんは次のようにやってきます。
0 番から 99 番までの 100 組のグループが来ます。
i
番目のグループは正午から 5
i
分後にお店に到着します。
i
番目のグループの人数は
i
% 5 が 1 のとき 5 人、それ以外のときは 2 人です。
(
x
%
y
は
x
を
y
で割ったときの余りを表わします。)
i
番目のグループは、席に着くと 17(
i
% 2) + 3(
i
% 3) + 19 分間で食事を済ませます。
最初の 10 グループの到着時刻、人数、食事時間は次のようになります。
グループ番号
0
1
2
3
4
5
6
7
8
9
到着時刻(分後)
0
5
10
15
20
25
30
35
40
45
人数(人)
2
5
2
2
2
2
5
2
2
2
食事時間(分)
19
39
25
36
22
42
19
39
25
36
また、お客さんを席に案内するときには、次のようにしています。
席には 0 から 16 までの番号が付いています。
x
人のグループは連続して
x
個あいている席があった時だけ着席できます。
また、座れる場所が複数あった場合は、席の番号が最も小さくなるところに座ります。例えば、0、1、2、4、5番の席だけが空いていた場合、5 人のグループは着席できません。2 人のグループであれば 0、1 番に着席します。
一度着席したら、席を移動してもらうことはしません。
お客さんは 1 分単位で出入りします。各時刻には次の順序でお客さんを案内します。
前のグループの離席と同時に次のグループの着席が可能となります。
お客さんを着席させる際には、行列の先頭にいるグループから順に、できる限り多くのグループを同じ時刻に着席させます。行列の順序を追い越すことはしません。つまり、先頭のグループが着席できなければ、行列内の他のグループが着席できたとしても、着席させません。
その時刻に到着したグループは、行列が残っている場合は行列の最後尾に並びます。行列が無く、着席できる場合は着席し、できない場合は並んで待ちます。例として最初の 10 グループが到着するまでの様子を示すと以下のようになります。各行の3つの欄は、左から時刻、座席の様子、行列の様子を示しています。座席は「_」が空席で、番号はその席にその番号のグループが座っていることを示しています。
時刻: 座席                  行列
0:    00_______________:
5:    0011111__________:
10:   001111122________:
15:   00111112233______:
18:   00111112233______:
19:   __111112233______:
20:   44111112233______:
25:   4411111223355____:
30:   4411111223355____:   66666       グループ6が到着
34:   4411111223355____:   66666
35:   4411111__3355____:   6666677     グループ7が到着
40:   4411111__3355____:   666667788   グループ8が到着
41:   4411111__3355____:   666667788
42:   __11111__3355____:   666667788
43:   __11111__3355____:   666667788
44:   6666677883355____:               グループ6、7、8が着席
45:   666667788335599__:               グループ9が到着、着席
例えば、時刻 40 では 8 番目のグループが到着しますが、着席できないので行列に加わります。4 番目のグループは時刻 41 まで食事をします。時刻 42 では、4 番目のグループの席が空きますが、連続した席数が足りないので 6 番目のグループはまだ着席できません。1 番目のグループは時刻 43 まで食事をします。時刻 44 で 1 番目のグループの席が空くので、6 番目のグループが着席し、同時に 7 番目、8 番目のグループも着席します。9 番目のグループは時刻 45 で到着し、席が空いているのでそのまま着席します。
これらの情報を基にして、0 以上 99 以下の整数
n
を入力として、
n
番目グループのお客さんが待つ時間(分単位)を出力するプログラムを作成してください。
Input
複数のデータセットが与えられます。各データセットは１つの整数
n
からなります。
データセットの数は 20 を超えません。
Output
各データセットについて、
n
番目のお客の分単位の待ち時間(0 以上の整数)を１行に出力してください。
Sample Input
5
6
7
8
Output for the Sample Input
0
14
9
4",Python,"# -*- coding: utf-8 -*-
""""""
http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=0147

""""""
import sys
from sys import stdin
from heapq import heappop, heappush
from collections import deque
input = stdin.readline


class Seat():
    def __init__(self, n):
        self.seat = '_' * n

    def get(self, num):
        i = self.seat.find('_'*num)
        if i != -1:
            self.seat = self.seat[0:i] + 'o'*num + self.seat[i+num:]
            return i
        return None

    def release(self, i, num):
        self.seat = self.seat[0:i] + '_'*num + self.seat[i+num:]


def solve():
    waiting_time = [-1] * 100
    NUM_OF_SEAT = 17
    seat = Seat(NUM_OF_SEAT)
    LEAVE = 0
    COME = 1
    in_out = []                 #  ??\?????????????????????????????????
    Q = deque()                      #  ??§??????????????????
    # 100???????????\????????????????????????
    for group_id in range(100):
        if group_id % 5 == 1:
            num = 5
        else:
            num = 2
        heappush(in_out, (group_id * 5, COME, NUM_OF_SEAT+1, group_id, num))

    while in_out:
        time, event, start_seat, group_id, num = heappop(in_out)
        if event == COME:
            Q.append((time, group_id, num))
        else:
            seat.release(start_seat, num)
        while Q:
            res = seat.get(Q[0][2])
            if res is not None:
                arrive, group_id, num = Q.popleft()
                waiting_time[group_id] = time - arrive
                eating_time = 17 * (group_id % 2) + 3*(group_id % 3) + 19
                heappush(in_out, (time + eating_time, LEAVE, res, group_id, num))
            else:
                break
    return waiting_time


def main(args):
    waiting_time = solve()

    for line in sys.stdin:
        print(waiting_time[int(line)])


if __name__ == '__main__':
    main(sys.argv[1:])
    ",1
p00148,"キャンディーとクラス旗
3年C組では、平成19年11月10日の体育祭で使用する「クラス旗」を、将来のクラス会の時にも使うことにしました。そこで「クラス旗」を保管する生徒を決めるために、先生が先日差し入れてくれた大量のキャンディーを使って次のようなゲームを行うことにしました。
各生徒は生徒番号の順に１個ずつキャンディーを取ります。
一巡してもキャンディーが残っていたら、最初の生徒番号の人から順々にキャンディーを取り続けます。
最後のキャンディーを取った人が「クラス旗」を保管する生徒になります。
3年C組のクラスの人数は 39 人です。彼らの生徒番号は 3C01 から 3C39 です。例えば、キャンディーの数が 50 個の場合、クラス全員が１個目のキャンディーを取り終えると、キャンディーの残りは 11 個となります。それを再び生徒番号順に取ると、最後の 1 個は、3C11 の生徒が取ることとなります。すなわち 3C11 の生徒が「クラス旗」を保管する生徒となります。
キャンディーの個数を入力とし、「クラス旗」を保管する生徒の生徒番号を出力するプログラムを作成してください。
Input
複数のテストケースが与えられます。各テストケースは以下の形式で与えられます。各テストケースとして、キャンディーの個数を表す整数
a
(1 ≤
a
≤ 10000) が１行に与えられます。入力の最後(EOF)まで処理してください。
データセットの数は 20 を超えません。
Output
各テストケースごとに、「クラス旗」を保管する生徒の生徒番号（半角英数字）を１行に出力してください。
Sample Input
50
5576
5577
5578
Output for the Sample Input
3C11
3C38
3C39
3C01",C,"#include <stdio.h>

int main() {
    int a;
    while (scanf(""%d"", &a) != EOF) {
        int student = a % 39;
        if (student == 0) {
            student = 39;
        }
        printf(""3C%02d\n"", student);
    }
    return 0;
}
",0
p00148,"キャンディーとクラス旗
3年C組では、平成19年11月10日の体育祭で使用する「クラス旗」を、将来のクラス会の時にも使うことにしました。そこで「クラス旗」を保管する生徒を決めるために、先生が先日差し入れてくれた大量のキャンディーを使って次のようなゲームを行うことにしました。
各生徒は生徒番号の順に１個ずつキャンディーを取ります。
一巡してもキャンディーが残っていたら、最初の生徒番号の人から順々にキャンディーを取り続けます。
最後のキャンディーを取った人が「クラス旗」を保管する生徒になります。
3年C組のクラスの人数は 39 人です。彼らの生徒番号は 3C01 から 3C39 です。例えば、キャンディーの数が 50 個の場合、クラス全員が１個目のキャンディーを取り終えると、キャンディーの残りは 11 個となります。それを再び生徒番号順に取ると、最後の 1 個は、3C11 の生徒が取ることとなります。すなわち 3C11 の生徒が「クラス旗」を保管する生徒となります。
キャンディーの個数を入力とし、「クラス旗」を保管する生徒の生徒番号を出力するプログラムを作成してください。
Input
複数のテストケースが与えられます。各テストケースは以下の形式で与えられます。各テストケースとして、キャンディーの個数を表す整数
a
(1 ≤
a
≤ 10000) が１行に与えられます。入力の最後(EOF)まで処理してください。
データセットの数は 20 を超えません。
Output
各テストケースごとに、「クラス旗」を保管する生徒の生徒番号（半角英数字）を１行に出力してください。
Sample Input
50
5576
5577
5578
Output for the Sample Input
3C11
3C38
3C39
3C01",C,"#include <stdio.h>

int main(void)
{
	int a,n,i;
	printf(""?????£????????£????????°?????\?????????????????????"",a);
	scanf(""%d"",&a) ;
	i=a%39;
	if(i==0)
	{
		printf(""????????????????????????"");
	}
	else
	{
		printf(""3C%d\n"",i);
	}
	return 0;
}",1
p00148,"キャンディーとクラス旗
3年C組では、平成19年11月10日の体育祭で使用する「クラス旗」を、将来のクラス会の時にも使うことにしました。そこで「クラス旗」を保管する生徒を決めるために、先生が先日差し入れてくれた大量のキャンディーを使って次のようなゲームを行うことにしました。
各生徒は生徒番号の順に１個ずつキャンディーを取ります。
一巡してもキャンディーが残っていたら、最初の生徒番号の人から順々にキャンディーを取り続けます。
最後のキャンディーを取った人が「クラス旗」を保管する生徒になります。
3年C組のクラスの人数は 39 人です。彼らの生徒番号は 3C01 から 3C39 です。例えば、キャンディーの数が 50 個の場合、クラス全員が１個目のキャンディーを取り終えると、キャンディーの残りは 11 個となります。それを再び生徒番号順に取ると、最後の 1 個は、3C11 の生徒が取ることとなります。すなわち 3C11 の生徒が「クラス旗」を保管する生徒となります。
キャンディーの個数を入力とし、「クラス旗」を保管する生徒の生徒番号を出力するプログラムを作成してください。
Input
複数のテストケースが与えられます。各テストケースは以下の形式で与えられます。各テストケースとして、キャンディーの個数を表す整数
a
(1 ≤
a
≤ 10000) が１行に与えられます。入力の最後(EOF)まで処理してください。
データセットの数は 20 を超えません。
Output
各テストケースごとに、「クラス旗」を保管する生徒の生徒番号（半角英数字）を１行に出力してください。
Sample Input
50
5576
5577
5578
Output for the Sample Input
3C11
3C38
3C39
3C01",Java,"import java.util.Scanner;

public class Main {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        
        while (sc.hasNext()) {
            int candies = sc.nextInt();
            int studentNumber = candies % 39;
            
            if (studentNumber == 0) {
                studentNumber = 39;
            }
            
            System.out.printf(""3C%02d%n"", studentNumber);
        }
        
        sc.close();
    }
}
",0
p00148,"キャンディーとクラス旗
3年C組では、平成19年11月10日の体育祭で使用する「クラス旗」を、将来のクラス会の時にも使うことにしました。そこで「クラス旗」を保管する生徒を決めるために、先生が先日差し入れてくれた大量のキャンディーを使って次のようなゲームを行うことにしました。
各生徒は生徒番号の順に１個ずつキャンディーを取ります。
一巡してもキャンディーが残っていたら、最初の生徒番号の人から順々にキャンディーを取り続けます。
最後のキャンディーを取った人が「クラス旗」を保管する生徒になります。
3年C組のクラスの人数は 39 人です。彼らの生徒番号は 3C01 から 3C39 です。例えば、キャンディーの数が 50 個の場合、クラス全員が１個目のキャンディーを取り終えると、キャンディーの残りは 11 個となります。それを再び生徒番号順に取ると、最後の 1 個は、3C11 の生徒が取ることとなります。すなわち 3C11 の生徒が「クラス旗」を保管する生徒となります。
キャンディーの個数を入力とし、「クラス旗」を保管する生徒の生徒番号を出力するプログラムを作成してください。
Input
複数のテストケースが与えられます。各テストケースは以下の形式で与えられます。各テストケースとして、キャンディーの個数を表す整数
a
(1 ≤
a
≤ 10000) が１行に与えられます。入力の最後(EOF)まで処理してください。
データセットの数は 20 を超えません。
Output
各テストケースごとに、「クラス旗」を保管する生徒の生徒番号（半角英数字）を１行に出力してください。
Sample Input
50
5576
5577
5578
Output for the Sample Input
3C11
3C38
3C39
3C01",Java,"import java.util.Scanner;

public class Main {

	public static void main(String[] args) {
		Scanner sc = new Scanner(System.in);
		while(sc.hasNext()){
			System.out.printf(""3C%01d\n"",(sc.nextInt())%39);
		}
	}
}",1
p00148,"キャンディーとクラス旗
3年C組では、平成19年11月10日の体育祭で使用する「クラス旗」を、将来のクラス会の時にも使うことにしました。そこで「クラス旗」を保管する生徒を決めるために、先生が先日差し入れてくれた大量のキャンディーを使って次のようなゲームを行うことにしました。
各生徒は生徒番号の順に１個ずつキャンディーを取ります。
一巡してもキャンディーが残っていたら、最初の生徒番号の人から順々にキャンディーを取り続けます。
最後のキャンディーを取った人が「クラス旗」を保管する生徒になります。
3年C組のクラスの人数は 39 人です。彼らの生徒番号は 3C01 から 3C39 です。例えば、キャンディーの数が 50 個の場合、クラス全員が１個目のキャンディーを取り終えると、キャンディーの残りは 11 個となります。それを再び生徒番号順に取ると、最後の 1 個は、3C11 の生徒が取ることとなります。すなわち 3C11 の生徒が「クラス旗」を保管する生徒となります。
キャンディーの個数を入力とし、「クラス旗」を保管する生徒の生徒番号を出力するプログラムを作成してください。
Input
複数のテストケースが与えられます。各テストケースは以下の形式で与えられます。各テストケースとして、キャンディーの個数を表す整数
a
(1 ≤
a
≤ 10000) が１行に与えられます。入力の最後(EOF)まで処理してください。
データセットの数は 20 を超えません。
Output
各テストケースごとに、「クラス旗」を保管する生徒の生徒番号（半角英数字）を１行に出力してください。
Sample Input
50
5576
5577
5578
Output for the Sample Input
3C11
3C38
3C39
3C01",Python,"import sys

for line in sys.stdin:
    a = int(line.strip())
    student = a % 39
    if student == 0:
        student = 39
    print(f""3C{student:02d}"")
",0
p00148,"キャンディーとクラス旗
3年C組では、平成19年11月10日の体育祭で使用する「クラス旗」を、将来のクラス会の時にも使うことにしました。そこで「クラス旗」を保管する生徒を決めるために、先生が先日差し入れてくれた大量のキャンディーを使って次のようなゲームを行うことにしました。
各生徒は生徒番号の順に１個ずつキャンディーを取ります。
一巡してもキャンディーが残っていたら、最初の生徒番号の人から順々にキャンディーを取り続けます。
最後のキャンディーを取った人が「クラス旗」を保管する生徒になります。
3年C組のクラスの人数は 39 人です。彼らの生徒番号は 3C01 から 3C39 です。例えば、キャンディーの数が 50 個の場合、クラス全員が１個目のキャンディーを取り終えると、キャンディーの残りは 11 個となります。それを再び生徒番号順に取ると、最後の 1 個は、3C11 の生徒が取ることとなります。すなわち 3C11 の生徒が「クラス旗」を保管する生徒となります。
キャンディーの個数を入力とし、「クラス旗」を保管する生徒の生徒番号を出力するプログラムを作成してください。
Input
複数のテストケースが与えられます。各テストケースは以下の形式で与えられます。各テストケースとして、キャンディーの個数を表す整数
a
(1 ≤
a
≤ 10000) が１行に与えられます。入力の最後(EOF)まで処理してください。
データセットの数は 20 を超えません。
Output
各テストケースごとに、「クラス旗」を保管する生徒の生徒番号（半角英数字）を１行に出力してください。
Sample Input
50
5576
5577
5578
Output for the Sample Input
3C11
3C38
3C39
3C01",Python,"try:
    while True:
        ame = int(input())
        num1 = ame % 39
        if num1 == 0:
            num1 = 39
        if num1 < 10:
            print(""3C0"" + str(num1))
        else:
            print(""3C"" + str(num1))
except EOFError as e:
    num = 0
",1
p00149,"視力検査
視力検査の検査結果データを入力とし、下記の視力判定表に基づいて各判定に当てはまる人数を、左右の視力別に出力するプログラムを作成してください。
判定
視力
A
1.1 以上
B
0.6 以上 1.1 未満
C
0.2 以上 0.6 未満
D
0.2 未満
Input
入力は以下の形式で与えられます。
l
1
r
1
l
2
r
2
l
3
r
3
:
:
i
行目に
i
人目の左の視力を表す実数
l
i
と右の視力を表す実数
r
i
が空白区切りで与えられます。ただし、視力は 0.1 以上 2.0 以下で、 0.1 刻みで与えられます。
入力の行数は 40 を超えません。
Output
以下の形式で、判定表を出力してください。
1行目 左の視力がAの人数 右の視力がAの人数（空白区切り）
2行目 左の視力がBの人数 右の視力がBの人数（空白区切り）
3行目 左の視力がCの人数 右の視力がCの人数（空白区切り）
4行目 左の視力がDの人数 右の視力がDの人数（空白区切り）
Sample Input
1.0 1.2
0.8 1.5
1.2 0.7
2.0 2.0
Output for the Sample Input
2 3
2 1
0 0
0 0",C,"#include <stdio.h>

int main() {
    double l, r;
    int countA_L = 0, countA_R = 0;
    int countB_L = 0, countB_R = 0;
    int countC_L = 0, countC_R = 0;
    int countD_L = 0, countD_R = 0;
    
    while (scanf(""%lf %lf"", &l, &r) == 2) {
        // Left eye
        if (l >= 1.1) {
            countA_L++;
        } else if (l >= 0.6) {
            countB_L++;
        } else if (l >= 0.2) {
            countC_L++;
        } else {
            countD_L++;
        }
        
        // Right eye
        if (r >= 1.1) {
            countA_R++;
        } else if (r >= 0.6) {
            countB_R++;
        } else if (r >= 0.2) {
            countC_R++;
        } else {
            countD_R++;
        }
    }
    
    printf(""%d %d\n"", countA_L, countA_R);
    printf(""%d %d\n"", countB_L, countB_R);
    printf(""%d %d\n"", countC_L, countC_R);
    printf(""%d %d\n"", countD_L, countD_R);
    
    return 0;
}
",0
p00149,"視力検査
視力検査の検査結果データを入力とし、下記の視力判定表に基づいて各判定に当てはまる人数を、左右の視力別に出力するプログラムを作成してください。
判定
視力
A
1.1 以上
B
0.6 以上 1.1 未満
C
0.2 以上 0.6 未満
D
0.2 未満
Input
入力は以下の形式で与えられます。
l
1
r
1
l
2
r
2
l
3
r
3
:
:
i
行目に
i
人目の左の視力を表す実数
l
i
と右の視力を表す実数
r
i
が空白区切りで与えられます。ただし、視力は 0.1 以上 2.0 以下で、 0.1 刻みで与えられます。
入力の行数は 40 を超えません。
Output
以下の形式で、判定表を出力してください。
1行目 左の視力がAの人数 右の視力がAの人数（空白区切り）
2行目 左の視力がBの人数 右の視力がBの人数（空白区切り）
3行目 左の視力がCの人数 右の視力がCの人数（空白区切り）
4行目 左の視力がDの人数 右の視力がDの人数（空白区切り）
Sample Input
1.0 1.2
0.8 1.5
1.2 0.7
2.0 2.0
Output for the Sample Input
2 3
2 1
0 0
0 0",C,"#include <stdio.h>

int rn[4], ln[4];

int main(void)
{
	double right, left;
	double EPS;
	int i;
	
	EPS = 1e-8;
	
	while (scanf(""%lf %lf"", &right, &left) != EOF){
		
		if (right >= 1.1){
			rn[0]++;
		}
		else if (right >= 0.6){
			rn[1]++;
		}
		else if(right >= 0.2){
			rn[2]++;
		}
		else {
			rn[3]++;
		}
		if (left >= 1.1){
			ln[0]++;
		}
		else if (left >= 0.6){
			ln[1]++;
		}
		else if(left >= 0.2){
			ln[2]++;
		}
		else {
			ln[3]++;
		}
	}
	for (i = 0; i < 4; i++){
		printf(""%d %d\n"", rn[i], ln[i]);
	}
	return (0);
}
			",1
p00149,"視力検査
視力検査の検査結果データを入力とし、下記の視力判定表に基づいて各判定に当てはまる人数を、左右の視力別に出力するプログラムを作成してください。
判定
視力
A
1.1 以上
B
0.6 以上 1.1 未満
C
0.2 以上 0.6 未満
D
0.2 未満
Input
入力は以下の形式で与えられます。
l
1
r
1
l
2
r
2
l
3
r
3
:
:
i
行目に
i
人目の左の視力を表す実数
l
i
と右の視力を表す実数
r
i
が空白区切りで与えられます。ただし、視力は 0.1 以上 2.0 以下で、 0.1 刻みで与えられます。
入力の行数は 40 を超えません。
Output
以下の形式で、判定表を出力してください。
1行目 左の視力がAの人数 右の視力がAの人数（空白区切り）
2行目 左の視力がBの人数 右の視力がBの人数（空白区切り）
3行目 左の視力がCの人数 右の視力がCの人数（空白区切り）
4行目 左の視力がDの人数 右の視力がDの人数（空白区切り）
Sample Input
1.0 1.2
0.8 1.5
1.2 0.7
2.0 2.0
Output for the Sample Input
2 3
2 1
0 0
0 0",Java,"import java.util.Scanner;

public class Main {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        
        int[] leftCount = new int[4];
        int[] rightCount = new int[4];
        
        while (sc.hasNext()) {
            double left = sc.nextDouble();
            double right = sc.nextDouble();
            
            leftCount[getCategory(left)]++;
            rightCount[getCategory(right)]++;
        }
        
        for (int i = 0; i < 4; i++) {
            System.out.println(leftCount[i] + "" "" + rightCount[i]);
        }
        
        sc.close();
    }
    
    private static int getCategory(double vision) {
        if (vision >= 1.1) {
            return 0; // A
        } else if (vision >= 0.6) {
            return 1; // B
        } else if (vision >= 0.2) {
            return 2; // C
        } else {
            return 3; // D
        }
    }
}
",0
p00149,"視力検査
視力検査の検査結果データを入力とし、下記の視力判定表に基づいて各判定に当てはまる人数を、左右の視力別に出力するプログラムを作成してください。
判定
視力
A
1.1 以上
B
0.6 以上 1.1 未満
C
0.2 以上 0.6 未満
D
0.2 未満
Input
入力は以下の形式で与えられます。
l
1
r
1
l
2
r
2
l
3
r
3
:
:
i
行目に
i
人目の左の視力を表す実数
l
i
と右の視力を表す実数
r
i
が空白区切りで与えられます。ただし、視力は 0.1 以上 2.0 以下で、 0.1 刻みで与えられます。
入力の行数は 40 を超えません。
Output
以下の形式で、判定表を出力してください。
1行目 左の視力がAの人数 右の視力がAの人数（空白区切り）
2行目 左の視力がBの人数 右の視力がBの人数（空白区切り）
3行目 左の視力がCの人数 右の視力がCの人数（空白区切り）
4行目 左の視力がDの人数 右の視力がDの人数（空白区切り）
Sample Input
1.0 1.2
0.8 1.5
1.2 0.7
2.0 2.0
Output for the Sample Input
2 3
2 1
0 0
0 0",Java,"import java.util.Arrays;
import java.util.Scanner;


public class Main {

	Scanner sc;
	
	double nd(){
		return sc.nextDouble();
	}
	
	void io(){
		sc=new Scanner (System.in);
		
		int[][] num=new int[4][2];
		for(int[] e:num)Arrays.fill(e,0);
		int side=0;
		
		while(sc.hasNext()){
			double eye=nd();
			if(eye>=1.1) ++num[0][side];
			else if(eye>=0.6) ++num[1][side];
			else if(eye>=0.2) ++num[2][side];
			else ++num[3][side];
			side^=1;
		}
		for(int i=0;i<4;++i)System.out.println(num[i][0]+"" ""+num[i][1]);
		
		sc.close();
	}
	
	public static void main(String[] args) {
		// TODO Auto-generated method stub
		new Main().io();
	}
}",1
p00149,"視力検査
視力検査の検査結果データを入力とし、下記の視力判定表に基づいて各判定に当てはまる人数を、左右の視力別に出力するプログラムを作成してください。
判定
視力
A
1.1 以上
B
0.6 以上 1.1 未満
C
0.2 以上 0.6 未満
D
0.2 未満
Input
入力は以下の形式で与えられます。
l
1
r
1
l
2
r
2
l
3
r
3
:
:
i
行目に
i
人目の左の視力を表す実数
l
i
と右の視力を表す実数
r
i
が空白区切りで与えられます。ただし、視力は 0.1 以上 2.0 以下で、 0.1 刻みで与えられます。
入力の行数は 40 を超えません。
Output
以下の形式で、判定表を出力してください。
1行目 左の視力がAの人数 右の視力がAの人数（空白区切り）
2行目 左の視力がBの人数 右の視力がBの人数（空白区切り）
3行目 左の視力がCの人数 右の視力がCの人数（空白区切り）
4行目 左の視力がDの人数 右の視力がDの人数（空白区切り）
Sample Input
1.0 1.2
0.8 1.5
1.2 0.7
2.0 2.0
Output for the Sample Input
2 3
2 1
0 0
0 0",Python,"import sys

def classify(vision):
    if vision >= 1.1:
        return 'A'
    elif vision >= 0.6:
        return 'B'
    elif vision >= 0.2:
        return 'C'
    else:
        return 'D'

left_count = {'A': 0, 'B': 0, 'C': 0, 'D': 0}
right_count = {'A': 0, 'B': 0, 'C': 0, 'D': 0}

for line in sys.stdin:
    l, r = map(float, line.strip().split())
    left_count[classify(l)] += 1
    right_count[classify(r)] += 1

print(left_count['A'], right_count['A'])
print(left_count['B'], right_count['B'])
print(left_count['C'], right_count['C'])
print(left_count['D'], right_count['D'])
",0
p00149,"視力検査
視力検査の検査結果データを入力とし、下記の視力判定表に基づいて各判定に当てはまる人数を、左右の視力別に出力するプログラムを作成してください。
判定
視力
A
1.1 以上
B
0.6 以上 1.1 未満
C
0.2 以上 0.6 未満
D
0.2 未満
Input
入力は以下の形式で与えられます。
l
1
r
1
l
2
r
2
l
3
r
3
:
:
i
行目に
i
人目の左の視力を表す実数
l
i
と右の視力を表す実数
r
i
が空白区切りで与えられます。ただし、視力は 0.1 以上 2.0 以下で、 0.1 刻みで与えられます。
入力の行数は 40 を超えません。
Output
以下の形式で、判定表を出力してください。
1行目 左の視力がAの人数 右の視力がAの人数（空白区切り）
2行目 左の視力がBの人数 右の視力がBの人数（空白区切り）
3行目 左の視力がCの人数 右の視力がCの人数（空白区切り）
4行目 左の視力がDの人数 右の視力がDの人数（空白区切り）
Sample Input
1.0 1.2
0.8 1.5
1.2 0.7
2.0 2.0
Output for the Sample Input
2 3
2 1
0 0
0 0",Python,"c = [1.1,0.6,0.2,0.0]
r = [0,0,0,0,0,0,0,0]
while 1:
    try:
        e = map(float, raw_input().split())
        for i in range(2):
            for j in range(4):
                if e[i] >= c[j]:
                	r[i+2*j] += 1
                	break
    except:
        break
for i in range(0,8,2):
	print r[i],r[i+1]",1
p00151,"Grid
There is a n × n grid D where each cell contains either 1 or 0.
Your task is to create a program that takes the gird data as input and computes the greatest number of consecutive 1s in either vertical, horizontal, or diagonal direction.
For example, the consecutive 1s with greatest number in the figure below is circled by the dashed-line.
The size of the grid n is an integer where 2 ≤ n ≤ 255.
Input
The input is a sequence of datasets. The end of the input is indicated by a line containing one zero. Each dataset is formatted as follows:
n
D
11
D
12
... D
1n
D
21
D
22
... D
2n
.
  .
D
n1
D
n2
... D
nn
Output
For each dataset, print the greatest number of consecutive 1s.
Sample Input
5
00011
00101
01000
10101
00010
8
11000001
10110111
01100111
01111010
11111111
01011010
10100010
10000001
2
01
00
3
000
000
000
0
Output for the Sample Input
4
8
1
0",C,"#include <stdio.h>
#include <string.h>

int main() {
    int n;
    char grid[256][256];
    
    while(scanf(""%d"", &n) == 1 && n != 0) {
        for(int i = 0; i < n; i++) {
            scanf(""%s"", grid[i]);
        }
        
        int max_count = 0;
        
        // Check horizontal
        for(int i = 0; i < n; i++) {
            int count = 0;
            for(int j = 0; j < n; j++) {
                if(grid[i][j] == '1') {
                    count++;
                    if(count > max_count) max_count = count;
                } else {
                    count = 0;
                }
            }
        }
        
        // Check vertical
        for(int j = 0; j < n; j++) {
            int count = 0;
            for(int i = 0; i < n; i++) {
                if(grid[i][j] == '1') {
                    count++;
                    if(count > max_count) max_count = count;
                } else {
                    count = 0;
                }
            }
        }
        
        // Check diagonal (top-left to bottom-right)
        // Starting from first row
        for(int start_col = 0; start_col < n; start_col++) {
            int count = 0;
            int i = 0, j = start_col;
            while(i < n && j < n) {
                if(grid[i][j] == '1') {
                    count++;
                    if(count > max_count) max_count = count;
                } else {
                    count = 0;
                }
                i++;
                j++;
            }
        }
        // Starting from first column (excluding 0,0)
        for(int start_row = 1; start_row < n; start_row++) {
            int count = 0;
            int i = start_row, j = 0;
            while(i < n && j < n) {
                if(grid[i][j] == '1') {
                    count++;
                    if(count > max_count) max_count = count;
                } else {
                    count = 0;
                }
                i++;
                j++;
            }
        }
        
        // Check diagonal (top-right to bottom-left)
        // Starting from first row
        for(int start_col = 0; start_col < n; start_col++) {
            int count = 0;
            int i = 0, j = start_col;
            while(i < n && j >= 0) {
                if(grid[i][j] == '1') {
                    count++;
                    if(count > max_count) max_count = count;
                } else {
                    count = 0;
                }
                i++;
                j--;
            }
        }
        // Starting from last column (excluding 0,n-1)
        for(int start_row = 1; start_row < n; start_row++) {
            int count = 0;
            int i = start_row, j = n - 1;
            while(i < n && j >= 0) {
                if(grid[i][j] == '1') {
                    count++;
                    if(count > max_count) max_count = count;
                } else {
                    count = 0;
                }
                i++;
                j--;
            }
        }
        
        printf(""%d\n"", max_count);
    }
    
    return 0;
}
",0
p00151,"Grid
There is a n × n grid D where each cell contains either 1 or 0.
Your task is to create a program that takes the gird data as input and computes the greatest number of consecutive 1s in either vertical, horizontal, or diagonal direction.
For example, the consecutive 1s with greatest number in the figure below is circled by the dashed-line.
The size of the grid n is an integer where 2 ≤ n ≤ 255.
Input
The input is a sequence of datasets. The end of the input is indicated by a line containing one zero. Each dataset is formatted as follows:
n
D
11
D
12
... D
1n
D
21
D
22
... D
2n
.
  .
D
n1
D
n2
... D
nn
Output
For each dataset, print the greatest number of consecutive 1s.
Sample Input
5
00011
00101
01000
10101
00010
8
11000001
10110111
01100111
01111010
11111111
01011010
10100010
10000001
2
01
00
3
000
000
000
0
Output for the Sample Input
4
8
1
0",C,"m[4][65536],i,l,L,p,c;main(n){for(;~scanf(""%d\n"",&n);L=n&&!printf(""%d\n"",L))for(p=255;++p<256-~n*n;)for(c=getchar(i=4);i--;L=l>L?l:L)l=m[i][p]=c-49?0:m[i][p-(i?n+i-1:1)]+1;}",1
p00151,"Grid
There is a n × n grid D where each cell contains either 1 or 0.
Your task is to create a program that takes the gird data as input and computes the greatest number of consecutive 1s in either vertical, horizontal, or diagonal direction.
For example, the consecutive 1s with greatest number in the figure below is circled by the dashed-line.
The size of the grid n is an integer where 2 ≤ n ≤ 255.
Input
The input is a sequence of datasets. The end of the input is indicated by a line containing one zero. Each dataset is formatted as follows:
n
D
11
D
12
... D
1n
D
21
D
22
... D
2n
.
  .
D
n1
D
n2
... D
nn
Output
For each dataset, print the greatest number of consecutive 1s.
Sample Input
5
00011
00101
01000
10101
00010
8
11000001
10110111
01100111
01111010
11111111
01011010
10100010
10000001
2
01
00
3
000
000
000
0
Output for the Sample Input
4
8
1
0",Java,"import java.util.Scanner;

public class Main {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        
        while (true) {
            int n = sc.nextInt();
            if (n == 0) break;
            
            int[][] grid = new int[n][n];
            for (int i = 0; i < n; i++) {
                String line = sc.next();
                for (int j = 0; j < n; j++) {
                    grid[i][j] = line.charAt(j) - '0';
                }
            }
            
            int maxConsecutive = 0;
            
            // Check horizontal
            for (int i = 0; i < n; i++) {
                int count = 0;
                for (int j = 0; j < n; j++) {
                    if (grid[i][j] == 1) {
                        count++;
                        maxConsecutive = Math.max(maxConsecutive, count);
                    } else {
                        count = 0;
                    }
                }
            }
            
            // Check vertical
            for (int j = 0; j < n; j++) {
                int count = 0;
                for (int i = 0; i < n; i++) {
                    if (grid[i][j] == 1) {
                        count++;
                        maxConsecutive = Math.max(maxConsecutive, count);
                    } else {
                        count = 0;
                    }
                }
            }
            
            // Check diagonal (top-left to bottom-right)
            for (int start = 0; start < n; start++) {
                // Starting from first row
                int count = 0;
                for (int i = 0, j = start; i < n && j < n; i++, j++) {
                    if (grid[i][j] == 1) {
                        count++;
                        maxConsecutive = Math.max(maxConsecutive, count);
                    } else {
                        count = 0;
                    }
                }
                
                // Starting from first column (skip 0,0 as it's already covered)
                if (start > 0) {
                    count = 0;
                    for (int i = start, j = 0; i < n && j < n; i++, j++) {
                        if (grid[i][j] == 1) {
                            count++;
                            maxConsecutive = Math.max(maxConsecutive, count);
                        } else {
                            count = 0;
                        }
                    }
                }
            }
            
            // Check diagonal (top-right to bottom-left)
            for (int start = 0; start < n; start++) {
                // Starting from first row
                int count = 0;
                for (int i = 0, j = start; i < n && j >= 0; i++, j--) {
                    if (grid[i][j] == 1) {
                        count++;
                        maxConsecutive = Math.max(maxConsecutive, count);
                    } else {
                        count = 0;
                    }
                }
                
                // Starting from last column (skip top-right corner as it's already covered)
                if (start > 0) {
                    count = 0;
                    for (int i = start, j = n - 1; i < n && j >= 0; i++, j--) {
                        if (grid[i][j] == 1) {
                            count++;
                            maxConsecutive = Math.max(maxConsecutive, count);
                        } else {
                            count = 0;
                        }
                    }
                }
            }
            
            System.out.println(maxConsecutive);
        }
        
        sc.close();
    }
}
",0
p00151,"Grid
There is a n × n grid D where each cell contains either 1 or 0.
Your task is to create a program that takes the gird data as input and computes the greatest number of consecutive 1s in either vertical, horizontal, or diagonal direction.
For example, the consecutive 1s with greatest number in the figure below is circled by the dashed-line.
The size of the grid n is an integer where 2 ≤ n ≤ 255.
Input
The input is a sequence of datasets. The end of the input is indicated by a line containing one zero. Each dataset is formatted as follows:
n
D
11
D
12
... D
1n
D
21
D
22
... D
2n
.
  .
D
n1
D
n2
... D
nn
Output
For each dataset, print the greatest number of consecutive 1s.
Sample Input
5
00011
00101
01000
10101
00010
8
11000001
10110111
01100111
01111010
11111111
01011010
10100010
10000001
2
01
00
3
000
000
000
0
Output for the Sample Input
4
8
1
0",Java,"import java.util.Arrays;
import java.util.LinkedList;
import java.util.List;
import java.util.Scanner;


public class Main {
	
	public static void main(String[] args) {
		Scanner sc = new Scanner(System.in);
		
		while(true){
			final int n = sc.nextInt();
			
			if(n == 0){
				break;
			}
			
			boolean[][] map = new boolean[n][n];
			
			for(int i = 0; i < n; i++){
				char[] ch = sc.next().toCharArray();
				
				for(int j = 0; j < n; j++){
					map[i][j] = ch[j] == '1';
				}
			}
			
			int max = 0;
			for(int i = 0; i < n; i++){
				int count = 0;
				
				for(int j = 0; j < n; j++){
					if(map[i][j] == true){
						count++;
					}
				}
				
				max = Math.max(max, count);
			}
			
			for(int i = 0; i < n; i++){
				int count = 0;
				
				for(int j = 0; j < n; j++){
					if(map[j][i] == true){
						count++;
					}
				}
				
				max = Math.max(max, count);
			}
			
			for(int i = 0; i < n; i++){
				int count = 0;
				
				for(int j = 0; j <= i; j++){
					//System.out.print(""( "" + (i - j) +"" "" + j + "") "");
					if(map[i - j][j] == true){
						count++;
					}
				}
				//System.out.println();
				max = Math.max(max, count);
			}
			
			for(int i = 0; i < n; i++){
				int count = 0;
				
				for(int j = n - 1; j >= i; j--){
					//System.out.print(""( "" + j +"" "" + (j - i) + "") "");
					if(map[j][j-i] == true){
						count++;
					}
				}
				//System.out.println();
				max = Math.max(max, count);
			}
			
			for(int i = 0; i < n; i++){
				int count = 0;
				
				for(int j = 0; j < (n - i) ; j++){
					//System.out.print(""( "" + (j) +"" "" + (i+j) + "") "");
					if(map[j][i+j] == true){
						count++;
					}
				}
				//System.out.println();
				max = Math.max(max, count);
			}
			
			for(int i = 0; i < n; i++){
				int count = 0;
				
				for(int j = 0; j < (n - i); j++){
					//System.out.print(""( "" + (i + j) +"" "" + (i) + "") "");
					if(map[i+j][i] == true){
						count++;
					}
				}
				//System.out.println();
				max = Math.max(max, count);
			}
			
			System.out.println(max);
		}

	}

}",1
p00151,"Grid
There is a n × n grid D where each cell contains either 1 or 0.
Your task is to create a program that takes the gird data as input and computes the greatest number of consecutive 1s in either vertical, horizontal, or diagonal direction.
For example, the consecutive 1s with greatest number in the figure below is circled by the dashed-line.
The size of the grid n is an integer where 2 ≤ n ≤ 255.
Input
The input is a sequence of datasets. The end of the input is indicated by a line containing one zero. Each dataset is formatted as follows:
n
D
11
D
12
... D
1n
D
21
D
22
... D
2n
.
  .
D
n1
D
n2
... D
nn
Output
For each dataset, print the greatest number of consecutive 1s.
Sample Input
5
00011
00101
01000
10101
00010
8
11000001
10110111
01100111
01111010
11111111
01011010
10100010
10000001
2
01
00
3
000
000
000
0
Output for the Sample Input
4
8
1
0",Python,"def count_consecutive(line):
    max_count = 0
    current_count = 0
    for char in line:
        if char == '1':
            current_count += 1
            max_count = max(max_count, current_count)
        else:
            current_count = 0
    return max_count

def solve(n, grid):
    max_consecutive = 0
    
    # Check horizontal
    for row in grid:
        max_consecutive = max(max_consecutive, count_consecutive(row))
    
    # Check vertical
    for col in range(n):
        column = ''.join(grid[row][col] for row in range(n))
        max_consecutive = max(max_consecutive, count_consecutive(column))
    
    # Check diagonals (top-left to bottom-right)
    # Diagonals starting from first row
    for start_col in range(n):
        diagonal = ''.join(grid[i][start_col + i] for i in range(n - start_col))
        max_consecutive = max(max_consecutive, count_consecutive(diagonal))
    
    # Diagonals starting from first column (excluding top-left corner)
    for start_row in range(1, n):
        diagonal = ''.join(grid[start_row + i][i] for i in range(n - start_row))
        max_consecutive = max(max_consecutive, count_consecutive(diagonal))
    
    # Check diagonals (top-right to bottom-left)
    # Diagonals starting from first row
    for start_col in range(n):
        diagonal = ''.join(grid[i][start_col - i] for i in range(start_col + 1))
        max_consecutive = max(max_consecutive, count_consecutive(diagonal))
    
    # Diagonals starting from last column (excluding top-right corner)
    for start_row in range(1, n):
        diagonal = ''.join(grid[start_row + i][n - 1 - i] for i in range(n - start_row))
        max_consecutive = max(max_consecutive, count_consecutive(diagonal))
    
    return max_consecutive

while True:
    n = int(input())
    if n == 0:
        break
    
    grid = []
    for _ in range(n):
        grid.append(input().strip())
    
    result = solve(n, grid)
    print(result)
",0
p00151,"Grid
There is a n × n grid D where each cell contains either 1 or 0.
Your task is to create a program that takes the gird data as input and computes the greatest number of consecutive 1s in either vertical, horizontal, or diagonal direction.
For example, the consecutive 1s with greatest number in the figure below is circled by the dashed-line.
The size of the grid n is an integer where 2 ≤ n ≤ 255.
Input
The input is a sequence of datasets. The end of the input is indicated by a line containing one zero. Each dataset is formatted as follows:
n
D
11
D
12
... D
1n
D
21
D
22
... D
2n
.
  .
D
n1
D
n2
... D
nn
Output
For each dataset, print the greatest number of consecutive 1s.
Sample Input
5
00011
00101
01000
10101
00010
8
11000001
10110111
01100111
01111010
11111111
01011010
10100010
10000001
2
01
00
3
000
000
000
0
Output for the Sample Input
4
8
1
0",Python,"def ge(n):
    for i in xrange(n):
        yield [(i,j) for j in xrange(n)]
        yield [(j,i) for j in xrange(n)]
        yield [(i-j,j) for j in xrange(i+1)]
        yield [(n-i+j-1,n-j-1) for j in xrange(i+1)]

while True:
    n = input()
    if n == 0:
        break
    A = [map(int,list(raw_input())) for _ in xrange(n)]
    print max(sum(map(lambda (i,j): A[i][j], p)) for p in ge(n))",1
p00152,"ボウリング
クラスのレクリエーションとしてボウリングを行うことになりました。参加者ごとの投球情報を入力とし、得点の高い順に成績情報を出力するプログラムを作成してください。なお、同点の場合は学籍番号の若い順に出力してください。ただし参加者は 3 名以上 40 名以下とし、1人当たり1ゲームずつ投球しているものとします。
ボウリングとは、プレイヤーに対して頂点を向けて正三角形に並べられた、10 本のピンをめがけてボールを転がし、ピンを倒すスポーツです。 1 回目の投球ですべて転倒した場合をストライクと言い、その投球のみで次のフレームに進みます。ストライクでない場合は、残ったピンをそのままにして 2 回目の投球を行います。2 回目の投球ですべて転倒した場合をスペアと言います。2 回目の投球終了後、次のフレームに進みます。
1 ゲームは 10 のフレームから構成され、第 1 から第 9 の各フレームは 2 回投球できます。各フレームの開始時点では、10 本のピンがすべて立った状態で用意されます。第 10 フレームは、ストライクもしくはスペアが出た場合には計 3 回の投球を、それ以外の場合は 2 回の投球を行い、ゲーム終了となります。
スコア例１
スコア例２（最高得点300点の場合）
スコア計算の方法
各フレームにおいてスペア、ストライクがない場合は、 2 回の投球で倒したピンの本数がそのフレームの得点となります。（スコア例１の第 4 フレームと第 8 フレーム）
スペアを出した場合、倒した本数である 10 点に加え、次の投球で倒したピンの本数がこのフレームの得点に加算されます。（スコア例１の第 1 フレームと第 2 フレームの関係など）スコア例１の第 1 フレームでは第 2 フレームの 1 投で倒した 10 本（点）を加えた 20 点が得点となります。第 3 フレームも同様の計算方法です。
ストライクを出した場合、倒した本数である 10 点に加え、続く 2 回の投球で倒したピンの本数が加算されます。（スコア例１の第 2 フレームと第 3 フレームの関係など）もちろん続く 2 投中にストライクの場合があります。（スコア例１の第 5 フレームと第 6、7 フレームの関係など）
第 10 フレームのみ、スペア、ストライクを出した場合、3 投して倒したピンの総数が第 10 フレームの得点として加算されます。
各フレームの得点の合計が 1 ゲームの得点となり、最高得点は 300 点となります。
Input
複数のデータセットの並びが入力として与えられます。入力の終わりはゼロひとつの行で示されます。
各データセットは以下の形式で与えられます。
m
score
1
score
2
:
score
m
1行目に参加者数
m
（3 ≤
m
≤ 40）、続く
m
行に
i
人目の参加者情報
score
i
が与えられます。各参加者情報は１行ずつ次の形式で与えられます。
id
s
1
s
2
...
s
n
先頭に学籍番号
id
(0 ≤
id
≤ 9999)、続いて第
j
投の転倒ピン数
s
j
(0 ≤
s
j
≤ 10) が与えられます。総投球数
n
は、12 以上 21 以下であり、得点計算に必要なピン数が過不足なく与えられるものとします。
Output
入力データセットごとに、学籍番号と得点を、得点の高い順（同点の場合は学籍番号の若い順）に出力します。学籍番号と得点を１つの空白で区切って１行に出力してください。
Sample Input
3
1010 6 3 10 7 1 0 7 9 1 10 6 2 4 3 9 1 9 0
1200 5 3 9 1 7 1 0 0 8 1 10 10 4 3 9 1 8 2 9
1101 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3
4
3321 8 2 10 9 1 7 0 10 10 10 0 8 10 10 10 10
3332 5 0 10 9 1 4 1 9 0 10 10 7 1 5 2 8 1
3335 10 10 10 10 10 10 10 10 10 10 10 10
3340 8 2 7 3 6 4 8 2 8 2 9 1 7 3 6 4 8 2 9 1 7
0
Output for the Sample Input
1200 127
1010 123
1101 60
3335 300
3321 200
3340 175
3332 122",C,"#include <stdio.h>
#include <stdlib.h>

typedef struct {
    int id;
    int score;
} Player;

int calculate_score(int pins[], int n) {
    int total = 0;
    int pin_idx = 0;
    
    for (int frame = 0; frame < 10; frame++) {
        if (frame < 9) {
            if (pins[pin_idx] == 10) { // Strike
                total += 10 + pins[pin_idx + 1] + pins[pin_idx + 2];
                pin_idx++;
            } else if (pins[pin_idx] + pins[pin_idx + 1] == 10) { // Spare
                total += 10 + pins[pin_idx + 2];
                pin_idx += 2;
            } else {
                total += pins[pin_idx] + pins[pin_idx + 1];
                pin_idx += 2;
            }
        } else { // 10th frame
            total += pins[pin_idx] + pins[pin_idx + 1];
            if (pins[pin_idx] == 10 || pins[pin_idx] + pins[pin_idx + 1] == 10) {
                total += pins[pin_idx + 2];
            }
        }
    }
    
    return total;
}

int compare_players(const void *a, const void *b) {
    Player *pa = (Player *)a;
    Player *pb = (Player *)b;
    
    if (pa->score != pb->score) {
        return pb->score - pa->score; // Higher score first
    }
    return pa->id - pb->id; // Lower ID first
}

int main() {
    int m;
    
    while (scanf(""%d"", &m) == 1 && m != 0) {
        Player players[40];
        
        for (int i = 0; i < m; i++) {
            int id;
            int pins[21];
            int n = 0;
            
            scanf(""%d"", &id);
            
            while (n < 21) {
                if (scanf(""%d"", &pins[n]) != 1) break;
                n++;
                
                // Check if we should stop reading (peek next character)
                int c = getchar();
                if (c == '\n' || c == EOF) {
                    ungetc(c, stdin);
                    break;
                }
                ungetc(c, stdin);
            }
            
            players[i].id = id;
            players[i].score = calculate_score(pins, n);
        }
        
        qsort(players, m, sizeof(Player), compare_players);
        
        for (int i = 0; i < m; i++) {
            printf(""%d %d\n"", players[i].id, players[i].score);
        }
    }
    
    return 0;
}
",0
p00152,"ボウリング
クラスのレクリエーションとしてボウリングを行うことになりました。参加者ごとの投球情報を入力とし、得点の高い順に成績情報を出力するプログラムを作成してください。なお、同点の場合は学籍番号の若い順に出力してください。ただし参加者は 3 名以上 40 名以下とし、1人当たり1ゲームずつ投球しているものとします。
ボウリングとは、プレイヤーに対して頂点を向けて正三角形に並べられた、10 本のピンをめがけてボールを転がし、ピンを倒すスポーツです。 1 回目の投球ですべて転倒した場合をストライクと言い、その投球のみで次のフレームに進みます。ストライクでない場合は、残ったピンをそのままにして 2 回目の投球を行います。2 回目の投球ですべて転倒した場合をスペアと言います。2 回目の投球終了後、次のフレームに進みます。
1 ゲームは 10 のフレームから構成され、第 1 から第 9 の各フレームは 2 回投球できます。各フレームの開始時点では、10 本のピンがすべて立った状態で用意されます。第 10 フレームは、ストライクもしくはスペアが出た場合には計 3 回の投球を、それ以外の場合は 2 回の投球を行い、ゲーム終了となります。
スコア例１
スコア例２（最高得点300点の場合）
スコア計算の方法
各フレームにおいてスペア、ストライクがない場合は、 2 回の投球で倒したピンの本数がそのフレームの得点となります。（スコア例１の第 4 フレームと第 8 フレーム）
スペアを出した場合、倒した本数である 10 点に加え、次の投球で倒したピンの本数がこのフレームの得点に加算されます。（スコア例１の第 1 フレームと第 2 フレームの関係など）スコア例１の第 1 フレームでは第 2 フレームの 1 投で倒した 10 本（点）を加えた 20 点が得点となります。第 3 フレームも同様の計算方法です。
ストライクを出した場合、倒した本数である 10 点に加え、続く 2 回の投球で倒したピンの本数が加算されます。（スコア例１の第 2 フレームと第 3 フレームの関係など）もちろん続く 2 投中にストライクの場合があります。（スコア例１の第 5 フレームと第 6、7 フレームの関係など）
第 10 フレームのみ、スペア、ストライクを出した場合、3 投して倒したピンの総数が第 10 フレームの得点として加算されます。
各フレームの得点の合計が 1 ゲームの得点となり、最高得点は 300 点となります。
Input
複数のデータセットの並びが入力として与えられます。入力の終わりはゼロひとつの行で示されます。
各データセットは以下の形式で与えられます。
m
score
1
score
2
:
score
m
1行目に参加者数
m
（3 ≤
m
≤ 40）、続く
m
行に
i
人目の参加者情報
score
i
が与えられます。各参加者情報は１行ずつ次の形式で与えられます。
id
s
1
s
2
...
s
n
先頭に学籍番号
id
(0 ≤
id
≤ 9999)、続いて第
j
投の転倒ピン数
s
j
(0 ≤
s
j
≤ 10) が与えられます。総投球数
n
は、12 以上 21 以下であり、得点計算に必要なピン数が過不足なく与えられるものとします。
Output
入力データセットごとに、学籍番号と得点を、得点の高い順（同点の場合は学籍番号の若い順）に出力します。学籍番号と得点を１つの空白で区切って１行に出力してください。
Sample Input
3
1010 6 3 10 7 1 0 7 9 1 10 6 2 4 3 9 1 9 0
1200 5 3 9 1 7 1 0 0 8 1 10 10 4 3 9 1 8 2 9
1101 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3
4
3321 8 2 10 9 1 7 0 10 10 10 0 8 10 10 10 10
3332 5 0 10 9 1 4 1 9 0 10 10 7 1 5 2 8 1
3335 10 10 10 10 10 10 10 10 10 10 10 10
3340 8 2 7 3 6 4 8 2 8 2 9 1 7 3 6 4 8 2 9 1 7
0
Output for the Sample Input
1200 127
1010 123
1101 60
3335 300
3321 200
3340 175
3332 122",C,"#include <stdio.h>

typedef struct{
	int no;
	int score;
} Info;

void sortInfo(int n,Info t[]){
	int i,j;
	for(i=0;i<n-1;i++){
		for(j=i+1;j<n;j++){
			if(t[i].score < t[j].score ||
			   t[i].score == t[j].score && t[i].no > t[j].no){
				Info tmp = t[i];
				t[i] = t[j];
				t[j] = tmp;
			}
		}
	}
}

int scoring(void){
	int i, x, total, frame, time, sum, flgSpare, flgStrike;
	
	total = sum = 0;
	frame = time = 1;
	flgSpare = flgStrike = 0;
	
	while(frame < 10){
		scanf(""%d"",&x);
		sum += x;
		
		if(flgSpare){
			total += x;
			flgSpare = 0;
		}
		else if(flgStrike){
			if(flgStrike == 3){
				total += x;
				flgStrike--;
			}
			total += x;
			flgStrike--;
		}
		
		if(time == 2){
			total += sum;
			if(sum == 10){
				flgSpare = 1;
			}
			sum = 0;
			time = 1;
			frame++;
		}
		else if(time == 1){
			time++;
			if(x == 10){
				total += 10;
				flgStrike += 2;
				sum = 0;
				time = 1;
				frame++;
			}
		}
	}
	
	for(i=0;i<3;i++){
		if(i == 2 && sum < 10) break;
		
		scanf(""%d"",&x);
		total += x;
		sum += x;
		
		if(flgSpare){
			total += x;
			flgSpare = 0;
		}
		else if(flgStrike){
			if(flgStrike == 3){
				total += x;
				flgStrike--;
			}
			total += x;
			flgStrike--;
		}
	}

	return total;
}

int main(void){
	int i, n;
	Info info[40];
	
	while(scanf(""%d"",&n) && n){
		for(i=0;i<n;i++){
			scanf(""%d"",&info[i].no);
			info[i].score = scoring();
		}
		sortInfo(n,info);
		for(i=0;i<n;i++){
			printf(""%d %d\n"",info[i].no,info[i].score);
		}
	}
	
	return 0;
}",1
p00152,"ボウリング
クラスのレクリエーションとしてボウリングを行うことになりました。参加者ごとの投球情報を入力とし、得点の高い順に成績情報を出力するプログラムを作成してください。なお、同点の場合は学籍番号の若い順に出力してください。ただし参加者は 3 名以上 40 名以下とし、1人当たり1ゲームずつ投球しているものとします。
ボウリングとは、プレイヤーに対して頂点を向けて正三角形に並べられた、10 本のピンをめがけてボールを転がし、ピンを倒すスポーツです。 1 回目の投球ですべて転倒した場合をストライクと言い、その投球のみで次のフレームに進みます。ストライクでない場合は、残ったピンをそのままにして 2 回目の投球を行います。2 回目の投球ですべて転倒した場合をスペアと言います。2 回目の投球終了後、次のフレームに進みます。
1 ゲームは 10 のフレームから構成され、第 1 から第 9 の各フレームは 2 回投球できます。各フレームの開始時点では、10 本のピンがすべて立った状態で用意されます。第 10 フレームは、ストライクもしくはスペアが出た場合には計 3 回の投球を、それ以外の場合は 2 回の投球を行い、ゲーム終了となります。
スコア例１
スコア例２（最高得点300点の場合）
スコア計算の方法
各フレームにおいてスペア、ストライクがない場合は、 2 回の投球で倒したピンの本数がそのフレームの得点となります。（スコア例１の第 4 フレームと第 8 フレーム）
スペアを出した場合、倒した本数である 10 点に加え、次の投球で倒したピンの本数がこのフレームの得点に加算されます。（スコア例１の第 1 フレームと第 2 フレームの関係など）スコア例１の第 1 フレームでは第 2 フレームの 1 投で倒した 10 本（点）を加えた 20 点が得点となります。第 3 フレームも同様の計算方法です。
ストライクを出した場合、倒した本数である 10 点に加え、続く 2 回の投球で倒したピンの本数が加算されます。（スコア例１の第 2 フレームと第 3 フレームの関係など）もちろん続く 2 投中にストライクの場合があります。（スコア例１の第 5 フレームと第 6、7 フレームの関係など）
第 10 フレームのみ、スペア、ストライクを出した場合、3 投して倒したピンの総数が第 10 フレームの得点として加算されます。
各フレームの得点の合計が 1 ゲームの得点となり、最高得点は 300 点となります。
Input
複数のデータセットの並びが入力として与えられます。入力の終わりはゼロひとつの行で示されます。
各データセットは以下の形式で与えられます。
m
score
1
score
2
:
score
m
1行目に参加者数
m
（3 ≤
m
≤ 40）、続く
m
行に
i
人目の参加者情報
score
i
が与えられます。各参加者情報は１行ずつ次の形式で与えられます。
id
s
1
s
2
...
s
n
先頭に学籍番号
id
(0 ≤
id
≤ 9999)、続いて第
j
投の転倒ピン数
s
j
(0 ≤
s
j
≤ 10) が与えられます。総投球数
n
は、12 以上 21 以下であり、得点計算に必要なピン数が過不足なく与えられるものとします。
Output
入力データセットごとに、学籍番号と得点を、得点の高い順（同点の場合は学籍番号の若い順）に出力します。学籍番号と得点を１つの空白で区切って１行に出力してください。
Sample Input
3
1010 6 3 10 7 1 0 7 9 1 10 6 2 4 3 9 1 9 0
1200 5 3 9 1 7 1 0 0 8 1 10 10 4 3 9 1 8 2 9
1101 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3
4
3321 8 2 10 9 1 7 0 10 10 10 0 8 10 10 10 10
3332 5 0 10 9 1 4 1 9 0 10 10 7 1 5 2 8 1
3335 10 10 10 10 10 10 10 10 10 10 10 10
3340 8 2 7 3 6 4 8 2 8 2 9 1 7 3 6 4 8 2 9 1 7
0
Output for the Sample Input
1200 127
1010 123
1101 60
3335 300
3321 200
3340 175
3332 122",Java,"import java.util.*;

public class Main {
    static class Player implements Comparable<Player> {
        int id;
        int score;
        
        public Player(int id, int score) {
            this.id = id;
            this.score = score;
        }
        
        @Override
        public int compareTo(Player other) {
            if (this.score != other.score) {
                return other.score - this.score;
            }
            return this.id - other.id;
        }
    }
    
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        
        while (true) {
            int m = sc.nextInt();
            if (m == 0) break;
            
            List<Player> players = new ArrayList<>();
            
            for (int i = 0; i < m; i++) {
                int id = sc.nextInt();
                List<Integer> rolls = new ArrayList<>();
                
                String line = sc.nextLine().trim();
                String[] tokens = line.split(""\\s+"");
                for (String token : tokens) {
                    rolls.add(Integer.parseInt(token));
                }
                
                int score = calculateScore(rolls);
                players.add(new Player(id, score));
            }
            
            Collections.sort(players);
            
            for (Player p : players) {
                System.out.println(p.id + "" "" + p.score);
            }
        }
        
        sc.close();
    }
    
    static int calculateScore(List<Integer> rolls) {
        int score = 0;
        int rollIndex = 0;
        
        for (int frame = 0; frame < 10; frame++) {
            if (frame < 9) {
                if (rolls.get(rollIndex) == 10) {
                    score += 10 + rolls.get(rollIndex + 1) + rolls.get(rollIndex + 2);
                    rollIndex++;
                } else if (rolls.get(rollIndex) + rolls.get(rollIndex + 1) == 10) {
                    score += 10 + rolls.get(rollIndex + 2);
                    rollIndex += 2;
                } else {
                    score += rolls.get(rollIndex) + rolls.get(rollIndex + 1);
                    rollIndex += 2;
                }
            } else {
                if (rolls.get(rollIndex) == 10) {
                    score += rolls.get(rollIndex) + rolls.get(rollIndex + 1) + rolls.get(rollIndex + 2);
                    rollIndex += 3;
                } else if (rolls.get(rollIndex) + rolls.get(rollIndex + 1) == 10) {
                    score += rolls.get(rollIndex) + rolls.get(rollIndex + 1) + rolls.get(rollIndex + 2);
                    rollIndex += 3;
                } else {
                    score += rolls.get(rollIndex) + rolls.get(rollIndex + 1);
                    rollIndex += 2;
                }
            }
        }
        
        return score;
    }
}
",0
p00152,"ボウリング
クラスのレクリエーションとしてボウリングを行うことになりました。参加者ごとの投球情報を入力とし、得点の高い順に成績情報を出力するプログラムを作成してください。なお、同点の場合は学籍番号の若い順に出力してください。ただし参加者は 3 名以上 40 名以下とし、1人当たり1ゲームずつ投球しているものとします。
ボウリングとは、プレイヤーに対して頂点を向けて正三角形に並べられた、10 本のピンをめがけてボールを転がし、ピンを倒すスポーツです。 1 回目の投球ですべて転倒した場合をストライクと言い、その投球のみで次のフレームに進みます。ストライクでない場合は、残ったピンをそのままにして 2 回目の投球を行います。2 回目の投球ですべて転倒した場合をスペアと言います。2 回目の投球終了後、次のフレームに進みます。
1 ゲームは 10 のフレームから構成され、第 1 から第 9 の各フレームは 2 回投球できます。各フレームの開始時点では、10 本のピンがすべて立った状態で用意されます。第 10 フレームは、ストライクもしくはスペアが出た場合には計 3 回の投球を、それ以外の場合は 2 回の投球を行い、ゲーム終了となります。
スコア例１
スコア例２（最高得点300点の場合）
スコア計算の方法
各フレームにおいてスペア、ストライクがない場合は、 2 回の投球で倒したピンの本数がそのフレームの得点となります。（スコア例１の第 4 フレームと第 8 フレーム）
スペアを出した場合、倒した本数である 10 点に加え、次の投球で倒したピンの本数がこのフレームの得点に加算されます。（スコア例１の第 1 フレームと第 2 フレームの関係など）スコア例１の第 1 フレームでは第 2 フレームの 1 投で倒した 10 本（点）を加えた 20 点が得点となります。第 3 フレームも同様の計算方法です。
ストライクを出した場合、倒した本数である 10 点に加え、続く 2 回の投球で倒したピンの本数が加算されます。（スコア例１の第 2 フレームと第 3 フレームの関係など）もちろん続く 2 投中にストライクの場合があります。（スコア例１の第 5 フレームと第 6、7 フレームの関係など）
第 10 フレームのみ、スペア、ストライクを出した場合、3 投して倒したピンの総数が第 10 フレームの得点として加算されます。
各フレームの得点の合計が 1 ゲームの得点となり、最高得点は 300 点となります。
Input
複数のデータセットの並びが入力として与えられます。入力の終わりはゼロひとつの行で示されます。
各データセットは以下の形式で与えられます。
m
score
1
score
2
:
score
m
1行目に参加者数
m
（3 ≤
m
≤ 40）、続く
m
行に
i
人目の参加者情報
score
i
が与えられます。各参加者情報は１行ずつ次の形式で与えられます。
id
s
1
s
2
...
s
n
先頭に学籍番号
id
(0 ≤
id
≤ 9999)、続いて第
j
投の転倒ピン数
s
j
(0 ≤
s
j
≤ 10) が与えられます。総投球数
n
は、12 以上 21 以下であり、得点計算に必要なピン数が過不足なく与えられるものとします。
Output
入力データセットごとに、学籍番号と得点を、得点の高い順（同点の場合は学籍番号の若い順）に出力します。学籍番号と得点を１つの空白で区切って１行に出力してください。
Sample Input
3
1010 6 3 10 7 1 0 7 9 1 10 6 2 4 3 9 1 9 0
1200 5 3 9 1 7 1 0 0 8 1 10 10 4 3 9 1 8 2 9
1101 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3
4
3321 8 2 10 9 1 7 0 10 10 10 0 8 10 10 10 10
3332 5 0 10 9 1 4 1 9 0 10 10 7 1 5 2 8 1
3335 10 10 10 10 10 10 10 10 10 10 10 10
3340 8 2 7 3 6 4 8 2 8 2 9 1 7 3 6 4 8 2 9 1 7
0
Output for the Sample Input
1200 127
1010 123
1101 60
3335 300
3321 200
3340 175
3332 122",Java,"import java.util.*;
import java.lang.*;
import java.math.*;

public class Main {
	Scanner sc = new Scanner(System.in);

	class score implements Comparable<score> {
		String id;
		int s;

		score(Scanner sc) {
			id = sc.next();
			int f = 0;
			int x1 = 0;
			int x2 = 0;
			int c = 0;
			int q = 0;
			int e = 0;
			s = 0;
			for (;;) {
				if(f == 9 && e == 1 && c==3){
					break;
				}
				if(f == 9 && e == 0 && c==2){
					break;
				}
				int v = sc.nextInt();
				if (x1 > 0) {
					x1--;
					s+=v;
				}
				if (x2 > 0) {
					x2--;
					x1++;
					s+=v;
				}
				s+=v;
//				System.out.println(s);
				if (f == 9) {
					if(c==0){
						if(v==10){
							e=1;
						}
						q=v;
						c++;
					}else if(c== 1 && q+v==10){
						e=1;
						c++;
					}else{
						c++;
					}
				} else if (v == 10) {
					x2 += 1;
					c = 0;
					q=0;
					f++;
				} else if (q + v == 10) {
					x1 += 1;
					c = 0;
					q=0;
					f++;
				} else if (c == 1) {
					c = 0;
					q=0;
					f++;
				} else {
					q = v;
					c++;
				}
			}
		}

		@Override
		public int compareTo(score arg0) {
			int a;
			a = arg0.s - s;
			if (a == 0) {
				a = id.compareTo(arg0.id);
			}
			return a;
		}
		
	}

	void run() {
		for (;;) {
			int n = sc.nextInt();
			if (n == 0) {
				break;
			}

			score[] c = new score[n];
			for(int i =0;i<n;i++){
			//	System.out.println(i);
				c[i] = new score(sc);
			}
			Arrays.sort(c);
			
			for(int i =0 ; i < n;i++){
				System.out.println(c[i].id+"" ""+c[i].s);
			}
		}
	}

	public static void main(String[] args) {
		Main m = new Main();
		m.run();
	}
}",1
p00152,"ボウリング
クラスのレクリエーションとしてボウリングを行うことになりました。参加者ごとの投球情報を入力とし、得点の高い順に成績情報を出力するプログラムを作成してください。なお、同点の場合は学籍番号の若い順に出力してください。ただし参加者は 3 名以上 40 名以下とし、1人当たり1ゲームずつ投球しているものとします。
ボウリングとは、プレイヤーに対して頂点を向けて正三角形に並べられた、10 本のピンをめがけてボールを転がし、ピンを倒すスポーツです。 1 回目の投球ですべて転倒した場合をストライクと言い、その投球のみで次のフレームに進みます。ストライクでない場合は、残ったピンをそのままにして 2 回目の投球を行います。2 回目の投球ですべて転倒した場合をスペアと言います。2 回目の投球終了後、次のフレームに進みます。
1 ゲームは 10 のフレームから構成され、第 1 から第 9 の各フレームは 2 回投球できます。各フレームの開始時点では、10 本のピンがすべて立った状態で用意されます。第 10 フレームは、ストライクもしくはスペアが出た場合には計 3 回の投球を、それ以外の場合は 2 回の投球を行い、ゲーム終了となります。
スコア例１
スコア例２（最高得点300点の場合）
スコア計算の方法
各フレームにおいてスペア、ストライクがない場合は、 2 回の投球で倒したピンの本数がそのフレームの得点となります。（スコア例１の第 4 フレームと第 8 フレーム）
スペアを出した場合、倒した本数である 10 点に加え、次の投球で倒したピンの本数がこのフレームの得点に加算されます。（スコア例１の第 1 フレームと第 2 フレームの関係など）スコア例１の第 1 フレームでは第 2 フレームの 1 投で倒した 10 本（点）を加えた 20 点が得点となります。第 3 フレームも同様の計算方法です。
ストライクを出した場合、倒した本数である 10 点に加え、続く 2 回の投球で倒したピンの本数が加算されます。（スコア例１の第 2 フレームと第 3 フレームの関係など）もちろん続く 2 投中にストライクの場合があります。（スコア例１の第 5 フレームと第 6、7 フレームの関係など）
第 10 フレームのみ、スペア、ストライクを出した場合、3 投して倒したピンの総数が第 10 フレームの得点として加算されます。
各フレームの得点の合計が 1 ゲームの得点となり、最高得点は 300 点となります。
Input
複数のデータセットの並びが入力として与えられます。入力の終わりはゼロひとつの行で示されます。
各データセットは以下の形式で与えられます。
m
score
1
score
2
:
score
m
1行目に参加者数
m
（3 ≤
m
≤ 40）、続く
m
行に
i
人目の参加者情報
score
i
が与えられます。各参加者情報は１行ずつ次の形式で与えられます。
id
s
1
s
2
...
s
n
先頭に学籍番号
id
(0 ≤
id
≤ 9999)、続いて第
j
投の転倒ピン数
s
j
(0 ≤
s
j
≤ 10) が与えられます。総投球数
n
は、12 以上 21 以下であり、得点計算に必要なピン数が過不足なく与えられるものとします。
Output
入力データセットごとに、学籍番号と得点を、得点の高い順（同点の場合は学籍番号の若い順）に出力します。学籍番号と得点を１つの空白で区切って１行に出力してください。
Sample Input
3
1010 6 3 10 7 1 0 7 9 1 10 6 2 4 3 9 1 9 0
1200 5 3 9 1 7 1 0 0 8 1 10 10 4 3 9 1 8 2 9
1101 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3
4
3321 8 2 10 9 1 7 0 10 10 10 0 8 10 10 10 10
3332 5 0 10 9 1 4 1 9 0 10 10 7 1 5 2 8 1
3335 10 10 10 10 10 10 10 10 10 10 10 10
3340 8 2 7 3 6 4 8 2 8 2 9 1 7 3 6 4 8 2 9 1 7
0
Output for the Sample Input
1200 127
1010 123
1101 60
3335 300
3321 200
3340 175
3332 122",Python,"def calculate_bowling_score(pins):
    score = 0
    pin_idx = 0
    
    for frame in range(10):
        if frame < 9:  # Frames 1-9
            if pins[pin_idx] == 10:  # Strike
                score += 10 + pins[pin_idx + 1] + pins[pin_idx + 2]
                pin_idx += 1
            elif pins[pin_idx] + pins[pin_idx + 1] == 10:  # Spare
                score += 10 + pins[pin_idx + 2]
                pin_idx += 2
            else:  # Regular
                score += pins[pin_idx] + pins[pin_idx + 1]
                pin_idx += 2
        else:  # Frame 10
            score += pins[pin_idx] + pins[pin_idx + 1] + pins[pin_idx + 2]
            pin_idx += 3
    
    return score

while True:
    m = int(input())
    if m == 0:
        break
    
    results = []
    for _ in range(m):
        data = list(map(int, input().split()))
        student_id = data[0]
        pins = data[1:]
        score = calculate_bowling_score(pins)
        results.append((student_id, score))
    
    # Sort by score (descending), then by student_id (ascending)
    results.sort(key=lambda x: (-x[1], x[0]))
    
    for student_id, score in results:
        print(f""{student_id} {score}"")
",0
p00152,"ボウリング
クラスのレクリエーションとしてボウリングを行うことになりました。参加者ごとの投球情報を入力とし、得点の高い順に成績情報を出力するプログラムを作成してください。なお、同点の場合は学籍番号の若い順に出力してください。ただし参加者は 3 名以上 40 名以下とし、1人当たり1ゲームずつ投球しているものとします。
ボウリングとは、プレイヤーに対して頂点を向けて正三角形に並べられた、10 本のピンをめがけてボールを転がし、ピンを倒すスポーツです。 1 回目の投球ですべて転倒した場合をストライクと言い、その投球のみで次のフレームに進みます。ストライクでない場合は、残ったピンをそのままにして 2 回目の投球を行います。2 回目の投球ですべて転倒した場合をスペアと言います。2 回目の投球終了後、次のフレームに進みます。
1 ゲームは 10 のフレームから構成され、第 1 から第 9 の各フレームは 2 回投球できます。各フレームの開始時点では、10 本のピンがすべて立った状態で用意されます。第 10 フレームは、ストライクもしくはスペアが出た場合には計 3 回の投球を、それ以外の場合は 2 回の投球を行い、ゲーム終了となります。
スコア例１
スコア例２（最高得点300点の場合）
スコア計算の方法
各フレームにおいてスペア、ストライクがない場合は、 2 回の投球で倒したピンの本数がそのフレームの得点となります。（スコア例１の第 4 フレームと第 8 フレーム）
スペアを出した場合、倒した本数である 10 点に加え、次の投球で倒したピンの本数がこのフレームの得点に加算されます。（スコア例１の第 1 フレームと第 2 フレームの関係など）スコア例１の第 1 フレームでは第 2 フレームの 1 投で倒した 10 本（点）を加えた 20 点が得点となります。第 3 フレームも同様の計算方法です。
ストライクを出した場合、倒した本数である 10 点に加え、続く 2 回の投球で倒したピンの本数が加算されます。（スコア例１の第 2 フレームと第 3 フレームの関係など）もちろん続く 2 投中にストライクの場合があります。（スコア例１の第 5 フレームと第 6、7 フレームの関係など）
第 10 フレームのみ、スペア、ストライクを出した場合、3 投して倒したピンの総数が第 10 フレームの得点として加算されます。
各フレームの得点の合計が 1 ゲームの得点となり、最高得点は 300 点となります。
Input
複数のデータセットの並びが入力として与えられます。入力の終わりはゼロひとつの行で示されます。
各データセットは以下の形式で与えられます。
m
score
1
score
2
:
score
m
1行目に参加者数
m
（3 ≤
m
≤ 40）、続く
m
行に
i
人目の参加者情報
score
i
が与えられます。各参加者情報は１行ずつ次の形式で与えられます。
id
s
1
s
2
...
s
n
先頭に学籍番号
id
(0 ≤
id
≤ 9999)、続いて第
j
投の転倒ピン数
s
j
(0 ≤
s
j
≤ 10) が与えられます。総投球数
n
は、12 以上 21 以下であり、得点計算に必要なピン数が過不足なく与えられるものとします。
Output
入力データセットごとに、学籍番号と得点を、得点の高い順（同点の場合は学籍番号の若い順）に出力します。学籍番号と得点を１つの空白で区切って１行に出力してください。
Sample Input
3
1010 6 3 10 7 1 0 7 9 1 10 6 2 4 3 9 1 9 0
1200 5 3 9 1 7 1 0 0 8 1 10 10 4 3 9 1 8 2 9
1101 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3
4
3321 8 2 10 9 1 7 0 10 10 10 0 8 10 10 10 10
3332 5 0 10 9 1 4 1 9 0 10 10 7 1 5 2 8 1
3335 10 10 10 10 10 10 10 10 10 10 10 10
3340 8 2 7 3 6 4 8 2 8 2 9 1 7 3 6 4 8 2 9 1 7
0
Output for the Sample Input
1200 127
1010 123
1101 60
3335 300
3321 200
3340 175
3332 122",Python,"def f1():
    frame = 1
    total = 0
    i = 0
    while frame < 10:
        if score[i] == 10:
            total += (score[i] + score[i+1] + score[i+2])
            i += 1
        elif score[i] + score[i+1] == 10:
            total += (score[i] + score[i+1] + score[i+2])
            i += 2
        else:
            total += (score[i] + score[i+1])
            i += 2
        frame += 1
    else:
        total += sum(score[i:])
        res[sn] = total

def f2():
    for k, v in sorted(res.items(), key=lambda x: (x[1], x[0]), reverse=True):
        print -k, v

while True:
    n = input()
    if n == 0: break
    res = {}
    for i in range(n):
        L = map(int, raw_input().split())
        sn = -L[0]
        score = L[1:]
        f1()
    else:
        f2()",1
p00153,"三角形と円
平面上にある三角形と円の位置関係を判定するプログラムを作成してください。対象となる図形はいずれも境界を含むものとします。
三角形は 3 頂点の位置が与えられ、円は中心の位置と半径が与えられます。位置は直交座標系による２つの整数の組によって与えられます。半径も整数で与えられます。
Input
複数のデータセットの並びが入力として与えられます。入力の終わりはゼロふたつの行で示されます。
各データセットは以下の形式で与えられます。
x
1
y
1
x
2
y
2
x
3
y
3
x
c
y
c
r
１行目から３行目に、三角形の第
i
の頂点座標
x
i
,
y
i
が与えられます。４行目に円の中心の座標
x
c
,
y
c
、５行目に円の半径
r
が与えられます。与えられる入力はすべて、1 以上 10,000 以下の整数とします。
データセットの数は 100 を超えません。
Output
入力データセットごとに以下の形式で判定結果を１行に出力します。
円が三角形に含まれる場合
a
三角形が円に含まれる場合
b
それ以外の場合で、共通部分がある場合には
c
共通部分がない場合には
d
Sample Input
1 1
3 1
3 3
3 2
3
3 12
9 3
11 12
8 7
5
15 3
17 7
22 5
7 6
4
6 11
8 2
16 9
10 8
2
0 0
Output for the Sample Input
b
c
d
a",C,"#include <stdio.h>
#include <math.h>

#define EPS 1e-9

typedef struct {
    double x, y;
} Point;

double dist(Point a, Point b) {
    double dx = a.x - b.x;
    double dy = a.y - b.y;
    return sqrt(dx * dx + dy * dy);
}

double dot(Point a, Point b, Point c) {
    return (b.x - a.x) * (c.x - a.x) + (b.y - a.y) * (c.y - a.y);
}

double cross(Point a, Point b, Point c) {
    return (b.x - a.x) * (c.y - a.y) - (b.y - a.y) * (c.x - a.x);
}

double distPointToSegment(Point p, Point a, Point b) {
    if (dot(a, b, p) < -EPS) return dist(p, a);
    if (dot(b, a, p) < -EPS) return dist(p, b);
    return fabs(cross(a, b, p)) / dist(a, b);
}

int pointInTriangle(Point p, Point t1, Point t2, Point t3) {
    double c1 = cross(t1, t2, p);
    double c2 = cross(t2, t3, p);
    double c3 = cross(t3, t1, p);
    
    if (c1 >= -EPS && c2 >= -EPS && c3 >= -EPS) return 1;
    if (c1 <= EPS && c2 <= EPS && c3 <= EPS) return 1;
    return 0;
}

int main() {
    int x1, y1, x2, y2, x3, y3, xc, yc, r;
    
    while (1) {
        scanf(""%d %d"", &x1, &y1);
        if (x1 == 0 && y1 == 0) break;
        scanf(""%d %d"", &x2, &y2);
        scanf(""%d %d"", &x3, &y3);
        scanf(""%d %d"", &xc, &yc);
        scanf(""%d"", &r);
        
        Point t1 = {x1, y1};
        Point t2 = {x2, y2};
        Point t3 = {x3, y3};
        Point c = {xc, yc};
        
        // Check if circle is inside triangle
        int circleInTriangle = 1;
        if (!pointInTriangle(c, t1, t2, t3)) {
            circleInTriangle = 0;
        } else {
            double d1 = distPointToSegment(c, t1, t2);
            double d2 = distPointToSegment(c, t2, t3);
            double d3 = distPointToSegment(c, t3, t1);
            if (d1 < r - EPS || d2 < r - EPS || d3 < r - EPS) {
                circleInTriangle = 0;
            }
        }
        
        // Check if triangle is inside circle
        int triangleInCircle = 1;
        if (dist(c, t1) > r + EPS || dist(c, t2) > r + EPS || dist(c, t3) > r + EPS) {
            triangleInCircle = 0;
        }
        
        // Check if they intersect
        int intersect = 0;
        double d1 = distPointToSegment(c, t1, t2);
        double d2 = distPointToSegment(c, t2, t3);
        double d3 = distPointToSegment(c, t3, t1);
        
        if (d1 <= r + EPS || d2 <= r + EPS || d3 <= r + EPS) {
            if (pointInTriangle(c, t1, t2, t3) || 
                dist(c, t1) <= r + EPS || 
                dist(c, t2) <= r + EPS || 
                dist(c, t3) <= r + EPS) {
                intersect = 1;
            }
        }
        
        if (circleInTriangle) {
            printf(""a\n"");
        } else if (triangleInCircle) {
            printf(""b\n"");
        } else if (intersect) {
            printf(""c\n"");
        } else {
            printf(""d\n"");
        }
    }
    
    return 0;
}
",0
p00153,"三角形と円
平面上にある三角形と円の位置関係を判定するプログラムを作成してください。対象となる図形はいずれも境界を含むものとします。
三角形は 3 頂点の位置が与えられ、円は中心の位置と半径が与えられます。位置は直交座標系による２つの整数の組によって与えられます。半径も整数で与えられます。
Input
複数のデータセットの並びが入力として与えられます。入力の終わりはゼロふたつの行で示されます。
各データセットは以下の形式で与えられます。
x
1
y
1
x
2
y
2
x
3
y
3
x
c
y
c
r
１行目から３行目に、三角形の第
i
の頂点座標
x
i
,
y
i
が与えられます。４行目に円の中心の座標
x
c
,
y
c
、５行目に円の半径
r
が与えられます。与えられる入力はすべて、1 以上 10,000 以下の整数とします。
データセットの数は 100 を超えません。
Output
入力データセットごとに以下の形式で判定結果を１行に出力します。
円が三角形に含まれる場合
a
三角形が円に含まれる場合
b
それ以外の場合で、共通部分がある場合には
c
共通部分がない場合には
d
Sample Input
1 1
3 1
3 3
3 2
3
3 12
9 3
11 12
8 7
5
15 3
17 7
22 5
7 6
4
6 11
8 2
16 9
10 8
2
0 0
Output for the Sample Input
b
c
d
a",C,"// Aizu Vol-1 0153: Triangle and Circle
// 2017.8.12 bal4u@uu

#include <stdio.h>

long long x[10], y[10];
long long xe, ye, r;

int atSameSide(long long x1, long long y1, long long x2, long long y2,
	long long xa, long long ya, long long xb, long long yb)
{
	long long sa, sb;
	sa = (x2 - x1) * (ya - y1) + (y2 - y1) * (x1 - xa);
	sb = (x2 - x1) * (yb - y1) + (y2 - y1) * (x1 - xb);
	return (sa >= 0 && sb >= 0) || (sa < 0 && sb < 0);
}

int between(long long x1, long long y1, long long x2, long long y2,
	long long x, long long y)
{
	long long sa, sb;
	sa = (x2 - x1) * (x - x1) + (y2 - y1) * (y - y1);
	sb = (x1 - x2) * (x - x2) + (y1 - y2) * (y - y2);
	return (sa >= 0 && sb >= 0) || (sa < 0 && sb < 0);
}

int disCmp(long long x1, long long y1, long long x2, long long y2,
	long long x, long long y, long long r)
{
	long long a, b, c, t;			/* ax + by + c = 0 */
	long long squ;
	a = y1 - y2, b = x2 - x1, c = y2*x1-x2*y1;
	squ = a*a + b*b;
	if (squ == 0) return 0;
	t = (a * x) + (b * y) + c;
	t = t*t - r*r*squ;
	if (t > 0) return 1;
	if (t < 0) return -1;
	return 0;
}

int main()
{
	int i, f;
	long long d[3], rr;

	while (1) {
		for (i = 0; i < 3; i++) {
			scanf(""%lld%lld"", x + i, y + i);
			if (!i && !x[0] && !y[0]) return 0;
			x[i + 3] = x[i], y[i + 3] = y[i];
		}
		scanf(""%lld%lld%lld"", &xe, &ye, &r); rr = r*r;

		for (i = 0; i < 3; i++)
			d[i] = (x[i] - xe)*(x[i] - xe) + (y[i] - ye)*(y[i] - ye);
		if (rr >= d[0] && rr >= d[1] && rr >= d[2]) { puts(""b""); continue; }
		if (rr >= d[0] || rr >= d[1] || rr >= d[2]) { puts(""c""); continue; }

		for (f = 1, i = 0; f && i < 3; i++)
			f = atSameSide(x[i], y[i], x[i + 1], y[i + 1],
				x[i + 2], y[i + 2], xe, ye);
		for (i = 0; i < 3; i++)
			d[i] = disCmp(x[i], y[i], x[i + 1], y[i + 1], xe, ye, r);
		if (f) { puts(d[0] >= 0 && d[1] >= 0 && d[2] >= 0 ? ""a"" : ""c""); continue; }
		if (d[0] > 0 && d[1] > 0 && d[2] > 0) { puts(""d""); continue; }

		for (f = 1, i = 0; f && i < 3; i++)
			if (between(x[i], y[i], x[i + 1], y[i + 1], xe, ye) && d[i] <= 0) f = 0;
		puts(f ? ""d"" : ""c"");
	}
	return 0;
}",1
p00153,"三角形と円
平面上にある三角形と円の位置関係を判定するプログラムを作成してください。対象となる図形はいずれも境界を含むものとします。
三角形は 3 頂点の位置が与えられ、円は中心の位置と半径が与えられます。位置は直交座標系による２つの整数の組によって与えられます。半径も整数で与えられます。
Input
複数のデータセットの並びが入力として与えられます。入力の終わりはゼロふたつの行で示されます。
各データセットは以下の形式で与えられます。
x
1
y
1
x
2
y
2
x
3
y
3
x
c
y
c
r
１行目から３行目に、三角形の第
i
の頂点座標
x
i
,
y
i
が与えられます。４行目に円の中心の座標
x
c
,
y
c
、５行目に円の半径
r
が与えられます。与えられる入力はすべて、1 以上 10,000 以下の整数とします。
データセットの数は 100 を超えません。
Output
入力データセットごとに以下の形式で判定結果を１行に出力します。
円が三角形に含まれる場合
a
三角形が円に含まれる場合
b
それ以外の場合で、共通部分がある場合には
c
共通部分がない場合には
d
Sample Input
1 1
3 1
3 3
3 2
3
3 12
9 3
11 12
8 7
5
15 3
17 7
22 5
7 6
4
6 11
8 2
16 9
10 8
2
0 0
Output for the Sample Input
b
c
d
a",Java,"import java.util.*;
import java.io.*;

public class Main {
    static final double EPS = 1e-9;
    
    static class Point {
        double x, y;
        Point(double x, double y) {
            this.x = x;
            this.y = y;
        }
        Point sub(Point p) {
            return new Point(x - p.x, y - p.y);
        }
        Point add(Point p) {
            return new Point(x + p.x, y + p.y);
        }
        Point mul(double t) {
            return new Point(x * t, y * t);
        }
        double dot(Point p) {
            return x * p.x + y * p.y;
        }
        double cross(Point p) {
            return x * p.y - y * p.x;
        }
        double norm() {
            return Math.sqrt(x * x + y * y);
        }
    }
    
    static double distancePointToSegment(Point p, Point a, Point b) {
        if (a.sub(b).norm() < EPS) return a.sub(p).norm();
        Point ab = b.sub(a);
        Point ap = p.sub(a);
        double t = ap.dot(ab) / ab.dot(ab);
        if (t < 0) return ap.norm();
        if (t > 1) return p.sub(b).norm();
        Point projection = a.add(ab.mul(t));
        return p.sub(projection).norm();
    }
    
    static boolean isPointInTriangle(Point p, Point a, Point b, Point c) {
        double d1 = b.sub(a).cross(p.sub(a));
        double d2 = c.sub(b).cross(p.sub(b));
        double d3 = a.sub(c).cross(p.sub(c));
        
        boolean hasNeg = (d1 < -EPS) || (d2 < -EPS) || (d3 < -EPS);
        boolean hasPos = (d1 > EPS) || (d2 > EPS) || (d3 > EPS);
        
        return !(hasNeg && hasPos);
    }
    
    static boolean circleInTriangle(Point c, double r, Point a, Point b, Point p) {
        if (!isPointInTriangle(c, a, b, p)) return false;
        
        double d1 = distancePointToSegment(c, a, b);
        double d2 = distancePointToSegment(c, b, p);
        double d3 = distancePointToSegment(c, p, a);
        
        return d1 >= r - EPS && d2 >= r - EPS && d3 >= r - EPS;
    }
    
    static boolean triangleInCircle(Point c, double r, Point a, Point b, Point p) {
        double d1 = c.sub(a).norm();
        double d2 = c.sub(b).norm();
        double d3 = c.sub(p).norm();
        
        return d1 <= r + EPS && d2 <= r + EPS && d3 <= r + EPS;
    }
    
    static boolean circleSegmentIntersect(Point c, double r, Point a, Point b) {
        double dist = distancePointToSegment(c, a, b);
        return dist <= r + EPS;
    }
    
    static boolean hasIntersection(Point c, double r, Point a, Point b, Point p) {
        if (circleSegmentIntersect(c, r, a, b)) return true;
        if (circleSegmentIntersect(c, r, b, p)) return true;
        if (circleSegmentIntersect(c, r, p, a)) return true;
        
        if (isPointInTriangle(c, a, b, p)) return true;
        
        return false;
    }
    
    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        String line;
        
        while ((line = br.readLine()) != null) {
            String[] tokens = line.trim().split(""\\s+"");
            if (tokens.length == 2 && tokens[0].equals(""0"") && tokens[1].equals(""0"")) {
                break;
            }
            
            Point p1 = new Point(Double.parseDouble(tokens[0]), Double.parseDouble(tokens[1]));
            
            tokens = br.readLine().trim().split(""\\s+"");
            Point p2 = new Point(Double.parseDouble(tokens[0]), Double.parseDouble(tokens[1]));
            
            tokens = br.readLine().trim().split(""\\s+"");
            Point p3 = new Point(Double.parseDouble(tokens[0]), Double.parseDouble(tokens[1]));
            
            tokens = br.readLine().trim().split(""\\s+"");
            Point center = new Point(Double.parseDouble(tokens[0]), Double.parseDouble(tokens[1]));
            
            tokens = br.readLine().trim().split(""\\s+"");
            double radius = Double.parseDouble(tokens[0]);
            
            if (circleInTriangle(center, radius, p1, p2, p3)) {
                System.out.println(""a"");
            } else if (triangleInCircle(center, radius, p1, p2, p3)) {
                System.out.println(""b"");
            } else if (hasIntersection(center, radius, p1, p2, p3)) {
                System.out.println(""c"");
            } else {
                System.out.println(""d"");
            }
        }
    }
}
",0
p00153,"三角形と円
平面上にある三角形と円の位置関係を判定するプログラムを作成してください。対象となる図形はいずれも境界を含むものとします。
三角形は 3 頂点の位置が与えられ、円は中心の位置と半径が与えられます。位置は直交座標系による２つの整数の組によって与えられます。半径も整数で与えられます。
Input
複数のデータセットの並びが入力として与えられます。入力の終わりはゼロふたつの行で示されます。
各データセットは以下の形式で与えられます。
x
1
y
1
x
2
y
2
x
3
y
3
x
c
y
c
r
１行目から３行目に、三角形の第
i
の頂点座標
x
i
,
y
i
が与えられます。４行目に円の中心の座標
x
c
,
y
c
、５行目に円の半径
r
が与えられます。与えられる入力はすべて、1 以上 10,000 以下の整数とします。
データセットの数は 100 を超えません。
Output
入力データセットごとに以下の形式で判定結果を１行に出力します。
円が三角形に含まれる場合
a
三角形が円に含まれる場合
b
それ以外の場合で、共通部分がある場合には
c
共通部分がない場合には
d
Sample Input
1 1
3 1
3 3
3 2
3
3 12
9 3
11 12
8 7
5
15 3
17 7
22 5
7 6
4
6 11
8 2
16 9
10 8
2
0 0
Output for the Sample Input
b
c
d
a",Java,"import java.awt.geom.Point2D;
import java.util.Scanner;

public class Main {

	public static void main(String[] args) throws Exception {
		Scanner sc = new Scanner(System.in);
		sc.useDelimiter("",|\\s+"");
		while (true) {
			int x1 = sc.nextInt();
			int y1 = sc.nextInt();
			if ((x1 | y1) == 0)
				break;
			int x2 = sc.nextInt();
			int y2 = sc.nextInt();
			int x3 = sc.nextInt();
			int y3 = sc.nextInt();
			int x4 = sc.nextInt();
			int y4 = sc.nextInt();
			int r = sc.nextInt();
			// 1行目 三角形の第1の頂点の座標x1 y1（整数 整数；半角空白区切り）
			// 2行目 三角形の第2の頂点の座標x2 y2（整数 整数；半角空白区切り）
			// 3行目 三角形の第3の頂点の座標x3 y3（整数 整数；半角空白区切り）
			// 4行目 円の中心の座標x4 y4（整数 整数；半角空白区切り）
			// 5行目 円の半径r（整数）
			//
			Point2D.Double[] ps = new Point2D.Double[4];
			ps[0] = new Point2D.Double(x1, y1);
			ps[1] = new Point2D.Double(x2, y2);
			ps[2] = new Point2D.Double(x3, y3);
			ps[3] = new Point2D.Double(x4, y4);
			double max = 0;
			for (int i = 0; i < 3; i++) {

				max = Math.max(max, nor(ps[3], ps[i]));
			}
			if (r * r >= max) {
				System.out.println(""b"");
				continue;
			}
			double min = Double.MAX_VALUE;
			for (int i = 0; i < 3; i++) {
				double dis = Math.max(Line.distanceSP(new Line(ps[i],
						ps[(i + 1) % 3]), ps[3]), Line.distanceSP(new Line(
						ps[i], ps[(i + 1) % 3]), ps[3]));
				min = Math.min(min, dis);
			}
			boolean right = true;
			boolean left = true;
			for (int i = 0; i < 3; i++) {
				double ep = new Line(ps[i], ps[(i + 1) % 3]).ep(new Line(ps[i],
						ps[3]));
				if (ep < 0)
					left = false;
				else if (ep > 0)
					right = false;
			}
			boolean in = left | right;
			if (r <= min && in)
				System.out.println(""a"");
			else if (!in && r < min)
				System.out.println(""d"");
			else
				System.out.println(""c"");
		}
	}

	public static double nor(Point2D.Double p, Point2D.Double q) {
		return (p.x - q.x) * (p.x - q.x) + (p.y - q.y) * (p.y - q.y);
	}
}

// Output
//
// 入力データセットごとに以下の判定結果を出力します。
//
// 円が三角形に含まれる場合 a
// 三角形が円に含まれる場合 b
// それ以外の場合で、共通部分がある場合には c
// 共通部分がない場合には d

class Line {
	public Point2D.Double p1;
	public Point2D.Double p2;

	Line(Point2D.Double p1, Point2D.Double p2) {
		this.p1 = p1;
		this.p2 = p2;
	}

	public double length() {
		return Math.sqrt((p1.x - p2.x) * (p1.x - p2.x) + (p1.y - p2.y)
				* (p1.y - p2.y));
	}

	public double ip(Line l) {
		Point2D.Double q1 = l.p1;
		Point2D.Double q2 = l.p2;
		return (p2.x - p1.x) * (q2.x - q1.x) + (p2.y - p1.y) * (q2.y - q1.y);
	}

	public double ep(Line l) {
		Point2D.Double q1 = l.p1;
		Point2D.Double q2 = l.p2;
		return (p2.x - p1.x) * (q2.y - q1.y) - (p2.y - p1.y) * (q2.x - q1.x);
	}

	public static double distanceSP(Line s, Point2D.Double p) {
		Point2D.Double r = proj(s, p);
		if (intersectSP(s, r))
			return norm(sub(r, p));
		return Math.min(norm(sub(s.p1, p)), norm(sub(s.p2, p)));
	}

	public static boolean intersectSP(Line s, Point2D.Double p) {
		return ccw(s.p1, s.p2, p) == 0;
	}

	public static int ccw(Point2D.Double a, Point2D.Double b, Point2D.Double c) {
		Point2D.Double p = sub(b, a);
		Point2D.Double q = sub(c, a);
		if (extp(p, q) > EPS)
			return 1; // counter clockwise
		if (extp(p, q) < -EPS)
			return -1; // clockwise
		if (inp(p, q) < -EPS)
			return 2; // c--a--b on line
		if (Math.abs(norm(p) - norm(q)) < EPS)
			return -2; // a--b--c on line
		return 0; // a--c--b(or a--c=b) on line
	}

	public static Point2D.Double sub(Point2D.Double p1, Point2D.Double p2) {
		return new Point2D.Double(p1.x - p2.x, p1.y - p2.y);
	}

	public static Point2D.Double proj(Line l, Point2D.Double p) {
		double t = inp(sub(p, l.p1), sub(l.p1, l.p2))
				/ Math.pow(norm(sub(l.p1, l.p2)), 2);
		Point2D.Double tp = sub(l.p1, l.p2);
		return new Point2D.Double(l.p1.x + t * tp.x, l.p1.y + t * tp.y);
	}

	public static double inp(Point2D.Double p1, Point2D.Double p2) {
		return p1.x * p2.x + p1.y * p2.y;
	}

	public static double extp(Point2D.Double p1, Point2D.Double p2) {
		return p1.x * p2.y - p2.x * p1.y;
	}

	public static final double EPS = 1.0e-8;

	public static double norm(Point2D.Double p) {
		return Math.hypot(p.x, p.y);
	}

	public double disToPoint(Point2D.Double q1) {
		Line p1q1 = new Line(p1, q1);
		double ip1 = p1q1.ip(this);
		double ip2 = this.ip(this);
		if (ip1 <= 0)
			return p1q1.length();
		else if (0 < ip1 && ip1 < ip2) {
			double d2 = ip1 / this.length();
			double size = p1q1.length();
			return Math.sqrt(size * size - d2 * d2);
		} else {
			Line p2q1 = new Line(p2, q1);
			return p2q1.length();
		}
	}

	public boolean isCross(Line q1q2) {
		Point2D.Double q1 = q1q2.p1;
		Point2D.Double q2 = q1q2.p2;
		Line p1q1 = new Line(p1, q1);
		Line p1q2 = new Line(p1, q2);
		Line q1p1 = new Line(q1, p1);
		Line q1p2 = new Line(q1, p2);
		if (this.ep(p1q1) * this.ep(p1q2) < 0
				&& q1q2.ep(q1p1) * q1q2.ep(q1p2) < 0)
			return true;
		else
			return false;
	}

	public double minDistance(Line q1q2) {
		if (this.isCross(q1q2))
			return 0;
		double ans = Double.MAX_VALUE;
		Point2D.Double q1 = q1q2.p1;
		Point2D.Double q2 = q1q2.p2;
		ans = Math.min(ans, this.disToPoint(q1));
		ans = Math.min(ans, this.disToPoint(q2));
		ans = Math.min(ans, q1q2.disToPoint(p1));
		ans = Math.min(ans, q1q2.disToPoint(p2));
		return ans;
	}

	public String toString() {
		return p1 + ""=>"" + p2;
	}
}",1
p00153,"三角形と円
平面上にある三角形と円の位置関係を判定するプログラムを作成してください。対象となる図形はいずれも境界を含むものとします。
三角形は 3 頂点の位置が与えられ、円は中心の位置と半径が与えられます。位置は直交座標系による２つの整数の組によって与えられます。半径も整数で与えられます。
Input
複数のデータセットの並びが入力として与えられます。入力の終わりはゼロふたつの行で示されます。
各データセットは以下の形式で与えられます。
x
1
y
1
x
2
y
2
x
3
y
3
x
c
y
c
r
１行目から３行目に、三角形の第
i
の頂点座標
x
i
,
y
i
が与えられます。４行目に円の中心の座標
x
c
,
y
c
、５行目に円の半径
r
が与えられます。与えられる入力はすべて、1 以上 10,000 以下の整数とします。
データセットの数は 100 を超えません。
Output
入力データセットごとに以下の形式で判定結果を１行に出力します。
円が三角形に含まれる場合
a
三角形が円に含まれる場合
b
それ以外の場合で、共通部分がある場合には
c
共通部分がない場合には
d
Sample Input
1 1
3 1
3 3
3 2
3
3 12
9 3
11 12
8 7
5
15 3
17 7
22 5
7 6
4
6 11
8 2
16 9
10 8
2
0 0
Output for the Sample Input
b
c
d
a",Python,"import sys
from math import sqrt

def read_input():
    datasets = []
    lines = sys.stdin.read().strip().split('\n')
    i = 0
    while i < len(lines):
        parts = lines[i].split()
        if len(parts) == 2 and parts[0] == '0' and parts[1] == '0':
            break
        
        # Read 3 triangle vertices
        x1, y1 = map(int, lines[i].split())
        x2, y2 = map(int, lines[i+1].split())
        x3, y3 = map(int, lines[i+2].split())
        
        # Read circle center and radius
        xc, yc = map(int, lines[i+3].split())
        r = int(lines[i+4])
        
        datasets.append(((x1, y1), (x2, y2), (x3, y3), (xc, yc), r))
        i += 5
    
    return datasets

def distance(p1, p2):
    return sqrt((p1[0] - p2[0])**2 + (p1[1] - p2[1])**2)

def point_to_segment_distance(p, a, b):
    ax, ay = a
    bx, by = b
    px, py = p
    
    abx = bx - ax
    aby = by - ay
    apx = px - ax
    apy = py - ay
    
    ab_ab = abx * abx + aby * aby
    if ab_ab == 0:
        return distance(p, a)
    
    ap_ab = apx * abx + apy * aby
    t = max(0, min(1, ap_ab / ab_ab))
    
    closest_x = ax + t * abx
    closest_y = ay + t * aby
    
    return distance(p, (closest_x, closest_y))

def point_in_triangle(p, v1, v2, v3):
    def sign(p1, p2, p3):
        return (p1[0] - p3[0]) * (p2[1] - p3[1]) - (p2[0] - p3[0]) * (p1[1] - p3[1])
    
    d1 = sign(p, v1, v2)
    d2 = sign(p, v2, v3)
    d3 = sign(p, v3, v1)
    
    has_neg = (d1 < 0) or (d2 < 0) or (d3 < 0)
    has_pos = (d1 > 0) or (d2 > 0) or (d3 > 0)
    
    return not (has_neg and has_pos)

def circle_in_triangle(v1, v2, v3, center, r):
    # Check if center is in triangle
    if not point_in_triangle(center, v1, v2, v3):
        return False
    
    # Check distance from center to all edges
    d1 = point_to_segment_distance(center, v1, v2)
    d2 = point_to_segment_distance(center, v2, v3)
    d3 = point_to_segment_distance(center, v3, v1)
    
    return d1 >= r and d2 >= r and d3 >= r

def triangle_in_circle(v1, v2, v3, center, r):
    d1 = distance(center, v1)
    d2 = distance(center, v2)
    d3 = distance(center, v3)
    
    return d1 <= r and d2 <= r and d3 <= r

def circle_triangle_intersect(v1, v2, v3, center, r):
    # Check if any vertex is inside or on the circle
    for v in [v1, v2, v3]:
        if distance(center, v) <= r:
            return True
    
    # Check if center is inside triangle
    if point_in_triangle(center, v1, v2, v3):
        return True
    
    # Check if any edge intersects the circle
    for a, b in [(v1, v2), (v2, v3), (v3, v1)]:
        if point_to_segment_distance(center, a, b) <= r:
            return True
    
    return False

def solve(v1, v2, v3, center, r):
    if circle_in_triangle(v1, v2, v3, center, r):
        return 'a'
    elif triangle_in_circle(v1, v2, v3, center, r):
        return 'b'
    elif circle_triangle_intersect(v1, v2, v3, center, r):
        return 'c'
    else:
        return 'd'

datasets = read_input()
for v1, v2, v3, center, r in datasets:
    print(solve(v1, v2, v3, center, r))
",0
p00153,"三角形と円
平面上にある三角形と円の位置関係を判定するプログラムを作成してください。対象となる図形はいずれも境界を含むものとします。
三角形は 3 頂点の位置が与えられ、円は中心の位置と半径が与えられます。位置は直交座標系による２つの整数の組によって与えられます。半径も整数で与えられます。
Input
複数のデータセットの並びが入力として与えられます。入力の終わりはゼロふたつの行で示されます。
各データセットは以下の形式で与えられます。
x
1
y
1
x
2
y
2
x
3
y
3
x
c
y
c
r
１行目から３行目に、三角形の第
i
の頂点座標
x
i
,
y
i
が与えられます。４行目に円の中心の座標
x
c
,
y
c
、５行目に円の半径
r
が与えられます。与えられる入力はすべて、1 以上 10,000 以下の整数とします。
データセットの数は 100 を超えません。
Output
入力データセットごとに以下の形式で判定結果を１行に出力します。
円が三角形に含まれる場合
a
三角形が円に含まれる場合
b
それ以外の場合で、共通部分がある場合には
c
共通部分がない場合には
d
Sample Input
1 1
3 1
3 3
3 2
3
3 12
9 3
11 12
8 7
5
15 3
17 7
22 5
7 6
4
6 11
8 2
16 9
10 8
2
0 0
Output for the Sample Input
b
c
d
a",Python,"def In(): return map(int,raw_input().split())
def D(a,b): return ((a[0]-b[0])**2+(a[1]-b[1])**2)**.5
def side(a, b, c): return (c[1]-a[1])*(b[0]-a[0])-(b[1]-a[1])*(c[0]-a[0])>0
def isIn(x,p0,p1,p2): return (side(p0,p1,x)==side(p1,p2,x)==side(p2,p0,x))
def S(a,b,c): return abs(a[0]*(b[1]-c[1])+b[0]*(c[1]-a[1])+c[0]*(a[1]-b[1]))/2.0
def H(P1,P2,P3): return 2*S(P1,P2,P3)/D(P2,P3)
def CinT(P4,r,P1,P2,P3):
  f1 = isIn(P4,P1,P2,P3)
  f = [H(P4,P1,P2)>=r, H(P4,P2,P3)>=r, H(P4,P3,P1)>=r]
  if f1:
    if all(f): return 1
    elif any(f): return 3
  return 0

def TinC(P4,r,P1,P2,P3):
  f = [D(P4,P1)<=r, D(P4,P2)<=r, D(P4,P3)<=r]
  if all(f): return 2
  elif any(f): return 3
  return 0
  
while 1:
  P1 = In()
  if P1[0]==P1[1]==0: break
  P2 = In()
  P3 = In()
  P4 = In()
  r = int(raw_input())
  f = CinT(P4,r,P1,P2,P3)
  if not f: f = TinC(P4,r,P1,P2,P3)
  print 'dabc'[f]",1
p00154,"カードの組み合わせ
整数が書いてあるカードが何枚か入っている袋を使ってゲームをしましょう。各回のゲームで参加者はまず、好きな数
n
を一つ宣言します。そして、袋の中から適当な枚数だけカードを一度に取り出して、それらのカードに書かれた数の総和が
n
に等しければ豪華賞品がもらえます。なお、それぞれのゲーム終了後カードは袋に戻されます。
袋の中の
m
種類のカードの情報および、
g
回のゲームで参加者が宣言した数を入力とし、それぞれのゲームで豪華商品をもらえるカードの組み合わせが何通りあるかを出力するプログラムを作成してください。
Input
複数のデータセットの並びが入力として与えられます。入力の終わりはゼロひとつの行で示されます。
各データセットは以下の形式で与えられます。
m
a
1
b
1
a
2
b
2
:
a
m
b
m
g
n
1
n
2
:
n
g
１行目にカードの種類数
m
（1 ≤
m
≤ 7）、続く
m
行に
i
種類目のカードに書かれた整数
a
i
(1 ≤
a
i
≤ 100) とその枚数
b
i
(1 ≤
b
i
≤ 10) が空白区切りで与えられます。
続く行にゲームの回数
g
(1 ≤
g
≤ 10)、続く
g
行にゲーム
i
で宣言された整数
n
i
(1 ≤
n
i
≤ 1,000) が与えられます。
データセットの数は 100 を超えない。
Output
入力データセットごとに、
i
行目にゲーム
i
で豪華賞品がもらえるカードの組み合わせ数を出力します。
Sample Input
5
1 10
5 3
10 3
25 2
50 2
4
120
500
100
168
7
1 10
3 10
5 10
10 10
25 10
50 10
100 10
3
452
574
787
0
Output for the Sample Input
16
0
12
7
9789
13658
17466",C,"#include <stdio.h>

int m, g;
int a[7], b[7];
int n;
int count;

void dfs(int idx, int sum) {
    if (idx == m) {
        if (sum == n) {
            count++;
        }
        return;
    }
    
    for (int i = 0; i <= b[idx]; i++) {
        dfs(idx + 1, sum + i * a[idx]);
    }
}

int main() {
    while (1) {
        scanf(""%d"", &m);
        if (m == 0) break;
        
        for (int i = 0; i < m; i++) {
            scanf(""%d %d"", &a[i], &b[i]);
        }
        
        scanf(""%d"", &g);
        
        for (int i = 0; i < g; i++) {
            scanf(""%d"", &n);
            count = 0;
            dfs(0, 0);
            printf(""%d\n"", count);
        }
    }
    
    return 0;
}
",0
p00154,"カードの組み合わせ
整数が書いてあるカードが何枚か入っている袋を使ってゲームをしましょう。各回のゲームで参加者はまず、好きな数
n
を一つ宣言します。そして、袋の中から適当な枚数だけカードを一度に取り出して、それらのカードに書かれた数の総和が
n
に等しければ豪華賞品がもらえます。なお、それぞれのゲーム終了後カードは袋に戻されます。
袋の中の
m
種類のカードの情報および、
g
回のゲームで参加者が宣言した数を入力とし、それぞれのゲームで豪華商品をもらえるカードの組み合わせが何通りあるかを出力するプログラムを作成してください。
Input
複数のデータセットの並びが入力として与えられます。入力の終わりはゼロひとつの行で示されます。
各データセットは以下の形式で与えられます。
m
a
1
b
1
a
2
b
2
:
a
m
b
m
g
n
1
n
2
:
n
g
１行目にカードの種類数
m
（1 ≤
m
≤ 7）、続く
m
行に
i
種類目のカードに書かれた整数
a
i
(1 ≤
a
i
≤ 100) とその枚数
b
i
(1 ≤
b
i
≤ 10) が空白区切りで与えられます。
続く行にゲームの回数
g
(1 ≤
g
≤ 10)、続く
g
行にゲーム
i
で宣言された整数
n
i
(1 ≤
n
i
≤ 1,000) が与えられます。
データセットの数は 100 を超えない。
Output
入力データセットごとに、
i
行目にゲーム
i
で豪華賞品がもらえるカードの組み合わせ数を出力します。
Sample Input
5
1 10
5 3
10 3
25 2
50 2
4
120
500
100
168
7
1 10
3 10
5 10
10 10
25 10
50 10
100 10
3
452
574
787
0
Output for the Sample Input
16
0
12
7
9789
13658
17466",C,"#include <stdio.h>

int count;
void solve(int depth, int card[][2], int n, int total, int goal) {
	int i;
	if(depth == n) {
		if(total == goal)
			count++;
		return;
	}
	
	for(i=0;i<=card[depth][1];i++) {
		solve(depth+1, card, n, total + card[depth][0] * i, goal);
	}
}

int main(void) {
	int n, g;
	int i;
	int goal;
	int j[1001];
	int card[1001][2];
	while(1) {
		count = 0;
		scanf(""%d\n"", &n);
		if(n==0) break;
		for(i=0;i<n;i++) {
			scanf(""%d %d\n"", &card[i][0], &card[i][1]);
		}
		scanf(""%d\n"", &g);
		for(i-0;i<g;i++) {
			scanf(""%d\n"", &goal);
			solve(0, card, n, 0, goal);	
			printf(""%d\n"", count);
		}
	}
	return 0;
}",1
p00154,"カードの組み合わせ
整数が書いてあるカードが何枚か入っている袋を使ってゲームをしましょう。各回のゲームで参加者はまず、好きな数
n
を一つ宣言します。そして、袋の中から適当な枚数だけカードを一度に取り出して、それらのカードに書かれた数の総和が
n
に等しければ豪華賞品がもらえます。なお、それぞれのゲーム終了後カードは袋に戻されます。
袋の中の
m
種類のカードの情報および、
g
回のゲームで参加者が宣言した数を入力とし、それぞれのゲームで豪華商品をもらえるカードの組み合わせが何通りあるかを出力するプログラムを作成してください。
Input
複数のデータセットの並びが入力として与えられます。入力の終わりはゼロひとつの行で示されます。
各データセットは以下の形式で与えられます。
m
a
1
b
1
a
2
b
2
:
a
m
b
m
g
n
1
n
2
:
n
g
１行目にカードの種類数
m
（1 ≤
m
≤ 7）、続く
m
行に
i
種類目のカードに書かれた整数
a
i
(1 ≤
a
i
≤ 100) とその枚数
b
i
(1 ≤
b
i
≤ 10) が空白区切りで与えられます。
続く行にゲームの回数
g
(1 ≤
g
≤ 10)、続く
g
行にゲーム
i
で宣言された整数
n
i
(1 ≤
n
i
≤ 1,000) が与えられます。
データセットの数は 100 を超えない。
Output
入力データセットごとに、
i
行目にゲーム
i
で豪華賞品がもらえるカードの組み合わせ数を出力します。
Sample Input
5
1 10
5 3
10 3
25 2
50 2
4
120
500
100
168
7
1 10
3 10
5 10
10 10
25 10
50 10
100 10
3
452
574
787
0
Output for the Sample Input
16
0
12
7
9789
13658
17466",Java,"import java.util.*;

public class Main {
    static int[] values;
    static int[] counts;
    static int m;
    
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        
        while (true) {
            m = sc.nextInt();
            if (m == 0) break;
            
            values = new int[m];
            counts = new int[m];
            
            for (int i = 0; i < m; i++) {
                values[i] = sc.nextInt();
                counts[i] = sc.nextInt();
            }
            
            int g = sc.nextInt();
            for (int i = 0; i < g; i++) {
                int n = sc.nextInt();
                int result = countCombinations(n);
                System.out.println(result);
            }
        }
        sc.close();
    }
    
    static int countCombinations(int target) {
        return dfs(0, target);
    }
    
    static int dfs(int index, int remaining) {
        if (remaining == 0) {
            return 1;
        }
        if (remaining < 0 || index >= m) {
            return 0;
        }
        
        int total = 0;
        for (int i = 0; i <= counts[index]; i++) {
            int newRemaining = remaining - (i * values[index]);
            if (newRemaining < 0) break;
            total += dfs(index + 1, newRemaining);
        }
        
        return total;
    }
}
",0
p00154,"カードの組み合わせ
整数が書いてあるカードが何枚か入っている袋を使ってゲームをしましょう。各回のゲームで参加者はまず、好きな数
n
を一つ宣言します。そして、袋の中から適当な枚数だけカードを一度に取り出して、それらのカードに書かれた数の総和が
n
に等しければ豪華賞品がもらえます。なお、それぞれのゲーム終了後カードは袋に戻されます。
袋の中の
m
種類のカードの情報および、
g
回のゲームで参加者が宣言した数を入力とし、それぞれのゲームで豪華商品をもらえるカードの組み合わせが何通りあるかを出力するプログラムを作成してください。
Input
複数のデータセットの並びが入力として与えられます。入力の終わりはゼロひとつの行で示されます。
各データセットは以下の形式で与えられます。
m
a
1
b
1
a
2
b
2
:
a
m
b
m
g
n
1
n
2
:
n
g
１行目にカードの種類数
m
（1 ≤
m
≤ 7）、続く
m
行に
i
種類目のカードに書かれた整数
a
i
(1 ≤
a
i
≤ 100) とその枚数
b
i
(1 ≤
b
i
≤ 10) が空白区切りで与えられます。
続く行にゲームの回数
g
(1 ≤
g
≤ 10)、続く
g
行にゲーム
i
で宣言された整数
n
i
(1 ≤
n
i
≤ 1,000) が与えられます。
データセットの数は 100 を超えない。
Output
入力データセットごとに、
i
行目にゲーム
i
で豪華賞品がもらえるカードの組み合わせ数を出力します。
Sample Input
5
1 10
5 3
10 3
25 2
50 2
4
120
500
100
168
7
1 10
3 10
5 10
10 10
25 10
50 10
100 10
3
452
574
787
0
Output for the Sample Input
16
0
12
7
9789
13658
17466",Java,"import java.util.*;

public class AOJ_0154{
    class Card{
        int a;
        int b;
        Card(int a, int b){
            this.a = a;
            this.b = b;
        }
    }
    void run(){
        Scanner sc = new Scanner(System.in);
        while(true){
            int[] card_num = new int[101];
            int m = sc.nextInt();
            if(m==0){
                break;
            }
            Card[] cards = new Card[m];
            for(int i = 0; i < m; i++){
                cards[i] = new Card(sc.nextInt(), sc.nextInt());
            }
            int ub = 7*100*10;
            int[] dp = new int[ub];
            dp[0] = 1;
            for(int i = 0; i < m; i++){
                for(int ii = 7 * 100 * 10 - cards[i].a -1; ii >= 0; ii--){
                    for(int iii = 1; iii <= cards[i].b; iii++){
                        if(ii + cards[i].a*iii < ub-1){
                            dp[ii + cards[i].a*iii] += dp[ii];
                        }
                    }
                }
            }
            /*
              System.out.println(Arrays.toString(dp));
              for(int i = 0; i < 100; i++){
              System.out.println(i + "" : "" + dp[i]);
              }
            */
            int g = sc.nextInt();
            for(int i = 0; i < g; i++){
                System.out.println(dp[sc.nextInt()]);
            }
        }
    }
    public static void main(String[] args){
        new AOJ_0154().run();
    }
}",1
p00154,"カードの組み合わせ
整数が書いてあるカードが何枚か入っている袋を使ってゲームをしましょう。各回のゲームで参加者はまず、好きな数
n
を一つ宣言します。そして、袋の中から適当な枚数だけカードを一度に取り出して、それらのカードに書かれた数の総和が
n
に等しければ豪華賞品がもらえます。なお、それぞれのゲーム終了後カードは袋に戻されます。
袋の中の
m
種類のカードの情報および、
g
回のゲームで参加者が宣言した数を入力とし、それぞれのゲームで豪華商品をもらえるカードの組み合わせが何通りあるかを出力するプログラムを作成してください。
Input
複数のデータセットの並びが入力として与えられます。入力の終わりはゼロひとつの行で示されます。
各データセットは以下の形式で与えられます。
m
a
1
b
1
a
2
b
2
:
a
m
b
m
g
n
1
n
2
:
n
g
１行目にカードの種類数
m
（1 ≤
m
≤ 7）、続く
m
行に
i
種類目のカードに書かれた整数
a
i
(1 ≤
a
i
≤ 100) とその枚数
b
i
(1 ≤
b
i
≤ 10) が空白区切りで与えられます。
続く行にゲームの回数
g
(1 ≤
g
≤ 10)、続く
g
行にゲーム
i
で宣言された整数
n
i
(1 ≤
n
i
≤ 1,000) が与えられます。
データセットの数は 100 を超えない。
Output
入力データセットごとに、
i
行目にゲーム
i
で豪華賞品がもらえるカードの組み合わせ数を出力します。
Sample Input
5
1 10
5 3
10 3
25 2
50 2
4
120
500
100
168
7
1 10
3 10
5 10
10 10
25 10
50 10
100 10
3
452
574
787
0
Output for the Sample Input
16
0
12
7
9789
13658
17466",Python,"import sys
from itertools import product

def count_combinations(cards, target):
    count = 0
    # Generate all possible combinations
    ranges = [range(b + 1) for a, b in cards]
    
    for combination in product(*ranges):
        total = sum(combination[i] * cards[i][0] for i in range(len(cards)))
        if total == target:
            count += 1
    
    return count

def main():
    lines = []
    for line in sys.stdin:
        lines.append(line.strip())
    
    idx = 0
    while idx < len(lines):
        m = int(lines[idx])
        if m == 0:
            break
        
        idx += 1
        cards = []
        for _ in range(m):
            a, b = map(int, lines[idx].split())
            cards.append((a, b))
            idx += 1
        
        g = int(lines[idx])
        idx += 1
        
        for _ in range(g):
            n = int(lines[idx])
            idx += 1
            result = count_combinations(cards, n)
            print(result)

if __name__ == ""__main__"":
    main()
",0
p00154,"カードの組み合わせ
整数が書いてあるカードが何枚か入っている袋を使ってゲームをしましょう。各回のゲームで参加者はまず、好きな数
n
を一つ宣言します。そして、袋の中から適当な枚数だけカードを一度に取り出して、それらのカードに書かれた数の総和が
n
に等しければ豪華賞品がもらえます。なお、それぞれのゲーム終了後カードは袋に戻されます。
袋の中の
m
種類のカードの情報および、
g
回のゲームで参加者が宣言した数を入力とし、それぞれのゲームで豪華商品をもらえるカードの組み合わせが何通りあるかを出力するプログラムを作成してください。
Input
複数のデータセットの並びが入力として与えられます。入力の終わりはゼロひとつの行で示されます。
各データセットは以下の形式で与えられます。
m
a
1
b
1
a
2
b
2
:
a
m
b
m
g
n
1
n
2
:
n
g
１行目にカードの種類数
m
（1 ≤
m
≤ 7）、続く
m
行に
i
種類目のカードに書かれた整数
a
i
(1 ≤
a
i
≤ 100) とその枚数
b
i
(1 ≤
b
i
≤ 10) が空白区切りで与えられます。
続く行にゲームの回数
g
(1 ≤
g
≤ 10)、続く
g
行にゲーム
i
で宣言された整数
n
i
(1 ≤
n
i
≤ 1,000) が与えられます。
データセットの数は 100 を超えない。
Output
入力データセットごとに、
i
行目にゲーム
i
で豪華賞品がもらえるカードの組み合わせ数を出力します。
Sample Input
5
1 10
5 3
10 3
25 2
50 2
4
120
500
100
168
7
1 10
3 10
5 10
10 10
25 10
50 10
100 10
3
452
574
787
0
Output for the Sample Input
16
0
12
7
9789
13658
17466",Python,"import sys
from array import array

def main():
	while True:
		m = input()
		if m == 0: return 0
		dp = [array('I', [0] * 1001) for i in range(m + 1)]
		dp[0][0] = 1
		for i in xrange(m):
			v, c = map(int, raw_input().split())
			for j in xrange(1001):
				for k in xrange(c + 1):
					next = j + v * k
					if next > 1000: continue
					dp[i + 1][next] += dp[i][j]
		n = input()
		for i in range(n):
			x = input()
			print dp[m][x]

if __name__ == '__main__':
	sys.exit(main())",1
p00155,"スパイダー人
正義のヒーロー「スパイダー人」は、腕からロープを出してビルからビルへ飛び移ることができます。しかし、ロープが短いので自分からの距離が 50 以下のビルにしか移動できません。それより遠くのビルに移動するには、一旦別のビルに飛び移らなくてはなりません。
ビルの数
n
、
n
個のビルの情報、スパイダー人の移動開始位置及び目的地を入力とし、その移動の最短経路を出力するプログラムを作成してください。どのようにビルを経由しても目標のビルに移動できない場合は NA と出力してください。各ビルは点として扱い、最短距離で移動するビルの経由方法が２つ以上存在することはないものとします。
Input
複数のデータセットの並びが入力として与えられます。入力の終わりはゼロひとつの行で示されます。
各データセットは以下の形式で与えられます。
n
b
1
x
1
y
1
b
2
x
2
y
2
:
b
n
x
n
y
n
m
s
1
g
1
s
2
g
2
:
s
m
g
m
１行目にビルの数
n
(1 ≤
n
≤ 100)、続く
n
行に
i
番目のビルのビル番号
b
i
(1 ≤
b
i
≤
n
)、そのビルのx座標とy座標を表す整数
x
i
,
y
i
(-1000 ≤
x
i
,
y
i
≤ 1000) が空白区切りで与えられます。
続く行に移動情報の個数
m
(1 ≤
m
≤ 100)、続く
m
行に
i
番目の移動情報が与えられます。各移動情報として、移動を開始するビルの番号
s
i
と目的地ビルの番号
g
i
が空白区切りで与えられます。
データセットの数は 10 を超えません。
Output
入力データセットごとに次の形式で出力します。
i
行目に
i
番目の移動情報に対する経路または NA を１行に出力します。各経路は以下の形式で出力します。
s
i
br
i1
br
i2
...
g
i
br
ij
は
i
番目の移動情報における、
j
番目に経由するビルの番号を表します。
Sample Input
4
1 0 0
2 30 0
3 60 40
4 0 60
2
1 3
1 4
22
1 0 0
2 150 40
3 30 20
4 180 150
5 40 80
6 130 130
7 72 28
8 172 118
9 50 50
10 160 82
11 90 105
12 144 131
13 130 64
14 80 140
15 38 117
16 190 90
17 60 100
18 100 70
19 130 100
20 71 69
21 200 110
22 120 150
1
1 22
0
Output for the Sample Input
1 2 3
NA
1 3 9 20 11 6 22",C,"#include <stdio.h>
#include <stdlib.h>
#include <math.h>
#include <string.h>

#define MAX_N 101
#define INF 1e9

typedef struct {
    int id;
    int x, y;
} Building;

Building buildings[MAX_N];
int n;
double dist[MAX_N][MAX_N];
int next_node[MAX_N][MAX_N];

double calc_dist(int i, int j) {
    double dx = buildings[i].x - buildings[j].x;
    double dy = buildings[i].y - buildings[j].y;
    return sqrt(dx * dx + dy * dy);
}

void floyd_warshall() {
    for (int i = 0; i < n; i++) {
        for (int j = 0; j < n; j++) {
            if (i == j) {
                dist[i][j] = 0;
                next_node[i][j] = -1;
            } else {
                double d = calc_dist(i, j);
                if (d <= 50.0) {
                    dist[i][j] = d;
                    next_node[i][j] = j;
                } else {
                    dist[i][j] = INF;
                    next_node[i][j] = -1;
                }
            }
        }
    }
    
    for (int k = 0; k < n; k++) {
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < n; j++) {
                if (dist[i][k] + dist[k][j] < dist[i][j]) {
                    dist[i][j] = dist[i][k] + dist[k][j];
                    next_node[i][j] = next_node[i][k];
                }
            }
        }
    }
}

void print_path(int start, int end) {
    if (dist[start][end] >= INF) {
        printf(""NA\n"");
        return;
    }
    
    printf(""%d"", buildings[start].id);
    int current = start;
    while (current != end) {
        current = next_node[current][end];
        printf("" %d"", buildings[current].id);
    }
    printf(""\n"");
}

int main() {
    while (1) {
        scanf(""%d"", &n);
        if (n == 0) break;
        
        for (int i = 0; i < n; i++) {
            scanf(""%d %d %d"", &buildings[i].id, &buildings[i].x, &buildings[i].y);
        }
        
        floyd_warshall();
        
        int m;
        scanf(""%d"", &m);
        
        for (int i = 0; i < m; i++) {
            int s, g;
            scanf(""%d %d"", &s, &g);
            
            int si = -1, gi = -1;
            for (int j = 0; j < n; j++) {
                if (buildings[j].id == s) si = j;
                if (buildings[j].id == g) gi = j;
            }
            
            print_path(si, gi);
        }
    }
    
    return 0;
}
",0
p00155,"スパイダー人
正義のヒーロー「スパイダー人」は、腕からロープを出してビルからビルへ飛び移ることができます。しかし、ロープが短いので自分からの距離が 50 以下のビルにしか移動できません。それより遠くのビルに移動するには、一旦別のビルに飛び移らなくてはなりません。
ビルの数
n
、
n
個のビルの情報、スパイダー人の移動開始位置及び目的地を入力とし、その移動の最短経路を出力するプログラムを作成してください。どのようにビルを経由しても目標のビルに移動できない場合は NA と出力してください。各ビルは点として扱い、最短距離で移動するビルの経由方法が２つ以上存在することはないものとします。
Input
複数のデータセットの並びが入力として与えられます。入力の終わりはゼロひとつの行で示されます。
各データセットは以下の形式で与えられます。
n
b
1
x
1
y
1
b
2
x
2
y
2
:
b
n
x
n
y
n
m
s
1
g
1
s
2
g
2
:
s
m
g
m
１行目にビルの数
n
(1 ≤
n
≤ 100)、続く
n
行に
i
番目のビルのビル番号
b
i
(1 ≤
b
i
≤
n
)、そのビルのx座標とy座標を表す整数
x
i
,
y
i
(-1000 ≤
x
i
,
y
i
≤ 1000) が空白区切りで与えられます。
続く行に移動情報の個数
m
(1 ≤
m
≤ 100)、続く
m
行に
i
番目の移動情報が与えられます。各移動情報として、移動を開始するビルの番号
s
i
と目的地ビルの番号
g
i
が空白区切りで与えられます。
データセットの数は 10 を超えません。
Output
入力データセットごとに次の形式で出力します。
i
行目に
i
番目の移動情報に対する経路または NA を１行に出力します。各経路は以下の形式で出力します。
s
i
br
i1
br
i2
...
g
i
br
ij
は
i
番目の移動情報における、
j
番目に経由するビルの番号を表します。
Sample Input
4
1 0 0
2 30 0
3 60 40
4 0 60
2
1 3
1 4
22
1 0 0
2 150 40
3 30 20
4 180 150
5 40 80
6 130 130
7 72 28
8 172 118
9 50 50
10 160 82
11 90 105
12 144 131
13 130 64
14 80 140
15 38 117
16 190 90
17 60 100
18 100 70
19 130 100
20 71 69
21 200 110
22 120 150
1
1 22
0
Output for the Sample Input
1 2 3
NA
1 3 9 20 11 6 22",C,"//from PKU1125
#define M 101
double dist[M][M],d;
next[M][M],x[M],y[M];
main(){
	int a,b,k,n,i,j;
	for(;scanf(""%d"",&n),n;){
		/*initialize*/
		for(i=1;i<=n;i++)scanf(""%d"",&a),scanf(""%d%d"",x+a,y+a);
		for(i=1;i<=n;i++)for(j=1;j<=n;next[i][j]=j,j++)
			dist[i][j]=(d=hypot(x[i]-x[j],y[i]-y[j]))<50.1?d:999;

		{/*warshall-floyd*/
			int k,i,j;
			for(k=1;k<=n;k++)
				for(i=1;i<=n;i++)
					for(j=1;j<=n;j++){
						if(dist[i][j]>dist[i][k]+dist[k][j])
							dist[i][j]=dist[i][k]+dist[k][j],next[i][j]=next[i][k];
					}
		}

		{/*query*/
			for(scanf(""%d"",&k);k;k--){
				scanf(""%d%d"",&a,&b);
				if(dist[a][b]>998)puts(""NA"");
				else{
					for(j=a;j!=b;j=next[j][b])printf(""%d "",j);
					printf(""%d\n"",b);
				}
			}
		}
	}exit(0);
}",1
p00155,"スパイダー人
正義のヒーロー「スパイダー人」は、腕からロープを出してビルからビルへ飛び移ることができます。しかし、ロープが短いので自分からの距離が 50 以下のビルにしか移動できません。それより遠くのビルに移動するには、一旦別のビルに飛び移らなくてはなりません。
ビルの数
n
、
n
個のビルの情報、スパイダー人の移動開始位置及び目的地を入力とし、その移動の最短経路を出力するプログラムを作成してください。どのようにビルを経由しても目標のビルに移動できない場合は NA と出力してください。各ビルは点として扱い、最短距離で移動するビルの経由方法が２つ以上存在することはないものとします。
Input
複数のデータセットの並びが入力として与えられます。入力の終わりはゼロひとつの行で示されます。
各データセットは以下の形式で与えられます。
n
b
1
x
1
y
1
b
2
x
2
y
2
:
b
n
x
n
y
n
m
s
1
g
1
s
2
g
2
:
s
m
g
m
１行目にビルの数
n
(1 ≤
n
≤ 100)、続く
n
行に
i
番目のビルのビル番号
b
i
(1 ≤
b
i
≤
n
)、そのビルのx座標とy座標を表す整数
x
i
,
y
i
(-1000 ≤
x
i
,
y
i
≤ 1000) が空白区切りで与えられます。
続く行に移動情報の個数
m
(1 ≤
m
≤ 100)、続く
m
行に
i
番目の移動情報が与えられます。各移動情報として、移動を開始するビルの番号
s
i
と目的地ビルの番号
g
i
が空白区切りで与えられます。
データセットの数は 10 を超えません。
Output
入力データセットごとに次の形式で出力します。
i
行目に
i
番目の移動情報に対する経路または NA を１行に出力します。各経路は以下の形式で出力します。
s
i
br
i1
br
i2
...
g
i
br
ij
は
i
番目の移動情報における、
j
番目に経由するビルの番号を表します。
Sample Input
4
1 0 0
2 30 0
3 60 40
4 0 60
2
1 3
1 4
22
1 0 0
2 150 40
3 30 20
4 180 150
5 40 80
6 130 130
7 72 28
8 172 118
9 50 50
10 160 82
11 90 105
12 144 131
13 130 64
14 80 140
15 38 117
16 190 90
17 60 100
18 100 70
19 130 100
20 71 69
21 200 110
22 120 150
1
1 22
0
Output for the Sample Input
1 2 3
NA
1 3 9 20 11 6 22",Java,"import java.util.*;

public class Main {
    static class Building {
        int id;
        int x, y;
        
        Building(int id, int x, int y) {
            this.id = id;
            this.x = x;
            this.y = y;
        }
        
        double distance(Building other) {
            return Math.sqrt((x - other.x) * (x - other.x) + (y - other.y) * (y - other.y));
        }
    }
    
    static class State implements Comparable<State> {
        int buildingId;
        double distance;
        
        State(int buildingId, double distance) {
            this.buildingId = buildingId;
            this.distance = distance;
        }
        
        @Override
        public int compareTo(State other) {
            return Double.compare(this.distance, other.distance);
        }
    }
    
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        
        while (true) {
            int n = sc.nextInt();
            if (n == 0) break;
            
            Map<Integer, Building> buildings = new HashMap<>();
            
            for (int i = 0; i < n; i++) {
                int id = sc.nextInt();
                int x = sc.nextInt();
                int y = sc.nextInt();
                buildings.put(id, new Building(id, x, y));
            }
            
            int m = sc.nextInt();
            
            for (int i = 0; i < m; i++) {
                int start = sc.nextInt();
                int goal = sc.nextInt();
                
                List<Integer> path = findPath(buildings, start, goal);
                
                if (path == null) {
                    System.out.println(""NA"");
                } else {
                    StringBuilder sb = new StringBuilder();
                    for (int j = 0; j < path.size(); j++) {
                        if (j > 0) sb.append("" "");
                        sb.append(path.get(j));
                    }
                    System.out.println(sb.toString());
                }
            }
        }
        
        sc.close();
    }
    
    static List<Integer> findPath(Map<Integer, Building> buildings, int start, int goal) {
        Map<Integer, Double> dist = new HashMap<>();
        Map<Integer, Integer> prev = new HashMap<>();
        PriorityQueue<State> pq = new PriorityQueue<>();
        
        for (int id : buildings.keySet()) {
            dist.put(id, Double.MAX_VALUE);
        }
        
        dist.put(start, 0.0);
        pq.offer(new State(start, 0.0));
        
        while (!pq.isEmpty()) {
            State current = pq.poll();
            int currentId = current.buildingId;
            
            if (current.distance > dist.get(currentId)) {
                continue;
            }
            
            if (currentId == goal) {
                break;
            }
            
            Building currentBuilding = buildings.get(currentId);
            
            for (int nextId : buildings.keySet()) {
                if (nextId == currentId) continue;
                
                Building nextBuilding = buildings.get(nextId);
                double distance = currentBuilding.distance(nextBuilding);
                
                if (distance <= 50.0) {
                    double newDist = dist.get(currentId) + distance;
                    
                    if (newDist < dist.get(nextId)) {
                        dist.put(nextId, newDist);
                        prev.put(nextId, currentId);
                        pq.offer(new State(nextId, newDist));
                    }
                }
            }
        }
        
        if (!prev.containsKey(goal) && start != goal) {
            return null;
        }
        
        List<Integer> path = new ArrayList<>();
        int current = goal;
        
        while (current != start) {
            path.add(current);
            if (!prev.containsKey(current)) {
                return null;
            }
            current = prev.get(current);
        }
        path.add(start);
        
        Collections.reverse(path);
        return path;
    }
}
",0
p00155,"スパイダー人
正義のヒーロー「スパイダー人」は、腕からロープを出してビルからビルへ飛び移ることができます。しかし、ロープが短いので自分からの距離が 50 以下のビルにしか移動できません。それより遠くのビルに移動するには、一旦別のビルに飛び移らなくてはなりません。
ビルの数
n
、
n
個のビルの情報、スパイダー人の移動開始位置及び目的地を入力とし、その移動の最短経路を出力するプログラムを作成してください。どのようにビルを経由しても目標のビルに移動できない場合は NA と出力してください。各ビルは点として扱い、最短距離で移動するビルの経由方法が２つ以上存在することはないものとします。
Input
複数のデータセットの並びが入力として与えられます。入力の終わりはゼロひとつの行で示されます。
各データセットは以下の形式で与えられます。
n
b
1
x
1
y
1
b
2
x
2
y
2
:
b
n
x
n
y
n
m
s
1
g
1
s
2
g
2
:
s
m
g
m
１行目にビルの数
n
(1 ≤
n
≤ 100)、続く
n
行に
i
番目のビルのビル番号
b
i
(1 ≤
b
i
≤
n
)、そのビルのx座標とy座標を表す整数
x
i
,
y
i
(-1000 ≤
x
i
,
y
i
≤ 1000) が空白区切りで与えられます。
続く行に移動情報の個数
m
(1 ≤
m
≤ 100)、続く
m
行に
i
番目の移動情報が与えられます。各移動情報として、移動を開始するビルの番号
s
i
と目的地ビルの番号
g
i
が空白区切りで与えられます。
データセットの数は 10 を超えません。
Output
入力データセットごとに次の形式で出力します。
i
行目に
i
番目の移動情報に対する経路または NA を１行に出力します。各経路は以下の形式で出力します。
s
i
br
i1
br
i2
...
g
i
br
ij
は
i
番目の移動情報における、
j
番目に経由するビルの番号を表します。
Sample Input
4
1 0 0
2 30 0
3 60 40
4 0 60
2
1 3
1 4
22
1 0 0
2 150 40
3 30 20
4 180 150
5 40 80
6 130 130
7 72 28
8 172 118
9 50 50
10 160 82
11 90 105
12 144 131
13 130 64
14 80 140
15 38 117
16 190 90
17 60 100
18 100 70
19 130 100
20 71 69
21 200 110
22 120 150
1
1 22
0
Output for the Sample Input
1 2 3
NA
1 3 9 20 11 6 22",Java,"
import java.io.IOException;
import java.io.InputStream;
import java.io.PrintWriter;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.NoSuchElementException;
import java.util.Scanner;
public class Main {
	static PrintWriter out = new PrintWriter(System.out);
	static Scanner stdIn = new Scanner(System.in);
	static FastScanner sc = new FastScanner();
	static int INF = 2 << 20;
	
	public static void main(String[] args) {
		while(true) {
			int n = sc.nextInt();
			if(n == 0) break;
			double [][] cost = new double[n+1][n+1];
			
			for(int i = 0; i < n+1; i++) {
				Arrays.fill(cost[i], INF);
			}
			Data[] list = new Data[n];
			for(int i = 0; i < n; i++) {
				int a = sc.nextInt();
				int b = sc.nextInt();
				int c = sc.nextInt();
				list[i] = new Data(a,b,c);
			}
			for(int i = 0; i < n; i++) {
				for(int j = 0; j < n; j++) {
					double sum = Math.sqrt((list[i].x - list[j].x)*(list[i].x - list[j].x) + (list[i].y - list[j].y) * (list[i].y - list[j].y));
					if(sum > 50.0) {
						continue;
					}
					cost[list[i].id][list[j].id] = sum;
				}
			}
			
			int m = sc.nextInt();
			
			for(int i = 0; i < m; i++) {
				double[] d = new double[n+1];
				boolean[] used = new boolean[n+1];
				int[] prev = new int[n+1];
				int s = sc.nextInt();
				int g = sc.nextInt();
				
				Arrays.fill(d, INF);
				Arrays.fill(used, false);
				Arrays.fill(prev, -1);
				d[s] = 0;
				
				while(true) {
					int v = -1;
					for(int u= 0; u < n+1; u++) {
						if(!used[u] && (v == -1 || d[u] < d[v])) v = u;
					}
					
					if(v == -1) break;
					used[v] = true;
					
					for(int u = 0; u < n+1; u++) {
						if(d[u] > d[v] + cost[v][u]) {
							d[u] = d[v] + cost[v][u];
							prev[u] = v;
						}
					}
				}
				
				if(d[g] == INF) {
					out.println(""NA"");
					continue;
				}
				
				ArrayList<Integer> Xist = new ArrayList<Integer>();
				for(; g != -1; g = prev[g]) Xist.add(g);
				
				Collections.reverse(Xist);
				out.print(Xist.get(0));
				for(int j = 1; j < Xist.size(); j++) {
					out.print("" "" + Xist.get(j));
				}
				out.println();
				
				
			}
			
			
			
		}
		out.flush();
	}
	
	static class Data {
		int id;
		int x;
		int y;
		
		Data(int a, int b, int c) {
			id = a;
			x = b;
			y = c;
		}
	}
	


}

class FastScanner {
    private final InputStream in = System.in;
    private final byte[] buffer = new byte[1024];
    private int ptr = 0;
    private int buflen = 0;
    private boolean hasNextByte() {
        if (ptr < buflen) {
            return true;
        }else{
            ptr = 0;
            try {
                buflen = in.read(buffer);
            } catch (IOException e) {
                e.printStackTrace();
            }
            if (buflen <= 0) {
                return false;
            }
        }
        return true;
    }
    private int readByte() { if (hasNextByte()) return buffer[ptr++]; else return -1;}
    private static boolean isPrintableChar(int c) { return 33 <= c && c <= 126;}
    private void skipUnprintable() { while(hasNextByte() && !isPrintableChar(buffer[ptr])) ptr++;}
    public boolean hasNext() { skipUnprintable(); return hasNextByte();}
    public String next() {
        if (!hasNext()) throw new NoSuchElementException();
        StringBuilder sb = new StringBuilder();
        int b = readByte();
        while(isPrintableChar(b)) {
            sb.appendCodePoint(b);
            b = readByte();
        }
        return sb.toString();
    }
    public long nextLong() {
        if (!hasNext()) throw new NoSuchElementException();
        long n = 0;
        boolean minus = false;
        int b = readByte();
        if (b == '-') {
            minus = true;
            b = readByte();
        }
        if (b < '0' || '9' < b) {
            throw new NumberFormatException();
        }
        while(true){
            if ('0' <= b && b <= '9') {
                n *= 10;
                n += b - '0';
            }else if(b == -1 || !isPrintableChar(b)){
                return minus ? -n : n;
            }else{
                throw new NumberFormatException();
            }
            b = readByte();
        }
    }
     
    public int nextInt() {
        return (int)nextLong();
    }
     
    public double nextDouble() {
        return Double.parseDouble(next());
    }
     
 
}",1
p00155,"スパイダー人
正義のヒーロー「スパイダー人」は、腕からロープを出してビルからビルへ飛び移ることができます。しかし、ロープが短いので自分からの距離が 50 以下のビルにしか移動できません。それより遠くのビルに移動するには、一旦別のビルに飛び移らなくてはなりません。
ビルの数
n
、
n
個のビルの情報、スパイダー人の移動開始位置及び目的地を入力とし、その移動の最短経路を出力するプログラムを作成してください。どのようにビルを経由しても目標のビルに移動できない場合は NA と出力してください。各ビルは点として扱い、最短距離で移動するビルの経由方法が２つ以上存在することはないものとします。
Input
複数のデータセットの並びが入力として与えられます。入力の終わりはゼロひとつの行で示されます。
各データセットは以下の形式で与えられます。
n
b
1
x
1
y
1
b
2
x
2
y
2
:
b
n
x
n
y
n
m
s
1
g
1
s
2
g
2
:
s
m
g
m
１行目にビルの数
n
(1 ≤
n
≤ 100)、続く
n
行に
i
番目のビルのビル番号
b
i
(1 ≤
b
i
≤
n
)、そのビルのx座標とy座標を表す整数
x
i
,
y
i
(-1000 ≤
x
i
,
y
i
≤ 1000) が空白区切りで与えられます。
続く行に移動情報の個数
m
(1 ≤
m
≤ 100)、続く
m
行に
i
番目の移動情報が与えられます。各移動情報として、移動を開始するビルの番号
s
i
と目的地ビルの番号
g
i
が空白区切りで与えられます。
データセットの数は 10 を超えません。
Output
入力データセットごとに次の形式で出力します。
i
行目に
i
番目の移動情報に対する経路または NA を１行に出力します。各経路は以下の形式で出力します。
s
i
br
i1
br
i2
...
g
i
br
ij
は
i
番目の移動情報における、
j
番目に経由するビルの番号を表します。
Sample Input
4
1 0 0
2 30 0
3 60 40
4 0 60
2
1 3
1 4
22
1 0 0
2 150 40
3 30 20
4 180 150
5 40 80
6 130 130
7 72 28
8 172 118
9 50 50
10 160 82
11 90 105
12 144 131
13 130 64
14 80 140
15 38 117
16 190 90
17 60 100
18 100 70
19 130 100
20 71 69
21 200 110
22 120 150
1
1 22
0
Output for the Sample Input
1 2 3
NA
1 3 9 20 11 6 22",Python,"import sys
from collections import deque
import math

def distance(p1, p2):
    return math.sqrt((p1[0] - p2[0])**2 + (p1[1] - p2[1])**2)

def bfs(start, goal, buildings, adjacency):
    if start == goal:
        return [start]
    
    queue = deque([(start, [start])])
    visited = {start}
    
    while queue:
        current, path = queue.popleft()
        
        for neighbor in adjacency[current]:
            if neighbor in visited:
                continue
            
            visited.add(neighbor)
            new_path = path + [neighbor]
            
            if neighbor == goal:
                return new_path
            
            queue.append((neighbor, new_path))
    
    return None

while True:
    n = int(input())
    if n == 0:
        break
    
    buildings = {}
    for _ in range(n):
        parts = list(map(int, input().split()))
        b_id = parts[0]
        x = parts[1]
        y = parts[2]
        buildings[b_id] = (x, y)
    
    # Build adjacency list
    adjacency = {b_id: [] for b_id in buildings}
    for b1 in buildings:
        for b2 in buildings:
            if b1 != b2:
                dist = distance(buildings[b1], buildings[b2])
                if dist <= 50:
                    adjacency[b1].append(b2)
    
    m = int(input())
    results = []
    for _ in range(m):
        s, g = map(int, input().split())
        path = bfs(s, g, buildings, adjacency)
        if path is None:
            results.append(""NA"")
        else:
            results.append("" "".join(map(str, path)))
    
    for result in results:
        print(result)
",0
p00155,"スパイダー人
正義のヒーロー「スパイダー人」は、腕からロープを出してビルからビルへ飛び移ることができます。しかし、ロープが短いので自分からの距離が 50 以下のビルにしか移動できません。それより遠くのビルに移動するには、一旦別のビルに飛び移らなくてはなりません。
ビルの数
n
、
n
個のビルの情報、スパイダー人の移動開始位置及び目的地を入力とし、その移動の最短経路を出力するプログラムを作成してください。どのようにビルを経由しても目標のビルに移動できない場合は NA と出力してください。各ビルは点として扱い、最短距離で移動するビルの経由方法が２つ以上存在することはないものとします。
Input
複数のデータセットの並びが入力として与えられます。入力の終わりはゼロひとつの行で示されます。
各データセットは以下の形式で与えられます。
n
b
1
x
1
y
1
b
2
x
2
y
2
:
b
n
x
n
y
n
m
s
1
g
1
s
2
g
2
:
s
m
g
m
１行目にビルの数
n
(1 ≤
n
≤ 100)、続く
n
行に
i
番目のビルのビル番号
b
i
(1 ≤
b
i
≤
n
)、そのビルのx座標とy座標を表す整数
x
i
,
y
i
(-1000 ≤
x
i
,
y
i
≤ 1000) が空白区切りで与えられます。
続く行に移動情報の個数
m
(1 ≤
m
≤ 100)、続く
m
行に
i
番目の移動情報が与えられます。各移動情報として、移動を開始するビルの番号
s
i
と目的地ビルの番号
g
i
が空白区切りで与えられます。
データセットの数は 10 を超えません。
Output
入力データセットごとに次の形式で出力します。
i
行目に
i
番目の移動情報に対する経路または NA を１行に出力します。各経路は以下の形式で出力します。
s
i
br
i1
br
i2
...
g
i
br
ij
は
i
番目の移動情報における、
j
番目に経由するビルの番号を表します。
Sample Input
4
1 0 0
2 30 0
3 60 40
4 0 60
2
1 3
1 4
22
1 0 0
2 150 40
3 30 20
4 180 150
5 40 80
6 130 130
7 72 28
8 172 118
9 50 50
10 160 82
11 90 105
12 144 131
13 130 64
14 80 140
15 38 117
16 190 90
17 60 100
18 100 70
19 130 100
20 71 69
21 200 110
22 120 150
1
1 22
0
Output for the Sample Input
1 2 3
NA
1 3 9 20 11 6 22",Python,"import copy, math

def f(n, d, D, res, buil):
    global sd, ans
    d += D
    res.append(n)
    if sd is not None and sd <= d:
        return
    elif n == g:
        ans = res
        sd = d
        return
    else:
        new_buil = copy.deepcopy(buil)
        A = new_buil[n]
        del new_buil[n]
        for m, B in new_buil.items():
            D = py(A, B)
            if D:
                f(m, d, D, res[:], new_buil)
            
def py(A, B):
    x = 0
    y = 1
    D = math.sqrt((B[x]-A[x])**2+(B[y]-A[y])**2)
    if D <= 50:
        return D

while True:
    N = input()
    if N == 0: break
    buil = {}
    for i in range(N):
        n, x, y = map(int, raw_input().split())
        buil[n] = (x, y)
    for i in range(input()):
        s, g = map(int, raw_input().split())
        sd = None
        ans = None
        f(s, 0, 0, [], buil)
        if ans:
            print ' '.join(map(str, ans))
        else:
            print 'NA'",1
p00156,"城の堀
いま、忍者が城外から天守閣に忍び入ろうと計画を立てています。この忍者は地面を走ったり、堀の中を泳いだりすることは難なくできますが、堀から這い上がることはとても苦手なので、忍者は堀に入る回数をできるだけ少なくしたいと考えています。
お城の見取図を入力とし、城外から天守閣に至るまでに、堀から這い上がらなくてはならない最小回数を出力するプログラムを作成して下さい。お城の見取図は二次元格子として与えられます。見取り図に描かれた記号には、天守閣の位置を示す「&」と堀の位置を示す「#」の位置が記され、そのほかの地点には「.」（半角ピリオド）が記されています。なお、お城には天守閣は一つだけあるものとし、忍者は走ったり泳いだりして移動するときに東西南北方向に1マスずつ移動するものとし、斜めには移動しません。
Input
複数のデータセットの並びが入力として与えられます。入力の終わりはゼロ２つの行で示されます。各データセットは以下の形式で与えられます。
n
m
c
1,1
c
1,2
...
c
1,n
c
2,1
c
2,2
...
c
2,n
:
c
m,1
c
m,2
...
c
m,n
１行目に見取図の東西の幅
n
と 南北の幅
m
(1 ≤
n
,
m
≤ 100) が与えられる。続く
m
行に見取り図の
i
行目の情報が与えられる。各情報は記号「&」、「#」、「.」からなる長さ
n
の文字列である。
データセットの数は 50 を越えない。
Output
データセットごとに堀から這い上がらなくてはならない最小回数（整数）を１行に出力します。
Sample Input
5 5
.###.
#...#
#.&.#
#...#
.###.
18 15
..####....####....
####..####....####
#...............##
.#.############.##
#..#..........#.##
.#.#.########.#.##
#..#.#......#.#.##
.#.#....&...#.#.##
#..#........#.#.##
.#.#.########.#.##
#..#..........#.##
.#.############.##
#...............##
.#################
##################
9 10
#########
........#
#######.#
#.....#.#
#.###.#.#
#.#&#.#.#
#.#...#.#
#.#####.#
#.......#
#########
9 3
###...###
#.#.&.#.#
###...###
0 0
</pre>

<H2>Output for the Sample Input</H2>

<pre>
1
2
0
0
</pre>",C,"#include <stdio.h>
#include <string.h>
#include <limits.h>

#define MAXN 105

typedef struct {
    int x, y, cost;
} State;

typedef struct {
    State data[MAXN * MAXN];
    int front, rear;
} Queue;

void initQueue(Queue *q) {
    q->front = 0;
    q->rear = 0;
}

void enqueue(Queue *q, State s) {
    q->data[q->rear++] = s;
}

State dequeue(Queue *q) {
    return q->data[q->front++];
}

int isEmpty(Queue *q) {
    return q->front == q->rear;
}

int main() {
    int n, m;
    char grid[MAXN][MAXN];
    int dist[MAXN][MAXN];
    int dx[] = {0, 0, 1, -1};
    int dy[] = {1, -1, 0, 0};
    
    while (scanf(""%d %d"", &n, &m) == 2 && (n || m)) {
        int startX = -1, startY = -1;
        
        for (int i = 0; i < m; i++) {
            scanf(""%s"", grid[i]);
            for (int j = 0; j < n; j++) {
                if (grid[i][j] == '&') {
                    startX = i;
                    startY = j;
                }
                dist[i][j] = INT_MAX;
            }
        }
        
        // Check if we can reach from boundary
        Queue q;
        initQueue(&q);
        
        // Start from all boundary cells
        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                if (i == 0 || i == m-1 || j == 0 || j == n-1) {
                    State s;
                    s.x = i;
                    s.y = j;
                    if (grid[i][j] == '#') {
                        s.cost = 1;
                    } else {
                        s.cost = 0;
                    }
                    dist[i][j] = s.cost;
                    enqueue(&q, s);
                }
            }
        }
        
        while (!isEmpty(&q)) {
            State cur = dequeue(&q);
            int x = cur.x;
            int y = cur.y;
            int cost = cur.cost;
            
            if (cost > dist[x][y]) continue;
            
            for (int d = 0; d < 4; d++) {
                int nx = x + dx[d];
                int ny = y + dy[d];
                
                if (nx >= 0 && nx < m && ny >= 0 && ny < n) {
                    int newCost = cost;
                    if (grid[x][y] == '#' && grid[nx][ny] != '#') {
                        newCost = cost + 1;
                    }
                    
                    if (newCost < dist[nx][ny]) {
                        dist[nx][ny] = newCost;
                        State ns;
                        ns.x = nx;
                        ns.y = ny;
                        ns.cost = newCost;
                        enqueue(&q, ns);
                    }
                }
            }
        }
        
        if (dist[startX][startY] == INT_MAX) {
            printf(""-1\n"");
        } else {
            printf(""%d\n"", dist[startX][startY]);
        }
    }
    
    return 0;
}
",0
p00156,"城の堀
いま、忍者が城外から天守閣に忍び入ろうと計画を立てています。この忍者は地面を走ったり、堀の中を泳いだりすることは難なくできますが、堀から這い上がることはとても苦手なので、忍者は堀に入る回数をできるだけ少なくしたいと考えています。
お城の見取図を入力とし、城外から天守閣に至るまでに、堀から這い上がらなくてはならない最小回数を出力するプログラムを作成して下さい。お城の見取図は二次元格子として与えられます。見取り図に描かれた記号には、天守閣の位置を示す「&」と堀の位置を示す「#」の位置が記され、そのほかの地点には「.」（半角ピリオド）が記されています。なお、お城には天守閣は一つだけあるものとし、忍者は走ったり泳いだりして移動するときに東西南北方向に1マスずつ移動するものとし、斜めには移動しません。
Input
複数のデータセットの並びが入力として与えられます。入力の終わりはゼロ２つの行で示されます。各データセットは以下の形式で与えられます。
n
m
c
1,1
c
1,2
...
c
1,n
c
2,1
c
2,2
...
c
2,n
:
c
m,1
c
m,2
...
c
m,n
１行目に見取図の東西の幅
n
と 南北の幅
m
(1 ≤
n
,
m
≤ 100) が与えられる。続く
m
行に見取り図の
i
行目の情報が与えられる。各情報は記号「&」、「#」、「.」からなる長さ
n
の文字列である。
データセットの数は 50 を越えない。
Output
データセットごとに堀から這い上がらなくてはならない最小回数（整数）を１行に出力します。
Sample Input
5 5
.###.
#...#
#.&.#
#...#
.###.
18 15
..####....####....
####..####....####
#...............##
.#.############.##
#..#..........#.##
.#.#.########.#.##
#..#.#......#.#.##
.#.#....&...#.#.##
#..#........#.#.##
.#.#.########.#.##
#..#..........#.##
.#.############.##
#...............##
.#################
##################
9 10
#########
........#
#######.#
#.....#.#
#.###.#.#
#.#&#.#.#
#.#...#.#
#.#####.#
#.......#
#########
9 3
###...###
#.#.&.#.#
###...###
0 0
</pre>

<H2>Output for the Sample Input</H2>

<pre>
1
2
0
0
</pre>",C,"#include <stdio.h>
#include <string.h>

typedef struct {
    int ty;
    int tx;
    int sharp;
} POINT;

POINT queue[10000000];
int head, tail;

void enq(POINT t)
{
    queue[tail++] = t;
    if (tail == 10000000){
        tail = 0;
    }
}

void deq(POINT *t)
{
    *t = queue[head++];
    if (head == 10000000){
        head = 0;
    }
}

int main(void)
{
    POINT temp, add;
    int ans;
    int i, j;
    int x, y;
    int mx, my;
    int dx[4] = {1, 0, -1, 0};
    int dy[4] = {0, 1, 0, -1};
    int cost[102][102];
    char map[102][103];
    
    while (1){
        scanf(""%d%d"", &x, &y);
        
        if (x + y == 0){
            break;
        }
        getchar();
        
        memset(map, '.', sizeof(map));
        
        for (i = 1; i <= y; i++){
            for (j = 1; j <= x; j++){
                scanf(""%c"", &map[i][j]);
                
                if (map[i][j] == '&'){
                    temp.tx = j;
                    temp.ty = i;
                }
            }
            getchar();
        }
        
        for (i = 0; i <= y + 1; i++){
            for (j = 0; j <= x + 1; j++){
                cost[i][j] = 100000;
            }
        }
        
        cost[temp.ty][temp.tx] = 0;
        temp.sharp = 0;
        head = tail = 0;
        enq(temp);
        ans = 100000;
        
        while (head != tail){
            deq(&temp);
            
            if (0 == temp.tx || 0 == temp.ty || x + 1 == temp.tx || y + 1 == temp.ty){
                ans = (ans > temp.sharp ? temp.sharp : ans);
                continue;
            }
            
            for (i = 0; i < 4; i++){
                mx = temp.tx + dx[i];
                my = temp.ty + dy[i];
                add = temp;
                if (cost[my][mx] > add.sharp){
                    if ((map[my][mx] == '.') && map[temp.ty][temp.tx] == '#'){
                        add.sharp++;
                    }
                    cost[my][mx] = add.sharp;
                    add.tx = mx;
                    add.ty = my;
                    enq(add);
                }
            }
        }
        
        printf(""%d\n"", ans);
    }
    
    return (0);
}",1
p00156,"城の堀
いま、忍者が城外から天守閣に忍び入ろうと計画を立てています。この忍者は地面を走ったり、堀の中を泳いだりすることは難なくできますが、堀から這い上がることはとても苦手なので、忍者は堀に入る回数をできるだけ少なくしたいと考えています。
お城の見取図を入力とし、城外から天守閣に至るまでに、堀から這い上がらなくてはならない最小回数を出力するプログラムを作成して下さい。お城の見取図は二次元格子として与えられます。見取り図に描かれた記号には、天守閣の位置を示す「&」と堀の位置を示す「#」の位置が記され、そのほかの地点には「.」（半角ピリオド）が記されています。なお、お城には天守閣は一つだけあるものとし、忍者は走ったり泳いだりして移動するときに東西南北方向に1マスずつ移動するものとし、斜めには移動しません。
Input
複数のデータセットの並びが入力として与えられます。入力の終わりはゼロ２つの行で示されます。各データセットは以下の形式で与えられます。
n
m
c
1,1
c
1,2
...
c
1,n
c
2,1
c
2,2
...
c
2,n
:
c
m,1
c
m,2
...
c
m,n
１行目に見取図の東西の幅
n
と 南北の幅
m
(1 ≤
n
,
m
≤ 100) が与えられる。続く
m
行に見取り図の
i
行目の情報が与えられる。各情報は記号「&」、「#」、「.」からなる長さ
n
の文字列である。
データセットの数は 50 を越えない。
Output
データセットごとに堀から這い上がらなくてはならない最小回数（整数）を１行に出力します。
Sample Input
5 5
.###.
#...#
#.&.#
#...#
.###.
18 15
..####....####....
####..####....####
#...............##
.#.############.##
#..#..........#.##
.#.#.########.#.##
#..#.#......#.#.##
.#.#....&...#.#.##
#..#........#.#.##
.#.#.########.#.##
#..#..........#.##
.#.############.##
#...............##
.#################
##################
9 10
#########
........#
#######.#
#.....#.#
#.###.#.#
#.#&#.#.#
#.#...#.#
#.#####.#
#.......#
#########
9 3
###...###
#.#.&.#.#
###...###
0 0
</pre>

<H2>Output for the Sample Input</H2>

<pre>
1
2
0
0
</pre>",Java,"import java.util.*;
import java.io.*;

public class Main {
    static class State implements Comparable<State> {
        int x, y, climbs;
        
        State(int x, int y, int climbs) {
            this.x = x;
            this.y = y;
            this.climbs = climbs;
        }
        
        @Override
        public int compareTo(State other) {
            return this.climbs - other.climbs;
        }
    }
    
    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        String line;
        
        while ((line = br.readLine()) != null) {
            String[] parts = line.trim().split(""\\s+"");
            int n = Integer.parseInt(parts[0]);
            int m = Integer.parseInt(parts[1]);
            
            if (n == 0 && m == 0) break;
            
            char[][] grid = new char[m][n];
            int targetX = -1, targetY = -1;
            
            for (int i = 0; i < m; i++) {
                String row = br.readLine();
                for (int j = 0; j < n; j++) {
                    grid[i][j] = row.charAt(j);
                    if (grid[i][j] == '&') {
                        targetX = i;
                        targetY = j;
                    }
                }
            }
            
            int result = solve(grid, m, n, targetX, targetY);
            System.out.println(result);
        }
    }
    
    static int solve(char[][] grid, int m, int n, int targetX, int targetY) {
        int[][] minClimbs = new int[m][n];
        for (int i = 0; i < m; i++) {
            Arrays.fill(minClimbs[i], Integer.MAX_VALUE);
        }
        
        PriorityQueue<State> pq = new PriorityQueue<>();
        
        // Start from all border cells
        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                if (i == 0 || i == m - 1 || j == 0 || j == n - 1) {
                    int initialClimbs = (grid[i][j] == '#') ? 1 : 0;
                    pq.offer(new State(i, j, initialClimbs));
                    minClimbs[i][j] = initialClimbs;
                }
            }
        }
        
        int[] dx = {-1, 1, 0, 0};
        int[] dy = {0, 0, -1, 1};
        
        while (!pq.isEmpty()) {
            State current = pq.poll();
            
            if (current.x == targetX && current.y == targetY) {
                return current.climbs;
            }
            
            if (current.climbs > minClimbs[current.x][current.y]) {
                continue;
            }
            
            for (int i = 0; i < 4; i++) {
                int nx = current.x + dx[i];
                int ny = current.y + dy[i];
                
                if (nx >= 0 && nx < m && ny >= 0 && ny < n) {
                    boolean currentInMoat = (grid[current.x][current.y] == '#');
                    boolean nextInMoat = (grid[nx][ny] == '#');
                    
                    int newClimbs = current.climbs;
                    if (currentInMoat && !nextInMoat) {
                        newClimbs++;
                    }
                    
                    if (newClimbs < minClimbs[nx][ny]) {
                        minClimbs[nx][ny] = newClimbs;
                        pq.offer(new State(nx, ny, newClimbs));
                    }
                }
            }
        }
        
        return minClimbs[targetX][targetY];
    }
}
",0
p00156,"城の堀
いま、忍者が城外から天守閣に忍び入ろうと計画を立てています。この忍者は地面を走ったり、堀の中を泳いだりすることは難なくできますが、堀から這い上がることはとても苦手なので、忍者は堀に入る回数をできるだけ少なくしたいと考えています。
お城の見取図を入力とし、城外から天守閣に至るまでに、堀から這い上がらなくてはならない最小回数を出力するプログラムを作成して下さい。お城の見取図は二次元格子として与えられます。見取り図に描かれた記号には、天守閣の位置を示す「&」と堀の位置を示す「#」の位置が記され、そのほかの地点には「.」（半角ピリオド）が記されています。なお、お城には天守閣は一つだけあるものとし、忍者は走ったり泳いだりして移動するときに東西南北方向に1マスずつ移動するものとし、斜めには移動しません。
Input
複数のデータセットの並びが入力として与えられます。入力の終わりはゼロ２つの行で示されます。各データセットは以下の形式で与えられます。
n
m
c
1,1
c
1,2
...
c
1,n
c
2,1
c
2,2
...
c
2,n
:
c
m,1
c
m,2
...
c
m,n
１行目に見取図の東西の幅
n
と 南北の幅
m
(1 ≤
n
,
m
≤ 100) が与えられる。続く
m
行に見取り図の
i
行目の情報が与えられる。各情報は記号「&」、「#」、「.」からなる長さ
n
の文字列である。
データセットの数は 50 を越えない。
Output
データセットごとに堀から這い上がらなくてはならない最小回数（整数）を１行に出力します。
Sample Input
5 5
.###.
#...#
#.&.#
#...#
.###.
18 15
..####....####....
####..####....####
#...............##
.#.############.##
#..#..........#.##
.#.#.########.#.##
#..#.#......#.#.##
.#.#....&...#.#.##
#..#........#.#.##
.#.#.########.#.##
#..#..........#.##
.#.############.##
#...............##
.#################
##################
9 10
#########
........#
#######.#
#.....#.#
#.###.#.#
#.#&#.#.#
#.#...#.#
#.#####.#
#.......#
#########
9 3
###...###
#.#.&.#.#
###...###
0 0
</pre>

<H2>Output for the Sample Input</H2>

<pre>
1
2
0
0
</pre>",Java,"
import java.util.ArrayDeque;
import java.util.Arrays;
import java.util.Deque;
import java.util.List;
import java.util.Scanner;

public class Main {
	public static void main(String[] args) {
		Scanner scanner = new Scanner(System.in);
		while (true) {
			int w = scanner.nextInt();
			int h = scanner.nextInt();
			if (w == 0 && h == 0)
				break;
			int gy = -1;
			int gx = -1;
			boolean[][] map = new boolean[h + 2][w + 2];
			for (int i = 1; i <= h; i++) {
				char[] c = scanner.next().toCharArray();
				for (int j = 1; j <= w; j++) {
					if (c[j - 1] == '#') {
						map[i][j] = true;
					} else if (c[j - 1] == '&') {
						gy = i;
						gx = j;
					}
				}
			}
			int[][] dxy = { { -1, 0 }, { 0, -1 }, { 0, 1 }, { 1, 0 } };
			int[][] cnt = new int[h + 2][w + 2];
			
			for (int[] c : cnt) {
				Arrays.fill(c, 1 << 10);
			}
			cnt[0][0] = 0;
			Deque<List<Integer>> deque = new ArrayDeque<List<Integer>>();
			deque.offer(Arrays.asList(0, 0));
			while (!deque.isEmpty()) {
				List<Integer> list = deque.poll();
				int y = list.get(0);
				int x = list.get(1);
				for (int[] d : dxy) {
					int dy = y + d[0];
					int dx = x + d[1];
					if (0 <= dy && dy < h + 2 && 0 <= dx & dx < w + 2) {
						int r;
						if (map[y][x] && !map[dy][dx]) {
							r = 1;
						} else {
							r = 0;
						}
						if (cnt[dy][dx] > cnt[y][x] + r) {
							cnt[dy][dx] = cnt[y][x] + r;
							deque.offer(Arrays.asList(dy, dx));
						}
					}
				}
			}
			System.out.println(cnt[gy][gx]);
		}
	}
}",1
p00156,"城の堀
いま、忍者が城外から天守閣に忍び入ろうと計画を立てています。この忍者は地面を走ったり、堀の中を泳いだりすることは難なくできますが、堀から這い上がることはとても苦手なので、忍者は堀に入る回数をできるだけ少なくしたいと考えています。
お城の見取図を入力とし、城外から天守閣に至るまでに、堀から這い上がらなくてはならない最小回数を出力するプログラムを作成して下さい。お城の見取図は二次元格子として与えられます。見取り図に描かれた記号には、天守閣の位置を示す「&」と堀の位置を示す「#」の位置が記され、そのほかの地点には「.」（半角ピリオド）が記されています。なお、お城には天守閣は一つだけあるものとし、忍者は走ったり泳いだりして移動するときに東西南北方向に1マスずつ移動するものとし、斜めには移動しません。
Input
複数のデータセットの並びが入力として与えられます。入力の終わりはゼロ２つの行で示されます。各データセットは以下の形式で与えられます。
n
m
c
1,1
c
1,2
...
c
1,n
c
2,1
c
2,2
...
c
2,n
:
c
m,1
c
m,2
...
c
m,n
１行目に見取図の東西の幅
n
と 南北の幅
m
(1 ≤
n
,
m
≤ 100) が与えられる。続く
m
行に見取り図の
i
行目の情報が与えられる。各情報は記号「&」、「#」、「.」からなる長さ
n
の文字列である。
データセットの数は 50 を越えない。
Output
データセットごとに堀から這い上がらなくてはならない最小回数（整数）を１行に出力します。
Sample Input
5 5
.###.
#...#
#.&.#
#...#
.###.
18 15
..####....####....
####..####....####
#...............##
.#.############.##
#..#..........#.##
.#.#.########.#.##
#..#.#......#.#.##
.#.#....&...#.#.##
#..#........#.#.##
.#.#.########.#.##
#..#..........#.##
.#.############.##
#...............##
.#################
##################
9 10
#########
........#
#######.#
#.....#.#
#.###.#.#
#.#&#.#.#
#.#...#.#
#.#####.#
#.......#
#########
9 3
###...###
#.#.&.#.#
###...###
0 0
</pre>

<H2>Output for the Sample Input</H2>

<pre>
1
2
0
0
</pre>",Python,"from collections import deque

def solve(n, m, grid):
    # Find the position of '&' (castle keep)
    castle_pos = None
    for i in range(m):
        for j in range(n):
            if grid[i][j] == '&':
                castle_pos = (i, j)
                break
        if castle_pos:
            break
    
    # BFS with state (row, col, climbs)
    # We want to find minimum climbs to reach castle from outside
    # Outside means any position on the border or reachable from border
    
    # Use 0-1 BFS (or Dijkstra-like approach)
    # State: (climbs, row, col, in_moat)
    # in_moat: True if currently in a moat
    
    visited = {}  # (row, col, in_moat) -> min_climbs
    pq = deque()
    
    # Start from all border positions
    for i in range(m):
        for j in range(n):
            if i == 0 or i == m-1 or j == 0 or j == n-1:
                in_moat = (grid[i][j] == '#')
                pq.append((0, i, j, in_moat))
                visited[(i, j, in_moat)] = 0
    
    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]
    
    while pq:
        climbs, row, col, in_moat = pq.popleft()
        
        if row == castle_pos[0] and col == castle_pos[1]:
            return climbs
        
        if visited.get((row, col, in_moat), float('inf')) < climbs:
            continue
        
        for dr, dc in directions:
            nr, nc = row + dr, col + dc
            if 0 <= nr < m and 0 <= nc < n:
                next_is_moat = (grid[nr][nc] == '#')
                
                # Calculate climbs needed
                new_climbs = climbs
                if in_moat and not next_is_moat:
                    # Climbing out of moat
                    new_climbs = climbs + 1
                
                if visited.get((nr, nc, next_is_moat), float('inf')) > new_climbs:
                    visited[(nr, nc, next_is_moat)] = new_climbs
                    if new_climbs == climbs:
                        pq.appendleft((new_climbs, nr, nc, next_is_moat))
                    else:
                        pq.append((new_climbs, nr, nc, next_is_moat))
    
    return -1

while True:
    line = input().split()
    n, m = int(line[0]), int(line[1])
    if n == 0 and m == 0:
        break
    
    grid = []
    for _ in range(m):
        grid.append(input().strip())
    
    result = solve(n, m, grid)
    print(result)
",0
p00156,"城の堀
いま、忍者が城外から天守閣に忍び入ろうと計画を立てています。この忍者は地面を走ったり、堀の中を泳いだりすることは難なくできますが、堀から這い上がることはとても苦手なので、忍者は堀に入る回数をできるだけ少なくしたいと考えています。
お城の見取図を入力とし、城外から天守閣に至るまでに、堀から這い上がらなくてはならない最小回数を出力するプログラムを作成して下さい。お城の見取図は二次元格子として与えられます。見取り図に描かれた記号には、天守閣の位置を示す「&」と堀の位置を示す「#」の位置が記され、そのほかの地点には「.」（半角ピリオド）が記されています。なお、お城には天守閣は一つだけあるものとし、忍者は走ったり泳いだりして移動するときに東西南北方向に1マスずつ移動するものとし、斜めには移動しません。
Input
複数のデータセットの並びが入力として与えられます。入力の終わりはゼロ２つの行で示されます。各データセットは以下の形式で与えられます。
n
m
c
1,1
c
1,2
...
c
1,n
c
2,1
c
2,2
...
c
2,n
:
c
m,1
c
m,2
...
c
m,n
１行目に見取図の東西の幅
n
と 南北の幅
m
(1 ≤
n
,
m
≤ 100) が与えられる。続く
m
行に見取り図の
i
行目の情報が与えられる。各情報は記号「&」、「#」、「.」からなる長さ
n
の文字列である。
データセットの数は 50 を越えない。
Output
データセットごとに堀から這い上がらなくてはならない最小回数（整数）を１行に出力します。
Sample Input
5 5
.###.
#...#
#.&.#
#...#
.###.
18 15
..####....####....
####..####....####
#...............##
.#.############.##
#..#..........#.##
.#.#.########.#.##
#..#.#......#.#.##
.#.#....&...#.#.##
#..#........#.#.##
.#.#.########.#.##
#..#..........#.##
.#.############.##
#...............##
.#################
##################
9 10
#########
........#
#######.#
#.....#.#
#.###.#.#
#.#&#.#.#
#.#...#.#
#.#####.#
#.......#
#########
9 3
###...###
#.#.&.#.#
###...###
0 0
</pre>

<H2>Output for the Sample Input</H2>

<pre>
1
2
0
0
</pre>",Python,"from heapq import heappush, heappop

while True:
  n, m = map(int, input().split())
  if n == 0: break

  mp = [""X"" + input() + ""X"" for _ in range(m)]
  mp.insert(0, ""X"" * (n + 2))
  mp.append(""X"" * (n + 2))
  
  que = []
  visited = [[False] * (n + 2) for _ in range(m + 2)]
  sur_flag = False
  for i in range(1, n + 1):
    if mp[1][i] ==""&"" or mp[m][i] == ""&"":
      sur_flag = True
      break
    c1, s1 = (1, 0) if mp[1][i] == ""#"" else (0, 1)
    c2, s2 = (1, 0) if mp[m][i] == ""#"" else (0, 1)
    heappush(que, (c1, s1, (i, 1)))
    heappush(que, (c2, s2, (i, m)))
    visited[1][i] = True
    visited[m][i] = True
  
  for i in range(1, m + 1):
    if mp[i][1] == ""&"" or mp[i][n] == ""&"":
      sur_flag = True
      break
    c1, s1 = (1, 0) if mp[i][1] == ""#"" else (0, 1)
    c2, s2 = (1, 0) if mp[i][n] == ""#"" else (0, 1)
    heappush(que, (c1, s1, (1, i)))
    heappush(que, (c2, s2, (n, i)))
    visited[i][1] = True
    visited[i][n] = True
  
  if sur_flag:
    print(0)
    continue
  
  direct = ((0, 1), (0, -1), (1, 0), (-1, 0))
  reached = False
  
  while que and not reached:
    cost, status, point = heappop(que)
    x, y = point
    for dx, dy in direct:
      newx, newy = x + dx, y + dy
      if not visited[newy][newx]:
        visited[newy][newx] = True
        if mp[newy][newx] == ""&"":
          print(cost)
          reached = True
          break
        elif mp[newy][newx] == ""#"":
          if status == 1:
            heappush(que, (cost + 1, 0, (newx, newy)))
          else:
            heappush(que, (cost, 0, (newx, newy)))
        elif mp[newy][newx] == ""."":
          heappush(que,(cost, 1, (newx, newy)))
",1
p00157,"マトリョーシカ
マトリョーシカとは女性像をかたどった木製の人形で、ロシアの代表的な民芸品です。マトリョーシカは、大きな人形の中にそれより小さな人形が入っている入れ子構造になっており、大きさの異なる複数の人形で構成されています。このような入れ子構造にするため、各人形の胴体は上下で分割できる筒状の構造になっています。マトリョーシカは職人の手で手作りされるため、一つ一つの人形は世界に一つしかない非常に貴重なものになります。
兄弟である一郎君と次郎君は、マトリョーシカで遊ぶのが大好きで、各自がそれぞれ1組のマトリョーシカを持っていました。一郎君のマトリョーシカは
n
個の人形から構成されており、次郎君のマトリョーシカは
m
個の人形から構成されています。
ある日、好奇心が旺盛な一郎君は、これら2組のマトリョーシカに含まれる人形たちを組み合わせて、より多くの人形を含む新たなマトリョーシカを作れないかと考えました。つまり、
n + m
個の人形を使い、
k
個の人形からなる１組のマトリョーシカを作ることを試みたのです。
n
と
m
の大きい方よりも
k
を大きくすることができれば、一郎君の目的は達成されます。
兄弟は2人仲良く、どのように人形を組み合わせれば
k
の値を最大にできるかを考えました。しかし、幼い2人にとってこの問題はあまりにも難しいので、年上のあなたはプログラムを作成して弟たちを助けることにしました。
一郎君と次郎君のマトリョーシカの人形の情報を入力とし、新たなマトリョーシカが含む人形の数
k
を出力するプログラムを作成して下さい。入力される人形に大きさが同じものは存在しません。また、人形を高さ
h
半径
r
の円柱とみなした場合、高さ
h
、半径
r
の人形が含むことのできる人形は
x < h
かつ
y < r
を満たす高さ
x
半径
y
の人形です。
Input
複数のデータセットの並びが入力として与えられます。入力の終わりはゼロひとつの行で示されます。各データセットは以下の形式で与えられます。
n
h
1
r
1
h
2
r
2
:
h
n
r
n
m
h
1
r
1
h
2
r
2
:
h
m
r
m
１行目に一郎君のマトリョーシカの人形の数
n
(
n
≤ 100)、続く
n
行に一郎君の第
i
の人形の高さ
h
i
と半径
r
i
(
h
i
,
r
i
< 1000) が与えられます。
続く行に二郎君のマトリョーシカの人形の数
m
(
m
≤ 100)、続く
m
行に二郎君の第
i
の人形の高さ
h
i
と半径
r
i
(
h
i
,
r
i
< 1000) が与えられます。
データセットの数は 20 を越えない。
Output
入力データセットごとに新たなマトリョーシカが含む人形の数
k
を出力します。
Sample Input
6
1 1
4 3
6 5
8 6
10 10
14 14
5
2 2
5 4
6 6
9 8
15 10
4
1 1
4 3
6 5
8 6
3
2 2
5 4
6 6
4
1 1
4 3
6 5
8 6
4
10 10
12 11
18 15
24 20
0
Output for the Sample Input
9
6
8",C,"#include <stdio.h>
#include <string.h>

typedef struct {
    int h, r;
} Doll;

int n, m;
Doll dolls[205];
int dp[205];
int parent[205];

int canContain(int i, int j) {
    return dolls[i].h < dolls[j].h && dolls[i].r < dolls[j].r;
}

int compare(const void *a, const void *b) {
    Doll *da = (Doll *)a;
    Doll *db = (Doll *)b;
    if (da->h != db->h) return da->h - db->h;
    return da->r - db->r;
}

int main() {
    while (1) {
        scanf(""%d"", &n);
        if (n == 0) break;
        
        for (int i = 0; i < n; i++) {
            scanf(""%d %d"", &dolls[i].h, &dolls[i].r);
        }
        
        scanf(""%d"", &m);
        for (int i = 0; i < m; i++) {
            scanf(""%d %d"", &dolls[n + i].h, &dolls[n + i].r);
        }
        
        int total = n + m;
        
        qsort(dolls, total, sizeof(Doll), compare);
        
        for (int i = 0; i < total; i++) {
            dp[i] = 1;
            parent[i] = -1;
        }
        
        int maxLen = 1;
        for (int i = 1; i < total; i++) {
            for (int j = 0; j < i; j++) {
                if (canContain(j, i)) {
                    if (dp[j] + 1 > dp[i]) {
                        dp[i] = dp[j] + 1;
                        parent[i] = j;
                    }
                }
            }
            if (dp[i] > maxLen) {
                maxLen = dp[i];
            }
        }
        
        printf(""%d\n"", maxLen);
    }
    
    return 0;
}
",0
p00157,"マトリョーシカ
マトリョーシカとは女性像をかたどった木製の人形で、ロシアの代表的な民芸品です。マトリョーシカは、大きな人形の中にそれより小さな人形が入っている入れ子構造になっており、大きさの異なる複数の人形で構成されています。このような入れ子構造にするため、各人形の胴体は上下で分割できる筒状の構造になっています。マトリョーシカは職人の手で手作りされるため、一つ一つの人形は世界に一つしかない非常に貴重なものになります。
兄弟である一郎君と次郎君は、マトリョーシカで遊ぶのが大好きで、各自がそれぞれ1組のマトリョーシカを持っていました。一郎君のマトリョーシカは
n
個の人形から構成されており、次郎君のマトリョーシカは
m
個の人形から構成されています。
ある日、好奇心が旺盛な一郎君は、これら2組のマトリョーシカに含まれる人形たちを組み合わせて、より多くの人形を含む新たなマトリョーシカを作れないかと考えました。つまり、
n + m
個の人形を使い、
k
個の人形からなる１組のマトリョーシカを作ることを試みたのです。
n
と
m
の大きい方よりも
k
を大きくすることができれば、一郎君の目的は達成されます。
兄弟は2人仲良く、どのように人形を組み合わせれば
k
の値を最大にできるかを考えました。しかし、幼い2人にとってこの問題はあまりにも難しいので、年上のあなたはプログラムを作成して弟たちを助けることにしました。
一郎君と次郎君のマトリョーシカの人形の情報を入力とし、新たなマトリョーシカが含む人形の数
k
を出力するプログラムを作成して下さい。入力される人形に大きさが同じものは存在しません。また、人形を高さ
h
半径
r
の円柱とみなした場合、高さ
h
、半径
r
の人形が含むことのできる人形は
x < h
かつ
y < r
を満たす高さ
x
半径
y
の人形です。
Input
複数のデータセットの並びが入力として与えられます。入力の終わりはゼロひとつの行で示されます。各データセットは以下の形式で与えられます。
n
h
1
r
1
h
2
r
2
:
h
n
r
n
m
h
1
r
1
h
2
r
2
:
h
m
r
m
１行目に一郎君のマトリョーシカの人形の数
n
(
n
≤ 100)、続く
n
行に一郎君の第
i
の人形の高さ
h
i
と半径
r
i
(
h
i
,
r
i
< 1000) が与えられます。
続く行に二郎君のマトリョーシカの人形の数
m
(
m
≤ 100)、続く
m
行に二郎君の第
i
の人形の高さ
h
i
と半径
r
i
(
h
i
,
r
i
< 1000) が与えられます。
データセットの数は 20 を越えない。
Output
入力データセットごとに新たなマトリョーシカが含む人形の数
k
を出力します。
Sample Input
6
1 1
4 3
6 5
8 6
10 10
14 14
5
2 2
5 4
6 6
9 8
15 10
4
1 1
4 3
6 5
8 6
3
2 2
5 4
6 6
4
1 1
4 3
6 5
8 6
4
10 10
12 11
18 15
24 20
0
Output for the Sample Input
9
6
8",C,"#include <stdio.h>
#include <stdlib.h>
#include <string.h>

typedef struct {
	int h;
	int r;
} DOLL;

int cmp(const void *a, const void *b)
{
	DOLL x, y;
	
	x = *(DOLL *)a;
	y = *(DOLL *)b;
	
	if (x.r - y.r){
		return (x.r - y.r);
	}
	return (x.h - y.h);
}

int main(void)
{
	DOLL rusd[256];
	int dp[256];
	int n, m;
	int i, j;
	int ans;
	
	while (1){
		ans = 0;
		memset(dp, 0, sizeof(dp));
		scanf(""%d"", &n);
		if (n == 0) break;
		for (i = 0; i < n; i++){
			scanf(""%d %d"", &rusd[i].h, &rusd[i].r);
		}
		scanf(""%d"", &m);
		for (j = 0; j < m; j++){
			scanf(""%d %d"", &rusd[n + j].h, &rusd[n + j].r);
		}
		qsort(rusd, n + m, sizeof(DOLL), cmp);
		
		for (i = 0; i < n + m; i++){
			dp[i] = 1;
			for (j = 0; j < i; j++){
				if (rusd[i].h > rusd[j].h && rusd[i].r > rusd[j].r){
					if (dp[i] < dp[j] + 1){
						dp[i] = dp[j] + 1;
						if (ans < dp[i]){
							ans = dp[i];
						}
					}
				}
			}
		}
		printf(""%d\n"", ans);
	}
	
	return (0);
}",1
p00157,"マトリョーシカ
マトリョーシカとは女性像をかたどった木製の人形で、ロシアの代表的な民芸品です。マトリョーシカは、大きな人形の中にそれより小さな人形が入っている入れ子構造になっており、大きさの異なる複数の人形で構成されています。このような入れ子構造にするため、各人形の胴体は上下で分割できる筒状の構造になっています。マトリョーシカは職人の手で手作りされるため、一つ一つの人形は世界に一つしかない非常に貴重なものになります。
兄弟である一郎君と次郎君は、マトリョーシカで遊ぶのが大好きで、各自がそれぞれ1組のマトリョーシカを持っていました。一郎君のマトリョーシカは
n
個の人形から構成されており、次郎君のマトリョーシカは
m
個の人形から構成されています。
ある日、好奇心が旺盛な一郎君は、これら2組のマトリョーシカに含まれる人形たちを組み合わせて、より多くの人形を含む新たなマトリョーシカを作れないかと考えました。つまり、
n + m
個の人形を使い、
k
個の人形からなる１組のマトリョーシカを作ることを試みたのです。
n
と
m
の大きい方よりも
k
を大きくすることができれば、一郎君の目的は達成されます。
兄弟は2人仲良く、どのように人形を組み合わせれば
k
の値を最大にできるかを考えました。しかし、幼い2人にとってこの問題はあまりにも難しいので、年上のあなたはプログラムを作成して弟たちを助けることにしました。
一郎君と次郎君のマトリョーシカの人形の情報を入力とし、新たなマトリョーシカが含む人形の数
k
を出力するプログラムを作成して下さい。入力される人形に大きさが同じものは存在しません。また、人形を高さ
h
半径
r
の円柱とみなした場合、高さ
h
、半径
r
の人形が含むことのできる人形は
x < h
かつ
y < r
を満たす高さ
x
半径
y
の人形です。
Input
複数のデータセットの並びが入力として与えられます。入力の終わりはゼロひとつの行で示されます。各データセットは以下の形式で与えられます。
n
h
1
r
1
h
2
r
2
:
h
n
r
n
m
h
1
r
1
h
2
r
2
:
h
m
r
m
１行目に一郎君のマトリョーシカの人形の数
n
(
n
≤ 100)、続く
n
行に一郎君の第
i
の人形の高さ
h
i
と半径
r
i
(
h
i
,
r
i
< 1000) が与えられます。
続く行に二郎君のマトリョーシカの人形の数
m
(
m
≤ 100)、続く
m
行に二郎君の第
i
の人形の高さ
h
i
と半径
r
i
(
h
i
,
r
i
< 1000) が与えられます。
データセットの数は 20 を越えない。
Output
入力データセットごとに新たなマトリョーシカが含む人形の数
k
を出力します。
Sample Input
6
1 1
4 3
6 5
8 6
10 10
14 14
5
2 2
5 4
6 6
9 8
15 10
4
1 1
4 3
6 5
8 6
3
2 2
5 4
6 6
4
1 1
4 3
6 5
8 6
4
10 10
12 11
18 15
24 20
0
Output for the Sample Input
9
6
8",Java,"import java.util.*;

public class Main {
    static class Doll implements Comparable<Doll> {
        int h, r;
        
        Doll(int h, int r) {
            this.h = h;
            this.r = r;
        }
        
        @Override
        public int compareTo(Doll other) {
            if (this.h != other.h) {
                return this.h - other.h;
            }
            return this.r - other.r;
        }
    }
    
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        
        while (true) {
            int n = sc.nextInt();
            if (n == 0) break;
            
            List<Doll> dolls = new ArrayList<>();
            
            for (int i = 0; i < n; i++) {
                int h = sc.nextInt();
                int r = sc.nextInt();
                dolls.add(new Doll(h, r));
            }
            
            int m = sc.nextInt();
            for (int i = 0; i < m; i++) {
                int h = sc.nextInt();
                int r = sc.nextInt();
                dolls.add(new Doll(h, r));
            }
            
            Collections.sort(dolls);
            
            int[] dp = new int[dolls.size()];
            Arrays.fill(dp, 1);
            
            for (int i = 1; i < dolls.size(); i++) {
                for (int j = 0; j < i; j++) {
                    if (dolls.get(j).h < dolls.get(i).h && dolls.get(j).r < dolls.get(i).r) {
                        dp[i] = Math.max(dp[i], dp[j] + 1);
                    }
                }
            }
            
            int max = 0;
            for (int i = 0; i < dolls.size(); i++) {
                max = Math.max(max, dp[i]);
            }
            
            System.out.println(max);
        }
        
        sc.close();
    }
}
",0
p00157,"マトリョーシカ
マトリョーシカとは女性像をかたどった木製の人形で、ロシアの代表的な民芸品です。マトリョーシカは、大きな人形の中にそれより小さな人形が入っている入れ子構造になっており、大きさの異なる複数の人形で構成されています。このような入れ子構造にするため、各人形の胴体は上下で分割できる筒状の構造になっています。マトリョーシカは職人の手で手作りされるため、一つ一つの人形は世界に一つしかない非常に貴重なものになります。
兄弟である一郎君と次郎君は、マトリョーシカで遊ぶのが大好きで、各自がそれぞれ1組のマトリョーシカを持っていました。一郎君のマトリョーシカは
n
個の人形から構成されており、次郎君のマトリョーシカは
m
個の人形から構成されています。
ある日、好奇心が旺盛な一郎君は、これら2組のマトリョーシカに含まれる人形たちを組み合わせて、より多くの人形を含む新たなマトリョーシカを作れないかと考えました。つまり、
n + m
個の人形を使い、
k
個の人形からなる１組のマトリョーシカを作ることを試みたのです。
n
と
m
の大きい方よりも
k
を大きくすることができれば、一郎君の目的は達成されます。
兄弟は2人仲良く、どのように人形を組み合わせれば
k
の値を最大にできるかを考えました。しかし、幼い2人にとってこの問題はあまりにも難しいので、年上のあなたはプログラムを作成して弟たちを助けることにしました。
一郎君と次郎君のマトリョーシカの人形の情報を入力とし、新たなマトリョーシカが含む人形の数
k
を出力するプログラムを作成して下さい。入力される人形に大きさが同じものは存在しません。また、人形を高さ
h
半径
r
の円柱とみなした場合、高さ
h
、半径
r
の人形が含むことのできる人形は
x < h
かつ
y < r
を満たす高さ
x
半径
y
の人形です。
Input
複数のデータセットの並びが入力として与えられます。入力の終わりはゼロひとつの行で示されます。各データセットは以下の形式で与えられます。
n
h
1
r
1
h
2
r
2
:
h
n
r
n
m
h
1
r
1
h
2
r
2
:
h
m
r
m
１行目に一郎君のマトリョーシカの人形の数
n
(
n
≤ 100)、続く
n
行に一郎君の第
i
の人形の高さ
h
i
と半径
r
i
(
h
i
,
r
i
< 1000) が与えられます。
続く行に二郎君のマトリョーシカの人形の数
m
(
m
≤ 100)、続く
m
行に二郎君の第
i
の人形の高さ
h
i
と半径
r
i
(
h
i
,
r
i
< 1000) が与えられます。
データセットの数は 20 を越えない。
Output
入力データセットごとに新たなマトリョーシカが含む人形の数
k
を出力します。
Sample Input
6
1 1
4 3
6 5
8 6
10 10
14 14
5
2 2
5 4
6 6
9 8
15 10
4
1 1
4 3
6 5
8 6
3
2 2
5 4
6 6
4
1 1
4 3
6 5
8 6
4
10 10
12 11
18 15
24 20
0
Output for the Sample Input
9
6
8",Java,"import java.util.Arrays;
import java.util.Scanner;

public class Main {
	MyScanner sc = new MyScanner();
	Scanner sc2 = new Scanner(System.in);
	int mod = 1000000007;
	int[][] data;
	int[] memo;
	boolean[] use;
	int n, m, N;

	void run() {
		for (;;) {
			n = sc.nextInt();
			if (n == 0) {
				return;
			}
			data = new int[201][2];
			for (int i = 0; i < n; i++) {
				data[i][0] = sc.nextInt();
				data[i][1] = sc.nextInt();
			}
			m = sc.nextInt();
			for (int i = n; i < m + n; i++) {
				data[i][0] = sc.nextInt();
				data[i][1] = sc.nextInt();
			}

			N = n + m;
			memo = new int[n + m];
			use = new boolean[n + m];
			int ans = 0;
			for (int i = 0; i < N; i++) {
				ans = Math.max(ans, dfs(i));
			}
			System.out.println(ans);
		}
	}

	int dfs(int index) {
		if (memo[index] > 0) {
			return memo[index];
		}
		int res = 1;
		use[index] = true;
		for (int i = 0; i < N; i++) {
			if (!use[i]) {
				if (data[i][0] < data[index][0] && data[i][1] < data[index][1]) {
					res = Math.max(res, dfs(i) + 1);
				}
			}
		}
		use[index] = false;
		return memo[index] = res;
	}

	public static void main(String[] args) {
		new Main().run();
	}

	void debug(Object... o) {
		System.out.println(Arrays.deepToString(o));
	}

	void debug2(int[][] array) {
		for (int i = 0; i < array.length; i++) {
			for (int j = 0; j < array[i].length; j++) {
				System.out.print(array[i][j]);
			}
			System.out.println();
		}
	}

	class MyScanner {
		int nextInt() {
			try {
				int c = System.in.read();
				while (c != '-' && (c < '0' || '9' < c))
					c = System.in.read();
				if (c == '-')
					return -nextInt();
				int res = 0;
				do {
					res *= 10;
					res += c - '0';
					c = System.in.read();
				} while ('0' <= c && c <= '9');
				return res;
			} catch (Exception e) {
				return -1;
			}
		}

		double nextDouble() {
			return Double.parseDouble(next());
		}

		String next() {
			try {
				StringBuilder res = new StringBuilder("""");
				int c = System.in.read();
				while (Character.isWhitespace(c))
					c = System.in.read();
				do {
					res.append((char) c);
				} while (!Character.isWhitespace(c = System.in.read()));
				return res.toString();
			} catch (Exception e) {
				return null;
			}
		}
	}
}",1
p00157,"マトリョーシカ
マトリョーシカとは女性像をかたどった木製の人形で、ロシアの代表的な民芸品です。マトリョーシカは、大きな人形の中にそれより小さな人形が入っている入れ子構造になっており、大きさの異なる複数の人形で構成されています。このような入れ子構造にするため、各人形の胴体は上下で分割できる筒状の構造になっています。マトリョーシカは職人の手で手作りされるため、一つ一つの人形は世界に一つしかない非常に貴重なものになります。
兄弟である一郎君と次郎君は、マトリョーシカで遊ぶのが大好きで、各自がそれぞれ1組のマトリョーシカを持っていました。一郎君のマトリョーシカは
n
個の人形から構成されており、次郎君のマトリョーシカは
m
個の人形から構成されています。
ある日、好奇心が旺盛な一郎君は、これら2組のマトリョーシカに含まれる人形たちを組み合わせて、より多くの人形を含む新たなマトリョーシカを作れないかと考えました。つまり、
n + m
個の人形を使い、
k
個の人形からなる１組のマトリョーシカを作ることを試みたのです。
n
と
m
の大きい方よりも
k
を大きくすることができれば、一郎君の目的は達成されます。
兄弟は2人仲良く、どのように人形を組み合わせれば
k
の値を最大にできるかを考えました。しかし、幼い2人にとってこの問題はあまりにも難しいので、年上のあなたはプログラムを作成して弟たちを助けることにしました。
一郎君と次郎君のマトリョーシカの人形の情報を入力とし、新たなマトリョーシカが含む人形の数
k
を出力するプログラムを作成して下さい。入力される人形に大きさが同じものは存在しません。また、人形を高さ
h
半径
r
の円柱とみなした場合、高さ
h
、半径
r
の人形が含むことのできる人形は
x < h
かつ
y < r
を満たす高さ
x
半径
y
の人形です。
Input
複数のデータセットの並びが入力として与えられます。入力の終わりはゼロひとつの行で示されます。各データセットは以下の形式で与えられます。
n
h
1
r
1
h
2
r
2
:
h
n
r
n
m
h
1
r
1
h
2
r
2
:
h
m
r
m
１行目に一郎君のマトリョーシカの人形の数
n
(
n
≤ 100)、続く
n
行に一郎君の第
i
の人形の高さ
h
i
と半径
r
i
(
h
i
,
r
i
< 1000) が与えられます。
続く行に二郎君のマトリョーシカの人形の数
m
(
m
≤ 100)、続く
m
行に二郎君の第
i
の人形の高さ
h
i
と半径
r
i
(
h
i
,
r
i
< 1000) が与えられます。
データセットの数は 20 を越えない。
Output
入力データセットごとに新たなマトリョーシカが含む人形の数
k
を出力します。
Sample Input
6
1 1
4 3
6 5
8 6
10 10
14 14
5
2 2
5 4
6 6
9 8
15 10
4
1 1
4 3
6 5
8 6
3
2 2
5 4
6 6
4
1 1
4 3
6 5
8 6
4
10 10
12 11
18 15
24 20
0
Output for the Sample Input
9
6
8",Python,"import sys
from bisect import bisect_left

def longest_chain(dolls):
    if not dolls:
        return 0
    
    # Sort by height, then by radius
    dolls.sort()
    
    # dp[i] = minimum radius for a chain of length i+1
    dp = []
    
    for h, r in dolls:
        # Find the longest chain where we can add this doll
        # We need to find largest index where dp[index] < r
        pos = bisect_left(dp, r)
        
        if pos < len(dp):
            dp[pos] = r
        else:
            dp.append(r)
    
    return len(dp)

while True:
    n = int(input())
    if n == 0:
        break
    
    dolls1 = []
    for _ in range(n):
        h, r = map(int, input().split())
        dolls1.append((h, r))
    
    m = int(input())
    dolls2 = []
    for _ in range(m):
        h, r = map(int, input().split())
        dolls2.append((h, r))
    
    # Combine all dolls
    all_dolls = dolls1 + dolls2
    
    # Find longest chain
    result = longest_chain(all_dolls)
    print(result)
",0
p00157,"マトリョーシカ
マトリョーシカとは女性像をかたどった木製の人形で、ロシアの代表的な民芸品です。マトリョーシカは、大きな人形の中にそれより小さな人形が入っている入れ子構造になっており、大きさの異なる複数の人形で構成されています。このような入れ子構造にするため、各人形の胴体は上下で分割できる筒状の構造になっています。マトリョーシカは職人の手で手作りされるため、一つ一つの人形は世界に一つしかない非常に貴重なものになります。
兄弟である一郎君と次郎君は、マトリョーシカで遊ぶのが大好きで、各自がそれぞれ1組のマトリョーシカを持っていました。一郎君のマトリョーシカは
n
個の人形から構成されており、次郎君のマトリョーシカは
m
個の人形から構成されています。
ある日、好奇心が旺盛な一郎君は、これら2組のマトリョーシカに含まれる人形たちを組み合わせて、より多くの人形を含む新たなマトリョーシカを作れないかと考えました。つまり、
n + m
個の人形を使い、
k
個の人形からなる１組のマトリョーシカを作ることを試みたのです。
n
と
m
の大きい方よりも
k
を大きくすることができれば、一郎君の目的は達成されます。
兄弟は2人仲良く、どのように人形を組み合わせれば
k
の値を最大にできるかを考えました。しかし、幼い2人にとってこの問題はあまりにも難しいので、年上のあなたはプログラムを作成して弟たちを助けることにしました。
一郎君と次郎君のマトリョーシカの人形の情報を入力とし、新たなマトリョーシカが含む人形の数
k
を出力するプログラムを作成して下さい。入力される人形に大きさが同じものは存在しません。また、人形を高さ
h
半径
r
の円柱とみなした場合、高さ
h
、半径
r
の人形が含むことのできる人形は
x < h
かつ
y < r
を満たす高さ
x
半径
y
の人形です。
Input
複数のデータセットの並びが入力として与えられます。入力の終わりはゼロひとつの行で示されます。各データセットは以下の形式で与えられます。
n
h
1
r
1
h
2
r
2
:
h
n
r
n
m
h
1
r
1
h
2
r
2
:
h
m
r
m
１行目に一郎君のマトリョーシカの人形の数
n
(
n
≤ 100)、続く
n
行に一郎君の第
i
の人形の高さ
h
i
と半径
r
i
(
h
i
,
r
i
< 1000) が与えられます。
続く行に二郎君のマトリョーシカの人形の数
m
(
m
≤ 100)、続く
m
行に二郎君の第
i
の人形の高さ
h
i
と半径
r
i
(
h
i
,
r
i
< 1000) が与えられます。
データセットの数は 20 を越えない。
Output
入力データセットごとに新たなマトリョーシカが含む人形の数
k
を出力します。
Sample Input
6
1 1
4 3
6 5
8 6
10 10
14 14
5
2 2
5 4
6 6
9 8
15 10
4
1 1
4 3
6 5
8 6
3
2 2
5 4
6 6
4
1 1
4 3
6 5
8 6
4
10 10
12 11
18 15
24 20
0
Output for the Sample Input
9
6
8",Python,"from operator import itemgetter

def f(f1, f2):
    res = 1
    c = 0
    i = 0
    while c < len(L)-1:
        if L[i][f1] > L[i+1][f1] and L[i][f2] > L[i+1][f2]:
            res += 1
            i += 1
        else:
            del L[i+1]
        c += 1
    return res

while True:
    n = input()
    if n == 0: break
    L = [map(int, raw_input().split()) for i in range(n)]
    for i in range(input()):
        L.append(map(int, raw_input().split()))
    else:
        h = 0
        r = 1
        L.sort(key=itemgetter(0,1), reverse=True)
        res1 = f(h, r)
        L.sort(key=itemgetter(1,0), reverse=True)
        res2 = f(r, h)
        if res2 < res1:
            print res1
        else:
            print res2",1
p00158,"コラッツの予想
正の整数
n
に対し、
n
が偶数の時は 2 で割る。
n
が奇数の時は 3 倍し、1 を足す。
という操作を繰り返すと結果が 1 になります。任意の正の整数
n
に対してこの操作を繰り返すと必ず 1 になるであろうというのが「コラッツの予想」と呼ばれる問題です。この問題は日本では、「角谷の問題」としても知られている未解決の問題です。コンピュータを利用して非常に大きな数 3 × 2
53
= 27,021,597,764,222,976 以下については反例がないことが知られていますが、数学的には証明されていません。
整数
n
を入力とし、結果が 1 になるまでに繰り返される操作の回数を出力するプログラムを作成してください。整数
n
は 1 以上でかつ上記の計算を繰り返す途中の値が 1000000 以下となる程度の整数とします。たとえば、入力として 3 を受け取った場合は、操作列は
3 → 10 → 5 → 16 → 8 → 4 → 2 → 1
になるので、操作の回数（上の矢印の個数）である 7 を出力します。
Input
複数のデータセットの並びが入力として与えられます。入力の終わりはゼロひとつの行で示されます。
各データセットとして１つの整数
n
(
n
≤ 1000000) が１行に与えられます。
データセットの数は 50 を越えない。
Output
データセットごとに操作の回数を１行に出力します。
Sample Input
3
10
0
Output for the Sample Input
7
6",C,"#include <stdio.h>

int main() {
    int n;
    
    while(1) {
        scanf(""%d"", &n);
        if(n == 0) break;
        
        int count = 0;
        while(n != 1) {
            if(n % 2 == 0) {
                n = n / 2;
            } else {
                n = 3 * n + 1;
            }
            count++;
        }
        
        printf(""%d\n"", count);
    }
    
    return 0;
}
",0
p00158,"コラッツの予想
正の整数
n
に対し、
n
が偶数の時は 2 で割る。
n
が奇数の時は 3 倍し、1 を足す。
という操作を繰り返すと結果が 1 になります。任意の正の整数
n
に対してこの操作を繰り返すと必ず 1 になるであろうというのが「コラッツの予想」と呼ばれる問題です。この問題は日本では、「角谷の問題」としても知られている未解決の問題です。コンピュータを利用して非常に大きな数 3 × 2
53
= 27,021,597,764,222,976 以下については反例がないことが知られていますが、数学的には証明されていません。
整数
n
を入力とし、結果が 1 になるまでに繰り返される操作の回数を出力するプログラムを作成してください。整数
n
は 1 以上でかつ上記の計算を繰り返す途中の値が 1000000 以下となる程度の整数とします。たとえば、入力として 3 を受け取った場合は、操作列は
3 → 10 → 5 → 16 → 8 → 4 → 2 → 1
になるので、操作の回数（上の矢印の個数）である 7 を出力します。
Input
複数のデータセットの並びが入力として与えられます。入力の終わりはゼロひとつの行で示されます。
各データセットとして１つの整数
n
(
n
≤ 1000000) が１行に与えられます。
データセットの数は 50 を越えない。
Output
データセットごとに操作の回数を１行に出力します。
Sample Input
3
10
0
Output for the Sample Input
7
6",C,"#include<stdio.h>
int main(){
  int n,c;
  while(1){
    scanf(""%d"",&n);
    if(n==0)break;
    for(c=0;n!=1;c++){
      if(n%2==0){
	n/=2;
      }
      else{
	n=n*3+1;
      }
    }
    printf(""%d\n"",c);
  }
  return 0;
}",1
p00158,"コラッツの予想
正の整数
n
に対し、
n
が偶数の時は 2 で割る。
n
が奇数の時は 3 倍し、1 を足す。
という操作を繰り返すと結果が 1 になります。任意の正の整数
n
に対してこの操作を繰り返すと必ず 1 になるであろうというのが「コラッツの予想」と呼ばれる問題です。この問題は日本では、「角谷の問題」としても知られている未解決の問題です。コンピュータを利用して非常に大きな数 3 × 2
53
= 27,021,597,764,222,976 以下については反例がないことが知られていますが、数学的には証明されていません。
整数
n
を入力とし、結果が 1 になるまでに繰り返される操作の回数を出力するプログラムを作成してください。整数
n
は 1 以上でかつ上記の計算を繰り返す途中の値が 1000000 以下となる程度の整数とします。たとえば、入力として 3 を受け取った場合は、操作列は
3 → 10 → 5 → 16 → 8 → 4 → 2 → 1
になるので、操作の回数（上の矢印の個数）である 7 を出力します。
Input
複数のデータセットの並びが入力として与えられます。入力の終わりはゼロひとつの行で示されます。
各データセットとして１つの整数
n
(
n
≤ 1000000) が１行に与えられます。
データセットの数は 50 を越えない。
Output
データセットごとに操作の回数を１行に出力します。
Sample Input
3
10
0
Output for the Sample Input
7
6",Java,"import java.util.Scanner;

public class Main {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        
        while (true) {
            int n = sc.nextInt();
            if (n == 0) break;
            
            int count = 0;
            while (n != 1) {
                if (n % 2 == 0) {
                    n = n / 2;
                } else {
                    n = n * 3 + 1;
                }
                count++;
            }
            
            System.out.println(count);
        }
        
        sc.close();
    }
}
",0
p00158,"コラッツの予想
正の整数
n
に対し、
n
が偶数の時は 2 で割る。
n
が奇数の時は 3 倍し、1 を足す。
という操作を繰り返すと結果が 1 になります。任意の正の整数
n
に対してこの操作を繰り返すと必ず 1 になるであろうというのが「コラッツの予想」と呼ばれる問題です。この問題は日本では、「角谷の問題」としても知られている未解決の問題です。コンピュータを利用して非常に大きな数 3 × 2
53
= 27,021,597,764,222,976 以下については反例がないことが知られていますが、数学的には証明されていません。
整数
n
を入力とし、結果が 1 になるまでに繰り返される操作の回数を出力するプログラムを作成してください。整数
n
は 1 以上でかつ上記の計算を繰り返す途中の値が 1000000 以下となる程度の整数とします。たとえば、入力として 3 を受け取った場合は、操作列は
3 → 10 → 5 → 16 → 8 → 4 → 2 → 1
になるので、操作の回数（上の矢印の個数）である 7 を出力します。
Input
複数のデータセットの並びが入力として与えられます。入力の終わりはゼロひとつの行で示されます。
各データセットとして１つの整数
n
(
n
≤ 1000000) が１行に与えられます。
データセットの数は 50 を越えない。
Output
データセットごとに操作の回数を１行に出力します。
Sample Input
3
10
0
Output for the Sample Input
7
6",Java,"import java.util.*;
import java.io.*;

class Main {

    public static void main(String[] args) {

	final Scanner stdin = new Scanner(System.in);

	while ( true ) {
	    int n = stdin.nextInt();
	    if ( n == 0 ) {
		break;
	    }

	    int count = 0;
	    while ( n != 1 ) {
		if ( n % 2 == 0 ) {
		    n /= 2;
		} else {
		    n = n * 3 + 1;
		}
		count++;
	    }
	    System.out.println( count );
	}	
    }    
}",1
p00158,"コラッツの予想
正の整数
n
に対し、
n
が偶数の時は 2 で割る。
n
が奇数の時は 3 倍し、1 を足す。
という操作を繰り返すと結果が 1 になります。任意の正の整数
n
に対してこの操作を繰り返すと必ず 1 になるであろうというのが「コラッツの予想」と呼ばれる問題です。この問題は日本では、「角谷の問題」としても知られている未解決の問題です。コンピュータを利用して非常に大きな数 3 × 2
53
= 27,021,597,764,222,976 以下については反例がないことが知られていますが、数学的には証明されていません。
整数
n
を入力とし、結果が 1 になるまでに繰り返される操作の回数を出力するプログラムを作成してください。整数
n
は 1 以上でかつ上記の計算を繰り返す途中の値が 1000000 以下となる程度の整数とします。たとえば、入力として 3 を受け取った場合は、操作列は
3 → 10 → 5 → 16 → 8 → 4 → 2 → 1
になるので、操作の回数（上の矢印の個数）である 7 を出力します。
Input
複数のデータセットの並びが入力として与えられます。入力の終わりはゼロひとつの行で示されます。
各データセットとして１つの整数
n
(
n
≤ 1000000) が１行に与えられます。
データセットの数は 50 を越えない。
Output
データセットごとに操作の回数を１行に出力します。
Sample Input
3
10
0
Output for the Sample Input
7
6",Python,"while True:
    n = int(input())
    if n == 0:
        break
    
    count = 0
    while n != 1:
        if n % 2 == 0:
            n = n // 2
        else:
            n = 3 * n + 1
        count += 1
    
    print(count)
",0
p00158,"コラッツの予想
正の整数
n
に対し、
n
が偶数の時は 2 で割る。
n
が奇数の時は 3 倍し、1 を足す。
という操作を繰り返すと結果が 1 になります。任意の正の整数
n
に対してこの操作を繰り返すと必ず 1 になるであろうというのが「コラッツの予想」と呼ばれる問題です。この問題は日本では、「角谷の問題」としても知られている未解決の問題です。コンピュータを利用して非常に大きな数 3 × 2
53
= 27,021,597,764,222,976 以下については反例がないことが知られていますが、数学的には証明されていません。
整数
n
を入力とし、結果が 1 になるまでに繰り返される操作の回数を出力するプログラムを作成してください。整数
n
は 1 以上でかつ上記の計算を繰り返す途中の値が 1000000 以下となる程度の整数とします。たとえば、入力として 3 を受け取った場合は、操作列は
3 → 10 → 5 → 16 → 8 → 4 → 2 → 1
になるので、操作の回数（上の矢印の個数）である 7 を出力します。
Input
複数のデータセットの並びが入力として与えられます。入力の終わりはゼロひとつの行で示されます。
各データセットとして１つの整数
n
(
n
≤ 1000000) が１行に与えられます。
データセットの数は 50 を越えない。
Output
データセットごとに操作の回数を１行に出力します。
Sample Input
3
10
0
Output for the Sample Input
7
6",Python,"while True:
	n = int(input())
	if n == 0: break
	k = 0
	while n > 1:
		if n & 1:
			n = n + ((n+1)>>1)
			k += 2
		else:
			n >>= 1
			k += 1
	print(k)
",1
p00159,"理想の体型
肥満度を表す指数としてBMI（Body Mass Index）があります。BMIの値は以下の式で計算します。
BMI = 体重(kg) / (身長(m))
2
BMIの値が標準値に近いほど「理想の体型」と考えられます。そこで、BMIの標準値を 22 とした場合、対象者の情報を入力とし、最も「理想の体型」に近い人の情報を出力するプログラムを作成してください。
対象者の数を
n
とすると、各対象者には重複のないように1 以上
n
以下の整数値の受付番号
p
が振られています。
Input
複数のデータセットの並びが入力として与えられます。入力の終わりはゼロひとつの行で示されます。各データセットは以下の形式で与えられます。
n
p
1
h
1
w
1
p
2
h
2
w
2
:
p
n
h
n
w
n
１行目に対象者の人数
n
(
n
≤ 1000)、続く
n
行に
i
人目の対象者の受付番号
p
i
(1 ≤
p
i
≤
n
)、センチメートル単位の身長
h
i
(1 ≤
h
i
≤ 200)、キログラム単位の体重
w
i
(1 ≤
w
i
≤ 200) が与えられます。入力は全て整数で与えられます。
Output
データセットごとに「理想の体型」に最も近い人の受付番号（整数）を１行に出力します。最も「理想の体型」に近い人が二人以上いる場合は、受付番号の小さい方を出力することとします。
Sample Input
6
1 165 66
2 178 60
3 180 72
4 160 65
5 185 62
6 182 62
3
3 160 65
2 180 70
1 170 75
0
Output for the Sample Input
3
2",C,"#include <stdio.h>
#include <math.h>

int main() {
    int n;
    
    while(scanf(""%d"", &n) == 1 && n != 0) {
        int best_p = -1;
        double min_diff = -1;
        
        for(int i = 0; i < n; i++) {
            int p, h, w;
            scanf(""%d %d %d"", &p, &h, &w);
            
            double height_m = h / 100.0;
            double bmi = w / (height_m * height_m);
            double diff = fabs(bmi - 22.0);
            
            if(min_diff < 0 || diff < min_diff || (diff == min_diff && p < best_p)) {
                min_diff = diff;
                best_p = p;
            }
        }
        
        printf(""%d\n"", best_p);
    }
    
    return 0;
}
",0
p00159,"理想の体型
肥満度を表す指数としてBMI（Body Mass Index）があります。BMIの値は以下の式で計算します。
BMI = 体重(kg) / (身長(m))
2
BMIの値が標準値に近いほど「理想の体型」と考えられます。そこで、BMIの標準値を 22 とした場合、対象者の情報を入力とし、最も「理想の体型」に近い人の情報を出力するプログラムを作成してください。
対象者の数を
n
とすると、各対象者には重複のないように1 以上
n
以下の整数値の受付番号
p
が振られています。
Input
複数のデータセットの並びが入力として与えられます。入力の終わりはゼロひとつの行で示されます。各データセットは以下の形式で与えられます。
n
p
1
h
1
w
1
p
2
h
2
w
2
:
p
n
h
n
w
n
１行目に対象者の人数
n
(
n
≤ 1000)、続く
n
行に
i
人目の対象者の受付番号
p
i
(1 ≤
p
i
≤
n
)、センチメートル単位の身長
h
i
(1 ≤
h
i
≤ 200)、キログラム単位の体重
w
i
(1 ≤
w
i
≤ 200) が与えられます。入力は全て整数で与えられます。
Output
データセットごとに「理想の体型」に最も近い人の受付番号（整数）を１行に出力します。最も「理想の体型」に近い人が二人以上いる場合は、受付番号の小さい方を出力することとします。
Sample Input
6
1 165 66
2 178 60
3 180 72
4 160 65
5 185 62
6 182 62
3
3 160 65
2 180 70
1 170 75
0
Output for the Sample Input
3
2",C,"#include<stdio.h>
int main(){
int n,a[1001],b[1001],c[1001],i,k=1001;
double x,y,z,d[1001],w=10000;
while(1){
scanf(""%d\n"",&n);
if(n==0){
break;
}
for(i=0;i<n;i++){
scanf(""%d %d %d\n"",&a[i],&b[i],&c[i]);
x=b[i],y=c[i];
x=x/100;
z=y/(x*x);
if(z>22){
z=z-22;
}
else{
z=22-z;
}
d[i]=z;
if((z<w) || (z==w && k>a[i])){
w=z;
k=a[i];
}
}
for(i=0;i<n;i++){
if(w==d[i]){
printf(""%d\n"",a[i]);
break;
}
}
w=10000,k=1001;
}
return 0;
}
",1
p00159,"理想の体型
肥満度を表す指数としてBMI（Body Mass Index）があります。BMIの値は以下の式で計算します。
BMI = 体重(kg) / (身長(m))
2
BMIの値が標準値に近いほど「理想の体型」と考えられます。そこで、BMIの標準値を 22 とした場合、対象者の情報を入力とし、最も「理想の体型」に近い人の情報を出力するプログラムを作成してください。
対象者の数を
n
とすると、各対象者には重複のないように1 以上
n
以下の整数値の受付番号
p
が振られています。
Input
複数のデータセットの並びが入力として与えられます。入力の終わりはゼロひとつの行で示されます。各データセットは以下の形式で与えられます。
n
p
1
h
1
w
1
p
2
h
2
w
2
:
p
n
h
n
w
n
１行目に対象者の人数
n
(
n
≤ 1000)、続く
n
行に
i
人目の対象者の受付番号
p
i
(1 ≤
p
i
≤
n
)、センチメートル単位の身長
h
i
(1 ≤
h
i
≤ 200)、キログラム単位の体重
w
i
(1 ≤
w
i
≤ 200) が与えられます。入力は全て整数で与えられます。
Output
データセットごとに「理想の体型」に最も近い人の受付番号（整数）を１行に出力します。最も「理想の体型」に近い人が二人以上いる場合は、受付番号の小さい方を出力することとします。
Sample Input
6
1 165 66
2 178 60
3 180 72
4 160 65
5 185 62
6 182 62
3
3 160 65
2 180 70
1 170 75
0
Output for the Sample Input
3
2",Java,"import java.util.Scanner;

public class Main {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        
        while (true) {
            int n = sc.nextInt();
            if (n == 0) break;
            
            int bestP = Integer.MAX_VALUE;
            double minDiff = Double.MAX_VALUE;
            
            for (int i = 0; i < n; i++) {
                int p = sc.nextInt();
                int h = sc.nextInt();
                int w = sc.nextInt();
                
                double heightInMeters = h / 100.0;
                double bmi = w / (heightInMeters * heightInMeters);
                double diff = Math.abs(bmi - 22.0);
                
                if (diff < minDiff || (diff == minDiff && p < bestP)) {
                    minDiff = diff;
                    bestP = p;
                }
            }
            
            System.out.println(bestP);
        }
        
        sc.close();
    }
}
",0
p00159,"理想の体型
肥満度を表す指数としてBMI（Body Mass Index）があります。BMIの値は以下の式で計算します。
BMI = 体重(kg) / (身長(m))
2
BMIの値が標準値に近いほど「理想の体型」と考えられます。そこで、BMIの標準値を 22 とした場合、対象者の情報を入力とし、最も「理想の体型」に近い人の情報を出力するプログラムを作成してください。
対象者の数を
n
とすると、各対象者には重複のないように1 以上
n
以下の整数値の受付番号
p
が振られています。
Input
複数のデータセットの並びが入力として与えられます。入力の終わりはゼロひとつの行で示されます。各データセットは以下の形式で与えられます。
n
p
1
h
1
w
1
p
2
h
2
w
2
:
p
n
h
n
w
n
１行目に対象者の人数
n
(
n
≤ 1000)、続く
n
行に
i
人目の対象者の受付番号
p
i
(1 ≤
p
i
≤
n
)、センチメートル単位の身長
h
i
(1 ≤
h
i
≤ 200)、キログラム単位の体重
w
i
(1 ≤
w
i
≤ 200) が与えられます。入力は全て整数で与えられます。
Output
データセットごとに「理想の体型」に最も近い人の受付番号（整数）を１行に出力します。最も「理想の体型」に近い人が二人以上いる場合は、受付番号の小さい方を出力することとします。
Sample Input
6
1 165 66
2 178 60
3 180 72
4 160 65
5 185 62
6 182 62
3
3 160 65
2 180 70
1 170 75
0
Output for the Sample Input
3
2",Java,"import java.util.*;
import java.lang.*;
import java.math.*;
import java.io.*;

import static java.lang.Math.*;
import static java.util.Arrays.*;

public class Main{

	Scanner sc=new Scanner(System.in);

	int INF=1<<28;
	double EPS=1e-9;

	int n;
	R[] rs;

	void run(){
		for(;;){
			n=sc.nextInt();
			if(n==0){
				break;
			}
			rs=new R[n];
			for(int i=0; i<n; i++){
				int id=sc.nextInt();
				int h=sc.nextInt();
				int w=sc.nextInt();
				rs[i]=new R(id, h, w);
			}
			solve();
		}
	}

	void solve(){
		Arrays.sort(rs);
		println(""""+rs[0].id);
	}

	class R implements Comparable<R>{
		int id;
		double error;

		R(int id, int h, int w){
			this.id=id;
			error=Math.abs(22-10000.*w/h/h);
		}

		@Override
		public int compareTo(R r){
			if(error+EPS<r.error){
				return -1;
			}else if(error>r.error+EPS){
				return 1;
			}else{
				return id-r.id;
			}
		}
	}

	void debug(Object... os){
		System.err.println(Arrays.deepToString(os));
	}

	void print(String s){
		System.out.print(s);
	}

	void println(String s){
		System.out.println(s);
	}

	public static void main(String[] args){
		// System.setOut(new PrintStream(new BufferedOutputStream(System.out)));
		new Main().run();
	}
}",1
p00159,"理想の体型
肥満度を表す指数としてBMI（Body Mass Index）があります。BMIの値は以下の式で計算します。
BMI = 体重(kg) / (身長(m))
2
BMIの値が標準値に近いほど「理想の体型」と考えられます。そこで、BMIの標準値を 22 とした場合、対象者の情報を入力とし、最も「理想の体型」に近い人の情報を出力するプログラムを作成してください。
対象者の数を
n
とすると、各対象者には重複のないように1 以上
n
以下の整数値の受付番号
p
が振られています。
Input
複数のデータセットの並びが入力として与えられます。入力の終わりはゼロひとつの行で示されます。各データセットは以下の形式で与えられます。
n
p
1
h
1
w
1
p
2
h
2
w
2
:
p
n
h
n
w
n
１行目に対象者の人数
n
(
n
≤ 1000)、続く
n
行に
i
人目の対象者の受付番号
p
i
(1 ≤
p
i
≤
n
)、センチメートル単位の身長
h
i
(1 ≤
h
i
≤ 200)、キログラム単位の体重
w
i
(1 ≤
w
i
≤ 200) が与えられます。入力は全て整数で与えられます。
Output
データセットごとに「理想の体型」に最も近い人の受付番号（整数）を１行に出力します。最も「理想の体型」に近い人が二人以上いる場合は、受付番号の小さい方を出力することとします。
Sample Input
6
1 165 66
2 178 60
3 180 72
4 160 65
5 185 62
6 182 62
3
3 160 65
2 180 70
1 170 75
0
Output for the Sample Input
3
2",Python,"while True:
    n = int(input())
    if n == 0:
        break
    
    best_person = None
    best_diff = float('inf')
    
    for _ in range(n):
        data = list(map(int, input().split()))
        p, h, w = data[0], data[1], data[2]
        
        # Convert height from cm to m
        h_m = h / 100.0
        
        # Calculate BMI
        bmi = w / (h_m * h_m)
        
        # Calculate difference from ideal BMI (22)
        diff = abs(bmi - 22)
        
        # Update best if this is closer, or same distance but smaller reception number
        if diff < best_diff or (diff == best_diff and p < best_person):
            best_diff = diff
            best_person = p
    
    print(best_person)
",0
p00159,"理想の体型
肥満度を表す指数としてBMI（Body Mass Index）があります。BMIの値は以下の式で計算します。
BMI = 体重(kg) / (身長(m))
2
BMIの値が標準値に近いほど「理想の体型」と考えられます。そこで、BMIの標準値を 22 とした場合、対象者の情報を入力とし、最も「理想の体型」に近い人の情報を出力するプログラムを作成してください。
対象者の数を
n
とすると、各対象者には重複のないように1 以上
n
以下の整数値の受付番号
p
が振られています。
Input
複数のデータセットの並びが入力として与えられます。入力の終わりはゼロひとつの行で示されます。各データセットは以下の形式で与えられます。
n
p
1
h
1
w
1
p
2
h
2
w
2
:
p
n
h
n
w
n
１行目に対象者の人数
n
(
n
≤ 1000)、続く
n
行に
i
人目の対象者の受付番号
p
i
(1 ≤
p
i
≤
n
)、センチメートル単位の身長
h
i
(1 ≤
h
i
≤ 200)、キログラム単位の体重
w
i
(1 ≤
w
i
≤ 200) が与えられます。入力は全て整数で与えられます。
Output
データセットごとに「理想の体型」に最も近い人の受付番号（整数）を１行に出力します。最も「理想の体型」に近い人が二人以上いる場合は、受付番号の小さい方を出力することとします。
Sample Input
6
1 165 66
2 178 60
3 180 72
4 160 65
5 185 62
6 182 62
3
3 160 65
2 180 70
1 170 75
0
Output for the Sample Input
3
2",Python,"while True:
    n = input()
    if n == 0: break
    pb = None
    ans = 0
    for i in range(n):
        i, h, w = map(int, raw_input().split())
        bmi = w/((float(h)/100)**2)
        a = abs(22-bmi)
        if pb is None:
            pb = a
            ans = i
        elif pb is not None and a < pb:
            pb = a
            ans = i
    else:
        print ans",1
p00160,"宅配料金
ある宅配業者の宅配料金は大きさと重量で下表のように料金が設定されています。
A サイズ
B サイズ
C サイズ
D サイズ
E サイズ
F サイズ
大きさ
60cm以内
80cm以内
100cm以内
120cm以内
140cm以内
160cm以内
重さ
2kg以内
5kg以内
10kg以内
15kg以内
20kg以内
25kg以内
料金
600円
800円
1000円
1200円
1400円
1600円
大きさは三辺（縦、横、高さ）の和です。例えば大きさが120cmで、重さが15kg以内の荷物はＤサイズ（1,200円）となります。大きさが120cm以内でも、重さが15kgを超え、20kg以内ならばＥサイズとなります。
1日に持ち込まれた荷物の情報を入力とし、料金の総計を出力するプログラムを作成してください。なお、Ｆサイズを超えた荷物は対象外とし料金の総計には含みません。
Input
複数のデータセットの並びが入力として与えられます。入力の終わりはゼロひとつの行で示されます。
各データセットは以下の形式で与えられます。
n
x
1
y
1
h
1
w
1
x
2
y
2
h
2
w
2
:
x
n
y
n
h
n
w
n
１行目に荷物の個数
n
(1 ≤
n
≤ 10000)、続く
n
行に
i
番目の荷物の縦の長さ
x
i
、横の長さ
y
i
、高さ
h
i
、重さ
w
i
(1 ≤
x
i
,
y
i
,
h
i
,
w
i
≤ 200) が空白区切りで１行に与えられます。
データセットの数は 20 を超えません。
Output
データセットごとに荷物の料金の総計を１行に出力します。
Sample Input
2
50 25 5 5
80 60 10 30
3
10 15 25 24
5 8 12 5
30 30 30 18
0
Output for the Sample Input
800
3800",C,"#include <stdio.h>

int main() {
    int n;
    
    while (1) {
        scanf(""%d"", &n);
        if (n == 0) break;
        
        int total = 0;
        
        for (int i = 0; i < n; i++) {
            int x, y, h, w;
            scanf(""%d %d %d %d"", &x, &y, &h, &w);
            
            int size = x + y + h;
            int price = 0;
            
            // Determine the category based on size and weight
            if (size <= 60 && w <= 2) {
                price = 600;
            } else if (size <= 80 && w <= 5) {
                price = 800;
            } else if (size <= 100 && w <= 10) {
                price = 1000;
            } else if (size <= 120 && w <= 15) {
                price = 1200;
            } else if (size <= 140 && w <= 20) {
                price = 1400;
            } else if (size <= 160 && w <= 25) {
                price = 1600;
            }
            // If it exceeds F size, price remains 0 and won't be added
            
            total += price;
        }
        
        printf(""%d\n"", total);
    }
    
    return 0;
}
",0
p00160,"宅配料金
ある宅配業者の宅配料金は大きさと重量で下表のように料金が設定されています。
A サイズ
B サイズ
C サイズ
D サイズ
E サイズ
F サイズ
大きさ
60cm以内
80cm以内
100cm以内
120cm以内
140cm以内
160cm以内
重さ
2kg以内
5kg以内
10kg以内
15kg以内
20kg以内
25kg以内
料金
600円
800円
1000円
1200円
1400円
1600円
大きさは三辺（縦、横、高さ）の和です。例えば大きさが120cmで、重さが15kg以内の荷物はＤサイズ（1,200円）となります。大きさが120cm以内でも、重さが15kgを超え、20kg以内ならばＥサイズとなります。
1日に持ち込まれた荷物の情報を入力とし、料金の総計を出力するプログラムを作成してください。なお、Ｆサイズを超えた荷物は対象外とし料金の総計には含みません。
Input
複数のデータセットの並びが入力として与えられます。入力の終わりはゼロひとつの行で示されます。
各データセットは以下の形式で与えられます。
n
x
1
y
1
h
1
w
1
x
2
y
2
h
2
w
2
:
x
n
y
n
h
n
w
n
１行目に荷物の個数
n
(1 ≤
n
≤ 10000)、続く
n
行に
i
番目の荷物の縦の長さ
x
i
、横の長さ
y
i
、高さ
h
i
、重さ
w
i
(1 ≤
x
i
,
y
i
,
h
i
,
w
i
≤ 200) が空白区切りで１行に与えられます。
データセットの数は 20 を超えません。
Output
データセットごとに荷物の料金の総計を１行に出力します。
Sample Input
2
50 25 5 5
80 60 10 30
3
10 15 25 24
5 8 12 5
30 30 30 18
0
Output for the Sample Input
800
3800",C,"#include<stdio.h>
int main(){
  int n,x,y,h,w,s,s1,s2,a,i;
  int m[]={600,800,1000,1200,1400,1600,0};
  while(1){
    scanf(""%d"",&n);
    if(n==0)break;
    a=0;
    for(i=0;i<n;i++){
      scanf(""%d %d %d %d"",&x,&y,&h,&w);
      if     (x+y+h>160)s1=6;
      else if(x+y+h>140)s1=5;
      else if(x+y+h>120)s1=4;
      else if(x+y+h>100)s1=3;
      else if(x+y+h> 80)s1=2;
      else if(x+y+h> 60)s1=1;
      else              s1=0;
      if     (w>25)s2=6;
      else if(w>20)s2=5;
      else if(w>15)s2=4;
      else if(w>10)s2=3;
      else if(w>5 )s2=2;
      else if(w>2 )s2=1;
      else         s2=0;
      if(s1>s2)s=s1;
      else     s=s2;
      a+=m[s];
    }
    printf(""%d\n"",a);
  }
  return 0;
}",1
p00160,"宅配料金
ある宅配業者の宅配料金は大きさと重量で下表のように料金が設定されています。
A サイズ
B サイズ
C サイズ
D サイズ
E サイズ
F サイズ
大きさ
60cm以内
80cm以内
100cm以内
120cm以内
140cm以内
160cm以内
重さ
2kg以内
5kg以内
10kg以内
15kg以内
20kg以内
25kg以内
料金
600円
800円
1000円
1200円
1400円
1600円
大きさは三辺（縦、横、高さ）の和です。例えば大きさが120cmで、重さが15kg以内の荷物はＤサイズ（1,200円）となります。大きさが120cm以内でも、重さが15kgを超え、20kg以内ならばＥサイズとなります。
1日に持ち込まれた荷物の情報を入力とし、料金の総計を出力するプログラムを作成してください。なお、Ｆサイズを超えた荷物は対象外とし料金の総計には含みません。
Input
複数のデータセットの並びが入力として与えられます。入力の終わりはゼロひとつの行で示されます。
各データセットは以下の形式で与えられます。
n
x
1
y
1
h
1
w
1
x
2
y
2
h
2
w
2
:
x
n
y
n
h
n
w
n
１行目に荷物の個数
n
(1 ≤
n
≤ 10000)、続く
n
行に
i
番目の荷物の縦の長さ
x
i
、横の長さ
y
i
、高さ
h
i
、重さ
w
i
(1 ≤
x
i
,
y
i
,
h
i
,
w
i
≤ 200) が空白区切りで１行に与えられます。
データセットの数は 20 を超えません。
Output
データセットごとに荷物の料金の総計を１行に出力します。
Sample Input
2
50 25 5 5
80 60 10 30
3
10 15 25 24
5 8 12 5
30 30 30 18
0
Output for the Sample Input
800
3800",Java,"import java.util.Scanner;

public class Main {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        
        while (true) {
            int n = sc.nextInt();
            if (n == 0) break;
            
            int totalCost = 0;
            
            for (int i = 0; i < n; i++) {
                int x = sc.nextInt();
                int y = sc.nextInt();
                int h = sc.nextInt();
                int w = sc.nextInt();
                
                int size = x + y + h;
                int cost = getPrice(size, w);
                totalCost += cost;
            }
            
            System.out.println(totalCost);
        }
        
        sc.close();
    }
    
    static int getPrice(int size, int weight) {
        int[] sizeLimits = {60, 80, 100, 120, 140, 160};
        int[] weightLimits = {2, 5, 10, 15, 20, 25};
        int[] prices = {600, 800, 1000, 1200, 1400, 1600};
        
        for (int i = 0; i < 6; i++) {
            if (size <= sizeLimits[i] && weight <= weightLimits[i]) {
                return prices[i];
            }
        }
        
        return 0;
    }
}
",0
p00160,"宅配料金
ある宅配業者の宅配料金は大きさと重量で下表のように料金が設定されています。
A サイズ
B サイズ
C サイズ
D サイズ
E サイズ
F サイズ
大きさ
60cm以内
80cm以内
100cm以内
120cm以内
140cm以内
160cm以内
重さ
2kg以内
5kg以内
10kg以内
15kg以内
20kg以内
25kg以内
料金
600円
800円
1000円
1200円
1400円
1600円
大きさは三辺（縦、横、高さ）の和です。例えば大きさが120cmで、重さが15kg以内の荷物はＤサイズ（1,200円）となります。大きさが120cm以内でも、重さが15kgを超え、20kg以内ならばＥサイズとなります。
1日に持ち込まれた荷物の情報を入力とし、料金の総計を出力するプログラムを作成してください。なお、Ｆサイズを超えた荷物は対象外とし料金の総計には含みません。
Input
複数のデータセットの並びが入力として与えられます。入力の終わりはゼロひとつの行で示されます。
各データセットは以下の形式で与えられます。
n
x
1
y
1
h
1
w
1
x
2
y
2
h
2
w
2
:
x
n
y
n
h
n
w
n
１行目に荷物の個数
n
(1 ≤
n
≤ 10000)、続く
n
行に
i
番目の荷物の縦の長さ
x
i
、横の長さ
y
i
、高さ
h
i
、重さ
w
i
(1 ≤
x
i
,
y
i
,
h
i
,
w
i
≤ 200) が空白区切りで１行に与えられます。
データセットの数は 20 を超えません。
Output
データセットごとに荷物の料金の総計を１行に出力します。
Sample Input
2
50 25 5 5
80 60 10 30
3
10 15 25 24
5 8 12 5
30 30 30 18
0
Output for the Sample Input
800
3800",Java,"import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.Map.Entry;
import java.util.StringTokenizer;
import java.util.TreeMap;

/**
 * Delivery Fee
 */
public class Main {

	static P0160 main = new P0160();
	static TreeMap<Parcel, Integer> fee = new TreeMap<Parcel, Integer>() {
		{
			put(main.new Parcel(60, 2), 600);
			put(main.new Parcel(80, 5), 800);
			put(main.new Parcel(100, 10), 1000);
			put(main.new Parcel(120, 15), 1200);
			put(main.new Parcel(140, 20), 1400);
			put(main.new Parcel(160, 25), 1600);
		}
	};

	public static void main(String[] args) throws IOException {
		BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
		String line = """";

		while (!(line = br.readLine()).equals(""0"")) {
			int n, sum = 0;
			n = Integer.parseInt(line);
			for (int i = 0; i < n; ++i) {
				Parcel p = main.new Parcel(br.readLine());
				Entry<Parcel, Integer> e;
				if ((e = fee.ceilingEntry(p)) != null) {
					sum += e.getValue();
				}
			}
			System.out.println(sum);
		}
	}

	class Parcel implements Comparable<Parcel> {
		int size, weight;

		Parcel(int size, int weight) {
			this.size = size;
			this.weight = weight;
		}

		Parcel(int x, int y, int h, int w) {
			this(x + y + h, w);
		}

		Parcel(String info) {
			StringTokenizer st = new StringTokenizer(info);
			int x, y, h, w;
			x = Integer.parseInt(st.nextToken());
			y = Integer.parseInt(st.nextToken());
			h = Integer.parseInt(st.nextToken());
			w = Integer.parseInt(st.nextToken());
			size = x + y + h;
			weight = w;
		}

		@Override
		public int compareTo(Parcel o) {
			int r1 = this.weight - o.weight;
			int r2 = this.size - o.size;
			if (r1 > 0 || r2 > 0) {
				return 1;
			} else if (r1 == 0 && r2 == 0) {
				return 0;
			} else {
				return -1;
			}
		}
	}
}",1
p00160,"宅配料金
ある宅配業者の宅配料金は大きさと重量で下表のように料金が設定されています。
A サイズ
B サイズ
C サイズ
D サイズ
E サイズ
F サイズ
大きさ
60cm以内
80cm以内
100cm以内
120cm以内
140cm以内
160cm以内
重さ
2kg以内
5kg以内
10kg以内
15kg以内
20kg以内
25kg以内
料金
600円
800円
1000円
1200円
1400円
1600円
大きさは三辺（縦、横、高さ）の和です。例えば大きさが120cmで、重さが15kg以内の荷物はＤサイズ（1,200円）となります。大きさが120cm以内でも、重さが15kgを超え、20kg以内ならばＥサイズとなります。
1日に持ち込まれた荷物の情報を入力とし、料金の総計を出力するプログラムを作成してください。なお、Ｆサイズを超えた荷物は対象外とし料金の総計には含みません。
Input
複数のデータセットの並びが入力として与えられます。入力の終わりはゼロひとつの行で示されます。
各データセットは以下の形式で与えられます。
n
x
1
y
1
h
1
w
1
x
2
y
2
h
2
w
2
:
x
n
y
n
h
n
w
n
１行目に荷物の個数
n
(1 ≤
n
≤ 10000)、続く
n
行に
i
番目の荷物の縦の長さ
x
i
、横の長さ
y
i
、高さ
h
i
、重さ
w
i
(1 ≤
x
i
,
y
i
,
h
i
,
w
i
≤ 200) が空白区切りで１行に与えられます。
データセットの数は 20 を超えません。
Output
データセットごとに荷物の料金の総計を１行に出力します。
Sample Input
2
50 25 5 5
80 60 10 30
3
10 15 25 24
5 8 12 5
30 30 30 18
0
Output for the Sample Input
800
3800",Python,"while True:
    n = int(input())
    if n == 0:
        break
    
    total = 0
    for _ in range(n):
        x, y, h, w = map(int, input().split())
        size = x + y + h
        
        # Determine the category based on size and weight
        if size <= 60 and w <= 2:
            total += 600
        elif size <= 80 and w <= 5:
            total += 800
        elif size <= 100 and w <= 10:
            total += 1000
        elif size <= 120 and w <= 15:
            total += 1200
        elif size <= 140 and w <= 20:
            total += 1400
        elif size <= 160 and w <= 25:
            total += 1600
        # If exceeds F size, don't add to total
    
    print(total)
",0
p00160,"宅配料金
ある宅配業者の宅配料金は大きさと重量で下表のように料金が設定されています。
A サイズ
B サイズ
C サイズ
D サイズ
E サイズ
F サイズ
大きさ
60cm以内
80cm以内
100cm以内
120cm以内
140cm以内
160cm以内
重さ
2kg以内
5kg以内
10kg以内
15kg以内
20kg以内
25kg以内
料金
600円
800円
1000円
1200円
1400円
1600円
大きさは三辺（縦、横、高さ）の和です。例えば大きさが120cmで、重さが15kg以内の荷物はＤサイズ（1,200円）となります。大きさが120cm以内でも、重さが15kgを超え、20kg以内ならばＥサイズとなります。
1日に持ち込まれた荷物の情報を入力とし、料金の総計を出力するプログラムを作成してください。なお、Ｆサイズを超えた荷物は対象外とし料金の総計には含みません。
Input
複数のデータセットの並びが入力として与えられます。入力の終わりはゼロひとつの行で示されます。
各データセットは以下の形式で与えられます。
n
x
1
y
1
h
1
w
1
x
2
y
2
h
2
w
2
:
x
n
y
n
h
n
w
n
１行目に荷物の個数
n
(1 ≤
n
≤ 10000)、続く
n
行に
i
番目の荷物の縦の長さ
x
i
、横の長さ
y
i
、高さ
h
i
、重さ
w
i
(1 ≤
x
i
,
y
i
,
h
i
,
w
i
≤ 200) が空白区切りで１行に与えられます。
データセットの数は 20 を超えません。
Output
データセットごとに荷物の料金の総計を１行に出力します。
Sample Input
2
50 25 5 5
80 60 10 30
3
10 15 25 24
5 8 12 5
30 30 30 18
0
Output for the Sample Input
800
3800",Python,"size = [60,80,100,120,140,160]        
weight = [2,5,10,16,20,25]
fee= [600,800,1000,1200,1400,1600]
while True:
    n = int(input())
    if n==0:
        break
    total = 0
    for _ in range(n):
        [x,y,h,wt] = list(map(int, input().split()))
        sz = x+y+h
        if sz > size[-1] or wt > weight[-1]:
            #print(""NotAccept"")
            continue
        isz = len(list(filter(lambda x: x<sz,   size)))
        iwt = len(list(filter(lambda x: x<wt, weight)))
        f   = fee[max(isz,iwt)]
        #print(""%d %d %d %d %d"" % (x,y,h,wt,f))
        total += f

    print(total)",1
p00161,"体育祭Sport Meet
秋の体育祭が行われます。種目は徒競走、ボール運び、障害物競走、リレーの4種目です。参加チームは
n
チームで、この4種目の合計タイムが最も小さいチームが「優勝」、次に小さいチームが「準優勝」、そして、最下位より2番目のチームを「ブービー賞」として表彰したいと思います。
各チームの成績を入力として、「優勝」、「準優勝」、「ブービー賞」のチームを出力するプログラムを作成してください。
ただし、チームにはそれぞれ 1 から
n
のチーム番号が割り当てられています。
Input
複数のデータセットの並びが入力として与えられます。入力の終わりはゼロひとつの行で示されます。
各データセットは以下の形式で与えられます。
n
record
1
record
2
:
record
n
１行目に対象となるチームの数
n
(4 ≤
n
≤ 100000)、続く
n
行に
i
番目のチームの情報が与えられます。各チームの情報は以下の形式で与えられます。
id
m1
s1
m2
s2
m3
s3
m4
s4
id
(1 ≤
id
≤
n
)はチーム番号、
m1
,
s1
はそれぞれ徒競走のタイムの分と秒、
m2
,
s2
はそれぞれボール運びのタイムの分と秒、
m3
,
s3
はそれぞれ障害物競走のタイムの分と秒、
m4
,
s4
はそれぞれリレーのタイムの分と秒を表します。分と秒はともに0 以上 59 以下の整数です。また、合計タイムが複数のチームで同じになるような入力はないものとします。
Output
入力データセットごとに以下の形式でチーム番号を出力します。
1 行目 優勝のチーム番号
2 行目 準優勝のチーム番号
3 行目 ブービー賞のチーム番号
Sample Input
8
34001 3 20 3 8 6 27 2 25
20941 3 5 2 41 7 19 2 42
90585 4 8 3 12 6 46 2 34
92201 3 28 2 47 6 37 2 58
10001 3 50 2 42 7 12 2 54
63812 4 11 3 11 6 53 2 22
54092 3 33 2 54 6 18 2 19
25012 3 44 2 58 6 45 2 46
4
1 3 23 1 23 1 34 4 44
2 5 12 2 12 3 41 2 29
3 5 24 1 24 2 0 3 35
4 4 49 2 22 4 41 4 23
0
Output for the Sample Input
54092
34001
10001
1
3
2",C,"#include <stdio.h>
#include <stdlib.h>

typedef struct {
    int id;
    int total_time;
} Team;

int compare(const void *a, const void *b) {
    Team *ta = (Team *)a;
    Team *tb = (Team *)b;
    return ta->total_time - tb->total_time;
}

int main() {
    int n;
    
    while (scanf(""%d"", &n) == 1 && n != 0) {
        Team *teams = (Team *)malloc(n * sizeof(Team));
        
        for (int i = 0; i < n; i++) {
            int id, m1, s1, m2, s2, m3, s3, m4, s4;
            scanf(""%d %d %d %d %d %d %d %d %d"", &id, &m1, &s1, &m2, &s2, &m3, &s3, &m4, &s4);
            
            teams[i].id = id;
            teams[i].total_time = (m1 * 60 + s1) + (m2 * 60 + s2) + (m3 * 60 + s3) + (m4 * 60 + s4);
        }
        
        qsort(teams, n, sizeof(Team), compare);
        
        printf(""%d\n"", teams[0].id);
        printf(""%d\n"", teams[1].id);
        printf(""%d\n"", teams[n-2].id);
        
        free(teams);
    }
    
    return 0;
}
",0
p00161,"体育祭Sport Meet
秋の体育祭が行われます。種目は徒競走、ボール運び、障害物競走、リレーの4種目です。参加チームは
n
チームで、この4種目の合計タイムが最も小さいチームが「優勝」、次に小さいチームが「準優勝」、そして、最下位より2番目のチームを「ブービー賞」として表彰したいと思います。
各チームの成績を入力として、「優勝」、「準優勝」、「ブービー賞」のチームを出力するプログラムを作成してください。
ただし、チームにはそれぞれ 1 から
n
のチーム番号が割り当てられています。
Input
複数のデータセットの並びが入力として与えられます。入力の終わりはゼロひとつの行で示されます。
各データセットは以下の形式で与えられます。
n
record
1
record
2
:
record
n
１行目に対象となるチームの数
n
(4 ≤
n
≤ 100000)、続く
n
行に
i
番目のチームの情報が与えられます。各チームの情報は以下の形式で与えられます。
id
m1
s1
m2
s2
m3
s3
m4
s4
id
(1 ≤
id
≤
n
)はチーム番号、
m1
,
s1
はそれぞれ徒競走のタイムの分と秒、
m2
,
s2
はそれぞれボール運びのタイムの分と秒、
m3
,
s3
はそれぞれ障害物競走のタイムの分と秒、
m4
,
s4
はそれぞれリレーのタイムの分と秒を表します。分と秒はともに0 以上 59 以下の整数です。また、合計タイムが複数のチームで同じになるような入力はないものとします。
Output
入力データセットごとに以下の形式でチーム番号を出力します。
1 行目 優勝のチーム番号
2 行目 準優勝のチーム番号
3 行目 ブービー賞のチーム番号
Sample Input
8
34001 3 20 3 8 6 27 2 25
20941 3 5 2 41 7 19 2 42
90585 4 8 3 12 6 46 2 34
92201 3 28 2 47 6 37 2 58
10001 3 50 2 42 7 12 2 54
63812 4 11 3 11 6 53 2 22
54092 3 33 2 54 6 18 2 19
25012 3 44 2 58 6 45 2 46
4
1 3 23 1 23 1 34 4 44
2 5 12 2 12 3 41 2 29
3 5 24 1 24 2 0 3 35
4 4 49 2 22 4 41 4 23
0
Output for the Sample Input
54092
34001
10001
1
3
2",C,"#include <stdio.h>
#include <stdlib.h>

typedef struct
{
	int c;
	int m[4];
	int s[4];
} TEAM;

int comparison(const void* a, const void* b);

int main(void)
{
	int n;
	TEAM* team;
	
	while (scanf(""%d"", &n) * n != 0){
		int i;
		
		team = (TEAM*)calloc(n, sizeof(TEAM));
		for (i = 0; i < n; i++){
			int j;
			
			scanf(""%d"", &team[i].c);
			for (j = 0; j < 4; j++){
				scanf(""%d %d"", &team[i].m[j], &team[i].s[j]);
			}
		}
		qsort(team, n, sizeof(TEAM), comparison);
		printf(""%d\n"", team[0].c);
		printf(""%d\n"", team[1].c);
		printf(""%d\n"", team[n - 2].c);
		
		free(team);
	}
	
	return 0;
}

int comparison(const void* a, const void* b)
{
	int sum_a, sum_b;
	int i;
	
	sum_a = sum_b = 0;
	for (i = 0; i < 4; i++){
		sum_a += ((TEAM*)a)->m[i] * 60 + ((TEAM*)a)->s[i];
		sum_b += ((TEAM*)b)->m[i] * 60 + ((TEAM*)b)->s[i];
	}
	if (sum_a > sum_b){
		return 1;
	}
	else if (sum_a < sum_b){
		return -1;
	}
	else {
		return 0;
	}
}",1
p00161,"体育祭Sport Meet
秋の体育祭が行われます。種目は徒競走、ボール運び、障害物競走、リレーの4種目です。参加チームは
n
チームで、この4種目の合計タイムが最も小さいチームが「優勝」、次に小さいチームが「準優勝」、そして、最下位より2番目のチームを「ブービー賞」として表彰したいと思います。
各チームの成績を入力として、「優勝」、「準優勝」、「ブービー賞」のチームを出力するプログラムを作成してください。
ただし、チームにはそれぞれ 1 から
n
のチーム番号が割り当てられています。
Input
複数のデータセットの並びが入力として与えられます。入力の終わりはゼロひとつの行で示されます。
各データセットは以下の形式で与えられます。
n
record
1
record
2
:
record
n
１行目に対象となるチームの数
n
(4 ≤
n
≤ 100000)、続く
n
行に
i
番目のチームの情報が与えられます。各チームの情報は以下の形式で与えられます。
id
m1
s1
m2
s2
m3
s3
m4
s4
id
(1 ≤
id
≤
n
)はチーム番号、
m1
,
s1
はそれぞれ徒競走のタイムの分と秒、
m2
,
s2
はそれぞれボール運びのタイムの分と秒、
m3
,
s3
はそれぞれ障害物競走のタイムの分と秒、
m4
,
s4
はそれぞれリレーのタイムの分と秒を表します。分と秒はともに0 以上 59 以下の整数です。また、合計タイムが複数のチームで同じになるような入力はないものとします。
Output
入力データセットごとに以下の形式でチーム番号を出力します。
1 行目 優勝のチーム番号
2 行目 準優勝のチーム番号
3 行目 ブービー賞のチーム番号
Sample Input
8
34001 3 20 3 8 6 27 2 25
20941 3 5 2 41 7 19 2 42
90585 4 8 3 12 6 46 2 34
92201 3 28 2 47 6 37 2 58
10001 3 50 2 42 7 12 2 54
63812 4 11 3 11 6 53 2 22
54092 3 33 2 54 6 18 2 19
25012 3 44 2 58 6 45 2 46
4
1 3 23 1 23 1 34 4 44
2 5 12 2 12 3 41 2 29
3 5 24 1 24 2 0 3 35
4 4 49 2 22 4 41 4 23
0
Output for the Sample Input
54092
34001
10001
1
3
2",Java,"import java.util.*;

public class Main {
    static class Team implements Comparable<Team> {
        int id;
        int totalSeconds;
        
        Team(int id, int totalSeconds) {
            this.id = id;
            this.totalSeconds = totalSeconds;
        }
        
        @Override
        public int compareTo(Team other) {
            return this.totalSeconds - other.totalSeconds;
        }
    }
    
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        
        while (true) {
            int n = sc.nextInt();
            if (n == 0) break;
            
            Team[] teams = new Team[n];
            
            for (int i = 0; i < n; i++) {
                int id = sc.nextInt();
                int totalSeconds = 0;
                
                for (int j = 0; j < 4; j++) {
                    int m = sc.nextInt();
                    int s = sc.nextInt();
                    totalSeconds += m * 60 + s;
                }
                
                teams[i] = new Team(id, totalSeconds);
            }
            
            Arrays.sort(teams);
            
            System.out.println(teams[0].id);
            System.out.println(teams[1].id);
            System.out.println(teams[n - 2].id);
        }
        
        sc.close();
    }
}
",0
p00161,"体育祭Sport Meet
秋の体育祭が行われます。種目は徒競走、ボール運び、障害物競走、リレーの4種目です。参加チームは
n
チームで、この4種目の合計タイムが最も小さいチームが「優勝」、次に小さいチームが「準優勝」、そして、最下位より2番目のチームを「ブービー賞」として表彰したいと思います。
各チームの成績を入力として、「優勝」、「準優勝」、「ブービー賞」のチームを出力するプログラムを作成してください。
ただし、チームにはそれぞれ 1 から
n
のチーム番号が割り当てられています。
Input
複数のデータセットの並びが入力として与えられます。入力の終わりはゼロひとつの行で示されます。
各データセットは以下の形式で与えられます。
n
record
1
record
2
:
record
n
１行目に対象となるチームの数
n
(4 ≤
n
≤ 100000)、続く
n
行に
i
番目のチームの情報が与えられます。各チームの情報は以下の形式で与えられます。
id
m1
s1
m2
s2
m3
s3
m4
s4
id
(1 ≤
id
≤
n
)はチーム番号、
m1
,
s1
はそれぞれ徒競走のタイムの分と秒、
m2
,
s2
はそれぞれボール運びのタイムの分と秒、
m3
,
s3
はそれぞれ障害物競走のタイムの分と秒、
m4
,
s4
はそれぞれリレーのタイムの分と秒を表します。分と秒はともに0 以上 59 以下の整数です。また、合計タイムが複数のチームで同じになるような入力はないものとします。
Output
入力データセットごとに以下の形式でチーム番号を出力します。
1 行目 優勝のチーム番号
2 行目 準優勝のチーム番号
3 行目 ブービー賞のチーム番号
Sample Input
8
34001 3 20 3 8 6 27 2 25
20941 3 5 2 41 7 19 2 42
90585 4 8 3 12 6 46 2 34
92201 3 28 2 47 6 37 2 58
10001 3 50 2 42 7 12 2 54
63812 4 11 3 11 6 53 2 22
54092 3 33 2 54 6 18 2 19
25012 3 44 2 58 6 45 2 46
4
1 3 23 1 23 1 34 4 44
2 5 12 2 12 3 41 2 29
3 5 24 1 24 2 0 3 35
4 4 49 2 22 4 41 4 23
0
Output for the Sample Input
54092
34001
10001
1
3
2",Java,"import java.util.Scanner;
class Main
{
    public static void main(String args[])
    {
	Scanner scan=new Scanner(System.in);
	while(true)
	    {
		int n=scan.nextInt();
		if(n==0)break;
		int num[]=new int[n];
		int sum[]=new int[n];
		for(int i=0;i<n;i++)
		    {
			num[i]=scan.nextInt();
			for(int j=0;j<8;j++)
			    {
				if(j%2==0)sum[i]+=60*(scan.nextInt());
				else sum[i]+=scan.nextInt();
			    }
		    }
		
		for(int i=0;i<n;i++)
		    {
			int min=sum[i],x=i;
			for(int j=i;j<n;j++)
			    {
				if(min>sum[j])
				    {
					min=sum[j];
					x=j;
					
				    }
			    }
			int tmp=num[i];
			num[i]=num[x];
			num[x]=tmp;
			int tmp2=sum[i];
			sum[i]=sum[x];
			sum[x]=tmp2;
		    }
		
		System.out.println(num[0]);
		System.out.println(num[1]);
		System.out.println(num[n-2]);
	    }
    }
}",1
p00161,"体育祭Sport Meet
秋の体育祭が行われます。種目は徒競走、ボール運び、障害物競走、リレーの4種目です。参加チームは
n
チームで、この4種目の合計タイムが最も小さいチームが「優勝」、次に小さいチームが「準優勝」、そして、最下位より2番目のチームを「ブービー賞」として表彰したいと思います。
各チームの成績を入力として、「優勝」、「準優勝」、「ブービー賞」のチームを出力するプログラムを作成してください。
ただし、チームにはそれぞれ 1 から
n
のチーム番号が割り当てられています。
Input
複数のデータセットの並びが入力として与えられます。入力の終わりはゼロひとつの行で示されます。
各データセットは以下の形式で与えられます。
n
record
1
record
2
:
record
n
１行目に対象となるチームの数
n
(4 ≤
n
≤ 100000)、続く
n
行に
i
番目のチームの情報が与えられます。各チームの情報は以下の形式で与えられます。
id
m1
s1
m2
s2
m3
s3
m4
s4
id
(1 ≤
id
≤
n
)はチーム番号、
m1
,
s1
はそれぞれ徒競走のタイムの分と秒、
m2
,
s2
はそれぞれボール運びのタイムの分と秒、
m3
,
s3
はそれぞれ障害物競走のタイムの分と秒、
m4
,
s4
はそれぞれリレーのタイムの分と秒を表します。分と秒はともに0 以上 59 以下の整数です。また、合計タイムが複数のチームで同じになるような入力はないものとします。
Output
入力データセットごとに以下の形式でチーム番号を出力します。
1 行目 優勝のチーム番号
2 行目 準優勝のチーム番号
3 行目 ブービー賞のチーム番号
Sample Input
8
34001 3 20 3 8 6 27 2 25
20941 3 5 2 41 7 19 2 42
90585 4 8 3 12 6 46 2 34
92201 3 28 2 47 6 37 2 58
10001 3 50 2 42 7 12 2 54
63812 4 11 3 11 6 53 2 22
54092 3 33 2 54 6 18 2 19
25012 3 44 2 58 6 45 2 46
4
1 3 23 1 23 1 34 4 44
2 5 12 2 12 3 41 2 29
3 5 24 1 24 2 0 3 35
4 4 49 2 22 4 41 4 23
0
Output for the Sample Input
54092
34001
10001
1
3
2",Python,"import sys

def solve():
    while True:
        n = int(input())
        if n == 0:
            break
        
        teams = []
        for _ in range(n):
            parts = list(map(int, input().split()))
            team_id = parts[0]
            
            # Calculate total time in seconds
            total_seconds = 0
            for i in range(1, 9, 2):
                minutes = parts[i]
                seconds = parts[i + 1]
                total_seconds += minutes * 60 + seconds
            
            teams.append((total_seconds, team_id))
        
        # Sort by total time
        teams.sort()
        
        # Winner: smallest time (index 0)
        winner = teams[0][1]
        # Runner-up: second smallest time (index 1)
        runner_up = teams[1][1]
        # Booby prize: second to last (index n-2)
        booby = teams[n - 2][1]
        
        print(winner)
        print(runner_up)
        print(booby)

solve()
",0
p00161,"体育祭Sport Meet
秋の体育祭が行われます。種目は徒競走、ボール運び、障害物競走、リレーの4種目です。参加チームは
n
チームで、この4種目の合計タイムが最も小さいチームが「優勝」、次に小さいチームが「準優勝」、そして、最下位より2番目のチームを「ブービー賞」として表彰したいと思います。
各チームの成績を入力として、「優勝」、「準優勝」、「ブービー賞」のチームを出力するプログラムを作成してください。
ただし、チームにはそれぞれ 1 から
n
のチーム番号が割り当てられています。
Input
複数のデータセットの並びが入力として与えられます。入力の終わりはゼロひとつの行で示されます。
各データセットは以下の形式で与えられます。
n
record
1
record
2
:
record
n
１行目に対象となるチームの数
n
(4 ≤
n
≤ 100000)、続く
n
行に
i
番目のチームの情報が与えられます。各チームの情報は以下の形式で与えられます。
id
m1
s1
m2
s2
m3
s3
m4
s4
id
(1 ≤
id
≤
n
)はチーム番号、
m1
,
s1
はそれぞれ徒競走のタイムの分と秒、
m2
,
s2
はそれぞれボール運びのタイムの分と秒、
m3
,
s3
はそれぞれ障害物競走のタイムの分と秒、
m4
,
s4
はそれぞれリレーのタイムの分と秒を表します。分と秒はともに0 以上 59 以下の整数です。また、合計タイムが複数のチームで同じになるような入力はないものとします。
Output
入力データセットごとに以下の形式でチーム番号を出力します。
1 行目 優勝のチーム番号
2 行目 準優勝のチーム番号
3 行目 ブービー賞のチーム番号
Sample Input
8
34001 3 20 3 8 6 27 2 25
20941 3 5 2 41 7 19 2 42
90585 4 8 3 12 6 46 2 34
92201 3 28 2 47 6 37 2 58
10001 3 50 2 42 7 12 2 54
63812 4 11 3 11 6 53 2 22
54092 3 33 2 54 6 18 2 19
25012 3 44 2 58 6 45 2 46
4
1 3 23 1 23 1 34 4 44
2 5 12 2 12 3 41 2 29
3 5 24 1 24 2 0 3 35
4 4 49 2 22 4 41 4 23
0
Output for the Sample Input
54092
34001
10001
1
3
2",Python,"while 1:
    n=int(input())
    if n==0:break
    a={}
    for _ in range(n):
        b=list(map(int,input().split()))
        a[b[0]]=sum(b[1:8:2])*60+sum(b[2:9:2])
    a=sorted(a.items(),key=lambda x:x[1])
    for i in [0,1,-2]:print(a[i][0])",1
p00162,"ハミング数
1 に 2, 3, 5 を何回か (0 回以上) かけ算して得られる数をハミング数 (Hamming numbers) と呼びます。例えば、
1
1 × 2 × 2 = 4
1 × 2 × 2 × 3 × 5 × 5 = 300
などはハミング数ですが、11, 13, 14 などはハミング数ではありません。
ハミング数はどれも 60 のべき乗を割り切る(例えば、54 は 60
3
= 21600 を割り切る) ので、時刻など 60 進法の計算には都合の良い数として昔から知られていました。また、楽器の調律に用いる音階の一つである純正律では、音の周波数の比が 24, 27, 30, 32, 36, 40, 45, 48 というハミング数からなる数列になります。
整数
m
、
n
を入力とし、
m
以上
n
以下のハミング数の個数を出力するプログラムを作成してください。
Input
複数のデータセットの並びが入力として与えられます。入力の終わりはゼロひとつの行で示されます。
各データセットとして、２つの整数
m
と
n
(1 ≤
m
,
n
≤ 1000000,
m
≤
n
) が空白区切りで１行に与えられます。
データセットの数は 20 を超えません。
Output
データセットごとに
m
以上
n
以下のハミング数の個数を１行に出力します。
Sample Input
3 8
1 27
1 86
0
Output for the Sample Input
5
17
31",C,"#include <stdio.h>
#include <stdlib.h>

#define MAX 1000000

int hamming[100000];
int hamming_count = 0;

int compare(const void *a, const void *b) {
    return (*(int*)a - *(int*)b);
}

void generate_hamming() {
    hamming[hamming_count++] = 1;
    
    int i2 = 0, i3 = 0, i5 = 0;
    int next_2 = 2, next_3 = 3, next_5 = 5;
    
    while (1) {
        int next = next_2;
        if (next_3 < next) next = next_3;
        if (next_5 < next) next = next_5;
        
        if (next > MAX) break;
        
        hamming[hamming_count++] = next;
        
        if (next == next_2) {
            i2++;
            next_2 = hamming[i2] * 2;
        }
        if (next == next_3) {
            i3++;
            next_3 = hamming[i3] * 3;
        }
        if (next == next_5) {
            i5++;
            next_5 = hamming[i5] * 5;
        }
    }
}

int binary_search_lower(int val) {
    int left = 0, right = hamming_count - 1;
    int result = hamming_count;
    
    while (left <= right) {
        int mid = (left + right) / 2;
        if (hamming[mid] >= val) {
            result = mid;
            right = mid - 1;
        } else {
            left = mid + 1;
        }
    }
    
    return result;
}

int binary_search_upper(int val) {
    int left = 0, right = hamming_count - 1;
    int result = -1;
    
    while (left <= right) {
        int mid = (left + right) / 2;
        if (hamming[mid] <= val) {
            result = mid;
            left = mid + 1;
        } else {
            right = mid - 1;
        }
    }
    
    return result;
}

int main() {
    generate_hamming();
    
    int m, n;
    while (1) {
        scanf(""%d"", &m);
        if (m == 0) break;
        scanf(""%d"", &n);
        
        int lower = binary_search_lower(m);
        int upper = binary_search_upper(n);
        
        if (lower <= upper) {
            printf(""%d\n"", upper - lower + 1);
        } else {
            printf(""0\n"");
        }
    }
    
    return 0;
}
",0
p00162,"ハミング数
1 に 2, 3, 5 を何回か (0 回以上) かけ算して得られる数をハミング数 (Hamming numbers) と呼びます。例えば、
1
1 × 2 × 2 = 4
1 × 2 × 2 × 3 × 5 × 5 = 300
などはハミング数ですが、11, 13, 14 などはハミング数ではありません。
ハミング数はどれも 60 のべき乗を割り切る(例えば、54 は 60
3
= 21600 を割り切る) ので、時刻など 60 進法の計算には都合の良い数として昔から知られていました。また、楽器の調律に用いる音階の一つである純正律では、音の周波数の比が 24, 27, 30, 32, 36, 40, 45, 48 というハミング数からなる数列になります。
整数
m
、
n
を入力とし、
m
以上
n
以下のハミング数の個数を出力するプログラムを作成してください。
Input
複数のデータセットの並びが入力として与えられます。入力の終わりはゼロひとつの行で示されます。
各データセットとして、２つの整数
m
と
n
(1 ≤
m
,
n
≤ 1000000,
m
≤
n
) が空白区切りで１行に与えられます。
データセットの数は 20 を超えません。
Output
データセットごとに
m
以上
n
以下のハミング数の個数を１行に出力します。
Sample Input
3 8
1 27
1 86
0
Output for the Sample Input
5
17
31",C,"#include<stdio.h>
#include<math.h>
int dfs(int,int);
int boad[110][110];
int w,h,xs,ys,xg,yg,n,c,d;

int main(void){
  int x,y,i,j,a,b;

  while(1){
   
    scanf(""%d %d"",&w,&h);
    if(w==0 && h==0)break;
    scanf(""%d %d"",&xs,&ys);
    scanf(""%d %d"",&xg,&yg);
    scanf(""%d"",&n);
    
    for(i=0;i<110;i++){
      for(j=0;j<110;j++){
	boad[i][j]=-1;
      }
    }
    int k;
    for(k=0;k<n;k++){
      scanf(""%d %d %d %d"",&c,&d,&x,&y);
      
      if(d){a=4;b=2;}
      else {a=2;b=4;}
	for(i=y;i<y+a;i++){
	  for(j=x;j<x+b;j++){
	    boad[i][j]=c;
	  }
	}

    }
    c=boad[xs][ys];
 
  
    if(dfs(xs,ys))printf(""OK\n"");
    else printf(""NG\n"");
    /*for(i=0;i<15;i++){
      for(j=0;j<15;j++)
printf(""%2d"",boad[i][j]);
      printf(""\n"");
      }*/
  }
  return 0;
}
  
int dfs(int x,int y){
  int i,j,res=0;
  if(x<=0||x>w||y<=0||y>h||boad[x][y]!=c)return 0;
  if(x==xg && y==yg)return 1;
  
  boad[x][y]=-1;
  
  for(i=-1;i<2;i++){
    for(j=-1;j<2;j++){
      if(boad[x+i][y+j]==c && abs(i)+abs(j)==1 && boad[x+i][y+j]!=-1)
	if(dfs(x+i,y+j))return 1;
    }
  }
  return 0;
}",1
p00162,"ハミング数
1 に 2, 3, 5 を何回か (0 回以上) かけ算して得られる数をハミング数 (Hamming numbers) と呼びます。例えば、
1
1 × 2 × 2 = 4
1 × 2 × 2 × 3 × 5 × 5 = 300
などはハミング数ですが、11, 13, 14 などはハミング数ではありません。
ハミング数はどれも 60 のべき乗を割り切る(例えば、54 は 60
3
= 21600 を割り切る) ので、時刻など 60 進法の計算には都合の良い数として昔から知られていました。また、楽器の調律に用いる音階の一つである純正律では、音の周波数の比が 24, 27, 30, 32, 36, 40, 45, 48 というハミング数からなる数列になります。
整数
m
、
n
を入力とし、
m
以上
n
以下のハミング数の個数を出力するプログラムを作成してください。
Input
複数のデータセットの並びが入力として与えられます。入力の終わりはゼロひとつの行で示されます。
各データセットとして、２つの整数
m
と
n
(1 ≤
m
,
n
≤ 1000000,
m
≤
n
) が空白区切りで１行に与えられます。
データセットの数は 20 を超えません。
Output
データセットごとに
m
以上
n
以下のハミング数の個数を１行に出力します。
Sample Input
3 8
1 27
1 86
0
Output for the Sample Input
5
17
31",Java,"import java.util.*;

public class Main {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        
        // Precompute all Hamming numbers up to 1000000
        TreeSet<Long> hammingSet = new TreeSet<>();
        long limit = 1000000;
        
        for (long i = 1; i <= limit; i *= 2) {
            for (long j = i; j <= limit; j *= 3) {
                for (long k = j; k <= limit; k *= 5) {
                    hammingSet.add(k);
                }
            }
        }
        
        List<Long> hamming = new ArrayList<>(hammingSet);
        
        while (true) {
            int m = sc.nextInt();
            if (m == 0) break;
            int n = sc.nextInt();
            
            int count = 0;
            for (long h : hamming) {
                if (h >= m && h <= n) {
                    count++;
                } else if (h > n) {
                    break;
                }
            }
            
            System.out.println(count);
        }
        
        sc.close();
    }
}
",0
p00162,"ハミング数
1 に 2, 3, 5 を何回か (0 回以上) かけ算して得られる数をハミング数 (Hamming numbers) と呼びます。例えば、
1
1 × 2 × 2 = 4
1 × 2 × 2 × 3 × 5 × 5 = 300
などはハミング数ですが、11, 13, 14 などはハミング数ではありません。
ハミング数はどれも 60 のべき乗を割り切る(例えば、54 は 60
3
= 21600 を割り切る) ので、時刻など 60 進法の計算には都合の良い数として昔から知られていました。また、楽器の調律に用いる音階の一つである純正律では、音の周波数の比が 24, 27, 30, 32, 36, 40, 45, 48 というハミング数からなる数列になります。
整数
m
、
n
を入力とし、
m
以上
n
以下のハミング数の個数を出力するプログラムを作成してください。
Input
複数のデータセットの並びが入力として与えられます。入力の終わりはゼロひとつの行で示されます。
各データセットとして、２つの整数
m
と
n
(1 ≤
m
,
n
≤ 1000000,
m
≤
n
) が空白区切りで１行に与えられます。
データセットの数は 20 を超えません。
Output
データセットごとに
m
以上
n
以下のハミング数の個数を１行に出力します。
Sample Input
3 8
1 27
1 86
0
Output for the Sample Input
5
17
31",Java,"import java.util.Scanner;

class Main {
	public static void main(String[] args){
		Scanner scan = new Scanner(System.in);
		int m, n;
		int a;
		
		int count;
		
		while(true){
			m = scan.nextInt();
			n = scan.nextInt();
			if(m == 0)break;
			
			count = 0;
			for(int i = m;i <= n; i++){
				a = i;
				while(true){
					if(a == 1){
						count++;;
						break;
					}
					if(a % 2 != 0 && a % 3 != 0 && a % 5 != 0){
						break;
					}
					if(a % 2 == 0)a /= 2;
					else if(a % 3 == 0)a /= 3;
					else if(a % 5 == 0)a /= 5;
				}
			}
			System.out.println(count);
		}
	}
}",1
p00162,"ハミング数
1 に 2, 3, 5 を何回か (0 回以上) かけ算して得られる数をハミング数 (Hamming numbers) と呼びます。例えば、
1
1 × 2 × 2 = 4
1 × 2 × 2 × 3 × 5 × 5 = 300
などはハミング数ですが、11, 13, 14 などはハミング数ではありません。
ハミング数はどれも 60 のべき乗を割り切る(例えば、54 は 60
3
= 21600 を割り切る) ので、時刻など 60 進法の計算には都合の良い数として昔から知られていました。また、楽器の調律に用いる音階の一つである純正律では、音の周波数の比が 24, 27, 30, 32, 36, 40, 45, 48 というハミング数からなる数列になります。
整数
m
、
n
を入力とし、
m
以上
n
以下のハミング数の個数を出力するプログラムを作成してください。
Input
複数のデータセットの並びが入力として与えられます。入力の終わりはゼロひとつの行で示されます。
各データセットとして、２つの整数
m
と
n
(1 ≤
m
,
n
≤ 1000000,
m
≤
n
) が空白区切りで１行に与えられます。
データセットの数は 20 を超えません。
Output
データセットごとに
m
以上
n
以下のハミング数の個数を１行に出力します。
Sample Input
3 8
1 27
1 86
0
Output for the Sample Input
5
17
31",Python,"import heapq

def generate_hamming_numbers(limit):
    hamming = set([1])
    heap = [1]
    
    while heap:
        h = heapq.heappop(heap)
        if h > limit:
            break
        
        for factor in [2, 3, 5]:
            new_num = h * factor
            if new_num <= limit and new_num not in hamming:
                hamming.add(new_num)
                heapq.heappush(heap, new_num)
    
    return sorted(hamming)

# Pre-generate all Hamming numbers up to 1000000
hamming_numbers = generate_hamming_numbers(1000000)

while True:
    line = input().strip()
    if line == ""0"":
        break
    
    m, n = map(int, line.split())
    
    # Binary search for the range
    count = 0
    for h in hamming_numbers:
        if h < m:
            continue
        if h > n:
            break
        count += 1
    
    print(count)
",0
p00162,"ハミング数
1 に 2, 3, 5 を何回か (0 回以上) かけ算して得られる数をハミング数 (Hamming numbers) と呼びます。例えば、
1
1 × 2 × 2 = 4
1 × 2 × 2 × 3 × 5 × 5 = 300
などはハミング数ですが、11, 13, 14 などはハミング数ではありません。
ハミング数はどれも 60 のべき乗を割り切る(例えば、54 は 60
3
= 21600 を割り切る) ので、時刻など 60 進法の計算には都合の良い数として昔から知られていました。また、楽器の調律に用いる音階の一つである純正律では、音の周波数の比が 24, 27, 30, 32, 36, 40, 45, 48 というハミング数からなる数列になります。
整数
m
、
n
を入力とし、
m
以上
n
以下のハミング数の個数を出力するプログラムを作成してください。
Input
複数のデータセットの並びが入力として与えられます。入力の終わりはゼロひとつの行で示されます。
各データセットとして、２つの整数
m
と
n
(1 ≤
m
,
n
≤ 1000000,
m
≤
n
) が空白区切りで１行に与えられます。
データセットの数は 20 を超えません。
Output
データセットごとに
m
以上
n
以下のハミング数の個数を１行に出力します。
Sample Input
3 8
1 27
1 86
0
Output for the Sample Input
5
17
31",Python,"import math

while True:
    try:
        m, n = map(int, raw_input().split())

        f2 = int(math.log(n, 2)) + 1
        f3 = int(math.log(n, 3)) + 1
        f5 = int(math.log(n, 5)) + 1

        c = 0
        for i in range(f2):
            for j in range(f3):
                for k in range(f5):
                    if m <= (2 ** i) * (3 ** j) * (5 ** k) <= n:
                        c += 1
        print c

    except ValueError:
        break",1
p00163,"有料道路通行料
20XX年に喜多方市熱塩加納町から南会津町までの6区間、総距離58kmの会津中央道路が完成し開通する予定です。
開通後、半年間は利用促進のため17時30分〜19時30分までに出発ICか到着ICを通過し、なおかつ走行距離が40km以下の車に対する通行料金は半額になります。ただし料金は50円単位とし、端数は切り上げます。下記の表は料金と距離の一覧表です。
例えば喜多方（２）から会津若松（４）までは料金が450円、距離が12kmとなります。半額時間帯であれば250円になります。
出発IC、出発IC通過時刻、到着IC、到着IC通過時刻を入力とし、料金を計算して出力するプログラムを作成してください。ただし、入力される時刻は24 時間表記の値とします。なお、17時30分および19時30分ちょうどに通過した場合も半額時間帯に含めます。
Input
複数のデータセットの並びが入力として与えられます。入力の終わりはゼロひとつの行で示されます。
各データセットは以下の形式で与えられます。
d
h
d
m
d
a
h
a
m
a
１行目に出発ICの番号
d
(1 ≤
d
≤ 7)、２行目に出発ICの通過時刻の時間
h
d
(0 ≤
h
d
≤ 23) と分
m
d
(0 ≤
m
d
≤ 59) が与えられます。
3行目に到着ICの番号
a
(1 ≤
a
≤ 7)、４行目に到着ICの通過時刻の時間
h
a
(0 ≤
h
a
≤ 23) と分
m
a
(0 ≤
m
a
≤ 59) が与えられます。
Output
データセットごとに通行料金（整数）を１行に出力します。
Sample Input
2
17 25
4
17 45
4
17 25
7
19 35
0
Output for the Sample Input
250
1300",C,"#include <stdio.h>

int main() {
    int price[8][8] = {
        {0, 0, 0, 0, 0, 0, 0, 0},
        {0, 0, 350, 450, 600, 750, 1050, 1300},
        {0, 350, 0, 450, 500, 650, 900, 1150},
        {0, 450, 450, 0, 400, 500, 750, 1050},
        {0, 600, 500, 400, 0, 350, 600, 850},
        {0, 750, 650, 500, 350, 0, 450, 700},
        {0, 1050, 900, 750, 600, 450, 0, 500},
        {0, 1300, 1150, 1050, 850, 700, 500, 0}
    };
    
    int distance[8][8] = {
        {0, 0, 0, 0, 0, 0, 0, 0},
        {0, 0, 9, 12, 19, 25, 39, 58},
        {0, 9, 0, 12, 16, 22, 36, 55},
        {0, 12, 12, 0, 10, 16, 30, 49},
        {0, 19, 16, 10, 0, 10, 24, 43},
        {0, 25, 22, 16, 10, 0, 18, 37},
        {0, 39, 36, 30, 24, 18, 0, 19},
        {0, 58, 55, 49, 43, 37, 19, 0}
    };
    
    int d;
    while(scanf(""%d"", &d) == 1 && d != 0) {
        int hd, md, a, ha, ma;
        scanf(""%d %d"", &hd, &md);
        scanf(""%d"", &a);
        scanf(""%d %d"", &ha, &ma);
        
        int start_time = hd * 60 + md;
        int end_time = ha * 60 + ma;
        int discount_start = 17 * 60 + 30;
        int discount_end = 19 * 60 + 30;
        
        int dist = distance[d][a];
        int cost = price[d][a];
        
        int is_discount = 0;
        if ((start_time >= discount_start && start_time <= discount_end) ||
            (end_time >= discount_start && end_time <= discount_end)) {
            if (dist <= 40) {
                is_discount = 1;
            }
        }
        
        if (is_discount) {
            int half = cost / 2;
            if (cost % 2 != 0) {
                half++;
            }
            int remainder = half % 50;
            if (remainder != 0) {
                half = half + (50 - remainder);
            }
            cost = half;
        }
        
        printf(""%d\n"", cost);
    }
    
    return 0;
}
",0
p00163,"有料道路通行料
20XX年に喜多方市熱塩加納町から南会津町までの6区間、総距離58kmの会津中央道路が完成し開通する予定です。
開通後、半年間は利用促進のため17時30分〜19時30分までに出発ICか到着ICを通過し、なおかつ走行距離が40km以下の車に対する通行料金は半額になります。ただし料金は50円単位とし、端数は切り上げます。下記の表は料金と距離の一覧表です。
例えば喜多方（２）から会津若松（４）までは料金が450円、距離が12kmとなります。半額時間帯であれば250円になります。
出発IC、出発IC通過時刻、到着IC、到着IC通過時刻を入力とし、料金を計算して出力するプログラムを作成してください。ただし、入力される時刻は24 時間表記の値とします。なお、17時30分および19時30分ちょうどに通過した場合も半額時間帯に含めます。
Input
複数のデータセットの並びが入力として与えられます。入力の終わりはゼロひとつの行で示されます。
各データセットは以下の形式で与えられます。
d
h
d
m
d
a
h
a
m
a
１行目に出発ICの番号
d
(1 ≤
d
≤ 7)、２行目に出発ICの通過時刻の時間
h
d
(0 ≤
h
d
≤ 23) と分
m
d
(0 ≤
m
d
≤ 59) が与えられます。
3行目に到着ICの番号
a
(1 ≤
a
≤ 7)、４行目に到着ICの通過時刻の時間
h
a
(0 ≤
h
a
≤ 23) と分
m
a
(0 ≤
m
a
≤ 59) が与えられます。
Output
データセットごとに通行料金（整数）を１行に出力します。
Sample Input
2
17 25
4
17 45
4
17 25
7
19 35
0
Output for the Sample Input
250
1300",C,"#include<stdio.h>
int main(){
  const int d[8][8]={
    {0,0,  0,  0,  0,  0,   0,  0},
    {0,0,300,500,600,700,1350,1650},
    {0,0,  0,350,450,600,1150,1500},
    {0,0,  0,  0,250,400,1000,1350},
    {0,0,  0,  0,  0,250, 850,1300},
    {0,0,  0,  0,  0,  0, 600,1150},
    {0,1,  0,  0,  0,  0,   0, 500},
    {0,1,  1,  1,  1,  1,   0,   0}
  };
  int n,m,ih,it,oh,ot;
  int p=0;
  while(1){
    scanf(""%d"",&n);
    if(!n)break;
    scanf(""%d %d %d %d %d"",&ih,&it,&m,&oh,&ot);
    if(n>m){
      p=n;
      n=m;
      m=p;
    }
    p=d[n][m];
    it+=60*ih;
    ot+=60*oh;
    if(d[m][n]==0&&
       ((17*60+30<=it&&it<=19*60+30)||
	17*60+30<=ot&&ot<=19*60+30))p/=2;
    if(p%50)p+=25;
    printf(""%d\n"",p);
  }
  return 0;
}",1
p00163,"有料道路通行料
20XX年に喜多方市熱塩加納町から南会津町までの6区間、総距離58kmの会津中央道路が完成し開通する予定です。
開通後、半年間は利用促進のため17時30分〜19時30分までに出発ICか到着ICを通過し、なおかつ走行距離が40km以下の車に対する通行料金は半額になります。ただし料金は50円単位とし、端数は切り上げます。下記の表は料金と距離の一覧表です。
例えば喜多方（２）から会津若松（４）までは料金が450円、距離が12kmとなります。半額時間帯であれば250円になります。
出発IC、出発IC通過時刻、到着IC、到着IC通過時刻を入力とし、料金を計算して出力するプログラムを作成してください。ただし、入力される時刻は24 時間表記の値とします。なお、17時30分および19時30分ちょうどに通過した場合も半額時間帯に含めます。
Input
複数のデータセットの並びが入力として与えられます。入力の終わりはゼロひとつの行で示されます。
各データセットは以下の形式で与えられます。
d
h
d
m
d
a
h
a
m
a
１行目に出発ICの番号
d
(1 ≤
d
≤ 7)、２行目に出発ICの通過時刻の時間
h
d
(0 ≤
h
d
≤ 23) と分
m
d
(0 ≤
m
d
≤ 59) が与えられます。
3行目に到着ICの番号
a
(1 ≤
a
≤ 7)、４行目に到着ICの通過時刻の時間
h
a
(0 ≤
h
a
≤ 23) と分
m
a
(0 ≤
m
a
≤ 59) が与えられます。
Output
データセットごとに通行料金（整数）を１行に出力します。
Sample Input
2
17 25
4
17 45
4
17 25
7
19 35
0
Output for the Sample Input
250
1300",Java,"import java.util.*;

public class Main {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        
        // Distance and price table
        int[][] distance = new int[8][8];
        int[][] price = new int[8][8];
        
        // Initialize distance table (symmetric)
        int[][] distData = {
            {0, 6, 12, 18, 32, 41, 58},
            {6, 0, 6, 12, 26, 35, 52},
            {12, 6, 0, 6, 20, 29, 46},
            {18, 12, 6, 0, 14, 23, 40},
            {32, 26, 20, 14, 0, 9, 26},
            {41, 35, 29, 23, 9, 0, 17},
            {58, 52, 46, 40, 26, 17, 0}
        };
        
        int[][] priceData = {
            {0, 350, 450, 600, 900, 1150, 1400},
            {350, 0, 350, 450, 750, 900, 1200},
            {450, 350, 0, 350, 600, 750, 1050},
            {600, 450, 350, 0, 450, 600, 850},
            {900, 750, 600, 450, 0, 350, 600},
            {1150, 900, 750, 600, 350, 0, 350},
            {1400, 1200, 1050, 850, 600, 350, 0}
        };
        
        for (int i = 0; i < 7; i++) {
            for (int j = 0; j < 7; j++) {
                distance[i+1][j+1] = distData[i][j];
                price[i+1][j+1] = priceData[i][j];
            }
        }
        
        while (true) {
            int d = sc.nextInt();
            if (d == 0) break;
            
            int hd = sc.nextInt();
            int md = sc.nextInt();
            int a = sc.nextInt();
            int ha = sc.nextInt();
            int ma = sc.nextInt();
            
            int dist = distance[d][a];
            int baseFare = price[d][a];
            
            // Check if discount applies
            // 17:30 - 19:30 (1050 - 1170 minutes from midnight)
            int departTime = hd * 60 + md;
            int arriveTime = ha * 60 + ma;
            
            boolean discount = false;
            if (dist <= 40) {
                // Check if either departure or arrival is in discount time
                if ((departTime >= 1050 && departTime <= 1170) || 
                    (arriveTime >= 1050 && arriveTime <= 1170)) {
                    discount = true;
                }
            }
            
            int fare;
            if (discount) {
                // Half price, round up to nearest 50 yen
                int halfFare = baseFare / 2;
                fare = ((halfFare + 49) / 50) * 50;
            } else {
                fare = baseFare;
            }
            
            System.out.println(fare);
        }
        
        sc.close();
    }
}
",0
p00163,"有料道路通行料
20XX年に喜多方市熱塩加納町から南会津町までの6区間、総距離58kmの会津中央道路が完成し開通する予定です。
開通後、半年間は利用促進のため17時30分〜19時30分までに出発ICか到着ICを通過し、なおかつ走行距離が40km以下の車に対する通行料金は半額になります。ただし料金は50円単位とし、端数は切り上げます。下記の表は料金と距離の一覧表です。
例えば喜多方（２）から会津若松（４）までは料金が450円、距離が12kmとなります。半額時間帯であれば250円になります。
出発IC、出発IC通過時刻、到着IC、到着IC通過時刻を入力とし、料金を計算して出力するプログラムを作成してください。ただし、入力される時刻は24 時間表記の値とします。なお、17時30分および19時30分ちょうどに通過した場合も半額時間帯に含めます。
Input
複数のデータセットの並びが入力として与えられます。入力の終わりはゼロひとつの行で示されます。
各データセットは以下の形式で与えられます。
d
h
d
m
d
a
h
a
m
a
１行目に出発ICの番号
d
(1 ≤
d
≤ 7)、２行目に出発ICの通過時刻の時間
h
d
(0 ≤
h
d
≤ 23) と分
m
d
(0 ≤
m
d
≤ 59) が与えられます。
3行目に到着ICの番号
a
(1 ≤
a
≤ 7)、４行目に到着ICの通過時刻の時間
h
a
(0 ≤
h
a
≤ 23) と分
m
a
(0 ≤
m
a
≤ 59) が与えられます。
Output
データセットごとに通行料金（整数）を１行に出力します。
Sample Input
2
17 25
4
17 45
4
17 25
7
19 35
0
Output for the Sample Input
250
1300",Java,"import java.util.Scanner;


public class Main {
	
	public static int[][] money = new int[][]
			{
				{	0,	300,	500,	600,	700,	1350,	1650},
				{	0,	0,		350,	450,	600,	1150,	1500},
				{	0,	0,		0,		250,	400,	1000,	1350},
				{	0,	0,		0,		0,		250,	850,	1300},
				{	0,	0,		0,		0,		0,		600,	1150},
				{	0,	0,		0,		0,		0,		0,		 500},
			};
	
	public static int[][] dist = new int[][]
			{
				{	0,	6,	13,	18,	23,	43,	58},
				{	0,	0,	7,	12,	17,	37,	52},
				{	0,	0,	0,	5,	10,	30,	45},
				{	0,	0,	0,	0,	5,	25,	40},
				{	0,	0,	0,	0,	0,	20,	35},
				{	0,	0,	0,	0,	0,	0,	15},
			};
	
	public static void main(String[] args) {
		Scanner sc = new Scanner(System.in);
		
		while(true){
			final int start = sc.nextInt() - 1;
			
			if(start == -1){
				break;
			}
			
			final int start_h = sc.nextInt();
			final int start_m = sc.nextInt();
			final int start_t = start_h * 60 + start_m;
			
			final int end = sc.nextInt() - 1;
			final int end_h = sc.nextInt();
			final int end_m = sc.nextInt();
			final int end_t = end_h * 60 + end_m;
			
			int cost = 0;
			if(start_t <= (17 * 60 + 30) && end_t >= (17 * 60 + 30) && end_t <= (19 * 60 + 30) || start_t >= (17 * 60 + 30) && start_t <= (19 * 60 + 30) && end_t >= (19 * 60 + 30)){
				if(dist[start][end] <= 40){
					cost = (int) (Math.ceil((money[start][end] / (2.0 * 50)))) * 50;
				}else{
					cost = money[start][end];
				}
			}else{
				cost = money[start][end];
			}
			
			System.out.println(cost);
		}
		
	}

}",1
p00163,"有料道路通行料
20XX年に喜多方市熱塩加納町から南会津町までの6区間、総距離58kmの会津中央道路が完成し開通する予定です。
開通後、半年間は利用促進のため17時30分〜19時30分までに出発ICか到着ICを通過し、なおかつ走行距離が40km以下の車に対する通行料金は半額になります。ただし料金は50円単位とし、端数は切り上げます。下記の表は料金と距離の一覧表です。
例えば喜多方（２）から会津若松（４）までは料金が450円、距離が12kmとなります。半額時間帯であれば250円になります。
出発IC、出発IC通過時刻、到着IC、到着IC通過時刻を入力とし、料金を計算して出力するプログラムを作成してください。ただし、入力される時刻は24 時間表記の値とします。なお、17時30分および19時30分ちょうどに通過した場合も半額時間帯に含めます。
Input
複数のデータセットの並びが入力として与えられます。入力の終わりはゼロひとつの行で示されます。
各データセットは以下の形式で与えられます。
d
h
d
m
d
a
h
a
m
a
１行目に出発ICの番号
d
(1 ≤
d
≤ 7)、２行目に出発ICの通過時刻の時間
h
d
(0 ≤
h
d
≤ 23) と分
m
d
(0 ≤
m
d
≤ 59) が与えられます。
3行目に到着ICの番号
a
(1 ≤
a
≤ 7)、４行目に到着ICの通過時刻の時間
h
a
(0 ≤
h
a
≤ 23) と分
m
a
(0 ≤
m
a
≤ 59) が与えられます。
Output
データセットごとに通行料金（整数）を１行に出力します。
Sample Input
2
17 25
4
17 45
4
17 25
7
19 35
0
Output for the Sample Input
250
1300",Python,"import math

# Distance and toll matrix
distance = [
    [0, 6, 18, 25, 37, 48, 58],
    [6, 0, 12, 19, 31, 42, 52],
    [18, 12, 0, 7, 19, 30, 40],
    [25, 19, 7, 0, 12, 23, 33],
    [37, 31, 19, 12, 0, 11, 21],
    [48, 42, 30, 23, 11, 0, 10],
    [58, 52, 40, 33, 21, 10, 0]
]

toll = [
    [0, 200, 500, 650, 900, 1150, 1350],
    [200, 0, 450, 600, 850, 1100, 1300],
    [500, 450, 0, 250, 500, 750, 950],
    [650, 600, 250, 0, 350, 600, 800],
    [900, 850, 500, 350, 0, 300, 550],
    [1150, 1100, 750, 600, 300, 0, 250],
    [1350, 1300, 950, 800, 550, 250, 0]
]

def in_discount_time(h, m):
    time_minutes = h * 60 + m
    start = 17 * 60 + 30  # 17:30
    end = 19 * 60 + 30    # 19:30
    return start <= time_minutes <= end

while True:
    d = int(input())
    if d == 0:
        break
    
    hd, md = map(int, input().split())
    a = int(input())
    ha, ma = map(int, input().split())
    
    # Convert to 0-indexed
    d -= 1
    a -= 1
    
    # Get base toll and distance
    base_toll = toll[d][a]
    dist = distance[d][a]
    
    # Check if discount applies
    discount = False
    if (in_discount_time(hd, md) or in_discount_time(ha, ma)) and dist <= 40:
        discount = True
    
    if discount:
        # Half price, rounded up to nearest 50
        half_toll = base_toll / 2
        final_toll = math.ceil(half_toll / 50) * 50
    else:
        final_toll = base_toll
    
    print(final_toll)
",0
p00163,"有料道路通行料
20XX年に喜多方市熱塩加納町から南会津町までの6区間、総距離58kmの会津中央道路が完成し開通する予定です。
開通後、半年間は利用促進のため17時30分〜19時30分までに出発ICか到着ICを通過し、なおかつ走行距離が40km以下の車に対する通行料金は半額になります。ただし料金は50円単位とし、端数は切り上げます。下記の表は料金と距離の一覧表です。
例えば喜多方（２）から会津若松（４）までは料金が450円、距離が12kmとなります。半額時間帯であれば250円になります。
出発IC、出発IC通過時刻、到着IC、到着IC通過時刻を入力とし、料金を計算して出力するプログラムを作成してください。ただし、入力される時刻は24 時間表記の値とします。なお、17時30分および19時30分ちょうどに通過した場合も半額時間帯に含めます。
Input
複数のデータセットの並びが入力として与えられます。入力の終わりはゼロひとつの行で示されます。
各データセットは以下の形式で与えられます。
d
h
d
m
d
a
h
a
m
a
１行目に出発ICの番号
d
(1 ≤
d
≤ 7)、２行目に出発ICの通過時刻の時間
h
d
(0 ≤
h
d
≤ 23) と分
m
d
(0 ≤
m
d
≤ 59) が与えられます。
3行目に到着ICの番号
a
(1 ≤
a
≤ 7)、４行目に到着ICの通過時刻の時間
h
a
(0 ≤
h
a
≤ 23) と分
m
a
(0 ≤
m
a
≤ 59) が与えられます。
Output
データセットごとに通行料金（整数）を１行に出力します。
Sample Input
2
17 25
4
17 45
4
17 25
7
19 35
0
Output for the Sample Input
250
1300",Python,"table=[[0,300,500,600,700,1350,1650],
       [0,0,350,450,600,1150,1500],
       [0,0,0,250,400,1000,1350],
       [0,0,0,0,250,850,1300],
       [0,0,0,0,0,600,1150],
       [0,0,0,0,0,0,500]]
fbd=[(1,6),(1,7),(2,7),(3,7)]
while True:
    init=input()
    if init==0:break
    h1,m1=map(int,raw_input().split())
    fin=input()
    h2,m2=map(int,raw_input().split())
    if init>fin:
        init,h1,m1,fin,h2,m2=fin,h2,m2,init,h1,m1
    t1=h1*60+m1
    t2=h2*60+m2
    if 1050<=t1<=1170 or 1050<=t2<=1170 and (init,fin) not in fbd:
        temp=table[init-1][fin-1]/2
        if temp%100>0:
            temp+=50-temp%50
        print temp
    else:
        print table[init-1][fin-1]",1
p00164,"おはじき取り
一郎君と次郎君の兄弟は家でよくおはじき取りをして遊びます。おはじき取りは、一カ所に積まれた複数のおはじきを二人が交互にとっていくゲームです。一度に1〜4個のおはじきを好きな数だけ順に取り、相手に最後の1個を取らせた方が勝ちになります。二人はいつも 32 個のおはじきを使い、兄である一郎君の番からゲームを始めます。
これまでに何度も戦っている二人ですが、次郎君は兄の一郎君にどうしても勝つことができません。それもそのはず、一郎君はこのゲームの必勝法を知っているからです。一郎君は、残りのおはじきの数を
n
とすると、必ず (
n
- 1) % 5 個のおはじきを取ります。ここで
x
%
y
は、
x
を
y
で割った余りを示します。
一方、次郎君は、残りのおはじきの数にかかわらず、ゲームのはじめに各回で取るおはじきの数を数列として決めてしまうのです。例えば、次郎君が決めた数列が{ 3, 1, 4, 2 } であるならば、彼の取るおはじきの数は順に 3 -> 1 -> 4 -> 2 -> 3 -> 1 -> 4 -> … となります（取ると決めた数が、おはじきの残りの数以上になった場合は、残りのおはじき全てを取ります）。
なんど負けてもやり方を変えようとしない頑固な次郎君の将来が心配になったお母さんは、次郎君がいかなる数列を選んだとしても一郎君には勝てないということを示すために、ゲームをシュミレートするプログラムを書くことにしました。
次郎君の考えた数列
a
を入力とし、一郎君と次郎君が順次おはじきを取った後の残りのおはじきの個数を出力するプログラムを作成してください。
Input
複数のデータセットの並びが入力として与えられます。入力の終わりはゼロひとつの行で示されます。
各データセットは以下の形式で与えられます。
n
a
1
a
2
...
a
n
１行目に次郎君の決めた数列の長さ
n
(1 ≤
n
≤ 25)、２行目に数列の
i
番目の要素
a
i
(1 ≤
a
i
≤ 4) が空白区切りで与えられます。入力はすべて整数で与えられます。
データセットの数は 100 を超えません。
Output
データセットごとに、ゲームの各回でのおはじきが取られた直後のおはじきの数（整数）を出力します。
Sample Input
4
3 1 4 2
3
4 3 2
0
Output for the Sample Input
31
28
26
25
21
17
16
14
11
8
6
5
1
0
31
27
26
23
21
19
16
12
11
8
6
4
1
0",C,"#include <stdio.h>

int main() {
    int n;
    while (scanf(""%d"", &n) == 1 && n != 0) {
        int a[25];
        for (int i = 0; i < n; i++) {
            scanf(""%d"", &a[i]);
        }
        
        int remaining = 32;
        int jiro_index = 0;
        int turn = 0; // 0 for Ichiro, 1 for Jiro
        
        while (remaining > 0) {
            if (turn == 0) {
                // Ichiro's turn
                int take = (remaining - 1) % 5;
                remaining -= take;
                printf(""%d\n"", remaining);
                turn = 1;
            } else {
                // Jiro's turn
                int take = a[jiro_index];
                if (take >= remaining) {
                    take = remaining;
                }
                remaining -= take;
                printf(""%d\n"", remaining);
                jiro_index = (jiro_index + 1) % n;
                turn = 0;
            }
        }
    }
    return 0;
}
",0
p00164,"おはじき取り
一郎君と次郎君の兄弟は家でよくおはじき取りをして遊びます。おはじき取りは、一カ所に積まれた複数のおはじきを二人が交互にとっていくゲームです。一度に1〜4個のおはじきを好きな数だけ順に取り、相手に最後の1個を取らせた方が勝ちになります。二人はいつも 32 個のおはじきを使い、兄である一郎君の番からゲームを始めます。
これまでに何度も戦っている二人ですが、次郎君は兄の一郎君にどうしても勝つことができません。それもそのはず、一郎君はこのゲームの必勝法を知っているからです。一郎君は、残りのおはじきの数を
n
とすると、必ず (
n
- 1) % 5 個のおはじきを取ります。ここで
x
%
y
は、
x
を
y
で割った余りを示します。
一方、次郎君は、残りのおはじきの数にかかわらず、ゲームのはじめに各回で取るおはじきの数を数列として決めてしまうのです。例えば、次郎君が決めた数列が{ 3, 1, 4, 2 } であるならば、彼の取るおはじきの数は順に 3 -> 1 -> 4 -> 2 -> 3 -> 1 -> 4 -> … となります（取ると決めた数が、おはじきの残りの数以上になった場合は、残りのおはじき全てを取ります）。
なんど負けてもやり方を変えようとしない頑固な次郎君の将来が心配になったお母さんは、次郎君がいかなる数列を選んだとしても一郎君には勝てないということを示すために、ゲームをシュミレートするプログラムを書くことにしました。
次郎君の考えた数列
a
を入力とし、一郎君と次郎君が順次おはじきを取った後の残りのおはじきの個数を出力するプログラムを作成してください。
Input
複数のデータセットの並びが入力として与えられます。入力の終わりはゼロひとつの行で示されます。
各データセットは以下の形式で与えられます。
n
a
1
a
2
...
a
n
１行目に次郎君の決めた数列の長さ
n
(1 ≤
n
≤ 25)、２行目に数列の
i
番目の要素
a
i
(1 ≤
a
i
≤ 4) が空白区切りで与えられます。入力はすべて整数で与えられます。
データセットの数は 100 を超えません。
Output
データセットごとに、ゲームの各回でのおはじきが取られた直後のおはじきの数（整数）を出力します。
Sample Input
4
3 1 4 2
3
4 3 2
0
Output for the Sample Input
31
28
26
25
21
17
16
14
11
8
6
5
1
0
31
27
26
23
21
19
16
12
11
8
6
4
1
0",C,"a[];main(f,l,i,n,S){for(;scanf(S=""%d\n"",&i)*i;){for(l=0;i--;)scanf(S,a+l++);for(n=32;n;f=!f)n-=f?~-n%5:a[++i%l],printf(S,n*=n>0);}}",1
p00164,"おはじき取り
一郎君と次郎君の兄弟は家でよくおはじき取りをして遊びます。おはじき取りは、一カ所に積まれた複数のおはじきを二人が交互にとっていくゲームです。一度に1〜4個のおはじきを好きな数だけ順に取り、相手に最後の1個を取らせた方が勝ちになります。二人はいつも 32 個のおはじきを使い、兄である一郎君の番からゲームを始めます。
これまでに何度も戦っている二人ですが、次郎君は兄の一郎君にどうしても勝つことができません。それもそのはず、一郎君はこのゲームの必勝法を知っているからです。一郎君は、残りのおはじきの数を
n
とすると、必ず (
n
- 1) % 5 個のおはじきを取ります。ここで
x
%
y
は、
x
を
y
で割った余りを示します。
一方、次郎君は、残りのおはじきの数にかかわらず、ゲームのはじめに各回で取るおはじきの数を数列として決めてしまうのです。例えば、次郎君が決めた数列が{ 3, 1, 4, 2 } であるならば、彼の取るおはじきの数は順に 3 -> 1 -> 4 -> 2 -> 3 -> 1 -> 4 -> … となります（取ると決めた数が、おはじきの残りの数以上になった場合は、残りのおはじき全てを取ります）。
なんど負けてもやり方を変えようとしない頑固な次郎君の将来が心配になったお母さんは、次郎君がいかなる数列を選んだとしても一郎君には勝てないということを示すために、ゲームをシュミレートするプログラムを書くことにしました。
次郎君の考えた数列
a
を入力とし、一郎君と次郎君が順次おはじきを取った後の残りのおはじきの個数を出力するプログラムを作成してください。
Input
複数のデータセットの並びが入力として与えられます。入力の終わりはゼロひとつの行で示されます。
各データセットは以下の形式で与えられます。
n
a
1
a
2
...
a
n
１行目に次郎君の決めた数列の長さ
n
(1 ≤
n
≤ 25)、２行目に数列の
i
番目の要素
a
i
(1 ≤
a
i
≤ 4) が空白区切りで与えられます。入力はすべて整数で与えられます。
データセットの数は 100 を超えません。
Output
データセットごとに、ゲームの各回でのおはじきが取られた直後のおはじきの数（整数）を出力します。
Sample Input
4
3 1 4 2
3
4 3 2
0
Output for the Sample Input
31
28
26
25
21
17
16
14
11
8
6
5
1
0
31
27
26
23
21
19
16
12
11
8
6
4
1
0",Java,"import java.util.*;

public class Main {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        
        while (true) {
            int n = sc.nextInt();
            if (n == 0) break;
            
            int[] a = new int[n];
            for (int i = 0; i < n; i++) {
                a[i] = sc.nextInt();
            }
            
            int remaining = 32;
            int jiroIndex = 0;
            
            while (remaining > 0) {
                // Ichiro's turn
                int ichiroTake = (remaining - 1) % 5;
                remaining -= ichiroTake;
                System.out.println(remaining);
                
                if (remaining == 0) break;
                
                // Jiro's turn
                int jiroTake = Math.min(a[jiroIndex], remaining);
                remaining -= jiroTake;
                System.out.println(remaining);
                
                jiroIndex = (jiroIndex + 1) % n;
                
                if (remaining == 0) break;
            }
        }
        
        sc.close();
    }
}
",0
p00164,"おはじき取り
一郎君と次郎君の兄弟は家でよくおはじき取りをして遊びます。おはじき取りは、一カ所に積まれた複数のおはじきを二人が交互にとっていくゲームです。一度に1〜4個のおはじきを好きな数だけ順に取り、相手に最後の1個を取らせた方が勝ちになります。二人はいつも 32 個のおはじきを使い、兄である一郎君の番からゲームを始めます。
これまでに何度も戦っている二人ですが、次郎君は兄の一郎君にどうしても勝つことができません。それもそのはず、一郎君はこのゲームの必勝法を知っているからです。一郎君は、残りのおはじきの数を
n
とすると、必ず (
n
- 1) % 5 個のおはじきを取ります。ここで
x
%
y
は、
x
を
y
で割った余りを示します。
一方、次郎君は、残りのおはじきの数にかかわらず、ゲームのはじめに各回で取るおはじきの数を数列として決めてしまうのです。例えば、次郎君が決めた数列が{ 3, 1, 4, 2 } であるならば、彼の取るおはじきの数は順に 3 -> 1 -> 4 -> 2 -> 3 -> 1 -> 4 -> … となります（取ると決めた数が、おはじきの残りの数以上になった場合は、残りのおはじき全てを取ります）。
なんど負けてもやり方を変えようとしない頑固な次郎君の将来が心配になったお母さんは、次郎君がいかなる数列を選んだとしても一郎君には勝てないということを示すために、ゲームをシュミレートするプログラムを書くことにしました。
次郎君の考えた数列
a
を入力とし、一郎君と次郎君が順次おはじきを取った後の残りのおはじきの個数を出力するプログラムを作成してください。
Input
複数のデータセットの並びが入力として与えられます。入力の終わりはゼロひとつの行で示されます。
各データセットは以下の形式で与えられます。
n
a
1
a
2
...
a
n
１行目に次郎君の決めた数列の長さ
n
(1 ≤
n
≤ 25)、２行目に数列の
i
番目の要素
a
i
(1 ≤
a
i
≤ 4) が空白区切りで与えられます。入力はすべて整数で与えられます。
データセットの数は 100 を超えません。
Output
データセットごとに、ゲームの各回でのおはじきが取られた直後のおはじきの数（整数）を出力します。
Sample Input
4
3 1 4 2
3
4 3 2
0
Output for the Sample Input
31
28
26
25
21
17
16
14
11
8
6
5
1
0
31
27
26
23
21
19
16
12
11
8
6
4
1
0",Java,"import static java.util.Arrays.deepToString;

import java.util.Scanner;

public class Main {
	public static void main(String[] args) {
		new Main().run();
	}
	void tr(Object... os) {
		System.err.println(deepToString(os));
	}

	Scanner sc = new Scanner(System.in);
	public void run() {
		for (;sc.hasNext();) {
			int n = sc.nextInt();
			if (n == 0) break;
			int[] a = new int[n];
			for (int i = 0; i < n; i++) a[i] = sc.nextInt();
			
			int st = 32;
			for (int time = 0; st > 0; time++) {
				st -= (st - 1) % 5;
				System.out.println(st);
				int g = a[time%a.length];
				st -= g;
				if (st < 0) {
					st = 0;
				}
				System.out.println(st);
			}
		}
	}
}",1
p00164,"おはじき取り
一郎君と次郎君の兄弟は家でよくおはじき取りをして遊びます。おはじき取りは、一カ所に積まれた複数のおはじきを二人が交互にとっていくゲームです。一度に1〜4個のおはじきを好きな数だけ順に取り、相手に最後の1個を取らせた方が勝ちになります。二人はいつも 32 個のおはじきを使い、兄である一郎君の番からゲームを始めます。
これまでに何度も戦っている二人ですが、次郎君は兄の一郎君にどうしても勝つことができません。それもそのはず、一郎君はこのゲームの必勝法を知っているからです。一郎君は、残りのおはじきの数を
n
とすると、必ず (
n
- 1) % 5 個のおはじきを取ります。ここで
x
%
y
は、
x
を
y
で割った余りを示します。
一方、次郎君は、残りのおはじきの数にかかわらず、ゲームのはじめに各回で取るおはじきの数を数列として決めてしまうのです。例えば、次郎君が決めた数列が{ 3, 1, 4, 2 } であるならば、彼の取るおはじきの数は順に 3 -> 1 -> 4 -> 2 -> 3 -> 1 -> 4 -> … となります（取ると決めた数が、おはじきの残りの数以上になった場合は、残りのおはじき全てを取ります）。
なんど負けてもやり方を変えようとしない頑固な次郎君の将来が心配になったお母さんは、次郎君がいかなる数列を選んだとしても一郎君には勝てないということを示すために、ゲームをシュミレートするプログラムを書くことにしました。
次郎君の考えた数列
a
を入力とし、一郎君と次郎君が順次おはじきを取った後の残りのおはじきの個数を出力するプログラムを作成してください。
Input
複数のデータセットの並びが入力として与えられます。入力の終わりはゼロひとつの行で示されます。
各データセットは以下の形式で与えられます。
n
a
1
a
2
...
a
n
１行目に次郎君の決めた数列の長さ
n
(1 ≤
n
≤ 25)、２行目に数列の
i
番目の要素
a
i
(1 ≤
a
i
≤ 4) が空白区切りで与えられます。入力はすべて整数で与えられます。
データセットの数は 100 を超えません。
Output
データセットごとに、ゲームの各回でのおはじきが取られた直後のおはじきの数（整数）を出力します。
Sample Input
4
3 1 4 2
3
4 3 2
0
Output for the Sample Input
31
28
26
25
21
17
16
14
11
8
6
5
1
0
31
27
26
23
21
19
16
12
11
8
6
4
1
0",Python,"while True:
    n = int(input())
    if n == 0:
        break
    
    sequence = list(map(int, input().split()))
    
    remaining = 32
    jiro_index = 0
    
    while remaining > 0:
        # Ichiro's turn
        to_take = (remaining - 1) % 5
        remaining -= to_take
        print(remaining)
        
        if remaining == 0:
            break
        
        # Jiro's turn
        to_take = min(sequence[jiro_index], remaining)
        remaining -= to_take
        print(remaining)
        
        jiro_index = (jiro_index + 1) % n
        
        if remaining == 0:
            break
",0
p00164,"おはじき取り
一郎君と次郎君の兄弟は家でよくおはじき取りをして遊びます。おはじき取りは、一カ所に積まれた複数のおはじきを二人が交互にとっていくゲームです。一度に1〜4個のおはじきを好きな数だけ順に取り、相手に最後の1個を取らせた方が勝ちになります。二人はいつも 32 個のおはじきを使い、兄である一郎君の番からゲームを始めます。
これまでに何度も戦っている二人ですが、次郎君は兄の一郎君にどうしても勝つことができません。それもそのはず、一郎君はこのゲームの必勝法を知っているからです。一郎君は、残りのおはじきの数を
n
とすると、必ず (
n
- 1) % 5 個のおはじきを取ります。ここで
x
%
y
は、
x
を
y
で割った余りを示します。
一方、次郎君は、残りのおはじきの数にかかわらず、ゲームのはじめに各回で取るおはじきの数を数列として決めてしまうのです。例えば、次郎君が決めた数列が{ 3, 1, 4, 2 } であるならば、彼の取るおはじきの数は順に 3 -> 1 -> 4 -> 2 -> 3 -> 1 -> 4 -> … となります（取ると決めた数が、おはじきの残りの数以上になった場合は、残りのおはじき全てを取ります）。
なんど負けてもやり方を変えようとしない頑固な次郎君の将来が心配になったお母さんは、次郎君がいかなる数列を選んだとしても一郎君には勝てないということを示すために、ゲームをシュミレートするプログラムを書くことにしました。
次郎君の考えた数列
a
を入力とし、一郎君と次郎君が順次おはじきを取った後の残りのおはじきの個数を出力するプログラムを作成してください。
Input
複数のデータセットの並びが入力として与えられます。入力の終わりはゼロひとつの行で示されます。
各データセットは以下の形式で与えられます。
n
a
1
a
2
...
a
n
１行目に次郎君の決めた数列の長さ
n
(1 ≤
n
≤ 25)、２行目に数列の
i
番目の要素
a
i
(1 ≤
a
i
≤ 4) が空白区切りで与えられます。入力はすべて整数で与えられます。
データセットの数は 100 を超えません。
Output
データセットごとに、ゲームの各回でのおはじきが取られた直後のおはじきの数（整数）を出力します。
Sample Input
4
3 1 4 2
3
4 3 2
0
Output for the Sample Input
31
28
26
25
21
17
16
14
11
8
6
5
1
0
31
27
26
23
21
19
16
12
11
8
6
4
1
0",Python,"while 1:
    n=int(input())
    if n==0: break
    a=list(map(int,input().split()))
    i,s=0,32
    while s>0:
        s-=(s-1)%5
        print(s)
        s-=a[i%n]
        i+=1
        print(max(0,s))",1
p00165,"宝くじ
ある国の王様は素数とギャンブルが大好きです。この国の通貨の単位はプライムといいます。2007 年 11 月 1 日現在のプライムのクロス円レートは 9973 とちょうど素数になっていたので、王様は大喜びです。この国では 1/101 プライムを1サブプライムとする補助貨幣が使われています。
この国の政府は、国家財政の安定、国民の娯楽、王様の趣味を同時に満足させることを目的に宝くじ振興公社を設立し、宝くじ事業を始めることにしました。素数が大好きな王様は、素数が話題になればそれだけで満足して、賞金をあげたくなります。そこで振興公社は次のような宝くじを考えました。
くじには 0 から
MP
までの一連の番号がつけられている。
MP
はこの国で知られている最大の素数で、毎月一日に官報で告示される。同時に、
MP
以下のすべての素数も発表される。それ以上大きな素数が発見されても、その月の間は、宝くじ振興公社を含む全ての公的な機関では、一日に発表された
MP
を最大の素数として扱う。2007 年 11 月 1 日 には
MP
= 999983 (1000000 以下の最大の素数) が発表された。
宝くじの販売価格は 1 サブプライム。
宝くじの抽選では、当たりくじの番号
p
と賞金算出のための数
m
の組(
p
,
m
) が何組か選ばれる。
p
,
m
はそれぞれ0 以上
MP
以下の整数。
この国で知られている素数の中で
p
-
m
以上
p
+
m
以下のものが
X
個あるとすると、抽選結果(
p
,
m
) の賞金は、
X
プライムとなる。
抽選結果 (
p
,
m
) の賞金
X
プライムは番号
p
の宝くじを持っている当選者に支払われるが、
X
= 0 の場合もあり、この場合には当選者には賞金は支払われない。
賞金のうち 1 プライムは宝くじの売り上げから支出され、
X
- 1 プライムは王様の内廷費から支出される（王様が払ってくれる）。
X
= 0 ならば宝くじの売り上げから 1 プライムが内廷費に繰り入れられる。（王様に対し支払われる）
ひとつの番号
p
が複数の当たりくじになることもある。この場合にはそれぞれの抽選結果(
p
,
m
) から算出される賞金の合計が当選者に支払われる。
このくじでは当たりくじを買った人は抽選結果から関係する素数を探し、その個数を数えるので、国民の話題に素数がよく出てきて王様はとてもご満悦です。宝くじ振興公社としては当たりくじ1本当たり公社負担が 1 プライム、販売価格が 1 サブプライムだから、当たりくじの本数
n
を、販売した宝くじ 101 本あたり 1 本以下となるようにすれば (すなわち、
n
≤ (販売した本数)/101 とすれば) 赤字にはなりません。
問題は内廷費からの支出額です。あなたの仕事は、抽選結果を入力として、2007 年 11 月における宝くじ振興公社が王様に請求する賞金の額を出力するプログラムを作成することです。ただし、請求する賞金の額が負になることはないものとします。
注意
この国における素数の定義も日本の学校教育で学習する内容と同じです。即ち、素数とは 1 と自分自身以外の約数を持たない自然数をいいます（なお、1 は素数ではありません）。
我々は 1000003 が素数であることを知っていますが、この国では 2007 年 11 月段階では知られていません。そのため、999963 以上 1000003 以下の範囲にあるこの国で知られている素数は 999983 と 999979 の 2 個しかありません。
Input
複数のデータセットの並びが入力として与えられます。入力の終わりはゼロひとつの行で示されます。
各データセットは以下の形式で与えられます。
n
p
1
m
1
p
2
m
2
:
p
n
m
n
１行目に抽選結果の数
n
(1 ≤
n
≤ 1000000)、続く
n
行に
i
番目の抽選結果の情報
p
i
,
m
i
が空白区切りで与えられます。
データセットの数は 20 を超えません。
Output
データセットごとに王様への請求額をプライム単位（整数）で１行に出力します。
Sample Input
4
5 0
9 1
3 10
11 3
1
999983 20
0
Output for the Sample Input
5
1",C,"#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#define MP 999983
#define MAX_PRIMES 80000

int is_prime[MP + 1];
int primes[MAX_PRIMES];
int prime_count = 0;

void sieve() {
    memset(is_prime, 1, sizeof(is_prime));
    is_prime[0] = is_prime[1] = 0;
    
    for (int i = 2; i * i <= MP; i++) {
        if (is_prime[i]) {
            for (int j = i * i; j <= MP; j += i) {
                is_prime[j] = 0;
            }
        }
    }
    
    for (int i = 2; i <= MP; i++) {
        if (is_prime[i]) {
            primes[prime_count++] = i;
        }
    }
}

int binary_search_lower(int val) {
    int left = 0, right = prime_count - 1;
    int result = prime_count;
    
    while (left <= right) {
        int mid = (left + right) / 2;
        if (primes[mid] >= val) {
            result = mid;
            right = mid - 1;
        } else {
            left = mid + 1;
        }
    }
    return result;
}

int binary_search_upper(int val) {
    int left = 0, right = prime_count - 1;
    int result = -1;
    
    while (left <= right) {
        int mid = (left + right) / 2;
        if (primes[mid] <= val) {
            result = mid;
            left = mid + 1;
        } else {
            right = mid - 1;
        }
    }
    return result;
}

int count_primes_in_range(int lower, int upper) {
    if (lower > MP) return 0;
    if (upper < 2) return 0;
    
    if (lower < 2) lower = 2;
    if (upper > MP) upper = MP;
    
    int lower_idx = binary_search_lower(lower);
    int upper_idx = binary_search_upper(upper);
    
    if (lower_idx > upper_idx || lower_idx >= prime_count || upper_idx < 0) {
        return 0;
    }
    
    return upper_idx - lower_idx + 1;
}

int main() {
    sieve();
    
    int n;
    while (scanf(""%d"", &n) == 1 && n != 0) {
        long long total = 0;
        
        for (int i = 0; i < n; i++) {
            int p, m;
            scanf(""%d %d"", &p, &m);
            
            int lower = p - m;
            int upper = p + m;
            
            int X = count_primes_in_range(lower, upper);
            
            if (X > 1) {
                total += (X - 1);
            } else if (X == 0) {
                total -= 1;
            }
        }
        
        if (total < 0) total = 0;
        
        printf(""%lld\n"", total);
    }
    
    return 0;
}
",0
p00165,"宝くじ
ある国の王様は素数とギャンブルが大好きです。この国の通貨の単位はプライムといいます。2007 年 11 月 1 日現在のプライムのクロス円レートは 9973 とちょうど素数になっていたので、王様は大喜びです。この国では 1/101 プライムを1サブプライムとする補助貨幣が使われています。
この国の政府は、国家財政の安定、国民の娯楽、王様の趣味を同時に満足させることを目的に宝くじ振興公社を設立し、宝くじ事業を始めることにしました。素数が大好きな王様は、素数が話題になればそれだけで満足して、賞金をあげたくなります。そこで振興公社は次のような宝くじを考えました。
くじには 0 から
MP
までの一連の番号がつけられている。
MP
はこの国で知られている最大の素数で、毎月一日に官報で告示される。同時に、
MP
以下のすべての素数も発表される。それ以上大きな素数が発見されても、その月の間は、宝くじ振興公社を含む全ての公的な機関では、一日に発表された
MP
を最大の素数として扱う。2007 年 11 月 1 日 には
MP
= 999983 (1000000 以下の最大の素数) が発表された。
宝くじの販売価格は 1 サブプライム。
宝くじの抽選では、当たりくじの番号
p
と賞金算出のための数
m
の組(
p
,
m
) が何組か選ばれる。
p
,
m
はそれぞれ0 以上
MP
以下の整数。
この国で知られている素数の中で
p
-
m
以上
p
+
m
以下のものが
X
個あるとすると、抽選結果(
p
,
m
) の賞金は、
X
プライムとなる。
抽選結果 (
p
,
m
) の賞金
X
プライムは番号
p
の宝くじを持っている当選者に支払われるが、
X
= 0 の場合もあり、この場合には当選者には賞金は支払われない。
賞金のうち 1 プライムは宝くじの売り上げから支出され、
X
- 1 プライムは王様の内廷費から支出される（王様が払ってくれる）。
X
= 0 ならば宝くじの売り上げから 1 プライムが内廷費に繰り入れられる。（王様に対し支払われる）
ひとつの番号
p
が複数の当たりくじになることもある。この場合にはそれぞれの抽選結果(
p
,
m
) から算出される賞金の合計が当選者に支払われる。
このくじでは当たりくじを買った人は抽選結果から関係する素数を探し、その個数を数えるので、国民の話題に素数がよく出てきて王様はとてもご満悦です。宝くじ振興公社としては当たりくじ1本当たり公社負担が 1 プライム、販売価格が 1 サブプライムだから、当たりくじの本数
n
を、販売した宝くじ 101 本あたり 1 本以下となるようにすれば (すなわち、
n
≤ (販売した本数)/101 とすれば) 赤字にはなりません。
問題は内廷費からの支出額です。あなたの仕事は、抽選結果を入力として、2007 年 11 月における宝くじ振興公社が王様に請求する賞金の額を出力するプログラムを作成することです。ただし、請求する賞金の額が負になることはないものとします。
注意
この国における素数の定義も日本の学校教育で学習する内容と同じです。即ち、素数とは 1 と自分自身以外の約数を持たない自然数をいいます（なお、1 は素数ではありません）。
我々は 1000003 が素数であることを知っていますが、この国では 2007 年 11 月段階では知られていません。そのため、999963 以上 1000003 以下の範囲にあるこの国で知られている素数は 999983 と 999979 の 2 個しかありません。
Input
複数のデータセットの並びが入力として与えられます。入力の終わりはゼロひとつの行で示されます。
各データセットは以下の形式で与えられます。
n
p
1
m
1
p
2
m
2
:
p
n
m
n
１行目に抽選結果の数
n
(1 ≤
n
≤ 1000000)、続く
n
行に
i
番目の抽選結果の情報
p
i
,
m
i
が空白区切りで与えられます。
データセットの数は 20 を超えません。
Output
データセットごとに王様への請求額をプライム単位（整数）で１行に出力します。
Sample Input
4
5 0
9 1
3 10
11 3
1
999983 20
0
Output for the Sample Input
5
1",C,"#include <stdio.h>

#define MAX 10000000

int pp[MAX + 1];

int main(){
  int n, p, m, i, j, prime, x, res, c;
  pp[0] = pp[1] = 1;
  for(i = 2; i < MAX / 2 ; ++i)
    if(pp[i] != 1)
      for(j = i * 2; j < MAX; j += i)
	pp[j] = 1;

  while(scanf(""%d"", &n) && n){
    res = 0;
    while(n--){
      scanf(""%d %d"", &p, &m);
      c = 0;
      for(i = ((p - m) < 0 ? 0 : p - m);i < ((p + m) > MAX ? MAX : p + m); ++i)
	if(pp[i] == 0) c++;
      if(c > 0) c--;
      res += c;
    }
    printf(""%d\n"", res);
  }
  return 0;
}",1
p00165,"宝くじ
ある国の王様は素数とギャンブルが大好きです。この国の通貨の単位はプライムといいます。2007 年 11 月 1 日現在のプライムのクロス円レートは 9973 とちょうど素数になっていたので、王様は大喜びです。この国では 1/101 プライムを1サブプライムとする補助貨幣が使われています。
この国の政府は、国家財政の安定、国民の娯楽、王様の趣味を同時に満足させることを目的に宝くじ振興公社を設立し、宝くじ事業を始めることにしました。素数が大好きな王様は、素数が話題になればそれだけで満足して、賞金をあげたくなります。そこで振興公社は次のような宝くじを考えました。
くじには 0 から
MP
までの一連の番号がつけられている。
MP
はこの国で知られている最大の素数で、毎月一日に官報で告示される。同時に、
MP
以下のすべての素数も発表される。それ以上大きな素数が発見されても、その月の間は、宝くじ振興公社を含む全ての公的な機関では、一日に発表された
MP
を最大の素数として扱う。2007 年 11 月 1 日 には
MP
= 999983 (1000000 以下の最大の素数) が発表された。
宝くじの販売価格は 1 サブプライム。
宝くじの抽選では、当たりくじの番号
p
と賞金算出のための数
m
の組(
p
,
m
) が何組か選ばれる。
p
,
m
はそれぞれ0 以上
MP
以下の整数。
この国で知られている素数の中で
p
-
m
以上
p
+
m
以下のものが
X
個あるとすると、抽選結果(
p
,
m
) の賞金は、
X
プライムとなる。
抽選結果 (
p
,
m
) の賞金
X
プライムは番号
p
の宝くじを持っている当選者に支払われるが、
X
= 0 の場合もあり、この場合には当選者には賞金は支払われない。
賞金のうち 1 プライムは宝くじの売り上げから支出され、
X
- 1 プライムは王様の内廷費から支出される（王様が払ってくれる）。
X
= 0 ならば宝くじの売り上げから 1 プライムが内廷費に繰り入れられる。（王様に対し支払われる）
ひとつの番号
p
が複数の当たりくじになることもある。この場合にはそれぞれの抽選結果(
p
,
m
) から算出される賞金の合計が当選者に支払われる。
このくじでは当たりくじを買った人は抽選結果から関係する素数を探し、その個数を数えるので、国民の話題に素数がよく出てきて王様はとてもご満悦です。宝くじ振興公社としては当たりくじ1本当たり公社負担が 1 プライム、販売価格が 1 サブプライムだから、当たりくじの本数
n
を、販売した宝くじ 101 本あたり 1 本以下となるようにすれば (すなわち、
n
≤ (販売した本数)/101 とすれば) 赤字にはなりません。
問題は内廷費からの支出額です。あなたの仕事は、抽選結果を入力として、2007 年 11 月における宝くじ振興公社が王様に請求する賞金の額を出力するプログラムを作成することです。ただし、請求する賞金の額が負になることはないものとします。
注意
この国における素数の定義も日本の学校教育で学習する内容と同じです。即ち、素数とは 1 と自分自身以外の約数を持たない自然数をいいます（なお、1 は素数ではありません）。
我々は 1000003 が素数であることを知っていますが、この国では 2007 年 11 月段階では知られていません。そのため、999963 以上 1000003 以下の範囲にあるこの国で知られている素数は 999983 と 999979 の 2 個しかありません。
Input
複数のデータセットの並びが入力として与えられます。入力の終わりはゼロひとつの行で示されます。
各データセットは以下の形式で与えられます。
n
p
1
m
1
p
2
m
2
:
p
n
m
n
１行目に抽選結果の数
n
(1 ≤
n
≤ 1000000)、続く
n
行に
i
番目の抽選結果の情報
p
i
,
m
i
が空白区切りで与えられます。
データセットの数は 20 を超えません。
Output
データセットごとに王様への請求額をプライム単位（整数）で１行に出力します。
Sample Input
4
5 0
9 1
3 10
11 3
1
999983 20
0
Output for the Sample Input
5
1",Java,"import java.util.*;
import java.io.*;

public class Main {
    static final int MP = 999983;
    static boolean[] isPrime;
    static int[] primeCount;
    
    static void sieve() {
        isPrime = new boolean[MP + 1];
        Arrays.fill(isPrime, true);
        isPrime[0] = isPrime[1] = false;
        
        for (int i = 2; i * i <= MP; i++) {
            if (isPrime[i]) {
                for (int j = i * i; j <= MP; j += i) {
                    isPrime[j] = false;
                }
            }
        }
        
        primeCount = new int[MP + 1];
        int count = 0;
        for (int i = 0; i <= MP; i++) {
            if (isPrime[i]) count++;
            primeCount[i] = count;
        }
    }
    
    static int countPrimes(int p, int m) {
        int left = Math.max(0, p - m);
        int right = Math.min(MP, p + m);
        
        int count = primeCount[right];
        if (left > 0) {
            count -= primeCount[left - 1];
        }
        
        return count;
    }
    
    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        PrintWriter pw = new PrintWriter(System.out);
        
        sieve();
        
        String line;
        while ((line = br.readLine()) != null) {
            int n = Integer.parseInt(line.trim());
            if (n == 0) break;
            
            long totalRequest = 0;
            
            for (int i = 0; i < n; i++) {
                String[] parts = br.readLine().trim().split(""\\s+"");
                int p = Integer.parseInt(parts[0]);
                int m = Integer.parseInt(parts[1]);
                
                int x = countPrimes(p, m);
                
                if (x == 0) {
                    totalRequest -= 1;
                } else {
                    totalRequest += (x - 1);
                }
            }
            
            totalRequest = Math.max(0, totalRequest);
            pw.println(totalRequest);
        }
        
        pw.flush();
        pw.close();
    }
}
",0
p00165,"宝くじ
ある国の王様は素数とギャンブルが大好きです。この国の通貨の単位はプライムといいます。2007 年 11 月 1 日現在のプライムのクロス円レートは 9973 とちょうど素数になっていたので、王様は大喜びです。この国では 1/101 プライムを1サブプライムとする補助貨幣が使われています。
この国の政府は、国家財政の安定、国民の娯楽、王様の趣味を同時に満足させることを目的に宝くじ振興公社を設立し、宝くじ事業を始めることにしました。素数が大好きな王様は、素数が話題になればそれだけで満足して、賞金をあげたくなります。そこで振興公社は次のような宝くじを考えました。
くじには 0 から
MP
までの一連の番号がつけられている。
MP
はこの国で知られている最大の素数で、毎月一日に官報で告示される。同時に、
MP
以下のすべての素数も発表される。それ以上大きな素数が発見されても、その月の間は、宝くじ振興公社を含む全ての公的な機関では、一日に発表された
MP
を最大の素数として扱う。2007 年 11 月 1 日 には
MP
= 999983 (1000000 以下の最大の素数) が発表された。
宝くじの販売価格は 1 サブプライム。
宝くじの抽選では、当たりくじの番号
p
と賞金算出のための数
m
の組(
p
,
m
) が何組か選ばれる。
p
,
m
はそれぞれ0 以上
MP
以下の整数。
この国で知られている素数の中で
p
-
m
以上
p
+
m
以下のものが
X
個あるとすると、抽選結果(
p
,
m
) の賞金は、
X
プライムとなる。
抽選結果 (
p
,
m
) の賞金
X
プライムは番号
p
の宝くじを持っている当選者に支払われるが、
X
= 0 の場合もあり、この場合には当選者には賞金は支払われない。
賞金のうち 1 プライムは宝くじの売り上げから支出され、
X
- 1 プライムは王様の内廷費から支出される（王様が払ってくれる）。
X
= 0 ならば宝くじの売り上げから 1 プライムが内廷費に繰り入れられる。（王様に対し支払われる）
ひとつの番号
p
が複数の当たりくじになることもある。この場合にはそれぞれの抽選結果(
p
,
m
) から算出される賞金の合計が当選者に支払われる。
このくじでは当たりくじを買った人は抽選結果から関係する素数を探し、その個数を数えるので、国民の話題に素数がよく出てきて王様はとてもご満悦です。宝くじ振興公社としては当たりくじ1本当たり公社負担が 1 プライム、販売価格が 1 サブプライムだから、当たりくじの本数
n
を、販売した宝くじ 101 本あたり 1 本以下となるようにすれば (すなわち、
n
≤ (販売した本数)/101 とすれば) 赤字にはなりません。
問題は内廷費からの支出額です。あなたの仕事は、抽選結果を入力として、2007 年 11 月における宝くじ振興公社が王様に請求する賞金の額を出力するプログラムを作成することです。ただし、請求する賞金の額が負になることはないものとします。
注意
この国における素数の定義も日本の学校教育で学習する内容と同じです。即ち、素数とは 1 と自分自身以外の約数を持たない自然数をいいます（なお、1 は素数ではありません）。
我々は 1000003 が素数であることを知っていますが、この国では 2007 年 11 月段階では知られていません。そのため、999963 以上 1000003 以下の範囲にあるこの国で知られている素数は 999983 と 999979 の 2 個しかありません。
Input
複数のデータセットの並びが入力として与えられます。入力の終わりはゼロひとつの行で示されます。
各データセットは以下の形式で与えられます。
n
p
1
m
1
p
2
m
2
:
p
n
m
n
１行目に抽選結果の数
n
(1 ≤
n
≤ 1000000)、続く
n
行に
i
番目の抽選結果の情報
p
i
,
m
i
が空白区切りで与えられます。
データセットの数は 20 を超えません。
Output
データセットごとに王様への請求額をプライム単位（整数）で１行に出力します。
Sample Input
4
5 0
9 1
3 10
11 3
1
999983 20
0
Output for the Sample Input
5
1",Java,"import java.io.*;
import java.util.*;

public class Main{
	public static void main(String args[]){
		try{
			new Main();
		}catch(IOException e){
			e.printStackTrace();
		}
	}
	
	long[] m = new long[]{ 2, 7, 61 };
	
	public Main() throws IOException{
		BufferedReader in = new BufferedReader(new InputStreamReader(System.in));
		List<Integer> Ans = new ArrayList<Integer>();
		String line;
		
		int[] prime = new int[1000000];
		
		while((line = in.readLine()) != null){
			int size = Integer.parseInt(line);
			if(size==0) break;
			
			int pay = 0;
			for(int n=0; n<size; n++){
				line = in.readLine();
				String[] dst = line.split("" "");
				int center = Integer.parseInt(dst[0]);
				int range = Integer.parseInt(dst[1]);
				
				int count = 0;
				for(int i=Math.max(2, center-range); i<=Math.min(center+range, 999983); i++){
					if(prime[i]==0){
						if(isPrime(i)){
							prime[i] = 1;
							count++;
						}
						else{
							prime[i] = 2;
						}
					}else{
						if(prime[i]==1){
							count++;
						}
					}
				}
				
				pay += count - 1;
			}
			
			Ans.add(Math.max(0, pay));
		}
		
		for(int n=0; n<Ans.size(); n++){
			System.out.println(Ans.get(n));
		}		
	}
	
	public boolean isPrime(long x){
		if(x==2){
			return true;
		}
		else if(x%2 == 0){
			return false;
		}
		else{
			long s = 0;
			long d = x - 1;
			while(d%2 == 0){
				d = d / 2;
				s++;
			}
			
			for(int i=0; i<3; i++){
				long a = m[i];
				if(a%x == 0) continue;
				
				long pow = mod(a, d, x);
				if(pow == 1) continue;
				if(pow == x - 1) continue;
				
				boolean con2 = false;
				for(int r=1; r<s; r++){
					pow = mod(pow, 2, x);
					//pow = mod(a, (long)(d * Math.pow(2.0, r)), x);
					if(pow ==  x - 1){
						con2 = true;
						break;
					}
				}
				
				if(!con2){
					return false;
				}
			}
			
			return true;
		}
	}
	
	public long mod(long a, long d, long n){
		if(a==0 || n==0) return 0;
		if(d==0) return 1 % n;
		
		long currentMod = a % n;
		long currentValue = (d%2 == 1) ? currentMod : 1;
		
		for(d>>=1; d>0; d>>=1){
			currentMod = (currentMod * currentMod) % n;
			if(d%2 == 1){
				currentValue = (currentValue * currentMod) % n;
			}
		}
		
		return currentValue;
		
	}
}",1
p00165,"宝くじ
ある国の王様は素数とギャンブルが大好きです。この国の通貨の単位はプライムといいます。2007 年 11 月 1 日現在のプライムのクロス円レートは 9973 とちょうど素数になっていたので、王様は大喜びです。この国では 1/101 プライムを1サブプライムとする補助貨幣が使われています。
この国の政府は、国家財政の安定、国民の娯楽、王様の趣味を同時に満足させることを目的に宝くじ振興公社を設立し、宝くじ事業を始めることにしました。素数が大好きな王様は、素数が話題になればそれだけで満足して、賞金をあげたくなります。そこで振興公社は次のような宝くじを考えました。
くじには 0 から
MP
までの一連の番号がつけられている。
MP
はこの国で知られている最大の素数で、毎月一日に官報で告示される。同時に、
MP
以下のすべての素数も発表される。それ以上大きな素数が発見されても、その月の間は、宝くじ振興公社を含む全ての公的な機関では、一日に発表された
MP
を最大の素数として扱う。2007 年 11 月 1 日 には
MP
= 999983 (1000000 以下の最大の素数) が発表された。
宝くじの販売価格は 1 サブプライム。
宝くじの抽選では、当たりくじの番号
p
と賞金算出のための数
m
の組(
p
,
m
) が何組か選ばれる。
p
,
m
はそれぞれ0 以上
MP
以下の整数。
この国で知られている素数の中で
p
-
m
以上
p
+
m
以下のものが
X
個あるとすると、抽選結果(
p
,
m
) の賞金は、
X
プライムとなる。
抽選結果 (
p
,
m
) の賞金
X
プライムは番号
p
の宝くじを持っている当選者に支払われるが、
X
= 0 の場合もあり、この場合には当選者には賞金は支払われない。
賞金のうち 1 プライムは宝くじの売り上げから支出され、
X
- 1 プライムは王様の内廷費から支出される（王様が払ってくれる）。
X
= 0 ならば宝くじの売り上げから 1 プライムが内廷費に繰り入れられる。（王様に対し支払われる）
ひとつの番号
p
が複数の当たりくじになることもある。この場合にはそれぞれの抽選結果(
p
,
m
) から算出される賞金の合計が当選者に支払われる。
このくじでは当たりくじを買った人は抽選結果から関係する素数を探し、その個数を数えるので、国民の話題に素数がよく出てきて王様はとてもご満悦です。宝くじ振興公社としては当たりくじ1本当たり公社負担が 1 プライム、販売価格が 1 サブプライムだから、当たりくじの本数
n
を、販売した宝くじ 101 本あたり 1 本以下となるようにすれば (すなわち、
n
≤ (販売した本数)/101 とすれば) 赤字にはなりません。
問題は内廷費からの支出額です。あなたの仕事は、抽選結果を入力として、2007 年 11 月における宝くじ振興公社が王様に請求する賞金の額を出力するプログラムを作成することです。ただし、請求する賞金の額が負になることはないものとします。
注意
この国における素数の定義も日本の学校教育で学習する内容と同じです。即ち、素数とは 1 と自分自身以外の約数を持たない自然数をいいます（なお、1 は素数ではありません）。
我々は 1000003 が素数であることを知っていますが、この国では 2007 年 11 月段階では知られていません。そのため、999963 以上 1000003 以下の範囲にあるこの国で知られている素数は 999983 と 999979 の 2 個しかありません。
Input
複数のデータセットの並びが入力として与えられます。入力の終わりはゼロひとつの行で示されます。
各データセットは以下の形式で与えられます。
n
p
1
m
1
p
2
m
2
:
p
n
m
n
１行目に抽選結果の数
n
(1 ≤
n
≤ 1000000)、続く
n
行に
i
番目の抽選結果の情報
p
i
,
m
i
が空白区切りで与えられます。
データセットの数は 20 を超えません。
Output
データセットごとに王様への請求額をプライム単位（整数）で１行に出力します。
Sample Input
4
5 0
9 1
3 10
11 3
1
999983 20
0
Output for the Sample Input
5
1",Python,"def sieve_of_eratosthenes(limit):
    is_prime = [True] * (limit + 1)
    is_prime[0] = is_prime[1] = False
    
    for i in range(2, int(limit**0.5) + 1):
        if is_prime[i]:
            for j in range(i*i, limit + 1, i):
                is_prime[j] = False
    
    primes = [i for i in range(limit + 1) if is_prime[i]]
    return primes, is_prime

MP = 999983
primes, is_prime = sieve_of_eratosthenes(MP)

def binary_search_left(arr, target):
    left, right = 0, len(arr)
    while left < right:
        mid = (left + right) // 2
        if arr[mid] < target:
            left = mid + 1
        else:
            right = mid
    return left

def binary_search_right(arr, target):
    left, right = 0, len(arr)
    while left < right:
        mid = (left + right) // 2
        if arr[mid] <= target:
            left = mid + 1
        else:
            right = mid
    return left

def count_primes_in_range(low, high):
    left_idx = binary_search_left(primes, low)
    right_idx = binary_search_right(primes, high)
    return right_idx - left_idx

while True:
    n = int(input())
    if n == 0:
        break
    
    total_cost = 0
    for _ in range(n):
        p, m = map(int, input().split())
        low = max(0, p - m)
        high = min(MP, p + m)
        
        X = count_primes_in_range(low, high)
        
        if X > 0:
            total_cost += X - 1
        else:
            total_cost -= 1
    
    total_cost = max(0, total_cost)
    print(total_cost)
",0
p00165,"宝くじ
ある国の王様は素数とギャンブルが大好きです。この国の通貨の単位はプライムといいます。2007 年 11 月 1 日現在のプライムのクロス円レートは 9973 とちょうど素数になっていたので、王様は大喜びです。この国では 1/101 プライムを1サブプライムとする補助貨幣が使われています。
この国の政府は、国家財政の安定、国民の娯楽、王様の趣味を同時に満足させることを目的に宝くじ振興公社を設立し、宝くじ事業を始めることにしました。素数が大好きな王様は、素数が話題になればそれだけで満足して、賞金をあげたくなります。そこで振興公社は次のような宝くじを考えました。
くじには 0 から
MP
までの一連の番号がつけられている。
MP
はこの国で知られている最大の素数で、毎月一日に官報で告示される。同時に、
MP
以下のすべての素数も発表される。それ以上大きな素数が発見されても、その月の間は、宝くじ振興公社を含む全ての公的な機関では、一日に発表された
MP
を最大の素数として扱う。2007 年 11 月 1 日 には
MP
= 999983 (1000000 以下の最大の素数) が発表された。
宝くじの販売価格は 1 サブプライム。
宝くじの抽選では、当たりくじの番号
p
と賞金算出のための数
m
の組(
p
,
m
) が何組か選ばれる。
p
,
m
はそれぞれ0 以上
MP
以下の整数。
この国で知られている素数の中で
p
-
m
以上
p
+
m
以下のものが
X
個あるとすると、抽選結果(
p
,
m
) の賞金は、
X
プライムとなる。
抽選結果 (
p
,
m
) の賞金
X
プライムは番号
p
の宝くじを持っている当選者に支払われるが、
X
= 0 の場合もあり、この場合には当選者には賞金は支払われない。
賞金のうち 1 プライムは宝くじの売り上げから支出され、
X
- 1 プライムは王様の内廷費から支出される（王様が払ってくれる）。
X
= 0 ならば宝くじの売り上げから 1 プライムが内廷費に繰り入れられる。（王様に対し支払われる）
ひとつの番号
p
が複数の当たりくじになることもある。この場合にはそれぞれの抽選結果(
p
,
m
) から算出される賞金の合計が当選者に支払われる。
このくじでは当たりくじを買った人は抽選結果から関係する素数を探し、その個数を数えるので、国民の話題に素数がよく出てきて王様はとてもご満悦です。宝くじ振興公社としては当たりくじ1本当たり公社負担が 1 プライム、販売価格が 1 サブプライムだから、当たりくじの本数
n
を、販売した宝くじ 101 本あたり 1 本以下となるようにすれば (すなわち、
n
≤ (販売した本数)/101 とすれば) 赤字にはなりません。
問題は内廷費からの支出額です。あなたの仕事は、抽選結果を入力として、2007 年 11 月における宝くじ振興公社が王様に請求する賞金の額を出力するプログラムを作成することです。ただし、請求する賞金の額が負になることはないものとします。
注意
この国における素数の定義も日本の学校教育で学習する内容と同じです。即ち、素数とは 1 と自分自身以外の約数を持たない自然数をいいます（なお、1 は素数ではありません）。
我々は 1000003 が素数であることを知っていますが、この国では 2007 年 11 月段階では知られていません。そのため、999963 以上 1000003 以下の範囲にあるこの国で知られている素数は 999983 と 999979 の 2 個しかありません。
Input
複数のデータセットの並びが入力として与えられます。入力の終わりはゼロひとつの行で示されます。
各データセットは以下の形式で与えられます。
n
p
1
m
1
p
2
m
2
:
p
n
m
n
１行目に抽選結果の数
n
(1 ≤
n
≤ 1000000)、続く
n
行に
i
番目の抽選結果の情報
p
i
,
m
i
が空白区切りで与えられます。
データセットの数は 20 を超えません。
Output
データセットごとに王様への請求額をプライム単位（整数）で１行に出力します。
Sample Input
4
5 0
9 1
3 10
11 3
1
999983 20
0
Output for the Sample Input
5
1",Python,"import math
N=1000000
prime=[1]*(N+1)
prime[0]=0
prime[1]=0
for i in range(2,int(math.sqrt(N))):
    if prime[i]==1:
        j=i
        while i*j<=N:
            prime[i*j]=0
            j+=1
prime=[i for i in range(N+1) if prime[i]==1]

while True:
    n=input()
    if n==0:break
    cnt=0
    for i in range(n):
        p,m=map(int,raw_input().split())
        for j in range(len(prime)):
            if p-m<=prime[j]<=p+m:
                cnt+=1
            if p+m<=prime[j]:
                break
    print cnt-n",1
p00167,"バブルソート
データを並べ替えるための整列（ソート）アルゴリズムはコンピュータ科学には欠かせない基本的なアルゴリズムです。例えば、下図のように「整数値の配列の要素を昇順に並べ替える」という操作が整列です。
多くの整列アルゴリズムが考案されてきましたが、その中でも基本的なアルゴリズムの１つがバブルソートです。例として、与えられた整数値の配列をバブルソートで昇順に並べてみます。
バブルソートでは、各計算ステップにおいて、配列を「ソートされた部分」と「ソートされていない部分」に分けて考えます。最初は配列全体がソートされていない部分になります。
ソートされていない部分の先頭から、隣同士の要素を比較して（図では緑色の要素）、大きい値が右にくるようにそれらを交換します。二つの値が等しい場合は交換しません。
この処理をソートされていない部分（図では白色の要素）の末尾まで繰り返します。最後に、末尾をソートされている部分（図では青色の要素）に追加して1ステップが完了します。
このステップをソートされていない部分の長さが1になるまで繰り返します。
このようにソートされていない部分の長さが 1 になったら、ソートの処理を終了します。
それでは、
n
個の数値の配列を入力とし、数値が配列の先頭から昇順に並ぶように上記のバブルソートの手順で並べ替えを行い、要した配列要素の交換回数を出力するプログラムを作成してください。
Input
複数のデータセットの並びが入力として与えられます。入力の終わりはゼロひとつの行で示されます。
各データセットは以下の形式で与えられます。
n
a
1
a
2
:
a
n
１行目に数値の数
n
(1 ≤
n
≤ 100)、続く
n
行に
i
番目の数値
a
i
(1 ≤
a
i
≤ 1000000) が与えられます。
データセットの数は 20 を超えません。
Output
データセットごとにデータ要素の交換回数（整数）を１行に出力します。
Sample Input
5
5
3
2
1
4
6
1
2
3
4
5
6
3
3
2
1
0
Output for the Sample Input
7
0
3",C,"#include <stdio.h>

int main() {
    int n;
    
    while(1) {
        scanf(""%d"", &n);
        if(n == 0) break;
        
        int arr[100];
        for(int i = 0; i < n; i++) {
            scanf(""%d"", &arr[i]);
        }
        
        int swaps = 0;
        for(int i = 0; i < n - 1; i++) {
            for(int j = 0; j < n - 1 - i; j++) {
                if(arr[j] > arr[j + 1]) {
                    int temp = arr[j];
                    arr[j] = arr[j + 1];
                    arr[j + 1] = temp;
                    swaps++;
                }
            }
        }
        
        printf(""%d\n"", swaps);
    }
    
    return 0;
}
",0
p00167,"バブルソート
データを並べ替えるための整列（ソート）アルゴリズムはコンピュータ科学には欠かせない基本的なアルゴリズムです。例えば、下図のように「整数値の配列の要素を昇順に並べ替える」という操作が整列です。
多くの整列アルゴリズムが考案されてきましたが、その中でも基本的なアルゴリズムの１つがバブルソートです。例として、与えられた整数値の配列をバブルソートで昇順に並べてみます。
バブルソートでは、各計算ステップにおいて、配列を「ソートされた部分」と「ソートされていない部分」に分けて考えます。最初は配列全体がソートされていない部分になります。
ソートされていない部分の先頭から、隣同士の要素を比較して（図では緑色の要素）、大きい値が右にくるようにそれらを交換します。二つの値が等しい場合は交換しません。
この処理をソートされていない部分（図では白色の要素）の末尾まで繰り返します。最後に、末尾をソートされている部分（図では青色の要素）に追加して1ステップが完了します。
このステップをソートされていない部分の長さが1になるまで繰り返します。
このようにソートされていない部分の長さが 1 になったら、ソートの処理を終了します。
それでは、
n
個の数値の配列を入力とし、数値が配列の先頭から昇順に並ぶように上記のバブルソートの手順で並べ替えを行い、要した配列要素の交換回数を出力するプログラムを作成してください。
Input
複数のデータセットの並びが入力として与えられます。入力の終わりはゼロひとつの行で示されます。
各データセットは以下の形式で与えられます。
n
a
1
a
2
:
a
n
１行目に数値の数
n
(1 ≤
n
≤ 100)、続く
n
行に
i
番目の数値
a
i
(1 ≤
a
i
≤ 1000000) が与えられます。
データセットの数は 20 を超えません。
Output
データセットごとにデータ要素の交換回数（整数）を１行に出力します。
Sample Input
5
5
3
2
1
4
6
1
2
3
4
5
6
3
3
2
1
0
Output for the Sample Input
7
0
3",C,"#include <stdio.h>
int main(void) {
  int n, data[100], j, tmp, i, count;
  while(scanf(""%d"",&n),n) {
    count = 0;
    for(i = 0; i < n; i++ ) {
      scanf(""%d"",&data[i]);
    }
    for(i = 0; i < n - 1; i++ ) {
      for(j = 1; j < n - i; j++ ) {
	if(data[j] < data[j-1]) {
	  tmp = data[j];
	  data[j] = data[j-1];
	  data[j-1] = tmp;
	  count++;
	}
      }
    }
    printf(""%d\n"",count);
  }
  return 0;
}",1
p00167,"バブルソート
データを並べ替えるための整列（ソート）アルゴリズムはコンピュータ科学には欠かせない基本的なアルゴリズムです。例えば、下図のように「整数値の配列の要素を昇順に並べ替える」という操作が整列です。
多くの整列アルゴリズムが考案されてきましたが、その中でも基本的なアルゴリズムの１つがバブルソートです。例として、与えられた整数値の配列をバブルソートで昇順に並べてみます。
バブルソートでは、各計算ステップにおいて、配列を「ソートされた部分」と「ソートされていない部分」に分けて考えます。最初は配列全体がソートされていない部分になります。
ソートされていない部分の先頭から、隣同士の要素を比較して（図では緑色の要素）、大きい値が右にくるようにそれらを交換します。二つの値が等しい場合は交換しません。
この処理をソートされていない部分（図では白色の要素）の末尾まで繰り返します。最後に、末尾をソートされている部分（図では青色の要素）に追加して1ステップが完了します。
このステップをソートされていない部分の長さが1になるまで繰り返します。
このようにソートされていない部分の長さが 1 になったら、ソートの処理を終了します。
それでは、
n
個の数値の配列を入力とし、数値が配列の先頭から昇順に並ぶように上記のバブルソートの手順で並べ替えを行い、要した配列要素の交換回数を出力するプログラムを作成してください。
Input
複数のデータセットの並びが入力として与えられます。入力の終わりはゼロひとつの行で示されます。
各データセットは以下の形式で与えられます。
n
a
1
a
2
:
a
n
１行目に数値の数
n
(1 ≤
n
≤ 100)、続く
n
行に
i
番目の数値
a
i
(1 ≤
a
i
≤ 1000000) が与えられます。
データセットの数は 20 を超えません。
Output
データセットごとにデータ要素の交換回数（整数）を１行に出力します。
Sample Input
5
5
3
2
1
4
6
1
2
3
4
5
6
3
3
2
1
0
Output for the Sample Input
7
0
3",Java,"import java.util.Scanner;

public class Main {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        
        while (true) {
            int n = sc.nextInt();
            if (n == 0) break;
            
            int[] arr = new int[n];
            for (int i = 0; i < n; i++) {
                arr[i] = sc.nextInt();
            }
            
            int swapCount = bubbleSort(arr, n);
            System.out.println(swapCount);
        }
        
        sc.close();
    }
    
    static int bubbleSort(int[] arr, int n) {
        int count = 0;
        for (int i = 0; i < n - 1; i++) {
            for (int j = 0; j < n - 1 - i; j++) {
                if (arr[j] > arr[j + 1]) {
                    int temp = arr[j];
                    arr[j] = arr[j + 1];
                    arr[j + 1] = temp;
                    count++;
                }
            }
        }
        return count;
    }
}
",0
p00167,"バブルソート
データを並べ替えるための整列（ソート）アルゴリズムはコンピュータ科学には欠かせない基本的なアルゴリズムです。例えば、下図のように「整数値の配列の要素を昇順に並べ替える」という操作が整列です。
多くの整列アルゴリズムが考案されてきましたが、その中でも基本的なアルゴリズムの１つがバブルソートです。例として、与えられた整数値の配列をバブルソートで昇順に並べてみます。
バブルソートでは、各計算ステップにおいて、配列を「ソートされた部分」と「ソートされていない部分」に分けて考えます。最初は配列全体がソートされていない部分になります。
ソートされていない部分の先頭から、隣同士の要素を比較して（図では緑色の要素）、大きい値が右にくるようにそれらを交換します。二つの値が等しい場合は交換しません。
この処理をソートされていない部分（図では白色の要素）の末尾まで繰り返します。最後に、末尾をソートされている部分（図では青色の要素）に追加して1ステップが完了します。
このステップをソートされていない部分の長さが1になるまで繰り返します。
このようにソートされていない部分の長さが 1 になったら、ソートの処理を終了します。
それでは、
n
個の数値の配列を入力とし、数値が配列の先頭から昇順に並ぶように上記のバブルソートの手順で並べ替えを行い、要した配列要素の交換回数を出力するプログラムを作成してください。
Input
複数のデータセットの並びが入力として与えられます。入力の終わりはゼロひとつの行で示されます。
各データセットは以下の形式で与えられます。
n
a
1
a
2
:
a
n
１行目に数値の数
n
(1 ≤
n
≤ 100)、続く
n
行に
i
番目の数値
a
i
(1 ≤
a
i
≤ 1000000) が与えられます。
データセットの数は 20 を超えません。
Output
データセットごとにデータ要素の交換回数（整数）を１行に出力します。
Sample Input
5
5
3
2
1
4
6
1
2
3
4
5
6
3
3
2
1
0
Output for the Sample Input
7
0
3",Java,"import java.util.*;

public class Main{
	Scanner sc = new Scanner(System.in);
	
	private void doit(){
		while(true){
			int n = sc.nextInt();
			if(n == 0) break;
			int [] data = new int[n];
			for(int i = 0; i  <n; i++){
				data[i] = sc.nextInt();
			}
			int count = 0;
			for(;;){
				boolean flg = false;
				for(int j = 0; j < n-1; j++){
					if(data[j] > data[j + 1]){
						int temp = data[j];
						data[j] = data[j+1];
						data[j+1] = temp;
						count++;
						flg = true;
					}
				}
				if(! flg){
					break;
				}
			}
			System.out.println(count);
		}
	}

	private void debug(Object... o) { System.out.println(""debug = "" + Arrays.deepToString(o)); }

	public static void main(String[] args) {
		new Main().doit();
	}
}",1
p00167,"バブルソート
データを並べ替えるための整列（ソート）アルゴリズムはコンピュータ科学には欠かせない基本的なアルゴリズムです。例えば、下図のように「整数値の配列の要素を昇順に並べ替える」という操作が整列です。
多くの整列アルゴリズムが考案されてきましたが、その中でも基本的なアルゴリズムの１つがバブルソートです。例として、与えられた整数値の配列をバブルソートで昇順に並べてみます。
バブルソートでは、各計算ステップにおいて、配列を「ソートされた部分」と「ソートされていない部分」に分けて考えます。最初は配列全体がソートされていない部分になります。
ソートされていない部分の先頭から、隣同士の要素を比較して（図では緑色の要素）、大きい値が右にくるようにそれらを交換します。二つの値が等しい場合は交換しません。
この処理をソートされていない部分（図では白色の要素）の末尾まで繰り返します。最後に、末尾をソートされている部分（図では青色の要素）に追加して1ステップが完了します。
このステップをソートされていない部分の長さが1になるまで繰り返します。
このようにソートされていない部分の長さが 1 になったら、ソートの処理を終了します。
それでは、
n
個の数値の配列を入力とし、数値が配列の先頭から昇順に並ぶように上記のバブルソートの手順で並べ替えを行い、要した配列要素の交換回数を出力するプログラムを作成してください。
Input
複数のデータセットの並びが入力として与えられます。入力の終わりはゼロひとつの行で示されます。
各データセットは以下の形式で与えられます。
n
a
1
a
2
:
a
n
１行目に数値の数
n
(1 ≤
n
≤ 100)、続く
n
行に
i
番目の数値
a
i
(1 ≤
a
i
≤ 1000000) が与えられます。
データセットの数は 20 を超えません。
Output
データセットごとにデータ要素の交換回数（整数）を１行に出力します。
Sample Input
5
5
3
2
1
4
6
1
2
3
4
5
6
3
3
2
1
0
Output for the Sample Input
7
0
3",Python,"while True:
    n = int(input())
    if n == 0:
        break
    
    arr = []
    for _ in range(n):
        arr.append(int(input()))
    
    count = 0
    for i in range(n - 1):
        for j in range(n - 1 - i):
            if arr[j] > arr[j + 1]:
                arr[j], arr[j + 1] = arr[j + 1], arr[j]
                count += 1
    
    print(count)
",0
p00167,"バブルソート
データを並べ替えるための整列（ソート）アルゴリズムはコンピュータ科学には欠かせない基本的なアルゴリズムです。例えば、下図のように「整数値の配列の要素を昇順に並べ替える」という操作が整列です。
多くの整列アルゴリズムが考案されてきましたが、その中でも基本的なアルゴリズムの１つがバブルソートです。例として、与えられた整数値の配列をバブルソートで昇順に並べてみます。
バブルソートでは、各計算ステップにおいて、配列を「ソートされた部分」と「ソートされていない部分」に分けて考えます。最初は配列全体がソートされていない部分になります。
ソートされていない部分の先頭から、隣同士の要素を比較して（図では緑色の要素）、大きい値が右にくるようにそれらを交換します。二つの値が等しい場合は交換しません。
この処理をソートされていない部分（図では白色の要素）の末尾まで繰り返します。最後に、末尾をソートされている部分（図では青色の要素）に追加して1ステップが完了します。
このステップをソートされていない部分の長さが1になるまで繰り返します。
このようにソートされていない部分の長さが 1 になったら、ソートの処理を終了します。
それでは、
n
個の数値の配列を入力とし、数値が配列の先頭から昇順に並ぶように上記のバブルソートの手順で並べ替えを行い、要した配列要素の交換回数を出力するプログラムを作成してください。
Input
複数のデータセットの並びが入力として与えられます。入力の終わりはゼロひとつの行で示されます。
各データセットは以下の形式で与えられます。
n
a
1
a
2
:
a
n
１行目に数値の数
n
(1 ≤
n
≤ 100)、続く
n
行に
i
番目の数値
a
i
(1 ≤
a
i
≤ 1000000) が与えられます。
データセットの数は 20 を超えません。
Output
データセットごとにデータ要素の交換回数（整数）を１行に出力します。
Sample Input
5
5
3
2
1
4
6
1
2
3
4
5
6
3
3
2
1
0
Output for the Sample Input
7
0
3",Python,"while True:
    n = int(input())
    if n == 0:
        break
    Num_lis = []
    cou = 0
    for i in range(n):
        Num_lis.append(int(input()))
    S_lis = sorted(Num_lis)
    while Num_lis != S_lis:
        
        for j in range(n - 1):
            if Num_lis[j] > Num_lis[j + 1]:
                Num_lis[j],Num_lis[j + 1] = Num_lis[j + 1],Num_lis[j]
                cou += 1
    print(cou)",1
p00168,"観音堂
一郎君の家の裏山には観音堂があります。この観音堂まではふもとから 30 段の階段があり、一郎君は、毎日のように観音堂まで遊びに行きます。一郎君は階段を１足で３段まで上がることができます。遊んでいるうちに階段の上り方の種類（段の飛ばし方の個数）が非常にたくさんあることに気がつきました。
そこで、一日に 10 種類の上り方をし、すべての上り方を試そうと考えました。しかし数学を熟知しているあなたはそんなことでは一郎君の寿命が尽きてしまうことを知っているはずです。
一郎君の計画が実現不可能であることを一郎君に納得させるために、階段の段数
n
を入力とし、一日に 10 種類の上り方をするとして、一郎君がすべての上り方を実行するのに要する年数を出力するプログラムを作成してください。一年は 365 日として計算してください。一日でも必要なら一年とします。365 日なら 1 年であり、366 日なら 2 年となります。
Input
複数のデータセットの並びが入力として与えられます。入力の終わりはゼロひとつの行で示されます。
各データセットとして、段数を表す１つの整数
n
(1 ≤
n
≤ 30) が１行に与えられます。
データセットの数は 30 を超えません。
Output
データセットごとに一郎君がすべての上り方を実行するのに必要な年数（整数）を１行に出力します。
Sample Input
1
10
20
25
0
Output for the Sample Input
1
1
34
701",C,"#include <stdio.h>

int main() {
    int n;
    long long dp[31];
    
    // Calculate number of ways to climb stairs for each n
    dp[0] = 1;
    dp[1] = 1;
    dp[2] = 2;
    
    for (int i = 3; i <= 30; i++) {
        dp[i] = dp[i-1] + dp[i-2] + dp[i-3];
    }
    
    while (scanf(""%d"", &n) == 1 && n != 0) {
        long long ways = dp[n];
        long long days = (ways + 9) / 10;  // Round up division
        long long years = (days + 364) / 365;  // Round up division
        printf(""%lld\n"", years);
    }
    
    return 0;
}
",0
p00168,"観音堂
一郎君の家の裏山には観音堂があります。この観音堂まではふもとから 30 段の階段があり、一郎君は、毎日のように観音堂まで遊びに行きます。一郎君は階段を１足で３段まで上がることができます。遊んでいるうちに階段の上り方の種類（段の飛ばし方の個数）が非常にたくさんあることに気がつきました。
そこで、一日に 10 種類の上り方をし、すべての上り方を試そうと考えました。しかし数学を熟知しているあなたはそんなことでは一郎君の寿命が尽きてしまうことを知っているはずです。
一郎君の計画が実現不可能であることを一郎君に納得させるために、階段の段数
n
を入力とし、一日に 10 種類の上り方をするとして、一郎君がすべての上り方を実行するのに要する年数を出力するプログラムを作成してください。一年は 365 日として計算してください。一日でも必要なら一年とします。365 日なら 1 年であり、366 日なら 2 年となります。
Input
複数のデータセットの並びが入力として与えられます。入力の終わりはゼロひとつの行で示されます。
各データセットとして、段数を表す１つの整数
n
(1 ≤
n
≤ 30) が１行に与えられます。
データセットの数は 30 を超えません。
Output
データセットごとに一郎君がすべての上り方を実行するのに必要な年数（整数）を１行に出力します。
Sample Input
1
10
20
25
0
Output for the Sample Input
1
1
34
701",C,"#include <stdio.h>

int main(){
  int n, p[31] = {}, i, res;
  p[0] = 1;
  p[1] = 1;
  p[2] = 2;


  while(scanf(""%d"", &n) && n){
    for(i = 3; i <= n; i++) p[i] = p[i - 1] + p[i - 2] + p[i - 3];
    res = p[n] / 10 / 365 + 1;
    printf(""%d\n"", res);
  }
  return 0;
}",1
p00168,"観音堂
一郎君の家の裏山には観音堂があります。この観音堂まではふもとから 30 段の階段があり、一郎君は、毎日のように観音堂まで遊びに行きます。一郎君は階段を１足で３段まで上がることができます。遊んでいるうちに階段の上り方の種類（段の飛ばし方の個数）が非常にたくさんあることに気がつきました。
そこで、一日に 10 種類の上り方をし、すべての上り方を試そうと考えました。しかし数学を熟知しているあなたはそんなことでは一郎君の寿命が尽きてしまうことを知っているはずです。
一郎君の計画が実現不可能であることを一郎君に納得させるために、階段の段数
n
を入力とし、一日に 10 種類の上り方をするとして、一郎君がすべての上り方を実行するのに要する年数を出力するプログラムを作成してください。一年は 365 日として計算してください。一日でも必要なら一年とします。365 日なら 1 年であり、366 日なら 2 年となります。
Input
複数のデータセットの並びが入力として与えられます。入力の終わりはゼロひとつの行で示されます。
各データセットとして、段数を表す１つの整数
n
(1 ≤
n
≤ 30) が１行に与えられます。
データセットの数は 30 を超えません。
Output
データセットごとに一郎君がすべての上り方を実行するのに必要な年数（整数）を１行に出力します。
Sample Input
1
10
20
25
0
Output for the Sample Input
1
1
34
701",Java,"import java.util.*;

public class Main {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        
        long[] ways = new long[31];
        ways[0] = 1;
        
        for (int i = 1; i <= 30; i++) {
            ways[i] = 0;
            if (i >= 1) ways[i] += ways[i-1];
            if (i >= 2) ways[i] += ways[i-2];
            if (i >= 3) ways[i] += ways[i-3];
        }
        
        while (true) {
            int n = sc.nextInt();
            if (n == 0) break;
            
            long totalWays = ways[n];
            long days = (totalWays + 9) / 10;
            long years = (days + 364) / 365;
            
            System.out.println(years);
        }
        
        sc.close();
    }
}
",0
p00168,"観音堂
一郎君の家の裏山には観音堂があります。この観音堂まではふもとから 30 段の階段があり、一郎君は、毎日のように観音堂まで遊びに行きます。一郎君は階段を１足で３段まで上がることができます。遊んでいるうちに階段の上り方の種類（段の飛ばし方の個数）が非常にたくさんあることに気がつきました。
そこで、一日に 10 種類の上り方をし、すべての上り方を試そうと考えました。しかし数学を熟知しているあなたはそんなことでは一郎君の寿命が尽きてしまうことを知っているはずです。
一郎君の計画が実現不可能であることを一郎君に納得させるために、階段の段数
n
を入力とし、一日に 10 種類の上り方をするとして、一郎君がすべての上り方を実行するのに要する年数を出力するプログラムを作成してください。一年は 365 日として計算してください。一日でも必要なら一年とします。365 日なら 1 年であり、366 日なら 2 年となります。
Input
複数のデータセットの並びが入力として与えられます。入力の終わりはゼロひとつの行で示されます。
各データセットとして、段数を表す１つの整数
n
(1 ≤
n
≤ 30) が１行に与えられます。
データセットの数は 30 を超えません。
Output
データセットごとに一郎君がすべての上り方を実行するのに必要な年数（整数）を１行に出力します。
Sample Input
1
10
20
25
0
Output for the Sample Input
1
1
34
701",Java,"import java.util.*;class Main{public static void main(String[]z){Scanner s=new Scanner(System.in);for(int n,i,j,a[];(n=s.nextInt())>0;System.out.println(a[n]/3650+1))for(a=new int[n+3],a[1]=a[2]=a[3]=1,i=0;i<n;++i)for(j=4;j-->1;)a[i+j]+=a[i];}}",1
p00168,"観音堂
一郎君の家の裏山には観音堂があります。この観音堂まではふもとから 30 段の階段があり、一郎君は、毎日のように観音堂まで遊びに行きます。一郎君は階段を１足で３段まで上がることができます。遊んでいるうちに階段の上り方の種類（段の飛ばし方の個数）が非常にたくさんあることに気がつきました。
そこで、一日に 10 種類の上り方をし、すべての上り方を試そうと考えました。しかし数学を熟知しているあなたはそんなことでは一郎君の寿命が尽きてしまうことを知っているはずです。
一郎君の計画が実現不可能であることを一郎君に納得させるために、階段の段数
n
を入力とし、一日に 10 種類の上り方をするとして、一郎君がすべての上り方を実行するのに要する年数を出力するプログラムを作成してください。一年は 365 日として計算してください。一日でも必要なら一年とします。365 日なら 1 年であり、366 日なら 2 年となります。
Input
複数のデータセットの並びが入力として与えられます。入力の終わりはゼロひとつの行で示されます。
各データセットとして、段数を表す１つの整数
n
(1 ≤
n
≤ 30) が１行に与えられます。
データセットの数は 30 を超えません。
Output
データセットごとに一郎君がすべての上り方を実行するのに必要な年数（整数）を１行に出力します。
Sample Input
1
10
20
25
0
Output for the Sample Input
1
1
34
701",Python,"import sys

def count_ways(n):
    if n == 0:
        return 1
    if n < 0:
        return 0
    
    dp = [0] * (n + 1)
    dp[0] = 1
    
    for i in range(1, n + 1):
        dp[i] = dp[i-1]
        if i >= 2:
            dp[i] += dp[i-2]
        if i >= 3:
            dp[i] += dp[i-3]
    
    return dp[n]

def calculate_years(n):
    ways = count_ways(n)
    days = (ways + 9) // 10
    years = (days + 364) // 365
    return years

for line in sys.stdin:
    n = int(line.strip())
    if n == 0:
        break
    print(calculate_years(n))
",0
p00168,"観音堂
一郎君の家の裏山には観音堂があります。この観音堂まではふもとから 30 段の階段があり、一郎君は、毎日のように観音堂まで遊びに行きます。一郎君は階段を１足で３段まで上がることができます。遊んでいるうちに階段の上り方の種類（段の飛ばし方の個数）が非常にたくさんあることに気がつきました。
そこで、一日に 10 種類の上り方をし、すべての上り方を試そうと考えました。しかし数学を熟知しているあなたはそんなことでは一郎君の寿命が尽きてしまうことを知っているはずです。
一郎君の計画が実現不可能であることを一郎君に納得させるために、階段の段数
n
を入力とし、一日に 10 種類の上り方をするとして、一郎君がすべての上り方を実行するのに要する年数を出力するプログラムを作成してください。一年は 365 日として計算してください。一日でも必要なら一年とします。365 日なら 1 年であり、366 日なら 2 年となります。
Input
複数のデータセットの並びが入力として与えられます。入力の終わりはゼロひとつの行で示されます。
各データセットとして、段数を表す１つの整数
n
(1 ≤
n
≤ 30) が１行に与えられます。
データセットの数は 30 を超えません。
Output
データセットごとに一郎君がすべての上り方を実行するのに必要な年数（整数）を１行に出力します。
Sample Input
1
10
20
25
0
Output for the Sample Input
1
1
34
701",Python,"a = []
a[:4] = [0, 1, 2, 3]
inList = []
while True:
    price = int(input())
    if price == 0:
        break
    inList.append(int(input()))
n = max(inList)
for i in range(4, n + 1):
    a[i] = a[i-1] + a[i-2] + a[i-3]
for i in inList:
    print((a[i] // 3650) + (a[i] % 3650 != 0))",1
p00169,"ブラックジャック
ブラックジャックはカジノで行われるカードゲームの一種で、1 〜 13  までの数が書かれたカードを使ってゲームが行われます。各カードの点数は次のように決まっています。
1 は 1 点あるいは 11 点
2 から 9 までは、書かれている数の通りの点数
10 から 13 までは、10 点
このゲームには親を含めた何人かの参加者がおり、それぞれが何枚かのカードの組を持っています。このカードの組のことを手と呼びます。手の点数はカードの点数の合計です。その計算は次のように行うものとします。
カードの点数の合計が 21 より大きくなるときは、手の点数を 0 点とする
カードの点数として、1 は 1 点と計算しても 11 点と計算してもよいが、手の点数が最大となる方を選ぶこととする
配られたカードの情報を入力とし、手の点数を出力するプログラムを作成してください。
Input
複数のデータセットの並びが入力として与えられます。入力の終わりはゼロひとつの行で示されます。
各データセットは以下の形式で与えられます。
c
1
c
2
...
c
n
１行に
i
番目のカードに書かれている整数
c
i
(1 ≤
c
i
≤ 13) が空白区切りで１行に与えられます。カードの数
n
は 100  を超えません。
データセットの数は 200 を超えません。
Output
データセットごとに手の点数を１行に出力します。
Sample Input
1
7 7 7
7 7 8
12 1
10 1 1
0
Output for the Sample Input
11
21
0
21
12",C,"#include <stdio.h>

int main() {
    int card;
    
    while (1) {
        scanf(""%d"", &card);
        if (card == 0) break;
        
        int sum = 0;
        int aces = 0;
        
        do {
            if (card == 1) {
                sum += 1;
                aces++;
            } else if (card >= 2 && card <= 9) {
                sum += card;
            } else if (card >= 10 && card <= 13) {
                sum += 10;
            }
            
            int c = getchar();
            if (c == '\n' || c == EOF) break;
            scanf(""%d"", &card);
        } while (1);
        
        // Try to maximize score by using 11 for aces
        while (aces > 0 && sum + 10 <= 21) {
            sum += 10;
            aces--;
        }
        
        if (sum > 21) {
            sum = 0;
        }
        
        printf(""%d\n"", sum);
    }
    
    return 0;
}
",0
p00169,"ブラックジャック
ブラックジャックはカジノで行われるカードゲームの一種で、1 〜 13  までの数が書かれたカードを使ってゲームが行われます。各カードの点数は次のように決まっています。
1 は 1 点あるいは 11 点
2 から 9 までは、書かれている数の通りの点数
10 から 13 までは、10 点
このゲームには親を含めた何人かの参加者がおり、それぞれが何枚かのカードの組を持っています。このカードの組のことを手と呼びます。手の点数はカードの点数の合計です。その計算は次のように行うものとします。
カードの点数の合計が 21 より大きくなるときは、手の点数を 0 点とする
カードの点数として、1 は 1 点と計算しても 11 点と計算してもよいが、手の点数が最大となる方を選ぶこととする
配られたカードの情報を入力とし、手の点数を出力するプログラムを作成してください。
Input
複数のデータセットの並びが入力として与えられます。入力の終わりはゼロひとつの行で示されます。
各データセットは以下の形式で与えられます。
c
1
c
2
...
c
n
１行に
i
番目のカードに書かれている整数
c
i
(1 ≤
c
i
≤ 13) が空白区切りで１行に与えられます。カードの数
n
は 100  を超えません。
データセットの数は 200 を超えません。
Output
データセットごとに手の点数を１行に出力します。
Sample Input
1
7 7 7
7 7 8
12 1
10 1 1
0
Output for the Sample Input
11
21
0
21
12",C,"#include<stdio.h>
#include<stdlib.h>
#include<string.h>
int main(){
  int i;
  int c[128],m,n;
  char s[256],*t;  
  for(;;){
    fgets(s,256,stdin);
    s[strlen(s)-1]='\0';
    t=strtok(s,"" "");
    c[0]=atoi(t)<10?atoi(t):10;
    if(c[0]==0)
      break;
    for(n=1;(t=strtok(NULL,"" ""))!=NULL;n++)
      c[n]=atoi(t)<10?atoi(t):10;
    m=0;
    for(i=0;i<n;i++)
      m+=c[i];
    for(i=0;i<n;i++){
      if(m<12&&c[i]==1)
	m+=10;
    }
    if(m>21)
      m=0;
    printf(""%d\n"",m);
  }
  return 0;
}",1
p00169,"ブラックジャック
ブラックジャックはカジノで行われるカードゲームの一種で、1 〜 13  までの数が書かれたカードを使ってゲームが行われます。各カードの点数は次のように決まっています。
1 は 1 点あるいは 11 点
2 から 9 までは、書かれている数の通りの点数
10 から 13 までは、10 点
このゲームには親を含めた何人かの参加者がおり、それぞれが何枚かのカードの組を持っています。このカードの組のことを手と呼びます。手の点数はカードの点数の合計です。その計算は次のように行うものとします。
カードの点数の合計が 21 より大きくなるときは、手の点数を 0 点とする
カードの点数として、1 は 1 点と計算しても 11 点と計算してもよいが、手の点数が最大となる方を選ぶこととする
配られたカードの情報を入力とし、手の点数を出力するプログラムを作成してください。
Input
複数のデータセットの並びが入力として与えられます。入力の終わりはゼロひとつの行で示されます。
各データセットは以下の形式で与えられます。
c
1
c
2
...
c
n
１行に
i
番目のカードに書かれている整数
c
i
(1 ≤
c
i
≤ 13) が空白区切りで１行に与えられます。カードの数
n
は 100  を超えません。
データセットの数は 200 を超えません。
Output
データセットごとに手の点数を１行に出力します。
Sample Input
1
7 7 7
7 7 8
12 1
10 1 1
0
Output for the Sample Input
11
21
0
21
12",Java,"import java.util.Scanner;

public class Main {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        
        while (true) {
            String line = sc.nextLine().trim();
            if (line.equals(""0"")) {
                break;
            }
            
            String[] tokens = line.split(""\\s+"");
            int[] cards = new int[tokens.length];
            for (int i = 0; i < tokens.length; i++) {
                cards[i] = Integer.parseInt(tokens[i]);
            }
            
            int result = calculateScore(cards);
            System.out.println(result);
        }
        
        sc.close();
    }
    
    private static int calculateScore(int[] cards) {
        int baseSum = 0;
        int aceCount = 0;
        
        for (int card : cards) {
            if (card == 1) {
                aceCount++;
                baseSum += 1;
            } else if (card >= 10) {
                baseSum += 10;
            } else {
                baseSum += card;
            }
        }
        
        // Try to maximize the score by using aces as 11
        int maxScore = baseSum;
        for (int i = 0; i <= aceCount; i++) {
            int score = baseSum + i * 10; // Each ace used as 11 adds 10 more (since base is 1)
            if (score <= 21) {
                maxScore = Math.max(maxScore, score);
            }
        }
        
        if (maxScore > 21) {
            return 0;
        }
        
        return maxScore;
    }
}
",0
p00169,"ブラックジャック
ブラックジャックはカジノで行われるカードゲームの一種で、1 〜 13  までの数が書かれたカードを使ってゲームが行われます。各カードの点数は次のように決まっています。
1 は 1 点あるいは 11 点
2 から 9 までは、書かれている数の通りの点数
10 から 13 までは、10 点
このゲームには親を含めた何人かの参加者がおり、それぞれが何枚かのカードの組を持っています。このカードの組のことを手と呼びます。手の点数はカードの点数の合計です。その計算は次のように行うものとします。
カードの点数の合計が 21 より大きくなるときは、手の点数を 0 点とする
カードの点数として、1 は 1 点と計算しても 11 点と計算してもよいが、手の点数が最大となる方を選ぶこととする
配られたカードの情報を入力とし、手の点数を出力するプログラムを作成してください。
Input
複数のデータセットの並びが入力として与えられます。入力の終わりはゼロひとつの行で示されます。
各データセットは以下の形式で与えられます。
c
1
c
2
...
c
n
１行に
i
番目のカードに書かれている整数
c
i
(1 ≤
c
i
≤ 13) が空白区切りで１行に与えられます。カードの数
n
は 100  を超えません。
データセットの数は 200 を超えません。
Output
データセットごとに手の点数を１行に出力します。
Sample Input
1
7 7 7
7 7 8
12 1
10 1 1
0
Output for the Sample Input
11
21
0
21
12",Java,"import java.util.Scanner;

public class Main {
	static Scanner sc = new Scanner(System.in);

	public static void main(String[] args) {
		while(sc.hasNext()) {
			String[] text = sc.nextLine().split("" "");
			int[] cards = new int[text.length];
			boolean one = false; //1????????????
			int sum = 0; //????¨??????°
			boolean flag = false;

			for(int $ = 0; $ < text.length; $++) {
				cards[$] = Integer.parseInt(text[$]);
				if(cards[0] == 0) {
					flag = true;
					break;
				}
				if(cards[$] == 1) {
					one = true;
					sum++;
				} else if(cards[$] >= 10 && cards[$] <=13) {
					sum += 10;
				} else {
					sum += cards[$];
				}
			}

			if(flag) {
				break;
			}

			if(one) {
				if(sum + 10 <= 21) {
					sum += 10;
				}
			}

			if(sum > 21) {
				sum = 0;
			}

			System.out.println(sum);

		}

	}

}",1
p00169,"ブラックジャック
ブラックジャックはカジノで行われるカードゲームの一種で、1 〜 13  までの数が書かれたカードを使ってゲームが行われます。各カードの点数は次のように決まっています。
1 は 1 点あるいは 11 点
2 から 9 までは、書かれている数の通りの点数
10 から 13 までは、10 点
このゲームには親を含めた何人かの参加者がおり、それぞれが何枚かのカードの組を持っています。このカードの組のことを手と呼びます。手の点数はカードの点数の合計です。その計算は次のように行うものとします。
カードの点数の合計が 21 より大きくなるときは、手の点数を 0 点とする
カードの点数として、1 は 1 点と計算しても 11 点と計算してもよいが、手の点数が最大となる方を選ぶこととする
配られたカードの情報を入力とし、手の点数を出力するプログラムを作成してください。
Input
複数のデータセットの並びが入力として与えられます。入力の終わりはゼロひとつの行で示されます。
各データセットは以下の形式で与えられます。
c
1
c
2
...
c
n
１行に
i
番目のカードに書かれている整数
c
i
(1 ≤
c
i
≤ 13) が空白区切りで１行に与えられます。カードの数
n
は 100  を超えません。
データセットの数は 200 を超えません。
Output
データセットごとに手の点数を１行に出力します。
Sample Input
1
7 7 7
7 7 8
12 1
10 1 1
0
Output for the Sample Input
11
21
0
21
12",Python,"import sys

def calculate_hand_value(cards):
    # Convert card values
    converted = []
    ace_count = 0
    
    for card in cards:
        if card == 1:
            ace_count += 1
            converted.append(1)
        elif card >= 10:
            converted.append(10)
        else:
            converted.append(card)
    
    # Calculate base sum (all aces as 1)
    base_sum = sum(converted)
    
    # Try to maximize by converting aces from 1 to 11
    max_value = base_sum
    
    # We can convert at most one ace from 1 to 11 (adding 10 to the sum)
    # because converting more than one would add 20+ which would likely bust
    for i in range(ace_count + 1):
        # i is the number of aces we treat as 11
        current_sum = base_sum + (i * 10)
        if current_sum <= 21:
            max_value = max(max_value, current_sum)
    
    if max_value > 21:
        return 0
    return max_value

for line in sys.stdin:
    line = line.strip()
    if line == '0':
        break
    
    cards = list(map(int, line.split()))
    result = calculate_hand_value(cards)
    print(result)
",0
p00169,"ブラックジャック
ブラックジャックはカジノで行われるカードゲームの一種で、1 〜 13  までの数が書かれたカードを使ってゲームが行われます。各カードの点数は次のように決まっています。
1 は 1 点あるいは 11 点
2 から 9 までは、書かれている数の通りの点数
10 から 13 までは、10 点
このゲームには親を含めた何人かの参加者がおり、それぞれが何枚かのカードの組を持っています。このカードの組のことを手と呼びます。手の点数はカードの点数の合計です。その計算は次のように行うものとします。
カードの点数の合計が 21 より大きくなるときは、手の点数を 0 点とする
カードの点数として、1 は 1 点と計算しても 11 点と計算してもよいが、手の点数が最大となる方を選ぶこととする
配られたカードの情報を入力とし、手の点数を出力するプログラムを作成してください。
Input
複数のデータセットの並びが入力として与えられます。入力の終わりはゼロひとつの行で示されます。
各データセットは以下の形式で与えられます。
c
1
c
2
...
c
n
１行に
i
番目のカードに書かれている整数
c
i
(1 ≤
c
i
≤ 13) が空白区切りで１行に与えられます。カードの数
n
は 100  を超えません。
データセットの数は 200 を超えません。
Output
データセットごとに手の点数を１行に出力します。
Sample Input
1
7 7 7
7 7 8
12 1
10 1 1
0
Output for the Sample Input
11
21
0
21
12",Python,"while True:
    h = map(int, raw_input().split())
    if h[0] == 0:
        break
    t = 0
    a = 0
    for c in sorted(h, reverse=True):
        if 2 <= c <= 9:
            t += c
        elif 10 <= c:
            t += 10
        elif c == 1:
            a += 1
            
    t += a
    if 21 < t:
        print 0
    else:
        for i in range(a):
            if 21 < t + 10:
                print t
                break
            else:
                t += 10
        else:
            print t",1
p00170,"ランチ
お昼に食べるお弁当を作るために、お店で食べ物を買いました。お店では、食べ物を入れるのに細長い袋しかもらえなかったので、すべての食べ物を縦に積んで袋に入れる必要があります。袋が倒れにくいように、できるだけ重い物を下にして詰めたいのですが、食べ物の中にはやわらかい物もあって、上に重い物を乗せるとつぶれてしまいます。
そこで、食べ物の情報を入力とし、全ての食べ物がつぶれず、かつ全体の重心が最も低くなるような積み方を出力するプログラムを作成してください。それぞれの食べ物ごとに、名前
f
、重さ
w
、上に載せて耐えられる重さ
s
が指定されます。
「全ての食べ物がつぶれない」というのは、下から順に、（
f
1
、
f
2
、... 、
f
n
）と
n
個の食べ物を積んだ時、すべての
f
について、
s
f
i
≥ w
f
i+1
+ w
f
i+2
+
...
+ w
f
n
であることを意味します。また、全体の重心
G
は、
G = (1 × w
f
1
+ 2 × w
f
2
+
...
+ n × w
f
n
)
/
(w
f
1
+ w
f
2
+
...
+w
f
n
)
とします。ただし、解はちょうど1つだけ存在するものとします。
Input
複数のデータセットの並びが入力として与えられます。入力の終わりはゼロひとつの行で示されます。各データセットは以下の形式で与えられます。
n
f
1
w
1
s
1
f
2
w
2
s
2
:
f
n
w
n
s
n
１行目に食べ物の個数
n
(1 ≤
n
≤ 10)、続く
n
行に
i
番目の食べ物の名前
f
i
(20 文字以内の半角英文字列)、重さ
w
i
(1 ≤
w
i
≤ 1000)、耐えられる重さ
s
i
(1 ≤
s
i
≤ 1000) が空白区切りで与えられます。
データセットの数は 20 を超えません。
Output
データセットごとに、次の形式で食べ物の名前を下から積み上げる順に出力します。
1 行目: 1 番下の食べ物の名前（半角英文字列）
2 行目: 下から2 番目の食べ物の名前
：
n
行目: 1 番上の食べ物の名前
Sample Input
4
sandwich 80 120
apple 50 200
cheese 20 40
cake 100 100
9
onigiri 80 300
onigiri 80 300
anpan 70 280
mikan 50 80
kanzume 100 500
chocolate 50 350
cookie 30 80
purin 40 400
cracker 40 160
0
Output for the Sample Input
apple
cake
sandwich
cheese
kanzume
purin
chocolate
onigiri
onigiri
anpan
mikan
cracker
cookie",C,"#include <stdio.h>
#include <string.h>

typedef struct {
    char name[25];
    int weight;
    int strength;
    int index;
} Food;

int n;
Food foods[10];
Food current[10];
Food best[10];
int visited[10];
double best_center;

int check_valid() {
    for (int i = 0; i < n; i++) {
        int weight_above = 0;
        for (int j = i + 1; j < n; j++) {
            weight_above += current[j].weight;
        }
        if (current[i].strength < weight_above) {
            return 0;
        }
    }
    return 1;
}

double calculate_center() {
    int numerator = 0;
    int denominator = 0;
    for (int i = 0; i < n; i++) {
        numerator += (i + 1) * current[i].weight;
        denominator += current[i].weight;
    }
    return (double)numerator / denominator;
}

void solve(int depth) {
    if (depth == n) {
        if (check_valid()) {
            double center = calculate_center();
            if (center < best_center) {
                best_center = center;
                for (int i = 0; i < n; i++) {
                    best[i] = current[i];
                }
            }
        }
        return;
    }
    
    for (int i = 0; i < n; i++) {
        if (!visited[i]) {
            visited[i] = 1;
            current[depth] = foods[i];
            solve(depth + 1);
            visited[i] = 0;
        }
    }
}

int main() {
    while (1) {
        scanf(""%d"", &n);
        if (n == 0) break;
        
        for (int i = 0; i < n; i++) {
            scanf(""%s %d %d"", foods[i].name, &foods[i].weight, &foods[i].strength);
            foods[i].index = i;
        }
        
        best_center = 1e9;
        memset(visited, 0, sizeof(visited));
        
        solve(0);
        
        for (int i = 0; i < n; i++) {
            printf(""%s\n"", best[i].name);
        }
    }
    
    return 0;
}
",0
p00170,"ランチ
お昼に食べるお弁当を作るために、お店で食べ物を買いました。お店では、食べ物を入れるのに細長い袋しかもらえなかったので、すべての食べ物を縦に積んで袋に入れる必要があります。袋が倒れにくいように、できるだけ重い物を下にして詰めたいのですが、食べ物の中にはやわらかい物もあって、上に重い物を乗せるとつぶれてしまいます。
そこで、食べ物の情報を入力とし、全ての食べ物がつぶれず、かつ全体の重心が最も低くなるような積み方を出力するプログラムを作成してください。それぞれの食べ物ごとに、名前
f
、重さ
w
、上に載せて耐えられる重さ
s
が指定されます。
「全ての食べ物がつぶれない」というのは、下から順に、（
f
1
、
f
2
、... 、
f
n
）と
n
個の食べ物を積んだ時、すべての
f
について、
s
f
i
≥ w
f
i+1
+ w
f
i+2
+
...
+ w
f
n
であることを意味します。また、全体の重心
G
は、
G = (1 × w
f
1
+ 2 × w
f
2
+
...
+ n × w
f
n
)
/
(w
f
1
+ w
f
2
+
...
+w
f
n
)
とします。ただし、解はちょうど1つだけ存在するものとします。
Input
複数のデータセットの並びが入力として与えられます。入力の終わりはゼロひとつの行で示されます。各データセットは以下の形式で与えられます。
n
f
1
w
1
s
1
f
2
w
2
s
2
:
f
n
w
n
s
n
１行目に食べ物の個数
n
(1 ≤
n
≤ 10)、続く
n
行に
i
番目の食べ物の名前
f
i
(20 文字以内の半角英文字列)、重さ
w
i
(1 ≤
w
i
≤ 1000)、耐えられる重さ
s
i
(1 ≤
s
i
≤ 1000) が空白区切りで与えられます。
データセットの数は 20 を超えません。
Output
データセットごとに、次の形式で食べ物の名前を下から積み上げる順に出力します。
1 行目: 1 番下の食べ物の名前（半角英文字列）
2 行目: 下から2 番目の食べ物の名前
：
n
行目: 1 番上の食べ物の名前
Sample Input
4
sandwich 80 120
apple 50 200
cheese 20 40
cake 100 100
9
onigiri 80 300
onigiri 80 300
anpan 70 280
mikan 50 80
kanzume 100 500
chocolate 50 350
cookie 30 80
purin 40 400
cracker 40 160
0
Output for the Sample Input
apple
cake
sandwich
cheese
kanzume
purin
chocolate
onigiri
onigiri
anpan
mikan
cracker
cookie",C,"#include<stdio.h>
#include<string.h>
typedef struct i{char f[21];int s,w;} i;
i g[10];
int n,t[10],f[10]={0},ans[10],max=0;

void rec(int d)
{
	int i,w=0,G=0;
	if(d==n)
	{
		for(i=0;i<n;i++)
		{
			if(w>g[t[i]].s)
				return;
			w+=g[t[i]].w;
			G+=g[t[i]].w*(i+1);
		}
		if(max<G)
		{
			max=G;
			memcpy(ans,t,sizeof(t));
		}
	}
	else
	{
		for(i=0;i<n;i++)
		{
			if(!f[i])
			{
				f[i]=1;
				t[d]=i;
				rec(d+1);
				f[i]=0;
			}
		}
	}
}

int main()
{
	int i;
	for(;;)
	{
		scanf(""%d"",&n);
		if(!n)
			return 0;
		for(i=0;i<n;i++)
			scanf(""%s %d%d"",g[i].f,&g[i].w,&g[i].s);
		rec(0);
		while(--n>=0)
			puts(g[ans[n]].f);
	}
	return 0;
}",1
p00170,"ランチ
お昼に食べるお弁当を作るために、お店で食べ物を買いました。お店では、食べ物を入れるのに細長い袋しかもらえなかったので、すべての食べ物を縦に積んで袋に入れる必要があります。袋が倒れにくいように、できるだけ重い物を下にして詰めたいのですが、食べ物の中にはやわらかい物もあって、上に重い物を乗せるとつぶれてしまいます。
そこで、食べ物の情報を入力とし、全ての食べ物がつぶれず、かつ全体の重心が最も低くなるような積み方を出力するプログラムを作成してください。それぞれの食べ物ごとに、名前
f
、重さ
w
、上に載せて耐えられる重さ
s
が指定されます。
「全ての食べ物がつぶれない」というのは、下から順に、（
f
1
、
f
2
、... 、
f
n
）と
n
個の食べ物を積んだ時、すべての
f
について、
s
f
i
≥ w
f
i+1
+ w
f
i+2
+
...
+ w
f
n
であることを意味します。また、全体の重心
G
は、
G = (1 × w
f
1
+ 2 × w
f
2
+
...
+ n × w
f
n
)
/
(w
f
1
+ w
f
2
+
...
+w
f
n
)
とします。ただし、解はちょうど1つだけ存在するものとします。
Input
複数のデータセットの並びが入力として与えられます。入力の終わりはゼロひとつの行で示されます。各データセットは以下の形式で与えられます。
n
f
1
w
1
s
1
f
2
w
2
s
2
:
f
n
w
n
s
n
１行目に食べ物の個数
n
(1 ≤
n
≤ 10)、続く
n
行に
i
番目の食べ物の名前
f
i
(20 文字以内の半角英文字列)、重さ
w
i
(1 ≤
w
i
≤ 1000)、耐えられる重さ
s
i
(1 ≤
s
i
≤ 1000) が空白区切りで与えられます。
データセットの数は 20 を超えません。
Output
データセットごとに、次の形式で食べ物の名前を下から積み上げる順に出力します。
1 行目: 1 番下の食べ物の名前（半角英文字列）
2 行目: 下から2 番目の食べ物の名前
：
n
行目: 1 番上の食べ物の名前
Sample Input
4
sandwich 80 120
apple 50 200
cheese 20 40
cake 100 100
9
onigiri 80 300
onigiri 80 300
anpan 70 280
mikan 50 80
kanzume 100 500
chocolate 50 350
cookie 30 80
purin 40 400
cracker 40 160
0
Output for the Sample Input
apple
cake
sandwich
cheese
kanzume
purin
chocolate
onigiri
onigiri
anpan
mikan
cracker
cookie",Java,"import java.util.*;

public class Main {
    static class Food {
        String name;
        int weight;
        int strength;
        
        Food(String name, int weight, int strength) {
            this.name = name;
            this.weight = weight;
            this.strength = strength;
        }
    }
    
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        
        while (true) {
            int n = sc.nextInt();
            if (n == 0) break;
            
            Food[] foods = new Food[n];
            for (int i = 0; i < n; i++) {
                String name = sc.next();
                int weight = sc.nextInt();
                int strength = sc.nextInt();
                foods[i] = new Food(name, weight, strength);
            }
            
            int[] bestPerm = null;
            double minG = Double.MAX_VALUE;
            
            int[] perm = new int[n];
            for (int i = 0; i < n; i++) {
                perm[i] = i;
            }
            
            do {
                if (isValid(foods, perm)) {
                    double g = calculateG(foods, perm);
                    if (g < minG) {
                        minG = g;
                        bestPerm = perm.clone();
                    }
                }
            } while (nextPermutation(perm));
            
            for (int i = 0; i < n; i++) {
                System.out.println(foods[bestPerm[i]].name);
            }
        }
        
        sc.close();
    }
    
    static boolean isValid(Food[] foods, int[] perm) {
        int n = perm.length;
        for (int i = 0; i < n; i++) {
            int weightAbove = 0;
            for (int j = i + 1; j < n; j++) {
                weightAbove += foods[perm[j]].weight;
            }
            if (foods[perm[i]].strength < weightAbove) {
                return false;
            }
        }
        return true;
    }
    
    static double calculateG(Food[] foods, int[] perm) {
        int n = perm.length;
        double numerator = 0;
        double denominator = 0;
        for (int i = 0; i < n; i++) {
            numerator += (i + 1) * foods[perm[i]].weight;
            denominator += foods[perm[i]].weight;
        }
        return numerator / denominator;
    }
    
    static boolean nextPermutation(int[] array) {
        int i = array.length - 2;
        while (i >= 0 && array[i] >= array[i + 1]) {
            i--;
        }
        
        if (i < 0) {
            return false;
        }
        
        int j = array.length - 1;
        while (array[j] <= array[i]) {
            j--;
        }
        
        swap(array, i, j);
        reverse(array, i + 1, array.length - 1);
        return true;
    }
    
    static void swap(int[] array, int i, int j) {
        int temp = array[i];
        array[i] = array[j];
        array[j] = temp;
    }
    
    static void reverse(int[] array, int start, int end) {
        while (start < end) {
            swap(array, start, end);
            start++;
            end--;
        }
    }
}
",0
p00170,"ランチ
お昼に食べるお弁当を作るために、お店で食べ物を買いました。お店では、食べ物を入れるのに細長い袋しかもらえなかったので、すべての食べ物を縦に積んで袋に入れる必要があります。袋が倒れにくいように、できるだけ重い物を下にして詰めたいのですが、食べ物の中にはやわらかい物もあって、上に重い物を乗せるとつぶれてしまいます。
そこで、食べ物の情報を入力とし、全ての食べ物がつぶれず、かつ全体の重心が最も低くなるような積み方を出力するプログラムを作成してください。それぞれの食べ物ごとに、名前
f
、重さ
w
、上に載せて耐えられる重さ
s
が指定されます。
「全ての食べ物がつぶれない」というのは、下から順に、（
f
1
、
f
2
、... 、
f
n
）と
n
個の食べ物を積んだ時、すべての
f
について、
s
f
i
≥ w
f
i+1
+ w
f
i+2
+
...
+ w
f
n
であることを意味します。また、全体の重心
G
は、
G = (1 × w
f
1
+ 2 × w
f
2
+
...
+ n × w
f
n
)
/
(w
f
1
+ w
f
2
+
...
+w
f
n
)
とします。ただし、解はちょうど1つだけ存在するものとします。
Input
複数のデータセットの並びが入力として与えられます。入力の終わりはゼロひとつの行で示されます。各データセットは以下の形式で与えられます。
n
f
1
w
1
s
1
f
2
w
2
s
2
:
f
n
w
n
s
n
１行目に食べ物の個数
n
(1 ≤
n
≤ 10)、続く
n
行に
i
番目の食べ物の名前
f
i
(20 文字以内の半角英文字列)、重さ
w
i
(1 ≤
w
i
≤ 1000)、耐えられる重さ
s
i
(1 ≤
s
i
≤ 1000) が空白区切りで与えられます。
データセットの数は 20 を超えません。
Output
データセットごとに、次の形式で食べ物の名前を下から積み上げる順に出力します。
1 行目: 1 番下の食べ物の名前（半角英文字列）
2 行目: 下から2 番目の食べ物の名前
：
n
行目: 1 番上の食べ物の名前
Sample Input
4
sandwich 80 120
apple 50 200
cheese 20 40
cake 100 100
9
onigiri 80 300
onigiri 80 300
anpan 70 280
mikan 50 80
kanzume 100 500
chocolate 50 350
cookie 30 80
purin 40 400
cracker 40 160
0
Output for the Sample Input
apple
cake
sandwich
cheese
kanzume
purin
chocolate
onigiri
onigiri
anpan
mikan
cracker
cookie",Java,"
import java.util.ArrayList;
import java.util.List;
import java.util.Scanner;

class Food {
	String name;
	int w;
	int s;

	public Food(String name, int w, int s) {
		this.name = name;
		this.w = w;
		this.s = s;
	}

}

public class Main {
	public static void main(String[] args) {
		new Main().run();
	}

	public void run() {
		Scanner scanner = new Scanner(System.in);
		while (true) {
			int n = scanner.nextInt();
			int max = 0;
			List<Food> list = new ArrayList<Food>();
			for (int i = 0; i < n; i++) {
				String l = scanner.next();
				int a = scanner.nextInt();
				int b = scanner.nextInt();
				list.add(new Food(l, a, b));
				max += a;
			}
			for (int i = 0; i < n; i++) {
				int l = 0;
				int k = 0;
				for (int j = 0; j < list.size(); j++) {
					int m = max - list.get(j).w;
					int ss = list.get(j).s;
					if (m <= ss) {
						if (list.get(j).w > k) {
							k = list.get(j).w;
							l = j;
						}
					}
				}
				max -= list.get(l).w;
				System.out.println(list.get(l).name);
				list.get(l).s = -10;
				list.get(l).w = 0;
			}
		}
	}

}",1
p00170,"ランチ
お昼に食べるお弁当を作るために、お店で食べ物を買いました。お店では、食べ物を入れるのに細長い袋しかもらえなかったので、すべての食べ物を縦に積んで袋に入れる必要があります。袋が倒れにくいように、できるだけ重い物を下にして詰めたいのですが、食べ物の中にはやわらかい物もあって、上に重い物を乗せるとつぶれてしまいます。
そこで、食べ物の情報を入力とし、全ての食べ物がつぶれず、かつ全体の重心が最も低くなるような積み方を出力するプログラムを作成してください。それぞれの食べ物ごとに、名前
f
、重さ
w
、上に載せて耐えられる重さ
s
が指定されます。
「全ての食べ物がつぶれない」というのは、下から順に、（
f
1
、
f
2
、... 、
f
n
）と
n
個の食べ物を積んだ時、すべての
f
について、
s
f
i
≥ w
f
i+1
+ w
f
i+2
+
...
+ w
f
n
であることを意味します。また、全体の重心
G
は、
G = (1 × w
f
1
+ 2 × w
f
2
+
...
+ n × w
f
n
)
/
(w
f
1
+ w
f
2
+
...
+w
f
n
)
とします。ただし、解はちょうど1つだけ存在するものとします。
Input
複数のデータセットの並びが入力として与えられます。入力の終わりはゼロひとつの行で示されます。各データセットは以下の形式で与えられます。
n
f
1
w
1
s
1
f
2
w
2
s
2
:
f
n
w
n
s
n
１行目に食べ物の個数
n
(1 ≤
n
≤ 10)、続く
n
行に
i
番目の食べ物の名前
f
i
(20 文字以内の半角英文字列)、重さ
w
i
(1 ≤
w
i
≤ 1000)、耐えられる重さ
s
i
(1 ≤
s
i
≤ 1000) が空白区切りで与えられます。
データセットの数は 20 を超えません。
Output
データセットごとに、次の形式で食べ物の名前を下から積み上げる順に出力します。
1 行目: 1 番下の食べ物の名前（半角英文字列）
2 行目: 下から2 番目の食べ物の名前
：
n
行目: 1 番上の食べ物の名前
Sample Input
4
sandwich 80 120
apple 50 200
cheese 20 40
cake 100 100
9
onigiri 80 300
onigiri 80 300
anpan 70 280
mikan 50 80
kanzume 100 500
chocolate 50 350
cookie 30 80
purin 40 400
cracker 40 160
0
Output for the Sample Input
apple
cake
sandwich
cheese
kanzume
purin
chocolate
onigiri
onigiri
anpan
mikan
cracker
cookie",Python,"from itertools import permutations

def is_valid(order, items):
    # Check if the order is valid (no food is crushed)
    # order is a list of indices
    for i in range(len(order)):
        weight_above = sum(items[order[j]][1] for j in range(i + 1, len(order)))
        if items[order[i]][2] < weight_above:
            return False
    return True

def calculate_center_of_gravity(order, items):
    # Calculate center of gravity
    # Lower is better
    numerator = sum((i + 1) * items[order[i]][1] for i in range(len(order)))
    denominator = sum(items[order[i]][1] for i in range(len(order)))
    return numerator / denominator

while True:
    n = int(input())
    if n == 0:
        break
    
    items = []
    for _ in range(n):
        parts = input().split()
        name = parts[0]
        weight = int(parts[1])
        strength = int(parts[2])
        items.append((name, weight, strength))
    
    best_order = None
    best_cog = float('inf')
    
    # Try all permutations
    for perm in permutations(range(n)):
        if is_valid(perm, items):
            cog = calculate_center_of_gravity(perm, items)
            if cog < best_cog:
                best_cog = cog
                best_order = perm
    
    # Output the result
    for idx in best_order:
        print(items[idx][0])
",0
p00170,"ランチ
お昼に食べるお弁当を作るために、お店で食べ物を買いました。お店では、食べ物を入れるのに細長い袋しかもらえなかったので、すべての食べ物を縦に積んで袋に入れる必要があります。袋が倒れにくいように、できるだけ重い物を下にして詰めたいのですが、食べ物の中にはやわらかい物もあって、上に重い物を乗せるとつぶれてしまいます。
そこで、食べ物の情報を入力とし、全ての食べ物がつぶれず、かつ全体の重心が最も低くなるような積み方を出力するプログラムを作成してください。それぞれの食べ物ごとに、名前
f
、重さ
w
、上に載せて耐えられる重さ
s
が指定されます。
「全ての食べ物がつぶれない」というのは、下から順に、（
f
1
、
f
2
、... 、
f
n
）と
n
個の食べ物を積んだ時、すべての
f
について、
s
f
i
≥ w
f
i+1
+ w
f
i+2
+
...
+ w
f
n
であることを意味します。また、全体の重心
G
は、
G = (1 × w
f
1
+ 2 × w
f
2
+
...
+ n × w
f
n
)
/
(w
f
1
+ w
f
2
+
...
+w
f
n
)
とします。ただし、解はちょうど1つだけ存在するものとします。
Input
複数のデータセットの並びが入力として与えられます。入力の終わりはゼロひとつの行で示されます。各データセットは以下の形式で与えられます。
n
f
1
w
1
s
1
f
2
w
2
s
2
:
f
n
w
n
s
n
１行目に食べ物の個数
n
(1 ≤
n
≤ 10)、続く
n
行に
i
番目の食べ物の名前
f
i
(20 文字以内の半角英文字列)、重さ
w
i
(1 ≤
w
i
≤ 1000)、耐えられる重さ
s
i
(1 ≤
s
i
≤ 1000) が空白区切りで与えられます。
データセットの数は 20 を超えません。
Output
データセットごとに、次の形式で食べ物の名前を下から積み上げる順に出力します。
1 行目: 1 番下の食べ物の名前（半角英文字列）
2 行目: 下から2 番目の食べ物の名前
：
n
行目: 1 番上の食べ物の名前
Sample Input
4
sandwich 80 120
apple 50 200
cheese 20 40
cake 100 100
9
onigiri 80 300
onigiri 80 300
anpan 70 280
mikan 50 80
kanzume 100 500
chocolate 50 350
cookie 30 80
purin 40 400
cracker 40 160
0
Output for the Sample Input
apple
cake
sandwich
cheese
kanzume
purin
chocolate
onigiri
onigiri
anpan
mikan
cracker
cookie",Python,"# -*- coding: utf-8 -*-
""""""
http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=0170

""""""
import sys
from sys import stdin
input = stdin.readline
from collections import namedtuple
from itertools import permutations


def solve(items):
    total_weight = 0
    for i in items:
        total_weight += i.w

    best_ans = []
    best_gp = float('inf')
    # ???????????????????????????????????????????????°?????????????????§????????????
    for perm in permutations(items):
        ans = []
        squashed = False
        cw = 0
        gp = 0
        n = len(items)

        for p in perm:
            if p.s < cw:
                squashed = True
                break
            cw += p.w
            ans.append(p.name)
            gp += n * p.w
            n -= 1
        # ????????°???????????£?????´????????????????¨???????????????????????????????????????£?????????????????§????????????
        if not squashed:
            gp /= total_weight
            if gp < best_gp:
                best_gp = gp
                best_ans = ans[:]
    # ????????????????????????????????£??????????????§?????????????±?????????????????????????????????????????????????
    best_ans.reverse()
    return best_ans


item = namedtuple('item', ['name', 'w', 's'])
def main(args):
    while True:
        n = int(input())
        if n == 0:
            break
        items = []
        for _ in range(n):
            name, w, s = input().split()
            items.append(item(name, int(w), int(s)))

        result = solve(items)
        print('\n'.join(result))


if __name__ == '__main__':
    main(sys.argv[1:])",1
p00173,"お化け屋敷
会津学園高等学校では、毎年学園祭をおこなっています。その中でも一番人気はお化け屋敷です。一番人気の理由は、お化け屋敷をおこなうクラスが 1クラスや 2クラスではなく、9クラスがお化け屋敷をおこなうことです。それぞれが工夫することより、それぞれが個性的なお化け屋敷になっています。そのため、最近では近隣から多くの来場者が訪れます。
そこで、学園祭実行委員会では、お化け屋敷の入場料金を下表のように校内で統一し、これにもとづき各クラスごとに入場者総数と収入の集計をおこなうことにしました。
入場料金表(入場者 1人あたりの入場料)
午前   午後
200円   300円
各クラス毎の午前と午後の入場者数を入力とし、各クラス毎の入場者総数及び収入の一覧表を作成するプログラムを作成してください。
Input
入力は以下の形式で与えられます。
name
1
a
1
b
1
name
2
a
2
b
2
:
name
9
a
9
b
9
入力は９行からなり、
i
行目に第
i
のクラスのクラス名
name
i
(数字とアルファベットを含む 1 文字以上 15 文字以下の半角文字列)、午前の入場者数
a
i
(0 ≤
a
i
≤ 400)、 午後の入場者数
b
i
(0 ≤
b
i
≤ 400) が与えられます。
Output
i
行目に第
i
のクラスのクラス名、 入場者総数、 料金収入を空白区切りで１行に出力してください。
Sample Input
1a 132 243
1c 324 183
1f 93 199
2b 372 163
2c 229 293
2e 391 206
3a 118 168
3b 263 293
3d 281 102
Output for the Sample Input
1a 375 99300
1c 507 119700
1f 292 78300
2b 535 123300
2c 522 133700
2e 597 140000
3a 286 74000
3b 556 140500
3d 383 86800",C,"#include <stdio.h>

int main() {
    char name[16];
    int morning, afternoon;
    
    for (int i = 0; i < 9; i++) {
        scanf(""%s %d %d"", name, &morning, &afternoon);
        int total = morning + afternoon;
        int revenue = morning * 200 + afternoon * 300;
        printf(""%s %d %d\n"", name, total, revenue);
    }
    
    return 0;
}
",0
p00173,"お化け屋敷
会津学園高等学校では、毎年学園祭をおこなっています。その中でも一番人気はお化け屋敷です。一番人気の理由は、お化け屋敷をおこなうクラスが 1クラスや 2クラスではなく、9クラスがお化け屋敷をおこなうことです。それぞれが工夫することより、それぞれが個性的なお化け屋敷になっています。そのため、最近では近隣から多くの来場者が訪れます。
そこで、学園祭実行委員会では、お化け屋敷の入場料金を下表のように校内で統一し、これにもとづき各クラスごとに入場者総数と収入の集計をおこなうことにしました。
入場料金表(入場者 1人あたりの入場料)
午前   午後
200円   300円
各クラス毎の午前と午後の入場者数を入力とし、各クラス毎の入場者総数及び収入の一覧表を作成するプログラムを作成してください。
Input
入力は以下の形式で与えられます。
name
1
a
1
b
1
name
2
a
2
b
2
:
name
9
a
9
b
9
入力は９行からなり、
i
行目に第
i
のクラスのクラス名
name
i
(数字とアルファベットを含む 1 文字以上 15 文字以下の半角文字列)、午前の入場者数
a
i
(0 ≤
a
i
≤ 400)、 午後の入場者数
b
i
(0 ≤
b
i
≤ 400) が与えられます。
Output
i
行目に第
i
のクラスのクラス名、 入場者総数、 料金収入を空白区切りで１行に出力してください。
Sample Input
1a 132 243
1c 324 183
1f 93 199
2b 372 163
2c 229 293
2e 391 206
3a 118 168
3b 263 293
3d 281 102
Output for the Sample Input
1a 375 99300
1c 507 119700
1f 292 78300
2b 535 123300
2c 522 133700
2e 597 140000
3a 286 74000
3b 556 140500
3d 383 86800",C,"#include<stdio.h>

int main(void)
{
	char class[20];
	int i, am, pm;
	
	for(i=0;i<9;i++)
	{
		scanf(""%s %d %d"",class,&am,&pm);
		printf(""%s %d %d\n"",class,am+pm,(200*am)+(300*pm));
	}
	return 0;
}",1
p00173,"お化け屋敷
会津学園高等学校では、毎年学園祭をおこなっています。その中でも一番人気はお化け屋敷です。一番人気の理由は、お化け屋敷をおこなうクラスが 1クラスや 2クラスではなく、9クラスがお化け屋敷をおこなうことです。それぞれが工夫することより、それぞれが個性的なお化け屋敷になっています。そのため、最近では近隣から多くの来場者が訪れます。
そこで、学園祭実行委員会では、お化け屋敷の入場料金を下表のように校内で統一し、これにもとづき各クラスごとに入場者総数と収入の集計をおこなうことにしました。
入場料金表(入場者 1人あたりの入場料)
午前   午後
200円   300円
各クラス毎の午前と午後の入場者数を入力とし、各クラス毎の入場者総数及び収入の一覧表を作成するプログラムを作成してください。
Input
入力は以下の形式で与えられます。
name
1
a
1
b
1
name
2
a
2
b
2
:
name
9
a
9
b
9
入力は９行からなり、
i
行目に第
i
のクラスのクラス名
name
i
(数字とアルファベットを含む 1 文字以上 15 文字以下の半角文字列)、午前の入場者数
a
i
(0 ≤
a
i
≤ 400)、 午後の入場者数
b
i
(0 ≤
b
i
≤ 400) が与えられます。
Output
i
行目に第
i
のクラスのクラス名、 入場者総数、 料金収入を空白区切りで１行に出力してください。
Sample Input
1a 132 243
1c 324 183
1f 93 199
2b 372 163
2c 229 293
2e 391 206
3a 118 168
3b 263 293
3d 281 102
Output for the Sample Input
1a 375 99300
1c 507 119700
1f 292 78300
2b 535 123300
2c 522 133700
2e 597 140000
3a 286 74000
3b 556 140500
3d 383 86800",Java,"import java.util.Scanner;

public class Main {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        
        for (int i = 0; i < 9; i++) {
            String name = sc.next();
            int morning = sc.nextInt();
            int afternoon = sc.nextInt();
            
            int totalVisitors = morning + afternoon;
            int totalRevenue = morning * 200 + afternoon * 300;
            
            System.out.println(name + "" "" + totalVisitors + "" "" + totalRevenue);
        }
        
        sc.close();
    }
}
",0
p00173,"お化け屋敷
会津学園高等学校では、毎年学園祭をおこなっています。その中でも一番人気はお化け屋敷です。一番人気の理由は、お化け屋敷をおこなうクラスが 1クラスや 2クラスではなく、9クラスがお化け屋敷をおこなうことです。それぞれが工夫することより、それぞれが個性的なお化け屋敷になっています。そのため、最近では近隣から多くの来場者が訪れます。
そこで、学園祭実行委員会では、お化け屋敷の入場料金を下表のように校内で統一し、これにもとづき各クラスごとに入場者総数と収入の集計をおこなうことにしました。
入場料金表(入場者 1人あたりの入場料)
午前   午後
200円   300円
各クラス毎の午前と午後の入場者数を入力とし、各クラス毎の入場者総数及び収入の一覧表を作成するプログラムを作成してください。
Input
入力は以下の形式で与えられます。
name
1
a
1
b
1
name
2
a
2
b
2
:
name
9
a
9
b
9
入力は９行からなり、
i
行目に第
i
のクラスのクラス名
name
i
(数字とアルファベットを含む 1 文字以上 15 文字以下の半角文字列)、午前の入場者数
a
i
(0 ≤
a
i
≤ 400)、 午後の入場者数
b
i
(0 ≤
b
i
≤ 400) が与えられます。
Output
i
行目に第
i
のクラスのクラス名、 入場者総数、 料金収入を空白区切りで１行に出力してください。
Sample Input
1a 132 243
1c 324 183
1f 93 199
2b 372 163
2c 229 293
2e 391 206
3a 118 168
3b 263 293
3d 281 102
Output for the Sample Input
1a 375 99300
1c 507 119700
1f 292 78300
2b 535 123300
2c 522 133700
2e 597 140000
3a 286 74000
3b 556 140500
3d 383 86800",Java,"/**
 * @author yuichirw
 *
 */
import java.util.*;

public class Main {

	static Scanner sc = new Scanner(System.in);
	
	public static void main(String[] args) {
		int a,b,rel,sum;
		String c;

		for(int i = 0; i < 9; i++) {
			c = sc.next(); a = sc.nextInt(); b = sc.nextInt();
			sum = a + b;
			rel = a * 200 + b * 300;
			System.out.println(c + "" "" + sum + "" "" + rel);
		}
	}
}",1
p00173,"お化け屋敷
会津学園高等学校では、毎年学園祭をおこなっています。その中でも一番人気はお化け屋敷です。一番人気の理由は、お化け屋敷をおこなうクラスが 1クラスや 2クラスではなく、9クラスがお化け屋敷をおこなうことです。それぞれが工夫することより、それぞれが個性的なお化け屋敷になっています。そのため、最近では近隣から多くの来場者が訪れます。
そこで、学園祭実行委員会では、お化け屋敷の入場料金を下表のように校内で統一し、これにもとづき各クラスごとに入場者総数と収入の集計をおこなうことにしました。
入場料金表(入場者 1人あたりの入場料)
午前   午後
200円   300円
各クラス毎の午前と午後の入場者数を入力とし、各クラス毎の入場者総数及び収入の一覧表を作成するプログラムを作成してください。
Input
入力は以下の形式で与えられます。
name
1
a
1
b
1
name
2
a
2
b
2
:
name
9
a
9
b
9
入力は９行からなり、
i
行目に第
i
のクラスのクラス名
name
i
(数字とアルファベットを含む 1 文字以上 15 文字以下の半角文字列)、午前の入場者数
a
i
(0 ≤
a
i
≤ 400)、 午後の入場者数
b
i
(0 ≤
b
i
≤ 400) が与えられます。
Output
i
行目に第
i
のクラスのクラス名、 入場者総数、 料金収入を空白区切りで１行に出力してください。
Sample Input
1a 132 243
1c 324 183
1f 93 199
2b 372 163
2c 229 293
2e 391 206
3a 118 168
3b 263 293
3d 281 102
Output for the Sample Input
1a 375 99300
1c 507 119700
1f 292 78300
2b 535 123300
2c 522 133700
2e 597 140000
3a 286 74000
3b 556 140500
3d 383 86800",Python,"for _ in range(9):
    line = input().split()
    name = line[0]
    morning = int(line[1])
    afternoon = int(line[2])
    total = morning + afternoon
    revenue = morning * 200 + afternoon * 300
    print(name, total, revenue)
",0
p00173,"お化け屋敷
会津学園高等学校では、毎年学園祭をおこなっています。その中でも一番人気はお化け屋敷です。一番人気の理由は、お化け屋敷をおこなうクラスが 1クラスや 2クラスではなく、9クラスがお化け屋敷をおこなうことです。それぞれが工夫することより、それぞれが個性的なお化け屋敷になっています。そのため、最近では近隣から多くの来場者が訪れます。
そこで、学園祭実行委員会では、お化け屋敷の入場料金を下表のように校内で統一し、これにもとづき各クラスごとに入場者総数と収入の集計をおこなうことにしました。
入場料金表(入場者 1人あたりの入場料)
午前   午後
200円   300円
各クラス毎の午前と午後の入場者数を入力とし、各クラス毎の入場者総数及び収入の一覧表を作成するプログラムを作成してください。
Input
入力は以下の形式で与えられます。
name
1
a
1
b
1
name
2
a
2
b
2
:
name
9
a
9
b
9
入力は９行からなり、
i
行目に第
i
のクラスのクラス名
name
i
(数字とアルファベットを含む 1 文字以上 15 文字以下の半角文字列)、午前の入場者数
a
i
(0 ≤
a
i
≤ 400)、 午後の入場者数
b
i
(0 ≤
b
i
≤ 400) が与えられます。
Output
i
行目に第
i
のクラスのクラス名、 入場者総数、 料金収入を空白区切りで１行に出力してください。
Sample Input
1a 132 243
1c 324 183
1f 93 199
2b 372 163
2c 229 293
2e 391 206
3a 118 168
3b 263 293
3d 281 102
Output for the Sample Input
1a 375 99300
1c 507 119700
1f 292 78300
2b 535 123300
2c 522 133700
2e 597 140000
3a 286 74000
3b 556 140500
3d 383 86800",Python,"for i in range(9):
    name,a,b=list(input().split())
    print(name,int(a)+int(b),int(a)*200+int(b)*300)
",1
p00174,"バドミントン
A君、Bさん、C君で久しぶりに遊ぶことになりました。 A君とBさんがプレイヤー、C君が審判になりバドミントンのシングルスのゲームをしました。3人で決めたルールは以下の通りです。
3 ゲームを行います。
11 点を先取した人が、そのゲームの勝者となります。
第 1 ゲームの最初のサーブはA君から始まりますが、次のサーブは直前のポイントを取った人が行います。
第 2 ゲーム、第 3 ゲームは前のゲームを取った人が最初のサーブを行います。
10 - 10 になって以降は 2 点差をつけた人が勝者となります。
全てのゲームが終わり、得点を見ようとしたのですが、審判のC君が得点を記録するのを忘れていました。しかし、サーブを打った人をきちんと記録していました。サーブ順の記録から得点を計算するプログラムを作成してください。ただし、二人が打ったサーブの回数の合計は 100 以下とし、サーブ順の記録は、サーブを打った人を表す ""A"" または ""B"" の文字列で表されます。
Input
複数のデータセットの並びが入力として与えられます。入力の終わりはゼロひとつの行で示されま
す。各データセットは以下の形式で与えられます。
record
1
record
2
record
3
i
行目に第
i
ゲームのサーブ順を表す文字列が与えられます。
データセットの数は 20 を超えません。
Output
データセット毎に、
i
行目に第
i
ゲームのA君の得点とBさんの得点を空白区切りで出力してください。
Sample Input
ABAABBBAABABAAABBAA
AABBBABBABBAAABABABAAB
BABAABAABABABBAAAB
AABABAAABBAABBBABAA
AAAAAAAAAAA
ABBBBBBBBBB
0
Output for the Sample Input
11 8
10 12
11 7
11 8
11 0
0 11",C,"#include <stdio.h>
#include <string.h>

int main() {
    char record[101];
    
    while(1) {
        if(scanf(""%s"", record) != 1) break;
        if(strcmp(record, ""0"") == 0) break;
        
        int len = strlen(record);
        int scoreA = 0, scoreB = 0;
        char lastServer = record[0];
        
        for(int i = 0; i < len; i++) {
            if(record[i] != lastServer) {
                // Server changed, so the previous server lost the point
                if(lastServer == 'A') {
                    scoreB++;
                } else {
                    scoreA++;
                }
                lastServer = record[i];
            } else {
                // Server stayed same, so server won the point
                if(lastServer == 'A') {
                    scoreA++;
                } else {
                    scoreB++;
                }
            }
            
            // Check if game ended
            if(scoreA >= 11 || scoreB >= 11) {
                if(scoreA >= 11 && scoreB >= 11) {
                    if(scoreA - scoreB >= 2 || scoreB - scoreA >= 2) {
                        break;
                    }
                } else {
                    break;
                }
            }
        }
        
        printf(""%d %d\n"", scoreA, scoreB);
    }
    
    return 0;
}
",0
p00174,"バドミントン
A君、Bさん、C君で久しぶりに遊ぶことになりました。 A君とBさんがプレイヤー、C君が審判になりバドミントンのシングルスのゲームをしました。3人で決めたルールは以下の通りです。
3 ゲームを行います。
11 点を先取した人が、そのゲームの勝者となります。
第 1 ゲームの最初のサーブはA君から始まりますが、次のサーブは直前のポイントを取った人が行います。
第 2 ゲーム、第 3 ゲームは前のゲームを取った人が最初のサーブを行います。
10 - 10 になって以降は 2 点差をつけた人が勝者となります。
全てのゲームが終わり、得点を見ようとしたのですが、審判のC君が得点を記録するのを忘れていました。しかし、サーブを打った人をきちんと記録していました。サーブ順の記録から得点を計算するプログラムを作成してください。ただし、二人が打ったサーブの回数の合計は 100 以下とし、サーブ順の記録は、サーブを打った人を表す ""A"" または ""B"" の文字列で表されます。
Input
複数のデータセットの並びが入力として与えられます。入力の終わりはゼロひとつの行で示されま
す。各データセットは以下の形式で与えられます。
record
1
record
2
record
3
i
行目に第
i
ゲームのサーブ順を表す文字列が与えられます。
データセットの数は 20 を超えません。
Output
データセット毎に、
i
行目に第
i
ゲームのA君の得点とBさんの得点を空白区切りで出力してください。
Sample Input
ABAABBBAABABAAABBAA
AABBBABBABBAAABABABAAB
BABAABAABABABBAAAB
AABABAAABBAABBBABAA
AAAAAAAAAAA
ABBBBBBBBBB
0
Output for the Sample Input
11 8
10 12
11 7
11 8
11 0
0 11",C,"main(a,b,c){for(a=b=0,getchar();(c=getchar())!='0';)if(c-'\n')c=='A'?a++:b++;else{printf(""%d %d\n"",a>b?a+1:a,a<b?b+1:b),a=b=0;if(getchar()=='0')break;}exit(0);}",1
p00174,"バドミントン
A君、Bさん、C君で久しぶりに遊ぶことになりました。 A君とBさんがプレイヤー、C君が審判になりバドミントンのシングルスのゲームをしました。3人で決めたルールは以下の通りです。
3 ゲームを行います。
11 点を先取した人が、そのゲームの勝者となります。
第 1 ゲームの最初のサーブはA君から始まりますが、次のサーブは直前のポイントを取った人が行います。
第 2 ゲーム、第 3 ゲームは前のゲームを取った人が最初のサーブを行います。
10 - 10 になって以降は 2 点差をつけた人が勝者となります。
全てのゲームが終わり、得点を見ようとしたのですが、審判のC君が得点を記録するのを忘れていました。しかし、サーブを打った人をきちんと記録していました。サーブ順の記録から得点を計算するプログラムを作成してください。ただし、二人が打ったサーブの回数の合計は 100 以下とし、サーブ順の記録は、サーブを打った人を表す ""A"" または ""B"" の文字列で表されます。
Input
複数のデータセットの並びが入力として与えられます。入力の終わりはゼロひとつの行で示されま
す。各データセットは以下の形式で与えられます。
record
1
record
2
record
3
i
行目に第
i
ゲームのサーブ順を表す文字列が与えられます。
データセットの数は 20 を超えません。
Output
データセット毎に、
i
行目に第
i
ゲームのA君の得点とBさんの得点を空白区切りで出力してください。
Sample Input
ABAABBBAABABAAABBAA
AABBBABBABBAAABABABAAB
BABAABAABABABBAAAB
AABABAAABBAABBBABAA
AAAAAAAAAAA
ABBBBBBBBBB
0
Output for the Sample Input
11 8
10 12
11 7
11 8
11 0
0 11",Java,"import java.util.*;

public class Main {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        
        while (true) {
            String line = sc.nextLine();
            if (line.equals(""0"")) break;
            
            String game1 = line;
            String game2 = sc.nextLine();
            String game3 = sc.nextLine();
            
            System.out.println(processGame(game1));
            System.out.println(processGame(game2));
            System.out.println(processGame(game3));
        }
        
        sc.close();
    }
    
    static String processGame(String record) {
        int scoreA = 0;
        int scoreB = 0;
        
        for (int i = 0; i < record.length(); i++) {
            char server = record.charAt(i);
            
            // The server who is recorded is the one who won the point
            if (server == 'A') {
                scoreA++;
            } else {
                scoreB++;
            }
            
            // Check if game is over
            if (scoreA >= 11 || scoreB >= 11) {
                if (scoreA >= 10 && scoreB >= 10) {
                    // Deuce situation - need 2 point difference
                    if (Math.abs(scoreA - scoreB) >= 2) {
                        break;
                    }
                } else {
                    // Normal situation - first to 11
                    if (scoreA >= 11 || scoreB >= 11) {
                        break;
                    }
                }
            }
        }
        
        return scoreA + "" "" + scoreB;
    }
}
",0
p00174,"バドミントン
A君、Bさん、C君で久しぶりに遊ぶことになりました。 A君とBさんがプレイヤー、C君が審判になりバドミントンのシングルスのゲームをしました。3人で決めたルールは以下の通りです。
3 ゲームを行います。
11 点を先取した人が、そのゲームの勝者となります。
第 1 ゲームの最初のサーブはA君から始まりますが、次のサーブは直前のポイントを取った人が行います。
第 2 ゲーム、第 3 ゲームは前のゲームを取った人が最初のサーブを行います。
10 - 10 になって以降は 2 点差をつけた人が勝者となります。
全てのゲームが終わり、得点を見ようとしたのですが、審判のC君が得点を記録するのを忘れていました。しかし、サーブを打った人をきちんと記録していました。サーブ順の記録から得点を計算するプログラムを作成してください。ただし、二人が打ったサーブの回数の合計は 100 以下とし、サーブ順の記録は、サーブを打った人を表す ""A"" または ""B"" の文字列で表されます。
Input
複数のデータセットの並びが入力として与えられます。入力の終わりはゼロひとつの行で示されま
す。各データセットは以下の形式で与えられます。
record
1
record
2
record
3
i
行目に第
i
ゲームのサーブ順を表す文字列が与えられます。
データセットの数は 20 を超えません。
Output
データセット毎に、
i
行目に第
i
ゲームのA君の得点とBさんの得点を空白区切りで出力してください。
Sample Input
ABAABBBAABABAAABBAA
AABBBABBABBAAABABABAAB
BABAABAABABABBAAAB
AABABAAABBAABBBABAA
AAAAAAAAAAA
ABBBBBBBBBB
0
Output for the Sample Input
11 8
10 12
11 7
11 8
11 0
0 11",Java,"import java.util.Scanner;
class Main
{
    public static void main(String args[])
    {
	Scanner scan=new Scanner(System.in);
	while(true)
	    {
		String str=scan.next();
		if(str.equals(""0""))break;
		int countA=0,countB=0;
		if(str.charAt(str.length()-1)=='A')
		    {
			countA+=1;
			//countB-=1;
		    }
		else if(str.charAt(str.length()-1)=='B')
		    {
		    countB+=1;
		    //countA-=1;
		    }
		for(int i=1;i<str.length();i++)
		    {
			if(str.charAt(i)=='A')countA+=1;
			else countB+=1;
		    }
		if(str.charAt(str.length()-1)=='B'&&(countB<countA))
		    {
			countB-=1;
			countA+=1;
		    }
		else if(str.charAt(str.length()-1)=='A'&&(countB>countA))
		    {
			countA-=1;
			countB+=1;
		    }
		System.out.println(countA+"" ""+countB);
	    }
    }
}",1
p00174,"バドミントン
A君、Bさん、C君で久しぶりに遊ぶことになりました。 A君とBさんがプレイヤー、C君が審判になりバドミントンのシングルスのゲームをしました。3人で決めたルールは以下の通りです。
3 ゲームを行います。
11 点を先取した人が、そのゲームの勝者となります。
第 1 ゲームの最初のサーブはA君から始まりますが、次のサーブは直前のポイントを取った人が行います。
第 2 ゲーム、第 3 ゲームは前のゲームを取った人が最初のサーブを行います。
10 - 10 になって以降は 2 点差をつけた人が勝者となります。
全てのゲームが終わり、得点を見ようとしたのですが、審判のC君が得点を記録するのを忘れていました。しかし、サーブを打った人をきちんと記録していました。サーブ順の記録から得点を計算するプログラムを作成してください。ただし、二人が打ったサーブの回数の合計は 100 以下とし、サーブ順の記録は、サーブを打った人を表す ""A"" または ""B"" の文字列で表されます。
Input
複数のデータセットの並びが入力として与えられます。入力の終わりはゼロひとつの行で示されま
す。各データセットは以下の形式で与えられます。
record
1
record
2
record
3
i
行目に第
i
ゲームのサーブ順を表す文字列が与えられます。
データセットの数は 20 を超えません。
Output
データセット毎に、
i
行目に第
i
ゲームのA君の得点とBさんの得点を空白区切りで出力してください。
Sample Input
ABAABBBAABABAAABBAA
AABBBABBABBAAABABABAAB
BABAABAABABABBAAAB
AABABAAABBAABBBABAA
AAAAAAAAAAA
ABBBBBBBBBB
0
Output for the Sample Input
11 8
10 12
11 7
11 8
11 0
0 11",Python,"import sys

def solve_game(record):
    score_a = 0
    score_b = 0
    
    i = 0
    while i < len(record):
        server = record[i]
        
        # Check if game is over
        if score_a >= 11 or score_b >= 11:
            if abs(score_a - score_b) >= 2:
                break
            elif score_a >= 11 and score_b >= 11:
                if abs(score_a - score_b) >= 2:
                    break
        
        # Determine who won the point
        if i + 1 < len(record):
            next_server = record[i + 1]
            if next_server == server:
                # Same server, so server won the point
                if server == 'A':
                    score_a += 1
                else:
                    score_b += 1
            else:
                # Different server, so server lost the point
                if server == 'A':
                    score_b += 1
                else:
                    score_a += 1
        else:
            # Last serve, determine winner based on current score
            # The game must end after this serve
            if score_a < 11 and score_b < 11:
                # Someone needs to reach 11
                if server == 'A':
                    score_a += 1
                else:
                    score_b += 1
            elif score_a >= 10 and score_b >= 10:
                # In deuce, need 2 point difference
                if server == 'A':
                    if score_a == score_b or score_a == score_b + 1:
                        score_a += 1
                    else:
                        score_b += 1
                else:
                    if score_b == score_a or score_b == score_a + 1:
                        score_b += 1
                    else:
                        score_a += 1
            else:
                if server == 'A':
                    score_a += 1
                else:
                    score_b += 1
        
        i += 1
    
    return score_a, score_b

while True:
    line = input().strip()
    if line == ""0"":
        break
    
    game1 = line
    game2 = input().strip()
    game3 = input().strip()
    
    score1 = solve_game(game1)
    score2 = solve_game(game2)
    score3 = solve_game(game3)
    
    print(f""{score1[0]} {score1[1]}"")
    print(f""{score2[0]} {score2[1]}"")
    print(f""{score3[0]} {score3[1]}"")
",0
p00174,"バドミントン
A君、Bさん、C君で久しぶりに遊ぶことになりました。 A君とBさんがプレイヤー、C君が審判になりバドミントンのシングルスのゲームをしました。3人で決めたルールは以下の通りです。
3 ゲームを行います。
11 点を先取した人が、そのゲームの勝者となります。
第 1 ゲームの最初のサーブはA君から始まりますが、次のサーブは直前のポイントを取った人が行います。
第 2 ゲーム、第 3 ゲームは前のゲームを取った人が最初のサーブを行います。
10 - 10 になって以降は 2 点差をつけた人が勝者となります。
全てのゲームが終わり、得点を見ようとしたのですが、審判のC君が得点を記録するのを忘れていました。しかし、サーブを打った人をきちんと記録していました。サーブ順の記録から得点を計算するプログラムを作成してください。ただし、二人が打ったサーブの回数の合計は 100 以下とし、サーブ順の記録は、サーブを打った人を表す ""A"" または ""B"" の文字列で表されます。
Input
複数のデータセットの並びが入力として与えられます。入力の終わりはゼロひとつの行で示されま
す。各データセットは以下の形式で与えられます。
record
1
record
2
record
3
i
行目に第
i
ゲームのサーブ順を表す文字列が与えられます。
データセットの数は 20 を超えません。
Output
データセット毎に、
i
行目に第
i
ゲームのA君の得点とBさんの得点を空白区切りで出力してください。
Sample Input
ABAABBBAABABAAABBAA
AABBBABBABBAAABABABAAB
BABAABAABABABBAAAB
AABABAAABBAABBBABAA
AAAAAAAAAAA
ABBBBBBBBBB
0
Output for the Sample Input
11 8
10 12
11 7
11 8
11 0
0 11",Python,"while True:
    ten=input()
    if ten=='0':
        break
    a=ten.count('A')
    b=ten.count('B')
    if ten[0]=='A':
        a-=1
    elif ten[0]=='B':
        b-=1
    if a>b:
        a+=1
    else:
        b+=1
    print(a,b)
",1
p00175,"４進数
10 進数は現在使われている一般的な記数法で、0、1、2、3、4、5、6、7、8、9 の10 個の記号を用いて全ての数字を表します。
2 進数はコンピュータの世界でよく使われる記数法で、0 と1 の二つの記号を用いて全ての数字を表します。
4 進数で用いられるのは 0、1、2、3 の 4 つの数字だけです。4 進数では 0 から順に数を増やしていったときに 4 まで来たら次の位に桁上がりします。そのため、10 進数の 4 は桁上がりして「10」という表現になります。
10 進数
0
1
2
3
4
5
6
7
8
9
10
...
2 進数
0
1
10
11
100
101
110
111
1000
101
1010
...
4 進数
0
1
2
3
10
11
12
13
20
21
22
...
昔ハワイでは魚やタロイモを指にはさんで数えていたので、10 進数ではなく4 進数を使っていたそうです。
10 進数で入力される整数
n
を 4 進数に変換し出力するプログラムを作成してください。
Input
複数のデータセットの並びが入力として与えられます。入力の終わりは -1 ひとつの行で示されます。各データセットとして１つの整数
n
(0 ≤
n
≤ 1000000) が１行に与えられます。
データセットの数は 2000 を超えません。
Output
入力データセット毎に 4 進数に変換した結果を１行に出力します。
Sample Input
7
4
0
12
10
10000
-1
Output for the Sample Input
13
10
0
30
22
2130100",C,"#include <stdio.h>

int main() {
    int n;
    
    while(1) {
        scanf(""%d"", &n);
        if(n == -1) break;
        
        if(n == 0) {
            printf(""0\n"");
            continue;
        }
        
        char result[32];
        int index = 0;
        
        while(n > 0) {
            result[index++] = '0' + (n % 4);
            n /= 4;
        }
        
        for(int i = index - 1; i >= 0; i--) {
            printf(""%c"", result[i]);
        }
        printf(""\n"");
    }
    
    return 0;
}
",0
p00175,"４進数
10 進数は現在使われている一般的な記数法で、0、1、2、3、4、5、6、7、8、9 の10 個の記号を用いて全ての数字を表します。
2 進数はコンピュータの世界でよく使われる記数法で、0 と1 の二つの記号を用いて全ての数字を表します。
4 進数で用いられるのは 0、1、2、3 の 4 つの数字だけです。4 進数では 0 から順に数を増やしていったときに 4 まで来たら次の位に桁上がりします。そのため、10 進数の 4 は桁上がりして「10」という表現になります。
10 進数
0
1
2
3
4
5
6
7
8
9
10
...
2 進数
0
1
10
11
100
101
110
111
1000
101
1010
...
4 進数
0
1
2
3
10
11
12
13
20
21
22
...
昔ハワイでは魚やタロイモを指にはさんで数えていたので、10 進数ではなく4 進数を使っていたそうです。
10 進数で入力される整数
n
を 4 進数に変換し出力するプログラムを作成してください。
Input
複数のデータセットの並びが入力として与えられます。入力の終わりは -1 ひとつの行で示されます。各データセットとして１つの整数
n
(0 ≤
n
≤ 1000000) が１行に与えられます。
データセットの数は 2000 を超えません。
Output
入力データセット毎に 4 進数に変換した結果を１行に出力します。
Sample Input
7
4
0
12
10
10000
-1
Output for the Sample Input
13
10
0
30
22
2130100",C,"#include<stdio.h>
int main(void)
{
	int n,nbox[10000],temp,i,j,flg;
	scanf(""%d"",&n);
	while(n!=-1){
		temp=0;
		i=0;
		flg=0;
		while(n>=4){
			nbox[i]=n%4;
			n/=4;
			i++;
		}
		printf(""%d"",n);
		for(j=i;j>=0;j--){
			if(flg==0){
				flg=1;
			}
			else if(flg==1){
				printf(""%d"",nbox[j]);
			}
		}
		printf(""\n"");
		scanf(""%d"",&n);
	}
	return 0;
}",1
p00175,"４進数
10 進数は現在使われている一般的な記数法で、0、1、2、3、4、5、6、7、8、9 の10 個の記号を用いて全ての数字を表します。
2 進数はコンピュータの世界でよく使われる記数法で、0 と1 の二つの記号を用いて全ての数字を表します。
4 進数で用いられるのは 0、1、2、3 の 4 つの数字だけです。4 進数では 0 から順に数を増やしていったときに 4 まで来たら次の位に桁上がりします。そのため、10 進数の 4 は桁上がりして「10」という表現になります。
10 進数
0
1
2
3
4
5
6
7
8
9
10
...
2 進数
0
1
10
11
100
101
110
111
1000
101
1010
...
4 進数
0
1
2
3
10
11
12
13
20
21
22
...
昔ハワイでは魚やタロイモを指にはさんで数えていたので、10 進数ではなく4 進数を使っていたそうです。
10 進数で入力される整数
n
を 4 進数に変換し出力するプログラムを作成してください。
Input
複数のデータセットの並びが入力として与えられます。入力の終わりは -1 ひとつの行で示されます。各データセットとして１つの整数
n
(0 ≤
n
≤ 1000000) が１行に与えられます。
データセットの数は 2000 を超えません。
Output
入力データセット毎に 4 進数に変換した結果を１行に出力します。
Sample Input
7
4
0
12
10
10000
-1
Output for the Sample Input
13
10
0
30
22
2130100",Java,"import java.util.Scanner;

public class Main {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        
        while (true) {
            int n = sc.nextInt();
            if (n == -1) break;
            
            if (n == 0) {
                System.out.println(0);
            } else {
                StringBuilder result = new StringBuilder();
                while (n > 0) {
                    result.append(n % 4);
                    n /= 4;
                }
                System.out.println(result.reverse().toString());
            }
        }
        
        sc.close();
    }
}
",0
p00175,"４進数
10 進数は現在使われている一般的な記数法で、0、1、2、3、4、5、6、7、8、9 の10 個の記号を用いて全ての数字を表します。
2 進数はコンピュータの世界でよく使われる記数法で、0 と1 の二つの記号を用いて全ての数字を表します。
4 進数で用いられるのは 0、1、2、3 の 4 つの数字だけです。4 進数では 0 から順に数を増やしていったときに 4 まで来たら次の位に桁上がりします。そのため、10 進数の 4 は桁上がりして「10」という表現になります。
10 進数
0
1
2
3
4
5
6
7
8
9
10
...
2 進数
0
1
10
11
100
101
110
111
1000
101
1010
...
4 進数
0
1
2
3
10
11
12
13
20
21
22
...
昔ハワイでは魚やタロイモを指にはさんで数えていたので、10 進数ではなく4 進数を使っていたそうです。
10 進数で入力される整数
n
を 4 進数に変換し出力するプログラムを作成してください。
Input
複数のデータセットの並びが入力として与えられます。入力の終わりは -1 ひとつの行で示されます。各データセットとして１つの整数
n
(0 ≤
n
≤ 1000000) が１行に与えられます。
データセットの数は 2000 を超えません。
Output
入力データセット毎に 4 進数に変換した結果を１行に出力します。
Sample Input
7
4
0
12
10
10000
-1
Output for the Sample Input
13
10
0
30
22
2130100",Java,"import java.util.*;

class Main {
  public static void main (String[] args) {
    Scanner scanner = new Scanner(System.in);
    while (scanner.hasNext()) {
      int a = scanner.nextInt();
      if (a < 0) {
        break;
      }
      if (a == 0) {
        System.out.println(0);
        continue;
      }
      System.out.println(aaa(a));
    }
  }
  public static String aaa (int a) {
    if (a == 0) {
      return """";
    }
    return aaa(a / 4) + a % 4;
  }
}",1
p00175,"４進数
10 進数は現在使われている一般的な記数法で、0、1、2、3、4、5、6、7、8、9 の10 個の記号を用いて全ての数字を表します。
2 進数はコンピュータの世界でよく使われる記数法で、0 と1 の二つの記号を用いて全ての数字を表します。
4 進数で用いられるのは 0、1、2、3 の 4 つの数字だけです。4 進数では 0 から順に数を増やしていったときに 4 まで来たら次の位に桁上がりします。そのため、10 進数の 4 は桁上がりして「10」という表現になります。
10 進数
0
1
2
3
4
5
6
7
8
9
10
...
2 進数
0
1
10
11
100
101
110
111
1000
101
1010
...
4 進数
0
1
2
3
10
11
12
13
20
21
22
...
昔ハワイでは魚やタロイモを指にはさんで数えていたので、10 進数ではなく4 進数を使っていたそうです。
10 進数で入力される整数
n
を 4 進数に変換し出力するプログラムを作成してください。
Input
複数のデータセットの並びが入力として与えられます。入力の終わりは -1 ひとつの行で示されます。各データセットとして１つの整数
n
(0 ≤
n
≤ 1000000) が１行に与えられます。
データセットの数は 2000 を超えません。
Output
入力データセット毎に 4 進数に変換した結果を１行に出力します。
Sample Input
7
4
0
12
10
10000
-1
Output for the Sample Input
13
10
0
30
22
2130100",Python,"while True:
    n = int(input())
    if n == -1:
        break
    
    if n == 0:
        print(0)
    else:
        result = """"
        while n > 0:
            result = str(n % 4) + result
            n //= 4
        print(result)
",0
p00175,"４進数
10 進数は現在使われている一般的な記数法で、0、1、2、3、4、5、6、7、8、9 の10 個の記号を用いて全ての数字を表します。
2 進数はコンピュータの世界でよく使われる記数法で、0 と1 の二つの記号を用いて全ての数字を表します。
4 進数で用いられるのは 0、1、2、3 の 4 つの数字だけです。4 進数では 0 から順に数を増やしていったときに 4 まで来たら次の位に桁上がりします。そのため、10 進数の 4 は桁上がりして「10」という表現になります。
10 進数
0
1
2
3
4
5
6
7
8
9
10
...
2 進数
0
1
10
11
100
101
110
111
1000
101
1010
...
4 進数
0
1
2
3
10
11
12
13
20
21
22
...
昔ハワイでは魚やタロイモを指にはさんで数えていたので、10 進数ではなく4 進数を使っていたそうです。
10 進数で入力される整数
n
を 4 進数に変換し出力するプログラムを作成してください。
Input
複数のデータセットの並びが入力として与えられます。入力の終わりは -1 ひとつの行で示されます。各データセットとして１つの整数
n
(0 ≤
n
≤ 1000000) が１行に与えられます。
データセットの数は 2000 を超えません。
Output
入力データセット毎に 4 進数に変換した結果を１行に出力します。
Sample Input
7
4
0
12
10
10000
-1
Output for the Sample Input
13
10
0
30
22
2130100",Python,"from operator import add
b2q = {""00"":""0"",""01"":""1"",""10"":""2"",""11"":""3""}
while True:
    n = input()
    if n == -1:
        break
    s = format(n,""b"")
    if len(s) % 2 == 1:
        s = ""0"" + s
    print """".join(map(b2q.get,map(add,s[::2],s[1::2])))",1
p00176,"何色？
ウェブデザイナーを目指す太郎君はただいま修行中。事務所の先輩から「このページの背景色は#ffe085で」と、ウェブデザイン特有の色番号で指示されるのですが、それがどんな色かパッと思い浮かべることができません。
この色番号は光の三原色である赤、緑、青それぞれの強さを表わしています。具体的には2 桁の 16 進数を3 つ組み合わせたもので、色番号を“#RGB”とするとき、R は赤の強さ、G は緑の強さ、は青の強さを表します。それぞれ 00 から ff までの値になります。
色番号にまだ不慣れな太郎君のために、色番号を入力とし、色の表の中からもっとも近い色の名前
を出力するプログラムを作成してください。使用する色の表は以下の通りです。
色の名前
赤の強さ
緑の強さ
青の強さ
black
00
00
00
blue
00
00
ff
lime
00
ff
00
aqua
00
ff
ff
red
ff
00
00
fuchsia
ff
00
ff
yellow
ff
ff
00
white
ff
ff
ff
「もっとも近い色」とは、以下のように定義します。与えられた色番号での赤、緑、青の強さをそれぞれ
R
、
G
、
B
とし、表の
k
番目の色の赤、緑、青の強さをそれぞれ
R
k
、
G
k
、
B
k
とするとき、次の式で計算する
d
k
の値が最も小さい色がもっとも近い色とします。
なお、
d
k
の値が同じになる色が複数存在する場合は表の中でより上にある色がもっとも近い色になり
ます。
Input
複数のデータセットの並びが入力として与えられます。入力の終わりはゼロひとつの行で示されます。各データセットとして、色番号を表す文字列が、
#
RGB
形式で１行に与えられます。
データセットの数は 1000 を超えません。
Output
データセット毎に最も近い色の名前を１行に出力します。
Sample Input
#ffe085
#787878
#decade
#ff55ff
0
Output for the Sample Input
white
black
white
fuchsia",C,"#include <stdio.h>
#include <string.h>
#include <stdlib.h>

typedef struct {
    char name[10];
    int r, g, b;
} Color;

int main() {
    Color colors[8] = {
        {""black"", 0x00, 0x00, 0x00},
        {""blue"", 0x00, 0x00, 0xff},
        {""lime"", 0x00, 0xff, 0x00},
        {""aqua"", 0x00, 0xff, 0xff},
        {""red"", 0xff, 0x00, 0x00},
        {""fuchsia"", 0xff, 0x00, 0xff},
        {""yellow"", 0xff, 0xff, 0x00},
        {""white"", 0xff, 0xff, 0xff}
    };
    
    char input[10];
    
    while(1) {
        scanf(""%s"", input);
        if(input[0] == '0') break;
        
        int r, g, b;
        char rstr[3], gstr[3], bstr[3];
        
        rstr[0] = input[1];
        rstr[1] = input[2];
        rstr[2] = '\0';
        
        gstr[0] = input[3];
        gstr[1] = input[4];
        gstr[2] = '\0';
        
        bstr[0] = input[5];
        bstr[1] = input[6];
        bstr[2] = '\0';
        
        r = strtol(rstr, NULL, 16);
        g = strtol(gstr, NULL, 16);
        b = strtol(bstr, NULL, 16);
        
        int minDist = -1;
        int minIdx = 0;
        
        for(int i = 0; i < 8; i++) {
            int dr = r - colors[i].r;
            int dg = g - colors[i].g;
            int db = b - colors[i].b;
            int dist = dr*dr + dg*dg + db*db;
            
            if(minDist == -1 || dist < minDist) {
                minDist = dist;
                minIdx = i;
            }
        }
        
        printf(""%s\n"", colors[minIdx].name);
    }
    
    return 0;
}
",0
p00176,"何色？
ウェブデザイナーを目指す太郎君はただいま修行中。事務所の先輩から「このページの背景色は#ffe085で」と、ウェブデザイン特有の色番号で指示されるのですが、それがどんな色かパッと思い浮かべることができません。
この色番号は光の三原色である赤、緑、青それぞれの強さを表わしています。具体的には2 桁の 16 進数を3 つ組み合わせたもので、色番号を“#RGB”とするとき、R は赤の強さ、G は緑の強さ、は青の強さを表します。それぞれ 00 から ff までの値になります。
色番号にまだ不慣れな太郎君のために、色番号を入力とし、色の表の中からもっとも近い色の名前
を出力するプログラムを作成してください。使用する色の表は以下の通りです。
色の名前
赤の強さ
緑の強さ
青の強さ
black
00
00
00
blue
00
00
ff
lime
00
ff
00
aqua
00
ff
ff
red
ff
00
00
fuchsia
ff
00
ff
yellow
ff
ff
00
white
ff
ff
ff
「もっとも近い色」とは、以下のように定義します。与えられた色番号での赤、緑、青の強さをそれぞれ
R
、
G
、
B
とし、表の
k
番目の色の赤、緑、青の強さをそれぞれ
R
k
、
G
k
、
B
k
とするとき、次の式で計算する
d
k
の値が最も小さい色がもっとも近い色とします。
なお、
d
k
の値が同じになる色が複数存在する場合は表の中でより上にある色がもっとも近い色になり
ます。
Input
複数のデータセットの並びが入力として与えられます。入力の終わりはゼロひとつの行で示されます。各データセットとして、色番号を表す文字列が、
#
RGB
形式で１行に与えられます。
データセットの数は 1000 を超えません。
Output
データセット毎に最も近い色の名前を１行に出力します。
Sample Input
#ffe085
#787878
#decade
#ff55ff
0
Output for the Sample Input
white
black
white
fuchsia",C,"#include <stdio.h>
#include <string.h>
#include <stdlib.h>

int i,r,g,b,d,ans,best;
char col[8][15]={""black"",""blue"",""lime"",""aqua"",""red"",""fuchsia"",""yellow"",""white""};
char code[24];

int main(){
	while(1){
		scanf(""%s"",&code);
		if(code[0]=='0')break;
		sscanf(code,""#%2x%2x%2x"",&r,&g,&b);
		best=99999999;
		for(i=0;i<8;i++){
			d=(r-255*(i>3))*(r-255*(i>3))+(g-255*(i%4>1))*(g-255*(i%4>1))+(b-255*(i%2))*(b-255*(i%2));
			if(d<best){best=d;ans=i;}
		}
		printf(""%s\n"",col[ans]);
	}
	return 0;
}",1
p00176,"何色？
ウェブデザイナーを目指す太郎君はただいま修行中。事務所の先輩から「このページの背景色は#ffe085で」と、ウェブデザイン特有の色番号で指示されるのですが、それがどんな色かパッと思い浮かべることができません。
この色番号は光の三原色である赤、緑、青それぞれの強さを表わしています。具体的には2 桁の 16 進数を3 つ組み合わせたもので、色番号を“#RGB”とするとき、R は赤の強さ、G は緑の強さ、は青の強さを表します。それぞれ 00 から ff までの値になります。
色番号にまだ不慣れな太郎君のために、色番号を入力とし、色の表の中からもっとも近い色の名前
を出力するプログラムを作成してください。使用する色の表は以下の通りです。
色の名前
赤の強さ
緑の強さ
青の強さ
black
00
00
00
blue
00
00
ff
lime
00
ff
00
aqua
00
ff
ff
red
ff
00
00
fuchsia
ff
00
ff
yellow
ff
ff
00
white
ff
ff
ff
「もっとも近い色」とは、以下のように定義します。与えられた色番号での赤、緑、青の強さをそれぞれ
R
、
G
、
B
とし、表の
k
番目の色の赤、緑、青の強さをそれぞれ
R
k
、
G
k
、
B
k
とするとき、次の式で計算する
d
k
の値が最も小さい色がもっとも近い色とします。
なお、
d
k
の値が同じになる色が複数存在する場合は表の中でより上にある色がもっとも近い色になり
ます。
Input
複数のデータセットの並びが入力として与えられます。入力の終わりはゼロひとつの行で示されます。各データセットとして、色番号を表す文字列が、
#
RGB
形式で１行に与えられます。
データセットの数は 1000 を超えません。
Output
データセット毎に最も近い色の名前を１行に出力します。
Sample Input
#ffe085
#787878
#decade
#ff55ff
0
Output for the Sample Input
white
black
white
fuchsia",Java,"import java.util.Scanner;

public class Main {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        
        String[] colorNames = {""black"", ""blue"", ""lime"", ""aqua"", ""red"", ""fuchsia"", ""yellow"", ""white""};
        int[][] colorValues = {
            {0x00, 0x00, 0x00},  // black
            {0x00, 0x00, 0xff},  // blue
            {0x00, 0xff, 0x00},  // lime
            {0x00, 0xff, 0xff},  // aqua
            {0xff, 0x00, 0x00},  // red
            {0xff, 0x00, 0xff},  // fuchsia
            {0xff, 0xff, 0x00},  // yellow
            {0xff, 0xff, 0xff}   // white
        };
        
        while (true) {
            String input = sc.next();
            if (input.equals(""0"")) {
                break;
            }
            
            // Parse color code
            String colorCode = input.substring(1); // Remove '#'
            int r = Integer.parseInt(colorCode.substring(0, 2), 16);
            int g = Integer.parseInt(colorCode.substring(2, 4), 16);
            int b = Integer.parseInt(colorCode.substring(4, 6), 16);
            
            // Find closest color
            int minDistance = Integer.MAX_VALUE;
            String closestColor = """";
            
            for (int i = 0; i < colorNames.length; i++) {
                int rk = colorValues[i][0];
                int gk = colorValues[i][1];
                int bk = colorValues[i][2];
                
                int distance = (r - rk) * (r - rk) + (g - gk) * (g - gk) + (b - bk) * (b - bk);
                
                if (distance < minDistance) {
                    minDistance = distance;
                    closestColor = colorNames[i];
                }
            }
            
            System.out.println(closestColor);
        }
        
        sc.close();
    }
}
",0
p00176,"何色？
ウェブデザイナーを目指す太郎君はただいま修行中。事務所の先輩から「このページの背景色は#ffe085で」と、ウェブデザイン特有の色番号で指示されるのですが、それがどんな色かパッと思い浮かべることができません。
この色番号は光の三原色である赤、緑、青それぞれの強さを表わしています。具体的には2 桁の 16 進数を3 つ組み合わせたもので、色番号を“#RGB”とするとき、R は赤の強さ、G は緑の強さ、は青の強さを表します。それぞれ 00 から ff までの値になります。
色番号にまだ不慣れな太郎君のために、色番号を入力とし、色の表の中からもっとも近い色の名前
を出力するプログラムを作成してください。使用する色の表は以下の通りです。
色の名前
赤の強さ
緑の強さ
青の強さ
black
00
00
00
blue
00
00
ff
lime
00
ff
00
aqua
00
ff
ff
red
ff
00
00
fuchsia
ff
00
ff
yellow
ff
ff
00
white
ff
ff
ff
「もっとも近い色」とは、以下のように定義します。与えられた色番号での赤、緑、青の強さをそれぞれ
R
、
G
、
B
とし、表の
k
番目の色の赤、緑、青の強さをそれぞれ
R
k
、
G
k
、
B
k
とするとき、次の式で計算する
d
k
の値が最も小さい色がもっとも近い色とします。
なお、
d
k
の値が同じになる色が複数存在する場合は表の中でより上にある色がもっとも近い色になり
ます。
Input
複数のデータセットの並びが入力として与えられます。入力の終わりはゼロひとつの行で示されます。各データセットとして、色番号を表す文字列が、
#
RGB
形式で１行に与えられます。
データセットの数は 1000 を超えません。
Output
データセット毎に最も近い色の名前を１行に出力します。
Sample Input
#ffe085
#787878
#decade
#ff55ff
0
Output for the Sample Input
white
black
white
fuchsia",Java,"import java.util.Scanner;
import java.util.HashMap;
import java.util.Arrays;
class Main
{
	public static void main(String args[])
	{
		Scanner sc = new Scanner(System.in).useDelimiter(""[\n#]+"");
		while (true)
		{
			String str = sc.next();
			if (str.equals(""0"")) break;
			int rk = Integer.parseInt(str.substring(0, 2), 16);
			int gk = Integer.parseInt(str.substring(2, 4), 16);
			int bk = Integer.parseInt(str.substring(4, 6), 16);
			int d[] = new int[8];
			HashMap<Integer, String> map = new HashMap<Integer, String>();
			d[0] = (0x00 - rk) * (0x00 - rk)
					+ (0x00 - gk) * (0x00 - gk)
					+ (0x00 - bk) * (0x00 - bk);
			map.put(d[0], ""black"");
			d[1] = (0x00 - rk) * (0x00 - rk)
					+ (0x00 - gk) * (0x00 - gk)
					+ (0xff - bk) * (0xff - bk);
			map.put(d[1], ""blue"");
			d[2] = (0x00 - rk) * (0x00 - rk)
					+ (0xff - gk) * (0xff - gk)
					+ (0x00 - bk) * (0x00 - bk);
			map.put(d[2], ""lime"");
			d[3] = (0x00 - rk) * (0x00 - rk)
					+ (0xff - gk) * (0xff - gk)
					+ (0xff - bk) * (0xff - bk);
			map.put(d[3], ""aqua"");
			d[4] = (0xff - rk) * (0xff - rk)
					+ (0x00 - gk) * (0x00 - gk)
					+ (0x00 - bk) * (0x00 - bk);
			map.put(d[4], ""red"");
			d[5] = (0xff - rk) * (0xff - rk)
					+ (0x00 - gk) * (0x00 - gk)
					+ (0xff - bk) * (0xff - bk);
			map.put(d[5], ""fuchsia"");
			d[6] = (0xff - rk) * (0xff - rk)
					+ (0xff - gk) * (0xff - gk)
					+ (0x00 - bk) * (0x00 - bk);
			map.put(d[6], ""yellow"");
			d[7] = (0xff - rk) * (0xff - rk)
					+ (0xff - gk) * (0xff - gk)
					+ (0xff - bk) * (0xff - bk);
			map.put(d[7], ""white"");
			Arrays.sort(d);
			System.out.println(map.get(d[0]));
		}
	}
}",1
p00176,"何色？
ウェブデザイナーを目指す太郎君はただいま修行中。事務所の先輩から「このページの背景色は#ffe085で」と、ウェブデザイン特有の色番号で指示されるのですが、それがどんな色かパッと思い浮かべることができません。
この色番号は光の三原色である赤、緑、青それぞれの強さを表わしています。具体的には2 桁の 16 進数を3 つ組み合わせたもので、色番号を“#RGB”とするとき、R は赤の強さ、G は緑の強さ、は青の強さを表します。それぞれ 00 から ff までの値になります。
色番号にまだ不慣れな太郎君のために、色番号を入力とし、色の表の中からもっとも近い色の名前
を出力するプログラムを作成してください。使用する色の表は以下の通りです。
色の名前
赤の強さ
緑の強さ
青の強さ
black
00
00
00
blue
00
00
ff
lime
00
ff
00
aqua
00
ff
ff
red
ff
00
00
fuchsia
ff
00
ff
yellow
ff
ff
00
white
ff
ff
ff
「もっとも近い色」とは、以下のように定義します。与えられた色番号での赤、緑、青の強さをそれぞれ
R
、
G
、
B
とし、表の
k
番目の色の赤、緑、青の強さをそれぞれ
R
k
、
G
k
、
B
k
とするとき、次の式で計算する
d
k
の値が最も小さい色がもっとも近い色とします。
なお、
d
k
の値が同じになる色が複数存在する場合は表の中でより上にある色がもっとも近い色になり
ます。
Input
複数のデータセットの並びが入力として与えられます。入力の終わりはゼロひとつの行で示されます。各データセットとして、色番号を表す文字列が、
#
RGB
形式で１行に与えられます。
データセットの数は 1000 を超えません。
Output
データセット毎に最も近い色の名前を１行に出力します。
Sample Input
#ffe085
#787878
#decade
#ff55ff
0
Output for the Sample Input
white
black
white
fuchsia",Python,"import sys

colors = [
    (""black"", 0x00, 0x00, 0x00),
    (""blue"", 0x00, 0x00, 0xff),
    (""lime"", 0x00, 0xff, 0x00),
    (""aqua"", 0x00, 0xff, 0xff),
    (""red"", 0xff, 0x00, 0x00),
    (""fuchsia"", 0xff, 0x00, 0xff),
    (""yellow"", 0xff, 0xff, 0x00),
    (""white"", 0xff, 0xff, 0xff)
]

for line in sys.stdin:
    line = line.strip()
    if line == ""0"":
        break
    
    # Parse color code
    color_code = line[1:]  # Remove #
    R = int(color_code[0:2], 16)
    G = int(color_code[2:4], 16)
    B = int(color_code[4:6], 16)
    
    # Find closest color
    min_distance = float('inf')
    closest_color = """"
    
    for name, Rk, Gk, Bk in colors:
        dk = (R - Rk) ** 2 + (G - Gk) ** 2 + (B - Bk) ** 2
        if dk < min_distance:
            min_distance = dk
            closest_color = name
    
    print(closest_color)
",0
p00176,"何色？
ウェブデザイナーを目指す太郎君はただいま修行中。事務所の先輩から「このページの背景色は#ffe085で」と、ウェブデザイン特有の色番号で指示されるのですが、それがどんな色かパッと思い浮かべることができません。
この色番号は光の三原色である赤、緑、青それぞれの強さを表わしています。具体的には2 桁の 16 進数を3 つ組み合わせたもので、色番号を“#RGB”とするとき、R は赤の強さ、G は緑の強さ、は青の強さを表します。それぞれ 00 から ff までの値になります。
色番号にまだ不慣れな太郎君のために、色番号を入力とし、色の表の中からもっとも近い色の名前
を出力するプログラムを作成してください。使用する色の表は以下の通りです。
色の名前
赤の強さ
緑の強さ
青の強さ
black
00
00
00
blue
00
00
ff
lime
00
ff
00
aqua
00
ff
ff
red
ff
00
00
fuchsia
ff
00
ff
yellow
ff
ff
00
white
ff
ff
ff
「もっとも近い色」とは、以下のように定義します。与えられた色番号での赤、緑、青の強さをそれぞれ
R
、
G
、
B
とし、表の
k
番目の色の赤、緑、青の強さをそれぞれ
R
k
、
G
k
、
B
k
とするとき、次の式で計算する
d
k
の値が最も小さい色がもっとも近い色とします。
なお、
d
k
の値が同じになる色が複数存在する場合は表の中でより上にある色がもっとも近い色になり
ます。
Input
複数のデータセットの並びが入力として与えられます。入力の終わりはゼロひとつの行で示されます。各データセットとして、色番号を表す文字列が、
#
RGB
形式で１行に与えられます。
データセットの数は 1000 を超えません。
Output
データセット毎に最も近い色の名前を１行に出力します。
Sample Input
#ffe085
#787878
#decade
#ff55ff
0
Output for the Sample Input
white
black
white
fuchsia",Python,"import math
L=[
(""black"",00,00,00),
(""blue"",00,00,255),
(""lime"",00,255,00),
(""aqua"",00,255,255),
(""red"",255,00,00),
(""fuchsia"",255,00,255),
(""yellow"",255,255,00),
(""white"",255,255,255)]
while True:
    c=raw_input()
    if c==""0"":break
    Rk,Gk,Bk=int(c[1:3],16),int(c[3:5],16),int(c[5:7],16)
    m=10000
    for cl,r,g,b in L:
        t=math.sqrt(pow(r-Rk,2)+pow(g-Gk,2)+pow(b-Bk,2))
        if t<m:
            m=t
            color=cl
    print color",1
p00177,"２都市間の距離
地球上の2 都市の北緯と東経を入力とし、地表距離を計算して出力するプログラムを作成してください。ただし、地球は半径 6,378.1 km の球とし、2 点間の地表距離とはこの球面に沿った最短距離です。また、南半球でも南緯は用いずに北緯 0 ~ -90 度を用い、グリニッジ子午線の西でも西経は用いずに東経 180 ~ 360 度を用いることとします。地表距離は km 単位で求め、小数点以下は四捨五入し、整数値として出力してください。
以下に主要都市の北緯、東経の例を示します。
地名
北緯(度)
東経(度)
東京
35.68
139.77
シンガポール
1.37
103.92
シドニー
-33.95
151.18
シカゴ
41.78
272.25
ブエノスアイレス
-34.58
301.52
ロンドン
51.15
359.82
Input
複数のデータセットの並びが入力として与えられます。入力の終わりは-1 四つの行で示されます。各データセットは以下の形式で与えられます。
a
b
c
d
1 行に第 1 の都市の北緯
a
、第 1 の都市の東経
b
、第 2 の都市の北緯
c
、第 2 の都市の東経
d
が空白区切りで与えられます。入力はすべて実数で与えられます。
データセットの数は 30 を超えません。
Output
データセット毎に 2 都市の地表距離を１行に出力します。
Sample Input
35.68 139.77 51.15 359.82
1.37 103.92 41.78 272.25
51.15 359.82 -34.58 301.52
-1 -1 -1 -1
Output for the Sample Input
9609
15092
11112",C,"#include <stdio.h>
#include <math.h>

#define PI 3.14159265358979323846
#define RADIUS 6378.1

int main() {
    double a, b, c, d;
    
    while (1) {
        scanf(""%lf %lf %lf %lf"", &a, &b, &c, &d);
        
        if (a == -1 && b == -1 && c == -1 && d == -1) {
            break;
        }
        
        double lat1 = a * PI / 180.0;
        double lon1 = b * PI / 180.0;
        double lat2 = c * PI / 180.0;
        double lon2 = d * PI / 180.0;
        
        double x1 = RADIUS * cos(lat1) * cos(lon1);
        double y1 = RADIUS * cos(lat1) * sin(lon1);
        double z1 = RADIUS * sin(lat1);
        
        double x2 = RADIUS * cos(lat2) * cos(lon2);
        double y2 = RADIUS * cos(lat2) * sin(lon2);
        double z2 = RADIUS * sin(lat2);
        
        double chord = sqrt((x2-x1)*(x2-x1) + (y2-y1)*(y2-y1) + (z2-z1)*(z2-z1));
        
        double angle = 2.0 * asin(chord / (2.0 * RADIUS));
        
        double distance = RADIUS * angle;
        
        int result = (int)(distance + 0.5);
        
        printf(""%d\n"", result);
    }
    
    return 0;
}
",0
p00177,"２都市間の距離
地球上の2 都市の北緯と東経を入力とし、地表距離を計算して出力するプログラムを作成してください。ただし、地球は半径 6,378.1 km の球とし、2 点間の地表距離とはこの球面に沿った最短距離です。また、南半球でも南緯は用いずに北緯 0 ~ -90 度を用い、グリニッジ子午線の西でも西経は用いずに東経 180 ~ 360 度を用いることとします。地表距離は km 単位で求め、小数点以下は四捨五入し、整数値として出力してください。
以下に主要都市の北緯、東経の例を示します。
地名
北緯(度)
東経(度)
東京
35.68
139.77
シンガポール
1.37
103.92
シドニー
-33.95
151.18
シカゴ
41.78
272.25
ブエノスアイレス
-34.58
301.52
ロンドン
51.15
359.82
Input
複数のデータセットの並びが入力として与えられます。入力の終わりは-1 四つの行で示されます。各データセットは以下の形式で与えられます。
a
b
c
d
1 行に第 1 の都市の北緯
a
、第 1 の都市の東経
b
、第 2 の都市の北緯
c
、第 2 の都市の東経
d
が空白区切りで与えられます。入力はすべて実数で与えられます。
データセットの数は 30 を超えません。
Output
データセット毎に 2 都市の地表距離を１行に出力します。
Sample Input
35.68 139.77 51.15 359.82
1.37 103.92 41.78 272.25
51.15 359.82 -34.58 301.52
-1 -1 -1 -1
Output for the Sample Input
9609
15092
11112",C,"#include <stdio.h>
#include <math.h>
#define PI 3.141592653589793
#define r 6378.1
int main(void) {
	while(1){
		double a,b,c,d;
		scanf(""%lf %lf %lf %lf\n"",&a,&b,&c,&d);
		if(a==(-1)&&b==(-1)&&c==(-1)&&d==(-1)) break;
		double a1,b1,c1,d1;
		a1=a*PI/180.0;
		b1=b*PI/180.0;
		c1=c*PI/180.0;
		d1=d*PI/180.0;
		double e1,f;
		e1=d1-b1;
		f=r*acos((sin(a1)*sin(c1))+(cos(a1)*cos(c1)*cos(e1)));
		printf(""%.0f\n"",f);
	}
	return 0;
}
",1
p00177,"２都市間の距離
地球上の2 都市の北緯と東経を入力とし、地表距離を計算して出力するプログラムを作成してください。ただし、地球は半径 6,378.1 km の球とし、2 点間の地表距離とはこの球面に沿った最短距離です。また、南半球でも南緯は用いずに北緯 0 ~ -90 度を用い、グリニッジ子午線の西でも西経は用いずに東経 180 ~ 360 度を用いることとします。地表距離は km 単位で求め、小数点以下は四捨五入し、整数値として出力してください。
以下に主要都市の北緯、東経の例を示します。
地名
北緯(度)
東経(度)
東京
35.68
139.77
シンガポール
1.37
103.92
シドニー
-33.95
151.18
シカゴ
41.78
272.25
ブエノスアイレス
-34.58
301.52
ロンドン
51.15
359.82
Input
複数のデータセットの並びが入力として与えられます。入力の終わりは-1 四つの行で示されます。各データセットは以下の形式で与えられます。
a
b
c
d
1 行に第 1 の都市の北緯
a
、第 1 の都市の東経
b
、第 2 の都市の北緯
c
、第 2 の都市の東経
d
が空白区切りで与えられます。入力はすべて実数で与えられます。
データセットの数は 30 を超えません。
Output
データセット毎に 2 都市の地表距離を１行に出力します。
Sample Input
35.68 139.77 51.15 359.82
1.37 103.92 41.78 272.25
51.15 359.82 -34.58 301.52
-1 -1 -1 -1
Output for the Sample Input
9609
15092
11112",Java,"import java.util.Scanner;

public class Main {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        
        while (true) {
            double a = sc.nextDouble();
            double b = sc.nextDouble();
            double c = sc.nextDouble();
            double d = sc.nextDouble();
            
            if (a == -1 && b == -1 && c == -1 && d == -1) {
                break;
            }
            
            double lat1 = Math.toRadians(a);
            double lon1 = Math.toRadians(b);
            double lat2 = Math.toRadians(c);
            double lon2 = Math.toRadians(d);
            
            double radius = 6378.1;
            
            double centralAngle = Math.acos(
                Math.sin(lat1) * Math.sin(lat2) + 
                Math.cos(lat1) * Math.cos(lat2) * Math.cos(lon2 - lon1)
            );
            
            double distance = radius * centralAngle;
            
            long result = Math.round(distance);
            
            System.out.println(result);
        }
        
        sc.close();
    }
}
",0
p00177,"２都市間の距離
地球上の2 都市の北緯と東経を入力とし、地表距離を計算して出力するプログラムを作成してください。ただし、地球は半径 6,378.1 km の球とし、2 点間の地表距離とはこの球面に沿った最短距離です。また、南半球でも南緯は用いずに北緯 0 ~ -90 度を用い、グリニッジ子午線の西でも西経は用いずに東経 180 ~ 360 度を用いることとします。地表距離は km 単位で求め、小数点以下は四捨五入し、整数値として出力してください。
以下に主要都市の北緯、東経の例を示します。
地名
北緯(度)
東経(度)
東京
35.68
139.77
シンガポール
1.37
103.92
シドニー
-33.95
151.18
シカゴ
41.78
272.25
ブエノスアイレス
-34.58
301.52
ロンドン
51.15
359.82
Input
複数のデータセットの並びが入力として与えられます。入力の終わりは-1 四つの行で示されます。各データセットは以下の形式で与えられます。
a
b
c
d
1 行に第 1 の都市の北緯
a
、第 1 の都市の東経
b
、第 2 の都市の北緯
c
、第 2 の都市の東経
d
が空白区切りで与えられます。入力はすべて実数で与えられます。
データセットの数は 30 を超えません。
Output
データセット毎に 2 都市の地表距離を１行に出力します。
Sample Input
35.68 139.77 51.15 359.82
1.37 103.92 41.78 272.25
51.15 359.82 -34.58 301.52
-1 -1 -1 -1
Output for the Sample Input
9609
15092
11112",Java,"import java.util.*;
import java.lang.*;
import java.math.*;

public class Main {
	Scanner sc = new Scanner(System.in);
	void run(){
		for(;;){
			double a = sc.nextDouble();
			double b = sc.nextDouble();
			double c = sc.nextDouble();
			double d = sc.nextDouble();
			if((a==-1)&&(b==-1)&&(c==-1)&&(d==-1)){
				break;
			}
			
			double vz = Math.sin(Math.toRadians(a));
			double vx = Math.cos(Math.toRadians(a))*Math.cos(Math.toRadians(b));
			double vy = Math.cos(Math.toRadians(a))*Math.sin(Math.toRadians(b));

			double wz = Math.sin(Math.toRadians(c));
			double wx = Math.cos(Math.toRadians(c))*Math.cos(Math.toRadians(d));
			double wy = Math.cos(Math.toRadians(c))*Math.sin(Math.toRadians(d));

			double dot = vz*wz + vx*wx + vy * wy;
			double theta = Math.acos(dot);
			double R =6378.1;
			System.out.println((int)(R*theta+0.5));
		}
		
	}
	public static void main(String[] args){
		Main m = new Main();
		m.run();
	}
}",1
p00177,"２都市間の距離
地球上の2 都市の北緯と東経を入力とし、地表距離を計算して出力するプログラムを作成してください。ただし、地球は半径 6,378.1 km の球とし、2 点間の地表距離とはこの球面に沿った最短距離です。また、南半球でも南緯は用いずに北緯 0 ~ -90 度を用い、グリニッジ子午線の西でも西経は用いずに東経 180 ~ 360 度を用いることとします。地表距離は km 単位で求め、小数点以下は四捨五入し、整数値として出力してください。
以下に主要都市の北緯、東経の例を示します。
地名
北緯(度)
東経(度)
東京
35.68
139.77
シンガポール
1.37
103.92
シドニー
-33.95
151.18
シカゴ
41.78
272.25
ブエノスアイレス
-34.58
301.52
ロンドン
51.15
359.82
Input
複数のデータセットの並びが入力として与えられます。入力の終わりは-1 四つの行で示されます。各データセットは以下の形式で与えられます。
a
b
c
d
1 行に第 1 の都市の北緯
a
、第 1 の都市の東経
b
、第 2 の都市の北緯
c
、第 2 の都市の東経
d
が空白区切りで与えられます。入力はすべて実数で与えられます。
データセットの数は 30 を超えません。
Output
データセット毎に 2 都市の地表距離を１行に出力します。
Sample Input
35.68 139.77 51.15 359.82
1.37 103.92 41.78 272.25
51.15 359.82 -34.58 301.52
-1 -1 -1 -1
Output for the Sample Input
9609
15092
11112",Python,"import math

R = 6378.1

while True:
    line = input().split()
    a, b, c, d = map(float, line)
    
    if a == -1 and b == -1 and c == -1 and d == -1:
        break
    
    # Convert degrees to radians
    lat1 = math.radians(a)
    lon1 = math.radians(b)
    lat2 = math.radians(c)
    lon2 = math.radians(d)
    
    # Calculate great circle distance using spherical law of cosines
    # or using haversine formula for better numerical stability
    
    # Using spherical law of cosines:
    # d = R * arccos(sin(lat1)*sin(lat2) + cos(lat1)*cos(lat2)*cos(lon2-lon1))
    
    cos_angle = math.sin(lat1) * math.sin(lat2) + math.cos(lat1) * math.cos(lat2) * math.cos(lon2 - lon1)
    
    # Clamp to [-1, 1] to avoid numerical errors
    cos_angle = max(-1, min(1, cos_angle))
    
    angle = math.acos(cos_angle)
    distance = R * angle
    
    print(round(distance))
",0
p00177,"２都市間の距離
地球上の2 都市の北緯と東経を入力とし、地表距離を計算して出力するプログラムを作成してください。ただし、地球は半径 6,378.1 km の球とし、2 点間の地表距離とはこの球面に沿った最短距離です。また、南半球でも南緯は用いずに北緯 0 ~ -90 度を用い、グリニッジ子午線の西でも西経は用いずに東経 180 ~ 360 度を用いることとします。地表距離は km 単位で求め、小数点以下は四捨五入し、整数値として出力してください。
以下に主要都市の北緯、東経の例を示します。
地名
北緯(度)
東経(度)
東京
35.68
139.77
シンガポール
1.37
103.92
シドニー
-33.95
151.18
シカゴ
41.78
272.25
ブエノスアイレス
-34.58
301.52
ロンドン
51.15
359.82
Input
複数のデータセットの並びが入力として与えられます。入力の終わりは-1 四つの行で示されます。各データセットは以下の形式で与えられます。
a
b
c
d
1 行に第 1 の都市の北緯
a
、第 1 の都市の東経
b
、第 2 の都市の北緯
c
、第 2 の都市の東経
d
が空白区切りで与えられます。入力はすべて実数で与えられます。
データセットの数は 30 を超えません。
Output
データセット毎に 2 都市の地表距離を１行に出力します。
Sample Input
35.68 139.77 51.15 359.82
1.37 103.92 41.78 272.25
51.15 359.82 -34.58 301.52
-1 -1 -1 -1
Output for the Sample Input
9609
15092
11112",Python,"from math import acos,sin,cos,radians
while 1:
    a,b,c,d=map(float,input().split())
    if a==b==c==d==-1:break
    a,c=radians(a),radians(c)
    print(int(6378.1*acos(sin(a)*sin(c) + cos(a)*cos(c)*cos(radians(d)-radians(b)))+0.5))",1
p00178,"テトリス
テトリスは、落ちてくるブロックを盤面上に並べて消すゲームです。ここでは、それを少しアレンジしたゲームを考えましょう。
このゲームの盤面の大きさは横 5 コマで、出現するブロックがすべて入るだけの高さがあります。落ちてくるブロックは直線状で、横向き、縦向きの 2 種類があり、長さは 1 から 5 までの 5 種類です。
以下に例を示します。Step(イ) からStep(ホ)までの図はブロックが落ちて消えていく様子を表したものです。
Step(イ)から順にStep(ロ)、Step(ハ)と順に進んでいきます。
ブロックを落とすときに、Step(イ)のようにブロックのどこかが下に積んであるブロックに引っかかったときには、Step(ロ)のように落ちたブロックはその場所で止まります。また、ブロックを落とした結果、盤面の横一行の全てのコマにブロックが詰まった場合には、Step(ニ)で示されるように、その行のブロックが消えます。この後、消えた行の上にあるブロックが、そのままの形で1行下にしずみます(Step(ホ))。
1 ゲームは 1000 個以内のブロックが順に落ちてくることとします。例えば、落ちるブロックの長さが順番に横向き 4 コマ, 横向き 3 コマ, 縦向き 2 コマ, 縦向き 3 コマで、落ちる場所が左端から 1 コマ目、1 コマ目、4 コマ目、5 コマ目であった場合には、下図のStep(イ)~(ト)のように落ち、最後に残るブロックは 2 コマになります。
順番に落ちてくるブロックの情報を入力とし、全てのブロックが落ちた時に残るコマ数を出力するプログラムを作成してください。
Input
複数のデータセットの並びが入力として与えられます。入力の終わりはゼロひとつの行で示されます。各データセットは以下の形式で与えられます。
n
d
1
p
1
q
1
d
2
p
2
q
2
:
d
n
p
n
q
n
１行目にブロックの数
n
(1 ≤
n
≤ 1000) が与えられます。続く
n
行に
i
個目のブロックの向き
d
i
(1 または2)、ブロックの長さ
p
i
(1 ≤
p
i
≤ 5)、ブロックの位置
q
i
が与えられます。ブロックの向き
d
i
は 1 が横向きを、2 が縦向きを表します。ブロックの位置
q
i
は盤面上の左端から1 ~ 5 までの整数とし、横向きのブロックの場合は左端のコマの落ちる位置とします。
データセットの数は 20 を超えません。
Output
データセット毎に最後に残るブロックの占めるコマ数を１行に出力します。
Sample Input
4
1 4 1
1 3 1
2 2 4
2 3 5
1
1 5 1
7
2 2 2
1 4 1
2 1 3
1 4 1
1 1 1
2 5 5
1 4 2
0
Output for the Sample Input
2
0
6",C,"#include <stdio.h>
#include <string.h>

#define MAX_HEIGHT 10000
#define WIDTH 5

int grid[MAX_HEIGHT][WIDTH];

int getHeight(int col) {
    int h = 0;
    for (int i = 0; i < MAX_HEIGHT; i++) {
        if (grid[i][col] == 1) {
            h = i + 1;
        }
    }
    return h;
}

void dropBlock(int d, int p, int q) {
    q--; // Convert to 0-indexed
    
    if (d == 1) { // Horizontal
        // Find the highest point where the block can land
        int maxHeight = 0;
        for (int i = 0; i < p; i++) {
            int h = getHeight(q + i);
            if (h > maxHeight) {
                maxHeight = h;
            }
        }
        // Place the block
        for (int i = 0; i < p; i++) {
            grid[maxHeight][q + i] = 1;
        }
    } else { // Vertical (d == 2)
        int h = getHeight(q);
        // Place the block
        for (int i = 0; i < p; i++) {
            grid[h + i][q] = 1;
        }
    }
}

void removeFullRows() {
    int removed = 0;
    for (int row = 0; row < MAX_HEIGHT; row++) {
        int full = 1;
        for (int col = 0; col < WIDTH; col++) {
            if (grid[row][col] == 0) {
                full = 0;
                break;
            }
        }
        if (full) {
            // Mark row for removal
            for (int col = 0; col < WIDTH; col++) {
                grid[row][col] = 0;
            }
            // Shift everything above down
            for (int r = row; r < MAX_HEIGHT - 1; r++) {
                for (int col = 0; col < WIDTH; col++) {
                    grid[r][col] = grid[r + 1][col];
                }
            }
            for (int col = 0; col < WIDTH; col++) {
                grid[MAX_HEIGHT - 1][col] = 0;
            }
            row--; // Check this row again
        }
    }
}

int countBlocks() {
    int count = 0;
    for (int i = 0; i < MAX_HEIGHT; i++) {
        for (int j = 0; j < WIDTH; j++) {
            if (grid[i][j] == 1) {
                count++;
            }
        }
    }
    return count;
}

int main() {
    int n;
    while (scanf(""%d"", &n) == 1 && n != 0) {
        // Clear the grid
        memset(grid, 0, sizeof(grid));
        
        for (int i = 0; i < n; i++) {
            int d, p, q;
            scanf(""%d %d %d"", &d, &p, &q);
            dropBlock(d, p, q);
            removeFullRows();
        }
        
        printf(""%d\n"", countBlocks());
    }
    
    return 0;
}
",0
p00178,"テトリス
テトリスは、落ちてくるブロックを盤面上に並べて消すゲームです。ここでは、それを少しアレンジしたゲームを考えましょう。
このゲームの盤面の大きさは横 5 コマで、出現するブロックがすべて入るだけの高さがあります。落ちてくるブロックは直線状で、横向き、縦向きの 2 種類があり、長さは 1 から 5 までの 5 種類です。
以下に例を示します。Step(イ) からStep(ホ)までの図はブロックが落ちて消えていく様子を表したものです。
Step(イ)から順にStep(ロ)、Step(ハ)と順に進んでいきます。
ブロックを落とすときに、Step(イ)のようにブロックのどこかが下に積んであるブロックに引っかかったときには、Step(ロ)のように落ちたブロックはその場所で止まります。また、ブロックを落とした結果、盤面の横一行の全てのコマにブロックが詰まった場合には、Step(ニ)で示されるように、その行のブロックが消えます。この後、消えた行の上にあるブロックが、そのままの形で1行下にしずみます(Step(ホ))。
1 ゲームは 1000 個以内のブロックが順に落ちてくることとします。例えば、落ちるブロックの長さが順番に横向き 4 コマ, 横向き 3 コマ, 縦向き 2 コマ, 縦向き 3 コマで、落ちる場所が左端から 1 コマ目、1 コマ目、4 コマ目、5 コマ目であった場合には、下図のStep(イ)~(ト)のように落ち、最後に残るブロックは 2 コマになります。
順番に落ちてくるブロックの情報を入力とし、全てのブロックが落ちた時に残るコマ数を出力するプログラムを作成してください。
Input
複数のデータセットの並びが入力として与えられます。入力の終わりはゼロひとつの行で示されます。各データセットは以下の形式で与えられます。
n
d
1
p
1
q
1
d
2
p
2
q
2
:
d
n
p
n
q
n
１行目にブロックの数
n
(1 ≤
n
≤ 1000) が与えられます。続く
n
行に
i
個目のブロックの向き
d
i
(1 または2)、ブロックの長さ
p
i
(1 ≤
p
i
≤ 5)、ブロックの位置
q
i
が与えられます。ブロックの向き
d
i
は 1 が横向きを、2 が縦向きを表します。ブロックの位置
q
i
は盤面上の左端から1 ~ 5 までの整数とし、横向きのブロックの場合は左端のコマの落ちる位置とします。
データセットの数は 20 を超えません。
Output
データセット毎に最後に残るブロックの占めるコマ数を１行に出力します。
Sample Input
4
1 4 1
1 3 1
2 2 4
2 3 5
1
1 5 1
7
2 2 2
1 4 1
2 1 3
1 4 1
1 1 1
2 5 5
1 4 2
0
Output for the Sample Input
2
0
6",C,"n,d,p,q,m[9999],h;main(b){for(;~scanf(""%d"",&n),n;d&&printf(""%d\n"",p)){for(memset(m,d=0,39996);n--;){scanf(""%d%d%d"",&d,&p,&q);b=(d-2?~-(1<<p):1)<<q;for(h=9998;~h&&!(m[h]&b);h--)d-2?p=1:0;for(h++;p--;m[h]-62?h++:memmove(m+h,m+h+1,9998-h))m[h]|=b;}for(p=0,h=9999;h--;)for(b=m[h];q=-b&b;b-=q)p++;}}",1
p00178,"テトリス
テトリスは、落ちてくるブロックを盤面上に並べて消すゲームです。ここでは、それを少しアレンジしたゲームを考えましょう。
このゲームの盤面の大きさは横 5 コマで、出現するブロックがすべて入るだけの高さがあります。落ちてくるブロックは直線状で、横向き、縦向きの 2 種類があり、長さは 1 から 5 までの 5 種類です。
以下に例を示します。Step(イ) からStep(ホ)までの図はブロックが落ちて消えていく様子を表したものです。
Step(イ)から順にStep(ロ)、Step(ハ)と順に進んでいきます。
ブロックを落とすときに、Step(イ)のようにブロックのどこかが下に積んであるブロックに引っかかったときには、Step(ロ)のように落ちたブロックはその場所で止まります。また、ブロックを落とした結果、盤面の横一行の全てのコマにブロックが詰まった場合には、Step(ニ)で示されるように、その行のブロックが消えます。この後、消えた行の上にあるブロックが、そのままの形で1行下にしずみます(Step(ホ))。
1 ゲームは 1000 個以内のブロックが順に落ちてくることとします。例えば、落ちるブロックの長さが順番に横向き 4 コマ, 横向き 3 コマ, 縦向き 2 コマ, 縦向き 3 コマで、落ちる場所が左端から 1 コマ目、1 コマ目、4 コマ目、5 コマ目であった場合には、下図のStep(イ)~(ト)のように落ち、最後に残るブロックは 2 コマになります。
順番に落ちてくるブロックの情報を入力とし、全てのブロックが落ちた時に残るコマ数を出力するプログラムを作成してください。
Input
複数のデータセットの並びが入力として与えられます。入力の終わりはゼロひとつの行で示されます。各データセットは以下の形式で与えられます。
n
d
1
p
1
q
1
d
2
p
2
q
2
:
d
n
p
n
q
n
１行目にブロックの数
n
(1 ≤
n
≤ 1000) が与えられます。続く
n
行に
i
個目のブロックの向き
d
i
(1 または2)、ブロックの長さ
p
i
(1 ≤
p
i
≤ 5)、ブロックの位置
q
i
が与えられます。ブロックの向き
d
i
は 1 が横向きを、2 が縦向きを表します。ブロックの位置
q
i
は盤面上の左端から1 ~ 5 までの整数とし、横向きのブロックの場合は左端のコマの落ちる位置とします。
データセットの数は 20 を超えません。
Output
データセット毎に最後に残るブロックの占めるコマ数を１行に出力します。
Sample Input
4
1 4 1
1 3 1
2 2 4
2 3 5
1
1 5 1
7
2 2 2
1 4 1
2 1 3
1 4 1
1 1 1
2 5 5
1 4 2
0
Output for the Sample Input
2
0
6",Java,"import java.util.*;

public class Main {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        
        while (true) {
            int n = sc.nextInt();
            if (n == 0) break;
            
            int[][] board = new int[10000][5];
            int maxHeight = 0;
            
            for (int i = 0; i < n; i++) {
                int d = sc.nextInt();
                int p = sc.nextInt();
                int q = sc.nextInt() - 1;
                
                if (d == 1) {
                    int dropHeight = 0;
                    for (int col = q; col < q + p; col++) {
                        for (int row = 0; row < 10000; row++) {
                            if (board[row][col] == 1) {
                                dropHeight = Math.max(dropHeight, row + 1);
                                break;
                            }
                        }
                    }
                    
                    for (int col = q; col < q + p; col++) {
                        board[dropHeight][col] = 1;
                    }
                    maxHeight = Math.max(maxHeight, dropHeight + 1);
                } else {
                    int dropHeight = 0;
                    for (int row = 0; row < 10000; row++) {
                        if (board[row][q] == 1) {
                            dropHeight = row + 1;
                            break;
                        }
                    }
                    
                    for (int row = dropHeight; row < dropHeight + p; row++) {
                        board[row][q] = 1;
                    }
                    maxHeight = Math.max(maxHeight, dropHeight + p);
                }
                
                boolean cleared = true;
                while (cleared) {
                    cleared = false;
                    for (int row = 0; row < maxHeight; row++) {
                        boolean full = true;
                        for (int col = 0; col < 5; col++) {
                            if (board[row][col] == 0) {
                                full = false;
                                break;
                            }
                        }
                        
                        if (full) {
                            cleared = true;
                            for (int r = row; r < maxHeight - 1; r++) {
                                for (int col = 0; col < 5; col++) {
                                    board[r][col] = board[r + 1][col];
                                }
                            }
                            for (int col = 0; col < 5; col++) {
                                board[maxHeight - 1][col] = 0;
                            }
                            maxHeight--;
                            break;
                        }
                    }
                }
            }
            
            int count = 0;
            for (int row = 0; row < maxHeight; row++) {
                for (int col = 0; col < 5; col++) {
                    if (board[row][col] == 1) {
                        count++;
                    }
                }
            }
            
            System.out.println(count);
        }
        
        sc.close();
    }
}
",0
p00178,"テトリス
テトリスは、落ちてくるブロックを盤面上に並べて消すゲームです。ここでは、それを少しアレンジしたゲームを考えましょう。
このゲームの盤面の大きさは横 5 コマで、出現するブロックがすべて入るだけの高さがあります。落ちてくるブロックは直線状で、横向き、縦向きの 2 種類があり、長さは 1 から 5 までの 5 種類です。
以下に例を示します。Step(イ) からStep(ホ)までの図はブロックが落ちて消えていく様子を表したものです。
Step(イ)から順にStep(ロ)、Step(ハ)と順に進んでいきます。
ブロックを落とすときに、Step(イ)のようにブロックのどこかが下に積んであるブロックに引っかかったときには、Step(ロ)のように落ちたブロックはその場所で止まります。また、ブロックを落とした結果、盤面の横一行の全てのコマにブロックが詰まった場合には、Step(ニ)で示されるように、その行のブロックが消えます。この後、消えた行の上にあるブロックが、そのままの形で1行下にしずみます(Step(ホ))。
1 ゲームは 1000 個以内のブロックが順に落ちてくることとします。例えば、落ちるブロックの長さが順番に横向き 4 コマ, 横向き 3 コマ, 縦向き 2 コマ, 縦向き 3 コマで、落ちる場所が左端から 1 コマ目、1 コマ目、4 コマ目、5 コマ目であった場合には、下図のStep(イ)~(ト)のように落ち、最後に残るブロックは 2 コマになります。
順番に落ちてくるブロックの情報を入力とし、全てのブロックが落ちた時に残るコマ数を出力するプログラムを作成してください。
Input
複数のデータセットの並びが入力として与えられます。入力の終わりはゼロひとつの行で示されます。各データセットは以下の形式で与えられます。
n
d
1
p
1
q
1
d
2
p
2
q
2
:
d
n
p
n
q
n
１行目にブロックの数
n
(1 ≤
n
≤ 1000) が与えられます。続く
n
行に
i
個目のブロックの向き
d
i
(1 または2)、ブロックの長さ
p
i
(1 ≤
p
i
≤ 5)、ブロックの位置
q
i
が与えられます。ブロックの向き
d
i
は 1 が横向きを、2 が縦向きを表します。ブロックの位置
q
i
は盤面上の左端から1 ~ 5 までの整数とし、横向きのブロックの場合は左端のコマの落ちる位置とします。
データセットの数は 20 を超えません。
Output
データセット毎に最後に残るブロックの占めるコマ数を１行に出力します。
Sample Input
4
1 4 1
1 3 1
2 2 4
2 3 5
1
1 5 1
7
2 2 2
1 4 1
2 1 3
1 4 1
1 1 1
2 5 5
1 4 2
0
Output for the Sample Input
2
0
6",Java,"import java.util.Scanner;

//TETORIS
public class Main {

	public static void main(String[] args) {
		Scanner sc = new Scanner(System.in);
		while(true){
			int n = sc.nextInt();
			if(n==0)break;
			boolean[][] m = new boolean[5000][5];
			while(n--!=0){
				int d = sc.nextInt();
				int p = sc.nextInt();
				int q = sc.nextInt()-1;
				if(d==2){
					int k = 4999;
					while(k>=0&&!m[k][q])k--;
					k++;
					for(int i=k;i<k+p;i++)m[i][q]=true;
				}
				else{
					int k = 4999;
					while(true){
						boolean f = true;
						if(k>=0){
							for(int j=q;j<q+p;j++){
								if(m[k][j])f = false;
							}
						}
						if(!f||k==-1){
							k++;
							for(int j=q;j<q+p;j++)m[k][j]=true;
							break;
						}
						k--;
					}
				}
				boolean con = true;
				int k = 0;
				while(k<5000&&con){
					con = false;
					boolean t = true;
					for(int j=0;j<5;j++){
						if(m[k][j])con = true;
						else t = false;
					}
					if(t){
						boolean f = true;
						int i = k;
						while(i<5000&&f){
							f = false;
							for(int j=0;j<5;j++){
								if(m[i][j])f = true;
							}
							if(f){
								for(int j=0;j<5;j++){
									m[i][j] = m[i+1][j];
								}
							}
							i++;
						}
					}
					else k++;
				}
			}
			int s = 0;
			for(int i=0;i<5000;i++)for(int j=0;j<5;j++)s+=m[i][j]?1:0;
			System.out.println(s);
		}
	}
}",1
p00178,"テトリス
テトリスは、落ちてくるブロックを盤面上に並べて消すゲームです。ここでは、それを少しアレンジしたゲームを考えましょう。
このゲームの盤面の大きさは横 5 コマで、出現するブロックがすべて入るだけの高さがあります。落ちてくるブロックは直線状で、横向き、縦向きの 2 種類があり、長さは 1 から 5 までの 5 種類です。
以下に例を示します。Step(イ) からStep(ホ)までの図はブロックが落ちて消えていく様子を表したものです。
Step(イ)から順にStep(ロ)、Step(ハ)と順に進んでいきます。
ブロックを落とすときに、Step(イ)のようにブロックのどこかが下に積んであるブロックに引っかかったときには、Step(ロ)のように落ちたブロックはその場所で止まります。また、ブロックを落とした結果、盤面の横一行の全てのコマにブロックが詰まった場合には、Step(ニ)で示されるように、その行のブロックが消えます。この後、消えた行の上にあるブロックが、そのままの形で1行下にしずみます(Step(ホ))。
1 ゲームは 1000 個以内のブロックが順に落ちてくることとします。例えば、落ちるブロックの長さが順番に横向き 4 コマ, 横向き 3 コマ, 縦向き 2 コマ, 縦向き 3 コマで、落ちる場所が左端から 1 コマ目、1 コマ目、4 コマ目、5 コマ目であった場合には、下図のStep(イ)~(ト)のように落ち、最後に残るブロックは 2 コマになります。
順番に落ちてくるブロックの情報を入力とし、全てのブロックが落ちた時に残るコマ数を出力するプログラムを作成してください。
Input
複数のデータセットの並びが入力として与えられます。入力の終わりはゼロひとつの行で示されます。各データセットは以下の形式で与えられます。
n
d
1
p
1
q
1
d
2
p
2
q
2
:
d
n
p
n
q
n
１行目にブロックの数
n
(1 ≤
n
≤ 1000) が与えられます。続く
n
行に
i
個目のブロックの向き
d
i
(1 または2)、ブロックの長さ
p
i
(1 ≤
p
i
≤ 5)、ブロックの位置
q
i
が与えられます。ブロックの向き
d
i
は 1 が横向きを、2 が縦向きを表します。ブロックの位置
q
i
は盤面上の左端から1 ~ 5 までの整数とし、横向きのブロックの場合は左端のコマの落ちる位置とします。
データセットの数は 20 を超えません。
Output
データセット毎に最後に残るブロックの占めるコマ数を１行に出力します。
Sample Input
4
1 4 1
1 3 1
2 2 4
2 3 5
1
1 5 1
7
2 2 2
1 4 1
2 1 3
1 4 1
1 1 1
2 5 5
1 4 2
0
Output for the Sample Input
2
0
6",Python,"def solve():
    while True:
        n = int(input())
        if n == 0:
            break
        
        # Board: 5 columns, use a list to store heights at each column
        # We'll use a grid representation where grid[row][col] tells if there's a block
        grid = []  # Will grow as needed, grid[0] is bottom
        
        for _ in range(n):
            d, p, q = map(int, input().split())
            q -= 1  # Convert to 0-indexed
            
            if d == 1:  # Horizontal block
                # Find the maximum height among columns q to q+p-1
                max_height = 0
                for col in range(q, q + p):
                    # Find height of column col
                    h = 0
                    for row in range(len(grid)):
                        if grid[row][col]:
                            h = row + 1
                    max_height = max(max_height, h)
                
                # Place block at row max_height
                while len(grid) <= max_height:
                    grid.append([False] * 5)
                
                for col in range(q, q + p):
                    grid[max_height][col] = True
                    
            else:  # Vertical block (d == 2)
                # Find height of column q
                height = 0
                for row in range(len(grid)):
                    if grid[row][q]:
                        height = row + 1
                
                # Place block from row height to height+p-1
                while len(grid) < height + p:
                    grid.append([False] * 5)
                
                for row in range(height, height + p):
                    grid[row][q] = True
            
            # Check for complete rows and remove them
            rows_to_remove = []
            for row_idx in range(len(grid)):
                if all(grid[row_idx]):
                    rows_to_remove.append(row_idx)
            
            # Remove complete rows (from top to bottom to maintain indices)
            for row_idx in reversed(rows_to_remove):
                grid.pop(row_idx)
        
        # Count remaining blocks
        count = 0
        for row in grid:
            count += sum(row)
        
        print(count)

solve()
",0
p00178,"テトリス
テトリスは、落ちてくるブロックを盤面上に並べて消すゲームです。ここでは、それを少しアレンジしたゲームを考えましょう。
このゲームの盤面の大きさは横 5 コマで、出現するブロックがすべて入るだけの高さがあります。落ちてくるブロックは直線状で、横向き、縦向きの 2 種類があり、長さは 1 から 5 までの 5 種類です。
以下に例を示します。Step(イ) からStep(ホ)までの図はブロックが落ちて消えていく様子を表したものです。
Step(イ)から順にStep(ロ)、Step(ハ)と順に進んでいきます。
ブロックを落とすときに、Step(イ)のようにブロックのどこかが下に積んであるブロックに引っかかったときには、Step(ロ)のように落ちたブロックはその場所で止まります。また、ブロックを落とした結果、盤面の横一行の全てのコマにブロックが詰まった場合には、Step(ニ)で示されるように、その行のブロックが消えます。この後、消えた行の上にあるブロックが、そのままの形で1行下にしずみます(Step(ホ))。
1 ゲームは 1000 個以内のブロックが順に落ちてくることとします。例えば、落ちるブロックの長さが順番に横向き 4 コマ, 横向き 3 コマ, 縦向き 2 コマ, 縦向き 3 コマで、落ちる場所が左端から 1 コマ目、1 コマ目、4 コマ目、5 コマ目であった場合には、下図のStep(イ)~(ト)のように落ち、最後に残るブロックは 2 コマになります。
順番に落ちてくるブロックの情報を入力とし、全てのブロックが落ちた時に残るコマ数を出力するプログラムを作成してください。
Input
複数のデータセットの並びが入力として与えられます。入力の終わりはゼロひとつの行で示されます。各データセットは以下の形式で与えられます。
n
d
1
p
1
q
1
d
2
p
2
q
2
:
d
n
p
n
q
n
１行目にブロックの数
n
(1 ≤
n
≤ 1000) が与えられます。続く
n
行に
i
個目のブロックの向き
d
i
(1 または2)、ブロックの長さ
p
i
(1 ≤
p
i
≤ 5)、ブロックの位置
q
i
が与えられます。ブロックの向き
d
i
は 1 が横向きを、2 が縦向きを表します。ブロックの位置
q
i
は盤面上の左端から1 ~ 5 までの整数とし、横向きのブロックの場合は左端のコマの落ちる位置とします。
データセットの数は 20 を超えません。
Output
データセット毎に最後に残るブロックの占めるコマ数を１行に出力します。
Sample Input
4
1 4 1
1 3 1
2 2 4
2 3 5
1
1 5 1
7
2 2 2
1 4 1
2 1 3
1 4 1
1 1 1
2 5 5
1 4 2
0
Output for the Sample Input
2
0
6",Python,"#!/usr/local/bin/python
from itertools import islice

def init():
    return [[None] * 5] * 5000

N = 4

while True:
    #N = int(input())
    if N == 0:
        break
    d, l, pos = [int(n) for n in raw_input().split()]
    lst = init()
    flwr = 0
    for i in xrange(N):
        print d, l, pos
        # if d == 1:
        #     for i in xrange(l):
        #         lst[flwr][pos-1 + i] = 1
        # else:
        #     tmp = 0
        #     for i in xrange(l):
        #         lst[flwr + tmp][pos-1] = 1
        #         tmp += 1
        #print lst[flwr]
        #print not None in lst[flwr]
        if not None in lst[flwr]:
            flwr += 1
    ret = 0
    for i in xrange(flwr):
        ret += len([i for i in lst[i] if not None])
    #print ret
    N -= 1
    break",1
p00179,"ふしぎな虫
会津生物学研究所のA博士は、とある南の島でふしぎな虫を発見しました。形は芋虫のように細長いのですが、ひとつの体節が玉のような形をしているので、糸でつないだビーズ玉のように見えます。ふしぎなのは体の色に様々なバリエーションがあることと、なかには時間がたつにつれて体の色が変っていく虫がいることでした。どの虫の体節の色も赤か緑か青のどれかに限られるようですが、1 秒ごとに体節の色が変わっていき、最後にはすべての体節が同じ色になって落ち着く場合もあれば、いつまで待ってもずっと色が変わりつづける場合もあるようでした。
調べていくうちに、ふだんはすべての体節が同じ色をしているのですが、何かに驚いたりして興奮した後は体節の色が勝手に変わってしまうことがわかりました。一度体節の色が変わってしまうと、ふたたびすべての体節が同じ色になるまではずっと色が変わり続けることがわかりました。
A博士はこの虫を何匹も捕まえて興奮させてみては、色が変わる様子を興味深く観察していましたが、やがて色が変化している最中の色の変わり方には次のような規則性があることに気がつきました。
色が変わるのは、隣り合っている色違いの 2つの体節のペア 1組だけが変わり、他の体節の色は変わらない。ただし、そのようなペアが複数あるときに、どのペアの色が変わるかはあらかじめ予測できない。
そのようなペアは、2つの体節の色のどちらでもない色に同時に変わる(たとえば、緑と赤の体節が隣り合っているときは、それらが同時に青に変わる)。
虫の色の変化を、2秒後まですべて書いたものが上の図です。図の上段のような色をした虫がいるとします。このとき、隣り合った色違いの体節のペアは 3組あるので、1秒後には中段に並べて描いた 3通りの色のどれかに変わります。1秒後に中段左側の 2つのように変わったときには、2秒後にすべての体節が緑色になることができます(図の下段の左側から 2番目)。 それに対して、1秒後に中段の1番右のように変わったときには、2秒後にすべての体節が同じ色に変わることはありません。
博士は、目の前にいる虫の体節がすべて同じ色になる可能性があるのか、あるとしたらそうなるのは最短で何秒後なのかを予測することにしました。
目の前にいる虫の体節の色の並びを入力とし、その虫の体節がすべて同じ色になるのに要する最短の時間を秒単位で出力するプログラムを作成してください。ただし、同じ色になる可能性がないときは「NA(半角英大文字)」と出力してください。また、虫の体節の色の並びは2  以上 10 以下のr(赤)、g(緑)、b(青)からなる文字列で表されます。
Input
複数のデータセットの並びが入力として与えられます。入力の終わりはゼロひとつの行で示されま
す。各データセットとして、 虫の体節の情報を表す１つの文字列が１行に与えられます。
データセットの数は 100 を超えません。
Output
データセット毎に、すべての体節の色が同じになるまでに要する最小時間 (秒単位の整数) または NA を１行に出力します。
Sample Input
rbgrg
rbbgbbr
bgr
bgrbrgbr
bggrgbgrr
gbrggrbggr
rrrrr
bgbr
0
Output for the Sample Input
5
7
1
6
NA
8
0
4",C,"#include <stdio.h>
#include <string.h>
#include <stdlib.h>

#define MAX_LEN 11
#define MAX_QUEUE 100000

typedef struct {
    char state[MAX_LEN];
    int steps;
} QueueItem;

typedef struct {
    char state[MAX_LEN];
} HashItem;

HashItem visited[MAX_QUEUE];
int visited_count;

int hash_string(char* s) {
    int h = 0;
    for (int i = 0; s[i]; i++) {
        h = h * 31 + s[i];
    }
    return abs(h) % MAX_QUEUE;
}

int is_visited(char* s) {
    for (int i = 0; i < visited_count; i++) {
        if (strcmp(visited[i].state, s) == 0) {
            return 1;
        }
    }
    return 0;
}

void add_visited(char* s) {
    strcpy(visited[visited_count].state, s);
    visited_count++;
}

int is_uniform(char* s) {
    char first = s[0];
    for (int i = 1; s[i]; i++) {
        if (s[i] != first) return 0;
    }
    return 1;
}

char get_third_color(char a, char b) {
    if ((a == 'r' && b == 'g') || (a == 'g' && b == 'r')) return 'b';
    if ((a == 'r' && b == 'b') || (a == 'b' && b == 'r')) return 'g';
    if ((a == 'g' && b == 'b') || (a == 'b' && b == 'g')) return 'r';
    return a;
}

int solve(char* initial) {
    if (is_uniform(initial)) return 0;
    
    QueueItem queue[MAX_QUEUE];
    int front = 0, rear = 0;
    
    visited_count = 0;
    strcpy(queue[rear].state, initial);
    queue[rear].steps = 0;
    rear++;
    add_visited(initial);
    
    while (front < rear) {
        QueueItem current = queue[front++];
        
        int len = strlen(current.state);
        
        for (int i = 0; i < len - 1; i++) {
            if (current.state[i] != current.state[i+1]) {
                char new_state[MAX_LEN];
                strcpy(new_state, current.state);
                
                char new_color = get_third_color(current.state[i], current.state[i+1]);
                new_state[i] = new_color;
                new_state[i+1] = new_color;
                
                if (is_uniform(new_state)) {
                    return current.steps + 1;
                }
                
                if (!is_visited(new_state) && rear < MAX_QUEUE) {
                    strcpy(queue[rear].state, new_state);
                    queue[rear].steps = current.steps + 1;
                    rear++;
                    add_visited(new_state);
                }
            }
        }
    }
    
    return -1;
}

int main() {
    char input[MAX_LEN];
    
    while (1) {
        scanf(""%s"", input);
        if (strcmp(input, ""0"") == 0) break;
        
        int result = solve(input);
        
        if (result == -1) {
            printf(""NA\n"");
        } else {
            printf(""%d\n"", result);
        }
    }
    
    return 0;
}
",0
p00179,"ふしぎな虫
会津生物学研究所のA博士は、とある南の島でふしぎな虫を発見しました。形は芋虫のように細長いのですが、ひとつの体節が玉のような形をしているので、糸でつないだビーズ玉のように見えます。ふしぎなのは体の色に様々なバリエーションがあることと、なかには時間がたつにつれて体の色が変っていく虫がいることでした。どの虫の体節の色も赤か緑か青のどれかに限られるようですが、1 秒ごとに体節の色が変わっていき、最後にはすべての体節が同じ色になって落ち着く場合もあれば、いつまで待ってもずっと色が変わりつづける場合もあるようでした。
調べていくうちに、ふだんはすべての体節が同じ色をしているのですが、何かに驚いたりして興奮した後は体節の色が勝手に変わってしまうことがわかりました。一度体節の色が変わってしまうと、ふたたびすべての体節が同じ色になるまではずっと色が変わり続けることがわかりました。
A博士はこの虫を何匹も捕まえて興奮させてみては、色が変わる様子を興味深く観察していましたが、やがて色が変化している最中の色の変わり方には次のような規則性があることに気がつきました。
色が変わるのは、隣り合っている色違いの 2つの体節のペア 1組だけが変わり、他の体節の色は変わらない。ただし、そのようなペアが複数あるときに、どのペアの色が変わるかはあらかじめ予測できない。
そのようなペアは、2つの体節の色のどちらでもない色に同時に変わる(たとえば、緑と赤の体節が隣り合っているときは、それらが同時に青に変わる)。
虫の色の変化を、2秒後まですべて書いたものが上の図です。図の上段のような色をした虫がいるとします。このとき、隣り合った色違いの体節のペアは 3組あるので、1秒後には中段に並べて描いた 3通りの色のどれかに変わります。1秒後に中段左側の 2つのように変わったときには、2秒後にすべての体節が緑色になることができます(図の下段の左側から 2番目)。 それに対して、1秒後に中段の1番右のように変わったときには、2秒後にすべての体節が同じ色に変わることはありません。
博士は、目の前にいる虫の体節がすべて同じ色になる可能性があるのか、あるとしたらそうなるのは最短で何秒後なのかを予測することにしました。
目の前にいる虫の体節の色の並びを入力とし、その虫の体節がすべて同じ色になるのに要する最短の時間を秒単位で出力するプログラムを作成してください。ただし、同じ色になる可能性がないときは「NA(半角英大文字)」と出力してください。また、虫の体節の色の並びは2  以上 10 以下のr(赤)、g(緑)、b(青)からなる文字列で表されます。
Input
複数のデータセットの並びが入力として与えられます。入力の終わりはゼロひとつの行で示されま
す。各データセットとして、 虫の体節の情報を表す１つの文字列が１行に与えられます。
データセットの数は 100 を超えません。
Output
データセット毎に、すべての体節の色が同じになるまでに要する最小時間 (秒単位の整数) または NA を１行に出力します。
Sample Input
rbgrg
rbbgbbr
bgr
bgrbrgbr
bggrgbgrr
gbrggrbggr
rrrrr
bgbr
0
Output for the Sample Input
5
7
1
6
NA
8
0
4",C,"// Aizu Vol-1 0179: Mysterious Worm
// 2017.8.22 bal4u@uu

#include <stdio.h>
#include <string.h>

#define MAX 0xaaaaa
char chk[MAX+10];
int Q[MAX+10], *top, *end, *qmax = Q + MAX;
int N, K, mask;

int nxt[16] = { 0, 10, 5, 0, 10, 5, 0, 0, 5, 0, 10 };

int main()
{
	int s, r, g, b, step;
	int i, k;
	char buf[15], *bp;

	while (1) {
		scanf(""%s"", buf); if (buf[0] == '0') break;
		memset(chk, 0, sizeof(chk));
		for (N = s = 0, bp = buf; *bp; bp++, N += 2) {
			if      (*bp == 'r') k = 0;
			else if (*bp == 'g') k = 1;
			else                 k = 2;
			s = (s << 2) | k;
		}
		mask = (1 << N) - 1, r = 0, g = 0x55555 & mask, b = 0xaaaaa & mask;
		top = end = Q;
		*end++ = s, *end++ = -1, chk[s] = 1, step = 0, K = N-4;
		while (top < end) {
			s = *top; if (++top >= qmax) top = Q;
			if (s < 0) { step++, *end = -1; if (++end >= qmax) end = Q; continue; }
			if (s == r || s == g || s == b) { printf(""%d\n"", step); break; }
			for (i = 0; i <= K; i += 2) {
				int s2, k2;
				k = (s >> i) & 0xf;
				k2 = nxt[k];
				if (k2 == k) continue;
				s2 = (s & ~(0xf << i)) | (k2 << i);
				if (!chk[s2]) { chk[s2] = 1, *end = s2; if (++end >= qmax) end = Q; }
			}
		}
		if (top >= end) puts(""NA"");
	}
	return 0;
}",1
p00179,"ふしぎな虫
会津生物学研究所のA博士は、とある南の島でふしぎな虫を発見しました。形は芋虫のように細長いのですが、ひとつの体節が玉のような形をしているので、糸でつないだビーズ玉のように見えます。ふしぎなのは体の色に様々なバリエーションがあることと、なかには時間がたつにつれて体の色が変っていく虫がいることでした。どの虫の体節の色も赤か緑か青のどれかに限られるようですが、1 秒ごとに体節の色が変わっていき、最後にはすべての体節が同じ色になって落ち着く場合もあれば、いつまで待ってもずっと色が変わりつづける場合もあるようでした。
調べていくうちに、ふだんはすべての体節が同じ色をしているのですが、何かに驚いたりして興奮した後は体節の色が勝手に変わってしまうことがわかりました。一度体節の色が変わってしまうと、ふたたびすべての体節が同じ色になるまではずっと色が変わり続けることがわかりました。
A博士はこの虫を何匹も捕まえて興奮させてみては、色が変わる様子を興味深く観察していましたが、やがて色が変化している最中の色の変わり方には次のような規則性があることに気がつきました。
色が変わるのは、隣り合っている色違いの 2つの体節のペア 1組だけが変わり、他の体節の色は変わらない。ただし、そのようなペアが複数あるときに、どのペアの色が変わるかはあらかじめ予測できない。
そのようなペアは、2つの体節の色のどちらでもない色に同時に変わる(たとえば、緑と赤の体節が隣り合っているときは、それらが同時に青に変わる)。
虫の色の変化を、2秒後まですべて書いたものが上の図です。図の上段のような色をした虫がいるとします。このとき、隣り合った色違いの体節のペアは 3組あるので、1秒後には中段に並べて描いた 3通りの色のどれかに変わります。1秒後に中段左側の 2つのように変わったときには、2秒後にすべての体節が緑色になることができます(図の下段の左側から 2番目)。 それに対して、1秒後に中段の1番右のように変わったときには、2秒後にすべての体節が同じ色に変わることはありません。
博士は、目の前にいる虫の体節がすべて同じ色になる可能性があるのか、あるとしたらそうなるのは最短で何秒後なのかを予測することにしました。
目の前にいる虫の体節の色の並びを入力とし、その虫の体節がすべて同じ色になるのに要する最短の時間を秒単位で出力するプログラムを作成してください。ただし、同じ色になる可能性がないときは「NA(半角英大文字)」と出力してください。また、虫の体節の色の並びは2  以上 10 以下のr(赤)、g(緑)、b(青)からなる文字列で表されます。
Input
複数のデータセットの並びが入力として与えられます。入力の終わりはゼロひとつの行で示されま
す。各データセットとして、 虫の体節の情報を表す１つの文字列が１行に与えられます。
データセットの数は 100 を超えません。
Output
データセット毎に、すべての体節の色が同じになるまでに要する最小時間 (秒単位の整数) または NA を１行に出力します。
Sample Input
rbgrg
rbbgbbr
bgr
bgrbrgbr
bggrgbgrr
gbrggrbggr
rrrrr
bgbr
0
Output for the Sample Input
5
7
1
6
NA
8
0
4",Java,"import java.util.*;

public class Main {
    static class State {
        String config;
        int steps;
        
        State(String config, int steps) {
            this.config = config;
            this.steps = steps;
        }
    }
    
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        
        while (true) {
            String input = sc.next();
            if (input.equals(""0"")) break;
            
            int result = solve(input);
            if (result == -1) {
                System.out.println(""NA"");
            } else {
                System.out.println(result);
            }
        }
        sc.close();
    }
    
    static int solve(String initial) {
        if (isUniform(initial)) {
            return 0;
        }
        
        Queue<State> queue = new LinkedList<>();
        Set<String> visited = new HashSet<>();
        
        queue.offer(new State(initial, 0));
        visited.add(initial);
        
        while (!queue.isEmpty()) {
            State current = queue.poll();
            String config = current.config;
            int steps = current.steps;
            
            // Find all adjacent pairs with different colors
            for (int i = 0; i < config.length() - 1; i++) {
                if (config.charAt(i) != config.charAt(i + 1)) {
                    // Change this pair to the third color
                    char newColor = getThirdColor(config.charAt(i), config.charAt(i + 1));
                    String newConfig = config.substring(0, i) + newColor + newColor + config.substring(i + 2);
                    
                    if (isUniform(newConfig)) {
                        return steps + 1;
                    }
                    
                    if (!visited.contains(newConfig)) {
                        visited.add(newConfig);
                        queue.offer(new State(newConfig, steps + 1));
                    }
                }
            }
        }
        
        return -1;
    }
    
    static boolean isUniform(String s) {
        if (s.length() == 0) return true;
        char first = s.charAt(0);
        for (int i = 1; i < s.length(); i++) {
            if (s.charAt(i) != first) return false;
        }
        return true;
    }
    
    static char getThirdColor(char c1, char c2) {
        if ((c1 == 'r' && c2 == 'g') || (c1 == 'g' && c2 == 'r')) return 'b';
        if ((c1 == 'r' && c2 == 'b') || (c1 == 'b' && c2 == 'r')) return 'g';
        if ((c1 == 'g' && c2 == 'b') || (c1 == 'b' && c2 == 'g')) return 'r';
        return c1; // Should not happen
    }
}
",0
p00179,"ふしぎな虫
会津生物学研究所のA博士は、とある南の島でふしぎな虫を発見しました。形は芋虫のように細長いのですが、ひとつの体節が玉のような形をしているので、糸でつないだビーズ玉のように見えます。ふしぎなのは体の色に様々なバリエーションがあることと、なかには時間がたつにつれて体の色が変っていく虫がいることでした。どの虫の体節の色も赤か緑か青のどれかに限られるようですが、1 秒ごとに体節の色が変わっていき、最後にはすべての体節が同じ色になって落ち着く場合もあれば、いつまで待ってもずっと色が変わりつづける場合もあるようでした。
調べていくうちに、ふだんはすべての体節が同じ色をしているのですが、何かに驚いたりして興奮した後は体節の色が勝手に変わってしまうことがわかりました。一度体節の色が変わってしまうと、ふたたびすべての体節が同じ色になるまではずっと色が変わり続けることがわかりました。
A博士はこの虫を何匹も捕まえて興奮させてみては、色が変わる様子を興味深く観察していましたが、やがて色が変化している最中の色の変わり方には次のような規則性があることに気がつきました。
色が変わるのは、隣り合っている色違いの 2つの体節のペア 1組だけが変わり、他の体節の色は変わらない。ただし、そのようなペアが複数あるときに、どのペアの色が変わるかはあらかじめ予測できない。
そのようなペアは、2つの体節の色のどちらでもない色に同時に変わる(たとえば、緑と赤の体節が隣り合っているときは、それらが同時に青に変わる)。
虫の色の変化を、2秒後まですべて書いたものが上の図です。図の上段のような色をした虫がいるとします。このとき、隣り合った色違いの体節のペアは 3組あるので、1秒後には中段に並べて描いた 3通りの色のどれかに変わります。1秒後に中段左側の 2つのように変わったときには、2秒後にすべての体節が緑色になることができます(図の下段の左側から 2番目)。 それに対して、1秒後に中段の1番右のように変わったときには、2秒後にすべての体節が同じ色に変わることはありません。
博士は、目の前にいる虫の体節がすべて同じ色になる可能性があるのか、あるとしたらそうなるのは最短で何秒後なのかを予測することにしました。
目の前にいる虫の体節の色の並びを入力とし、その虫の体節がすべて同じ色になるのに要する最短の時間を秒単位で出力するプログラムを作成してください。ただし、同じ色になる可能性がないときは「NA(半角英大文字)」と出力してください。また、虫の体節の色の並びは2  以上 10 以下のr(赤)、g(緑)、b(青)からなる文字列で表されます。
Input
複数のデータセットの並びが入力として与えられます。入力の終わりはゼロひとつの行で示されま
す。各データセットとして、 虫の体節の情報を表す１つの文字列が１行に与えられます。
データセットの数は 100 を超えません。
Output
データセット毎に、すべての体節の色が同じになるまでに要する最小時間 (秒単位の整数) または NA を１行に出力します。
Sample Input
rbgrg
rbbgbbr
bgr
bgrbrgbr
bggrgbgrr
gbrggrbggr
rrrrr
bgbr
0
Output for the Sample Input
5
7
1
6
NA
8
0
4",Java,"import java.awt.geom.Point2D;
import java.util.*;


public class Main {
	Scanner in = new Scanner(System.in);
	public static void main(String[] args) {
		new Main();
	}
	public Main() {

		new AOJ0179();


	}

	class AOJ0179{
		public AOJ0179() {
			while(true){
				String warm = in.next();
				if(warm.equals(""0""))break;
				int ans = get_warm(warm);
				System.out.println(ans==-1? ""NA"":ans);
			}
		}
		
		int get_warm(String input){
			Queue<String> warm = new LinkedList<String>();
			Queue<Integer> cnt = new LinkedList<Integer>();
			HashMap<String, Boolean> memo = new HashMap<String, Boolean>();
			memo.put(input,true);
			warm.add(input);
			cnt.add(0);
			while(warm.size()>0){
				String a = warm.remove();
				int step = cnt.remove();
//				System.out.println(a+"" ""+step);//deba
				boolean sw = true;
				for(int i=0;i<a.length()-1;i++)if(a.charAt(i)!=a.charAt(i+1))sw=false;
				if(sw)return step;
				//ここから
				for(int i=0;i<a.length()-1;i++)if(a.charAt(i)!=a.charAt(i+1)){
					String b = a.substring(0,i)+getColor(a.charAt(i),a.charAt(i+1))+a.substring(i+2,a.length());
					if(memo.containsKey(b))continue;
					warm.add(b);
					cnt.add(step+1);
					memo.put(b, true);
				}
			}
			return -1;
		}
		
		String getColor(char a, char b){
			if(a=='r'&&b=='b'||a=='b'&&b=='r')return ""gg"";
			else if(a=='r'&&b=='g'||a=='g'&&b=='r')return ""bb"";
			else return ""rr"";
		}
		
	}

}",1
p00179,"ふしぎな虫
会津生物学研究所のA博士は、とある南の島でふしぎな虫を発見しました。形は芋虫のように細長いのですが、ひとつの体節が玉のような形をしているので、糸でつないだビーズ玉のように見えます。ふしぎなのは体の色に様々なバリエーションがあることと、なかには時間がたつにつれて体の色が変っていく虫がいることでした。どの虫の体節の色も赤か緑か青のどれかに限られるようですが、1 秒ごとに体節の色が変わっていき、最後にはすべての体節が同じ色になって落ち着く場合もあれば、いつまで待ってもずっと色が変わりつづける場合もあるようでした。
調べていくうちに、ふだんはすべての体節が同じ色をしているのですが、何かに驚いたりして興奮した後は体節の色が勝手に変わってしまうことがわかりました。一度体節の色が変わってしまうと、ふたたびすべての体節が同じ色になるまではずっと色が変わり続けることがわかりました。
A博士はこの虫を何匹も捕まえて興奮させてみては、色が変わる様子を興味深く観察していましたが、やがて色が変化している最中の色の変わり方には次のような規則性があることに気がつきました。
色が変わるのは、隣り合っている色違いの 2つの体節のペア 1組だけが変わり、他の体節の色は変わらない。ただし、そのようなペアが複数あるときに、どのペアの色が変わるかはあらかじめ予測できない。
そのようなペアは、2つの体節の色のどちらでもない色に同時に変わる(たとえば、緑と赤の体節が隣り合っているときは、それらが同時に青に変わる)。
虫の色の変化を、2秒後まですべて書いたものが上の図です。図の上段のような色をした虫がいるとします。このとき、隣り合った色違いの体節のペアは 3組あるので、1秒後には中段に並べて描いた 3通りの色のどれかに変わります。1秒後に中段左側の 2つのように変わったときには、2秒後にすべての体節が緑色になることができます(図の下段の左側から 2番目)。 それに対して、1秒後に中段の1番右のように変わったときには、2秒後にすべての体節が同じ色に変わることはありません。
博士は、目の前にいる虫の体節がすべて同じ色になる可能性があるのか、あるとしたらそうなるのは最短で何秒後なのかを予測することにしました。
目の前にいる虫の体節の色の並びを入力とし、その虫の体節がすべて同じ色になるのに要する最短の時間を秒単位で出力するプログラムを作成してください。ただし、同じ色になる可能性がないときは「NA(半角英大文字)」と出力してください。また、虫の体節の色の並びは2  以上 10 以下のr(赤)、g(緑)、b(青)からなる文字列で表されます。
Input
複数のデータセットの並びが入力として与えられます。入力の終わりはゼロひとつの行で示されま
す。各データセットとして、 虫の体節の情報を表す１つの文字列が１行に与えられます。
データセットの数は 100 を超えません。
Output
データセット毎に、すべての体節の色が同じになるまでに要する最小時間 (秒単位の整数) または NA を１行に出力します。
Sample Input
rbgrg
rbbgbbr
bgr
bgrbrgbr
bggrgbgrr
gbrggrbggr
rrrrr
bgbr
0
Output for the Sample Input
5
7
1
6
NA
8
0
4",Python,"from collections import deque

def get_other_color(c1, c2):
    colors = {'r', 'g', 'b'}
    return list(colors - {c1, c2})[0]

def get_neighbors(state):
    neighbors = []
    for i in range(len(state) - 1):
        if state[i] != state[i + 1]:
            new_state = list(state)
            new_color = get_other_color(state[i], state[i + 1])
            new_state[i] = new_color
            new_state[i + 1] = new_color
            neighbors.append(''.join(new_state))
    return neighbors

def solve(state):
    if len(set(state)) == 1:
        return 0
    
    visited = {state}
    queue = deque([(state, 0)])
    
    while queue:
        current, steps = queue.popleft()
        
        for neighbor in get_neighbors(current):
            if len(set(neighbor)) == 1:
                return steps + 1
            
            if neighbor not in visited:
                visited.add(neighbor)
                queue.append((neighbor, steps + 1))
    
    return ""NA""

while True:
    line = input().strip()
    if line == ""0"":
        break
    print(solve(line))
",0
p00179,"ふしぎな虫
会津生物学研究所のA博士は、とある南の島でふしぎな虫を発見しました。形は芋虫のように細長いのですが、ひとつの体節が玉のような形をしているので、糸でつないだビーズ玉のように見えます。ふしぎなのは体の色に様々なバリエーションがあることと、なかには時間がたつにつれて体の色が変っていく虫がいることでした。どの虫の体節の色も赤か緑か青のどれかに限られるようですが、1 秒ごとに体節の色が変わっていき、最後にはすべての体節が同じ色になって落ち着く場合もあれば、いつまで待ってもずっと色が変わりつづける場合もあるようでした。
調べていくうちに、ふだんはすべての体節が同じ色をしているのですが、何かに驚いたりして興奮した後は体節の色が勝手に変わってしまうことがわかりました。一度体節の色が変わってしまうと、ふたたびすべての体節が同じ色になるまではずっと色が変わり続けることがわかりました。
A博士はこの虫を何匹も捕まえて興奮させてみては、色が変わる様子を興味深く観察していましたが、やがて色が変化している最中の色の変わり方には次のような規則性があることに気がつきました。
色が変わるのは、隣り合っている色違いの 2つの体節のペア 1組だけが変わり、他の体節の色は変わらない。ただし、そのようなペアが複数あるときに、どのペアの色が変わるかはあらかじめ予測できない。
そのようなペアは、2つの体節の色のどちらでもない色に同時に変わる(たとえば、緑と赤の体節が隣り合っているときは、それらが同時に青に変わる)。
虫の色の変化を、2秒後まですべて書いたものが上の図です。図の上段のような色をした虫がいるとします。このとき、隣り合った色違いの体節のペアは 3組あるので、1秒後には中段に並べて描いた 3通りの色のどれかに変わります。1秒後に中段左側の 2つのように変わったときには、2秒後にすべての体節が緑色になることができます(図の下段の左側から 2番目)。 それに対して、1秒後に中段の1番右のように変わったときには、2秒後にすべての体節が同じ色に変わることはありません。
博士は、目の前にいる虫の体節がすべて同じ色になる可能性があるのか、あるとしたらそうなるのは最短で何秒後なのかを予測することにしました。
目の前にいる虫の体節の色の並びを入力とし、その虫の体節がすべて同じ色になるのに要する最短の時間を秒単位で出力するプログラムを作成してください。ただし、同じ色になる可能性がないときは「NA(半角英大文字)」と出力してください。また、虫の体節の色の並びは2  以上 10 以下のr(赤)、g(緑)、b(青)からなる文字列で表されます。
Input
複数のデータセットの並びが入力として与えられます。入力の終わりはゼロひとつの行で示されま
す。各データセットとして、 虫の体節の情報を表す１つの文字列が１行に与えられます。
データセットの数は 100 を超えません。
Output
データセット毎に、すべての体節の色が同じになるまでに要する最小時間 (秒単位の整数) または NA を１行に出力します。
Sample Input
rbgrg
rbbgbbr
bgr
bgrbrgbr
bggrgbgrr
gbrggrbggr
rrrrr
bgbr
0
Output for the Sample Input
5
7
1
6
NA
8
0
4",Python,"from collections import deque
used = [0]*(3**10)


while True:
	s = raw_input()
	if s==""0"":
		break
	n=len(s)
	t=0
	for i in range(len(s)):
		t*=3
		if s[i]==""r"":
			t+=0
		if s[i]==""g"":
			t+=1
		if s[i]==""b"":
			t+=2
	f=0
	for i in range(3**n):
		used[i]=0
	tq=[t]
	q=deque(tq)
	used[t]=1
	ans=-1
	cnt=0
	while len(q)>0:
		qs=len(q)
		for o in range(qs):
			top=q.popleft()
			v=[0]
			v.pop()
			for i in range(n):
				v.append(top%3)
				top/=3
			ok=1
			a=v[0]
			for i in range(n):
				if v[i]!=a:
					ok=0
			if ok==1:
				f=1
				ans=cnt
				break
			for i in range(n-1):
				if v[i]!=v[i+1]:
					t1=v[i]
					t2=v[i+1]
					v[i]=3-t1-t2
					v[i+1]=3-t1-t2
					tmp=0
					for j in range(n):
						tmp*=3
						tmp+=v[j]
					if used[tmp]==0:
						q.append(tmp)
						used[tmp]=1
					v[i]=t1
					v[i+1]=t2
		if f==1:
			break
		else:
			cnt+=1
	if ans==-1:
		print ""NA""
	else:
		print ans",1
p00180,"橋の取り壊し
水の国ウォーターデブンには
n
個の都市があります。各都市は水に囲まれており、島国のようになっています。ウォーターデブンには
m
本の橋があり、都市間の交通はそれらの橋によって行われ、全ての都市に行き来することができます。
最近、道路特定財源の見直しにより橋の維持費の削減が決定されました。全部の橋を維持することができなくなってしまい、いくつかの橋を取り壊すことになりました。そこで、ウォーターデブンはどの都市にでも行くことができるように橋を残しつつ、橋の維持費を最小化することが課題となりました。
都市の数、橋の数、各橋の維持費を入力とし、橋を利用してどの都市にも行けるようにしつつ、橋を取り壊した場合の維持費の最小値を出力するプログラムを作成してください。なお、橋の取り壊しには費用が掛からないものとします。ただし、各都市は 0 から
n
- 1 まで順番に番号が付けられているものとします。
Input
複数のデータセットの並びが入力として与えられます。入力の終わりはゼロふたつの行で示されます。各データセットは以下の形式で与えられます。
n
m
a
1
b
1
cost
1
a
2
b
2
cost
2
:
a
m
b
m
cost
m
１行目に都市の数
n
(2 ≤
n
≤ 100)、 橋の数
m
(1 ≤
m
≤ 500) が与えられます。続く
m
行に第
i
の橋の情報が与えられます。
a
i
,
b
i
は橋がつないでいる都市の番号、
cost
i
(1 ≤
cost
i
≤ 1000) は橋にかかる維持費を表します。
Output
データセット毎に橋の維持費の合計を１行に出力します。
Sample Input
5 6
0 2 1
2 1 3
2 3 8
1 3 2
3 4 5
1 4 4
3 3
1 2 3
2 0 3
0 1 3
0 0
Output for the Sample Input
10
6",C,"#include <stdio.h>
#include <stdlib.h>

typedef struct {
    int a, b, cost;
} Edge;

int parent[100];

int find(int x) {
    if (parent[x] == x) return x;
    return parent[x] = find(parent[x]);
}

int unite(int x, int y) {
    x = find(x);
    y = find(y);
    if (x == y) return 0;
    parent[x] = y;
    return 1;
}

int compare(const void *a, const void *b) {
    Edge *ea = (Edge *)a;
    Edge *eb = (Edge *)b;
    return ea->cost - eb->cost;
}

int main() {
    int n, m;
    
    while (1) {
        scanf(""%d %d"", &n, &m);
        if (n == 0 && m == 0) break;
        
        Edge edges[500];
        for (int i = 0; i < m; i++) {
            scanf(""%d %d %d"", &edges[i].a, &edges[i].b, &edges[i].cost);
        }
        
        qsort(edges, m, sizeof(Edge), compare);
        
        for (int i = 0; i < n; i++) {
            parent[i] = i;
        }
        
        int total = 0;
        int count = 0;
        
        for (int i = 0; i < m; i++) {
            if (unite(edges[i].a, edges[i].b)) {
                total += edges[i].cost;
                count++;
                if (count == n - 1) break;
            }
        }
        
        printf(""%d\n"", total);
    }
    
    return 0;
}
",0
p00180,"橋の取り壊し
水の国ウォーターデブンには
n
個の都市があります。各都市は水に囲まれており、島国のようになっています。ウォーターデブンには
m
本の橋があり、都市間の交通はそれらの橋によって行われ、全ての都市に行き来することができます。
最近、道路特定財源の見直しにより橋の維持費の削減が決定されました。全部の橋を維持することができなくなってしまい、いくつかの橋を取り壊すことになりました。そこで、ウォーターデブンはどの都市にでも行くことができるように橋を残しつつ、橋の維持費を最小化することが課題となりました。
都市の数、橋の数、各橋の維持費を入力とし、橋を利用してどの都市にも行けるようにしつつ、橋を取り壊した場合の維持費の最小値を出力するプログラムを作成してください。なお、橋の取り壊しには費用が掛からないものとします。ただし、各都市は 0 から
n
- 1 まで順番に番号が付けられているものとします。
Input
複数のデータセットの並びが入力として与えられます。入力の終わりはゼロふたつの行で示されます。各データセットは以下の形式で与えられます。
n
m
a
1
b
1
cost
1
a
2
b
2
cost
2
:
a
m
b
m
cost
m
１行目に都市の数
n
(2 ≤
n
≤ 100)、 橋の数
m
(1 ≤
m
≤ 500) が与えられます。続く
m
行に第
i
の橋の情報が与えられます。
a
i
,
b
i
は橋がつないでいる都市の番号、
cost
i
(1 ≤
cost
i
≤ 1000) は橋にかかる維持費を表します。
Output
データセット毎に橋の維持費の合計を１行に出力します。
Sample Input
5 6
0 2 1
2 1 3
2 3 8
1 3 2
3 4 5
1 4 4
3 3
1 2 3
2 0 3
0 1 3
0 0
Output for the Sample Input
10
6",C,"// Aizu Vol-1 0180: Demolition of Bridges
// 2017.8.9

#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#define INF 0x77777777
#define MAX 100
#define EMAX 500
int n;
typedef struct { int b, c; } ND;
ND d[MAX + 2][MAX + 2];
int w[MAX + 2];
int visited[MAX];

int qsize;
typedef struct { int a, b, c; } QUE;
QUE que[EMAX + 1];

#define PARENT(i) ((i)/2)
#define LEFT(i)   ((i)<<1)
#define RIGHT(i)  (((i)<<1)+1)

static void min_heapify(int i)
{
	int l, r, smallest;

	l = LEFT(i), r = RIGHT(i);
	if (l < qsize && que[l].c < que[i].c) smallest = l; else smallest = i;
	if (r < qsize && que[r].c < que[smallest].c) smallest = r;
	if (smallest != i) {
		QUE t;
		memcpy(&t, que + i, sizeof(QUE)), memcpy(que + i, que + smallest, sizeof(QUE));
		memcpy(que + smallest, &t, sizeof(QUE));
		min_heapify(smallest);
	}
}

int deq(QUE *q)
{
	if (qsize == 0) return -1;
	memcpy(q, &que[0], sizeof(QUE));
	memcpy(que, que + --qsize, sizeof(QUE));
	min_heapify(0);
	return 1;
}

void enq(QUE *q)
{
	int i;

	i = qsize++;
	memcpy(que + i, q, sizeof(QUE));
	while (i > 0 && que[PARENT(i)].c > que[i].c) {
		QUE t;
		memcpy(&t, que + i, sizeof(QUE)), memcpy(que + i, que + PARENT(i), sizeof(QUE));
		memcpy(que + PARENT(i), &t, sizeof(QUE));
		i = PARENT(i);
	}
}


int main()
{
	int m, a, b, c;
	int i, k, ans;
	QUE q;

	while (1) {
		scanf(""%d%d"", &n, &m); if (!n) return 0;
		memset(w, 0, sizeof(w));
		for (i = 0; i < m; i++) {
			scanf(""%d%d%d"", &a, &b, &c);
			d[a][w[a]].b = b, d[a][w[a]++].c = c;
			d[b][w[b]].b = a, d[b][w[b]++].c = c;
		}
		memset(visited, 0, sizeof(visited));
		ans = 0, visited[0] = 1, k = 1, qsize = 0;
		for (i = 0; i < w[0]; i++) q.a = 0, q.b = d[0][i].b, q.c = d[0][i].c, enq(&q);
		while (k < n) {
			do deq(&q);
			while (visited[q.a] && visited[q.b]);
			k++;
			a = visited[q.a] ? q.b : q.a;
			visited[a] = 1, ans += q.c;
			for (i = 0; i < w[a]; i++) {
				b = d[a][i].b;
				if (!visited[b]) q.a = a, q.b = b, q.c = d[a][i].c, enq(&q);
			}

		}
		printf(""%d\n"", ans);
	}
	return 0;
}",1
p00180,"橋の取り壊し
水の国ウォーターデブンには
n
個の都市があります。各都市は水に囲まれており、島国のようになっています。ウォーターデブンには
m
本の橋があり、都市間の交通はそれらの橋によって行われ、全ての都市に行き来することができます。
最近、道路特定財源の見直しにより橋の維持費の削減が決定されました。全部の橋を維持することができなくなってしまい、いくつかの橋を取り壊すことになりました。そこで、ウォーターデブンはどの都市にでも行くことができるように橋を残しつつ、橋の維持費を最小化することが課題となりました。
都市の数、橋の数、各橋の維持費を入力とし、橋を利用してどの都市にも行けるようにしつつ、橋を取り壊した場合の維持費の最小値を出力するプログラムを作成してください。なお、橋の取り壊しには費用が掛からないものとします。ただし、各都市は 0 から
n
- 1 まで順番に番号が付けられているものとします。
Input
複数のデータセットの並びが入力として与えられます。入力の終わりはゼロふたつの行で示されます。各データセットは以下の形式で与えられます。
n
m
a
1
b
1
cost
1
a
2
b
2
cost
2
:
a
m
b
m
cost
m
１行目に都市の数
n
(2 ≤
n
≤ 100)、 橋の数
m
(1 ≤
m
≤ 500) が与えられます。続く
m
行に第
i
の橋の情報が与えられます。
a
i
,
b
i
は橋がつないでいる都市の番号、
cost
i
(1 ≤
cost
i
≤ 1000) は橋にかかる維持費を表します。
Output
データセット毎に橋の維持費の合計を１行に出力します。
Sample Input
5 6
0 2 1
2 1 3
2 3 8
1 3 2
3 4 5
1 4 4
3 3
1 2 3
2 0 3
0 1 3
0 0
Output for the Sample Input
10
6",Java,"import java.util.*;

public class Main {
    static class Edge implements Comparable<Edge> {
        int u, v, cost;
        
        Edge(int u, int v, int cost) {
            this.u = u;
            this.v = v;
            this.cost = cost;
        }
        
        @Override
        public int compareTo(Edge other) {
            return this.cost - other.cost;
        }
    }
    
    static class UnionFind {
        int[] parent;
        int[] rank;
        
        UnionFind(int n) {
            parent = new int[n];
            rank = new int[n];
            for (int i = 0; i < n; i++) {
                parent[i] = i;
                rank[i] = 0;
            }
        }
        
        int find(int x) {
            if (parent[x] != x) {
                parent[x] = find(parent[x]);
            }
            return parent[x];
        }
        
        boolean union(int x, int y) {
            int rootX = find(x);
            int rootY = find(y);
            
            if (rootX == rootY) {
                return false;
            }
            
            if (rank[rootX] < rank[rootY]) {
                parent[rootX] = rootY;
            } else if (rank[rootX] > rank[rootY]) {
                parent[rootY] = rootX;
            } else {
                parent[rootY] = rootX;
                rank[rootX]++;
            }
            
            return true;
        }
    }
    
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        
        while (true) {
            int n = sc.nextInt();
            int m = sc.nextInt();
            
            if (n == 0 && m == 0) {
                break;
            }
            
            List<Edge> edges = new ArrayList<>();
            
            for (int i = 0; i < m; i++) {
                int a = sc.nextInt();
                int b = sc.nextInt();
                int cost = sc.nextInt();
                edges.add(new Edge(a, b, cost));
            }
            
            Collections.sort(edges);
            
            UnionFind uf = new UnionFind(n);
            int totalCost = 0;
            int edgeCount = 0;
            
            for (Edge edge : edges) {
                if (uf.union(edge.u, edge.v)) {
                    totalCost += edge.cost;
                    edgeCount++;
                    if (edgeCount == n - 1) {
                        break;
                    }
                }
            }
            
            System.out.println(totalCost);
        }
        
        sc.close();
    }
}
",0
p00180,"橋の取り壊し
水の国ウォーターデブンには
n
個の都市があります。各都市は水に囲まれており、島国のようになっています。ウォーターデブンには
m
本の橋があり、都市間の交通はそれらの橋によって行われ、全ての都市に行き来することができます。
最近、道路特定財源の見直しにより橋の維持費の削減が決定されました。全部の橋を維持することができなくなってしまい、いくつかの橋を取り壊すことになりました。そこで、ウォーターデブンはどの都市にでも行くことができるように橋を残しつつ、橋の維持費を最小化することが課題となりました。
都市の数、橋の数、各橋の維持費を入力とし、橋を利用してどの都市にも行けるようにしつつ、橋を取り壊した場合の維持費の最小値を出力するプログラムを作成してください。なお、橋の取り壊しには費用が掛からないものとします。ただし、各都市は 0 から
n
- 1 まで順番に番号が付けられているものとします。
Input
複数のデータセットの並びが入力として与えられます。入力の終わりはゼロふたつの行で示されます。各データセットは以下の形式で与えられます。
n
m
a
1
b
1
cost
1
a
2
b
2
cost
2
:
a
m
b
m
cost
m
１行目に都市の数
n
(2 ≤
n
≤ 100)、 橋の数
m
(1 ≤
m
≤ 500) が与えられます。続く
m
行に第
i
の橋の情報が与えられます。
a
i
,
b
i
は橋がつないでいる都市の番号、
cost
i
(1 ≤
cost
i
≤ 1000) は橋にかかる維持費を表します。
Output
データセット毎に橋の維持費の合計を１行に出力します。
Sample Input
5 6
0 2 1
2 1 3
2 3 8
1 3 2
3 4 5
1 4 4
3 3
1 2 3
2 0 3
0 1 3
0 0
Output for the Sample Input
10
6",Java,"import java.util.HashSet;
import java.util.Iterator;
import java.util.Scanner;

public class Main {
	static Scanner sc = new Scanner(System.in);

	static int n, m;
	static int[][] node;


	public static void main(String[] args) {
		while(read()){
			solve();
		}

	}

	static boolean read(){
		n = sc.nextInt();
		m = sc.nextInt();
		if(n == 0 && m == 0)  return false;

		node = new int[n][n];  //£sñ

		for(int i=0; i<n; i++){
			for(int j=0; j<n; j++){
				if(i==j) node[i][j] = 0;
				else     node[i][j] = -1;
			}
		}

		for(int i=0; i<m; i++){
			int node1 = sc.nextInt();
			int node2 = sc.nextInt();
			int cost = sc.nextInt();

			node[node1][node2] = cost;
			node[node2][node1] = cost;
		}

		return true;
	}


	//v@
	static void solve(){
		int sum =0;
		HashSet<Integer> X = new HashSet<Integer>();  //èÏÝW
		HashSet<Integer> Y = new HashSet<Integer>();  //¢èW

		//WÌú»
		X.add(0);
		for(int i=1; i<n; i++){
			Y.add(i);
		}

		//¢èÌWªóÉÈéÜÅ
		while(!Y.isEmpty()){

			//Å¬RXgÌ×Úm[hð²×é
			int min = Integer.MAX_VALUE;
			int min_num = -1, min_num2 = -1;

			for(Iterator<Integer> i1 = X.iterator(); i1.hasNext();){
				int n1 = i1.next();
				for (Iterator<Integer> i2 = Y.iterator(); i2.hasNext();){
					int n2 = i2.next();
					if(node[n1][n2] == -1)  continue;

					if(min > node[n1][n2]){
						min = node[n1][n2];
						min_num = n1;
						min_num2 = n2;
					}
				}
			}

			sum += node[min_num][min_num2];
			Y.remove(min_num2);
			X.add(min_num2);
		}

		System.out.println(sum);  //oÍ
	}
}",1
p00180,"橋の取り壊し
水の国ウォーターデブンには
n
個の都市があります。各都市は水に囲まれており、島国のようになっています。ウォーターデブンには
m
本の橋があり、都市間の交通はそれらの橋によって行われ、全ての都市に行き来することができます。
最近、道路特定財源の見直しにより橋の維持費の削減が決定されました。全部の橋を維持することができなくなってしまい、いくつかの橋を取り壊すことになりました。そこで、ウォーターデブンはどの都市にでも行くことができるように橋を残しつつ、橋の維持費を最小化することが課題となりました。
都市の数、橋の数、各橋の維持費を入力とし、橋を利用してどの都市にも行けるようにしつつ、橋を取り壊した場合の維持費の最小値を出力するプログラムを作成してください。なお、橋の取り壊しには費用が掛からないものとします。ただし、各都市は 0 から
n
- 1 まで順番に番号が付けられているものとします。
Input
複数のデータセットの並びが入力として与えられます。入力の終わりはゼロふたつの行で示されます。各データセットは以下の形式で与えられます。
n
m
a
1
b
1
cost
1
a
2
b
2
cost
2
:
a
m
b
m
cost
m
１行目に都市の数
n
(2 ≤
n
≤ 100)、 橋の数
m
(1 ≤
m
≤ 500) が与えられます。続く
m
行に第
i
の橋の情報が与えられます。
a
i
,
b
i
は橋がつないでいる都市の番号、
cost
i
(1 ≤
cost
i
≤ 1000) は橋にかかる維持費を表します。
Output
データセット毎に橋の維持費の合計を１行に出力します。
Sample Input
5 6
0 2 1
2 1 3
2 3 8
1 3 2
3 4 5
1 4 4
3 3
1 2 3
2 0 3
0 1 3
0 0
Output for the Sample Input
10
6",Python,"import sys
from typing import List, Tuple

class UnionFind:
    def __init__(self, n: int):
        self.parent = list(range(n))
        self.rank = [0] * n
    
    def find(self, x: int) -> int:
        if self.parent[x] != x:
            self.parent[x] = self.find(self.parent[x])
        return self.parent[x]
    
    def union(self, x: int, y: int) -> bool:
        root_x = self.find(x)
        root_y = self.find(y)
        
        if root_x == root_y:
            return False
        
        if self.rank[root_x] < self.rank[root_y]:
            self.parent[root_x] = root_y
        elif self.rank[root_x] > self.rank[root_y]:
            self.parent[root_y] = root_x
        else:
            self.parent[root_y] = root_x
            self.rank[root_x] += 1
        
        return True

def kruskal(n: int, edges: List[Tuple[int, int, int]]) -> int:
    edges.sort(key=lambda x: x[2])
    uf = UnionFind(n)
    total_cost = 0
    edges_added = 0
    
    for a, b, cost in edges:
        if uf.union(a, b):
            total_cost += cost
            edges_added += 1
            if edges_added == n - 1:
                break
    
    return total_cost

def main():
    input_lines = sys.stdin.read().strip().split('\n')
    i = 0
    
    while i < len(input_lines):
        line = input_lines[i].strip()
        if not line:
            i += 1
            continue
        
        parts = line.split()
        n, m = int(parts[0]), int(parts[1])
        
        if n == 0 and m == 0:
            break
        
        i += 1
        edges = []
        
        for j in range(m):
            line = input_lines[i].strip()
            parts = line.split()
            a, b, cost = int(parts[0]), int(parts[1]), int(parts[2])
            edges.append((a, b, cost))
            i += 1
        
        result = kruskal(n, edges)
        print(result)

if __name__ == ""__main__"":
    main()
",0
p00180,"橋の取り壊し
水の国ウォーターデブンには
n
個の都市があります。各都市は水に囲まれており、島国のようになっています。ウォーターデブンには
m
本の橋があり、都市間の交通はそれらの橋によって行われ、全ての都市に行き来することができます。
最近、道路特定財源の見直しにより橋の維持費の削減が決定されました。全部の橋を維持することができなくなってしまい、いくつかの橋を取り壊すことになりました。そこで、ウォーターデブンはどの都市にでも行くことができるように橋を残しつつ、橋の維持費を最小化することが課題となりました。
都市の数、橋の数、各橋の維持費を入力とし、橋を利用してどの都市にも行けるようにしつつ、橋を取り壊した場合の維持費の最小値を出力するプログラムを作成してください。なお、橋の取り壊しには費用が掛からないものとします。ただし、各都市は 0 から
n
- 1 まで順番に番号が付けられているものとします。
Input
複数のデータセットの並びが入力として与えられます。入力の終わりはゼロふたつの行で示されます。各データセットは以下の形式で与えられます。
n
m
a
1
b
1
cost
1
a
2
b
2
cost
2
:
a
m
b
m
cost
m
１行目に都市の数
n
(2 ≤
n
≤ 100)、 橋の数
m
(1 ≤
m
≤ 500) が与えられます。続く
m
行に第
i
の橋の情報が与えられます。
a
i
,
b
i
は橋がつないでいる都市の番号、
cost
i
(1 ≤
cost
i
≤ 1000) は橋にかかる維持費を表します。
Output
データセット毎に橋の維持費の合計を１行に出力します。
Sample Input
5 6
0 2 1
2 1 3
2 3 8
1 3 2
3 4 5
1 4 4
3 3
1 2 3
2 0 3
0 1 3
0 0
Output for the Sample Input
10
6",Python,"def f(s, cost, route, ans):
    route.append(s)
    ans += cost[s]
    del cost[s]
    for k, c in data.items():
        if s in k:
            a, b = k
            if s == a:
                if not b in route:
                    if not b in cost or c < cost[b]:
                        cost[b] = c
                        del data[(a, b)]
            elif s == b:
                if not a in route:
                    if not a in cost or c < cost[a]:
                        cost[a] = c
                        del data[(a, b)]
    if cost:
        s = sorted(cost.items(), key=lambda x: x[1])[0][0]
        return f(s, cost, route, ans)
    return ans

while 1:
    n, m = map(int, raw_input().split())
    if n == m == 0: break
    data = {}
    for i in range(m):
        a, b, c = map(int, raw_input().split())
        data[(a, b)] = c
    print f(0, {0:0}, [], 0)",1
p00181,"本棚
太郎君はとある小説にはまっています。その小説は全部で
n
巻あり、各巻で本の厚さが異なります。太郎君はこの小説が大変気に入ったので、その小説専用の本棚を買おうと思っています。しかし、部屋に大きな本棚を置くとかなり狭くなってしまうので、出来るだけ本棚の幅が小さくなるように工夫しなければなりません。床から天井の高さを測ったところ、どうやら
m
段の本棚なら置けることが分かりました。そこで、小説
n
巻をどのように分ければ
m
段の本棚の幅を最小に出来るでしょうか?
 太郎君にはこだわりがあり、各段に納める小説は巻の番号順に並んでいなければなりません。
本棚の段数、小説の巻数、各本の厚さを入力として、全巻を 1巻から順に収めることができる本棚の中で幅が最小となるものの幅を求めるプログラムを作成してください。ただし、本棚の枠の大きさは幅に含めないこととします。
Input
複数のデータセットの並びが入力として与えられます。入力の終わりはゼロふたつの行で示されます。各データセットは以下の形式で与えられます。
m
n
w
1
w
2
:
w
n
１行目に部屋に置くことができる本棚の段数
m
(1 ≤
m
≤ 20)、 小説の巻数
n
(1 ≤
n
≤ 100) が与えられます。続く
n
行に第
i
巻の本の厚さを表す整数
w
i
(1 ≤
w
i
≤ 1000000) が与えられます。
ただし、本棚の幅は 1500000 を超えないものとします。
データセットの数は 50  を超えません。
Output
データセット毎に最小となる本棚の幅を１行に出力します。
Sample Input
3 9
500
300
800
200
100
600
900
700
400
4 3
1000
1000
1000
0 0
Output for the Sample Input
1800
1000",C,"#include <stdio.h>
#include <string.h>

int m, n;
int w[105];
int dp[105][25];

int max(int a, int b) {
    return a > b ? a : b;
}

int solve(int pos, int shelves) {
    if (pos == n) {
        if (shelves == 0) return 0;
        return 1e9;
    }
    if (shelves == 0) return 1e9;
    
    if (dp[pos][shelves] != -1) return dp[pos][shelves];
    
    int result = 1e9;
    int sum = 0;
    
    for (int i = pos; i < n; i++) {
        sum += w[i];
        int remaining = solve(i + 1, shelves - 1);
        if (remaining != 1e9) {
            result = result < max(sum, remaining) ? result : max(sum, remaining);
        }
    }
    
    dp[pos][shelves] = result;
    return result;
}

int main() {
    while (1) {
        scanf(""%d %d"", &m, &n);
        if (m == 0 && n == 0) break;
        
        for (int i = 0; i < n; i++) {
            scanf(""%d"", &w[i]);
        }
        
        memset(dp, -1, sizeof(dp));
        printf(""%d\n"", solve(0, m));
    }
    
    return 0;
}
",0
p00181,"本棚
太郎君はとある小説にはまっています。その小説は全部で
n
巻あり、各巻で本の厚さが異なります。太郎君はこの小説が大変気に入ったので、その小説専用の本棚を買おうと思っています。しかし、部屋に大きな本棚を置くとかなり狭くなってしまうので、出来るだけ本棚の幅が小さくなるように工夫しなければなりません。床から天井の高さを測ったところ、どうやら
m
段の本棚なら置けることが分かりました。そこで、小説
n
巻をどのように分ければ
m
段の本棚の幅を最小に出来るでしょうか?
 太郎君にはこだわりがあり、各段に納める小説は巻の番号順に並んでいなければなりません。
本棚の段数、小説の巻数、各本の厚さを入力として、全巻を 1巻から順に収めることができる本棚の中で幅が最小となるものの幅を求めるプログラムを作成してください。ただし、本棚の枠の大きさは幅に含めないこととします。
Input
複数のデータセットの並びが入力として与えられます。入力の終わりはゼロふたつの行で示されます。各データセットは以下の形式で与えられます。
m
n
w
1
w
2
:
w
n
１行目に部屋に置くことができる本棚の段数
m
(1 ≤
m
≤ 20)、 小説の巻数
n
(1 ≤
n
≤ 100) が与えられます。続く
n
行に第
i
巻の本の厚さを表す整数
w
i
(1 ≤
w
i
≤ 1000000) が与えられます。
ただし、本棚の幅は 1500000 を超えないものとします。
データセットの数は 50  を超えません。
Output
データセット毎に最小となる本棚の幅を１行に出力します。
Sample Input
3 9
500
300
800
200
100
600
900
700
400
4 3
1000
1000
1000
0 0
Output for the Sample Input
1800
1000",C,"#include <stdio.h>
int main(void){
	int m,n,q,r,a,i,j,t[100],s;
	for(;scanf(""%d%d"",&m,&n),m;printf(""%d\n"",q)){
		for(s=i=q=0;i<n;i++){
			scanf(""%d"",&a);
			t[i]=a;
			s+=a;
			if(q<a)q=a;
		}
		r=s>1500000?1500000:s;
		for(;q<r;){
			j=m;
			a=q+r>>1;
			s=0;
			for(i=0;i<n;i++){
				s+=t[i];
				if(s>a){
					if(!--j)break;
					s=t[i];
				}
			}
			if(i==n){	r=a;	}
			else{	q=a+1;	}
		}
	}
	return 0;
}",1
p00181,"本棚
太郎君はとある小説にはまっています。その小説は全部で
n
巻あり、各巻で本の厚さが異なります。太郎君はこの小説が大変気に入ったので、その小説専用の本棚を買おうと思っています。しかし、部屋に大きな本棚を置くとかなり狭くなってしまうので、出来るだけ本棚の幅が小さくなるように工夫しなければなりません。床から天井の高さを測ったところ、どうやら
m
段の本棚なら置けることが分かりました。そこで、小説
n
巻をどのように分ければ
m
段の本棚の幅を最小に出来るでしょうか?
 太郎君にはこだわりがあり、各段に納める小説は巻の番号順に並んでいなければなりません。
本棚の段数、小説の巻数、各本の厚さを入力として、全巻を 1巻から順に収めることができる本棚の中で幅が最小となるものの幅を求めるプログラムを作成してください。ただし、本棚の枠の大きさは幅に含めないこととします。
Input
複数のデータセットの並びが入力として与えられます。入力の終わりはゼロふたつの行で示されます。各データセットは以下の形式で与えられます。
m
n
w
1
w
2
:
w
n
１行目に部屋に置くことができる本棚の段数
m
(1 ≤
m
≤ 20)、 小説の巻数
n
(1 ≤
n
≤ 100) が与えられます。続く
n
行に第
i
巻の本の厚さを表す整数
w
i
(1 ≤
w
i
≤ 1000000) が与えられます。
ただし、本棚の幅は 1500000 を超えないものとします。
データセットの数は 50  を超えません。
Output
データセット毎に最小となる本棚の幅を１行に出力します。
Sample Input
3 9
500
300
800
200
100
600
900
700
400
4 3
1000
1000
1000
0 0
Output for the Sample Input
1800
1000",Java,"import java.util.*;

public class Main {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        
        while (true) {
            int m = sc.nextInt();
            int n = sc.nextInt();
            
            if (m == 0 && n == 0) break;
            
            int[] w = new int[n];
            for (int i = 0; i < n; i++) {
                w[i] = sc.nextInt();
            }
            
            // Binary search on the width
            int left = 0;
            int right = 1500000;
            
            // Find the minimum of maximum widths
            for (int i = 0; i < n; i++) {
                left = Math.max(left, w[i]);
            }
            
            while (left < right) {
                int mid = (left + right) / 2;
                if (canFit(w, n, m, mid)) {
                    right = mid;
                } else {
                    left = mid + 1;
                }
            }
            
            System.out.println(left);
        }
        
        sc.close();
    }
    
    private static boolean canFit(int[] w, int n, int m, int maxWidth) {
        int shelves = 1;
        int currentWidth = 0;
        
        for (int i = 0; i < n; i++) {
            if (currentWidth + w[i] <= maxWidth) {
                currentWidth += w[i];
            } else {
                shelves++;
                currentWidth = w[i];
                if (shelves > m) {
                    return false;
                }
            }
        }
        
        return true;
    }
}
",0
p00181,"本棚
太郎君はとある小説にはまっています。その小説は全部で
n
巻あり、各巻で本の厚さが異なります。太郎君はこの小説が大変気に入ったので、その小説専用の本棚を買おうと思っています。しかし、部屋に大きな本棚を置くとかなり狭くなってしまうので、出来るだけ本棚の幅が小さくなるように工夫しなければなりません。床から天井の高さを測ったところ、どうやら
m
段の本棚なら置けることが分かりました。そこで、小説
n
巻をどのように分ければ
m
段の本棚の幅を最小に出来るでしょうか?
 太郎君にはこだわりがあり、各段に納める小説は巻の番号順に並んでいなければなりません。
本棚の段数、小説の巻数、各本の厚さを入力として、全巻を 1巻から順に収めることができる本棚の中で幅が最小となるものの幅を求めるプログラムを作成してください。ただし、本棚の枠の大きさは幅に含めないこととします。
Input
複数のデータセットの並びが入力として与えられます。入力の終わりはゼロふたつの行で示されます。各データセットは以下の形式で与えられます。
m
n
w
1
w
2
:
w
n
１行目に部屋に置くことができる本棚の段数
m
(1 ≤
m
≤ 20)、 小説の巻数
n
(1 ≤
n
≤ 100) が与えられます。続く
n
行に第
i
巻の本の厚さを表す整数
w
i
(1 ≤
w
i
≤ 1000000) が与えられます。
ただし、本棚の幅は 1500000 を超えないものとします。
データセットの数は 50  を超えません。
Output
データセット毎に最小となる本棚の幅を１行に出力します。
Sample Input
3 9
500
300
800
200
100
600
900
700
400
4 3
1000
1000
1000
0 0
Output for the Sample Input
1800
1000",Java,"import java.util.Scanner;

public class Main {
	static int n, m;
	static int book[];

	public static int binarySearch(int low, int high) {
		if (high - low <= 0) {
			return high;
		}
		int mid = (low + high) / 2;
		int shellId = 0;
		int sumWidth = 0;
		for (int i = 0; i < m; i++) {
			if (mid < sumWidth + book[i]) {
				shellId++;
				sumWidth = book[i];
			} else {
				sumWidth += book[i];
			}
		}

		if (n <= shellId) {
			return binarySearch(mid + 1, high);
		} else {
			return binarySearch(low, mid);
		}
	}

	public static void main(String[] args) {
		Scanner sc = new Scanner(System.in);
		int max;

		while (true) {
			n = sc.nextInt();//tana
			m = sc.nextInt();//kann
			if ((n | m) == 0) {
				break;
			}
			book = new int[m];
			max = 0;
			for (int i = 0; i < m; i++) {
				book[i] = sc.nextInt();
				max = Math.max(max, book[i]);
			}

			System.out.println(binarySearch(max, 1500000));
		}
	}
}",1
p00181,"本棚
太郎君はとある小説にはまっています。その小説は全部で
n
巻あり、各巻で本の厚さが異なります。太郎君はこの小説が大変気に入ったので、その小説専用の本棚を買おうと思っています。しかし、部屋に大きな本棚を置くとかなり狭くなってしまうので、出来るだけ本棚の幅が小さくなるように工夫しなければなりません。床から天井の高さを測ったところ、どうやら
m
段の本棚なら置けることが分かりました。そこで、小説
n
巻をどのように分ければ
m
段の本棚の幅を最小に出来るでしょうか?
 太郎君にはこだわりがあり、各段に納める小説は巻の番号順に並んでいなければなりません。
本棚の段数、小説の巻数、各本の厚さを入力として、全巻を 1巻から順に収めることができる本棚の中で幅が最小となるものの幅を求めるプログラムを作成してください。ただし、本棚の枠の大きさは幅に含めないこととします。
Input
複数のデータセットの並びが入力として与えられます。入力の終わりはゼロふたつの行で示されます。各データセットは以下の形式で与えられます。
m
n
w
1
w
2
:
w
n
１行目に部屋に置くことができる本棚の段数
m
(1 ≤
m
≤ 20)、 小説の巻数
n
(1 ≤
n
≤ 100) が与えられます。続く
n
行に第
i
巻の本の厚さを表す整数
w
i
(1 ≤
w
i
≤ 1000000) が与えられます。
ただし、本棚の幅は 1500000 を超えないものとします。
データセットの数は 50  を超えません。
Output
データセット毎に最小となる本棚の幅を１行に出力します。
Sample Input
3 9
500
300
800
200
100
600
900
700
400
4 3
1000
1000
1000
0 0
Output for the Sample Input
1800
1000",Python,"def can_fit(books, m, max_width):
    shelves_used = 1
    current_width = 0
    
    for book in books:
        if book > max_width:
            return False
        if current_width + book > max_width:
            shelves_used += 1
            current_width = book
            if shelves_used > m:
                return False
        else:
            current_width += book
    
    return True

def solve(m, n, books):
    left = max(books)
    right = sum(books)
    
    result = right
    
    while left <= right:
        mid = (left + right) // 2
        if can_fit(books, m, mid):
            result = mid
            right = mid - 1
        else:
            left = mid + 1
    
    return result

while True:
    line = input().split()
    m, n = int(line[0]), int(line[1])
    
    if m == 0 and n == 0:
        break
    
    books = []
    for _ in range(n):
        books.append(int(input()))
    
    print(solve(m, n, books))
",0
p00181,"本棚
太郎君はとある小説にはまっています。その小説は全部で
n
巻あり、各巻で本の厚さが異なります。太郎君はこの小説が大変気に入ったので、その小説専用の本棚を買おうと思っています。しかし、部屋に大きな本棚を置くとかなり狭くなってしまうので、出来るだけ本棚の幅が小さくなるように工夫しなければなりません。床から天井の高さを測ったところ、どうやら
m
段の本棚なら置けることが分かりました。そこで、小説
n
巻をどのように分ければ
m
段の本棚の幅を最小に出来るでしょうか?
 太郎君にはこだわりがあり、各段に納める小説は巻の番号順に並んでいなければなりません。
本棚の段数、小説の巻数、各本の厚さを入力として、全巻を 1巻から順に収めることができる本棚の中で幅が最小となるものの幅を求めるプログラムを作成してください。ただし、本棚の枠の大きさは幅に含めないこととします。
Input
複数のデータセットの並びが入力として与えられます。入力の終わりはゼロふたつの行で示されます。各データセットは以下の形式で与えられます。
m
n
w
1
w
2
:
w
n
１行目に部屋に置くことができる本棚の段数
m
(1 ≤
m
≤ 20)、 小説の巻数
n
(1 ≤
n
≤ 100) が与えられます。続く
n
行に第
i
巻の本の厚さを表す整数
w
i
(1 ≤
w
i
≤ 1000000) が与えられます。
ただし、本棚の幅は 1500000 を超えないものとします。
データセットの数は 50  を超えません。
Output
データセット毎に最小となる本棚の幅を１行に出力します。
Sample Input
3 9
500
300
800
200
100
600
900
700
400
4 3
1000
1000
1000
0 0
Output for the Sample Input
1800
1000",Python,"def hondan(w,m):
    m_sum = b_lis[0]
    num = 0
    if w < max(b_lis):
        return False
    else:
        for i in range(len(b_lis) - 1):
            m_sum += b_lis[i + 1]
            if m_sum > w:

                m_sum = b_lis[i + 1]
                num += 1

        if num < m:
            return True
        else:
            return False
        
def nibutan(f_id,e_id,m):
    
    
    m_id = int((f_id + e_id) / 2)
    m_bo = hondan(m_id,m)


    if (f_id > e_id):
        return m_id + 1
    else:
        if m_bo:
            return(nibutan(f_id,m_id -1,m))
        elif not m_bo:
            return(nibutan(m_id + 1,e_id,m))
        else:
            return m_id + 1



while True:
    global w_lis
    b_lis = []
    w_lis = []
    dan_num = [0]

    m,n = map(int,input().split())
    if m == n == 0:
        break
    for i in range(n):
        num = int(input())
        b_lis.append(num)
    s_num = int(sum(b_lis) /m)

    print(nibutan(s_num,1500000,m) )",1
p00182,"ビーカー
いろいろな容量のビーカーが与えられています。はじめに、その中の一番容量の大きなビーカーを一個選び、蛇口から水をいっぱいになるまで注ぎます。つぎに、次のルールにしたがいながら、ビーカーの水を他のビーカーに移し替えていきます。
ビーカーに入っている水は,残さずにすべて他のビーカーに移さなければならない。ただし、一個のビーカーに水を全部移せないときは、複数のビーカーに分けて移してもよい。
ビーカーに水を入れるとき、いっぱいになるまで水を注がなければならない。また、水をこぼしてはならない。
複数のビーカーから同じビーカーに一度に水を注いではならない。
同じビーカーには一度しか水を注いではならない。
このルールにしたがったとき、ビーカーの個数
n
と各ビーカーの容量を入力とし、すべてのビーカーに水を注ぐことができるかどうかを判定して出力するプログラムを作成してください。すべてのビーカーに水を注ぐことができるときは YES (半角英大文字)、できないときは NO (半角英大文字) を出力してください。
Input
複数のデータセットの並びが入力として与えられます。入力の終わりはゼロひとつの行で示されます。各データセットは以下の形式で与えられます。
n
c
1
c
2
...
c
n
1 行目にビーカーの個数
n
(1 ≤
n
≤ 50) が与えられます。２行目に
i
番目のビーカーの容量を表す整数
c
i
(1 ≤
c
i
≤ 100) が与えられます。
データセットの数は 105 を超えません。
Output
データセット毎に判定結果を１行に出力します。
Sample Input
10
11 2 23 4 2 12 8 5 2 10
8
2 1 3 11 2 3 1 4
9
5 9 1 2 4 8 17 1 8
8
3 38 9 4 18 14 19 5
1
1
0
Output for the Sample Input
YES
YES
YES
NO
YES",C,"#include <stdio.h>
#include <stdlib.h>

int compare(const void *a, const void *b) {
    return (*(int*)b - *(int*)a);
}

int canFill(int *beakers, int n) {
    int *filled = (int*)calloc(n, sizeof(int));
    int i, j;
    
    filled[0] = beakers[0];
    
    for (i = 0; i < n; i++) {
        if (filled[i] == 0) continue;
        
        int water = filled[i];
        
        for (j = 0; j < n && water > 0; j++) {
            if (filled[j] == 0) {
                int toFill = beakers[j];
                if (water >= toFill) {
                    filled[j] = toFill;
                    water -= toFill;
                }
            }
        }
        
        if (water > 0) {
            free(filled);
            return 0;
        }
    }
    
    for (i = 0; i < n; i++) {
        if (filled[i] == 0) {
            free(filled);
            return 0;
        }
    }
    
    free(filled);
    return 1;
}

int solve(int *beakers, int n, int index, long long water, int *used) {
    if (water < 0) return 0;
    
    if (index == n) {
        return (water == 0);
    }
    
    if (used[index]) {
        return solve(beakers, n, index + 1, water, used);
    }
    
    if (water >= beakers[index]) {
        used[index] = 1;
        if (solve(beakers, n, 0, water - beakers[index], used)) {
            used[index] = 0;
            return 1;
        }
        used[index] = 0;
    }
    
    return solve(beakers, n, index + 1, water, used);
}

int canFillRecursive(int *beakers, int n, int current, int *used) {
    if (current == n) {
        for (int i = 0; i < n; i++) {
            if (!used[i]) return 0;
        }
        return 1;
    }
    
    if (!used[current]) return 0;
    
    long long water = beakers[current];
    int *newUsed = (int*)malloc(n * sizeof(int));
    for (int i = 0; i < n; i++) newUsed[i] = used[i];
    
    if (solve(beakers, n, 0, water, newUsed)) {
        if (canFillRecursive(beakers, n, current + 1, newUsed)) {
            free(newUsed);
            return 1;
        }
    }
    
    free(newUsed);
    return 0;
}

int main() {
    int n;
    
    while (scanf(""%d"", &n) == 1 && n != 0) {
        int *beakers = (int*)malloc(n * sizeof(int));
        
        for (int i = 0; i < n; i++) {
            scanf(""%d"", &beakers[i]);
        }
        
        qsort(beakers, n, sizeof(int), compare);
        
        if (n == 1) {
            printf(""YES\n"");
            free(beakers);
            continue;
        }
        
        int *used = (int*)calloc(n, sizeof(int));
        used[0] = 1;
        
        if (canFillRecursive(beakers, n, 0, used)) {
            printf(""YES\n"");
        } else {
            printf(""NO\n"");
        }
        
        free(used);
        free(beakers);
    }
    
    return 0;
}
",0
p00182,"ビーカー
いろいろな容量のビーカーが与えられています。はじめに、その中の一番容量の大きなビーカーを一個選び、蛇口から水をいっぱいになるまで注ぎます。つぎに、次のルールにしたがいながら、ビーカーの水を他のビーカーに移し替えていきます。
ビーカーに入っている水は,残さずにすべて他のビーカーに移さなければならない。ただし、一個のビーカーに水を全部移せないときは、複数のビーカーに分けて移してもよい。
ビーカーに水を入れるとき、いっぱいになるまで水を注がなければならない。また、水をこぼしてはならない。
複数のビーカーから同じビーカーに一度に水を注いではならない。
同じビーカーには一度しか水を注いではならない。
このルールにしたがったとき、ビーカーの個数
n
と各ビーカーの容量を入力とし、すべてのビーカーに水を注ぐことができるかどうかを判定して出力するプログラムを作成してください。すべてのビーカーに水を注ぐことができるときは YES (半角英大文字)、できないときは NO (半角英大文字) を出力してください。
Input
複数のデータセットの並びが入力として与えられます。入力の終わりはゼロひとつの行で示されます。各データセットは以下の形式で与えられます。
n
c
1
c
2
...
c
n
1 行目にビーカーの個数
n
(1 ≤
n
≤ 50) が与えられます。２行目に
i
番目のビーカーの容量を表す整数
c
i
(1 ≤
c
i
≤ 100) が与えられます。
データセットの数は 105 を超えません。
Output
データセット毎に判定結果を１行に出力します。
Sample Input
10
11 2 23 4 2 12 8 5 2 10
8
2 1 3 11 2 3 1 4
9
5 9 1 2 4 8 17 1 8
8
3 38 9 4 18 14 19 5
1
1
0
Output for the Sample Input
YES
YES
YES
NO
YES",C,"#include <stdio.h>
#include <stdlib.h>

int b[50]; // beaker status
int d[50]; // used status
int f[50]; // filled status

int compare(const void *a, const void *b) {
  return *(int *)b - *(int *)a;
}

int dcheck(int n) {
  int i, r;
  for (i = 0, r = 0; i < n; i++)
    r += d[i];
  if (r == n)
    return 1;
  else
    return 0;
}

int beaker(int n, int m) {
  int i, t;
  f[m] = 0;
  d[m] = 1;

  if (n == 1) return 1;
  for (i = m + 1, t = b[m]; i < n; i++) {
    if (t >= b[i] && f[i] == 0) {
      t -= b[i];
      d[i] = f[i] = 1;
    }
    if (t == 0)
      if (dcheck(n))
        return 1;
      else
        beaker(n, m + 1);
  }
  return 0;
}

void init() {
  int i;
  for (i = 0; i < 50; i++)
    b[i] = f[i] = d[i] = 0;
  return;
}

int main() {
  int i, n, m;

  for (;;) {
    scanf(""%d"", &n);
    if (n == 0)
      return 0;
    init();
    for (i = 0; i < n; i++)
      scanf(""%d"", &b[i]);
    qsort(b, n, sizeof(int), compare);
    m = 0; // set max value posion
    printf(""%s"", beaker(n, m) ? ""YES\n"" : ""NO\n"");
  }
  return -1;
}",1
p00182,"ビーカー
いろいろな容量のビーカーが与えられています。はじめに、その中の一番容量の大きなビーカーを一個選び、蛇口から水をいっぱいになるまで注ぎます。つぎに、次のルールにしたがいながら、ビーカーの水を他のビーカーに移し替えていきます。
ビーカーに入っている水は,残さずにすべて他のビーカーに移さなければならない。ただし、一個のビーカーに水を全部移せないときは、複数のビーカーに分けて移してもよい。
ビーカーに水を入れるとき、いっぱいになるまで水を注がなければならない。また、水をこぼしてはならない。
複数のビーカーから同じビーカーに一度に水を注いではならない。
同じビーカーには一度しか水を注いではならない。
このルールにしたがったとき、ビーカーの個数
n
と各ビーカーの容量を入力とし、すべてのビーカーに水を注ぐことができるかどうかを判定して出力するプログラムを作成してください。すべてのビーカーに水を注ぐことができるときは YES (半角英大文字)、できないときは NO (半角英大文字) を出力してください。
Input
複数のデータセットの並びが入力として与えられます。入力の終わりはゼロひとつの行で示されます。各データセットは以下の形式で与えられます。
n
c
1
c
2
...
c
n
1 行目にビーカーの個数
n
(1 ≤
n
≤ 50) が与えられます。２行目に
i
番目のビーカーの容量を表す整数
c
i
(1 ≤
c
i
≤ 100) が与えられます。
データセットの数は 105 を超えません。
Output
データセット毎に判定結果を１行に出力します。
Sample Input
10
11 2 23 4 2 12 8 5 2 10
8
2 1 3 11 2 3 1 4
9
5 9 1 2 4 8 17 1 8
8
3 38 9 4 18 14 19 5
1
1
0
Output for the Sample Input
YES
YES
YES
NO
YES",Java,"import java.util.*;

public class Main {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        
        while (true) {
            int n = sc.nextInt();
            if (n == 0) break;
            
            int[] beakers = new int[n];
            for (int i = 0; i < n; i++) {
                beakers[i] = sc.nextInt();
            }
            
            if (canFillAll(beakers)) {
                System.out.println(""YES"");
            } else {
                System.out.println(""NO"");
            }
        }
        
        sc.close();
    }
    
    static boolean canFillAll(int[] beakers) {
        int n = beakers.length;
        if (n == 1) return true;
        
        Arrays.sort(beakers);
        int maxIdx = n - 1;
        
        return dfs(beakers, new boolean[n], maxIdx, beakers[maxIdx]);
    }
    
    static boolean dfs(int[] beakers, boolean[] used, int currentIdx, int currentWater) {
        used[currentIdx] = true;
        
        if (allUsed(used)) {
            return true;
        }
        
        return tryPour(beakers, used, currentWater, 0);
    }
    
    static boolean tryPour(int[] beakers, boolean[] used, int water, int startIdx) {
        if (water == 0) {
            for (int i = beakers.length - 1; i >= 0; i--) {
                if (!used[i]) {
                    boolean[] newUsed = used.clone();
                    if (dfs(beakers, newUsed, i, beakers[i])) {
                        return true;
                    }
                }
            }
            return false;
        }
        
        for (int i = startIdx; i < beakers.length; i++) {
            if (!used[i] && beakers[i] <= water) {
                boolean[] newUsed = used.clone();
                if (tryPour(beakers, newUsed, water - beakers[i], i + 1)) {
                    return true;
                }
            }
        }
        
        return false;
    }
    
    static boolean allUsed(boolean[] used) {
        for (boolean u : used) {
            if (!u) return false;
        }
        return true;
    }
}
",0
p00182,"ビーカー
いろいろな容量のビーカーが与えられています。はじめに、その中の一番容量の大きなビーカーを一個選び、蛇口から水をいっぱいになるまで注ぎます。つぎに、次のルールにしたがいながら、ビーカーの水を他のビーカーに移し替えていきます。
ビーカーに入っている水は,残さずにすべて他のビーカーに移さなければならない。ただし、一個のビーカーに水を全部移せないときは、複数のビーカーに分けて移してもよい。
ビーカーに水を入れるとき、いっぱいになるまで水を注がなければならない。また、水をこぼしてはならない。
複数のビーカーから同じビーカーに一度に水を注いではならない。
同じビーカーには一度しか水を注いではならない。
このルールにしたがったとき、ビーカーの個数
n
と各ビーカーの容量を入力とし、すべてのビーカーに水を注ぐことができるかどうかを判定して出力するプログラムを作成してください。すべてのビーカーに水を注ぐことができるときは YES (半角英大文字)、できないときは NO (半角英大文字) を出力してください。
Input
複数のデータセットの並びが入力として与えられます。入力の終わりはゼロひとつの行で示されます。各データセットは以下の形式で与えられます。
n
c
1
c
2
...
c
n
1 行目にビーカーの個数
n
(1 ≤
n
≤ 50) が与えられます。２行目に
i
番目のビーカーの容量を表す整数
c
i
(1 ≤
c
i
≤ 100) が与えられます。
データセットの数は 105 を超えません。
Output
データセット毎に判定結果を１行に出力します。
Sample Input
10
11 2 23 4 2 12 8 5 2 10
8
2 1 3 11 2 3 1 4
9
5 9 1 2 4 8 17 1 8
8
3 38 9 4 18 14 19 5
1
1
0
Output for the Sample Input
YES
YES
YES
NO
YES",Java,"import java.util.Arrays;
import java.util.Scanner;

//Beaker
public class Main{

	int n;
	int[] a;
	boolean[] have, t;
	
	boolean dfs(int k, int rest){
		if(rest==0){
			for(int i=0;i<n;i++)t[i]=have[i];
			return greedy();
		}
		if(rest < a[k])return false;
		have[k] = true;
		if(dfs(k+1, rest-a[k]))return true;
		have[k] = false;
		return dfs(k+1, rest);
	}
	
	boolean choice(int k, int rest){
		if(rest==0)return true;
		if(k<0)return false;
		if(!t[k])return choice(k-1, rest);
		if(a[k]<=rest){
			t[k] = false;
			if(choice(k-1, rest-a[k]))return true;
			t[k] = true;
		}
		return choice(k-1, rest);
	}
	
	boolean greedy(){
		for(int i=0;i<n;i++)if(!t[i]){
			if(!choice(i-1, a[i]))return false;
			t[i] = true;
		}
		return true;
	}
	
	void run(){
		Scanner sc = new Scanner(System.in);
		t = new boolean[100];
		have = new boolean[100];
		for(;;){
			n = sc.nextInt();
			if(n==0)break;
			a = new int[n];
			for(int i=0;i<n;i++){
				a[i] = sc.nextInt();
			}
			Arrays.sort(a);
			Arrays.fill(have, false);
			have[0] = true;
			System.out.println(dfs(1, a[n-1]-a[0])?""YES"":""NO"");
		}
	}
	
	public static void main(String[] args) {
		new Main().run();
	}
}",1
p00182,"ビーカー
いろいろな容量のビーカーが与えられています。はじめに、その中の一番容量の大きなビーカーを一個選び、蛇口から水をいっぱいになるまで注ぎます。つぎに、次のルールにしたがいながら、ビーカーの水を他のビーカーに移し替えていきます。
ビーカーに入っている水は,残さずにすべて他のビーカーに移さなければならない。ただし、一個のビーカーに水を全部移せないときは、複数のビーカーに分けて移してもよい。
ビーカーに水を入れるとき、いっぱいになるまで水を注がなければならない。また、水をこぼしてはならない。
複数のビーカーから同じビーカーに一度に水を注いではならない。
同じビーカーには一度しか水を注いではならない。
このルールにしたがったとき、ビーカーの個数
n
と各ビーカーの容量を入力とし、すべてのビーカーに水を注ぐことができるかどうかを判定して出力するプログラムを作成してください。すべてのビーカーに水を注ぐことができるときは YES (半角英大文字)、できないときは NO (半角英大文字) を出力してください。
Input
複数のデータセットの並びが入力として与えられます。入力の終わりはゼロひとつの行で示されます。各データセットは以下の形式で与えられます。
n
c
1
c
2
...
c
n
1 行目にビーカーの個数
n
(1 ≤
n
≤ 50) が与えられます。２行目に
i
番目のビーカーの容量を表す整数
c
i
(1 ≤
c
i
≤ 100) が与えられます。
データセットの数は 105 を超えません。
Output
データセット毎に判定結果を１行に出力します。
Sample Input
10
11 2 23 4 2 12 8 5 2 10
8
2 1 3 11 2 3 1 4
9
5 9 1 2 4 8 17 1 8
8
3 38 9 4 18 14 19 5
1
1
0
Output for the Sample Input
YES
YES
YES
NO
YES",Python,"def can_fill_all_beakers(beakers):
    n = len(beakers)
    if n == 1:
        return True
    
    beakers_sorted = sorted(beakers, reverse=True)
    max_beaker = beakers_sorted[0]
    
    # Try DFS to see if we can fill all beakers
    def dfs(filled, current_water):
        if len(filled) == n:
            return current_water == 0
        
        if current_water == 0:
            return False
        
        # Try to fill each unfilled beaker
        for i in range(n):
            if i not in filled:
                beaker_capacity = beakers_sorted[i]
                if beaker_capacity <= current_water:
                    # Fill this beaker
                    new_filled = filled | {i}
                    new_water = current_water - beaker_capacity + beaker_capacity
                    # After filling, we pour out this beaker's water
                    if dfs(new_filled, new_water):
                        return True
        
        return False
    
    # Different approach: simulate the process
    # Start with largest beaker filled
    def solve():
        # Use bitmask DP or backtracking
        # State: which beakers have been filled
        from functools import lru_cache
        
        @lru_cache(maxsize=None)
        def can_fill(filled_mask, available_water):
            if filled_mask == (1 << n) - 1:
                return available_water == 0
            
            if available_water == 0:
                return False
            
            # Try filling each unfilled beaker
            for i in range(n):
                if not (filled_mask & (1 << i)):
                    capacity = beakers_sorted[i]
                    if capacity <= available_water:
                        # Fill beaker i
                        new_mask = filled_mask | (1 << i)
                        new_water = available_water - capacity + capacity
                        if can_fill(new_mask, new_water):
                            return True
            
            return False
        
        # Start with the largest beaker (index 0) filled
        initial_mask = 1
        initial_water = max_beaker
        return can_fill(initial_mask, initial_water)
    
    return solve()

while True:
    n = int(input())
    if n == 0:
        break
    
    beakers = list(map(int, input().split()))
    
    if can_fill_all_beakers(beakers):
        print(""YES"")
    else:
        print(""NO"")
",0
p00182,"ビーカー
いろいろな容量のビーカーが与えられています。はじめに、その中の一番容量の大きなビーカーを一個選び、蛇口から水をいっぱいになるまで注ぎます。つぎに、次のルールにしたがいながら、ビーカーの水を他のビーカーに移し替えていきます。
ビーカーに入っている水は,残さずにすべて他のビーカーに移さなければならない。ただし、一個のビーカーに水を全部移せないときは、複数のビーカーに分けて移してもよい。
ビーカーに水を入れるとき、いっぱいになるまで水を注がなければならない。また、水をこぼしてはならない。
複数のビーカーから同じビーカーに一度に水を注いではならない。
同じビーカーには一度しか水を注いではならない。
このルールにしたがったとき、ビーカーの個数
n
と各ビーカーの容量を入力とし、すべてのビーカーに水を注ぐことができるかどうかを判定して出力するプログラムを作成してください。すべてのビーカーに水を注ぐことができるときは YES (半角英大文字)、できないときは NO (半角英大文字) を出力してください。
Input
複数のデータセットの並びが入力として与えられます。入力の終わりはゼロひとつの行で示されます。各データセットは以下の形式で与えられます。
n
c
1
c
2
...
c
n
1 行目にビーカーの個数
n
(1 ≤
n
≤ 50) が与えられます。２行目に
i
番目のビーカーの容量を表す整数
c
i
(1 ≤
c
i
≤ 100) が与えられます。
データセットの数は 105 を超えません。
Output
データセット毎に判定結果を１行に出力します。
Sample Input
10
11 2 23 4 2 12 8 5 2 10
8
2 1 3 11 2 3 1 4
9
5 9 1 2 4 8 17 1 8
8
3 38 9 4 18 14 19 5
1
1
0
Output for the Sample Input
YES
YES
YES
NO
YES",Python,"while True:
    n = int(input())
    if n == 0: break
    beakers = list(map(int, input().split()))
    m = max(beakers)
    beakers.remove(m)
    beakers.sort()
    if beakers:
        beakersum = [beakers[0]]
        del beakers[0]
    else:
        print(""YES"")
        continue

    if sum(beakers) < m:
        print(""NO"")
        continue
    elif sum(beakers) == m:
        print(""YES"")
        continue

    for b in beakers:
        tmp = [bks + b for bks in beakersum if bks + b <= m]
        beakersum.extend(tmp)
        if m in beakersum:
            break
    
    if m in beakersum:
        print(""YES"")
    else:
        print(""NO"")
            
        ",1
p00183,"三目並べ
3 × 3 の盤面の三目並べを考えましょう。三目並べは 2 人で行う対戦ゲームです。先攻後攻を決め、一人は黒石、一人は白石を打ちます。盤面に石を交互に一つずつ置いていき、縦横斜めのいずれかの方向に先に 3 つ自分の石を並べた人が勝ちとなります。
盤面の情報を入力とし、勝敗の判定を行い、黒が勝ちの場合は「b」、白が勝ちの場合は「w」、どちらもそろっていない場合は「NA」と出力するプログラムを作成してください。 盤面の情報は、3行3列の文字列で構成されます。「b」は黒石、「w」は白石、「+」(半角プラ
ス)は何も置かれていない状況を表します。ただし、同時に黒が3つ、白が3つ並ぶことはありませ
ん。
Input
複数のデータセットの並びが入力として与えられます。入力の終わりはゼロひとつの行で示されます。
 各データセットは以下の形式で与えられます。
board
1
board
2
board
3
i
行目に盤面の
i
行目の情報を表す文字列
board
i
が与えられます。
データセットの数は 50 を超えません。
Output
データセット毎に、「b」、「w」、「NA」のいずれかを１行に出力します。
Sample Input
bbw
wbw
+b+
bwb
wbw
wbw
0
Output for the Sample Input
b
NA",C,"#include <stdio.h>
#include <string.h>

int check_win(char board[3][4], char player) {
    // Check rows
    for (int i = 0; i < 3; i++) {
        if (board[i][0] == player && board[i][1] == player && board[i][2] == player) {
            return 1;
        }
    }
    
    // Check columns
    for (int j = 0; j < 3; j++) {
        if (board[0][j] == player && board[1][j] == player && board[2][j] == player) {
            return 1;
        }
    }
    
    // Check diagonals
    if (board[0][0] == player && board[1][1] == player && board[2][2] == player) {
        return 1;
    }
    if (board[0][2] == player && board[1][1] == player && board[2][0] == player) {
        return 1;
    }
    
    return 0;
}

int main() {
    char board[3][4];
    
    while (1) {
        if (scanf(""%s"", board[0]) != 1) break;
        if (board[0][0] == '0') break;
        
        scanf(""%s"", board[1]);
        scanf(""%s"", board[2]);
        
        if (check_win(board, 'b')) {
            printf(""b\n"");
        } else if (check_win(board, 'w')) {
            printf(""w\n"");
        } else {
            printf(""NA\n"");
        }
    }
    
    return 0;
}
",0
p00183,"三目並べ
3 × 3 の盤面の三目並べを考えましょう。三目並べは 2 人で行う対戦ゲームです。先攻後攻を決め、一人は黒石、一人は白石を打ちます。盤面に石を交互に一つずつ置いていき、縦横斜めのいずれかの方向に先に 3 つ自分の石を並べた人が勝ちとなります。
盤面の情報を入力とし、勝敗の判定を行い、黒が勝ちの場合は「b」、白が勝ちの場合は「w」、どちらもそろっていない場合は「NA」と出力するプログラムを作成してください。 盤面の情報は、3行3列の文字列で構成されます。「b」は黒石、「w」は白石、「+」(半角プラ
ス)は何も置かれていない状況を表します。ただし、同時に黒が3つ、白が3つ並ぶことはありませ
ん。
Input
複数のデータセットの並びが入力として与えられます。入力の終わりはゼロひとつの行で示されます。
 各データセットは以下の形式で与えられます。
board
1
board
2
board
3
i
行目に盤面の
i
行目の情報を表す文字列
board
i
が与えられます。
データセットの数は 50 を超えません。
Output
データセット毎に、「b」、「w」、「NA」のいずれかを１行に出力します。
Sample Input
bbw
wbw
+b+
bwb
wbw
wbw
0
Output for the Sample Input
b
NA",C,"

#include<stdio.h>
int main(){
  char c[9],i;
  int d[]={0,1,2,3,4,5,6,7,8,0,3,6,1,4,7,2,5,8,0,4,8,2,4,6};
  while(scanf("" %c"",&c[0]),c[0]-'0'){
    for(i=1;i<9;i++){
      scanf("" %c"",&c[i]);
    }
    for(i=0;i<8;i++){
      if(c[d[i*3+0]]==c[d[i*3+1]]&&c[d[i*3+1]]==c[d[i*3+2]]&&c[d[i*3+0]]-'+'){
	printf(""%c\n"",c[d[i*3]]);
	break;
      }
    }
      if(i==8)printf(""NA\n"");
  }
  return 0;
}",1
p00183,"三目並べ
3 × 3 の盤面の三目並べを考えましょう。三目並べは 2 人で行う対戦ゲームです。先攻後攻を決め、一人は黒石、一人は白石を打ちます。盤面に石を交互に一つずつ置いていき、縦横斜めのいずれかの方向に先に 3 つ自分の石を並べた人が勝ちとなります。
盤面の情報を入力とし、勝敗の判定を行い、黒が勝ちの場合は「b」、白が勝ちの場合は「w」、どちらもそろっていない場合は「NA」と出力するプログラムを作成してください。 盤面の情報は、3行3列の文字列で構成されます。「b」は黒石、「w」は白石、「+」(半角プラ
ス)は何も置かれていない状況を表します。ただし、同時に黒が3つ、白が3つ並ぶことはありませ
ん。
Input
複数のデータセットの並びが入力として与えられます。入力の終わりはゼロひとつの行で示されます。
 各データセットは以下の形式で与えられます。
board
1
board
2
board
3
i
行目に盤面の
i
行目の情報を表す文字列
board
i
が与えられます。
データセットの数は 50 を超えません。
Output
データセット毎に、「b」、「w」、「NA」のいずれかを１行に出力します。
Sample Input
bbw
wbw
+b+
bwb
wbw
wbw
0
Output for the Sample Input
b
NA",Java,"import java.util.*;

public class Main {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        
        while (true) {
            String line = sc.nextLine();
            if (line.equals(""0"")) {
                break;
            }
            
            char[][] board = new char[3][3];
            board[0] = line.toCharArray();
            board[1] = sc.nextLine().toCharArray();
            board[2] = sc.nextLine().toCharArray();
            
            boolean bWins = checkWin(board, 'b');
            boolean wWins = checkWin(board, 'w');
            
            if (bWins) {
                System.out.println(""b"");
            } else if (wWins) {
                System.out.println(""w"");
            } else {
                System.out.println(""NA"");
            }
        }
        
        sc.close();
    }
    
    private static boolean checkWin(char[][] board, char player) {
        // Check rows
        for (int i = 0; i < 3; i++) {
            if (board[i][0] == player && board[i][1] == player && board[i][2] == player) {
                return true;
            }
        }
        
        // Check columns
        for (int j = 0; j < 3; j++) {
            if (board[0][j] == player && board[1][j] == player && board[2][j] == player) {
                return true;
            }
        }
        
        // Check diagonals
        if (board[0][0] == player && board[1][1] == player && board[2][2] == player) {
            return true;
        }
        if (board[0][2] == player && board[1][1] == player && board[2][0] == player) {
            return true;
        }
        
        return false;
    }
}
",0
p00183,"三目並べ
3 × 3 の盤面の三目並べを考えましょう。三目並べは 2 人で行う対戦ゲームです。先攻後攻を決め、一人は黒石、一人は白石を打ちます。盤面に石を交互に一つずつ置いていき、縦横斜めのいずれかの方向に先に 3 つ自分の石を並べた人が勝ちとなります。
盤面の情報を入力とし、勝敗の判定を行い、黒が勝ちの場合は「b」、白が勝ちの場合は「w」、どちらもそろっていない場合は「NA」と出力するプログラムを作成してください。 盤面の情報は、3行3列の文字列で構成されます。「b」は黒石、「w」は白石、「+」(半角プラ
ス)は何も置かれていない状況を表します。ただし、同時に黒が3つ、白が3つ並ぶことはありませ
ん。
Input
複数のデータセットの並びが入力として与えられます。入力の終わりはゼロひとつの行で示されます。
 各データセットは以下の形式で与えられます。
board
1
board
2
board
3
i
行目に盤面の
i
行目の情報を表す文字列
board
i
が与えられます。
データセットの数は 50 を超えません。
Output
データセット毎に、「b」、「w」、「NA」のいずれかを１行に出力します。
Sample Input
bbw
wbw
+b+
bwb
wbw
wbw
0
Output for the Sample Input
b
NA",Java,"import java.util.*;

public class Main {
	static Scanner sc = new Scanner(System.in);
	static char[][] board = new char[3][3];
	
	static boolean read() {
		String line = sc.next();
		if(line.equals(""0"")) return false;
		board[0][0] = line.charAt(0); board[0][1] = line.charAt(1); board[0][2] = line.charAt(2);
		for(int i = 1; i < 3; i++) {
			line = sc.next();
			for(int j = 0; j < 3; j++) board[i][j] = line.charAt(j);
		}
		return true;
	}
	
	static String solve() {
		char stone;
		boolean win;
		
		for(int i = 0; i < 3; i++) {
			win = true;
			stone = board[i][0];
			for(int j = 1; j < 3; j++) {
				if(stone != board[i][j]) win = false;
			}
			if(win) return """" + stone;
		}
		
		for(int j = 0; j < 3; j++) {
			win = true;
			stone = board[0][j];
			for(int i = 1; i < 3; i++) {
				if(stone != board[i][j]) win = false;
			}
			if(win) return """" + stone;
		}
		
		if(board[0][0] == board[1][1] && board[0][0] == board[2][2]) return """" + board[0][0];
		
		if(board[2][0] == board[1][1]  && board[1][1] == board[0][2]) return """" + board[2][0];
		
		return ""NA"";
	}
	
	public static void main(String[] args) {
		while(read()) {
			System.out.println(solve());
		}

	}

}",1
p00183,"三目並べ
3 × 3 の盤面の三目並べを考えましょう。三目並べは 2 人で行う対戦ゲームです。先攻後攻を決め、一人は黒石、一人は白石を打ちます。盤面に石を交互に一つずつ置いていき、縦横斜めのいずれかの方向に先に 3 つ自分の石を並べた人が勝ちとなります。
盤面の情報を入力とし、勝敗の判定を行い、黒が勝ちの場合は「b」、白が勝ちの場合は「w」、どちらもそろっていない場合は「NA」と出力するプログラムを作成してください。 盤面の情報は、3行3列の文字列で構成されます。「b」は黒石、「w」は白石、「+」(半角プラ
ス)は何も置かれていない状況を表します。ただし、同時に黒が3つ、白が3つ並ぶことはありませ
ん。
Input
複数のデータセットの並びが入力として与えられます。入力の終わりはゼロひとつの行で示されます。
 各データセットは以下の形式で与えられます。
board
1
board
2
board
3
i
行目に盤面の
i
行目の情報を表す文字列
board
i
が与えられます。
データセットの数は 50 を超えません。
Output
データセット毎に、「b」、「w」、「NA」のいずれかを１行に出力します。
Sample Input
bbw
wbw
+b+
bwb
wbw
wbw
0
Output for the Sample Input
b
NA",Python,"import sys

def check_winner(board):
    # Check rows
    for i in range(3):
        if board[i][0] == board[i][1] == board[i][2] and board[i][0] != '+':
            return board[i][0]
    
    # Check columns
    for i in range(3):
        if board[0][i] == board[1][i] == board[2][i] and board[0][i] != '+':
            return board[0][i]
    
    # Check diagonals
    if board[0][0] == board[1][1] == board[2][2] and board[0][0] != '+':
        return board[0][0]
    
    if board[0][2] == board[1][1] == board[2][0] and board[0][2] != '+':
        return board[0][2]
    
    return 'NA'

while True:
    line = input().strip()
    if line == '0':
        break
    
    board = [line]
    board.append(input().strip())
    board.append(input().strip())
    
    result = check_winner(board)
    print(result)
",0
p00183,"三目並べ
3 × 3 の盤面の三目並べを考えましょう。三目並べは 2 人で行う対戦ゲームです。先攻後攻を決め、一人は黒石、一人は白石を打ちます。盤面に石を交互に一つずつ置いていき、縦横斜めのいずれかの方向に先に 3 つ自分の石を並べた人が勝ちとなります。
盤面の情報を入力とし、勝敗の判定を行い、黒が勝ちの場合は「b」、白が勝ちの場合は「w」、どちらもそろっていない場合は「NA」と出力するプログラムを作成してください。 盤面の情報は、3行3列の文字列で構成されます。「b」は黒石、「w」は白石、「+」(半角プラ
ス)は何も置かれていない状況を表します。ただし、同時に黒が3つ、白が3つ並ぶことはありませ
ん。
Input
複数のデータセットの並びが入力として与えられます。入力の終わりはゼロひとつの行で示されます。
 各データセットは以下の形式で与えられます。
board
1
board
2
board
3
i
行目に盤面の
i
行目の情報を表す文字列
board
i
が与えられます。
データセットの数は 50 を超えません。
Output
データセット毎に、「b」、「w」、「NA」のいずれかを１行に出力します。
Sample Input
bbw
wbw
+b+
bwb
wbw
wbw
0
Output for the Sample Input
b
NA",Python,"while True:
    try:
        f = [list(raw_input()) for _ in xrange(3)]
    except EOFError:
        break
    g = map(lambda x:"""".join(x),f+zip(*f))
    print ""b"" if ""b""*3 in g else ""w"" if ""w""*3 in g else ""NA""",1
p00184,"鶴ヶ城
会津若松市のシンボルである鶴ヶ城は、蒲生氏郷が本格的な天守閣を築城し、「鶴ヶ城」と名付けました。天守閣からは会津盆地が一望できます。また、晴れた日には、白虎隊で有名な飯盛山の山頂から鶴ヶ城を見ることができます。
会津若松市の今後の広報活動の参考にするため、鶴ヶ城に訪れた来場者について、年代調査をすることにしました。来場者の年齢を入力とし、下記の年齢区分別に人数を出力するプログラムを作成してください。
区分
年齢
10歳未満
0  ~ 9
10代
10  ~ 19
20代
20  ~ 29
30代
30  ~ 39
40代
40  ~ 49
50代
50  ~ 59
60歳以上
60  ~
Input
複数のデータセットの並びが入力として与えられます。入力の終わりはゼロひとつの行で示されます。
 各データセットは以下の形式で与えられます。
n
a
1
a
2
:
a
n
1 行目に来場者の人数
n
(1 ≤
n
≤ 1000000)、続く
n
行に
i
人目の来場者の年齢
a
i
( 0 ≤
a
i
≤ 120 ) が与えられます。
Output
データセット毎に以下の形式で人数を出力します。
1 行目: 10 歳未満の人数
2 行目: 10 代の人数
3 行目: 20 代の人数
4 行目: 30 代の人数
5 行目: 40 代の人数
6 行目: 50 代の人数
7 行目: 60 歳以上の人数
Sample Input
8
71
34
65
11
41
39
6
5
4
67
81
78
65
0
Output for the Sample Input
2
1
0
2
1
0
2
0
0
0
0
0
0
4",C,"#include <stdio.h>

int main() {
    int n;
    
    while(scanf(""%d"", &n) == 1 && n != 0) {
        int count[7] = {0};
        
        for(int i = 0; i < n; i++) {
            int age;
            scanf(""%d"", &age);
            
            if(age < 10) {
                count[0]++;
            } else if(age < 20) {
                count[1]++;
            } else if(age < 30) {
                count[2]++;
            } else if(age < 40) {
                count[3]++;
            } else if(age < 50) {
                count[4]++;
            } else if(age < 60) {
                count[5]++;
            } else {
                count[6]++;
            }
        }
        
        for(int i = 0; i < 7; i++) {
            printf(""%d\n"", count[i]);
        }
    }
    
    return 0;
}
",0
p00184,"鶴ヶ城
会津若松市のシンボルである鶴ヶ城は、蒲生氏郷が本格的な天守閣を築城し、「鶴ヶ城」と名付けました。天守閣からは会津盆地が一望できます。また、晴れた日には、白虎隊で有名な飯盛山の山頂から鶴ヶ城を見ることができます。
会津若松市の今後の広報活動の参考にするため、鶴ヶ城に訪れた来場者について、年代調査をすることにしました。来場者の年齢を入力とし、下記の年齢区分別に人数を出力するプログラムを作成してください。
区分
年齢
10歳未満
0  ~ 9
10代
10  ~ 19
20代
20  ~ 29
30代
30  ~ 39
40代
40  ~ 49
50代
50  ~ 59
60歳以上
60  ~
Input
複数のデータセットの並びが入力として与えられます。入力の終わりはゼロひとつの行で示されます。
 各データセットは以下の形式で与えられます。
n
a
1
a
2
:
a
n
1 行目に来場者の人数
n
(1 ≤
n
≤ 1000000)、続く
n
行に
i
人目の来場者の年齢
a
i
( 0 ≤
a
i
≤ 120 ) が与えられます。
Output
データセット毎に以下の形式で人数を出力します。
1 行目: 10 歳未満の人数
2 行目: 10 代の人数
3 行目: 20 代の人数
4 行目: 30 代の人数
5 行目: 40 代の人数
6 行目: 50 代の人数
7 行目: 60 歳以上の人数
Sample Input
8
71
34
65
11
41
39
6
5
4
67
81
78
65
0
Output for the Sample Input
2
1
0
2
1
0
2
0
0
0
0
0
0
4",C,"#include<stdio.h>
int main(){
    int age0,age1,age2,age3,age4,age5,age6,n,i,x;
    while(1){
        age0=0;age1=0;age2=0;age3=0;age4=0;age5=0;age6=0;
        scanf(""%d"",&n);
        if(n==0)break;
        for(i=0;i<n;i++){
            scanf(""%d"",&x);
            if(x>=60){
                age6++;
            }else if(x>=50){
                age5++;
            }else if(x>=40){
                age4++;
            }else if(x>=30){
                age3++;
            }else if(x>=20){
                age2++;
            }else if(x>=10){
                age1++;
            }else{
                age0++;
            }
        }
        printf(""%d\n%d\n%d\n%d\n%d\n%d\n%d\n"",age0,age1,age2,age3,age4,age5,age6);
    }
    return 0;
}",1
p00184,"鶴ヶ城
会津若松市のシンボルである鶴ヶ城は、蒲生氏郷が本格的な天守閣を築城し、「鶴ヶ城」と名付けました。天守閣からは会津盆地が一望できます。また、晴れた日には、白虎隊で有名な飯盛山の山頂から鶴ヶ城を見ることができます。
会津若松市の今後の広報活動の参考にするため、鶴ヶ城に訪れた来場者について、年代調査をすることにしました。来場者の年齢を入力とし、下記の年齢区分別に人数を出力するプログラムを作成してください。
区分
年齢
10歳未満
0  ~ 9
10代
10  ~ 19
20代
20  ~ 29
30代
30  ~ 39
40代
40  ~ 49
50代
50  ~ 59
60歳以上
60  ~
Input
複数のデータセットの並びが入力として与えられます。入力の終わりはゼロひとつの行で示されます。
 各データセットは以下の形式で与えられます。
n
a
1
a
2
:
a
n
1 行目に来場者の人数
n
(1 ≤
n
≤ 1000000)、続く
n
行に
i
人目の来場者の年齢
a
i
( 0 ≤
a
i
≤ 120 ) が与えられます。
Output
データセット毎に以下の形式で人数を出力します。
1 行目: 10 歳未満の人数
2 行目: 10 代の人数
3 行目: 20 代の人数
4 行目: 30 代の人数
5 行目: 40 代の人数
6 行目: 50 代の人数
7 行目: 60 歳以上の人数
Sample Input
8
71
34
65
11
41
39
6
5
4
67
81
78
65
0
Output for the Sample Input
2
1
0
2
1
0
2
0
0
0
0
0
0
4",Java,"import java.util.*;

public class Main {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        
        while (true) {
            int n = sc.nextInt();
            if (n == 0) break;
            
            int[] counts = new int[7];
            
            for (int i = 0; i < n; i++) {
                int age = sc.nextInt();
                
                if (age < 10) {
                    counts[0]++;
                } else if (age < 20) {
                    counts[1]++;
                } else if (age < 30) {
                    counts[2]++;
                } else if (age < 40) {
                    counts[3]++;
                } else if (age < 50) {
                    counts[4]++;
                } else if (age < 60) {
                    counts[5]++;
                } else {
                    counts[6]++;
                }
            }
            
            for (int i = 0; i < 7; i++) {
                System.out.println(counts[i]);
            }
        }
        
        sc.close();
    }
}
",0
p00184,"鶴ヶ城
会津若松市のシンボルである鶴ヶ城は、蒲生氏郷が本格的な天守閣を築城し、「鶴ヶ城」と名付けました。天守閣からは会津盆地が一望できます。また、晴れた日には、白虎隊で有名な飯盛山の山頂から鶴ヶ城を見ることができます。
会津若松市の今後の広報活動の参考にするため、鶴ヶ城に訪れた来場者について、年代調査をすることにしました。来場者の年齢を入力とし、下記の年齢区分別に人数を出力するプログラムを作成してください。
区分
年齢
10歳未満
0  ~ 9
10代
10  ~ 19
20代
20  ~ 29
30代
30  ~ 39
40代
40  ~ 49
50代
50  ~ 59
60歳以上
60  ~
Input
複数のデータセットの並びが入力として与えられます。入力の終わりはゼロひとつの行で示されます。
 各データセットは以下の形式で与えられます。
n
a
1
a
2
:
a
n
1 行目に来場者の人数
n
(1 ≤
n
≤ 1000000)、続く
n
行に
i
人目の来場者の年齢
a
i
( 0 ≤
a
i
≤ 120 ) が与えられます。
Output
データセット毎に以下の形式で人数を出力します。
1 行目: 10 歳未満の人数
2 行目: 10 代の人数
3 行目: 20 代の人数
4 行目: 30 代の人数
5 行目: 40 代の人数
6 行目: 50 代の人数
7 行目: 60 歳以上の人数
Sample Input
8
71
34
65
11
41
39
6
5
4
67
81
78
65
0
Output for the Sample Input
2
1
0
2
1
0
2
0
0
0
0
0
0
4",Java,"import java.util.Scanner;
class Main
{
    public static void main(String args[])
    {
	Scanner scan=new Scanner(System.in);
	while(true)
	    {
		
		int n=scan.nextInt();
		if(n==0)break;
		int s[]=new int[7];
		for(int i=0;i<n;i++)
		    {
			
			int old=scan.nextInt();
			int x=old/10;
			if(x>=6)x=6;
			s[x]++;
		    }
		for(int i=0;i<7;i++)
		    {
			System.out.println(s[i]);
		    }
	    }
    }
}",1
p00184,"鶴ヶ城
会津若松市のシンボルである鶴ヶ城は、蒲生氏郷が本格的な天守閣を築城し、「鶴ヶ城」と名付けました。天守閣からは会津盆地が一望できます。また、晴れた日には、白虎隊で有名な飯盛山の山頂から鶴ヶ城を見ることができます。
会津若松市の今後の広報活動の参考にするため、鶴ヶ城に訪れた来場者について、年代調査をすることにしました。来場者の年齢を入力とし、下記の年齢区分別に人数を出力するプログラムを作成してください。
区分
年齢
10歳未満
0  ~ 9
10代
10  ~ 19
20代
20  ~ 29
30代
30  ~ 39
40代
40  ~ 49
50代
50  ~ 59
60歳以上
60  ~
Input
複数のデータセットの並びが入力として与えられます。入力の終わりはゼロひとつの行で示されます。
 各データセットは以下の形式で与えられます。
n
a
1
a
2
:
a
n
1 行目に来場者の人数
n
(1 ≤
n
≤ 1000000)、続く
n
行に
i
人目の来場者の年齢
a
i
( 0 ≤
a
i
≤ 120 ) が与えられます。
Output
データセット毎に以下の形式で人数を出力します。
1 行目: 10 歳未満の人数
2 行目: 10 代の人数
3 行目: 20 代の人数
4 行目: 30 代の人数
5 行目: 40 代の人数
6 行目: 50 代の人数
7 行目: 60 歳以上の人数
Sample Input
8
71
34
65
11
41
39
6
5
4
67
81
78
65
0
Output for the Sample Input
2
1
0
2
1
0
2
0
0
0
0
0
0
4",Python,"while True:
    n = int(input())
    if n == 0:
        break
    
    counts = [0] * 7
    
    for _ in range(n):
        age = int(input())
        if age < 10:
            counts[0] += 1
        elif age < 20:
            counts[1] += 1
        elif age < 30:
            counts[2] += 1
        elif age < 40:
            counts[3] += 1
        elif age < 50:
            counts[4] += 1
        elif age < 60:
            counts[5] += 1
        else:
            counts[6] += 1
    
    for count in counts:
        print(count)
",0
p00184,"鶴ヶ城
会津若松市のシンボルである鶴ヶ城は、蒲生氏郷が本格的な天守閣を築城し、「鶴ヶ城」と名付けました。天守閣からは会津盆地が一望できます。また、晴れた日には、白虎隊で有名な飯盛山の山頂から鶴ヶ城を見ることができます。
会津若松市の今後の広報活動の参考にするため、鶴ヶ城に訪れた来場者について、年代調査をすることにしました。来場者の年齢を入力とし、下記の年齢区分別に人数を出力するプログラムを作成してください。
区分
年齢
10歳未満
0  ~ 9
10代
10  ~ 19
20代
20  ~ 29
30代
30  ~ 39
40代
40  ~ 49
50代
50  ~ 59
60歳以上
60  ~
Input
複数のデータセットの並びが入力として与えられます。入力の終わりはゼロひとつの行で示されます。
 各データセットは以下の形式で与えられます。
n
a
1
a
2
:
a
n
1 行目に来場者の人数
n
(1 ≤
n
≤ 1000000)、続く
n
行に
i
人目の来場者の年齢
a
i
( 0 ≤
a
i
≤ 120 ) が与えられます。
Output
データセット毎に以下の形式で人数を出力します。
1 行目: 10 歳未満の人数
2 行目: 10 代の人数
3 行目: 20 代の人数
4 行目: 30 代の人数
5 行目: 40 代の人数
6 行目: 50 代の人数
7 行目: 60 歳以上の人数
Sample Input
8
71
34
65
11
41
39
6
5
4
67
81
78
65
0
Output for the Sample Input
2
1
0
2
1
0
2
0
0
0
0
0
0
4",Python,"# -*- coding: utf-8 -*-
import sys
'import math'
while 1:
    n=int(input())
    if n==0: sys.exit()
    arr=[0]*7
    while n:
        a=int(input())
        if a>60: a=61
        arr[int(a/10)]+=1
        n-=1
    for i in range(len(arr)):
        print(arr[i])",1
p00185,"ゴールドバッハ予想
ゴールドバッハ予想とは「6 以上のどんな偶数も、2 つの素数 (*1) の和として表わすことができる」というものです。
たとえば、偶数の 12 は
12 = 5 + 7
、18 は
18 = 5 + 13 = 7 + 11
などと表すことができます。
和が 134 となる 2 つの素数の組み合せをすべて書き出すと、以下の通りとなります。
134 = 3+131 = 7+127 = 31+103 = 37+97 = 61+73 = 67+67
= 131+3 = 127+7 = 103+31 = 97+37 = 73+61
与えられた数が大きくなると、いくらでも素数の組み合せが見つかるような気がします。しかし、現代数学をもってしてもこの予想を証明することも、反例を作ることもできません(*2)。ちょっと不思議な感じがしますね。
そこで、ゴールドバッハ予想を鑑賞するために、偶数
n
を入力とし、和が
n
となる 2 つの素数の組み合せの数を求めるプログラムを作成してください。
和が
n
となる素数の組み合せの数とは
n = p + q
かつ
p ≤ q
であるような正の素数
p
,
q
の組み合せの数です。上の例からわかるように和が 134 となる素数の組み合せは6 個です。
(*1)  素数とは、1 または自分自身以外に約数を持たない整数のことである。なお、1 は素数ではない。
(*2)  2007 年 2 月現在、5×10
17
までの全ての偶数について成り立つことが確かめられている。(Wikipedia)
Input
複数のデータセットの並びが入力として与えられます。入力の終わりはゼロひとつの行で示されます。 各データセットとして、１つの偶数
n
(6 ≤
n
≤ 1000000) が１行に与えられます。
データセットの数は 500 を超えません。
Output
データセット毎に素数の組み合せの数を１行に出力します。
Sample Input
134
4330
34808
98792
0
Output for the Sample Input
6
72
274
607",C,"#include <stdio.h>
#include <string.h>
#include <math.h>

#define MAX 1000001

int is_prime[MAX];

void sieve() {
    memset(is_prime, 1, sizeof(is_prime));
    is_prime[0] = is_prime[1] = 0;
    
    for (int i = 2; i * i < MAX; i++) {
        if (is_prime[i]) {
            for (int j = i * i; j < MAX; j += i) {
                is_prime[j] = 0;
            }
        }
    }
}

int main() {
    sieve();
    
    int n;
    while (scanf(""%d"", &n) == 1 && n != 0) {
        int count = 0;
        for (int p = 2; p <= n / 2; p++) {
            if (is_prime[p] && is_prime[n - p]) {
                count++;
            }
        }
        printf(""%d\n"", count);
    }
    
    return 0;
}
",0
p00185,"ゴールドバッハ予想
ゴールドバッハ予想とは「6 以上のどんな偶数も、2 つの素数 (*1) の和として表わすことができる」というものです。
たとえば、偶数の 12 は
12 = 5 + 7
、18 は
18 = 5 + 13 = 7 + 11
などと表すことができます。
和が 134 となる 2 つの素数の組み合せをすべて書き出すと、以下の通りとなります。
134 = 3+131 = 7+127 = 31+103 = 37+97 = 61+73 = 67+67
= 131+3 = 127+7 = 103+31 = 97+37 = 73+61
与えられた数が大きくなると、いくらでも素数の組み合せが見つかるような気がします。しかし、現代数学をもってしてもこの予想を証明することも、反例を作ることもできません(*2)。ちょっと不思議な感じがしますね。
そこで、ゴールドバッハ予想を鑑賞するために、偶数
n
を入力とし、和が
n
となる 2 つの素数の組み合せの数を求めるプログラムを作成してください。
和が
n
となる素数の組み合せの数とは
n = p + q
かつ
p ≤ q
であるような正の素数
p
,
q
の組み合せの数です。上の例からわかるように和が 134 となる素数の組み合せは6 個です。
(*1)  素数とは、1 または自分自身以外に約数を持たない整数のことである。なお、1 は素数ではない。
(*2)  2007 年 2 月現在、5×10
17
までの全ての偶数について成り立つことが確かめられている。(Wikipedia)
Input
複数のデータセットの並びが入力として与えられます。入力の終わりはゼロひとつの行で示されます。 各データセットとして、１つの偶数
n
(6 ≤
n
≤ 1000000) が１行に与えられます。
データセットの数は 500 を超えません。
Output
データセット毎に素数の組み合せの数を１行に出力します。
Sample Input
134
4330
34808
98792
0
Output for the Sample Input
6
72
274
607",C,"j,p[1<<20],n;
main(i)
{
	for(;++i<999;)
		if(!p[i])
			for(j=i+i;j<1<<20;j+=i)
				p[j]=1;
	for(;scanf(""%d"",&n),j=0,n;printf(""%d\n"",j))
		for(i=2;i<=n/2;i++)if(!p[i]&!p[n-i])j++;
	return 0;
}",1
p00185,"ゴールドバッハ予想
ゴールドバッハ予想とは「6 以上のどんな偶数も、2 つの素数 (*1) の和として表わすことができる」というものです。
たとえば、偶数の 12 は
12 = 5 + 7
、18 は
18 = 5 + 13 = 7 + 11
などと表すことができます。
和が 134 となる 2 つの素数の組み合せをすべて書き出すと、以下の通りとなります。
134 = 3+131 = 7+127 = 31+103 = 37+97 = 61+73 = 67+67
= 131+3 = 127+7 = 103+31 = 97+37 = 73+61
与えられた数が大きくなると、いくらでも素数の組み合せが見つかるような気がします。しかし、現代数学をもってしてもこの予想を証明することも、反例を作ることもできません(*2)。ちょっと不思議な感じがしますね。
そこで、ゴールドバッハ予想を鑑賞するために、偶数
n
を入力とし、和が
n
となる 2 つの素数の組み合せの数を求めるプログラムを作成してください。
和が
n
となる素数の組み合せの数とは
n = p + q
かつ
p ≤ q
であるような正の素数
p
,
q
の組み合せの数です。上の例からわかるように和が 134 となる素数の組み合せは6 個です。
(*1)  素数とは、1 または自分自身以外に約数を持たない整数のことである。なお、1 は素数ではない。
(*2)  2007 年 2 月現在、5×10
17
までの全ての偶数について成り立つことが確かめられている。(Wikipedia)
Input
複数のデータセットの並びが入力として与えられます。入力の終わりはゼロひとつの行で示されます。 各データセットとして、１つの偶数
n
(6 ≤
n
≤ 1000000) が１行に与えられます。
データセットの数は 500 を超えません。
Output
データセット毎に素数の組み合せの数を１行に出力します。
Sample Input
134
4330
34808
98792
0
Output for the Sample Input
6
72
274
607",Java,"import java.util.*;

public class Main {
    static boolean[] sieve;
    static int MAX = 1000001;
    
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        
        // Sieve of Eratosthenes
        sieve = new boolean[MAX];
        Arrays.fill(sieve, true);
        sieve[0] = sieve[1] = false;
        
        for (int i = 2; i * i < MAX; i++) {
            if (sieve[i]) {
                for (int j = i * i; j < MAX; j += i) {
                    sieve[j] = false;
                }
            }
        }
        
        while (true) {
            int n = sc.nextInt();
            if (n == 0) break;
            
            int count = 0;
            for (int p = 2; p <= n / 2; p++) {
                if (sieve[p] && sieve[n - p]) {
                    count++;
                }
            }
            
            System.out.println(count);
        }
        
        sc.close();
    }
}
",0
p00185,"ゴールドバッハ予想
ゴールドバッハ予想とは「6 以上のどんな偶数も、2 つの素数 (*1) の和として表わすことができる」というものです。
たとえば、偶数の 12 は
12 = 5 + 7
、18 は
18 = 5 + 13 = 7 + 11
などと表すことができます。
和が 134 となる 2 つの素数の組み合せをすべて書き出すと、以下の通りとなります。
134 = 3+131 = 7+127 = 31+103 = 37+97 = 61+73 = 67+67
= 131+3 = 127+7 = 103+31 = 97+37 = 73+61
与えられた数が大きくなると、いくらでも素数の組み合せが見つかるような気がします。しかし、現代数学をもってしてもこの予想を証明することも、反例を作ることもできません(*2)。ちょっと不思議な感じがしますね。
そこで、ゴールドバッハ予想を鑑賞するために、偶数
n
を入力とし、和が
n
となる 2 つの素数の組み合せの数を求めるプログラムを作成してください。
和が
n
となる素数の組み合せの数とは
n = p + q
かつ
p ≤ q
であるような正の素数
p
,
q
の組み合せの数です。上の例からわかるように和が 134 となる素数の組み合せは6 個です。
(*1)  素数とは、1 または自分自身以外に約数を持たない整数のことである。なお、1 は素数ではない。
(*2)  2007 年 2 月現在、5×10
17
までの全ての偶数について成り立つことが確かめられている。(Wikipedia)
Input
複数のデータセットの並びが入力として与えられます。入力の終わりはゼロひとつの行で示されます。 各データセットとして、１つの偶数
n
(6 ≤
n
≤ 1000000) が１行に与えられます。
データセットの数は 500 を超えません。
Output
データセット毎に素数の組み合せの数を１行に出力します。
Sample Input
134
4330
34808
98792
0
Output for the Sample Input
6
72
274
607",Java,"import java.util.*;
public class Main {
    static Scanner sc = new Scanner(System.in);
    static boolean[] prime = new boolean[1000001];
    static int n;
    public static void main(String[] args) {
        makePrime();
        while(read()){
            solve();
        }

    }

    static void makePrime(){
        Arrays.fill(prime, true);
        prime[0] = false;
        prime[1] = false;
        for(int i = 2; i < prime.length; i++){
            if(prime[i]){
                for(int j = i*2; j < prime.length; j += i)prime[j] = false;
            }
        }
    }

    static boolean read(){
        n = sc.nextInt();
        if( n == 0 )return false;
        return true;
    }

    static void solve(){
        int res = 0;
        for(int i = 2; i <= n/2; i++){
            if(prime[n - i] && prime[i])res++;
        }
        System.out.println(res);
    }

}",1
p00185,"ゴールドバッハ予想
ゴールドバッハ予想とは「6 以上のどんな偶数も、2 つの素数 (*1) の和として表わすことができる」というものです。
たとえば、偶数の 12 は
12 = 5 + 7
、18 は
18 = 5 + 13 = 7 + 11
などと表すことができます。
和が 134 となる 2 つの素数の組み合せをすべて書き出すと、以下の通りとなります。
134 = 3+131 = 7+127 = 31+103 = 37+97 = 61+73 = 67+67
= 131+3 = 127+7 = 103+31 = 97+37 = 73+61
与えられた数が大きくなると、いくらでも素数の組み合せが見つかるような気がします。しかし、現代数学をもってしてもこの予想を証明することも、反例を作ることもできません(*2)。ちょっと不思議な感じがしますね。
そこで、ゴールドバッハ予想を鑑賞するために、偶数
n
を入力とし、和が
n
となる 2 つの素数の組み合せの数を求めるプログラムを作成してください。
和が
n
となる素数の組み合せの数とは
n = p + q
かつ
p ≤ q
であるような正の素数
p
,
q
の組み合せの数です。上の例からわかるように和が 134 となる素数の組み合せは6 個です。
(*1)  素数とは、1 または自分自身以外に約数を持たない整数のことである。なお、1 は素数ではない。
(*2)  2007 年 2 月現在、5×10
17
までの全ての偶数について成り立つことが確かめられている。(Wikipedia)
Input
複数のデータセットの並びが入力として与えられます。入力の終わりはゼロひとつの行で示されます。 各データセットとして、１つの偶数
n
(6 ≤
n
≤ 1000000) が１行に与えられます。
データセットの数は 500 を超えません。
Output
データセット毎に素数の組み合せの数を１行に出力します。
Sample Input
134
4330
34808
98792
0
Output for the Sample Input
6
72
274
607",Python,"def sieve_of_eratosthenes(limit):
    is_prime = [True] * (limit + 1)
    is_prime[0] = is_prime[1] = False
    
    for i in range(2, int(limit**0.5) + 1):
        if is_prime[i]:
            for j in range(i*i, limit + 1, i):
                is_prime[j] = False
    
    return is_prime

# Precompute primes up to 1000000
MAX_N = 1000000
is_prime = sieve_of_eratosthenes(MAX_N)

while True:
    n = int(input())
    if n == 0:
        break
    
    count = 0
    for p in range(2, n // 2 + 1):
        if is_prime[p]:
            q = n - p
            if is_prime[q]:
                count += 1
    
    print(count)
",0
p00185,"ゴールドバッハ予想
ゴールドバッハ予想とは「6 以上のどんな偶数も、2 つの素数 (*1) の和として表わすことができる」というものです。
たとえば、偶数の 12 は
12 = 5 + 7
、18 は
18 = 5 + 13 = 7 + 11
などと表すことができます。
和が 134 となる 2 つの素数の組み合せをすべて書き出すと、以下の通りとなります。
134 = 3+131 = 7+127 = 31+103 = 37+97 = 61+73 = 67+67
= 131+3 = 127+7 = 103+31 = 97+37 = 73+61
与えられた数が大きくなると、いくらでも素数の組み合せが見つかるような気がします。しかし、現代数学をもってしてもこの予想を証明することも、反例を作ることもできません(*2)。ちょっと不思議な感じがしますね。
そこで、ゴールドバッハ予想を鑑賞するために、偶数
n
を入力とし、和が
n
となる 2 つの素数の組み合せの数を求めるプログラムを作成してください。
和が
n
となる素数の組み合せの数とは
n = p + q
かつ
p ≤ q
であるような正の素数
p
,
q
の組み合せの数です。上の例からわかるように和が 134 となる素数の組み合せは6 個です。
(*1)  素数とは、1 または自分自身以外に約数を持たない整数のことである。なお、1 は素数ではない。
(*2)  2007 年 2 月現在、5×10
17
までの全ての偶数について成り立つことが確かめられている。(Wikipedia)
Input
複数のデータセットの並びが入力として与えられます。入力の終わりはゼロひとつの行で示されます。 各データセットとして、１つの偶数
n
(6 ≤
n
≤ 1000000) が１行に与えられます。
データセットの数は 500 を超えません。
Output
データセット毎に素数の組み合せの数を１行に出力します。
Sample Input
134
4330
34808
98792
0
Output for the Sample Input
6
72
274
607",Python,"from itertools import compress
MAXN = 1000001
p = [True]*MAXN
p[0] = p[1] = False
for i in xrange(int(MAXN**0.5)+1):
    if p[i]:
        for j in xrange(i+i,MAXN,i):
            p[j] = False
while True:
    n = input()
    if n == 0:
        break
    print sum(1 for i in compress(xrange(n/2+1),p) if p[n-i])",1
p00187,"投石おみくじ
「自分の道は自分で切り開く」をモットーに、ある神社が自分自身の手で運勢を決めるおみくじを作りました。そのおみくじを引く人にはまず6つの石を投げてもらい、その投げた石の一つ目と二つ目を結ぶ 線分、三つ目と四つ目を結ぶ 線分、五つ目と六つ目を結ぶ 線分の3本の線分の交点を頂点とする 三角形の面積から運勢を決めるというものです。各運勢と三角形の面積との関係は以下のとおりです。
線分の交点を頂点とする三角形の面積
運勢
1,900,000以上
大吉 (dai-kichi)
1,000,000以上1,900,000未満
中吉 (chu-kichi)
100,000以上1,000,000未満
吉 (kichi)
0より大きく 100,000未満
小吉 (syo-kichi)
三角形なし
凶 (kyo)
しかし、三角形の面積の大きさの判定は神主さんが手計算でやっているので正確とはいえず、時間もかかってしまいます。そこで近所に住む優秀なプログラマであるあなたは、一刻でも早くプログラムを書いて神主さんを助けてあげることにしました。
3 本の線分の情報を入力とし、線分の交点を頂点とする 三角形の面積から運勢を出力するプログラムを作成してください。線分の情報は始点の座標 (
x
1
,
y
1
) と、終点の座標 (
x
2
,
y
2
) が与えられ、始点と終点の座標は必ず異なることとします。また、2 つ以上の線分が同一直線上にある場合、交点を持たない 2 つの線分がある場合、3 つの線分が 1 点で交わる場合は、「三角形なし」となります。
Input
複数のデータセットの並びが入力として与えられます。入力の終わりはゼロ4つの行で示されます。
 各データセットは以下の形式で与えられます。
line
1
line
2
line
3
i
行目に
i
番目の線分の情報が与えられます。各線分の情報は以下の形式で与えられます。
x
1
y
1
x
2
y
2
線分の端点の座標を表す整数 (
x
1
,
y
1
),  (
x
2
,
y
2
) (-1000 ≤
x
1
,
y
1
,
x
2
,
y
2
≤ 1000 ) が空白区切りで与えられます。
Output
データセット毎に、おみくじの結果を１行に出力します。
Sample Input
-3 -2 9 6
3 -2 7 6
-1 0 5 0
2 2 -1 -1
0 1 2 1
-3 -1 3 1
0 0 0 0
Output for the Sample Input
syo-kichi
kyo",C,"#include <stdio.h>
#include <math.h>

typedef struct {
    double x, y;
} Point;

typedef struct {
    Point p1, p2;
} Line;

int getIntersection(Line l1, Line l2, Point *result) {
    double x1 = l1.p1.x, y1 = l1.p1.y;
    double x2 = l1.p2.x, y2 = l1.p2.y;
    double x3 = l2.p1.x, y3 = l2.p1.y;
    double x4 = l2.p2.x, y4 = l2.p2.y;
    
    double denom = (x1 - x2) * (y3 - y4) - (y1 - y2) * (x3 - x4);
    
    if (fabs(denom) < 1e-9) {
        return 0;
    }
    
    double t = ((x1 - x3) * (y3 - y4) - (y1 - y3) * (x3 - x4)) / denom;
    
    result->x = x1 + t * (x2 - x1);
    result->y = y1 + t * (y2 - y1);
    
    return 1;
}

double triangleArea(Point p1, Point p2, Point p3) {
    return fabs((p1.x * (p2.y - p3.y) + p2.x * (p3.y - p1.y) + p3.x * (p1.y - p2.y)) / 2.0);
}

int areCollinear(Point p1, Point p2, Point p3) {
    double area = fabs((p1.x * (p2.y - p3.y) + p2.x * (p3.y - p1.y) + p3.x * (p1.y - p2.y)));
    return area < 1e-6;
}

int main() {
    Line lines[3];
    
    while (1) {
        scanf(""%lf %lf %lf %lf"", &lines[0].p1.x, &lines[0].p1.y, &lines[0].p2.x, &lines[0].p2.y);
        
        if (lines[0].p1.x == 0 && lines[0].p1.y == 0 && lines[0].p2.x == 0 && lines[0].p2.y == 0) {
            break;
        }
        
        scanf(""%lf %lf %lf %lf"", &lines[1].p1.x, &lines[1].p1.y, &lines[1].p2.x, &lines[1].p2.y);
        scanf(""%lf %lf %lf %lf"", &lines[2].p1.x, &lines[2].p1.y, &lines[2].p2.x, &lines[2].p2.y);
        
        Point intersections[3];
        
        if (!getIntersection(lines[0], lines[1], &intersections[0]) ||
            !getIntersection(lines[1], lines[2], &intersections[1]) ||
            !getIntersection(lines[2], lines[0], &intersections[2])) {
            printf(""kyo\n"");
            continue;
        }
        
        if (areCollinear(intersections[0], intersections[1], intersections[2])) {
            printf(""kyo\n"");
            continue;
        }
        
        double area = triangleArea(intersections[0], intersections[1], intersections[2]);
        
        if (area < 1e-6) {
            printf(""kyo\n"");
        } else if (area >= 1900000) {
            printf(""dai-kichi\n"");
        } else if (area >= 1000000) {
            printf(""chu-kichi\n"");
        } else if (area >= 100000) {
            printf(""kichi\n"");
        } else {
            printf(""syo-kichi\n"");
        }
    }
    
    return 0;
}
",0
p00187,"投石おみくじ
「自分の道は自分で切り開く」をモットーに、ある神社が自分自身の手で運勢を決めるおみくじを作りました。そのおみくじを引く人にはまず6つの石を投げてもらい、その投げた石の一つ目と二つ目を結ぶ 線分、三つ目と四つ目を結ぶ 線分、五つ目と六つ目を結ぶ 線分の3本の線分の交点を頂点とする 三角形の面積から運勢を決めるというものです。各運勢と三角形の面積との関係は以下のとおりです。
線分の交点を頂点とする三角形の面積
運勢
1,900,000以上
大吉 (dai-kichi)
1,000,000以上1,900,000未満
中吉 (chu-kichi)
100,000以上1,000,000未満
吉 (kichi)
0より大きく 100,000未満
小吉 (syo-kichi)
三角形なし
凶 (kyo)
しかし、三角形の面積の大きさの判定は神主さんが手計算でやっているので正確とはいえず、時間もかかってしまいます。そこで近所に住む優秀なプログラマであるあなたは、一刻でも早くプログラムを書いて神主さんを助けてあげることにしました。
3 本の線分の情報を入力とし、線分の交点を頂点とする 三角形の面積から運勢を出力するプログラムを作成してください。線分の情報は始点の座標 (
x
1
,
y
1
) と、終点の座標 (
x
2
,
y
2
) が与えられ、始点と終点の座標は必ず異なることとします。また、2 つ以上の線分が同一直線上にある場合、交点を持たない 2 つの線分がある場合、3 つの線分が 1 点で交わる場合は、「三角形なし」となります。
Input
複数のデータセットの並びが入力として与えられます。入力の終わりはゼロ4つの行で示されます。
 各データセットは以下の形式で与えられます。
line
1
line
2
line
3
i
行目に
i
番目の線分の情報が与えられます。各線分の情報は以下の形式で与えられます。
x
1
y
1
x
2
y
2
線分の端点の座標を表す整数 (
x
1
,
y
1
),  (
x
2
,
y
2
) (-1000 ≤
x
1
,
y
1
,
x
2
,
y
2
≤ 1000 ) が空白区切りで与えられます。
Output
データセット毎に、おみくじの結果を１行に出力します。
Sample Input
-3 -2 9 6
3 -2 7 6
-1 0 5 0
2 2 -1 -1
0 1 2 1
-3 -1 3 1
0 0 0 0
Output for the Sample Input
syo-kichi
kyo",C,"#include <stdio.h>

int cross(int x1,int y1,int x2,int y2,
		int x3,int y3,int x4,int y4) {
	long long b12x,b12y,b34x,b34y;
	long long b24x,b24y;
	long long b13x,b13y,b14x,b14y,b32x,b32y;
	long long g1213,g1214,g3431,g3432;
	long long n1213,n1214,n3431,n3432;
	long long n2123,n2124,n4341,n4342;

	b12x=x2-x1;b12y=y2-y1;
	b34x=x4-x3;b34y=y4-y3;
	b13x=x3-x1;b13y=y3-y1;
	b14x=x4-x1;b14y=y4-y1;
	b32x=x2-x3;b32y=y2-y3;
	b24x=x4-x2;b24y=y4-y2;

	g1213=b12x*b13y-b13x*b12y;
	g1214=b12x*b14y-b14x*b12y;
	g3431=b34x*(-b13y)-(-b13x)*b34y;
	g3432=b34x*b32y-b32x*b34y;

	n1213=b12x*b13x+b12y*b13y;
	n1214=b12x*b14x+b12y*b14y;
	n3431=b34x*(-b13x)+b34y*(-b13y);
	n3432=b34x*b32x+b34y*b32y;
	n2123=(-b12x)*(-b32x)+(-b12y)*(-b32y);
	n2124=(-b12x)*b24x+(-b12y)*b24y;
	n4341=(-b34x)*(-b14x)+(-b34y)*(-b14y);
	n4342=(-b34x)*(-b24x)+(-b34y)*(-b24y);

	if(
		((g1213<0 && g1214>0) || (g1213>0 && g1214<0)) &&
		((g3431<0 && g3432>0) || (g3431>0 && g3432<0))
	) return 1;
	if(
		(g1213==0 && n1213>=0 && n2123>=0) ||
		(g1214==0 && n1214>=0 && n2124>=0) ||
		(g3431==0 && n3431>=0 && n4341>=0) ||
		(g3432==0 && n3432>=0 && n4342>=0)
	) return 1;

	return 0;
}

/*
a1x+b1y=c1
a2x+b2y=c2
*/
int solve_houteisiki(double* x,double* y,
		int a1,int b1,int c1,
		int a2,int b2,int c2) {
	int d;
	d=a1*b2-b1*a2;
	if(d==0)return 0;
	*x=(double)(b2*c1-b1*c2)/d;
	*y=(double)(-a2*c1+a1*c2)/d;
	return 1;
}

int main(void) {
	int x[6],y[6];
	int no_triangle;
	int x1,y1,t1,x2,y2,t2,x3,y3,t3;
	double tx1,ty1,tx2,ty2,tx3,ty3;
	double s;
	while(1) {
		scanf(""%d%d%d%d"",&x[0],&y[0],&x[1],&y[1]);
		if((x[0]|y[0]|x[1]|y[1])==0)break;
		scanf(""%d%d%d%d"",&x[2],&y[2],&x[3],&y[3]);
		scanf(""%d%d%d%d"",&x[4],&y[4],&x[5],&y[5]);
		no_triangle=0;
		no_triangle=no_triangle ||
			!cross(x[0],y[0],x[1],y[1],x[2],y[2],x[3],y[3]);
		no_triangle=no_triangle ||
			!cross(x[2],y[2],x[3],y[3],x[4],y[4],x[5],y[5]);
		no_triangle=no_triangle ||
			!cross(x[4],y[4],x[5],y[5],x[0],y[0],x[1],y[1]);
		if(!no_triangle) {
			x1=y[1]-y[0];
			y1=-(x[1]-x[0]);
			t1=x[0]*(y[1]-y[0])-y[0]*(x[1]-x[0]);
			x2=y[3]-y[2];
			y2=-(x[3]-x[2]);
			t2=x[2]*(y[3]-y[2])-y[2]*(x[3]-x[2]);
			x3=y[5]-y[4];
			y3=-(x[5]-x[4]);
			t3=x[4]*(y[5]-y[4])-y[4]*(x[5]-x[4]);
			no_triangle=no_triangle ||
				!solve_houteisiki(&tx1,&ty1,
					x1,y1,t1,x2,y2,t2);
			no_triangle=no_triangle ||
				!solve_houteisiki(&tx2,&ty2,
					x2,y2,t2,x3,y3,t3);
			no_triangle=no_triangle ||
				!solve_houteisiki(&tx3,&ty3,
					x3,y3,t3,x1,y1,t1);
		}
		if(!no_triangle) {
			s=((tx2-tx1)*(ty3-ty1)-(tx3-tx1)*(ty2-ty1))/2;
			if(s<0)s=-s;
			if(s<1e-8)puts(""kyo"");
			else if(s<100000+1e-8)puts(""syo-kichi"");
			else if(s<1000000+1e-8)puts(""kichi"");
			else if(s<1900000+1e-8)puts(""chu-kichi"");
			else puts(""dai-kichi"");
		} else puts(""kyo"");
	}
	return 0;
}",1
p00187,"投石おみくじ
「自分の道は自分で切り開く」をモットーに、ある神社が自分自身の手で運勢を決めるおみくじを作りました。そのおみくじを引く人にはまず6つの石を投げてもらい、その投げた石の一つ目と二つ目を結ぶ 線分、三つ目と四つ目を結ぶ 線分、五つ目と六つ目を結ぶ 線分の3本の線分の交点を頂点とする 三角形の面積から運勢を決めるというものです。各運勢と三角形の面積との関係は以下のとおりです。
線分の交点を頂点とする三角形の面積
運勢
1,900,000以上
大吉 (dai-kichi)
1,000,000以上1,900,000未満
中吉 (chu-kichi)
100,000以上1,000,000未満
吉 (kichi)
0より大きく 100,000未満
小吉 (syo-kichi)
三角形なし
凶 (kyo)
しかし、三角形の面積の大きさの判定は神主さんが手計算でやっているので正確とはいえず、時間もかかってしまいます。そこで近所に住む優秀なプログラマであるあなたは、一刻でも早くプログラムを書いて神主さんを助けてあげることにしました。
3 本の線分の情報を入力とし、線分の交点を頂点とする 三角形の面積から運勢を出力するプログラムを作成してください。線分の情報は始点の座標 (
x
1
,
y
1
) と、終点の座標 (
x
2
,
y
2
) が与えられ、始点と終点の座標は必ず異なることとします。また、2 つ以上の線分が同一直線上にある場合、交点を持たない 2 つの線分がある場合、3 つの線分が 1 点で交わる場合は、「三角形なし」となります。
Input
複数のデータセットの並びが入力として与えられます。入力の終わりはゼロ4つの行で示されます。
 各データセットは以下の形式で与えられます。
line
1
line
2
line
3
i
行目に
i
番目の線分の情報が与えられます。各線分の情報は以下の形式で与えられます。
x
1
y
1
x
2
y
2
線分の端点の座標を表す整数 (
x
1
,
y
1
),  (
x
2
,
y
2
) (-1000 ≤
x
1
,
y
1
,
x
2
,
y
2
≤ 1000 ) が空白区切りで与えられます。
Output
データセット毎に、おみくじの結果を１行に出力します。
Sample Input
-3 -2 9 6
3 -2 7 6
-1 0 5 0
2 2 -1 -1
0 1 2 1
-3 -1 3 1
0 0 0 0
Output for the Sample Input
syo-kichi
kyo",Java,"import java.util.*;
import java.io.*;

public class Main {
    static class Point {
        double x, y;
        Point(double x, double y) {
            this.x = x;
            this.y = y;
        }
    }
    
    static class Line {
        Point p1, p2;
        Line(Point p1, Point p2) {
            this.p1 = p1;
            this.p2 = p2;
        }
    }
    
    static final double EPS = 1e-9;
    
    static Point getIntersection(Line l1, Line l2) {
        double x1 = l1.p1.x, y1 = l1.p1.y;
        double x2 = l1.p2.x, y2 = l1.p2.y;
        double x3 = l2.p1.x, y3 = l2.p1.y;
        double x4 = l2.p2.x, y4 = l2.p2.y;
        
        double denom = (x1 - x2) * (y3 - y4) - (y1 - y2) * (x3 - x4);
        
        if (Math.abs(denom) < EPS) {
            return null; // parallel or coincident
        }
        
        double t = ((x1 - x3) * (y3 - y4) - (y1 - y3) * (x3 - x4)) / denom;
        
        double px = x1 + t * (x2 - x1);
        double py = y1 + t * (y2 - y1);
        
        return new Point(px, py);
    }
    
    static boolean isParallel(Line l1, Line l2) {
        double dx1 = l1.p2.x - l1.p1.x;
        double dy1 = l1.p2.y - l1.p1.y;
        double dx2 = l2.p2.x - l2.p1.x;
        double dy2 = l2.p2.y - l2.p1.y;
        
        return Math.abs(dx1 * dy2 - dy1 * dx2) < EPS;
    }
    
    static double triangleArea(Point p1, Point p2, Point p3) {
        return Math.abs((p2.x - p1.x) * (p3.y - p1.y) - (p3.x - p1.x) * (p2.y - p1.y)) / 2.0;
    }
    
    static boolean areCollinear(Point p1, Point p2, Point p3) {
        return Math.abs((p2.x - p1.x) * (p3.y - p1.y) - (p3.x - p1.x) * (p2.y - p1.y)) < EPS;
    }
    
    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        String line;
        
        while (true) {
            line = br.readLine();
            String[] parts = line.split("" "");
            int x1 = Integer.parseInt(parts[0]);
            int y1 = Integer.parseInt(parts[1]);
            int x2 = Integer.parseInt(parts[2]);
            int y2 = Integer.parseInt(parts[3]);
            
            if (x1 == 0 && y1 == 0 && x2 == 0 && y2 == 0) break;
            
            Line l1 = new Line(new Point(x1, y1), new Point(x2, y2));
            
            line = br.readLine();
            parts = line.split("" "");
            x1 = Integer.parseInt(parts[0]);
            y1 = Integer.parseInt(parts[1]);
            x2 = Integer.parseInt(parts[2]);
            y2 = Integer.parseInt(parts[3]);
            Line l2 = new Line(new Point(x1, y1), new Point(x2, y2));
            
            line = br.readLine();
            parts = line.split("" "");
            x1 = Integer.parseInt(parts[0]);
            y1 = Integer.parseInt(parts[1]);
            x2 = Integer.parseInt(parts[2]);
            y2 = Integer.parseInt(parts[3]);
            Line l3 = new Line(new Point(x1, y1), new Point(x2, y2));
            
            Point p12 = getIntersection(l1, l2);
            Point p13 = getIntersection(l1, l3);
            Point p23 = getIntersection(l2, l3);
            
            if (p12 == null || p13 == null || p23 == null) {
                System.out.println(""kyo"");
                continue;
            }
            
            if (areCollinear(p12, p13, p23)) {
                System.out.println(""kyo"");
                continue;
            }
            
            double area = triangleArea(p12, p13, p23);
            
            if (area < EPS) {
                System.out.println(""kyo"");
            } else if (area < 100000) {
                System.out.println(""syo-kichi"");
            } else if (area < 1000000) {
                System.out.println(""kichi"");
            } else if (area < 1900000) {
                System.out.println(""chu-kichi"");
            } else {
                System.out.println(""dai-kichi"");
            }
        }
    }
}
",0
p00187,"投石おみくじ
「自分の道は自分で切り開く」をモットーに、ある神社が自分自身の手で運勢を決めるおみくじを作りました。そのおみくじを引く人にはまず6つの石を投げてもらい、その投げた石の一つ目と二つ目を結ぶ 線分、三つ目と四つ目を結ぶ 線分、五つ目と六つ目を結ぶ 線分の3本の線分の交点を頂点とする 三角形の面積から運勢を決めるというものです。各運勢と三角形の面積との関係は以下のとおりです。
線分の交点を頂点とする三角形の面積
運勢
1,900,000以上
大吉 (dai-kichi)
1,000,000以上1,900,000未満
中吉 (chu-kichi)
100,000以上1,000,000未満
吉 (kichi)
0より大きく 100,000未満
小吉 (syo-kichi)
三角形なし
凶 (kyo)
しかし、三角形の面積の大きさの判定は神主さんが手計算でやっているので正確とはいえず、時間もかかってしまいます。そこで近所に住む優秀なプログラマであるあなたは、一刻でも早くプログラムを書いて神主さんを助けてあげることにしました。
3 本の線分の情報を入力とし、線分の交点を頂点とする 三角形の面積から運勢を出力するプログラムを作成してください。線分の情報は始点の座標 (
x
1
,
y
1
) と、終点の座標 (
x
2
,
y
2
) が与えられ、始点と終点の座標は必ず異なることとします。また、2 つ以上の線分が同一直線上にある場合、交点を持たない 2 つの線分がある場合、3 つの線分が 1 点で交わる場合は、「三角形なし」となります。
Input
複数のデータセットの並びが入力として与えられます。入力の終わりはゼロ4つの行で示されます。
 各データセットは以下の形式で与えられます。
line
1
line
2
line
3
i
行目に
i
番目の線分の情報が与えられます。各線分の情報は以下の形式で与えられます。
x
1
y
1
x
2
y
2
線分の端点の座標を表す整数 (
x
1
,
y
1
),  (
x
2
,
y
2
) (-1000 ≤
x
1
,
y
1
,
x
2
,
y
2
≤ 1000 ) が空白区切りで与えられます。
Output
データセット毎に、おみくじの結果を１行に出力します。
Sample Input
-3 -2 9 6
3 -2 7 6
-1 0 5 0
2 2 -1 -1
0 1 2 1
-3 -1 3 1
0 0 0 0
Output for the Sample Input
syo-kichi
kyo",Java,"import java.util.*;
public class Main
{
	static	double EPS=1e-4;
	public static void main(String[] args) 
	{
		Scanner in=new Scanner(System.in);
		for(;;)
		{
			Point p1=new Point(in.nextDouble(), in.nextDouble()); 
			Point p2=new Point(in.nextDouble(), in.nextDouble()); 
			if(p1.x==0&&p1.y==0&&p2.x==0&&p2.y==0)
				return;
			Point p3=new Point(in.nextDouble(), in.nextDouble()); 
			Point p4=new Point(in.nextDouble(), in.nextDouble()); 
			Point p5=new Point(in.nextDouble(), in.nextDouble()); 
			Point p6=new Point(in.nextDouble(), in.nextDouble());
			boolean judge=true;
			if(!lineCross(p1, p2, p3, p4))
				judge=false;
			if(!lineCross(p3, p4, p5, p6))
				judge=false;
			if(!lineCross(p5, p6, p1, p2))
				judge=false;

			if(judge)
			{
				double a1=slanting(p1, p2);
				double a2=slanting(p3, p4);
				double x1=(a1*p1.x-p1.y-a2*p3.x+p3.y)/(a1-a2);
				if(a1==-1.123)
					x1=p1.x;
				else if(a2==-1.123)
					x1=p3.x;
				double y1=(p2.y-p1.y)/(p2.x-p1.x)*(x1-p1.x)+p1.y;
				if(a1==-1.123)
					y1=(p4.y-p3.y)/(p4.x-p3.x)*(x1-p3.x)+p3.y;

				a1=slanting(p3, p4);
				a2=slanting(p5, p6);
				double x2=(a1*p3.x-p3.y-a2*p5.x+p5.y)/(a1-a2);
				if(a1==-1.123)
					x2=p3.x;
				else if(a2==-1.123)
					x2=p5.x;
				double y2=(p4.y-p3.y)/(p4.x-p3.x)*(x2-p3.x)+p3.y;
				if(a1==-1.123)
					y2=(p5.y-p6.y)/(p5.x-p6.x)*(x2-p5.x)+p5.y;

				a1=slanting(p5, p6);
				a2=slanting(p1, p2);
				double x3=(a1*p5.x-p5.y-a2*p1.x+p1.y)/(a1-a2);
				if(a1==-1.123)
					x3=p5.x;
				else if(a2==-1.123)
					x3=p1.x;
				double y3=(p6.y-p5.y)/(p6.x-p5.x)*(x3-p5.x)+p5.y;
				if(a1==-1.123)
					y3=(p2.y-p1.y)/(p2.x-p1.x)*(x3-p1.x)+p1.y;

				double a=x2-x1;
				double b=y2-y1;
				double c=x3-x1;
				double d=y3-y1;
				double S=Math.abs(a*d-b*c)/2;
				if(S<EPS)
					System.out.println(""kyo"");
				else if(S<100000)
					System.out.println(""syo-kichi"");
				else if(S<1000000)
					System.out.println(""kichi"");
				else if(S<1900000)
					System.out.println(""chu-kichi"");
				else 
					System.out.println(""dai-kichi"");			
			}
			else
				System.out.println(""kyo"");
		}
	}

	static boolean lineCross(Point p1,Point p2,Point p3,Point p4)
	{
		double jc1=(p1.x-p2.x)*(p3.y-p1.y)+(p1.y-p2.y)*(p1.x-p3.x);
		double jd1=(p1.x-p2.x)*(p4.y-p1.y)+(p1.y-p2.y)*(p1.x-p4.x);
		double jc2=(p3.x-p4.x)*(p1.y-p3.y)+(p3.y-p4.y)*(p3.x-p1.x);
		double jd2=(p3.x-p4.x)*(p2.y-p3.y)+(p3.y-p4.y)*(p3.x-p2.x);
		return jc1*jd1<=0 && jc2*jd2<=0;
	}

	static double slanting(Point p1,Point p2)
	{
		if(Math.abs(p1.x-p2.x)<EPS)
			return -1.123;
		else
			return (p1.y-p2.y)/(p1.x-p2.x);
	}
}
class Point
{
	double x;
	double y;
	Point(double x,double y)
	{
		this.x=x;
		this.y=y;
	}
}",1
p00187,"投石おみくじ
「自分の道は自分で切り開く」をモットーに、ある神社が自分自身の手で運勢を決めるおみくじを作りました。そのおみくじを引く人にはまず6つの石を投げてもらい、その投げた石の一つ目と二つ目を結ぶ 線分、三つ目と四つ目を結ぶ 線分、五つ目と六つ目を結ぶ 線分の3本の線分の交点を頂点とする 三角形の面積から運勢を決めるというものです。各運勢と三角形の面積との関係は以下のとおりです。
線分の交点を頂点とする三角形の面積
運勢
1,900,000以上
大吉 (dai-kichi)
1,000,000以上1,900,000未満
中吉 (chu-kichi)
100,000以上1,000,000未満
吉 (kichi)
0より大きく 100,000未満
小吉 (syo-kichi)
三角形なし
凶 (kyo)
しかし、三角形の面積の大きさの判定は神主さんが手計算でやっているので正確とはいえず、時間もかかってしまいます。そこで近所に住む優秀なプログラマであるあなたは、一刻でも早くプログラムを書いて神主さんを助けてあげることにしました。
3 本の線分の情報を入力とし、線分の交点を頂点とする 三角形の面積から運勢を出力するプログラムを作成してください。線分の情報は始点の座標 (
x
1
,
y
1
) と、終点の座標 (
x
2
,
y
2
) が与えられ、始点と終点の座標は必ず異なることとします。また、2 つ以上の線分が同一直線上にある場合、交点を持たない 2 つの線分がある場合、3 つの線分が 1 点で交わる場合は、「三角形なし」となります。
Input
複数のデータセットの並びが入力として与えられます。入力の終わりはゼロ4つの行で示されます。
 各データセットは以下の形式で与えられます。
line
1
line
2
line
3
i
行目に
i
番目の線分の情報が与えられます。各線分の情報は以下の形式で与えられます。
x
1
y
1
x
2
y
2
線分の端点の座標を表す整数 (
x
1
,
y
1
),  (
x
2
,
y
2
) (-1000 ≤
x
1
,
y
1
,
x
2
,
y
2
≤ 1000 ) が空白区切りで与えられます。
Output
データセット毎に、おみくじの結果を１行に出力します。
Sample Input
-3 -2 9 6
3 -2 7 6
-1 0 5 0
2 2 -1 -1
0 1 2 1
-3 -1 3 1
0 0 0 0
Output for the Sample Input
syo-kichi
kyo",Python,"import sys
from math import isclose

def line_intersection(x1, y1, x2, y2, x3, y3, x4, y4):
    denom = (x1 - x2) * (y3 - y4) - (y1 - y2) * (x3 - x4)
    if abs(denom) < 1e-9:
        return None
    
    t = ((x1 - x3) * (y3 - y4) - (y1 - y3) * (x3 - x4)) / denom
    u = -((x1 - x2) * (y1 - y3) - (y1 - y2) * (x1 - x3)) / denom
    
    px = x1 + t * (x2 - x1)
    py = y1 + t * (y2 - y1)
    
    return (px, py)

def triangle_area(p1, p2, p3):
    x1, y1 = p1
    x2, y2 = p2
    x3, y3 = p3
    area = abs((x1 * (y2 - y3) + x2 * (y3 - y1) + x3 * (y1 - y2)) / 2.0)
    return area

def are_collinear(p1, p2, p3):
    if p1 is None or p2 is None or p3 is None:
        return True
    x1, y1 = p1
    x2, y2 = p2
    x3, y3 = p3
    area = abs((x1 * (y2 - y3) + x2 * (y3 - y1) + x3 * (y1 - y2)))
    return area < 1e-6

def solve(lines):
    # Get intersection points
    p1 = line_intersection(*lines[0], *lines[1])
    p2 = line_intersection(*lines[0], *lines[2])
    p3 = line_intersection(*lines[1], *lines[2])
    
    if p1 is None or p2 is None or p3 is None:
        return ""kyo""
    
    if are_collinear(p1, p2, p3):
        return ""kyo""
    
    area = triangle_area(p1, p2, p3)
    
    if area < 1e-9:
        return ""kyo""
    elif area < 100000:
        return ""syo-kichi""
    elif area < 1000000:
        return ""kichi""
    elif area < 1900000:
        return ""chu-kichi""
    else:
        return ""dai-kichi""

while True:
    line = input().split()
    if line == ['0', '0', '0', '0']:
        break
    
    lines = []
    lines.append([int(x) for x in line])
    for _ in range(2):
        lines.append([int(x) for x in input().split()])
    
    result = solve(lines)
    print(result)
",0
p00187,"投石おみくじ
「自分の道は自分で切り開く」をモットーに、ある神社が自分自身の手で運勢を決めるおみくじを作りました。そのおみくじを引く人にはまず6つの石を投げてもらい、その投げた石の一つ目と二つ目を結ぶ 線分、三つ目と四つ目を結ぶ 線分、五つ目と六つ目を結ぶ 線分の3本の線分の交点を頂点とする 三角形の面積から運勢を決めるというものです。各運勢と三角形の面積との関係は以下のとおりです。
線分の交点を頂点とする三角形の面積
運勢
1,900,000以上
大吉 (dai-kichi)
1,000,000以上1,900,000未満
中吉 (chu-kichi)
100,000以上1,000,000未満
吉 (kichi)
0より大きく 100,000未満
小吉 (syo-kichi)
三角形なし
凶 (kyo)
しかし、三角形の面積の大きさの判定は神主さんが手計算でやっているので正確とはいえず、時間もかかってしまいます。そこで近所に住む優秀なプログラマであるあなたは、一刻でも早くプログラムを書いて神主さんを助けてあげることにしました。
3 本の線分の情報を入力とし、線分の交点を頂点とする 三角形の面積から運勢を出力するプログラムを作成してください。線分の情報は始点の座標 (
x
1
,
y
1
) と、終点の座標 (
x
2
,
y
2
) が与えられ、始点と終点の座標は必ず異なることとします。また、2 つ以上の線分が同一直線上にある場合、交点を持たない 2 つの線分がある場合、3 つの線分が 1 点で交わる場合は、「三角形なし」となります。
Input
複数のデータセットの並びが入力として与えられます。入力の終わりはゼロ4つの行で示されます。
 各データセットは以下の形式で与えられます。
line
1
line
2
line
3
i
行目に
i
番目の線分の情報が与えられます。各線分の情報は以下の形式で与えられます。
x
1
y
1
x
2
y
2
線分の端点の座標を表す整数 (
x
1
,
y
1
),  (
x
2
,
y
2
) (-1000 ≤
x
1
,
y
1
,
x
2
,
y
2
≤ 1000 ) が空白区切りで与えられます。
Output
データセット毎に、おみくじの結果を１行に出力します。
Sample Input
-3 -2 9 6
3 -2 7 6
-1 0 5 0
2 2 -1 -1
0 1 2 1
-3 -1 3 1
0 0 0 0
Output for the Sample Input
syo-kichi
kyo",Python,"def cross3(O, A, B):
    ox, oy = O; ax, ay = A; bx, by = B
    return (ax - ox) * (by - oy) - (bx - ox) * (ay - oy)
def outer(x0, y0, x1, y1):
    return x0*y1 - x1*y0
def is_intersection(P0, P1, Q0, Q1):
    C0 = cross3(P0, P1, Q0)
    C1 = cross3(P0, P1, Q1)
    D0 = cross3(Q0, Q1, P0)
    D1 = cross3(Q0, Q1, P1)
    if C0 == C1 == 0:
        return 0
    return C0 * C1 <= 0 and D0 * D1 <= 0
def cross_point(P0, Q0, P1, Q1):
    x0, y0 = P0; x1, y1 = Q0
    x2, y2 = P1; x3, y3 = Q1
    dx0 = x1 - x0
    dy0 = y1 - y0
    dx1 = x3 - x2
    dy1 = y3 - y2

    s = (y0-y2)*dx1 - (x0-x2)*dy1
    sm = dx0*dy1 - dy0*dx1
    if s < 0:
        s = -s
        sm = -sm
    if s == 0:
        x = x0
        y = y0
    else:
        x = x0 + s*dx0/sm
        y = y0 + s*dy0/sm
    return x, y
while 1:
    x1, y1, x2, y2 = map(int, input().split())
    if x1 == y1 == x2 == y2 == 0:
        break
    P1 = (x1, y1); Q1 = (x2, y2)
    x3, y3, x4, y4 = map(int, input().split())
    P2 = (x3, y3); Q2 = (x4, y4)
    x5, y5, x6, y6 = map(int, input().split())
    P3 = (x5, y5); Q3 = (x6, y6)
    if (not is_intersection(P1, Q1, P2, Q2)
            or not is_intersection(P2, Q2, P3, Q3)
            or not is_intersection(P3, Q3, P1, Q1)):
        print(""kyo"")
        continue
    p1, q1 = cross_point(P1, Q1, P2, Q2)
    p2, q2 = cross_point(P2, Q2, P3, Q3)
    p3, q3 = cross_point(P3, Q3, P1, Q1)
    S = abs(outer(p2-p1, q2-q1, p3-p1, q3-q1)) / 2.
    if S < 1e-9:
        print(""kyo"")
    elif S < 100000:
        print(""syo-kichi"")
    elif S < 1000000:
        print(""kichi"")
    elif S < 1900000:
        print(""chu-kichi"")
    else:
        print(""dai-kichi"")
",1
p00188,"探索
「探索」とは、たくさんの情報の中から望みの情報を得る操作のことです。身近な例では、合格発表の時の「たくさんの受験番号から自分の受験番号を見つける」ことや、電話帳から「会津太郎さんの電話番号を見つける」ときなどがあります。この探索という操作はコンピュータの分野でも広く用いられています。
探索の方法は沢山あります。探索の対象となるデータが、小さい順(または大きい順)に並べられている場合に使うことができる探索の方法を考えます。
小さい順(または大きい順)に並べられているデータ列の中央に位置する値と目的の値との大小関係を用いて、中央に位置する値から前半部分を探索範囲にするか後半部分を探索範囲にするかを決めることで、探索の範囲を絞っていく方法があります。手順は以下のようになります。
データの列の全体を探索の範囲とします。
探索の範囲の中央に位置する値を調べます。
目的の値と中央に位置する値が一致すれば探索を終了します。
目的の値と中央に位置する値よりも小さければ前半部分を探索の範囲とし、大きければ後半部分を探索の範囲として2.へ戻ります。
以下は上述した探索の方法の例です。この例での目的の値は51です。それぞれのデータには番号
(index)が振られており、この番号は0から始まっています。
ステップ1: 最初は番号0~6全体を探索の範囲とします。
ステップ2: 探索の範囲の中央に位置する値を調べます。ただし、「中央に位置する値」とは、(左側の番号+右側の番号)を2で割った番号の位置にある値とします。つまり、この場合、(0 + 6) ÷ 2 を計算し、番号3にある値(36)が中央に位置する値となります。
ステップ3:目的の値(51)と中央に位置する値(36)を比較します。
ステップ4:ステップ3の結果から、目的の値は中央に位置する値より大きいので、後半部分にあたる番号4 (中央に位置する値の隣)以降を探索の範囲とします。同様の手順で探索の範囲の中央に位置する値を調べ、目的の値が中央に位置する値より小さければ前半部分を探索の範囲とし、大きければ後半部分を探索の範囲として、探索の範囲を小さくしていきます。(ステップ2~ステップ4の繰り返し)目的の値が中央に位置する値と一致するか、探索の範囲がつきてしまった時に探索を終了します。
n
個の数値の配列を入力とし、目的の値と中央に位置する値を比較した回数を出力するプログラムを作成してください。ただし、中央に位置する値の番号を計算したとき、割り切れない場合は、小数点以下を切り捨てた値をその番号とすることとします。
与えられるデータ列は小さい順に整列されているものとします。
Input
複数のデータセットの並びが入力として与えられます。入力の終わりはゼロひとつの行で示されます。 各データセットは以下の形式で与えられます。
n
a
1
a
2
:
a
n
k
1 行目に数値の数
n
(1 ≤
n
≤ 100) 、続く
n
行に
i
個目の数値
a
i
(1 ≤
a
i
≤ 100000, 整数) が与えられます。
続く行に探索する値
k
(1 ≤
k
≤ 100000) が与えられます。
Output
データセット毎に探索が終わるまでの比較回数を１行に出力します。
Sample Input
7
11
15
23
36
51
61
86
51
4
1
2
3
5
4
0
Output for the Sample Input
3
3",C,"#include <stdio.h>

int binarySearch(int arr[], int n, int target) {
    int left = 0;
    int right = n - 1;
    int count = 0;
    
    while (left <= right) {
        int mid = (left + right) / 2;
        count++;
        
        if (arr[mid] == target) {
            return count;
        } else if (target < arr[mid]) {
            right = mid - 1;
        } else {
            left = mid + 1;
        }
    }
    
    return count;
}

int main() {
    int n;
    
    while (scanf(""%d"", &n) == 1 && n != 0) {
        int arr[100];
        
        for (int i = 0; i < n; i++) {
            scanf(""%d"", &arr[i]);
        }
        
        int k;
        scanf(""%d"", &k);
        
        int result = binarySearch(arr, n, k);
        printf(""%d\n"", result);
    }
    
    return 0;
}
",0
p00188,"探索
「探索」とは、たくさんの情報の中から望みの情報を得る操作のことです。身近な例では、合格発表の時の「たくさんの受験番号から自分の受験番号を見つける」ことや、電話帳から「会津太郎さんの電話番号を見つける」ときなどがあります。この探索という操作はコンピュータの分野でも広く用いられています。
探索の方法は沢山あります。探索の対象となるデータが、小さい順(または大きい順)に並べられている場合に使うことができる探索の方法を考えます。
小さい順(または大きい順)に並べられているデータ列の中央に位置する値と目的の値との大小関係を用いて、中央に位置する値から前半部分を探索範囲にするか後半部分を探索範囲にするかを決めることで、探索の範囲を絞っていく方法があります。手順は以下のようになります。
データの列の全体を探索の範囲とします。
探索の範囲の中央に位置する値を調べます。
目的の値と中央に位置する値が一致すれば探索を終了します。
目的の値と中央に位置する値よりも小さければ前半部分を探索の範囲とし、大きければ後半部分を探索の範囲として2.へ戻ります。
以下は上述した探索の方法の例です。この例での目的の値は51です。それぞれのデータには番号
(index)が振られており、この番号は0から始まっています。
ステップ1: 最初は番号0~6全体を探索の範囲とします。
ステップ2: 探索の範囲の中央に位置する値を調べます。ただし、「中央に位置する値」とは、(左側の番号+右側の番号)を2で割った番号の位置にある値とします。つまり、この場合、(0 + 6) ÷ 2 を計算し、番号3にある値(36)が中央に位置する値となります。
ステップ3:目的の値(51)と中央に位置する値(36)を比較します。
ステップ4:ステップ3の結果から、目的の値は中央に位置する値より大きいので、後半部分にあたる番号4 (中央に位置する値の隣)以降を探索の範囲とします。同様の手順で探索の範囲の中央に位置する値を調べ、目的の値が中央に位置する値より小さければ前半部分を探索の範囲とし、大きければ後半部分を探索の範囲として、探索の範囲を小さくしていきます。(ステップ2~ステップ4の繰り返し)目的の値が中央に位置する値と一致するか、探索の範囲がつきてしまった時に探索を終了します。
n
個の数値の配列を入力とし、目的の値と中央に位置する値を比較した回数を出力するプログラムを作成してください。ただし、中央に位置する値の番号を計算したとき、割り切れない場合は、小数点以下を切り捨てた値をその番号とすることとします。
与えられるデータ列は小さい順に整列されているものとします。
Input
複数のデータセットの並びが入力として与えられます。入力の終わりはゼロひとつの行で示されます。 各データセットは以下の形式で与えられます。
n
a
1
a
2
:
a
n
k
1 行目に数値の数
n
(1 ≤
n
≤ 100) 、続く
n
行に
i
個目の数値
a
i
(1 ≤
a
i
≤ 100000, 整数) が与えられます。
続く行に探索する値
k
(1 ≤
k
≤ 100000) が与えられます。
Output
データセット毎に探索が終わるまでの比較回数を１行に出力します。
Sample Input
7
11
15
23
36
51
61
86
51
4
1
2
3
5
4
0
Output for the Sample Input
3
3",C,"#define _CRT_SECURE_NO_WARNINGS
//#define _USE_MATH_DEFINES
#include<stdio.h>
//#include<stdlib.h>
//#include<math.h>
//#include<string.h>
#define P(type,x) fprintf(stdout,""%""#type""\n"",x)
int main() {
	int n, l, m, r, A[100] = {}, i,key,cnt;
	while (~fscanf(stdin, ""%d"", &n), n) {
		l = cnt = 0, r = n - 1;
		for (i = 0; i < n; i++) fscanf(stdin, ""%d"", &A[i]);
		fscanf(stdin, ""%d"", &key);
		while (l <= r) {
			m = (l + r) / 2;
			cnt++;
			if (A[m] > key) r = m-1;
			else if (A[m] < key) l = m+1;
			else break;
		}
		P(d, cnt);
	}
	return 0;
}",1
p00188,"探索
「探索」とは、たくさんの情報の中から望みの情報を得る操作のことです。身近な例では、合格発表の時の「たくさんの受験番号から自分の受験番号を見つける」ことや、電話帳から「会津太郎さんの電話番号を見つける」ときなどがあります。この探索という操作はコンピュータの分野でも広く用いられています。
探索の方法は沢山あります。探索の対象となるデータが、小さい順(または大きい順)に並べられている場合に使うことができる探索の方法を考えます。
小さい順(または大きい順)に並べられているデータ列の中央に位置する値と目的の値との大小関係を用いて、中央に位置する値から前半部分を探索範囲にするか後半部分を探索範囲にするかを決めることで、探索の範囲を絞っていく方法があります。手順は以下のようになります。
データの列の全体を探索の範囲とします。
探索の範囲の中央に位置する値を調べます。
目的の値と中央に位置する値が一致すれば探索を終了します。
目的の値と中央に位置する値よりも小さければ前半部分を探索の範囲とし、大きければ後半部分を探索の範囲として2.へ戻ります。
以下は上述した探索の方法の例です。この例での目的の値は51です。それぞれのデータには番号
(index)が振られており、この番号は0から始まっています。
ステップ1: 最初は番号0~6全体を探索の範囲とします。
ステップ2: 探索の範囲の中央に位置する値を調べます。ただし、「中央に位置する値」とは、(左側の番号+右側の番号)を2で割った番号の位置にある値とします。つまり、この場合、(0 + 6) ÷ 2 を計算し、番号3にある値(36)が中央に位置する値となります。
ステップ3:目的の値(51)と中央に位置する値(36)を比較します。
ステップ4:ステップ3の結果から、目的の値は中央に位置する値より大きいので、後半部分にあたる番号4 (中央に位置する値の隣)以降を探索の範囲とします。同様の手順で探索の範囲の中央に位置する値を調べ、目的の値が中央に位置する値より小さければ前半部分を探索の範囲とし、大きければ後半部分を探索の範囲として、探索の範囲を小さくしていきます。(ステップ2~ステップ4の繰り返し)目的の値が中央に位置する値と一致するか、探索の範囲がつきてしまった時に探索を終了します。
n
個の数値の配列を入力とし、目的の値と中央に位置する値を比較した回数を出力するプログラムを作成してください。ただし、中央に位置する値の番号を計算したとき、割り切れない場合は、小数点以下を切り捨てた値をその番号とすることとします。
与えられるデータ列は小さい順に整列されているものとします。
Input
複数のデータセットの並びが入力として与えられます。入力の終わりはゼロひとつの行で示されます。 各データセットは以下の形式で与えられます。
n
a
1
a
2
:
a
n
k
1 行目に数値の数
n
(1 ≤
n
≤ 100) 、続く
n
行に
i
個目の数値
a
i
(1 ≤
a
i
≤ 100000, 整数) が与えられます。
続く行に探索する値
k
(1 ≤
k
≤ 100000) が与えられます。
Output
データセット毎に探索が終わるまでの比較回数を１行に出力します。
Sample Input
7
11
15
23
36
51
61
86
51
4
1
2
3
5
4
0
Output for the Sample Input
3
3",Java,"import java.util.Scanner;

public class Main {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        
        while (true) {
            int n = sc.nextInt();
            if (n == 0) break;
            
            int[] arr = new int[n];
            for (int i = 0; i < n; i++) {
                arr[i] = sc.nextInt();
            }
            
            int k = sc.nextInt();
            
            int count = 0;
            int left = 0;
            int right = n - 1;
            
            while (left <= right) {
                int mid = (left + right) / 2;
                count++;
                
                if (arr[mid] == k) {
                    break;
                } else if (k < arr[mid]) {
                    right = mid - 1;
                } else {
                    left = mid + 1;
                }
            }
            
            System.out.println(count);
        }
        
        sc.close();
    }
}
",0
p00188,"探索
「探索」とは、たくさんの情報の中から望みの情報を得る操作のことです。身近な例では、合格発表の時の「たくさんの受験番号から自分の受験番号を見つける」ことや、電話帳から「会津太郎さんの電話番号を見つける」ときなどがあります。この探索という操作はコンピュータの分野でも広く用いられています。
探索の方法は沢山あります。探索の対象となるデータが、小さい順(または大きい順)に並べられている場合に使うことができる探索の方法を考えます。
小さい順(または大きい順)に並べられているデータ列の中央に位置する値と目的の値との大小関係を用いて、中央に位置する値から前半部分を探索範囲にするか後半部分を探索範囲にするかを決めることで、探索の範囲を絞っていく方法があります。手順は以下のようになります。
データの列の全体を探索の範囲とします。
探索の範囲の中央に位置する値を調べます。
目的の値と中央に位置する値が一致すれば探索を終了します。
目的の値と中央に位置する値よりも小さければ前半部分を探索の範囲とし、大きければ後半部分を探索の範囲として2.へ戻ります。
以下は上述した探索の方法の例です。この例での目的の値は51です。それぞれのデータには番号
(index)が振られており、この番号は0から始まっています。
ステップ1: 最初は番号0~6全体を探索の範囲とします。
ステップ2: 探索の範囲の中央に位置する値を調べます。ただし、「中央に位置する値」とは、(左側の番号+右側の番号)を2で割った番号の位置にある値とします。つまり、この場合、(0 + 6) ÷ 2 を計算し、番号3にある値(36)が中央に位置する値となります。
ステップ3:目的の値(51)と中央に位置する値(36)を比較します。
ステップ4:ステップ3の結果から、目的の値は中央に位置する値より大きいので、後半部分にあたる番号4 (中央に位置する値の隣)以降を探索の範囲とします。同様の手順で探索の範囲の中央に位置する値を調べ、目的の値が中央に位置する値より小さければ前半部分を探索の範囲とし、大きければ後半部分を探索の範囲として、探索の範囲を小さくしていきます。(ステップ2~ステップ4の繰り返し)目的の値が中央に位置する値と一致するか、探索の範囲がつきてしまった時に探索を終了します。
n
個の数値の配列を入力とし、目的の値と中央に位置する値を比較した回数を出力するプログラムを作成してください。ただし、中央に位置する値の番号を計算したとき、割り切れない場合は、小数点以下を切り捨てた値をその番号とすることとします。
与えられるデータ列は小さい順に整列されているものとします。
Input
複数のデータセットの並びが入力として与えられます。入力の終わりはゼロひとつの行で示されます。 各データセットは以下の形式で与えられます。
n
a
1
a
2
:
a
n
k
1 行目に数値の数
n
(1 ≤
n
≤ 100) 、続く
n
行に
i
個目の数値
a
i
(1 ≤
a
i
≤ 100000, 整数) が与えられます。
続く行に探索する値
k
(1 ≤
k
≤ 100000) が与えられます。
Output
データセット毎に探索が終わるまでの比較回数を１行に出力します。
Sample Input
7
11
15
23
36
51
61
86
51
4
1
2
3
5
4
0
Output for the Sample Input
3
3",Java,"import java.util.*;

public class Main{
    Main(){
	Scanner sc = new Scanner(System.in);

	while(sc.hasNext()){
	    int r = sc.nextInt(), t, cnt=1, l=0;
	    if(r == 0) break;
	    int[] ary = new int[r+1];
	    
	    for(int i = 0; i < r; i++)
		ary[i] = sc.nextInt();
	    t = sc.nextInt();
	    r--;

	    while(l <= r){
		int v = (l+r)/2;

		if(ary[v] == t || l >= r) break;
		else if(ary[v] < t) l = v+1;
		else r = v-1;

		cnt++;
	    }

	    System.out.println(Integer.toString(cnt));
	}
    }

    public static void main(String[] args){
	new Main();
    }
}",1
p00188,"探索
「探索」とは、たくさんの情報の中から望みの情報を得る操作のことです。身近な例では、合格発表の時の「たくさんの受験番号から自分の受験番号を見つける」ことや、電話帳から「会津太郎さんの電話番号を見つける」ときなどがあります。この探索という操作はコンピュータの分野でも広く用いられています。
探索の方法は沢山あります。探索の対象となるデータが、小さい順(または大きい順)に並べられている場合に使うことができる探索の方法を考えます。
小さい順(または大きい順)に並べられているデータ列の中央に位置する値と目的の値との大小関係を用いて、中央に位置する値から前半部分を探索範囲にするか後半部分を探索範囲にするかを決めることで、探索の範囲を絞っていく方法があります。手順は以下のようになります。
データの列の全体を探索の範囲とします。
探索の範囲の中央に位置する値を調べます。
目的の値と中央に位置する値が一致すれば探索を終了します。
目的の値と中央に位置する値よりも小さければ前半部分を探索の範囲とし、大きければ後半部分を探索の範囲として2.へ戻ります。
以下は上述した探索の方法の例です。この例での目的の値は51です。それぞれのデータには番号
(index)が振られており、この番号は0から始まっています。
ステップ1: 最初は番号0~6全体を探索の範囲とします。
ステップ2: 探索の範囲の中央に位置する値を調べます。ただし、「中央に位置する値」とは、(左側の番号+右側の番号)を2で割った番号の位置にある値とします。つまり、この場合、(0 + 6) ÷ 2 を計算し、番号3にある値(36)が中央に位置する値となります。
ステップ3:目的の値(51)と中央に位置する値(36)を比較します。
ステップ4:ステップ3の結果から、目的の値は中央に位置する値より大きいので、後半部分にあたる番号4 (中央に位置する値の隣)以降を探索の範囲とします。同様の手順で探索の範囲の中央に位置する値を調べ、目的の値が中央に位置する値より小さければ前半部分を探索の範囲とし、大きければ後半部分を探索の範囲として、探索の範囲を小さくしていきます。(ステップ2~ステップ4の繰り返し)目的の値が中央に位置する値と一致するか、探索の範囲がつきてしまった時に探索を終了します。
n
個の数値の配列を入力とし、目的の値と中央に位置する値を比較した回数を出力するプログラムを作成してください。ただし、中央に位置する値の番号を計算したとき、割り切れない場合は、小数点以下を切り捨てた値をその番号とすることとします。
与えられるデータ列は小さい順に整列されているものとします。
Input
複数のデータセットの並びが入力として与えられます。入力の終わりはゼロひとつの行で示されます。 各データセットは以下の形式で与えられます。
n
a
1
a
2
:
a
n
k
1 行目に数値の数
n
(1 ≤
n
≤ 100) 、続く
n
行に
i
個目の数値
a
i
(1 ≤
a
i
≤ 100000, 整数) が与えられます。
続く行に探索する値
k
(1 ≤
k
≤ 100000) が与えられます。
Output
データセット毎に探索が終わるまでの比較回数を１行に出力します。
Sample Input
7
11
15
23
36
51
61
86
51
4
1
2
3
5
4
0
Output for the Sample Input
3
3",Python,"while True:
    n = int(input())
    if n == 0:
        break
    
    arr = []
    for _ in range(n):
        arr.append(int(input()))
    
    k = int(input())
    
    left = 0
    right = n - 1
    count = 0
    
    while left <= right:
        mid = (left + right) // 2
        count += 1
        
        if arr[mid] == k:
            break
        elif k < arr[mid]:
            right = mid - 1
        else:
            left = mid + 1
    
    print(count)
",0
p00188,"探索
「探索」とは、たくさんの情報の中から望みの情報を得る操作のことです。身近な例では、合格発表の時の「たくさんの受験番号から自分の受験番号を見つける」ことや、電話帳から「会津太郎さんの電話番号を見つける」ときなどがあります。この探索という操作はコンピュータの分野でも広く用いられています。
探索の方法は沢山あります。探索の対象となるデータが、小さい順(または大きい順)に並べられている場合に使うことができる探索の方法を考えます。
小さい順(または大きい順)に並べられているデータ列の中央に位置する値と目的の値との大小関係を用いて、中央に位置する値から前半部分を探索範囲にするか後半部分を探索範囲にするかを決めることで、探索の範囲を絞っていく方法があります。手順は以下のようになります。
データの列の全体を探索の範囲とします。
探索の範囲の中央に位置する値を調べます。
目的の値と中央に位置する値が一致すれば探索を終了します。
目的の値と中央に位置する値よりも小さければ前半部分を探索の範囲とし、大きければ後半部分を探索の範囲として2.へ戻ります。
以下は上述した探索の方法の例です。この例での目的の値は51です。それぞれのデータには番号
(index)が振られており、この番号は0から始まっています。
ステップ1: 最初は番号0~6全体を探索の範囲とします。
ステップ2: 探索の範囲の中央に位置する値を調べます。ただし、「中央に位置する値」とは、(左側の番号+右側の番号)を2で割った番号の位置にある値とします。つまり、この場合、(0 + 6) ÷ 2 を計算し、番号3にある値(36)が中央に位置する値となります。
ステップ3:目的の値(51)と中央に位置する値(36)を比較します。
ステップ4:ステップ3の結果から、目的の値は中央に位置する値より大きいので、後半部分にあたる番号4 (中央に位置する値の隣)以降を探索の範囲とします。同様の手順で探索の範囲の中央に位置する値を調べ、目的の値が中央に位置する値より小さければ前半部分を探索の範囲とし、大きければ後半部分を探索の範囲として、探索の範囲を小さくしていきます。(ステップ2~ステップ4の繰り返し)目的の値が中央に位置する値と一致するか、探索の範囲がつきてしまった時に探索を終了します。
n
個の数値の配列を入力とし、目的の値と中央に位置する値を比較した回数を出力するプログラムを作成してください。ただし、中央に位置する値の番号を計算したとき、割り切れない場合は、小数点以下を切り捨てた値をその番号とすることとします。
与えられるデータ列は小さい順に整列されているものとします。
Input
複数のデータセットの並びが入力として与えられます。入力の終わりはゼロひとつの行で示されます。 各データセットは以下の形式で与えられます。
n
a
1
a
2
:
a
n
k
1 行目に数値の数
n
(1 ≤
n
≤ 100) 、続く
n
行に
i
個目の数値
a
i
(1 ≤
a
i
≤ 100000, 整数) が与えられます。
続く行に探索する値
k
(1 ≤
k
≤ 100000) が与えられます。
Output
データセット毎に探索が終わるまでの比較回数を１行に出力します。
Sample Input
7
11
15
23
36
51
61
86
51
4
1
2
3
5
4
0
Output for the Sample Input
3
3",Python,"import math

def f(check, n, L, count):
    count += 1
    median = int(math.floor(float(n-1)/2))
    if len(L) == 1:
        return count
    elif L[median] == check:
        return count
    elif L[median] < check:
        L = L[median+1:]
    elif check < L[median]:
        L = L[:median]
    n = len(L)
    return f(check, n, L, count)

while True:
    n = int(raw_input())
    if n == 0: break
    L = [int(raw_input()) for i in range(n)]
    check = int(raw_input())
    print f(check, n, L, 0)",1
p00190,"11 パズル
太郎君は 8 パズルが大得意で休み時間などにいつも友達に並び替えてもらって遊んでいます。そんなとき、友達から「もっと複雑なパズルは解ける?」と聞かれたのですが、他のパズルはやったことはありません。どうやらその友達は自作で 11 パズルを作っていたみたいです。そのパズルは以下のような形をしています。
11 パズルは 11 枚の正方形のカードと、図 1 のような形の枠を使って行います。最初に 11 枚のカードを枠に入れます。すると 2 カ所の空きスペースができますので、この空きスペースに隣接したカードを動かすことができます。これを繰り返し、カードをきれいに整列して、図 2 の完成型にすることが 11 パズルの目的です。
太郎君はこのパズルに挑戦することにしました。ところが太郎君はこの 11 パズルをいとも簡単に解いてしまいました。そこで友達は「動かす数を一番少なくして解いてよ!」と無茶なことを言ってきました。太郎君は答えがわからないので、プログラムのできるあなたに 11 パズルを解くときの最小ステップ数を出すプログラムを作成してもらってから挑戦することにしました。このとき、2 カ所動かせるところがあるのですが、一つの数字を 1 スペース分移動させることを1ステップとして考えることとします。
11 パズルの初期状態を入力とし、11 パズルを解くときの最小ステップ数を出力するプログラムを作成してください。ただし、パズルを解くときの最小ステップ数が 20 ステップより多くかかってしまう場合は、「NA」と出力してください。パズルの状態は、一行目の情報から順に入力されるものとし、数字の 0 は空きスペースを表します。例えば、図 1 の状態を表す入力は以下のようになります。
6
2 1 3
10 5 7 0 8
9 4 11
0
Input
複数のデータセットの並びが入力として与えられます。入力の終わりは-1ひとつの行で示されます。 各データセットは以下の形式で与えられます。
p
1
p
2
p
3
p
4
p
5
p
6
p
7
p
8
p
9
p
10
p
11
p
12
p
13
i
行目にパズルの
i
行目の情報
p
i
(0 ≤
p
i
≤ 11) が空白区切りで与えられます。
データセットの数は 100 を超えません。
Output
データセット毎に、最小ステップ数または NA を１行に出力します。
Sample Input
2
1 0 3
4 5 6 7 8
9 0 11
10
0
1 2 3
4 5 6 7 8
9 10 11
0
0
11 10 9
8 7 6 5 4
3 2 1
0
-1
Output for the Sample Input
2
0
NA",C,"#include <stdio.h>
#include <string.h>
#include <stdlib.h>

#define MAX_DEPTH 20

typedef struct {
    int board[13];
    int zero1, zero2;
} State;

int goal[13] = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 0, 0};

int adj[13][5] = {
    {1, -1, -1, -1, -1},     // 0
    {0, 2, 3, -1, -1},       // 1
    {1, 4, -1, -1, -1},      // 2
    {1, 4, 5, -1, -1},       // 3
    {2, 3, 6, 8, -1},        // 4
    {3, 6, 9, -1, -1},       // 5
    {4, 5, 7, 10, -1},       // 6
    {6, 8, 11, -1, -1},      // 7
    {4, 7, 11, -1, -1},      // 8
    {5, 10, -1, -1, -1},     // 9
    {6, 9, 11, -1, -1},      // 10
    {7, 8, 10, 12, -1},      // 11
    {11, -1, -1, -1, -1}     // 12
};

int isGoal(State *s) {
    for (int i = 0; i < 13; i++) {
        if (s->board[i] != goal[i]) return 0;
    }
    return 1;
}

typedef struct {
    State state;
    int depth;
} QueueItem;

QueueItem queue[10000000];
int qfront, qback;

unsigned long long hash(State *s) {
    unsigned long long h = 0;
    for (int i = 0; i < 13; i++) {
        h = h * 13 + s->board[i];
    }
    return h;
}

int visited[1 << 24];

int getVisitedIndex(unsigned long long h) {
    return (int)(h % (1 << 24));
}

int solve(State *init) {
    if (isGoal(init)) return 0;
    
    memset(visited, 0, sizeof(visited));
    qfront = qback = 0;
    
    queue[qback].state = *init;
    queue[qback].depth = 0;
    qback++;
    
    unsigned long long h = hash(init);
    visited[getVisitedIndex(h)] = 1;
    
    while (qfront < qback) {
        QueueItem cur = queue[qfront++];
        
        if (cur.depth >= MAX_DEPTH) continue;
        
        int zeros[2] = {cur.state.zero1, cur.state.zero2};
        
        for (int zi = 0; zi < 2; zi++) {
            int zpos = zeros[zi];
            
            for (int i = 0; adj[zpos][i] != -1; i++) {
                int npos = adj[zpos][i];
                
                State next = cur.state;
                next.board[zpos] = next.board[npos];
                next.board[npos] = 0;
                
                if (zi == 0) {
                    next.zero1 = npos;
                } else {
                    next.zero2 = npos;
                }
                
                if (next.zero1 > next.zero2) {
                    int tmp = next.zero1;
                    next.zero1 = next.zero2;
                    next.zero2 = tmp;
                }
                
                if (isGoal(&next)) {
                    return cur.depth + 1;
                }
                
                h = hash(&next);
                int idx = getVisitedIndex(h);
                if (!visited[idx]) {
                    visited[idx] = 1;
                    queue[qback].state = next;
                    queue[qback].depth = cur.depth + 1;
                    qback++;
                }
            }
        }
    }
    
    return -1;
}

int main() {
    int first;
    while (scanf(""%d"", &first) == 1 && first != -1) {
        State init;
        init.board[0] = first;
        
        for (int i = 1; i < 13; i++) {
            scanf(""%d"", &init.board[i]);
        }
        
        init.zero1 = -1;
        init.zero2 = -1;
        for (int i = 0; i < 13; i++) {
            if (init.board[i] == 0) {
                if (init.zero1 == -1) init.zero1 = i;
                else init.zero2 = i;
            }
        }
        
        int result = solve(&init);
        
        if (result == -1) {
            printf(""NA\n"");
        } else {
            printf(""%d\n"", result);
        }
    }
    
    return 0;
}
",0
p00190,"11 パズル
太郎君は 8 パズルが大得意で休み時間などにいつも友達に並び替えてもらって遊んでいます。そんなとき、友達から「もっと複雑なパズルは解ける?」と聞かれたのですが、他のパズルはやったことはありません。どうやらその友達は自作で 11 パズルを作っていたみたいです。そのパズルは以下のような形をしています。
11 パズルは 11 枚の正方形のカードと、図 1 のような形の枠を使って行います。最初に 11 枚のカードを枠に入れます。すると 2 カ所の空きスペースができますので、この空きスペースに隣接したカードを動かすことができます。これを繰り返し、カードをきれいに整列して、図 2 の完成型にすることが 11 パズルの目的です。
太郎君はこのパズルに挑戦することにしました。ところが太郎君はこの 11 パズルをいとも簡単に解いてしまいました。そこで友達は「動かす数を一番少なくして解いてよ!」と無茶なことを言ってきました。太郎君は答えがわからないので、プログラムのできるあなたに 11 パズルを解くときの最小ステップ数を出すプログラムを作成してもらってから挑戦することにしました。このとき、2 カ所動かせるところがあるのですが、一つの数字を 1 スペース分移動させることを1ステップとして考えることとします。
11 パズルの初期状態を入力とし、11 パズルを解くときの最小ステップ数を出力するプログラムを作成してください。ただし、パズルを解くときの最小ステップ数が 20 ステップより多くかかってしまう場合は、「NA」と出力してください。パズルの状態は、一行目の情報から順に入力されるものとし、数字の 0 は空きスペースを表します。例えば、図 1 の状態を表す入力は以下のようになります。
6
2 1 3
10 5 7 0 8
9 4 11
0
Input
複数のデータセットの並びが入力として与えられます。入力の終わりは-1ひとつの行で示されます。 各データセットは以下の形式で与えられます。
p
1
p
2
p
3
p
4
p
5
p
6
p
7
p
8
p
9
p
10
p
11
p
12
p
13
i
行目にパズルの
i
行目の情報
p
i
(0 ≤
p
i
≤ 11) が空白区切りで与えられます。
データセットの数は 100 を超えません。
Output
データセット毎に、最小ステップ数または NA を１行に出力します。
Sample Input
2
1 0 3
4 5 6 7 8
9 0 11
10
0
1 2 3
4 5 6 7 8
9 10 11
0
0
11 10 9
8 7 6 5 4
3 2 1
0
-1
Output for the Sample Input
2
0
NA",C,"#include <stdio.h>
#include <math.h>
#include <stdlib.h>

typedef struct{
	long long int code;
	int steps;
} puzz;

int q[10000000][14],size[30000],size2[30000];
long long int FR,TO,SW;
puzz* hash[30000][100],hash2[30000][100];

void swap (int* x,int* y){
	int z;
	z=*x;
	*x=*y;
	*y=z;
}

long long int convert(int a[]){
	long long int ret=0;
	int i;
	for(i=0;i<13;i++)ret=ret*13+a[i];
	return ret;
}

void hashadd(long long int code,int step){
	int ccc=code%30000;
	puzz* ppp=(puzz*)malloc(sizeof(puzz));
	ppp->code=code;
	ppp->steps=step;
	if(size[ccc]>99){fprintf(stderr,""SIZE OVER!! (%d)\n"",ccc);return;}
	hash[ccc][size[ccc]]=ppp;
	size[ccc]++;
}

int hashsearch(long long int code){
	int ccc=code%30000;
	int i=size[ccc];
	for(i--;i>=0;i--){
		if(hash[ccc][i]->code==code)return hash[ccc][i]->steps;
	}
	return -1;
}

void mark(int x,int y){
	int k;
	long long int cd;

	swap(&q[FR][x],&q[FR][y]);
	cd=convert(q[FR]);

	if(SW==1 || hashsearch(cd)<0){
		for(k=0;k<14;k++){q[TO][k]=q[FR][k];}
		q[TO][13]++;
		if(SW==0)hashadd(cd,q[TO][13]);
		TO++;
	}

	swap(&q[FR][x],&q[FR][y]);

}

void check(){
	if(q[FR][0]==0){mark(0,2);}
	if(q[FR][1]==0){mark(1,2);mark(1,5);}
	if(q[FR][2]==0){mark(2,0);mark(2,1);mark(2,3);mark(2,6);}
	if(q[FR][3]==0){mark(3,2);mark(3,7);}
	if(q[FR][4]==0){mark(4,5);}
	if(q[FR][5]==0){mark(5,1);mark(5,4);mark(5,6);mark(5,9);}
	if(q[FR][6]==0){mark(6,2);mark(6,5);mark(6,7);mark(6,10);}
	if(q[FR][7]==0){mark(7,3);mark(7,6);mark(7,8);mark(7,11);}
	if(q[FR][8]==0){mark(8,7);}
	if(q[FR][9]==0){mark(9,5);mark(9,10);}
	if(q[FR][10]==0){mark(10,6);mark(10,9);mark(10,11);mark(10,12);}
	if(q[FR][11]==0){mark(11,7);mark(11,10);}
	if(q[FR][12]==0){mark(12,10);}
}


int main(){
	int i,ans;
	long long int cd;

	for(i=1;i<12;i++)q[0][i]=i;
	q[0][0]=0;q[0][12]=0;q[0][13]=0;

	FR=0;TO=1;SW=0;

	while(FR<TO && q[FR][13]<=13){
		check();
		FR++;
	}

	while(scanf(""%d"",&q[0][0])*q[0][0]>=0){
		for(i=1;i<13;i++)scanf(""%d"",&q[0][i]);
		q[0][13]=0;FR=0;TO=1;SW=1;ans=9999;
		//for(i=0;i<30000;i++)size2[i]=0;

		while(FR<TO){
			cd=hashsearch(convert(q[FR]));
			if(cd>=0){
				if(FR>0 && cd!=14)fprintf(stderr,""%d?\n"",cd);
				ans=(int)cd+q[FR][13];
				break;
			}
			if(q[FR][13]<6)check();
			FR++;
		}

		if(ans>20 && ans<9999)fprintf(stderr,""ans:%d?\n"",ans);
		if(ans>20)printf(""NA\n""); else printf(""%d\n"",ans);
	}

	return 0;
}",1
p00190,"11 パズル
太郎君は 8 パズルが大得意で休み時間などにいつも友達に並び替えてもらって遊んでいます。そんなとき、友達から「もっと複雑なパズルは解ける?」と聞かれたのですが、他のパズルはやったことはありません。どうやらその友達は自作で 11 パズルを作っていたみたいです。そのパズルは以下のような形をしています。
11 パズルは 11 枚の正方形のカードと、図 1 のような形の枠を使って行います。最初に 11 枚のカードを枠に入れます。すると 2 カ所の空きスペースができますので、この空きスペースに隣接したカードを動かすことができます。これを繰り返し、カードをきれいに整列して、図 2 の完成型にすることが 11 パズルの目的です。
太郎君はこのパズルに挑戦することにしました。ところが太郎君はこの 11 パズルをいとも簡単に解いてしまいました。そこで友達は「動かす数を一番少なくして解いてよ!」と無茶なことを言ってきました。太郎君は答えがわからないので、プログラムのできるあなたに 11 パズルを解くときの最小ステップ数を出すプログラムを作成してもらってから挑戦することにしました。このとき、2 カ所動かせるところがあるのですが、一つの数字を 1 スペース分移動させることを1ステップとして考えることとします。
11 パズルの初期状態を入力とし、11 パズルを解くときの最小ステップ数を出力するプログラムを作成してください。ただし、パズルを解くときの最小ステップ数が 20 ステップより多くかかってしまう場合は、「NA」と出力してください。パズルの状態は、一行目の情報から順に入力されるものとし、数字の 0 は空きスペースを表します。例えば、図 1 の状態を表す入力は以下のようになります。
6
2 1 3
10 5 7 0 8
9 4 11
0
Input
複数のデータセットの並びが入力として与えられます。入力の終わりは-1ひとつの行で示されます。 各データセットは以下の形式で与えられます。
p
1
p
2
p
3
p
4
p
5
p
6
p
7
p
8
p
9
p
10
p
11
p
12
p
13
i
行目にパズルの
i
行目の情報
p
i
(0 ≤
p
i
≤ 11) が空白区切りで与えられます。
データセットの数は 100 を超えません。
Output
データセット毎に、最小ステップ数または NA を１行に出力します。
Sample Input
2
1 0 3
4 5 6 7 8
9 0 11
10
0
1 2 3
4 5 6 7 8
9 10 11
0
0
11 10 9
8 7 6 5 4
3 2 1
0
-1
Output for the Sample Input
2
0
NA",Java,"import java.util.*;

public class Main {
    static final int[] GOAL = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 0, 0};
    
    static class State {
        int[] board;
        int steps;
        
        State(int[] board, int steps) {
            this.board = board.clone();
            this.steps = steps;
        }
        
        String hash() {
            return Arrays.toString(board);
        }
    }
    
    static int[] readInput(Scanner sc) {
        int[] board = new int[13];
        int idx = 0;
        
        // Row 1: 1 element
        board[idx++] = sc.nextInt();
        
        // Row 2: 3 elements
        for (int i = 0; i < 3; i++) {
            board[idx++] = sc.nextInt();
        }
        
        // Row 3: 5 elements
        for (int i = 0; i < 5; i++) {
            board[idx++] = sc.nextInt();
        }
        
        // Row 4: 3 elements
        for (int i = 0; i < 3; i++) {
            board[idx++] = sc.nextInt();
        }
        
        // Row 5: 1 element
        board[idx++] = sc.nextInt();
        
        return board;
    }
    
    static int[][] getNeighbors() {
        int[][] neighbors = new int[13][];
        neighbors[0] = new int[]{1};
        neighbors[1] = new int[]{0, 2, 4};
        neighbors[2] = new int[]{1, 3, 5};
        neighbors[3] = new int[]{2, 6};
        neighbors[4] = new int[]{1, 5, 7};
        neighbors[5] = new int[]{2, 4, 6, 8};
        neighbors[6] = new int[]{3, 5, 9};
        neighbors[7] = new int[]{4, 8, 10};
        neighbors[8] = new int[]{5, 7, 9, 11};
        neighbors[9] = new int[]{6, 8, 12};
        neighbors[10] = new int[]{7, 11};
        neighbors[11] = new int[]{8, 10, 12};
        neighbors[12] = new int[]{9, 11};
        return neighbors;
    }
    
    static int solve(int[] initial) {
        if (Arrays.equals(initial, GOAL)) {
            return 0;
        }
        
        Queue<State> queue = new LinkedList<>();
        Set<String> visited = new HashSet<>();
        
        State start = new State(initial, 0);
        queue.offer(start);
        visited.add(start.hash());
        
        int[][] neighbors = getNeighbors();
        
        while (!queue.isEmpty()) {
            State curr = queue.poll();
            
            if (curr.steps >= 20) {
                continue;
            }
            
            // Find empty spaces
            List<Integer> empties = new ArrayList<>();
            for (int i = 0; i < 13; i++) {
                if (curr.board[i] == 0) {
                    empties.add(i);
                }
            }
            
            // Try moving tiles into empty spaces
            for (int emptyPos : empties) {
                for (int neighbor : neighbors[emptyPos]) {
                    if (curr.board[neighbor] != 0) {
                        int[] newBoard = curr.board.clone();
                        newBoard[emptyPos] = newBoard[neighbor];
                        newBoard[neighbor] = 0;
                        
                        if (Arrays.equals(newBoard, GOAL)) {
                            return curr.steps + 1;
                        }
                        
                        String hash = Arrays.toString(newBoard);
                        if (!visited.contains(hash)) {
                            visited.add(hash);
                            queue.offer(new State(newBoard, curr.steps + 1));
                        }
                    }
                }
            }
        }
        
        return -1;
    }
    
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        
        while (true) {
            int first = sc.nextInt();
            if (first == -1) break;
            
            int[] board = new int[13];
            board[0] = first;
            
            for (int i = 1; i < 13; i++) {
                board[i] = sc.nextInt();
            }
            
            int result = solve(board);
            if (result == -1) {
                System.out.println(""NA"");
            } else {
                System.out.println(result);
            }
        }
        
        sc.close();
    }
}
",0
p00190,"11 パズル
太郎君は 8 パズルが大得意で休み時間などにいつも友達に並び替えてもらって遊んでいます。そんなとき、友達から「もっと複雑なパズルは解ける?」と聞かれたのですが、他のパズルはやったことはありません。どうやらその友達は自作で 11 パズルを作っていたみたいです。そのパズルは以下のような形をしています。
11 パズルは 11 枚の正方形のカードと、図 1 のような形の枠を使って行います。最初に 11 枚のカードを枠に入れます。すると 2 カ所の空きスペースができますので、この空きスペースに隣接したカードを動かすことができます。これを繰り返し、カードをきれいに整列して、図 2 の完成型にすることが 11 パズルの目的です。
太郎君はこのパズルに挑戦することにしました。ところが太郎君はこの 11 パズルをいとも簡単に解いてしまいました。そこで友達は「動かす数を一番少なくして解いてよ!」と無茶なことを言ってきました。太郎君は答えがわからないので、プログラムのできるあなたに 11 パズルを解くときの最小ステップ数を出すプログラムを作成してもらってから挑戦することにしました。このとき、2 カ所動かせるところがあるのですが、一つの数字を 1 スペース分移動させることを1ステップとして考えることとします。
11 パズルの初期状態を入力とし、11 パズルを解くときの最小ステップ数を出力するプログラムを作成してください。ただし、パズルを解くときの最小ステップ数が 20 ステップより多くかかってしまう場合は、「NA」と出力してください。パズルの状態は、一行目の情報から順に入力されるものとし、数字の 0 は空きスペースを表します。例えば、図 1 の状態を表す入力は以下のようになります。
6
2 1 3
10 5 7 0 8
9 4 11
0
Input
複数のデータセットの並びが入力として与えられます。入力の終わりは-1ひとつの行で示されます。 各データセットは以下の形式で与えられます。
p
1
p
2
p
3
p
4
p
5
p
6
p
7
p
8
p
9
p
10
p
11
p
12
p
13
i
行目にパズルの
i
行目の情報
p
i
(0 ≤
p
i
≤ 11) が空白区切りで与えられます。
データセットの数は 100 を超えません。
Output
データセット毎に、最小ステップ数または NA を１行に出力します。
Sample Input
2
1 0 3
4 5 6 7 8
9 0 11
10
0
1 2 3
4 5 6 7 8
9 10 11
0
0
11 10 9
8 7 6 5 4
3 2 1
0
-1
Output for the Sample Input
2
0
NA",Java,"
import java.util.ArrayDeque;
import java.util.Deque;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Map;
import java.util.Scanner;
import java.util.Set;

public class Main {

	public static void main(String[] args) {
		new Main().run();
	}

	private void run() {
		Scanner scanner = new Scanner(System.in);
		int[][] adj = { { 2 }, { 2, 5 }, { 0, 1, 3, 6 }, { 2, 7 }, { 5 },
				{ 1, 4, 6, 9 }, { 2, 5, 7, 10 }, { 3, 6, 8, 11 }, { 7 },
				{ 5, 10 }, { 6, 9, 11, 12 }, { 7, 10 }, { 10 } };
		String g = ""0ABCDEFGHIJK0"";
		Map<String, Integer> m = new HashMap<String, Integer>();
		Deque<String> deque = new ArrayDeque<String>();
		int step = 1;
		deque.offer(g);
		m.put(g, 0);
		while (!deque.isEmpty() && step < 10) {
			int size = deque.size();
			for (int k = 0; k < size; k++) {
				String s = deque.pop();
				char[] c = s.toCharArray();
				for (int i = 0; i < 13; i++) {
					if (c[i] == '0') {
						for (int j = 0; j < adj[i].length; j++) {
							c[i] = c[adj[i][j]];
							c[adj[i][j]] = '0';
							String n = String.valueOf(c);
							if (!m.containsKey(n)) {
								m.put(n, step);
								deque.offer(n);
							}
							c[adj[i][j]] = c[i];
							c[i] = '0';
						}
					}
				}
			}
			step++;
		}
		while (true) {
			int p = scanner.nextInt();
			if (p == -1)
				break;
			char[] cc = new char[13];
			cc[0] = p == 0 ? '0' : (char) (p - 1 + 'A');
			for (int i = 1; i < 13; i++) {
				p = scanner.nextInt();
				cc[i] = p == 0 ? '0' : (char) (p - 1 + 'A');
			}
			String st = String.valueOf(cc);
			Set<String> set = new HashSet<String>();
			deque.clear();
			deque.offer(st);
			step = 0;
			boolean flag = false;
			String ans = """";
			loop: while (!deque.isEmpty() && step < 10) {
				int size = deque.size();
				for (int w = 0; w < size; w++) {
					String s = deque.pop();
					if (m.containsKey(s)) {
						flag = true;
						ans = s;
						break loop;
					}
					char[] cs = s.toCharArray();
					for (int i = 0; i < 13; i++) {
						if (cs[i] == '0') {
							for (int j = 0; j < adj[i].length; j++) {
								cs[i] = cs[adj[i][j]];
								cs[adj[i][j]] = '0';
								String news = String.valueOf(cs);
								if (!set.contains(news)) {
									set.add(news);
									deque.offer(news);
								}
								cs[adj[i][j]] = cs[i];
								cs[i] = '0';
							}
						}
					}

				}
				step++;
			}
			System.out.println(flag ? m.get(ans) : ""NA"");

		}
	}
}",1
p00190,"11 パズル
太郎君は 8 パズルが大得意で休み時間などにいつも友達に並び替えてもらって遊んでいます。そんなとき、友達から「もっと複雑なパズルは解ける?」と聞かれたのですが、他のパズルはやったことはありません。どうやらその友達は自作で 11 パズルを作っていたみたいです。そのパズルは以下のような形をしています。
11 パズルは 11 枚の正方形のカードと、図 1 のような形の枠を使って行います。最初に 11 枚のカードを枠に入れます。すると 2 カ所の空きスペースができますので、この空きスペースに隣接したカードを動かすことができます。これを繰り返し、カードをきれいに整列して、図 2 の完成型にすることが 11 パズルの目的です。
太郎君はこのパズルに挑戦することにしました。ところが太郎君はこの 11 パズルをいとも簡単に解いてしまいました。そこで友達は「動かす数を一番少なくして解いてよ!」と無茶なことを言ってきました。太郎君は答えがわからないので、プログラムのできるあなたに 11 パズルを解くときの最小ステップ数を出すプログラムを作成してもらってから挑戦することにしました。このとき、2 カ所動かせるところがあるのですが、一つの数字を 1 スペース分移動させることを1ステップとして考えることとします。
11 パズルの初期状態を入力とし、11 パズルを解くときの最小ステップ数を出力するプログラムを作成してください。ただし、パズルを解くときの最小ステップ数が 20 ステップより多くかかってしまう場合は、「NA」と出力してください。パズルの状態は、一行目の情報から順に入力されるものとし、数字の 0 は空きスペースを表します。例えば、図 1 の状態を表す入力は以下のようになります。
6
2 1 3
10 5 7 0 8
9 4 11
0
Input
複数のデータセットの並びが入力として与えられます。入力の終わりは-1ひとつの行で示されます。 各データセットは以下の形式で与えられます。
p
1
p
2
p
3
p
4
p
5
p
6
p
7
p
8
p
9
p
10
p
11
p
12
p
13
i
行目にパズルの
i
行目の情報
p
i
(0 ≤
p
i
≤ 11) が空白区切りで与えられます。
データセットの数は 100 を超えません。
Output
データセット毎に、最小ステップ数または NA を１行に出力します。
Sample Input
2
1 0 3
4 5 6 7 8
9 0 11
10
0
1 2 3
4 5 6 7 8
9 10 11
0
0
11 10 9
8 7 6 5 4
3 2 1
0
-1
Output for the Sample Input
2
0
NA",Python,"from collections import deque

def read_puzzle():
    line = input().strip()
    if line == '-1':
        return None
    
    puzzle = []
    puzzle.append(list(map(int, line.split())))
    puzzle.append(list(map(int, input().split())))
    puzzle.append(list(map(int, input().split())))
    puzzle.append(list(map(int, input().split())))
    input()  # empty line
    
    return puzzle

def puzzle_to_tuple(puzzle):
    result = []
    for row in puzzle:
        result.extend(row)
    return tuple(result)

def tuple_to_puzzle(t):
    puzzle = []
    puzzle.append(list(t[0:1]))
    puzzle.append(list(t[1:4]))
    puzzle.append(list(t[4:9]))
    puzzle.append(list(t[9:12]))
    return puzzle

def get_neighbors(puzzle):
    neighbors = []
    
    # Find all zeros
    zeros = []
    for i in range(len(puzzle)):
        for j in range(len(puzzle[i])):
            if puzzle[i][j] == 0:
                zeros.append((i, j))
    
    # For each zero, find adjacent numbers that can move
    for zi, zj in zeros:
        # Check all 4 directions
        directions = [(-1, 0), (1, 0), (0, -1), (0, 1)]
        for di, dj in directions:
            ni, nj = zi + di, zj + dj
            if 0 <= ni < len(puzzle) and 0 <= nj < len(puzzle[ni]):
                if puzzle[ni][nj] != 0:
                    # Make a move
                    new_puzzle = [row[:] for row in puzzle]
                    new_puzzle[zi][zj] = new_puzzle[ni][nj]
                    new_puzzle[ni][nj] = 0
                    neighbors.append(new_puzzle)
    
    return neighbors

def solve_puzzle(start_puzzle):
    goal = (1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 0, 0)
    
    start = puzzle_to_tuple(start_puzzle)
    
    if start == goal:
        return 0
    
    queue = deque([(start_puzzle, 0)])
    visited = {start}
    
    while queue:
        current_puzzle, steps = queue.popleft()
        
        if steps >= 20:
            continue
        
        for neighbor in get_neighbors(current_puzzle):
            neighbor_tuple = puzzle_to_tuple(neighbor)
            
            if neighbor_tuple == goal:
                return steps + 1
            
            if neighbor_tuple not in visited:
                visited.add(neighbor_tuple)
                queue.append((neighbor, steps + 1))
    
    return -1

while True:
    puzzle = read_puzzle()
    if puzzle is None:
        break
    
    result = solve_puzzle(puzzle)
    if result == -1:
        print(""NA"")
    else:
        print(result)
",0
p00190,"11 パズル
太郎君は 8 パズルが大得意で休み時間などにいつも友達に並び替えてもらって遊んでいます。そんなとき、友達から「もっと複雑なパズルは解ける?」と聞かれたのですが、他のパズルはやったことはありません。どうやらその友達は自作で 11 パズルを作っていたみたいです。そのパズルは以下のような形をしています。
11 パズルは 11 枚の正方形のカードと、図 1 のような形の枠を使って行います。最初に 11 枚のカードを枠に入れます。すると 2 カ所の空きスペースができますので、この空きスペースに隣接したカードを動かすことができます。これを繰り返し、カードをきれいに整列して、図 2 の完成型にすることが 11 パズルの目的です。
太郎君はこのパズルに挑戦することにしました。ところが太郎君はこの 11 パズルをいとも簡単に解いてしまいました。そこで友達は「動かす数を一番少なくして解いてよ!」と無茶なことを言ってきました。太郎君は答えがわからないので、プログラムのできるあなたに 11 パズルを解くときの最小ステップ数を出すプログラムを作成してもらってから挑戦することにしました。このとき、2 カ所動かせるところがあるのですが、一つの数字を 1 スペース分移動させることを1ステップとして考えることとします。
11 パズルの初期状態を入力とし、11 パズルを解くときの最小ステップ数を出力するプログラムを作成してください。ただし、パズルを解くときの最小ステップ数が 20 ステップより多くかかってしまう場合は、「NA」と出力してください。パズルの状態は、一行目の情報から順に入力されるものとし、数字の 0 は空きスペースを表します。例えば、図 1 の状態を表す入力は以下のようになります。
6
2 1 3
10 5 7 0 8
9 4 11
0
Input
複数のデータセットの並びが入力として与えられます。入力の終わりは-1ひとつの行で示されます。 各データセットは以下の形式で与えられます。
p
1
p
2
p
3
p
4
p
5
p
6
p
7
p
8
p
9
p
10
p
11
p
12
p
13
i
行目にパズルの
i
行目の情報
p
i
(0 ≤
p
i
≤ 11) が空白区切りで与えられます。
データセットの数は 100 を超えません。
Output
データセット毎に、最小ステップ数または NA を１行に出力します。
Sample Input
2
1 0 3
4 5 6 7 8
9 0 11
10
0
1 2 3
4 5 6 7 8
9 10 11
0
0
11 10 9
8 7 6 5 4
3 2 1
0
-1
Output for the Sample Input
2
0
NA",Python,"from math import factorial
from Queue import PriorityQueue

FACTORIAL=[factorial(i) for i in xrange(13)]
LEFT,UP,RIGHT,DOWN=0,1,2,3
MOVE=[[0] for u in xrange(13)]
MOVE[0] =[-1,-1,-1, 2]
MOVE[1] =[-1,-1, 2, 5]
MOVE[2] =[ 1, 0, 3, 6]
MOVE[3] =[ 2,-1,-1, 7] 
MOVE[4] =[-1,-1, 5,-1]
MOVE[5] =[ 4, 1, 6, 9]
MOVE[6] =[ 5, 2, 7,10]
MOVE[7] =[ 6, 3, 8,11]
MOVE[8] =[ 7,-1,-1,-1]
MOVE[9] =[-1, 5,10,-1]
MOVE[10]=[ 9, 6,11,12]
MOVE[11]=[10, 7,-1,-1]
MOVE[12]=[-1,10,-1,-1]

def hash(cell):
    work = cell[:]
    hash = 0
    for i in xrange(12):
        hash += work[i] * FACTORIAL[13-1-i]
        for ii in xrange(i+1,13):
            if work[ii]>work[i]:
                work[ii]-=1
    return hash

def dehash(key):
    cell=[]
    for i in xrange(13):
        cell.append(key/FACTORIAL[13-1-i])
        key %= FACTORIAL[13-1-i]
    for i in xrange(13-1,-1,-1):
        for ii in xrange(i+1,13):
            if cell[i]<=cell[ii]:
                cell[ii]+=1
    return cell

def evaluate(cell):
    point=[[0,2],
           [1,1],[1,2],[1,3],
           [2,0],[2,1],[2,2],[2,3],[2,4],
           [3,1],[3,2],[3,3],
           [4,2]]
    eva=0
    for i in xrange(0,13):
        if not (cell[i]==0 or cell[i]==12):
            eva+=abs(point[cell[i]][0]-point[i][0])
            eva+=abs(point[cell[i]][1]-point[i][1])
    return eva

ANS_HASH=[hash([0,1,2,3,4,5,6,7,8,9,10,11,12]),hash([12,1,2,3,4,5,6,7,8,9,10,11,0])]          

while True:
    p=[input()]
    if p==[-1]:
        break
    for u in xrange(4):
        for pp in map(int,raw_input().split()):
            p.append(pp)
    p[p.index(0)]=12
    pq = PriorityQueue()
    pq.put([evaluate(p),hash(p),0])
    visited={}
    visited[hash(p)]=True
    ans=0 if hash(p) in ANS_HASH else ""NA""
    #cur=[eva,hashkey,step]
    while not pq.empty():
        eva,cur_hash,cur_step=pq.get()
        cur_cell=dehash(cur_hash)
        if not (eva<=20 and ans==""NA""):
            break
        for i in xrange(13):
            if cur_cell[i]==0 or cur_cell[i]==12:
                for ii in [LEFT,UP,RIGHT,DOWN]:
                    if not MOVE[i][ii]==-1:
                        cur_cell[i],cur_cell[MOVE[i][ii]]=cur_cell[MOVE[i][ii]],cur_cell[i]
                        hashkey=hash(cur_cell)
                        if not hashkey in visited:
                            if hashkey in ANS_HASH:
                                ans=cur_step+1
                                break
                            pq.put([evaluate(cur_cell)+cur_step+1,hashkey,cur_step+1])
                            visited[hashkey]=True
                        cur_cell[i],cur_cell[MOVE[i][ii]]=cur_cell[MOVE[i][ii]],cur_cell[i]
    print ans",1
p00191,"苗木
植物学者のサトー博士は苗木用の特殊肥料を何種類も発明しました。その肥料を苗木に与えると、瞬く間に苗木の大きさが変わります。
 但し、肥料に以下のように副作用があることが判明しました。
1 回目に与えた肥料だけでは、苗木の大きさが変わりません。
2 回目以降は、その回に与えた肥料と、その直前に与えた肥料との組み合わせによって苗木に影響を与えます。良い影響を与えると苗木が伸び、悪い影響を与えると苗木が縮んでしまうこともあります。
試しに、サトー博士は 3 種類の肥料 (肥料 1、2、3) に対し、ある時点で与えた肥料 (今回の肥料) とその直前に与えた肥料 (直前の肥料) の組み合わせによる苗木の成長度合いを調べ、以下の「成長度表」を作成しました。
右表の 1 行目は今回与える肥料の番号で、1 列目はその直前に与えた肥料の番号です。他の数字は直前に与えた肥料と今回与える肥料の組み合わせによる苗木の成長度 (成長後対成長前の大きさの比率) を示します。成長度 > 1.0 の場合は苗木が伸びる、成長度 < 1.0 の場合は苗木が縮むことを示します。例えば肥料 1 の後に肥料 2 を与えると苗木の大きさが 3 倍になるが、肥料 1 の後に肥料 3 を与えると苗木の大きさが半分に縮んでしまいます。
苗木に与える肥料の回数が制限された場合、苗木をできるだけ大きく育てるにはどの肥料をどのような順で与えればよいでしょうか?「成長度表」がその答え教えてくれます。例として上の表にある肥料を 3 回だけ与える場合、以下のように肥料 3 → 肥料 1 → 肥料 2 の順にあげると最も苗木が成長します。
1 回目の肥料 (肥料 3) では苗木の大きさは変わりません。
2 回目の肥料 (肥料 1) では、表より肥料 3 後の肥料 1 での成長度が 3.0 なので、苗木の大きさは前回の 3.0 倍になります。
3 回目の肥料 (肥料 2) では、表より肥料 1 後の肥料 2 での成長度が 3.0 なので、苗木の大きさはさらに前回の 3.0 倍で、最初の 3.0 × 3.0 の 9.0 倍になります。
今度は、サトー博士は発明した
n
種類の肥料を全部調べて、上のような「成長度表」を作りあげましたが、非常に大きな表になってしまい、肥料の種類と与える順番を決めるのに大変苦労しています。
そこで博士に代わり、
n
種類の肥料の組み合わせによる苗木の「成長度表」中の成長度値部分を入力とし、肥料を
m
回与えた後の最大の苗木の大きさを求めるプログラムを作成してください。ただし、初めの苗木の大きさを 1 とし、1 回目に与える肥料の成長度はどの肥料でも 1.0 とします。なお、肥料は 1 から
n
まで番号付けされています。
Input
複数のデータセットの並びが入力として与えられます。入力の終わりはゼロふたつの行で示されます。 各データセットは以下の形式で与えられます。
n
m
g
11
g
12
...
g
1n
g
21
g
22
...
g
2n
:
g
n1
g
n2
...
g
nn
1 行目に肥料の種類数
n
(2 ≤
n
≤ 100)、 肥料を与える回数
m
(1 ≤
m
≤ 100) が与えられます。
続く
n
行に、肥料
i
の後に肥料
j
を与えた時の苗木の成長度
g
ij
(0.0 ≤
g
ij
≤ 10.0, 実数) が与えられます。
データセットの数は 20 を超えません。
Output
データセット毎に、最大の苗木の大きさを１行に出力します。出力する苗木の大きさは、小数点第 3 位を四捨五入して、小数点第 2 位まで求めてください。
Sample Input
3 3          
1.3 3.0 0.5 
2.4 2.1 1.0
3.0 0.8 1.2
2 2
1.0 1.0
1.0 1.0
0 0
Output for the Sample Input
9.00
1.00",C,"#include <stdio.h>
#include <string.h>

int main() {
    int n, m;
    double g[101][101];
    double dp[101][101];
    
    while (scanf(""%d %d"", &n, &m) == 2) {
        if (n == 0 && m == 0) break;
        
        for (int i = 1; i <= n; i++) {
            for (int j = 1; j <= n; j++) {
                scanf(""%lf"", &g[i][j]);
            }
        }
        
        memset(dp, 0, sizeof(dp));
        
        for (int i = 1; i <= n; i++) {
            dp[1][i] = 1.0;
        }
        
        for (int step = 2; step <= m; step++) {
            for (int curr = 1; curr <= n; curr++) {
                dp[step][curr] = 0.0;
                for (int prev = 1; prev <= n; prev++) {
                    double val = dp[step-1][prev] * g[prev][curr];
                    if (val > dp[step][curr]) {
                        dp[step][curr] = val;
                    }
                }
            }
        }
        
        double max_size = 0.0;
        for (int i = 1; i <= n; i++) {
            if (dp[m][i] > max_size) {
                max_size = dp[m][i];
            }
        }
        
        printf(""%.2lf\n"", max_size);
    }
    
    return 0;
}
",0
p00191,"苗木
植物学者のサトー博士は苗木用の特殊肥料を何種類も発明しました。その肥料を苗木に与えると、瞬く間に苗木の大きさが変わります。
 但し、肥料に以下のように副作用があることが判明しました。
1 回目に与えた肥料だけでは、苗木の大きさが変わりません。
2 回目以降は、その回に与えた肥料と、その直前に与えた肥料との組み合わせによって苗木に影響を与えます。良い影響を与えると苗木が伸び、悪い影響を与えると苗木が縮んでしまうこともあります。
試しに、サトー博士は 3 種類の肥料 (肥料 1、2、3) に対し、ある時点で与えた肥料 (今回の肥料) とその直前に与えた肥料 (直前の肥料) の組み合わせによる苗木の成長度合いを調べ、以下の「成長度表」を作成しました。
右表の 1 行目は今回与える肥料の番号で、1 列目はその直前に与えた肥料の番号です。他の数字は直前に与えた肥料と今回与える肥料の組み合わせによる苗木の成長度 (成長後対成長前の大きさの比率) を示します。成長度 > 1.0 の場合は苗木が伸びる、成長度 < 1.0 の場合は苗木が縮むことを示します。例えば肥料 1 の後に肥料 2 を与えると苗木の大きさが 3 倍になるが、肥料 1 の後に肥料 3 を与えると苗木の大きさが半分に縮んでしまいます。
苗木に与える肥料の回数が制限された場合、苗木をできるだけ大きく育てるにはどの肥料をどのような順で与えればよいでしょうか?「成長度表」がその答え教えてくれます。例として上の表にある肥料を 3 回だけ与える場合、以下のように肥料 3 → 肥料 1 → 肥料 2 の順にあげると最も苗木が成長します。
1 回目の肥料 (肥料 3) では苗木の大きさは変わりません。
2 回目の肥料 (肥料 1) では、表より肥料 3 後の肥料 1 での成長度が 3.0 なので、苗木の大きさは前回の 3.0 倍になります。
3 回目の肥料 (肥料 2) では、表より肥料 1 後の肥料 2 での成長度が 3.0 なので、苗木の大きさはさらに前回の 3.0 倍で、最初の 3.0 × 3.0 の 9.0 倍になります。
今度は、サトー博士は発明した
n
種類の肥料を全部調べて、上のような「成長度表」を作りあげましたが、非常に大きな表になってしまい、肥料の種類と与える順番を決めるのに大変苦労しています。
そこで博士に代わり、
n
種類の肥料の組み合わせによる苗木の「成長度表」中の成長度値部分を入力とし、肥料を
m
回与えた後の最大の苗木の大きさを求めるプログラムを作成してください。ただし、初めの苗木の大きさを 1 とし、1 回目に与える肥料の成長度はどの肥料でも 1.0 とします。なお、肥料は 1 から
n
まで番号付けされています。
Input
複数のデータセットの並びが入力として与えられます。入力の終わりはゼロふたつの行で示されます。 各データセットは以下の形式で与えられます。
n
m
g
11
g
12
...
g
1n
g
21
g
22
...
g
2n
:
g
n1
g
n2
...
g
nn
1 行目に肥料の種類数
n
(2 ≤
n
≤ 100)、 肥料を与える回数
m
(1 ≤
m
≤ 100) が与えられます。
続く
n
行に、肥料
i
の後に肥料
j
を与えた時の苗木の成長度
g
ij
(0.0 ≤
g
ij
≤ 10.0, 実数) が与えられます。
データセットの数は 20 を超えません。
Output
データセット毎に、最大の苗木の大きさを１行に出力します。出力する苗木の大きさは、小数点第 3 位を四捨五入して、小数点第 2 位まで求めてください。
Sample Input
3 3          
1.3 3.0 0.5 
2.4 2.1 1.0
3.0 0.8 1.2
2 2
1.0 1.0
1.0 1.0
0 0
Output for the Sample Input
9.00
1.00",C,"double g[100][100],G[100],H[100],a;main(n,m,i,j){for(;scanf(""%d%d"",&n,&m),n;printf(""%.2f\n"",a)){for(i=n;i--;G[i]=1)for(j=n;j--;)scanf(""%lf"",g[i]+j);for(;--m;memcpy(G,H,8*n))for(i=n;i--;)for(H[i]=0,j=n;j--;a>H[i]?H[i]=a:0)a=G[j]*g[j][i];for(a=0;n--;)G[n]>a?a=G[n]:0;}exit(0);}",1
p00191,"苗木
植物学者のサトー博士は苗木用の特殊肥料を何種類も発明しました。その肥料を苗木に与えると、瞬く間に苗木の大きさが変わります。
 但し、肥料に以下のように副作用があることが判明しました。
1 回目に与えた肥料だけでは、苗木の大きさが変わりません。
2 回目以降は、その回に与えた肥料と、その直前に与えた肥料との組み合わせによって苗木に影響を与えます。良い影響を与えると苗木が伸び、悪い影響を与えると苗木が縮んでしまうこともあります。
試しに、サトー博士は 3 種類の肥料 (肥料 1、2、3) に対し、ある時点で与えた肥料 (今回の肥料) とその直前に与えた肥料 (直前の肥料) の組み合わせによる苗木の成長度合いを調べ、以下の「成長度表」を作成しました。
右表の 1 行目は今回与える肥料の番号で、1 列目はその直前に与えた肥料の番号です。他の数字は直前に与えた肥料と今回与える肥料の組み合わせによる苗木の成長度 (成長後対成長前の大きさの比率) を示します。成長度 > 1.0 の場合は苗木が伸びる、成長度 < 1.0 の場合は苗木が縮むことを示します。例えば肥料 1 の後に肥料 2 を与えると苗木の大きさが 3 倍になるが、肥料 1 の後に肥料 3 を与えると苗木の大きさが半分に縮んでしまいます。
苗木に与える肥料の回数が制限された場合、苗木をできるだけ大きく育てるにはどの肥料をどのような順で与えればよいでしょうか?「成長度表」がその答え教えてくれます。例として上の表にある肥料を 3 回だけ与える場合、以下のように肥料 3 → 肥料 1 → 肥料 2 の順にあげると最も苗木が成長します。
1 回目の肥料 (肥料 3) では苗木の大きさは変わりません。
2 回目の肥料 (肥料 1) では、表より肥料 3 後の肥料 1 での成長度が 3.0 なので、苗木の大きさは前回の 3.0 倍になります。
3 回目の肥料 (肥料 2) では、表より肥料 1 後の肥料 2 での成長度が 3.0 なので、苗木の大きさはさらに前回の 3.0 倍で、最初の 3.0 × 3.0 の 9.0 倍になります。
今度は、サトー博士は発明した
n
種類の肥料を全部調べて、上のような「成長度表」を作りあげましたが、非常に大きな表になってしまい、肥料の種類と与える順番を決めるのに大変苦労しています。
そこで博士に代わり、
n
種類の肥料の組み合わせによる苗木の「成長度表」中の成長度値部分を入力とし、肥料を
m
回与えた後の最大の苗木の大きさを求めるプログラムを作成してください。ただし、初めの苗木の大きさを 1 とし、1 回目に与える肥料の成長度はどの肥料でも 1.0 とします。なお、肥料は 1 から
n
まで番号付けされています。
Input
複数のデータセットの並びが入力として与えられます。入力の終わりはゼロふたつの行で示されます。 各データセットは以下の形式で与えられます。
n
m
g
11
g
12
...
g
1n
g
21
g
22
...
g
2n
:
g
n1
g
n2
...
g
nn
1 行目に肥料の種類数
n
(2 ≤
n
≤ 100)、 肥料を与える回数
m
(1 ≤
m
≤ 100) が与えられます。
続く
n
行に、肥料
i
の後に肥料
j
を与えた時の苗木の成長度
g
ij
(0.0 ≤
g
ij
≤ 10.0, 実数) が与えられます。
データセットの数は 20 を超えません。
Output
データセット毎に、最大の苗木の大きさを１行に出力します。出力する苗木の大きさは、小数点第 3 位を四捨五入して、小数点第 2 位まで求めてください。
Sample Input
3 3          
1.3 3.0 0.5 
2.4 2.1 1.0
3.0 0.8 1.2
2 2
1.0 1.0
1.0 1.0
0 0
Output for the Sample Input
9.00
1.00",Java,"import java.util.*;

public class Main {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        
        while (true) {
            int n = sc.nextInt();
            int m = sc.nextInt();
            
            if (n == 0 && m == 0) break;
            
            double[][] g = new double[n][n];
            for (int i = 0; i < n; i++) {
                for (int j = 0; j < n; j++) {
                    g[i][j] = sc.nextDouble();
                }
            }
            
            if (m == 1) {
                System.out.println(""1.00"");
                continue;
            }
            
            // dp[step][lastFertilizer] = maximum size after 'step' applications with last fertilizer being 'lastFertilizer'
            double[][] dp = new double[m + 1][n];
            
            // Initialize: after 1 application, size is 1.0 for any fertilizer
            for (int i = 0; i < n; i++) {
                dp[1][i] = 1.0;
            }
            
            // Fill DP table
            for (int step = 2; step <= m; step++) {
                for (int curr = 0; curr < n; curr++) {
                    dp[step][curr] = 0.0;
                    for (int prev = 0; prev < n; prev++) {
                        if (dp[step - 1][prev] > 0) {
                            dp[step][curr] = Math.max(dp[step][curr], dp[step - 1][prev] * g[prev][curr]);
                        }
                    }
                }
            }
            
            // Find maximum size after m applications
            double maxSize = 0.0;
            for (int i = 0; i < n; i++) {
                maxSize = Math.max(maxSize, dp[m][i]);
            }
            
            System.out.printf(""%.2f\n"", maxSize);
        }
        
        sc.close();
    }
}
",0
p00191,"苗木
植物学者のサトー博士は苗木用の特殊肥料を何種類も発明しました。その肥料を苗木に与えると、瞬く間に苗木の大きさが変わります。
 但し、肥料に以下のように副作用があることが判明しました。
1 回目に与えた肥料だけでは、苗木の大きさが変わりません。
2 回目以降は、その回に与えた肥料と、その直前に与えた肥料との組み合わせによって苗木に影響を与えます。良い影響を与えると苗木が伸び、悪い影響を与えると苗木が縮んでしまうこともあります。
試しに、サトー博士は 3 種類の肥料 (肥料 1、2、3) に対し、ある時点で与えた肥料 (今回の肥料) とその直前に与えた肥料 (直前の肥料) の組み合わせによる苗木の成長度合いを調べ、以下の「成長度表」を作成しました。
右表の 1 行目は今回与える肥料の番号で、1 列目はその直前に与えた肥料の番号です。他の数字は直前に与えた肥料と今回与える肥料の組み合わせによる苗木の成長度 (成長後対成長前の大きさの比率) を示します。成長度 > 1.0 の場合は苗木が伸びる、成長度 < 1.0 の場合は苗木が縮むことを示します。例えば肥料 1 の後に肥料 2 を与えると苗木の大きさが 3 倍になるが、肥料 1 の後に肥料 3 を与えると苗木の大きさが半分に縮んでしまいます。
苗木に与える肥料の回数が制限された場合、苗木をできるだけ大きく育てるにはどの肥料をどのような順で与えればよいでしょうか?「成長度表」がその答え教えてくれます。例として上の表にある肥料を 3 回だけ与える場合、以下のように肥料 3 → 肥料 1 → 肥料 2 の順にあげると最も苗木が成長します。
1 回目の肥料 (肥料 3) では苗木の大きさは変わりません。
2 回目の肥料 (肥料 1) では、表より肥料 3 後の肥料 1 での成長度が 3.0 なので、苗木の大きさは前回の 3.0 倍になります。
3 回目の肥料 (肥料 2) では、表より肥料 1 後の肥料 2 での成長度が 3.0 なので、苗木の大きさはさらに前回の 3.0 倍で、最初の 3.0 × 3.0 の 9.0 倍になります。
今度は、サトー博士は発明した
n
種類の肥料を全部調べて、上のような「成長度表」を作りあげましたが、非常に大きな表になってしまい、肥料の種類と与える順番を決めるのに大変苦労しています。
そこで博士に代わり、
n
種類の肥料の組み合わせによる苗木の「成長度表」中の成長度値部分を入力とし、肥料を
m
回与えた後の最大の苗木の大きさを求めるプログラムを作成してください。ただし、初めの苗木の大きさを 1 とし、1 回目に与える肥料の成長度はどの肥料でも 1.0 とします。なお、肥料は 1 から
n
まで番号付けされています。
Input
複数のデータセットの並びが入力として与えられます。入力の終わりはゼロふたつの行で示されます。 各データセットは以下の形式で与えられます。
n
m
g
11
g
12
...
g
1n
g
21
g
22
...
g
2n
:
g
n1
g
n2
...
g
nn
1 行目に肥料の種類数
n
(2 ≤
n
≤ 100)、 肥料を与える回数
m
(1 ≤
m
≤ 100) が与えられます。
続く
n
行に、肥料
i
の後に肥料
j
を与えた時の苗木の成長度
g
ij
(0.0 ≤
g
ij
≤ 10.0, 実数) が与えられます。
データセットの数は 20 を超えません。
Output
データセット毎に、最大の苗木の大きさを１行に出力します。出力する苗木の大きさは、小数点第 3 位を四捨五入して、小数点第 2 位まで求めてください。
Sample Input
3 3          
1.3 3.0 0.5 
2.4 2.1 1.0
3.0 0.8 1.2
2 2
1.0 1.0
1.0 1.0
0 0
Output for the Sample Input
9.00
1.00",Java,"import java.util.*;
public class Main {
    static Scanner sc = new Scanner(System.in);
    static int n, m;
    static double[][] dp, table;

    public static void main(String[] args) {
        while(read()){
            solve();
        }

    }

    static boolean read(){
        if(!sc.hasNext())return false;
        n = sc.nextInt();
        m = sc.nextInt();
        if(n == 0 || m == 0)return false;
        dp = new double[m][n];
        table = new double[m][n];

        for(int i = 0; i < m; i++){
            for(int j = 0; j < n; j++){
                table[i][j] = sc.nextDouble();
            }
        }

        for(int i = 0; i < 1; i++){
            for(int j = 0; j < n; j++){
                dp[i][j] = 1.0;
            }
        }

        return true;
    }

    static void solve(){
        int index = 0;
        double value = 0.0, res = 0.0;
        double[] array = new double[n];
        for(int i = 0; i < m-1; i++){
            for(int j = 0; j < n; j++){
                for(int k = 0; k < n; k++){
                    array[k] = table[j][k];
                }
                for(int k = 0; k < n; k++){
                    if(value < array[k]){
                        index = k;
                        value = array[k];
                    }
                }
                dp[i+1][index] = Math.max(dp[i+1][index], value*dp[i][j]);
            }
        }

        for(int j = 0; j < n; j++){
            res = Math.max(res, dp[m-1][j]);
        }
        System.out.printf(""%.2f\n"", res);
    }
}",1
p00191,"苗木
植物学者のサトー博士は苗木用の特殊肥料を何種類も発明しました。その肥料を苗木に与えると、瞬く間に苗木の大きさが変わります。
 但し、肥料に以下のように副作用があることが判明しました。
1 回目に与えた肥料だけでは、苗木の大きさが変わりません。
2 回目以降は、その回に与えた肥料と、その直前に与えた肥料との組み合わせによって苗木に影響を与えます。良い影響を与えると苗木が伸び、悪い影響を与えると苗木が縮んでしまうこともあります。
試しに、サトー博士は 3 種類の肥料 (肥料 1、2、3) に対し、ある時点で与えた肥料 (今回の肥料) とその直前に与えた肥料 (直前の肥料) の組み合わせによる苗木の成長度合いを調べ、以下の「成長度表」を作成しました。
右表の 1 行目は今回与える肥料の番号で、1 列目はその直前に与えた肥料の番号です。他の数字は直前に与えた肥料と今回与える肥料の組み合わせによる苗木の成長度 (成長後対成長前の大きさの比率) を示します。成長度 > 1.0 の場合は苗木が伸びる、成長度 < 1.0 の場合は苗木が縮むことを示します。例えば肥料 1 の後に肥料 2 を与えると苗木の大きさが 3 倍になるが、肥料 1 の後に肥料 3 を与えると苗木の大きさが半分に縮んでしまいます。
苗木に与える肥料の回数が制限された場合、苗木をできるだけ大きく育てるにはどの肥料をどのような順で与えればよいでしょうか?「成長度表」がその答え教えてくれます。例として上の表にある肥料を 3 回だけ与える場合、以下のように肥料 3 → 肥料 1 → 肥料 2 の順にあげると最も苗木が成長します。
1 回目の肥料 (肥料 3) では苗木の大きさは変わりません。
2 回目の肥料 (肥料 1) では、表より肥料 3 後の肥料 1 での成長度が 3.0 なので、苗木の大きさは前回の 3.0 倍になります。
3 回目の肥料 (肥料 2) では、表より肥料 1 後の肥料 2 での成長度が 3.0 なので、苗木の大きさはさらに前回の 3.0 倍で、最初の 3.0 × 3.0 の 9.0 倍になります。
今度は、サトー博士は発明した
n
種類の肥料を全部調べて、上のような「成長度表」を作りあげましたが、非常に大きな表になってしまい、肥料の種類と与える順番を決めるのに大変苦労しています。
そこで博士に代わり、
n
種類の肥料の組み合わせによる苗木の「成長度表」中の成長度値部分を入力とし、肥料を
m
回与えた後の最大の苗木の大きさを求めるプログラムを作成してください。ただし、初めの苗木の大きさを 1 とし、1 回目に与える肥料の成長度はどの肥料でも 1.0 とします。なお、肥料は 1 から
n
まで番号付けされています。
Input
複数のデータセットの並びが入力として与えられます。入力の終わりはゼロふたつの行で示されます。 各データセットは以下の形式で与えられます。
n
m
g
11
g
12
...
g
1n
g
21
g
22
...
g
2n
:
g
n1
g
n2
...
g
nn
1 行目に肥料の種類数
n
(2 ≤
n
≤ 100)、 肥料を与える回数
m
(1 ≤
m
≤ 100) が与えられます。
続く
n
行に、肥料
i
の後に肥料
j
を与えた時の苗木の成長度
g
ij
(0.0 ≤
g
ij
≤ 10.0, 実数) が与えられます。
データセットの数は 20 を超えません。
Output
データセット毎に、最大の苗木の大きさを１行に出力します。出力する苗木の大きさは、小数点第 3 位を四捨五入して、小数点第 2 位まで求めてください。
Sample Input
3 3          
1.3 3.0 0.5 
2.4 2.1 1.0
3.0 0.8 1.2
2 2
1.0 1.0
1.0 1.0
0 0
Output for the Sample Input
9.00
1.00",Python,"import sys

def solve(n, m, growth):
    if m == 1:
        return 1.0
    
    # dp[step][fertilizer] = maximum growth after 'step' applications, ending with 'fertilizer'
    dp = [[-1.0] * n for _ in range(m + 1)]
    
    # After first application, size is 1.0 for any fertilizer
    for i in range(n):
        dp[1][i] = 1.0
    
    # For each subsequent application
    for step in range(2, m + 1):
        for curr in range(n):
            # Try all possible previous fertilizers
            for prev in range(n):
                if dp[step - 1][prev] > 0:
                    # Apply fertilizer 'curr' after fertilizer 'prev'
                    new_size = dp[step - 1][prev] * growth[prev][curr]
                    dp[step][curr] = max(dp[step][curr], new_size)
    
    # Find maximum size after m applications
    max_size = max(dp[m])
    return max_size

while True:
    line = sys.stdin.readline().strip()
    if not line:
        break
    
    parts = line.split()
    n, m = int(parts[0]), int(parts[1])
    
    if n == 0 and m == 0:
        break
    
    growth = []
    for i in range(n):
        row = list(map(float, sys.stdin.readline().split()))
        growth.append(row)
    
    result = solve(n, m, growth)
    print(f""{result:.2f}"")
",0
p00191,"苗木
植物学者のサトー博士は苗木用の特殊肥料を何種類も発明しました。その肥料を苗木に与えると、瞬く間に苗木の大きさが変わります。
 但し、肥料に以下のように副作用があることが判明しました。
1 回目に与えた肥料だけでは、苗木の大きさが変わりません。
2 回目以降は、その回に与えた肥料と、その直前に与えた肥料との組み合わせによって苗木に影響を与えます。良い影響を与えると苗木が伸び、悪い影響を与えると苗木が縮んでしまうこともあります。
試しに、サトー博士は 3 種類の肥料 (肥料 1、2、3) に対し、ある時点で与えた肥料 (今回の肥料) とその直前に与えた肥料 (直前の肥料) の組み合わせによる苗木の成長度合いを調べ、以下の「成長度表」を作成しました。
右表の 1 行目は今回与える肥料の番号で、1 列目はその直前に与えた肥料の番号です。他の数字は直前に与えた肥料と今回与える肥料の組み合わせによる苗木の成長度 (成長後対成長前の大きさの比率) を示します。成長度 > 1.0 の場合は苗木が伸びる、成長度 < 1.0 の場合は苗木が縮むことを示します。例えば肥料 1 の後に肥料 2 を与えると苗木の大きさが 3 倍になるが、肥料 1 の後に肥料 3 を与えると苗木の大きさが半分に縮んでしまいます。
苗木に与える肥料の回数が制限された場合、苗木をできるだけ大きく育てるにはどの肥料をどのような順で与えればよいでしょうか?「成長度表」がその答え教えてくれます。例として上の表にある肥料を 3 回だけ与える場合、以下のように肥料 3 → 肥料 1 → 肥料 2 の順にあげると最も苗木が成長します。
1 回目の肥料 (肥料 3) では苗木の大きさは変わりません。
2 回目の肥料 (肥料 1) では、表より肥料 3 後の肥料 1 での成長度が 3.0 なので、苗木の大きさは前回の 3.0 倍になります。
3 回目の肥料 (肥料 2) では、表より肥料 1 後の肥料 2 での成長度が 3.0 なので、苗木の大きさはさらに前回の 3.0 倍で、最初の 3.0 × 3.0 の 9.0 倍になります。
今度は、サトー博士は発明した
n
種類の肥料を全部調べて、上のような「成長度表」を作りあげましたが、非常に大きな表になってしまい、肥料の種類と与える順番を決めるのに大変苦労しています。
そこで博士に代わり、
n
種類の肥料の組み合わせによる苗木の「成長度表」中の成長度値部分を入力とし、肥料を
m
回与えた後の最大の苗木の大きさを求めるプログラムを作成してください。ただし、初めの苗木の大きさを 1 とし、1 回目に与える肥料の成長度はどの肥料でも 1.0 とします。なお、肥料は 1 から
n
まで番号付けされています。
Input
複数のデータセットの並びが入力として与えられます。入力の終わりはゼロふたつの行で示されます。 各データセットは以下の形式で与えられます。
n
m
g
11
g
12
...
g
1n
g
21
g
22
...
g
2n
:
g
n1
g
n2
...
g
nn
1 行目に肥料の種類数
n
(2 ≤
n
≤ 100)、 肥料を与える回数
m
(1 ≤
m
≤ 100) が与えられます。
続く
n
行に、肥料
i
の後に肥料
j
を与えた時の苗木の成長度
g
ij
(0.0 ≤
g
ij
≤ 10.0, 実数) が与えられます。
データセットの数は 20 を超えません。
Output
データセット毎に、最大の苗木の大きさを１行に出力します。出力する苗木の大きさは、小数点第 3 位を四捨五入して、小数点第 2 位まで求めてください。
Sample Input
3 3          
1.3 3.0 0.5 
2.4 2.1 1.0
3.0 0.8 1.2
2 2
1.0 1.0
1.0 1.0
0 0
Output for the Sample Input
9.00
1.00",Python,"while 1:
    n, m = map(int, raw_input().split())
    if n==0:
        exit(0)
    mat = [map(float, raw_input().split()) for i in xrange(n)]
    dp = [1.0] * n
    for t in xrange(m-1):
        dp2 = [-1.0] * n
        for i in xrange(n):
            mat_i = mat[i]; dp_i = dp[i]
            for j in xrange(n):
                dp2[j] = max(dp2[j], dp_i * mat_i[j])
        dp = dp2
    print ""%.02f"" % round(max(dp), 2)",1
p00192,"立体駐車場
街中には駐車場の利用効率を上げるため、立体式やタワー式などの様々な駐車場があります。その中には、ひとつの駐車スペースに図のような「2段式駐車装置」を設置し、2台分の駐車スペースを確保している駐車場もあります。この2段式駐車装置は1台を昇降式のパレット(車を乗せる平らな鉄板)に乗せて上段に駐車させ、もう1台を下段に駐車することができます。
このような2段式駐車装置を用いている駐車場では、上段の車を出し入れするのに、その都度、下段に駐車されている車を出して、退かす必要があるので、必ず管理人さんが駐車している車のカギを預かって、必要に応じて車の出し入れを行います。
鶴ヶ駐車場もこのような2段式駐車装置を設置している駐車場のひとつですが、人手不足のため、車の運転ができない人が管理人になってしまいました。そのため、一度駐車した車はお客さんが戻るまで動かすことができず、上段になった車は下段の車の持ち主が戻ってからでないと車を出すことができない状態になってしまいました。
次から次へと駐車しに来る車を手際よくさばかなければならない管理人さんを手伝うため、鶴ヶ駐車場のルールを満たすプログラムを作成してください。
鶴ヶ駐車場の設備
駐車スペースは1つ以上あり、全て2段式駐車装置が設置されています。
各駐車スペースには1から順に番号が割り振られています。
初めは駐車場に1台も駐車していないものとします。
鶴ヶ駐車場は以下のようなルールを採用しています。
車を止める時
駐車する車の駐車時間が管理人に知らされます。
1台も駐車されていない駐車スペースから先に駐車していきます。
1台も駐車されていない駐車スペースがない場合には、空いている駐車スペースに駐車します。
ただし、そのような駐車スペースが複数あるときは以下の手順で駐車します。
駐車してある車の残り駐車時間が駐車しようとしている車の駐車時間以上のものがある場合、その差が一番小さい駐車スペースに駐車します。
駐車してあるどの車の残り駐車時間も駐車しようとしている車の駐車時間未満である場合、その差が一番小さい駐車スペースに駐車します。
満車(空いている駐車スペースがない)の場合、駐車しようとする車は駐車スペースが空くまで順番に待ちます。空いたと同時に、最初に待っていた車から順に駐車します。
※各条件において、該当する駐車スペースが複数ある場合は駐車スペース番号の最も小さいところに駐車することとします。また、同時刻に出庫する車がある場合は、出庫する車がすべて出てから駐車を始め、待っている車がある限り、駐車できるだけの車が同時刻に駐車することとします。
車が出る時
管理人に知らされた駐車時間を過ぎた車は出庫します。
複数の駐車スペースで同時に駐車時間を過ぎた車があった場合、駐車スペース番号の小さい車から先に出庫します。
上段に駐車した車の駐車時間が過ぎた場合、下段の車が出庫するまで待たなければなりません。上段の車は下段の車が出庫した後、同時刻に出庫します。
下図で鶴ヶ駐車場の駐車方法の例を示します。この例では、駐車スペースの数は3で、車 B ~車 Eがすでに駐車してあるとします。そこに駐車時間70分の車 A が来たことを考えます。駐車スペース3にはすでに2台駐車されているので駐車できず、まだ空いている駐車スペース1か駐車スペース2のどちらかに駐車することになります。駐車スペース1に駐車中の車 B の残り駐車時間は50分、駐車スペース2に駐車中の車Cの残り駐車時間は22分で、どちらも車 A の駐車時間より少ないので、車 A の駐車時間との差がより小さい車 B が駐車してある駐車スペース1に駐車します。その結果、先に駐車していた車 B は上段になります。
駐車スペースの数
m
、駐車する車の台数
n
、各車の駐車時間
t
を入力とし、駐車場から出てくる順番に車の整理番号を出力するプログラムを作成してください。ただし、車には入力の順に1からはじまる整数の整理番号が割り振られており、車は10分おきに1台ずつ整理番号順に駐車しにくるものとします。
Input
複数のデータセットの並びが入力として与えられます。入力の終わりはゼロふたつの行で示されます。各データセットは以下の形式で与えられます。
m
n
t
1
t
2
:
t
n
1 行目に2段式の駐車装置の数
m
(1 ≤
m
≤ 10) と駐車する車の台数
n
(1 ≤
n
≤ 100) が与えられます。続く
n
行に
i
台目の車の駐車時間
t
i
(1 ≤
t
i
≤ 120) が与えられます。
データセットの数は 20 を超えません。
Output
データセット毎に駐車場から出てくる順番に車の整理番号を１行に出力します。整理番号は空白区切りで出力してください。
Sample Input
3 5
90
52
82
84
70
2 4
10
30
40
60
0 0
Output for the Sample Input
2 5 1 4 3
1 2 4 3",C,"#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#define MAX_SPACES 10
#define MAX_CARS 100

typedef struct {
    int id;
    int parking_time;
    int arrival_time;
    int exit_time;
} Car;

typedef struct {
    int lower_car;
    int upper_car;
} Space;

typedef struct {
    int car_id;
    int arrival_time;
} WaitingCar;

int main() {
    int m, n;
    
    while (1) {
        scanf(""%d %d"", &m, &n);
        if (m == 0 && n == 0) break;
        
        Car cars[MAX_CARS];
        Space spaces[MAX_SPACES];
        WaitingCar waiting[MAX_CARS];
        int waiting_count = 0;
        int output[MAX_CARS];
        int output_count = 0;
        
        for (int i = 0; i < n; i++) {
            scanf(""%d"", &cars[i].parking_time);
            cars[i].id = i + 1;
            cars[i].arrival_time = i * 10;
            cars[i].exit_time = -1;
        }
        
        for (int i = 0; i < m; i++) {
            spaces[i].lower_car = -1;
            spaces[i].upper_car = -1;
        }
        
        int current_car = 0;
        int time = 0;
        
        while (output_count < n) {
            // Process exits
            for (int s = 0; s < m; s++) {
                if (spaces[s].lower_car != -1) {
                    int lower_id = spaces[s].lower_car;
                    if (cars[lower_id].exit_time == time) {
                        output[output_count++] = cars[lower_id].id;
                        spaces[s].lower_car = -1;
                        
                        if (spaces[s].upper_car != -1) {
                            int upper_id = spaces[s].upper_car;
                            output[output_count++] = cars[upper_id].id;
                            spaces[s].upper_car = -1;
                        }
                    }
                }
            }
            
            // Add arriving cars to waiting list
            while (current_car < n && cars[current_car].arrival_time == time) {
                waiting[waiting_count].car_id = current_car;
                waiting[waiting_count].arrival_time = time;
                waiting_count++;
                current_car++;
            }
            
            // Park waiting cars
            int parked_any = 1;
            while (waiting_count > 0 && parked_any) {
                parked_any = 0;
                int car_id = waiting[0].car_id;
                int park_time = cars[car_id].parking_time;
                
                int best_space = -1;
                int best_type = -1; // 0: empty, 1: one car
                int best_diff = 999999;
                
                for (int s = 0; s < m; s++) {
                    if (spaces[s].lower_car == -1) {
                        if (best_type == -1 || best_type > 0) {
                            best_space = s;
                            best_type = 0;
                        }
                    } else if (spaces[s].upper_car == -1) {
                        int remaining = cars[spaces[s].lower_car].exit_time - time;
                        int diff;
                        if (remaining >= park_time) {
                            diff = remaining - park_time;
                            if (best_type == -1 || best_type > 1 || (best_type == 1 && diff < best_diff)) {
                                best_space = s;
                                best_type = 1;
                                best_diff = diff;
                            }
                        } else {
                            diff = park_time - remaining;
                            if (best_type == -1 || (best_type == 2 && diff < best_diff)) {
                                best_space = s;
                                best_type = 2;
                                best_diff = diff;
                            }
                        }
                    }
                }
                
                if (best_space != -1) {
                    if (spaces[best_space].lower_car == -1) {
                        spaces[best_space].lower_car = car_id;
                    } else {
                        spaces[best_space].upper_car = car_id;
                    }
                    cars[car_id].exit_time = time + park_time;
                    
                    for (int i = 0; i < waiting_count - 1; i++) {
                        waiting[i] = waiting[i + 1];
                    }
                    waiting_count--;
                    parked_any = 1;
                } else {
                    break;
                }
            }
            
            time++;
        }
        
        for (int i = 0; i < output_count; i++) {
            if (i > 0) printf("" "");
            printf(""%d"", output[i]);
        }
        printf(""\n"");
    }
    
    return 0;
}
",0
p00192,"立体駐車場
街中には駐車場の利用効率を上げるため、立体式やタワー式などの様々な駐車場があります。その中には、ひとつの駐車スペースに図のような「2段式駐車装置」を設置し、2台分の駐車スペースを確保している駐車場もあります。この2段式駐車装置は1台を昇降式のパレット(車を乗せる平らな鉄板)に乗せて上段に駐車させ、もう1台を下段に駐車することができます。
このような2段式駐車装置を用いている駐車場では、上段の車を出し入れするのに、その都度、下段に駐車されている車を出して、退かす必要があるので、必ず管理人さんが駐車している車のカギを預かって、必要に応じて車の出し入れを行います。
鶴ヶ駐車場もこのような2段式駐車装置を設置している駐車場のひとつですが、人手不足のため、車の運転ができない人が管理人になってしまいました。そのため、一度駐車した車はお客さんが戻るまで動かすことができず、上段になった車は下段の車の持ち主が戻ってからでないと車を出すことができない状態になってしまいました。
次から次へと駐車しに来る車を手際よくさばかなければならない管理人さんを手伝うため、鶴ヶ駐車場のルールを満たすプログラムを作成してください。
鶴ヶ駐車場の設備
駐車スペースは1つ以上あり、全て2段式駐車装置が設置されています。
各駐車スペースには1から順に番号が割り振られています。
初めは駐車場に1台も駐車していないものとします。
鶴ヶ駐車場は以下のようなルールを採用しています。
車を止める時
駐車する車の駐車時間が管理人に知らされます。
1台も駐車されていない駐車スペースから先に駐車していきます。
1台も駐車されていない駐車スペースがない場合には、空いている駐車スペースに駐車します。
ただし、そのような駐車スペースが複数あるときは以下の手順で駐車します。
駐車してある車の残り駐車時間が駐車しようとしている車の駐車時間以上のものがある場合、その差が一番小さい駐車スペースに駐車します。
駐車してあるどの車の残り駐車時間も駐車しようとしている車の駐車時間未満である場合、その差が一番小さい駐車スペースに駐車します。
満車(空いている駐車スペースがない)の場合、駐車しようとする車は駐車スペースが空くまで順番に待ちます。空いたと同時に、最初に待っていた車から順に駐車します。
※各条件において、該当する駐車スペースが複数ある場合は駐車スペース番号の最も小さいところに駐車することとします。また、同時刻に出庫する車がある場合は、出庫する車がすべて出てから駐車を始め、待っている車がある限り、駐車できるだけの車が同時刻に駐車することとします。
車が出る時
管理人に知らされた駐車時間を過ぎた車は出庫します。
複数の駐車スペースで同時に駐車時間を過ぎた車があった場合、駐車スペース番号の小さい車から先に出庫します。
上段に駐車した車の駐車時間が過ぎた場合、下段の車が出庫するまで待たなければなりません。上段の車は下段の車が出庫した後、同時刻に出庫します。
下図で鶴ヶ駐車場の駐車方法の例を示します。この例では、駐車スペースの数は3で、車 B ~車 Eがすでに駐車してあるとします。そこに駐車時間70分の車 A が来たことを考えます。駐車スペース3にはすでに2台駐車されているので駐車できず、まだ空いている駐車スペース1か駐車スペース2のどちらかに駐車することになります。駐車スペース1に駐車中の車 B の残り駐車時間は50分、駐車スペース2に駐車中の車Cの残り駐車時間は22分で、どちらも車 A の駐車時間より少ないので、車 A の駐車時間との差がより小さい車 B が駐車してある駐車スペース1に駐車します。その結果、先に駐車していた車 B は上段になります。
駐車スペースの数
m
、駐車する車の台数
n
、各車の駐車時間
t
を入力とし、駐車場から出てくる順番に車の整理番号を出力するプログラムを作成してください。ただし、車には入力の順に1からはじまる整数の整理番号が割り振られており、車は10分おきに1台ずつ整理番号順に駐車しにくるものとします。
Input
複数のデータセットの並びが入力として与えられます。入力の終わりはゼロふたつの行で示されます。各データセットは以下の形式で与えられます。
m
n
t
1
t
2
:
t
n
1 行目に2段式の駐車装置の数
m
(1 ≤
m
≤ 10) と駐車する車の台数
n
(1 ≤
n
≤ 100) が与えられます。続く
n
行に
i
台目の車の駐車時間
t
i
(1 ≤
t
i
≤ 120) が与えられます。
データセットの数は 20 を超えません。
Output
データセット毎に駐車場から出てくる順番に車の整理番号を１行に出力します。整理番号は空白区切りで出力してください。
Sample Input
3 5
90
52
82
84
70
2 4
10
30
40
60
0 0
Output for the Sample Input
2 5 1 4 3
1 2 4 3",C,"n,T,C[10][2],c,d,O[10][2],t,s,u,v,h,*p;D(h){p=C[s]+h;*p&&T>=O[s][h]?*p=!printf(""%d%c"",*p,d<n|--c?32:10):0;}main(m){for(;~scanf(""%d%d"",&m,&n);)for(memset(C,T=c=d=0,80);d<n|c;T++){for(s=m;s--;C[s][1]||D(0))D(1);for(;T>=d*10&d<n&c<m*2;C[s=~u?u:v][h]=++d,O[s][h]=T+t,c++)for(h=scanf(""%d"",&t),u=v=-1,s=m;h&&s--;)*C[s]?C[s][1]||(*O[s]<T+t?!~v||*O[s]>*O[v]?v=s:0:!~u||*O[s]<*O[u]?u=s:0):(u=s,h=0);}}",1
p00192,"立体駐車場
街中には駐車場の利用効率を上げるため、立体式やタワー式などの様々な駐車場があります。その中には、ひとつの駐車スペースに図のような「2段式駐車装置」を設置し、2台分の駐車スペースを確保している駐車場もあります。この2段式駐車装置は1台を昇降式のパレット(車を乗せる平らな鉄板)に乗せて上段に駐車させ、もう1台を下段に駐車することができます。
このような2段式駐車装置を用いている駐車場では、上段の車を出し入れするのに、その都度、下段に駐車されている車を出して、退かす必要があるので、必ず管理人さんが駐車している車のカギを預かって、必要に応じて車の出し入れを行います。
鶴ヶ駐車場もこのような2段式駐車装置を設置している駐車場のひとつですが、人手不足のため、車の運転ができない人が管理人になってしまいました。そのため、一度駐車した車はお客さんが戻るまで動かすことができず、上段になった車は下段の車の持ち主が戻ってからでないと車を出すことができない状態になってしまいました。
次から次へと駐車しに来る車を手際よくさばかなければならない管理人さんを手伝うため、鶴ヶ駐車場のルールを満たすプログラムを作成してください。
鶴ヶ駐車場の設備
駐車スペースは1つ以上あり、全て2段式駐車装置が設置されています。
各駐車スペースには1から順に番号が割り振られています。
初めは駐車場に1台も駐車していないものとします。
鶴ヶ駐車場は以下のようなルールを採用しています。
車を止める時
駐車する車の駐車時間が管理人に知らされます。
1台も駐車されていない駐車スペースから先に駐車していきます。
1台も駐車されていない駐車スペースがない場合には、空いている駐車スペースに駐車します。
ただし、そのような駐車スペースが複数あるときは以下の手順で駐車します。
駐車してある車の残り駐車時間が駐車しようとしている車の駐車時間以上のものがある場合、その差が一番小さい駐車スペースに駐車します。
駐車してあるどの車の残り駐車時間も駐車しようとしている車の駐車時間未満である場合、その差が一番小さい駐車スペースに駐車します。
満車(空いている駐車スペースがない)の場合、駐車しようとする車は駐車スペースが空くまで順番に待ちます。空いたと同時に、最初に待っていた車から順に駐車します。
※各条件において、該当する駐車スペースが複数ある場合は駐車スペース番号の最も小さいところに駐車することとします。また、同時刻に出庫する車がある場合は、出庫する車がすべて出てから駐車を始め、待っている車がある限り、駐車できるだけの車が同時刻に駐車することとします。
車が出る時
管理人に知らされた駐車時間を過ぎた車は出庫します。
複数の駐車スペースで同時に駐車時間を過ぎた車があった場合、駐車スペース番号の小さい車から先に出庫します。
上段に駐車した車の駐車時間が過ぎた場合、下段の車が出庫するまで待たなければなりません。上段の車は下段の車が出庫した後、同時刻に出庫します。
下図で鶴ヶ駐車場の駐車方法の例を示します。この例では、駐車スペースの数は3で、車 B ~車 Eがすでに駐車してあるとします。そこに駐車時間70分の車 A が来たことを考えます。駐車スペース3にはすでに2台駐車されているので駐車できず、まだ空いている駐車スペース1か駐車スペース2のどちらかに駐車することになります。駐車スペース1に駐車中の車 B の残り駐車時間は50分、駐車スペース2に駐車中の車Cの残り駐車時間は22分で、どちらも車 A の駐車時間より少ないので、車 A の駐車時間との差がより小さい車 B が駐車してある駐車スペース1に駐車します。その結果、先に駐車していた車 B は上段になります。
駐車スペースの数
m
、駐車する車の台数
n
、各車の駐車時間
t
を入力とし、駐車場から出てくる順番に車の整理番号を出力するプログラムを作成してください。ただし、車には入力の順に1からはじまる整数の整理番号が割り振られており、車は10分おきに1台ずつ整理番号順に駐車しにくるものとします。
Input
複数のデータセットの並びが入力として与えられます。入力の終わりはゼロふたつの行で示されます。各データセットは以下の形式で与えられます。
m
n
t
1
t
2
:
t
n
1 行目に2段式の駐車装置の数
m
(1 ≤
m
≤ 10) と駐車する車の台数
n
(1 ≤
n
≤ 100) が与えられます。続く
n
行に
i
台目の車の駐車時間
t
i
(1 ≤
t
i
≤ 120) が与えられます。
データセットの数は 20 を超えません。
Output
データセット毎に駐車場から出てくる順番に車の整理番号を１行に出力します。整理番号は空白区切りで出力してください。
Sample Input
3 5
90
52
82
84
70
2 4
10
30
40
60
0 0
Output for the Sample Input
2 5 1 4 3
1 2 4 3",Java,"import java.util.*;

public class Main {
    static class Car {
        int id;
        int arrivalTime;
        int parkingDuration;
        int departureTime;
        
        Car(int id, int arrivalTime, int parkingDuration) {
            this.id = id;
            this.arrivalTime = arrivalTime;
            this.parkingDuration = parkingDuration;
            this.departureTime = arrivalTime + parkingDuration;
        }
    }
    
    static class Space {
        Car lower;
        Car upper;
        
        boolean isEmpty() {
            return lower == null && upper == null;
        }
        
        boolean hasSpace() {
            return lower == null || upper == null;
        }
        
        int getRemainingTime(int currentTime) {
            if (lower != null) {
                return Math.max(0, lower.departureTime - currentTime);
            }
            return 0;
        }
    }
    
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        
        while (true) {
            int m = sc.nextInt();
            int n = sc.nextInt();
            
            if (m == 0 && n == 0) break;
            
            List<Car> cars = new ArrayList<>();
            for (int i = 0; i < n; i++) {
                int duration = sc.nextInt();
                cars.add(new Car(i + 1, i * 10, duration));
            }
            
            Space[] spaces = new Space[m];
            for (int i = 0; i < m; i++) {
                spaces[i] = new Space();
            }
            
            Queue<Car> waitingQueue = new LinkedList<>();
            List<Integer> exitOrder = new ArrayList<>();
            int carIndex = 0;
            int currentTime = 0;
            
            while (exitOrder.size() < n) {
                // Process departures
                List<Car> departing = new ArrayList<>();
                for (int i = 0; i < m; i++) {
                    Space space = spaces[i];
                    if (space.lower != null && space.lower.departureTime <= currentTime) {
                        departing.add(space.lower);
                        if (space.upper != null && space.upper.departureTime <= currentTime) {
                            departing.add(space.upper);
                        }
                    }
                }
                
                Collections.sort(departing, (a, b) -> {
                    for (int i = 0; i < m; i++) {
                        if (spaces[i].lower == a) return -1;
                        if (spaces[i].lower == b) return 1;
                    }
                    return 0;
                });
                
                for (Car car : departing) {
                    exitOrder.add(car.id);
                    for (int i = 0; i < m; i++) {
                        if (spaces[i].lower == car) {
                            spaces[i].lower = spaces[i].upper;
                            spaces[i].upper = null;
                            break;
                        }
                    }
                }
                
                // Add arriving cars to queue
                while (carIndex < n && cars.get(carIndex).arrivalTime <= currentTime) {
                    waitingQueue.add(cars.get(carIndex));
                    carIndex++;
                }
                
                // Process parking
                while (!waitingQueue.isEmpty()) {
                    Car car = waitingQueue.peek();
                    int bestSpace = findBestSpace(spaces, car, currentTime);
                    
                    if (bestSpace == -1) break;
                    
                    waitingQueue.poll();
                    if (spaces[bestSpace].isEmpty()) {
                        spaces[bestSpace].lower = car;
                    } else {
                        spaces[bestSpace].upper = car;
                    }
                }
                
                currentTime++;
            }
            
            for (int i = 0; i < exitOrder.size(); i++) {
                if (i > 0) System.out.print("" "");
                System.out.print(exitOrder.get(i));
            }
            System.out.println();
        }
    }
    
    static int findBestSpace(Space[] spaces, Car car, int currentTime) {
        int bestSpace = -1;
        int bestDiff = Integer.MAX_VALUE;
        boolean foundEmpty = false;
        
        // First check for empty spaces
        for (int i = 0; i < spaces.length; i++) {
            if (spaces[i].isEmpty()) {
                return i;
            }
        }
        
        // Check for spaces with one car
        for (int i = 0; i < spaces.length; i++) {
            if (spaces[i].hasSpace() && !spaces[i].isEmpty()) {
                int remaining = spaces[i].getRemainingTime(currentTime);
                int diff = Math.abs(remaining - car.parkingDuration);
                
                if (remaining >= car.parkingDuration) {
                    if (bestSpace == -1 || diff < bestDiff || 
                        (diff == bestDiff && remaining >= car.parkingDuration)) {
                        bestSpace = i;
                        bestDiff = diff;
                    }
                } else {
                    if (bestSpace == -1 || spaces[bestSpace].getRemainingTime(currentTime) >= car.parkingDuration || diff < bestDiff) {
                        bestSpace = i;
                        bestDiff = diff;
                    }
                }
            }
        }
        
        return bestSpace;
    }
}
",0
p00192,"立体駐車場
街中には駐車場の利用効率を上げるため、立体式やタワー式などの様々な駐車場があります。その中には、ひとつの駐車スペースに図のような「2段式駐車装置」を設置し、2台分の駐車スペースを確保している駐車場もあります。この2段式駐車装置は1台を昇降式のパレット(車を乗せる平らな鉄板)に乗せて上段に駐車させ、もう1台を下段に駐車することができます。
このような2段式駐車装置を用いている駐車場では、上段の車を出し入れするのに、その都度、下段に駐車されている車を出して、退かす必要があるので、必ず管理人さんが駐車している車のカギを預かって、必要に応じて車の出し入れを行います。
鶴ヶ駐車場もこのような2段式駐車装置を設置している駐車場のひとつですが、人手不足のため、車の運転ができない人が管理人になってしまいました。そのため、一度駐車した車はお客さんが戻るまで動かすことができず、上段になった車は下段の車の持ち主が戻ってからでないと車を出すことができない状態になってしまいました。
次から次へと駐車しに来る車を手際よくさばかなければならない管理人さんを手伝うため、鶴ヶ駐車場のルールを満たすプログラムを作成してください。
鶴ヶ駐車場の設備
駐車スペースは1つ以上あり、全て2段式駐車装置が設置されています。
各駐車スペースには1から順に番号が割り振られています。
初めは駐車場に1台も駐車していないものとします。
鶴ヶ駐車場は以下のようなルールを採用しています。
車を止める時
駐車する車の駐車時間が管理人に知らされます。
1台も駐車されていない駐車スペースから先に駐車していきます。
1台も駐車されていない駐車スペースがない場合には、空いている駐車スペースに駐車します。
ただし、そのような駐車スペースが複数あるときは以下の手順で駐車します。
駐車してある車の残り駐車時間が駐車しようとしている車の駐車時間以上のものがある場合、その差が一番小さい駐車スペースに駐車します。
駐車してあるどの車の残り駐車時間も駐車しようとしている車の駐車時間未満である場合、その差が一番小さい駐車スペースに駐車します。
満車(空いている駐車スペースがない)の場合、駐車しようとする車は駐車スペースが空くまで順番に待ちます。空いたと同時に、最初に待っていた車から順に駐車します。
※各条件において、該当する駐車スペースが複数ある場合は駐車スペース番号の最も小さいところに駐車することとします。また、同時刻に出庫する車がある場合は、出庫する車がすべて出てから駐車を始め、待っている車がある限り、駐車できるだけの車が同時刻に駐車することとします。
車が出る時
管理人に知らされた駐車時間を過ぎた車は出庫します。
複数の駐車スペースで同時に駐車時間を過ぎた車があった場合、駐車スペース番号の小さい車から先に出庫します。
上段に駐車した車の駐車時間が過ぎた場合、下段の車が出庫するまで待たなければなりません。上段の車は下段の車が出庫した後、同時刻に出庫します。
下図で鶴ヶ駐車場の駐車方法の例を示します。この例では、駐車スペースの数は3で、車 B ~車 Eがすでに駐車してあるとします。そこに駐車時間70分の車 A が来たことを考えます。駐車スペース3にはすでに2台駐車されているので駐車できず、まだ空いている駐車スペース1か駐車スペース2のどちらかに駐車することになります。駐車スペース1に駐車中の車 B の残り駐車時間は50分、駐車スペース2に駐車中の車Cの残り駐車時間は22分で、どちらも車 A の駐車時間より少ないので、車 A の駐車時間との差がより小さい車 B が駐車してある駐車スペース1に駐車します。その結果、先に駐車していた車 B は上段になります。
駐車スペースの数
m
、駐車する車の台数
n
、各車の駐車時間
t
を入力とし、駐車場から出てくる順番に車の整理番号を出力するプログラムを作成してください。ただし、車には入力の順に1からはじまる整数の整理番号が割り振られており、車は10分おきに1台ずつ整理番号順に駐車しにくるものとします。
Input
複数のデータセットの並びが入力として与えられます。入力の終わりはゼロふたつの行で示されます。各データセットは以下の形式で与えられます。
m
n
t
1
t
2
:
t
n
1 行目に2段式の駐車装置の数
m
(1 ≤
m
≤ 10) と駐車する車の台数
n
(1 ≤
n
≤ 100) が与えられます。続く
n
行に
i
台目の車の駐車時間
t
i
(1 ≤
t
i
≤ 120) が与えられます。
データセットの数は 20 を超えません。
Output
データセット毎に駐車場から出てくる順番に車の整理番号を１行に出力します。整理番号は空白区切りで出力してください。
Sample Input
3 5
90
52
82
84
70
2 4
10
30
40
60
0 0
Output for the Sample Input
2 5 1 4 3
1 2 4 3",Java,"import java.util.Arrays;
import java.util.LinkedList;
import java.util.Scanner;

public class Main {
	
	public static final int MAX_SIZE = 10;
	public static final int MAX_CAR = 100;
	
	public static final int M_INF = Integer.MIN_VALUE / 2 + 1;
	
	public static boolean try_fst(int[][] spaces, int[][] numbers, final int m, final int remain_time, final int car_number){
		for(int i = 0; i < m; i++){
			if(spaces[i][0] <= M_INF){
				spaces[i][0] = remain_time;
				numbers[i][0] = car_number;
				return true;
			}
		}
		
		return false;
	}
	
	public static void add_time(int[][] spaces, final int m, final int time){
		for(int i = 0; i < m; i++){
			if(spaces[i][0] <= M_INF){
				continue;
			}
			
			spaces[i][0] -= time;
			spaces[i][1] -= time;
		}
	}
	
	public static boolean is_finish(int[][] spaces, final int m){
		for(int i = 0; i < m; i++){
			if(spaces[i][0] > M_INF){
				return false;
			}
		}
		
		return true;
	}
	
	public static boolean can_upper(int[][] spaces, int[][] numbers, final int m, final int remain_time, final int car_number){
		for(int i = 0; i < m; i++){
			if(spaces[i][0] >= remain_time && spaces[i][1] <= M_INF){
				return true;
			}
		}
		
		return false;
	}
	
	public static boolean try_snd(int[][] spaces, int[][] numbers, final int m, final int remain_time, final int car_number){
		final boolean can_upper = can_upper(spaces, numbers, m, remain_time, car_number);
		
		int pos = -1;
		int attr = can_upper ? Integer.MAX_VALUE : Integer.MIN_VALUE;
		for(int i = 0; i < m; i++){
			//System.out.println(can_upper + "" "" + (spaces[i][0]<= M_INF) + "" "" + (attr < spaces[i][0]));
			
			if(can_upper && spaces[i][1] <= M_INF && spaces[i][0] >= remain_time && attr > spaces[i][0]){
				attr = spaces[i][0];
				pos = i;
			}else if(!can_upper && spaces[i][1] <= M_INF && attr < spaces[i][0]){
				attr = spaces[i][0];
				pos = i;
			}
		}
		
		//System.out.println(attr  + "" "" + pos + "" "" + can_upper);
		
		if(pos < 0){
			return false;
		}
		
		spaces[pos][1] = Math.max(spaces[pos][0], remain_time);
		numbers[pos][1] = numbers[pos][0];
		spaces[pos][0] = remain_time;
		numbers[pos][0] = car_number;
		
		return true;
	}
	
	public static void print(int[][] spaces, int[][] numbers, final int m){
		System.out.println(""-----------------------------------"");
		for(int i = 0; i < m; i++){
			System.out.print(spaces[i][0] + "" "");
		}
		System.out.println();
		for(int i = 0; i < m; i++){
			System.out.print(spaces[i][1] + "" "");
		}
		System.out.println();
		for(int i = 0; i < m; i++){
			System.out.print(numbers[i][0] + "" "");
		}
		System.out.println();
		for(int i = 0; i < m; i++){
			System.out.print(numbers[i][1] + "" "");
		}
		System.out.println();
		System.out.println(""-----------------------------------"");
		
	}
		
	public static void main(String[] args) {
		Scanner sc = new Scanner(System.in);
		
		int[][] spaces = new int[MAX_SIZE][2];
		int[][] numbers = new int[MAX_SIZE][2];
		
		while(true){
			final int m = sc.nextInt();
			final int n = sc.nextInt();
			
			if(m == 0 && n == 0){
				break;
			}
			
			for(int i = 0; i < m; i++){
				spaces[i][0] = spaces[i][1] = M_INF;
				numbers[i][0] = numbers[i][1] = -1;
			}
			
			LinkedList<Integer> remain_queue = new LinkedList<Integer>();
			LinkedList<Integer> number_queue = new LinkedList<Integer>();
			//int time = 0;
			
			LinkedList<Integer> out_numbers = new LinkedList<Integer>();
			for(int car = 0; ; car++){
				//
				if(car < n){
					remain_queue.add(sc.nextInt());
					number_queue.add(car + 1);
				}else if(remain_queue.isEmpty() && is_finish(spaces, m)){
					break;
				}
				
				add_time(spaces, m, 10);
				//print(spaces, numbers, m);
				
				while(true){
					int min = 1;
					int min_pos = -1;
					int min_car = -1;
					
					for(int i = 0; i < m; i++){
						if(spaces[i][0] <= M_INF){
							continue;
						}else if(spaces[i][0] < min){
							min = spaces[i][0];
							min_car = numbers[i][0];
							min_pos = i;
						}
					}
					
					if(min_car == -1){
						break;
					}
					
					spaces[min_pos][0] = spaces[min_pos][1];
					numbers[min_pos][0] = numbers[min_pos][1];
					spaces[min_pos][1] = M_INF;
					numbers[min_pos][1] = M_INF;
					out_numbers.add(min_car);
				}
				
				while(!remain_queue.isEmpty()){
					final int remain_time = remain_queue.poll();
					final int car_number  = number_queue.poll();
					
					if(try_fst(spaces, numbers, m, remain_time, car_number)){
						//ok
						continue;
					}else if(try_snd(spaces, numbers, m, remain_time, car_number)){
						//ok
						continue;
					}else{
						//System.out.println(""fail "" + car_number);
						remain_queue.addFirst(remain_time);
						number_queue.addFirst(car_number);
						break;
					}
				}
			}
			
			boolean first = true;
			for(int i : out_numbers){
				if(first){
					first = false;
					System.out.print(i);
				}else{
					System.out.print("" "" + i);
				}
			}
			System.out.println();
			
			//System.out.println(out_numbers);
		}

	}

}",1
p00192,"立体駐車場
街中には駐車場の利用効率を上げるため、立体式やタワー式などの様々な駐車場があります。その中には、ひとつの駐車スペースに図のような「2段式駐車装置」を設置し、2台分の駐車スペースを確保している駐車場もあります。この2段式駐車装置は1台を昇降式のパレット(車を乗せる平らな鉄板)に乗せて上段に駐車させ、もう1台を下段に駐車することができます。
このような2段式駐車装置を用いている駐車場では、上段の車を出し入れするのに、その都度、下段に駐車されている車を出して、退かす必要があるので、必ず管理人さんが駐車している車のカギを預かって、必要に応じて車の出し入れを行います。
鶴ヶ駐車場もこのような2段式駐車装置を設置している駐車場のひとつですが、人手不足のため、車の運転ができない人が管理人になってしまいました。そのため、一度駐車した車はお客さんが戻るまで動かすことができず、上段になった車は下段の車の持ち主が戻ってからでないと車を出すことができない状態になってしまいました。
次から次へと駐車しに来る車を手際よくさばかなければならない管理人さんを手伝うため、鶴ヶ駐車場のルールを満たすプログラムを作成してください。
鶴ヶ駐車場の設備
駐車スペースは1つ以上あり、全て2段式駐車装置が設置されています。
各駐車スペースには1から順に番号が割り振られています。
初めは駐車場に1台も駐車していないものとします。
鶴ヶ駐車場は以下のようなルールを採用しています。
車を止める時
駐車する車の駐車時間が管理人に知らされます。
1台も駐車されていない駐車スペースから先に駐車していきます。
1台も駐車されていない駐車スペースがない場合には、空いている駐車スペースに駐車します。
ただし、そのような駐車スペースが複数あるときは以下の手順で駐車します。
駐車してある車の残り駐車時間が駐車しようとしている車の駐車時間以上のものがある場合、その差が一番小さい駐車スペースに駐車します。
駐車してあるどの車の残り駐車時間も駐車しようとしている車の駐車時間未満である場合、その差が一番小さい駐車スペースに駐車します。
満車(空いている駐車スペースがない)の場合、駐車しようとする車は駐車スペースが空くまで順番に待ちます。空いたと同時に、最初に待っていた車から順に駐車します。
※各条件において、該当する駐車スペースが複数ある場合は駐車スペース番号の最も小さいところに駐車することとします。また、同時刻に出庫する車がある場合は、出庫する車がすべて出てから駐車を始め、待っている車がある限り、駐車できるだけの車が同時刻に駐車することとします。
車が出る時
管理人に知らされた駐車時間を過ぎた車は出庫します。
複数の駐車スペースで同時に駐車時間を過ぎた車があった場合、駐車スペース番号の小さい車から先に出庫します。
上段に駐車した車の駐車時間が過ぎた場合、下段の車が出庫するまで待たなければなりません。上段の車は下段の車が出庫した後、同時刻に出庫します。
下図で鶴ヶ駐車場の駐車方法の例を示します。この例では、駐車スペースの数は3で、車 B ~車 Eがすでに駐車してあるとします。そこに駐車時間70分の車 A が来たことを考えます。駐車スペース3にはすでに2台駐車されているので駐車できず、まだ空いている駐車スペース1か駐車スペース2のどちらかに駐車することになります。駐車スペース1に駐車中の車 B の残り駐車時間は50分、駐車スペース2に駐車中の車Cの残り駐車時間は22分で、どちらも車 A の駐車時間より少ないので、車 A の駐車時間との差がより小さい車 B が駐車してある駐車スペース1に駐車します。その結果、先に駐車していた車 B は上段になります。
駐車スペースの数
m
、駐車する車の台数
n
、各車の駐車時間
t
を入力とし、駐車場から出てくる順番に車の整理番号を出力するプログラムを作成してください。ただし、車には入力の順に1からはじまる整数の整理番号が割り振られており、車は10分おきに1台ずつ整理番号順に駐車しにくるものとします。
Input
複数のデータセットの並びが入力として与えられます。入力の終わりはゼロふたつの行で示されます。各データセットは以下の形式で与えられます。
m
n
t
1
t
2
:
t
n
1 行目に2段式の駐車装置の数
m
(1 ≤
m
≤ 10) と駐車する車の台数
n
(1 ≤
n
≤ 100) が与えられます。続く
n
行に
i
台目の車の駐車時間
t
i
(1 ≤
t
i
≤ 120) が与えられます。
データセットの数は 20 を超えません。
Output
データセット毎に駐車場から出てくる順番に車の整理番号を１行に出力します。整理番号は空白区切りで出力してください。
Sample Input
3 5
90
52
82
84
70
2 4
10
30
40
60
0 0
Output for the Sample Input
2 5 1 4 3
1 2 4 3",Python,"import heapq
from collections import deque

def solve(m, n, parking_times):
    # spaces[i] = [lower_car, upper_car] where car = (car_id, end_time)
    spaces = [[None, None] for _ in range(m)]
    waiting_queue = deque()
    events = []  # (time, event_type, data)
    exit_order = []
    
    current_time = 0
    
    for car_id in range(1, n + 1):
        arrival_time = (car_id - 1) * 10
        parking_time = parking_times[car_id - 1]
        heapq.heappush(events, (arrival_time, 0, car_id, parking_time))  # 0 = arrival
    
    while events or waiting_queue:
        if not events:
            break
            
        current_time, event_type, *data = heapq.heappop(events)
        
        if event_type == 0:  # arrival
            car_id, parking_time = data
            end_time = current_time + parking_time
            
            # Process all exits at current time first
            exits_now = []
            temp_events = []
            while events and events[0][0] == current_time and events[0][1] == 1:
                temp_events.append(heapq.heappop(events))
            
            for ev in temp_events:
                exits_now.append(ev)
            
            # Process exits
            for exit_event in sorted(exits_now, key=lambda x: x[2]):
                space_id = x[2]
                process_exit(spaces, space_id, exit_order)
            
            # Put events back
            for ev in temp_events:
                if ev not in exits_now:
                    heapq.heappush(events, ev)
            
            # Try to park cars from waiting queue
            while waiting_queue:
                w_car_id, w_parking_time, w_arrival = waiting_queue[0]
                w_end_time = w_arrival + w_parking_time
                space_idx = find_space(spaces, w_parking_time, current_time)
                if space_idx == -1:
                    break
                waiting_queue.popleft()
                park_car(spaces, space_idx, w_car_id, w_end_time, current_time, events)
            
            # Try to park current car
            space_idx = find_space(spaces, parking_time, current_time)
            if space_idx == -1:
                waiting_queue.append((car_id, parking_time, current_time))
            else:
                park_car(spaces, space_idx, car_id, end_time, current_time, events)
                
        elif event_type == 1:  # exit
            space_id = data[0]
            process_exit(spaces, space_id, exit_order)
            
            # Try to park cars from waiting queue
            while waiting_queue:
                w_car_id, w_parking_time, w_arrival = waiting_queue[0]
                w_end_time = current_time + w_parking_time
                space_idx = find_space(spaces, w_parking_time, current_time)
                if space_idx == -1:
                    break
                waiting_queue.popleft()
                park_car(spaces, space_idx, w_car_id, w_end_time, current_time, events)
    
    return exit_order

def find_space(spaces, parking_time, current_time):
    empty_spaces = []
    one_car_spaces = []
    
    for i, space in enumerate(spaces):
        if space[0] is None:
            empty_spaces.append(i)
        elif space[1] is None:
            remaining_time = space[0][1] - current_time
            one_car_spaces.append((i, remaining_time))
    
    if empty_spaces:
        return min(empty_spaces)
    
    if not one_car_spaces:
        return -1
    
    # Find best space
    ge_spaces = [(i, rt) for i, rt in one_car_spaces if rt >= parking_time]
    lt_spaces = [(i, rt) for i, rt in one_car_spaces if rt < parking_time]
    
    if ge_spaces:
        best = min(ge_spaces, key=lambda x: (x[1] - parking_time, x[0]))
        return best[0]
    else:
        best = min(lt_spaces, key=lambda x: (parking_time - x[1], x[0]))
        return best[0]

def park_car(spaces, space_idx, car_id, end_time, current_time, events):
    if spaces[space_idx][0] is None:
        spaces[space_idx][0] = (car_id, end_time)
        heapq.heappush(events, (end_time, 1, space_idx))
    else:
        spaces[space_idx][1] = (car_id, end_time)

def process_exit(spaces, space_id, exit_order):
    if spaces[space_id][1] is not None:
        exit_order.append(spaces[space_id][0][0])
        exit_order.append(spaces[space_id][1][0])
        spaces[space_id][0] = None
        spaces[space_id][1] = None
    elif spaces[space_id][0] is not None:
        exit_order.append(spaces[space_id][0][0])
        spaces[space_id][0] = None

while True:
    line = input().split()
    m, n = int(line[0]), int(line[1])
    if m == 0 and n == 0:
        break
    
    parking_times = []
    for _ in range(n):
        parking_times.append(int(input()))
    
    result = solve(m, n, parking_times)
    print(' '.join(map(str, result)))
",0
p00192,"立体駐車場
街中には駐車場の利用効率を上げるため、立体式やタワー式などの様々な駐車場があります。その中には、ひとつの駐車スペースに図のような「2段式駐車装置」を設置し、2台分の駐車スペースを確保している駐車場もあります。この2段式駐車装置は1台を昇降式のパレット(車を乗せる平らな鉄板)に乗せて上段に駐車させ、もう1台を下段に駐車することができます。
このような2段式駐車装置を用いている駐車場では、上段の車を出し入れするのに、その都度、下段に駐車されている車を出して、退かす必要があるので、必ず管理人さんが駐車している車のカギを預かって、必要に応じて車の出し入れを行います。
鶴ヶ駐車場もこのような2段式駐車装置を設置している駐車場のひとつですが、人手不足のため、車の運転ができない人が管理人になってしまいました。そのため、一度駐車した車はお客さんが戻るまで動かすことができず、上段になった車は下段の車の持ち主が戻ってからでないと車を出すことができない状態になってしまいました。
次から次へと駐車しに来る車を手際よくさばかなければならない管理人さんを手伝うため、鶴ヶ駐車場のルールを満たすプログラムを作成してください。
鶴ヶ駐車場の設備
駐車スペースは1つ以上あり、全て2段式駐車装置が設置されています。
各駐車スペースには1から順に番号が割り振られています。
初めは駐車場に1台も駐車していないものとします。
鶴ヶ駐車場は以下のようなルールを採用しています。
車を止める時
駐車する車の駐車時間が管理人に知らされます。
1台も駐車されていない駐車スペースから先に駐車していきます。
1台も駐車されていない駐車スペースがない場合には、空いている駐車スペースに駐車します。
ただし、そのような駐車スペースが複数あるときは以下の手順で駐車します。
駐車してある車の残り駐車時間が駐車しようとしている車の駐車時間以上のものがある場合、その差が一番小さい駐車スペースに駐車します。
駐車してあるどの車の残り駐車時間も駐車しようとしている車の駐車時間未満である場合、その差が一番小さい駐車スペースに駐車します。
満車(空いている駐車スペースがない)の場合、駐車しようとする車は駐車スペースが空くまで順番に待ちます。空いたと同時に、最初に待っていた車から順に駐車します。
※各条件において、該当する駐車スペースが複数ある場合は駐車スペース番号の最も小さいところに駐車することとします。また、同時刻に出庫する車がある場合は、出庫する車がすべて出てから駐車を始め、待っている車がある限り、駐車できるだけの車が同時刻に駐車することとします。
車が出る時
管理人に知らされた駐車時間を過ぎた車は出庫します。
複数の駐車スペースで同時に駐車時間を過ぎた車があった場合、駐車スペース番号の小さい車から先に出庫します。
上段に駐車した車の駐車時間が過ぎた場合、下段の車が出庫するまで待たなければなりません。上段の車は下段の車が出庫した後、同時刻に出庫します。
下図で鶴ヶ駐車場の駐車方法の例を示します。この例では、駐車スペースの数は3で、車 B ~車 Eがすでに駐車してあるとします。そこに駐車時間70分の車 A が来たことを考えます。駐車スペース3にはすでに2台駐車されているので駐車できず、まだ空いている駐車スペース1か駐車スペース2のどちらかに駐車することになります。駐車スペース1に駐車中の車 B の残り駐車時間は50分、駐車スペース2に駐車中の車Cの残り駐車時間は22分で、どちらも車 A の駐車時間より少ないので、車 A の駐車時間との差がより小さい車 B が駐車してある駐車スペース1に駐車します。その結果、先に駐車していた車 B は上段になります。
駐車スペースの数
m
、駐車する車の台数
n
、各車の駐車時間
t
を入力とし、駐車場から出てくる順番に車の整理番号を出力するプログラムを作成してください。ただし、車には入力の順に1からはじまる整数の整理番号が割り振られており、車は10分おきに1台ずつ整理番号順に駐車しにくるものとします。
Input
複数のデータセットの並びが入力として与えられます。入力の終わりはゼロふたつの行で示されます。各データセットは以下の形式で与えられます。
m
n
t
1
t
2
:
t
n
1 行目に2段式の駐車装置の数
m
(1 ≤
m
≤ 10) と駐車する車の台数
n
(1 ≤
n
≤ 100) が与えられます。続く
n
行に
i
台目の車の駐車時間
t
i
(1 ≤
t
i
≤ 120) が与えられます。
データセットの数は 20 を超えません。
Output
データセット毎に駐車場から出てくる順番に車の整理番号を１行に出力します。整理番号は空白区切りで出力してください。
Sample Input
3 5
90
52
82
84
70
2 4
10
30
40
60
0 0
Output for the Sample Input
2 5 1 4 3
1 2 4 3",Python,"from collections import deque

def out(time, parking):
  x = len(parking)
  outs = []
  for i in range(x):
    for j in range(2):
      if parking[i][j] != None:
        parking[i][j][0] -= time
  
  for i in range(x):
    c1 = parking[i][0]
    c2 = parking[i][1]
    if c1 != None and c2 != None:
      if c1[0] <= 0 and c2[0] <= 0:
        outs.append([c2[1], c1[1]])
        parking[i][0] = None
        parking[i][1] = None
      elif c2[0] <= 0:
        outs.append([c2[1]])
        parking[i][1] = None
    elif c1 != None:
      if c1[0] <= 0:
        outs.append([c1[1]])
        parking[i][0] = None
    elif c2 != None:
      if c2[0] <= 0:
        outs.append([c2[1]])
        parking[i][1] = None
  outs.sort()
  lst = []
  for l in outs:
    lst += l
  return lst

def into(num, time, parking):
  x = len(parking)
  times = []
  for i in range(x):
    if parking[i] == [None, None]:
      parking[i][0] = [time, num]
      return
    if parking[i][0] == None:
      times.append((parking[i][1][0], i))
    elif parking[i][1] == None:
      times.append((parking[i][0][0], i))
  times.sort()
  
  for t, ind in times:
    if t >= time:
      if parking[ind][0] == None:
        parking[ind][0] = [time, num]
      else:
        parking[ind][1] = [time, num]
      return
  else:
    max_t = t

  for t, ind in times:
    if t == max_t:
      if parking[ind][0] == None:
        parking[ind][0] = [time, num]
      else:
        parking[ind][1] = [time, num]
      return
 
while True:
  m, n = map(int, input().split())
  if m == 0:
    break
  
  parking = [[None] * 2 for _ in range(m)]
  wait = deque()
  space = m * 2
  ans = []
  
  for t in range(120 * n):
    o = out(1, parking)
    if o:
      space += len(o)
      ans += o

    if t % 10 == 0 and t <= 10 * (n - 1):
      time = int(input())
      wait.append((t // 10 + 1, time))

    for i in range(min(space, len(wait))):
      num, time = wait.popleft()
      into(num, time, parking)
      space -= 1
  print(*ans)
",1
p00193,"コンビニ
コンビニエンスストア・デブンイレブンは事業を広げるため若松市に一店舗目をオープンしようと考えています。若松市には既に他のたくさんのコンビニエンスストアがあるので、新店舗をオープンする場所が成功の鍵を握ることになりそうです。デブンイレブンは「お客さんは自分の住んでいる地域から最も近いコンビニを利用する」という前提の下、「多くのお客さんが利用するであろう地点」に出店することにしています。
デブンイレブンは、既設の各コンビニがカバーしている範囲を把握するため、若松市の地図を合同な正六角形(以後「ブロック」)を用いて区分しました。このとき、各ブロックには既設のコンビニが多くとも一つだけ入るように区分しました。この地図上で、各ブロックからあるコンビニへ行くのに経由するブロックの数をもとにコンビニとの距離を求めます。各ブロックはこの距離が最も小さいコンビニによってカバーされていると考えます。問題は、この地図をもとに「できるだけ多くのブロックをカバーする既設のコンビニがないブロック」を探すことです。
デブンイレブンのプログラマであるあなたは、ブロック分けされた地図情報と新店舗の候補地の情報から、最も広くカバーできるブロック数を計算するプログラムを開発することになりました。
m × n
に区分した地図は図1のように表します。六角形のブロックが横に
m
個、縦に
n
個並び、それぞれは一つの座標(
x, y
)で示されます。奇数行の左端はその上の行の左端の左下に、偶数行の左端はその上の行の左端の右下に、それぞれ位置します。例えば、座標(1, 1)は図1の一番左上のブロックを示します。また、座標(1, 2)は座標(1, 1)の右下に位置し、座標(1, 3)は座標(1, 2)の左下に位置します。
図2は既設のコンビニが6個あった場合の例で、6 × 6 に区分されています。各コンビニは1から順に番号が振られています。このとき、各コンビニがカバーするブロックを番号毎に塗り分けると図3のようになります。座標(1, 4)や(2, 5)のように塗られていないブロックは最も近いコンビニが二つ以上あり、どちらとも判断がつかないブロックになっています。例えば、座標(1, 4)のブロックの場合、番号4のコンビニと番号5のコンビニへの距離が等しく、このブロックをカバーしているコンビニはないものとして考えます。番号4のコンビニがカバーしているブロック数は5となります。
ここで、デブンイレブンが座標(1, 3)と座標(5, 3)を新店舗の候補地として考えているとします。座標(1, 3)に店舗を構えた場合、カバーできるブロック数は3となります(図4)。一方、座標(5, 3)に店舗を構えた場合にカバーできるブロック数は4となります(図5)。したがって、最も広くカバーできるブロック数は4となります。
地図情報
m × n
、既設のコンビニの数
s
とその座標(
x, y
)、候補地の数
t
とその座標(
p, q
)を入力とし、全候補地の中で最も広くカバーできるブロック数を出力するプログラムを作成してください。
Input
複数のデータセットの並びが入力として与えられます。入力の終わりはゼロふたつの行で示されます。 各データセットは以下の形式で与えられます。
m
n
s
x
1
y
1
x
2
y
2
:
x
s
y
s
t
p
1
q
1
p
2
q
2
:
p
t
q
t
1 行目に区分した地図の大きさ(横、縦)を表す整数
m
,
n
(2 ≤
m, n
≤ 100) が与えられます。
2行目に既設のコンビニの数
s
(1 ≤
s
≤ 10) が与えられます。続く
s
行に、
i
個目の既設のコンビニの座標
x
i
,
y
1
が与えられます。
続く行に、新店舗の候補地の数
t
(1 ≤
t
≤ 10 ) が与えられます。続く
t
行に、
i
個目の候補地の座標
p
i
,
q
i
が与えられます。
データセットの数は 20 を超えません。
Output
データセット毎に、全候補地の中で最も広くカバーできるブロック数を１行に出力します。
Sample Input
6 6
6  
1 1
6 1
3 2
3 5
1 6
5 6
2
1 3
5 3
6 6
6
3 2
3 5
6 1
1 1
1 6
5 6
2
2 3
5 3
0 0
Output for the Sample Input
4
4",C,"#include <stdio.h>
#include <stdlib.h>

typedef struct {
    int x, y;
} Point;

int dx_odd[6] = {0, 1, 1, 0, -1, -1};
int dy_odd[6] = {-1, -1, 0, 1, 0, -1};
int dx_even[6] = {-1, 0, 1, 1, 1, 0};
int dy_even[6] = {-1, -1, 0, 1, 0, -1};

typedef struct {
    int x, y, dist;
} Node;

int dist[101][101];
int queue[20000][2];
int qfront, qrear;

void bfs(int sx, int sy, int m, int n) {
    int visited[101][101] = {0};
    qfront = qrear = 0;
    queue[qrear][0] = sx;
    queue[qrear][1] = sy;
    qrear++;
    visited[sx][sy] = 1;
    dist[sx][sy] = 0;
    
    while (qfront < qrear) {
        int cx = queue[qfront][0];
        int cy = queue[qfront][1];
        qfront++;
        
        int *dx = (cy % 2 == 1) ? dx_odd : dx_even;
        int *dy = (cy % 2 == 1) ? dy_odd : dy_even;
        
        for (int i = 0; i < 6; i++) {
            int nx = cx + dx[i];
            int ny = cy + dy[i];
            
            if (nx >= 1 && nx <= m && ny >= 1 && ny <= n && !visited[nx][ny]) {
                visited[nx][ny] = 1;
                dist[nx][ny] = dist[cx][cy] + 1;
                queue[qrear][0] = nx;
                queue[qrear][1] = ny;
                qrear++;
            }
        }
    }
}

int main() {
    int m, n;
    
    while (scanf(""%d %d"", &m, &n) == 2) {
        if (m == 0 && n == 0) break;
        
        int s;
        scanf(""%d"", &s);
        Point stores[11];
        for (int i = 0; i < s; i++) {
            scanf(""%d %d"", &stores[i].x, &stores[i].y);
        }
        
        int t;
        scanf(""%d"", &t);
        Point candidates[11];
        for (int i = 0; i < t; i++) {
            scanf(""%d %d"", &candidates[i].x, &candidates[i].y);
        }
        
        int max_coverage = 0;
        
        for (int cand = 0; cand < t; cand++) {
            int coverage = 0;
            
            for (int x = 1; x <= m; x++) {
                for (int y = 1; y <= n; y++) {
                    int min_dist_cand = 1000000;
                    int min_dist_store = 1000000;
                    int count_min_store = 0;
                    
                    bfs(candidates[cand].x, candidates[cand].y, m, n);
                    min_dist_cand = dist[x][y];
                    
                    for (int i = 0; i < s; i++) {
                        bfs(stores[i].x, stores[i].y, m, n);
                        int d = dist[x][y];
                        if (d < min_dist_store) {
                            min_dist_store = d;
                            count_min_store = 1;
                        } else if (d == min_dist_store) {
                            count_min_store++;
                        }
                    }
                    
                    if (min_dist_cand < min_dist_store) {
                        coverage++;
                    } else if (min_dist_cand == min_dist_store && count_min_store == 0) {
                        coverage++;
                    }
                }
            }
            
            if (coverage > max_coverage) {
                max_coverage = coverage;
            }
        }
        
        printf(""%d\n"", max_coverage);
    }
    
    return 0;
}
",0
p00193,"コンビニ
コンビニエンスストア・デブンイレブンは事業を広げるため若松市に一店舗目をオープンしようと考えています。若松市には既に他のたくさんのコンビニエンスストアがあるので、新店舗をオープンする場所が成功の鍵を握ることになりそうです。デブンイレブンは「お客さんは自分の住んでいる地域から最も近いコンビニを利用する」という前提の下、「多くのお客さんが利用するであろう地点」に出店することにしています。
デブンイレブンは、既設の各コンビニがカバーしている範囲を把握するため、若松市の地図を合同な正六角形(以後「ブロック」)を用いて区分しました。このとき、各ブロックには既設のコンビニが多くとも一つだけ入るように区分しました。この地図上で、各ブロックからあるコンビニへ行くのに経由するブロックの数をもとにコンビニとの距離を求めます。各ブロックはこの距離が最も小さいコンビニによってカバーされていると考えます。問題は、この地図をもとに「できるだけ多くのブロックをカバーする既設のコンビニがないブロック」を探すことです。
デブンイレブンのプログラマであるあなたは、ブロック分けされた地図情報と新店舗の候補地の情報から、最も広くカバーできるブロック数を計算するプログラムを開発することになりました。
m × n
に区分した地図は図1のように表します。六角形のブロックが横に
m
個、縦に
n
個並び、それぞれは一つの座標(
x, y
)で示されます。奇数行の左端はその上の行の左端の左下に、偶数行の左端はその上の行の左端の右下に、それぞれ位置します。例えば、座標(1, 1)は図1の一番左上のブロックを示します。また、座標(1, 2)は座標(1, 1)の右下に位置し、座標(1, 3)は座標(1, 2)の左下に位置します。
図2は既設のコンビニが6個あった場合の例で、6 × 6 に区分されています。各コンビニは1から順に番号が振られています。このとき、各コンビニがカバーするブロックを番号毎に塗り分けると図3のようになります。座標(1, 4)や(2, 5)のように塗られていないブロックは最も近いコンビニが二つ以上あり、どちらとも判断がつかないブロックになっています。例えば、座標(1, 4)のブロックの場合、番号4のコンビニと番号5のコンビニへの距離が等しく、このブロックをカバーしているコンビニはないものとして考えます。番号4のコンビニがカバーしているブロック数は5となります。
ここで、デブンイレブンが座標(1, 3)と座標(5, 3)を新店舗の候補地として考えているとします。座標(1, 3)に店舗を構えた場合、カバーできるブロック数は3となります(図4)。一方、座標(5, 3)に店舗を構えた場合にカバーできるブロック数は4となります(図5)。したがって、最も広くカバーできるブロック数は4となります。
地図情報
m × n
、既設のコンビニの数
s
とその座標(
x, y
)、候補地の数
t
とその座標(
p, q
)を入力とし、全候補地の中で最も広くカバーできるブロック数を出力するプログラムを作成してください。
Input
複数のデータセットの並びが入力として与えられます。入力の終わりはゼロふたつの行で示されます。 各データセットは以下の形式で与えられます。
m
n
s
x
1
y
1
x
2
y
2
:
x
s
y
s
t
p
1
q
1
p
2
q
2
:
p
t
q
t
1 行目に区分した地図の大きさ(横、縦)を表す整数
m
,
n
(2 ≤
m, n
≤ 100) が与えられます。
2行目に既設のコンビニの数
s
(1 ≤
s
≤ 10) が与えられます。続く
s
行に、
i
個目の既設のコンビニの座標
x
i
,
y
1
が与えられます。
続く行に、新店舗の候補地の数
t
(1 ≤
t
≤ 10 ) が与えられます。続く
t
行に、
i
個目の候補地の座標
p
i
,
q
i
が与えられます。
データセットの数は 20 を超えません。
Output
データセット毎に、全候補地の中で最も広くカバーできるブロック数を１行に出力します。
Sample Input
6 6
6  
1 1
6 1
3 2
3 5
1 6
5 6
2
1 3
5 3
6 6
6
3 2
3 5
6 1
1 1
1 6
5 6
2
2 3
5 3
0 0
Output for the Sample Input
4
4",C,"// Aizu Vol-1 0193: Convenience Store
// 2017.8.25 bal4u@uu

#include <stdio.h>
#include <string.h>

#define abs(a) ((a)>=0?(a):(-(a)))
//#define min(a,b) ((a)<=(b)?(a):(b))

typedef struct { int r, c, f; } T;
T shop[25]; int n, S, N;
int R, C;

int hexDistance(int r1, int c1, int r2, int c2)
{
	int dr, dc, c;
	dr = abs(r2 - r1), dc = abs(c2 - c1);
	if (r2 == r1) return dc;
	if (c2 == c1) return dr;
	if (r2 < r1) c = r2, r2 = r1, r1 = c, c = c2, c2 = c1, c1 = c;
	if (c2 >= c1) {
		c = c1 + (dr+1-(r1&1))/2;
		if (c2 >= c) dr += abs(c-c2);
	} else {
		c = c1 - (dr+(r1&1))/2;
		if (c2 <= c) dr += abs(c-c2);
	}
	return dr;
}

int belong(int r, int c)
{
	int i, d, k, min;
	for (min = -1, d = -2, k = 0, i = 1; i <= n; i++) {
		d = hexDistance(shop[i].r, shop[i].c, r, c);
		if (min < 0 || d < min) min = d, k = i;
		else if (d == min) k = 0;
	}
	return k;
}

int main()
{
	int i, r, c;
	int ans;

	while (scanf(""%d%d"", &C, &R) && C) {
		scanf(""%d"", &S);
		for (n = 1, i = 0; i < S; i++) {
			scanf(""%d%d"", &shop[n].c, &shop[n].r), shop[n++].f = 0;
		}
		scanf(""%d"", &N);
		for (i = 0; i < N; i++) {
			scanf(""%d%d"", &shop[n].c, &shop[n].r), shop[n++].f = 0;
		}
		n--;
		for (r = 1; r <= R; r++) for (c = 1; c <= C; c++)
			if ((i = belong(r, c)) > 0) shop[i].f++;
		for (ans = -1, i = S+1; i <= n; i++) if (shop[i].f > ans) ans = shop[i].f;
		printf(""%d\n"", ans);
	}
	return 0;
}",1
p00193,"コンビニ
コンビニエンスストア・デブンイレブンは事業を広げるため若松市に一店舗目をオープンしようと考えています。若松市には既に他のたくさんのコンビニエンスストアがあるので、新店舗をオープンする場所が成功の鍵を握ることになりそうです。デブンイレブンは「お客さんは自分の住んでいる地域から最も近いコンビニを利用する」という前提の下、「多くのお客さんが利用するであろう地点」に出店することにしています。
デブンイレブンは、既設の各コンビニがカバーしている範囲を把握するため、若松市の地図を合同な正六角形(以後「ブロック」)を用いて区分しました。このとき、各ブロックには既設のコンビニが多くとも一つだけ入るように区分しました。この地図上で、各ブロックからあるコンビニへ行くのに経由するブロックの数をもとにコンビニとの距離を求めます。各ブロックはこの距離が最も小さいコンビニによってカバーされていると考えます。問題は、この地図をもとに「できるだけ多くのブロックをカバーする既設のコンビニがないブロック」を探すことです。
デブンイレブンのプログラマであるあなたは、ブロック分けされた地図情報と新店舗の候補地の情報から、最も広くカバーできるブロック数を計算するプログラムを開発することになりました。
m × n
に区分した地図は図1のように表します。六角形のブロックが横に
m
個、縦に
n
個並び、それぞれは一つの座標(
x, y
)で示されます。奇数行の左端はその上の行の左端の左下に、偶数行の左端はその上の行の左端の右下に、それぞれ位置します。例えば、座標(1, 1)は図1の一番左上のブロックを示します。また、座標(1, 2)は座標(1, 1)の右下に位置し、座標(1, 3)は座標(1, 2)の左下に位置します。
図2は既設のコンビニが6個あった場合の例で、6 × 6 に区分されています。各コンビニは1から順に番号が振られています。このとき、各コンビニがカバーするブロックを番号毎に塗り分けると図3のようになります。座標(1, 4)や(2, 5)のように塗られていないブロックは最も近いコンビニが二つ以上あり、どちらとも判断がつかないブロックになっています。例えば、座標(1, 4)のブロックの場合、番号4のコンビニと番号5のコンビニへの距離が等しく、このブロックをカバーしているコンビニはないものとして考えます。番号4のコンビニがカバーしているブロック数は5となります。
ここで、デブンイレブンが座標(1, 3)と座標(5, 3)を新店舗の候補地として考えているとします。座標(1, 3)に店舗を構えた場合、カバーできるブロック数は3となります(図4)。一方、座標(5, 3)に店舗を構えた場合にカバーできるブロック数は4となります(図5)。したがって、最も広くカバーできるブロック数は4となります。
地図情報
m × n
、既設のコンビニの数
s
とその座標(
x, y
)、候補地の数
t
とその座標(
p, q
)を入力とし、全候補地の中で最も広くカバーできるブロック数を出力するプログラムを作成してください。
Input
複数のデータセットの並びが入力として与えられます。入力の終わりはゼロふたつの行で示されます。 各データセットは以下の形式で与えられます。
m
n
s
x
1
y
1
x
2
y
2
:
x
s
y
s
t
p
1
q
1
p
2
q
2
:
p
t
q
t
1 行目に区分した地図の大きさ(横、縦)を表す整数
m
,
n
(2 ≤
m, n
≤ 100) が与えられます。
2行目に既設のコンビニの数
s
(1 ≤
s
≤ 10) が与えられます。続く
s
行に、
i
個目の既設のコンビニの座標
x
i
,
y
1
が与えられます。
続く行に、新店舗の候補地の数
t
(1 ≤
t
≤ 10 ) が与えられます。続く
t
行に、
i
個目の候補地の座標
p
i
,
q
i
が与えられます。
データセットの数は 20 を超えません。
Output
データセット毎に、全候補地の中で最も広くカバーできるブロック数を１行に出力します。
Sample Input
6 6
6  
1 1
6 1
3 2
3 5
1 6
5 6
2
1 3
5 3
6 6
6
3 2
3 5
6 1
1 1
1 6
5 6
2
2 3
5 3
0 0
Output for the Sample Input
4
4",Java,"import java.util.*;

public class Main {
    static int m, n;
    static int[][] dirs = {{1, 0}, {-1, 0}, {0, 1}, {0, -1}, {1, -1}, {-1, 1}};
    
    static int[][] getNeighbors(int x, int y) {
        int[][] neighbors = new int[6][2];
        if (y % 2 == 1) {
            neighbors[0] = new int[]{x + 1, y};
            neighbors[1] = new int[]{x - 1, y};
            neighbors[2] = new int[]{x, y + 1};
            neighbors[3] = new int[]{x, y - 1};
            neighbors[4] = new int[]{x - 1, y + 1};
            neighbors[5] = new int[]{x - 1, y - 1};
        } else {
            neighbors[0] = new int[]{x + 1, y};
            neighbors[1] = new int[]{x - 1, y};
            neighbors[2] = new int[]{x + 1, y + 1};
            neighbors[3] = new int[]{x + 1, y - 1};
            neighbors[4] = new int[]{x, y + 1};
            neighbors[5] = new int[]{x, y - 1};
        }
        return neighbors;
    }
    
    static int[][] computeDistances(int sx, int sy) {
        int[][] dist = new int[m + 1][n + 1];
        for (int i = 0; i <= m; i++) {
            Arrays.fill(dist[i], -1);
        }
        
        Queue<int[]> queue = new LinkedList<>();
        queue.offer(new int[]{sx, sy, 0});
        dist[sx][sy] = 0;
        
        while (!queue.isEmpty()) {
            int[] curr = queue.poll();
            int x = curr[0];
            int y = curr[1];
            int d = curr[2];
            
            int[][] neighbors = getNeighbors(x, y);
            for (int[] neighbor : neighbors) {
                int nx = neighbor[0];
                int ny = neighbor[1];
                if (nx >= 1 && nx <= m && ny >= 1 && ny <= n && dist[nx][ny] == -1) {
                    dist[nx][ny] = d + 1;
                    queue.offer(new int[]{nx, ny, d + 1});
                }
            }
        }
        
        return dist;
    }
    
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        
        while (true) {
            m = sc.nextInt();
            n = sc.nextInt();
            if (m == 0 && n == 0) break;
            
            int s = sc.nextInt();
            int[][] existing = new int[s][2];
            for (int i = 0; i < s; i++) {
                existing[i][0] = sc.nextInt();
                existing[i][1] = sc.nextInt();
            }
            
            int t = sc.nextInt();
            int[][] candidates = new int[t][2];
            for (int i = 0; i < t; i++) {
                candidates[i][0] = sc.nextInt();
                candidates[i][1] = sc.nextInt();
            }
            
            int[][][] existingDist = new int[s][][];
            for (int i = 0; i < s; i++) {
                existingDist[i] = computeDistances(existing[i][0], existing[i][1]);
            }
            
            int maxCoverage = 0;
            
            for (int c = 0; c < t; c++) {
                int[][] newDist = computeDistances(candidates[c][0], candidates[c][1]);
                int coverage = 0;
                
                for (int x = 1; x <= m; x++) {
                    for (int y = 1; y <= n; y++) {
                        boolean isExisting = false;
                        for (int i = 0; i < s; i++) {
                            if (existing[i][0] == x && existing[i][1] == y) {
                                isExisting = true;
                                break;
                            }
                        }
                        if (isExisting) continue;
                        
                        if (candidates[c][0] == x && candidates[c][1] == y) continue;
                        
                        int minDist = newDist[x][y];
                        if (minDist == -1) continue;
                        
                        boolean uniqueMin = true;
                        for (int i = 0; i < s; i++) {
                            int d = existingDist[i][x][y];
                            if (d == -1) continue;
                            if (d < minDist) {
                                uniqueMin = false;
                                break;
                            } else if (d == minDist) {
                                uniqueMin = false;
                                break;
                            }
                        }
                        
                        if (uniqueMin) {
                            coverage++;
                        }
                    }
                }
                
                maxCoverage = Math.max(maxCoverage, coverage);
            }
            
            System.out.println(maxCoverage);
        }
        
        sc.close();
    }
}
",0
p00193,"コンビニ
コンビニエンスストア・デブンイレブンは事業を広げるため若松市に一店舗目をオープンしようと考えています。若松市には既に他のたくさんのコンビニエンスストアがあるので、新店舗をオープンする場所が成功の鍵を握ることになりそうです。デブンイレブンは「お客さんは自分の住んでいる地域から最も近いコンビニを利用する」という前提の下、「多くのお客さんが利用するであろう地点」に出店することにしています。
デブンイレブンは、既設の各コンビニがカバーしている範囲を把握するため、若松市の地図を合同な正六角形(以後「ブロック」)を用いて区分しました。このとき、各ブロックには既設のコンビニが多くとも一つだけ入るように区分しました。この地図上で、各ブロックからあるコンビニへ行くのに経由するブロックの数をもとにコンビニとの距離を求めます。各ブロックはこの距離が最も小さいコンビニによってカバーされていると考えます。問題は、この地図をもとに「できるだけ多くのブロックをカバーする既設のコンビニがないブロック」を探すことです。
デブンイレブンのプログラマであるあなたは、ブロック分けされた地図情報と新店舗の候補地の情報から、最も広くカバーできるブロック数を計算するプログラムを開発することになりました。
m × n
に区分した地図は図1のように表します。六角形のブロックが横に
m
個、縦に
n
個並び、それぞれは一つの座標(
x, y
)で示されます。奇数行の左端はその上の行の左端の左下に、偶数行の左端はその上の行の左端の右下に、それぞれ位置します。例えば、座標(1, 1)は図1の一番左上のブロックを示します。また、座標(1, 2)は座標(1, 1)の右下に位置し、座標(1, 3)は座標(1, 2)の左下に位置します。
図2は既設のコンビニが6個あった場合の例で、6 × 6 に区分されています。各コンビニは1から順に番号が振られています。このとき、各コンビニがカバーするブロックを番号毎に塗り分けると図3のようになります。座標(1, 4)や(2, 5)のように塗られていないブロックは最も近いコンビニが二つ以上あり、どちらとも判断がつかないブロックになっています。例えば、座標(1, 4)のブロックの場合、番号4のコンビニと番号5のコンビニへの距離が等しく、このブロックをカバーしているコンビニはないものとして考えます。番号4のコンビニがカバーしているブロック数は5となります。
ここで、デブンイレブンが座標(1, 3)と座標(5, 3)を新店舗の候補地として考えているとします。座標(1, 3)に店舗を構えた場合、カバーできるブロック数は3となります(図4)。一方、座標(5, 3)に店舗を構えた場合にカバーできるブロック数は4となります(図5)。したがって、最も広くカバーできるブロック数は4となります。
地図情報
m × n
、既設のコンビニの数
s
とその座標(
x, y
)、候補地の数
t
とその座標(
p, q
)を入力とし、全候補地の中で最も広くカバーできるブロック数を出力するプログラムを作成してください。
Input
複数のデータセットの並びが入力として与えられます。入力の終わりはゼロふたつの行で示されます。 各データセットは以下の形式で与えられます。
m
n
s
x
1
y
1
x
2
y
2
:
x
s
y
s
t
p
1
q
1
p
2
q
2
:
p
t
q
t
1 行目に区分した地図の大きさ(横、縦)を表す整数
m
,
n
(2 ≤
m, n
≤ 100) が与えられます。
2行目に既設のコンビニの数
s
(1 ≤
s
≤ 10) が与えられます。続く
s
行に、
i
個目の既設のコンビニの座標
x
i
,
y
1
が与えられます。
続く行に、新店舗の候補地の数
t
(1 ≤
t
≤ 10 ) が与えられます。続く
t
行に、
i
個目の候補地の座標
p
i
,
q
i
が与えられます。
データセットの数は 20 を超えません。
Output
データセット毎に、全候補地の中で最も広くカバーできるブロック数を１行に出力します。
Sample Input
6 6
6  
1 1
6 1
3 2
3 5
1 6
5 6
2
1 3
5 3
6 6
6
3 2
3 5
6 1
1 1
1 6
5 6
2
2 3
5 3
0 0
Output for the Sample Input
4
4",Java,"import java.util.*;

public class Main {
	public static void main(String[] args) {
		Scanner s=new Scanner(System.in);
		for(int m,n,x,a[][];(m=s.nextInt())>0;){
			n=s.nextInt();
			x=s.nextInt();
			a=new int[n][m];
			Deque<int[]>q=new ArrayDeque<int[]>();
			for(int i=0;i<x;++i){
				int v=s.nextInt()-1,u=s.nextInt()-1;
				a[u][v]=1;
				q.add(new int[]{u,v,1});
			}
			int[][]dm={{-1,-1,-1,0,0,1},{-1,0,0,1,1,1}};
			int[][]dn={{-1,0,1,-1,1,0},{0,-1,1,-1,0,1}};
			while(!q.isEmpty()){
				int[]t=q.poll();
				for(int i=0;i<6;++i){
					int u=t[0]+dn[t[0]%2][i],v=t[1]+dm[t[0]%2][i];
					if(0<=u&&u<n&&0<=v&&v<m&&a[u][v]<1){
						q.add(new int[]{u,v,a[u][v]=t[2]+1});
					}
				}
			}
			int r=0;
			for(x=s.nextInt();x-->0;){
				int v=s.nextInt()-1,u=s.nextInt()-1;
				if(a[u][v]>1){
					int[][] tmp = new int[n][];
					for(int i=0;i<n;++i)
						tmp[i]=Arrays.copyOf(a[i],m);
				q.add(new int[]{u,v,1});
				int c=1;
				while(!q.isEmpty()){
					int[]t=q.poll();
					for(int i=0;i<6;++i){
						int u1=t[0]+dn[t[0]%2][i],v1=t[1]+dm[t[0]%2][i];
						if(0<=u1&&u1<n&&0<=v1&&v1<m&&tmp[u1][v1]>t[2]+1){
							++c;
							q.add(new int[]{u1,v1,tmp[u1][v1]=t[2]+1});
						}
					}
				}
				r=r>c?r:c;
				}
			}
			System.out.println(r);
		}
	}
}",1
p00193,"コンビニ
コンビニエンスストア・デブンイレブンは事業を広げるため若松市に一店舗目をオープンしようと考えています。若松市には既に他のたくさんのコンビニエンスストアがあるので、新店舗をオープンする場所が成功の鍵を握ることになりそうです。デブンイレブンは「お客さんは自分の住んでいる地域から最も近いコンビニを利用する」という前提の下、「多くのお客さんが利用するであろう地点」に出店することにしています。
デブンイレブンは、既設の各コンビニがカバーしている範囲を把握するため、若松市の地図を合同な正六角形(以後「ブロック」)を用いて区分しました。このとき、各ブロックには既設のコンビニが多くとも一つだけ入るように区分しました。この地図上で、各ブロックからあるコンビニへ行くのに経由するブロックの数をもとにコンビニとの距離を求めます。各ブロックはこの距離が最も小さいコンビニによってカバーされていると考えます。問題は、この地図をもとに「できるだけ多くのブロックをカバーする既設のコンビニがないブロック」を探すことです。
デブンイレブンのプログラマであるあなたは、ブロック分けされた地図情報と新店舗の候補地の情報から、最も広くカバーできるブロック数を計算するプログラムを開発することになりました。
m × n
に区分した地図は図1のように表します。六角形のブロックが横に
m
個、縦に
n
個並び、それぞれは一つの座標(
x, y
)で示されます。奇数行の左端はその上の行の左端の左下に、偶数行の左端はその上の行の左端の右下に、それぞれ位置します。例えば、座標(1, 1)は図1の一番左上のブロックを示します。また、座標(1, 2)は座標(1, 1)の右下に位置し、座標(1, 3)は座標(1, 2)の左下に位置します。
図2は既設のコンビニが6個あった場合の例で、6 × 6 に区分されています。各コンビニは1から順に番号が振られています。このとき、各コンビニがカバーするブロックを番号毎に塗り分けると図3のようになります。座標(1, 4)や(2, 5)のように塗られていないブロックは最も近いコンビニが二つ以上あり、どちらとも判断がつかないブロックになっています。例えば、座標(1, 4)のブロックの場合、番号4のコンビニと番号5のコンビニへの距離が等しく、このブロックをカバーしているコンビニはないものとして考えます。番号4のコンビニがカバーしているブロック数は5となります。
ここで、デブンイレブンが座標(1, 3)と座標(5, 3)を新店舗の候補地として考えているとします。座標(1, 3)に店舗を構えた場合、カバーできるブロック数は3となります(図4)。一方、座標(5, 3)に店舗を構えた場合にカバーできるブロック数は4となります(図5)。したがって、最も広くカバーできるブロック数は4となります。
地図情報
m × n
、既設のコンビニの数
s
とその座標(
x, y
)、候補地の数
t
とその座標(
p, q
)を入力とし、全候補地の中で最も広くカバーできるブロック数を出力するプログラムを作成してください。
Input
複数のデータセットの並びが入力として与えられます。入力の終わりはゼロふたつの行で示されます。 各データセットは以下の形式で与えられます。
m
n
s
x
1
y
1
x
2
y
2
:
x
s
y
s
t
p
1
q
1
p
2
q
2
:
p
t
q
t
1 行目に区分した地図の大きさ(横、縦)を表す整数
m
,
n
(2 ≤
m, n
≤ 100) が与えられます。
2行目に既設のコンビニの数
s
(1 ≤
s
≤ 10) が与えられます。続く
s
行に、
i
個目の既設のコンビニの座標
x
i
,
y
1
が与えられます。
続く行に、新店舗の候補地の数
t
(1 ≤
t
≤ 10 ) が与えられます。続く
t
行に、
i
個目の候補地の座標
p
i
,
q
i
が与えられます。
データセットの数は 20 を超えません。
Output
データセット毎に、全候補地の中で最も広くカバーできるブロック数を１行に出力します。
Sample Input
6 6
6  
1 1
6 1
3 2
3 5
1 6
5 6
2
1 3
5 3
6 6
6
3 2
3 5
6 1
1 1
1 6
5 6
2
2 3
5 3
0 0
Output for the Sample Input
4
4",Python,"from collections import deque

def get_neighbors(x, y, m, n):
    neighbors = []
    if y % 2 == 1:  # odd row
        # neighbors for odd row
        candidates = [
            (x-1, y-1), (x, y-1),    # upper left, upper right
            (x-1, y), (x+1, y),       # left, right
            (x-1, y+1), (x, y+1)      # lower left, lower right
        ]
    else:  # even row
        # neighbors for even row
        candidates = [
            (x, y-1), (x+1, y-1),     # upper left, upper right
            (x-1, y), (x+1, y),       # left, right
            (x, y+1), (x+1, y+1)      # lower left, lower right
        ]
    
    for nx, ny in candidates:
        if 1 <= nx <= m and 1 <= ny <= n:
            neighbors.append((nx, ny))
    
    return neighbors

def bfs_distances(start_x, start_y, m, n):
    distances = {}
    queue = deque([(start_x, start_y, 0)])
    distances[(start_x, start_y)] = 0
    
    while queue:
        x, y, dist = queue.popleft()
        
        for nx, ny in get_neighbors(x, y, m, n):
            if (nx, ny) not in distances:
                distances[(nx, ny)] = dist + 1
                queue.append((nx, ny, dist + 1))
    
    return distances

def count_covered_blocks(stores, m, n):
    # For each block, find the minimum distance to any store
    min_distances = {}
    
    for i, (sx, sy) in enumerate(stores):
        distances = bfs_distances(sx, sy, m, n)
        for (x, y), dist in distances.items():
            if (x, y) not in min_distances:
                min_distances[(x, y)] = []
            min_distances[(x, y)].append((dist, i))
    
    # Count blocks covered by each store
    coverage = [0] * len(stores)
    
    for (x, y), dists in min_distances.items():
        dists.sort()
        if len(dists) > 0:
            min_dist = dists[0][0]
            stores_at_min_dist = [store_idx for dist, store_idx in dists if dist == min_dist]
            
            # Only count if exactly one store is closest
            if len(stores_at_min_dist) == 1:
                coverage[stores_at_min_dist[0]] += 1
    
    return coverage

while True:
    m, n = map(int, input().split())
    if m == 0 and n == 0:
        break
    
    s = int(input())
    existing_stores = []
    for _ in range(s):
        x, y = map(int, input().split())
        existing_stores.append((x, y))
    
    t = int(input())
    candidates = []
    for _ in range(t):
        p, q = map(int, input().split())
        candidates.append((p, q))
    
    max_coverage = 0
    
    for candidate in candidates:
        # Create a list of all stores including the new one
        all_stores = existing_stores + [candidate]
        
        # Count coverage for all stores
        coverage = count_covered_blocks(all_stores, m, n)
        
        # The last store in the list is the new one
        new_store_coverage = coverage[-1]
        
        max_coverage = max(max_coverage, new_store_coverage)
    
    print(max_coverage)
",0
p00193,"コンビニ
コンビニエンスストア・デブンイレブンは事業を広げるため若松市に一店舗目をオープンしようと考えています。若松市には既に他のたくさんのコンビニエンスストアがあるので、新店舗をオープンする場所が成功の鍵を握ることになりそうです。デブンイレブンは「お客さんは自分の住んでいる地域から最も近いコンビニを利用する」という前提の下、「多くのお客さんが利用するであろう地点」に出店することにしています。
デブンイレブンは、既設の各コンビニがカバーしている範囲を把握するため、若松市の地図を合同な正六角形(以後「ブロック」)を用いて区分しました。このとき、各ブロックには既設のコンビニが多くとも一つだけ入るように区分しました。この地図上で、各ブロックからあるコンビニへ行くのに経由するブロックの数をもとにコンビニとの距離を求めます。各ブロックはこの距離が最も小さいコンビニによってカバーされていると考えます。問題は、この地図をもとに「できるだけ多くのブロックをカバーする既設のコンビニがないブロック」を探すことです。
デブンイレブンのプログラマであるあなたは、ブロック分けされた地図情報と新店舗の候補地の情報から、最も広くカバーできるブロック数を計算するプログラムを開発することになりました。
m × n
に区分した地図は図1のように表します。六角形のブロックが横に
m
個、縦に
n
個並び、それぞれは一つの座標(
x, y
)で示されます。奇数行の左端はその上の行の左端の左下に、偶数行の左端はその上の行の左端の右下に、それぞれ位置します。例えば、座標(1, 1)は図1の一番左上のブロックを示します。また、座標(1, 2)は座標(1, 1)の右下に位置し、座標(1, 3)は座標(1, 2)の左下に位置します。
図2は既設のコンビニが6個あった場合の例で、6 × 6 に区分されています。各コンビニは1から順に番号が振られています。このとき、各コンビニがカバーするブロックを番号毎に塗り分けると図3のようになります。座標(1, 4)や(2, 5)のように塗られていないブロックは最も近いコンビニが二つ以上あり、どちらとも判断がつかないブロックになっています。例えば、座標(1, 4)のブロックの場合、番号4のコンビニと番号5のコンビニへの距離が等しく、このブロックをカバーしているコンビニはないものとして考えます。番号4のコンビニがカバーしているブロック数は5となります。
ここで、デブンイレブンが座標(1, 3)と座標(5, 3)を新店舗の候補地として考えているとします。座標(1, 3)に店舗を構えた場合、カバーできるブロック数は3となります(図4)。一方、座標(5, 3)に店舗を構えた場合にカバーできるブロック数は4となります(図5)。したがって、最も広くカバーできるブロック数は4となります。
地図情報
m × n
、既設のコンビニの数
s
とその座標(
x, y
)、候補地の数
t
とその座標(
p, q
)を入力とし、全候補地の中で最も広くカバーできるブロック数を出力するプログラムを作成してください。
Input
複数のデータセットの並びが入力として与えられます。入力の終わりはゼロふたつの行で示されます。 各データセットは以下の形式で与えられます。
m
n
s
x
1
y
1
x
2
y
2
:
x
s
y
s
t
p
1
q
1
p
2
q
2
:
p
t
q
t
1 行目に区分した地図の大きさ(横、縦)を表す整数
m
,
n
(2 ≤
m, n
≤ 100) が与えられます。
2行目に既設のコンビニの数
s
(1 ≤
s
≤ 10) が与えられます。続く
s
行に、
i
個目の既設のコンビニの座標
x
i
,
y
1
が与えられます。
続く行に、新店舗の候補地の数
t
(1 ≤
t
≤ 10 ) が与えられます。続く
t
行に、
i
個目の候補地の座標
p
i
,
q
i
が与えられます。
データセットの数は 20 を超えません。
Output
データセット毎に、全候補地の中で最も広くカバーできるブロック数を１行に出力します。
Sample Input
6 6
6  
1 1
6 1
3 2
3 5
1 6
5 6
2
1 3
5 3
6 6
6
3 2
3 5
6 1
1 1
1 6
5 6
2
2 3
5 3
0 0
Output for the Sample Input
4
4",Python,"#Deven-Eleven:
import re
D = (((-1, -1), (0, -1), (1, 0), (0, 1), (-1, 1), (-1, 0)),
     ((0, -1), (1, -1), (1, 0), (1, 1), (0, 1), (-1, 0)))
def func(y, x):
    q = [(y, x, 0)]
    cover = [[-1] * m for _ in xrange(n)]
    while len(q) != 0:
        y, x, step = q.pop(0)
        if cover[y][x] >= 0:
            continue
        cover[y][x] = step
        for dx, dy in D[y % 2]:           
            ny, nx = y + dy, x + dx
            if 0 <= ny < n and 0 <= nx < m:
                q.append((ny, nx, step + 1))
    return cover
 
def solve():
    scover = [func(pos[1] - 1, pos[0] - 1) for pos in spos]
    min_cover = [[min(sc[y][x] for sc in scover) for x in xrange(m)] for y in xrange(n)]
    def count(cover):
        ret = 0
        for y in xrange(n):
            for x in xrange(m):
                if cover[y][x] < min_cover[y][x]:
                    ret += 1
        return ret
    return max(count(func(pos[1] - 1, pos[0] - 1)) for pos in tpos)

while True:
    data = raw_input().sprit()
    if data == ""0 0"":
        break
    m, n = map(int, data.split())
    s = input()
    spos = [map(int, raw_input().split()) for _ in xrange(s)]
    t = input()
    tpos = [map(int, raw_input().split()) for _ in xrange(t)]
    print solve()",1
p00194,"運送会社
白虎運送は会津若松市を代表する運送会社です。昨今の原油価格の高騰は運送会社にも多大なダメージを与え、運送会社各社では、できるだけ少ないガソリンで荷物を運ぶことが課題となっています。
白虎運送では、重い荷物を積んだトラックは、その走りだしに多くのエネルギーを必要とすることに着目しました。トラックが倉庫を出発してから一度も停止することなく目的地まで到達する経路の中で最短時間の経路を通ることで、ガソリンの節約ができると考えました。
あなたの仕事は、このような最短経路を計算できるカーナビを開発することです。作成するカーナビ用プログラムの仕様は以下のとおりです。
市内は、下図のように、東西方向の道路
M
本、南北方向の道路
N
本 からなる格子で表し、格子の各交点は交差点を表します。
交差点のいくつかには東西 - 南北の方向に信号機が設置されており、一定の周期で青、赤のシグナルが点灯しています。
市内の交差点間を結ぶ道路には工事中で通過できない個所がいくつかあります。
トラックが交差点から交差点へ移動するのに必要な時間は一定ですが、渋滞している道路ではさらに長い時間がかかります。
市内の道路情報、トラックが交差点間を移動するのに必要な時間、信号機がある交差点と各信号機の周期、工事中の道路、渋滞している道路と渋滞度、白虎運送の倉庫(始点)と目的地(終点)の位置を入力とし、始点から終点までの最短の時間を出力するプログラムを作成して下さい。
図のように、東西の方向の道路はa、b、c、... と英小文字で名前が付けられ 、南北の方向の道路は 1、2、3、... と整数で名前が付けられています。市内の交差点は、これらの英小文字と整数の組み合わせ
H
-
V
で指定されます。
例えば、市内の最北西の交差点は a-1 で指定されます。各信号は周期
k
をもち、
k
分ごとに切り替わります。東西が青ならば南北が赤で、南北が青ならば東西が赤です。黄色のシグナルは存在しません。トラックは二つの交差点を結ぶ道路を移動するのに
D
分要しますが、その道路が渋滞している場合はさらに
d
分の時間を要します。トラックは道路が工事中の場合は移動できません。
また、交差点に到達した時刻に、信号が赤の場合には進入できません。トラックは交差点でのみ、東、西、南、北に方向を変えることができますが、来た方向へは移動(Uターン)できません。道路は2方通行であり、トラックが行き来する時間、工事状況、渋滞度は2方向共通です。
初期状態として、トラックは東を向いていて、トラックが倉庫を出発する瞬間すべての信号機が南北の方向に青に切り替わるものとします。また、トラックは 100分以内で目的地に到達できるものとします。
Input
複数のデータセットの並びが入力として与えられます。入力の終わりはゼロふたつの行で示されます。各データセットは以下の形式で与えられます。
M
N
D
ns
H
1
-
V
1
k
1
H
2
-
V
2
k
2
:
H
ns
-
V
ns
k
ns
nc
H
11
-
V
11
H
12
-
V
12
H
21
-
V
21
H
22
-
V
22
:
H
nc1
-
V
nc1
H
nc2
-
V
nc2
nj
H
11
-
V
11
H
12
-
V
12
d
1
H
21
-
V
21
H
22
-
V
22
d
2
:
H
nj1
-
V
nj1
H
nj2
-
V
nj2
d
nj
H
s
-
V
s
H
d
-
V
d
１行目に道路の本数
M
,
N
(2 ≤
M, N
≤ 20) が与えられます。２行目に、二つの交差点を結ぶ道路を移動するのに要する時間
D
(1 ≤
D
≤ D, 整数) が与えられます。
３行目に信号機の数
ns
が与えられます。続く
ns
行に、
i
個目の信号機の位置を表す英小文字と整数の組
H
i
-
V
i
と周期
k
(1 ≤
k
≤ 100) が与えられます。
続く行に、工事中の道路の数
nc
が与えられます。続く
nc
行に、
i
個目の工事中の道路の２つの端点（交差点）を表す英小文字と整数の組
H
i1
-
V
i1
H
i2
-
V
i2
が与えられます。
続く行に、渋滞道路の数
nj
が与えられます。続く
nj
行に、
i
個目の渋滞道路の２つの端点（交差点）を表す英小文字と整数の組
H
i1
-
V
i1
H
i2
-
V
i2
と時間
d
i
(1 ≤
d
i
≤ 100) が与えられます。
最後の行に、始点の交差点
H
s
-
V
d
と終点の交差点
H
d
-
V
d
が与えられます。
データセットの数は 20 を超えません。
Output
データセット毎に最短時間を１行に出力します。
Sample Input
4 5
1
3
b-2 3
c-3 2
c-4 1
3
a-2 b-2
b-3 c-3
d-3 d-4
2
b-3 b-4 1
c-1 d-1 1
d-1 b-4
4 5
1
3
b-2 3
c-3 2
c-4 1
3
a-2 b-2
b-3 c-3
d-3 d-4
2
b-3 b-4 1
c-1 d-1 1
d-2 b-4
4 5
1
3
b-2 3
c-3 2
c-4 1
3
a-2 b-2
b-3 c-3
d-3 d-4
2
b-3 b-4 1
c-1 d-1 1
d-3 b-4
0 0
Output for the Sample Input
7
4
8",C,"#include <stdio.h>
#include <string.h>
#include <stdlib.h>

#define MAX_N 20
#define INF 1000000

typedef struct {
    int r, c, time, dir;
} State;

int M, N, D;
int signal[MAX_N][MAX_N];
int period[MAX_N][MAX_N];
int construction[MAX_N][MAX_N][MAX_N][MAX_N];
int traffic[MAX_N][MAX_N][MAX_N][MAX_N];
int visited[MAX_N][MAX_N][101][4];

State queue[1000000];
int head, tail;

int dr[] = {0, 0, -1, 1};
int dc[] = {-1, 1, 0, 0};

void parseIntersection(char *s, int *r, int *c) {
    char h[10];
    int v;
    sscanf(s, ""%[^-]-%d"", h, &v);
    *r = h[0] - 'a';
    *c = v - 1;
}

int canPass(int r, int c, int time, int from_dir, int to_dir) {
    if (signal[r][c] == 0) return 1;
    
    int k = period[r][c];
    int cycle = time % (2 * k);
    int is_ns_green = (cycle < k);
    
    if (to_dir == 2 || to_dir == 3) {
        return is_ns_green;
    } else {
        return !is_ns_green;
    }
}

int solve(int sr, int sc, int er, int ec) {
    memset(visited, 0, sizeof(visited));
    
    head = tail = 0;
    queue[tail].r = sr;
    queue[tail].c = sc;
    queue[tail].time = 0;
    queue[tail].dir = 1;
    tail++;
    visited[sr][sc][0][1] = 1;
    
    while (head < tail) {
        State cur = queue[head++];
        
        if (cur.r == er && cur.c == ec) {
            return cur.time;
        }
        
        if (cur.time >= 100) continue;
        
        for (int d = 0; d < 4; d++) {
            if (d == (cur.dir ^ 1)) continue;
            
            int nr = cur.r + dr[d];
            int nc = cur.c + dc[d];
            
            if (nr < 0 || nr >= M || nc < 0 || nc >= N) continue;
            if (construction[cur.r][cur.c][nr][nc]) continue;
            
            if (!canPass(cur.r, cur.c, cur.time, cur.dir, d)) continue;
            
            int next_time = cur.time + D + traffic[cur.r][cur.c][nr][nc];
            
            if (next_time > 100) continue;
            if (visited[nr][nc][next_time][d]) continue;
            
            visited[nr][nc][next_time][d] = 1;
            queue[tail].r = nr;
            queue[tail].c = nc;
            queue[tail].time = next_time;
            queue[tail].dir = d;
            tail++;
        }
    }
    
    return -1;
}

int main() {
    while (1) {
        scanf(""%d %d"", &M, &N);
        if (M == 0 && N == 0) break;
        
        scanf(""%d"", &D);
        
        memset(signal, 0, sizeof(signal));
        memset(period, 0, sizeof(period));
        memset(construction, 0, sizeof(construction));
        memset(traffic, 0, sizeof(traffic));
        
        int ns;
        scanf(""%d"", &ns);
        for (int i = 0; i < ns; i++) {
            char s[20];
            int k, r, c;
            scanf(""%s %d"", s, &k);
            parseIntersection(s, &r, &c);
            signal[r][c] = 1;
            period[r][c] = k;
        }
        
        int nc;
        scanf(""%d"", &nc);
        for (int i = 0; i < nc; i++) {
            char s1[20], s2[20];
            int r1, c1, r2, c2;
            scanf(""%s %s"", s1, s2);
            parseIntersection(s1, &r1, &c1);
            parseIntersection(s2, &r2, &c2);
            construction[r1][c1][r2][c2] = 1;
            construction[r2][c2][r1][c1] = 1;
        }
        
        int nj;
        scanf(""%d"", &nj);
        for (int i = 0; i < nj; i++) {
            char s1[20], s2[20];
            int r1, c1, r2, c2, d;
            scanf(""%s %s %d"", s1, s2, &d);
            parseIntersection(s1, &r1, &c1);
            parseIntersection(s2, &r2, &c2);
            traffic[r1][c1][r2][c2] = d;
            traffic[r2][c2][r1][c1] = d;
        }
        
        char start[20], end[20];
        int sr, sc, er, ec;
        scanf(""%s %s"", start, end);
        parseIntersection(start, &sr, &sc);
        parseIntersection(end, &er, &ec);
        
        int result = solve(sr, sc, er, ec);
        printf(""%d\n"", result);
    }
    
    return 0;
}
",0
p00194,"運送会社
白虎運送は会津若松市を代表する運送会社です。昨今の原油価格の高騰は運送会社にも多大なダメージを与え、運送会社各社では、できるだけ少ないガソリンで荷物を運ぶことが課題となっています。
白虎運送では、重い荷物を積んだトラックは、その走りだしに多くのエネルギーを必要とすることに着目しました。トラックが倉庫を出発してから一度も停止することなく目的地まで到達する経路の中で最短時間の経路を通ることで、ガソリンの節約ができると考えました。
あなたの仕事は、このような最短経路を計算できるカーナビを開発することです。作成するカーナビ用プログラムの仕様は以下のとおりです。
市内は、下図のように、東西方向の道路
M
本、南北方向の道路
N
本 からなる格子で表し、格子の各交点は交差点を表します。
交差点のいくつかには東西 - 南北の方向に信号機が設置されており、一定の周期で青、赤のシグナルが点灯しています。
市内の交差点間を結ぶ道路には工事中で通過できない個所がいくつかあります。
トラックが交差点から交差点へ移動するのに必要な時間は一定ですが、渋滞している道路ではさらに長い時間がかかります。
市内の道路情報、トラックが交差点間を移動するのに必要な時間、信号機がある交差点と各信号機の周期、工事中の道路、渋滞している道路と渋滞度、白虎運送の倉庫(始点)と目的地(終点)の位置を入力とし、始点から終点までの最短の時間を出力するプログラムを作成して下さい。
図のように、東西の方向の道路はa、b、c、... と英小文字で名前が付けられ 、南北の方向の道路は 1、2、3、... と整数で名前が付けられています。市内の交差点は、これらの英小文字と整数の組み合わせ
H
-
V
で指定されます。
例えば、市内の最北西の交差点は a-1 で指定されます。各信号は周期
k
をもち、
k
分ごとに切り替わります。東西が青ならば南北が赤で、南北が青ならば東西が赤です。黄色のシグナルは存在しません。トラックは二つの交差点を結ぶ道路を移動するのに
D
分要しますが、その道路が渋滞している場合はさらに
d
分の時間を要します。トラックは道路が工事中の場合は移動できません。
また、交差点に到達した時刻に、信号が赤の場合には進入できません。トラックは交差点でのみ、東、西、南、北に方向を変えることができますが、来た方向へは移動(Uターン)できません。道路は2方通行であり、トラックが行き来する時間、工事状況、渋滞度は2方向共通です。
初期状態として、トラックは東を向いていて、トラックが倉庫を出発する瞬間すべての信号機が南北の方向に青に切り替わるものとします。また、トラックは 100分以内で目的地に到達できるものとします。
Input
複数のデータセットの並びが入力として与えられます。入力の終わりはゼロふたつの行で示されます。各データセットは以下の形式で与えられます。
M
N
D
ns
H
1
-
V
1
k
1
H
2
-
V
2
k
2
:
H
ns
-
V
ns
k
ns
nc
H
11
-
V
11
H
12
-
V
12
H
21
-
V
21
H
22
-
V
22
:
H
nc1
-
V
nc1
H
nc2
-
V
nc2
nj
H
11
-
V
11
H
12
-
V
12
d
1
H
21
-
V
21
H
22
-
V
22
d
2
:
H
nj1
-
V
nj1
H
nj2
-
V
nj2
d
nj
H
s
-
V
s
H
d
-
V
d
１行目に道路の本数
M
,
N
(2 ≤
M, N
≤ 20) が与えられます。２行目に、二つの交差点を結ぶ道路を移動するのに要する時間
D
(1 ≤
D
≤ D, 整数) が与えられます。
３行目に信号機の数
ns
が与えられます。続く
ns
行に、
i
個目の信号機の位置を表す英小文字と整数の組
H
i
-
V
i
と周期
k
(1 ≤
k
≤ 100) が与えられます。
続く行に、工事中の道路の数
nc
が与えられます。続く
nc
行に、
i
個目の工事中の道路の２つの端点（交差点）を表す英小文字と整数の組
H
i1
-
V
i1
H
i2
-
V
i2
が与えられます。
続く行に、渋滞道路の数
nj
が与えられます。続く
nj
行に、
i
個目の渋滞道路の２つの端点（交差点）を表す英小文字と整数の組
H
i1
-
V
i1
H
i2
-
V
i2
と時間
d
i
(1 ≤
d
i
≤ 100) が与えられます。
最後の行に、始点の交差点
H
s
-
V
d
と終点の交差点
H
d
-
V
d
が与えられます。
データセットの数は 20 を超えません。
Output
データセット毎に最短時間を１行に出力します。
Sample Input
4 5
1
3
b-2 3
c-3 2
c-4 1
3
a-2 b-2
b-3 c-3
d-3 d-4
2
b-3 b-4 1
c-1 d-1 1
d-1 b-4
4 5
1
3
b-2 3
c-3 2
c-4 1
3
a-2 b-2
b-3 c-3
d-3 d-4
2
b-3 b-4 1
c-1 d-1 1
d-2 b-4
4 5
1
3
b-2 3
c-3 2
c-4 1
3
a-2 b-2
b-3 c-3
d-3 d-4
2
b-3 b-4 1
c-1 d-1 1
d-3 b-4
0 0
Output for the Sample Input
7
4
8",C,"M,N,D;P[101][4][21][21];S[21][21];C[4][21][21];J[4][21][21];h1,h2;i,n,v1,v2,k;xs,ys,xg,yg,T;d,x,y,d1,t1,x1,y1;vx[]={1,0,-1,0},vy[]={0,1,0,-1};void set_road(int A[][21][21],int h1,int v1,int h2,int v2,int d){if(v1==v2){A[h1<h2?1:3][v1][h1-96]=d;A[h1<h2?3:1][v2][h2-96]=d;}else{A[v1<v2?0:2][v1][h1-96]=d;A[v1<v2?2:0][v2][h2-96]=d;}}main(){for(;scanf(""%d%d%d%d"",&M,&N,&D,&n),M;){memset(P,0,sizeof(P));memset(S,0,sizeof(S));memset(C,0,sizeof(C));memset(J,0,sizeof(J));for(i=0;i<n;i++){scanf(""\n%c-%d%d"",&h1,&v1,&k);S[v1][h1-96]=k;}scanf(""%d"",&n);for(i=0;i<n;i++){scanf(""\n%c-%d %c-%d"",&h1,&v1,&h2,&v2);set_road(C,h1,v1,h2,v2,1);}scanf(""%d"",&n);for(i=0;i<n;i++){scanf(""\n%c-%d %c-%d%d"",&h1,&v1,&h2,&v2,&k);set_road(J,h1,v1,h2,v2,k);}scanf(""\n%c-%d %c-%d"",&h1,&v1,&h2,&v2);xs=v1;ys=h1-96;xg=v2;yg=h2-96;P[0][0][xs][ys]=1;for(T=0;;T++)for(d=0;d<4;d++){if(P[T][d][xg][yg]){printf(""%d\n"",T);goto E;}for(x=1;x<=N;x++)for(y=1;y<=M;y++)if(P[T][d][x][y]&&(!S[x][y]||T/S[x][y]%2!=d%2))for(d1=0;d1<4;d1++){t1=T+D+J[d1][x][y];x1=x+vx[d1];y1=y+vy[d1];if(d1!=(d^2)&&!C[d1][x][y]&&t1<=100&&x1>=1&&x1<=N&&y1>=1&&y1<=M)P[t1][d1][x1][y1]=1;}}E:;}return 0;}",1
p00194,"運送会社
白虎運送は会津若松市を代表する運送会社です。昨今の原油価格の高騰は運送会社にも多大なダメージを与え、運送会社各社では、できるだけ少ないガソリンで荷物を運ぶことが課題となっています。
白虎運送では、重い荷物を積んだトラックは、その走りだしに多くのエネルギーを必要とすることに着目しました。トラックが倉庫を出発してから一度も停止することなく目的地まで到達する経路の中で最短時間の経路を通ることで、ガソリンの節約ができると考えました。
あなたの仕事は、このような最短経路を計算できるカーナビを開発することです。作成するカーナビ用プログラムの仕様は以下のとおりです。
市内は、下図のように、東西方向の道路
M
本、南北方向の道路
N
本 からなる格子で表し、格子の各交点は交差点を表します。
交差点のいくつかには東西 - 南北の方向に信号機が設置されており、一定の周期で青、赤のシグナルが点灯しています。
市内の交差点間を結ぶ道路には工事中で通過できない個所がいくつかあります。
トラックが交差点から交差点へ移動するのに必要な時間は一定ですが、渋滞している道路ではさらに長い時間がかかります。
市内の道路情報、トラックが交差点間を移動するのに必要な時間、信号機がある交差点と各信号機の周期、工事中の道路、渋滞している道路と渋滞度、白虎運送の倉庫(始点)と目的地(終点)の位置を入力とし、始点から終点までの最短の時間を出力するプログラムを作成して下さい。
図のように、東西の方向の道路はa、b、c、... と英小文字で名前が付けられ 、南北の方向の道路は 1、2、3、... と整数で名前が付けられています。市内の交差点は、これらの英小文字と整数の組み合わせ
H
-
V
で指定されます。
例えば、市内の最北西の交差点は a-1 で指定されます。各信号は周期
k
をもち、
k
分ごとに切り替わります。東西が青ならば南北が赤で、南北が青ならば東西が赤です。黄色のシグナルは存在しません。トラックは二つの交差点を結ぶ道路を移動するのに
D
分要しますが、その道路が渋滞している場合はさらに
d
分の時間を要します。トラックは道路が工事中の場合は移動できません。
また、交差点に到達した時刻に、信号が赤の場合には進入できません。トラックは交差点でのみ、東、西、南、北に方向を変えることができますが、来た方向へは移動(Uターン)できません。道路は2方通行であり、トラックが行き来する時間、工事状況、渋滞度は2方向共通です。
初期状態として、トラックは東を向いていて、トラックが倉庫を出発する瞬間すべての信号機が南北の方向に青に切り替わるものとします。また、トラックは 100分以内で目的地に到達できるものとします。
Input
複数のデータセットの並びが入力として与えられます。入力の終わりはゼロふたつの行で示されます。各データセットは以下の形式で与えられます。
M
N
D
ns
H
1
-
V
1
k
1
H
2
-
V
2
k
2
:
H
ns
-
V
ns
k
ns
nc
H
11
-
V
11
H
12
-
V
12
H
21
-
V
21
H
22
-
V
22
:
H
nc1
-
V
nc1
H
nc2
-
V
nc2
nj
H
11
-
V
11
H
12
-
V
12
d
1
H
21
-
V
21
H
22
-
V
22
d
2
:
H
nj1
-
V
nj1
H
nj2
-
V
nj2
d
nj
H
s
-
V
s
H
d
-
V
d
１行目に道路の本数
M
,
N
(2 ≤
M, N
≤ 20) が与えられます。２行目に、二つの交差点を結ぶ道路を移動するのに要する時間
D
(1 ≤
D
≤ D, 整数) が与えられます。
３行目に信号機の数
ns
が与えられます。続く
ns
行に、
i
個目の信号機の位置を表す英小文字と整数の組
H
i
-
V
i
と周期
k
(1 ≤
k
≤ 100) が与えられます。
続く行に、工事中の道路の数
nc
が与えられます。続く
nc
行に、
i
個目の工事中の道路の２つの端点（交差点）を表す英小文字と整数の組
H
i1
-
V
i1
H
i2
-
V
i2
が与えられます。
続く行に、渋滞道路の数
nj
が与えられます。続く
nj
行に、
i
個目の渋滞道路の２つの端点（交差点）を表す英小文字と整数の組
H
i1
-
V
i1
H
i2
-
V
i2
と時間
d
i
(1 ≤
d
i
≤ 100) が与えられます。
最後の行に、始点の交差点
H
s
-
V
d
と終点の交差点
H
d
-
V
d
が与えられます。
データセットの数は 20 を超えません。
Output
データセット毎に最短時間を１行に出力します。
Sample Input
4 5
1
3
b-2 3
c-3 2
c-4 1
3
a-2 b-2
b-3 c-3
d-3 d-4
2
b-3 b-4 1
c-1 d-1 1
d-1 b-4
4 5
1
3
b-2 3
c-3 2
c-4 1
3
a-2 b-2
b-3 c-3
d-3 d-4
2
b-3 b-4 1
c-1 d-1 1
d-2 b-4
4 5
1
3
b-2 3
c-3 2
c-4 1
3
a-2 b-2
b-3 c-3
d-3 d-4
2
b-3 b-4 1
c-1 d-1 1
d-3 b-4
0 0
Output for the Sample Input
7
4
8",Java,"import java.util.*;
import java.io.*;

public class Main {
    static class State implements Comparable<State> {
        int row, col, time, dir;
        
        public State(int row, int col, int time, int dir) {
            this.row = row;
            this.col = col;
            this.time = time;
            this.dir = dir;
        }
        
        public int compareTo(State other) {
            return this.time - other.time;
        }
    }
    
    static final int EAST = 0, WEST = 1, SOUTH = 2, NORTH = 3;
    static final int[] DR = {0, 0, 1, -1};
    static final int[] DC = {1, -1, 0, 0};
    
    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        String line;
        
        while ((line = br.readLine()) != null) {
            String[] tokens = line.trim().split(""\\s+"");
            int M = Integer.parseInt(tokens[0]);
            int N = Integer.parseInt(tokens[1]);
            
            if (M == 0 && N == 0) break;
            
            int D = Integer.parseInt(br.readLine().trim());
            
            int[][] signal = new int[M][N];
            for (int i = 0; i < M; i++) {
                Arrays.fill(signal[i], -1);
            }
            
            int ns = Integer.parseInt(br.readLine().trim());
            for (int i = 0; i < ns; i++) {
                tokens = br.readLine().trim().split(""\\s+"");
                String[] pos = tokens[0].split(""-"");
                int row = pos[0].charAt(0) - 'a';
                int col = Integer.parseInt(pos[1]) - 1;
                int k = Integer.parseInt(tokens[1]);
                signal[row][col] = k;
            }
            
            boolean[][][] blocked = new boolean[M][N][4];
            int nc = Integer.parseInt(br.readLine().trim());
            for (int i = 0; i < nc; i++) {
                tokens = br.readLine().trim().split(""\\s+"");
                String[] pos1 = tokens[0].split(""-"");
                String[] pos2 = tokens[1].split(""-"");
                int r1 = pos1[0].charAt(0) - 'a';
                int c1 = Integer.parseInt(pos1[1]) - 1;
                int r2 = pos2[0].charAt(0) - 'a';
                int c2 = Integer.parseInt(pos2[1]) - 1;
                
                for (int d = 0; d < 4; d++) {
                    if (r1 + DR[d] == r2 && c1 + DC[d] == c2) {
                        blocked[r1][c1][d] = true;
                        blocked[r2][c2][d ^ 1] = true;
                    }
                }
            }
            
            int[][] congestion = new int[M][N];
            for (int i = 0; i < M; i++) {
                for (int j = 0; j < N; j++) {
                    congestion[i][j] = D;
                }
            }
            
            int nj = Integer.parseInt(br.readLine().trim());
            for (int i = 0; i < nj; i++) {
                tokens = br.readLine().trim().split(""\\s+"");
                String[] pos1 = tokens[0].split(""-"");
                String[] pos2 = tokens[1].split(""-"");
                int r1 = pos1[0].charAt(0) - 'a';
                int c1 = Integer.parseInt(pos1[1]) - 1;
                int r2 = pos2[0].charAt(0) - 'a';
                int c2 = Integer.parseInt(pos2[1]) - 1;
                int d = Integer.parseInt(tokens[2]);
                
                congestion[r1][c1] = Math.max(congestion[r1][c1], D + d);
            }
            
            tokens = br.readLine().trim().split(""\\s+"");
            String[] start = tokens[0].split(""-"");
            String[] end = tokens[1].split(""-"");
            int sr = start[0].charAt(0) - 'a';
            int sc = Integer.parseInt(start[1]) - 1;
            int er = end[0].charAt(0) - 'a';
            int ec = Integer.parseInt(end[1]) - 1;
            
            int result = dijkstra(M, N, sr, sc, er, ec, signal, blocked, congestion);
            System.out.println(result);
        }
    }
    
    static int dijkstra(int M, int N, int sr, int sc, int er, int ec, 
                        int[][] signal, boolean[][][] blocked, int[][] congestion) {
        int[][][] dist = new int[M][N][4];
        for (int i = 0; i < M; i++) {
            for (int j = 0; j < N; j++) {
                Arrays.fill(dist[i][j], Integer.MAX_VALUE);
            }
        }
        
        PriorityQueue<State> pq = new PriorityQueue<>();
        pq.offer(new State(sr, sc, 0, EAST));
        dist[sr][sc][EAST] = 0;
        
        while (!pq.isEmpty()) {
            State curr = pq.poll();
            
            if (curr.row == er && curr.col == ec) {
                return curr.time;
            }
            
            if (curr.time > dist[curr.row][curr.col][curr.dir]) continue;
            
            for (int d = 0; d < 4; d++) {
                if (d == (curr.dir ^ 1)) continue;
                
                if (blocked[curr.row][curr.col][d]) continue;
                
                if (signal[curr.row][curr.col] != -1) {
                    int k = signal[curr.row][curr.col];
                    int cycle = curr.time / k;
                    boolean isNSGreen = (cycle % 2 == 0);
                    boolean isEWGreen = !isNSGreen;
                    
                    if ((d == EAST || d == WEST) && !isEWGreen) continue;
                    if ((d == NORTH || d == SOUTH) && !isNSGreen) continue;
                }
                
                int nr = curr.row + DR[d];
                int nc = curr.col + DC[d];
                
                if (nr < 0 || nr >= M || nc < 0 || nc >= N) continue;
                
                int travelTime = congestion[curr.row][curr.col];
                int newTime = curr.time + travelTime;
                
                if (newTime < dist[nr][nc][d]) {
                    dist[nr][nc][d] = newTime;
                    pq.offer(new State(nr, nc, newTime, d));
                }
            }
        }
        
        return -1;
    }
}
",0
p00194,"運送会社
白虎運送は会津若松市を代表する運送会社です。昨今の原油価格の高騰は運送会社にも多大なダメージを与え、運送会社各社では、できるだけ少ないガソリンで荷物を運ぶことが課題となっています。
白虎運送では、重い荷物を積んだトラックは、その走りだしに多くのエネルギーを必要とすることに着目しました。トラックが倉庫を出発してから一度も停止することなく目的地まで到達する経路の中で最短時間の経路を通ることで、ガソリンの節約ができると考えました。
あなたの仕事は、このような最短経路を計算できるカーナビを開発することです。作成するカーナビ用プログラムの仕様は以下のとおりです。
市内は、下図のように、東西方向の道路
M
本、南北方向の道路
N
本 からなる格子で表し、格子の各交点は交差点を表します。
交差点のいくつかには東西 - 南北の方向に信号機が設置されており、一定の周期で青、赤のシグナルが点灯しています。
市内の交差点間を結ぶ道路には工事中で通過できない個所がいくつかあります。
トラックが交差点から交差点へ移動するのに必要な時間は一定ですが、渋滞している道路ではさらに長い時間がかかります。
市内の道路情報、トラックが交差点間を移動するのに必要な時間、信号機がある交差点と各信号機の周期、工事中の道路、渋滞している道路と渋滞度、白虎運送の倉庫(始点)と目的地(終点)の位置を入力とし、始点から終点までの最短の時間を出力するプログラムを作成して下さい。
図のように、東西の方向の道路はa、b、c、... と英小文字で名前が付けられ 、南北の方向の道路は 1、2、3、... と整数で名前が付けられています。市内の交差点は、これらの英小文字と整数の組み合わせ
H
-
V
で指定されます。
例えば、市内の最北西の交差点は a-1 で指定されます。各信号は周期
k
をもち、
k
分ごとに切り替わります。東西が青ならば南北が赤で、南北が青ならば東西が赤です。黄色のシグナルは存在しません。トラックは二つの交差点を結ぶ道路を移動するのに
D
分要しますが、その道路が渋滞している場合はさらに
d
分の時間を要します。トラックは道路が工事中の場合は移動できません。
また、交差点に到達した時刻に、信号が赤の場合には進入できません。トラックは交差点でのみ、東、西、南、北に方向を変えることができますが、来た方向へは移動(Uターン)できません。道路は2方通行であり、トラックが行き来する時間、工事状況、渋滞度は2方向共通です。
初期状態として、トラックは東を向いていて、トラックが倉庫を出発する瞬間すべての信号機が南北の方向に青に切り替わるものとします。また、トラックは 100分以内で目的地に到達できるものとします。
Input
複数のデータセットの並びが入力として与えられます。入力の終わりはゼロふたつの行で示されます。各データセットは以下の形式で与えられます。
M
N
D
ns
H
1
-
V
1
k
1
H
2
-
V
2
k
2
:
H
ns
-
V
ns
k
ns
nc
H
11
-
V
11
H
12
-
V
12
H
21
-
V
21
H
22
-
V
22
:
H
nc1
-
V
nc1
H
nc2
-
V
nc2
nj
H
11
-
V
11
H
12
-
V
12
d
1
H
21
-
V
21
H
22
-
V
22
d
2
:
H
nj1
-
V
nj1
H
nj2
-
V
nj2
d
nj
H
s
-
V
s
H
d
-
V
d
１行目に道路の本数
M
,
N
(2 ≤
M, N
≤ 20) が与えられます。２行目に、二つの交差点を結ぶ道路を移動するのに要する時間
D
(1 ≤
D
≤ D, 整数) が与えられます。
３行目に信号機の数
ns
が与えられます。続く
ns
行に、
i
個目の信号機の位置を表す英小文字と整数の組
H
i
-
V
i
と周期
k
(1 ≤
k
≤ 100) が与えられます。
続く行に、工事中の道路の数
nc
が与えられます。続く
nc
行に、
i
個目の工事中の道路の２つの端点（交差点）を表す英小文字と整数の組
H
i1
-
V
i1
H
i2
-
V
i2
が与えられます。
続く行に、渋滞道路の数
nj
が与えられます。続く
nj
行に、
i
個目の渋滞道路の２つの端点（交差点）を表す英小文字と整数の組
H
i1
-
V
i1
H
i2
-
V
i2
と時間
d
i
(1 ≤
d
i
≤ 100) が与えられます。
最後の行に、始点の交差点
H
s
-
V
d
と終点の交差点
H
d
-
V
d
が与えられます。
データセットの数は 20 を超えません。
Output
データセット毎に最短時間を１行に出力します。
Sample Input
4 5
1
3
b-2 3
c-3 2
c-4 1
3
a-2 b-2
b-3 c-3
d-3 d-4
2
b-3 b-4 1
c-1 d-1 1
d-1 b-4
4 5
1
3
b-2 3
c-3 2
c-4 1
3
a-2 b-2
b-3 c-3
d-3 d-4
2
b-3 b-4 1
c-1 d-1 1
d-2 b-4
4 5
1
3
b-2 3
c-3 2
c-4 1
3
a-2 b-2
b-3 c-3
d-3 d-4
2
b-3 b-4 1
c-1 d-1 1
d-3 b-4
0 0
Output for the Sample Input
7
4
8",Java,"import java.util.*;
import java.awt.Point;

public class Main{
	public static void main(String[] args){
		Scanner sc = new Scanner(System.in);
		int dx[] = {0,1,0,-1};
		int dy[] = {-1,0,1,0};
		boolean pass[] = {true,false,true,false};

		while(true){
			int h = sc.nextInt();
			int w = sc.nextInt();
			if(w == 0 && h == 0) break;
			int d = sc.nextInt();

			HashMap<Point,Integer> node = new HashMap<Point,Integer>();
			int ns = sc.nextInt();
			for(int i=0;i<ns;i++){
				node.put(toPoint(sc.next()),sc.nextInt());
			}

			HashMap<Point,HashMap<Point,Integer>> edge = new HashMap<Point,HashMap<Point,Integer>>();
			int nc = sc.nextInt();
			for(int i=0;i<nc;i++){
				Point a = toPoint(sc.next());
				Point b = toPoint(sc.next());
				if(edge.get(a) == null) edge.put(a,new HashMap<Point,Integer>());
				if(edge.get(b) == null) edge.put(b,new HashMap<Point,Integer>());
				edge.get(a).put(b,-1);
				edge.get(b).put(a,-1);
			}

			int nj = sc.nextInt();
			for(int i=0;i<nj;i++){
				Point a = toPoint(sc.next());
				Point b = toPoint(sc.next());
				int cost = sc.nextInt();
				if(edge.get(a) == null) edge.put(a,new HashMap<Point,Integer>());
				if(edge.get(b) == null) edge.put(b,new HashMap<Point,Integer>());
				edge.get(a).put(b,cost);
				edge.get(b).put(a,cost);
			}

			Point start = toPoint(sc.next());
			Point goal = toPoint(sc.next());

			PriorityQueue<State> open = new PriorityQueue<State>();
			HashSet<State> closed = new HashSet<State>();
			open.add(new State(start,1,0));
			//closed.add(new State(start,1,0));
			State ans = null;

			while(!open.isEmpty()){
				State st = open.poll();

				if(closed.contains(st)) continue;
				closed.add(st);

				if(st.p.equals(goal)){
					ans = st;
					break;
				}

				for(int i=0;i<4;i++){
					//U^[µÄÍ¢¯È¢
					if((st.d + 2) % 4 == i) continue;

					Point np = new Point(st.p.x + dx[i], st.p.y + dy[i]);

					if(np.x>=0 && np.x<w && np.y>=0 && np.y<h){
						int val = 0;
						//st.p©çnpÖÌ¹îñðæèo·
						if(edge.containsKey(st.p) &&
							 edge.get(st.p).containsKey(np)) val = edge.get(st.p).get(np);
						//HÈçÊêÈ¢
						if(val == -1) continue;

						int ncost = st.cost + d + val;

						//Mª éêÌ
						if(node.containsKey(np)){
							int k = node.get(np);
							boolean flg = pass[i]; //true:NüÂ\Å é
							int div = ncost / k;
							if(div % 2 == 1) flg = !flg;
							if(!flg) continue;
							//if(!flg) ncost += k - ncost % k;
						}

						open.add(new State(np,i,ncost));
						State nst = new State(np,i,ncost);
						//if(closed.contains(nst)) continue;
						//closed.add(nst);
						//open.add(nst);
					}
				}
			}

			System.out.println(ans.cost);
		}
	}

	private static Point toPoint(String s){
		String[] tmp = s.split(""-"");
		int x = Integer.parseInt(tmp[1]) - 1;
		int y = tmp[0].charAt(0) - 'a';
		return new Point(x,y);
	}
}

class State implements Comparable<State>{
	Point p;
	int d,cost;

	State(Point p,int d,int cost){
		this.p = new Point(p.x,p.y);
		this.d = d;
		this.cost = cost;
	}

	public int compareTo(State st){
		return this.cost - st.cost;
	}

	public boolean equals(Object o){
		State st = (State)o;
		return p.equals(st.p) && d == st.d;
	}

	public int hashCode(){
		return p.x + p.y * 100 + d * 10000;
	}

	public String toString(){
		return String.format(""[(%d,%d),%d,%d]"",p.x,p.y,d,cost);
	}
}",1
p00194,"運送会社
白虎運送は会津若松市を代表する運送会社です。昨今の原油価格の高騰は運送会社にも多大なダメージを与え、運送会社各社では、できるだけ少ないガソリンで荷物を運ぶことが課題となっています。
白虎運送では、重い荷物を積んだトラックは、その走りだしに多くのエネルギーを必要とすることに着目しました。トラックが倉庫を出発してから一度も停止することなく目的地まで到達する経路の中で最短時間の経路を通ることで、ガソリンの節約ができると考えました。
あなたの仕事は、このような最短経路を計算できるカーナビを開発することです。作成するカーナビ用プログラムの仕様は以下のとおりです。
市内は、下図のように、東西方向の道路
M
本、南北方向の道路
N
本 からなる格子で表し、格子の各交点は交差点を表します。
交差点のいくつかには東西 - 南北の方向に信号機が設置されており、一定の周期で青、赤のシグナルが点灯しています。
市内の交差点間を結ぶ道路には工事中で通過できない個所がいくつかあります。
トラックが交差点から交差点へ移動するのに必要な時間は一定ですが、渋滞している道路ではさらに長い時間がかかります。
市内の道路情報、トラックが交差点間を移動するのに必要な時間、信号機がある交差点と各信号機の周期、工事中の道路、渋滞している道路と渋滞度、白虎運送の倉庫(始点)と目的地(終点)の位置を入力とし、始点から終点までの最短の時間を出力するプログラムを作成して下さい。
図のように、東西の方向の道路はa、b、c、... と英小文字で名前が付けられ 、南北の方向の道路は 1、2、3、... と整数で名前が付けられています。市内の交差点は、これらの英小文字と整数の組み合わせ
H
-
V
で指定されます。
例えば、市内の最北西の交差点は a-1 で指定されます。各信号は周期
k
をもち、
k
分ごとに切り替わります。東西が青ならば南北が赤で、南北が青ならば東西が赤です。黄色のシグナルは存在しません。トラックは二つの交差点を結ぶ道路を移動するのに
D
分要しますが、その道路が渋滞している場合はさらに
d
分の時間を要します。トラックは道路が工事中の場合は移動できません。
また、交差点に到達した時刻に、信号が赤の場合には進入できません。トラックは交差点でのみ、東、西、南、北に方向を変えることができますが、来た方向へは移動(Uターン)できません。道路は2方通行であり、トラックが行き来する時間、工事状況、渋滞度は2方向共通です。
初期状態として、トラックは東を向いていて、トラックが倉庫を出発する瞬間すべての信号機が南北の方向に青に切り替わるものとします。また、トラックは 100分以内で目的地に到達できるものとします。
Input
複数のデータセットの並びが入力として与えられます。入力の終わりはゼロふたつの行で示されます。各データセットは以下の形式で与えられます。
M
N
D
ns
H
1
-
V
1
k
1
H
2
-
V
2
k
2
:
H
ns
-
V
ns
k
ns
nc
H
11
-
V
11
H
12
-
V
12
H
21
-
V
21
H
22
-
V
22
:
H
nc1
-
V
nc1
H
nc2
-
V
nc2
nj
H
11
-
V
11
H
12
-
V
12
d
1
H
21
-
V
21
H
22
-
V
22
d
2
:
H
nj1
-
V
nj1
H
nj2
-
V
nj2
d
nj
H
s
-
V
s
H
d
-
V
d
１行目に道路の本数
M
,
N
(2 ≤
M, N
≤ 20) が与えられます。２行目に、二つの交差点を結ぶ道路を移動するのに要する時間
D
(1 ≤
D
≤ D, 整数) が与えられます。
３行目に信号機の数
ns
が与えられます。続く
ns
行に、
i
個目の信号機の位置を表す英小文字と整数の組
H
i
-
V
i
と周期
k
(1 ≤
k
≤ 100) が与えられます。
続く行に、工事中の道路の数
nc
が与えられます。続く
nc
行に、
i
個目の工事中の道路の２つの端点（交差点）を表す英小文字と整数の組
H
i1
-
V
i1
H
i2
-
V
i2
が与えられます。
続く行に、渋滞道路の数
nj
が与えられます。続く
nj
行に、
i
個目の渋滞道路の２つの端点（交差点）を表す英小文字と整数の組
H
i1
-
V
i1
H
i2
-
V
i2
と時間
d
i
(1 ≤
d
i
≤ 100) が与えられます。
最後の行に、始点の交差点
H
s
-
V
d
と終点の交差点
H
d
-
V
d
が与えられます。
データセットの数は 20 を超えません。
Output
データセット毎に最短時間を１行に出力します。
Sample Input
4 5
1
3
b-2 3
c-3 2
c-4 1
3
a-2 b-2
b-3 c-3
d-3 d-4
2
b-3 b-4 1
c-1 d-1 1
d-1 b-4
4 5
1
3
b-2 3
c-3 2
c-4 1
3
a-2 b-2
b-3 c-3
d-3 d-4
2
b-3 b-4 1
c-1 d-1 1
d-2 b-4
4 5
1
3
b-2 3
c-3 2
c-4 1
3
a-2 b-2
b-3 c-3
d-3 d-4
2
b-3 b-4 1
c-1 d-1 1
d-3 b-4
0 0
Output for the Sample Input
7
4
8",Python,"import heapq
from collections import defaultdict

def parse_intersection(s):
    parts = s.split('-')
    h = ord(parts[0]) - ord('a')
    v = int(parts[1]) - 1
    return (h, v)

def solve():
    while True:
        line = input().split()
        M, N = int(line[0]), int(line[1])
        if M == 0 and N == 0:
            break
        
        D = int(input())
        
        ns = int(input())
        signals = {}
        for _ in range(ns):
            parts = input().split()
            pos = parse_intersection(parts[0])
            k = int(parts[1])
            signals[pos] = k
        
        nc = int(input())
        blocked = set()
        for _ in range(nc):
            parts = input().split()
            pos1 = parse_intersection(parts[0])
            pos2 = parse_intersection(parts[1])
            blocked.add((min(pos1, pos2), max(pos1, pos2)))
        
        nj = int(input())
        jams = {}
        for _ in range(nj):
            parts = input().split()
            pos1 = parse_intersection(parts[0])
            pos2 = parse_intersection(parts[1])
            d = int(parts[2])
            key = (min(pos1, pos2), max(pos1, pos2))
            jams[key] = d
        
        parts = input().split()
        start = parse_intersection(parts[0])
        end = parse_intersection(parts[1])
        
        # Dijkstra with state (time, pos, direction)
        # direction: 0=E, 1=W, 2=S, 3=N
        pq = [(0, start, 0)]
        visited = set()
        
        # Direction vectors: E, W, S, N
        dirs = [(0, 1), (0, -1), (1, 0), (-1, 0)]
        # EW: 0,1  NS: 2,3
        
        while pq:
            time, pos, prev_dir = heapq.heappop(pq)
            
            if pos == end:
                print(time)
                break
            
            state = (pos, prev_dir)
            if state in visited:
                continue
            visited.add(state)
            
            h, v = pos
            
            for d in range(4):
                # No U-turn
                if prev_dir == 0 and d == 1:
                    continue
                if prev_dir == 1 and d == 0:
                    continue
                if prev_dir == 2 and d == 3:
                    continue
                if prev_dir == 3 and d == 2:
                    continue
                
                dh, dv = dirs[d]
                nh, nv = h + dh, v + dv
                
                if nh < 0 or nh >= M or nv < 0 or nv >= N:
                    continue
                
                new_pos = (nh, nv)
                edge = (min(pos, new_pos), max(pos, new_pos))
                
                if edge in blocked:
                    continue
                
                # Check signal at current position
                if pos in signals:
                    k = signals[pos]
                    cycle_time = time % (2 * k)
                    # At time 0, NS is green (d=2,3)
                    # 0 to k-1: NS green (EW red)
                    # k to 2k-1: EW green (NS red)
                    
                    if d in [0, 1]:  # EW direction
                        if cycle_time < k:  # NS is green, EW is red
                            continue
                    else:  # NS direction
                        if cycle_time >= k:  # EW is green, NS is red
                            continue
                
                travel_time = D
                if edge in jams:
                    travel_time += jams[edge]
                
                new_time = time + travel_time
                
                if new_time <= 100:
                    heapq.heappush(pq, (new_time, new_pos, d))

solve()
",0
p00194,"運送会社
白虎運送は会津若松市を代表する運送会社です。昨今の原油価格の高騰は運送会社にも多大なダメージを与え、運送会社各社では、できるだけ少ないガソリンで荷物を運ぶことが課題となっています。
白虎運送では、重い荷物を積んだトラックは、その走りだしに多くのエネルギーを必要とすることに着目しました。トラックが倉庫を出発してから一度も停止することなく目的地まで到達する経路の中で最短時間の経路を通ることで、ガソリンの節約ができると考えました。
あなたの仕事は、このような最短経路を計算できるカーナビを開発することです。作成するカーナビ用プログラムの仕様は以下のとおりです。
市内は、下図のように、東西方向の道路
M
本、南北方向の道路
N
本 からなる格子で表し、格子の各交点は交差点を表します。
交差点のいくつかには東西 - 南北の方向に信号機が設置されており、一定の周期で青、赤のシグナルが点灯しています。
市内の交差点間を結ぶ道路には工事中で通過できない個所がいくつかあります。
トラックが交差点から交差点へ移動するのに必要な時間は一定ですが、渋滞している道路ではさらに長い時間がかかります。
市内の道路情報、トラックが交差点間を移動するのに必要な時間、信号機がある交差点と各信号機の周期、工事中の道路、渋滞している道路と渋滞度、白虎運送の倉庫(始点)と目的地(終点)の位置を入力とし、始点から終点までの最短の時間を出力するプログラムを作成して下さい。
図のように、東西の方向の道路はa、b、c、... と英小文字で名前が付けられ 、南北の方向の道路は 1、2、3、... と整数で名前が付けられています。市内の交差点は、これらの英小文字と整数の組み合わせ
H
-
V
で指定されます。
例えば、市内の最北西の交差点は a-1 で指定されます。各信号は周期
k
をもち、
k
分ごとに切り替わります。東西が青ならば南北が赤で、南北が青ならば東西が赤です。黄色のシグナルは存在しません。トラックは二つの交差点を結ぶ道路を移動するのに
D
分要しますが、その道路が渋滞している場合はさらに
d
分の時間を要します。トラックは道路が工事中の場合は移動できません。
また、交差点に到達した時刻に、信号が赤の場合には進入できません。トラックは交差点でのみ、東、西、南、北に方向を変えることができますが、来た方向へは移動(Uターン)できません。道路は2方通行であり、トラックが行き来する時間、工事状況、渋滞度は2方向共通です。
初期状態として、トラックは東を向いていて、トラックが倉庫を出発する瞬間すべての信号機が南北の方向に青に切り替わるものとします。また、トラックは 100分以内で目的地に到達できるものとします。
Input
複数のデータセットの並びが入力として与えられます。入力の終わりはゼロふたつの行で示されます。各データセットは以下の形式で与えられます。
M
N
D
ns
H
1
-
V
1
k
1
H
2
-
V
2
k
2
:
H
ns
-
V
ns
k
ns
nc
H
11
-
V
11
H
12
-
V
12
H
21
-
V
21
H
22
-
V
22
:
H
nc1
-
V
nc1
H
nc2
-
V
nc2
nj
H
11
-
V
11
H
12
-
V
12
d
1
H
21
-
V
21
H
22
-
V
22
d
2
:
H
nj1
-
V
nj1
H
nj2
-
V
nj2
d
nj
H
s
-
V
s
H
d
-
V
d
１行目に道路の本数
M
,
N
(2 ≤
M, N
≤ 20) が与えられます。２行目に、二つの交差点を結ぶ道路を移動するのに要する時間
D
(1 ≤
D
≤ D, 整数) が与えられます。
３行目に信号機の数
ns
が与えられます。続く
ns
行に、
i
個目の信号機の位置を表す英小文字と整数の組
H
i
-
V
i
と周期
k
(1 ≤
k
≤ 100) が与えられます。
続く行に、工事中の道路の数
nc
が与えられます。続く
nc
行に、
i
個目の工事中の道路の２つの端点（交差点）を表す英小文字と整数の組
H
i1
-
V
i1
H
i2
-
V
i2
が与えられます。
続く行に、渋滞道路の数
nj
が与えられます。続く
nj
行に、
i
個目の渋滞道路の２つの端点（交差点）を表す英小文字と整数の組
H
i1
-
V
i1
H
i2
-
V
i2
と時間
d
i
(1 ≤
d
i
≤ 100) が与えられます。
最後の行に、始点の交差点
H
s
-
V
d
と終点の交差点
H
d
-
V
d
が与えられます。
データセットの数は 20 を超えません。
Output
データセット毎に最短時間を１行に出力します。
Sample Input
4 5
1
3
b-2 3
c-3 2
c-4 1
3
a-2 b-2
b-3 c-3
d-3 d-4
2
b-3 b-4 1
c-1 d-1 1
d-1 b-4
4 5
1
3
b-2 3
c-3 2
c-4 1
3
a-2 b-2
b-3 c-3
d-3 d-4
2
b-3 b-4 1
c-1 d-1 1
d-2 b-4
4 5
1
3
b-2 3
c-3 2
c-4 1
3
a-2 b-2
b-3 c-3
d-3 d-4
2
b-3 b-4 1
c-1 d-1 1
d-3 b-4
0 0
Output for the Sample Input
7
4
8",Python,"#Byakko Delivery Company
from heapq import heappop, heappush
from string import ascii_lowercase as al
dic = dict([(c,i) for i, c in enumerate(al)])
f = lambda (h, v):(dic[h], int(v) - 1)
g = lambda s:f(s.split(""-""))

def solve():
    hq = [(0, start[0], start[1])]
    while len(hq) != 0:
        cost, cy, cx = heappop(hq)
        #print ""cost = {}, pos = ({}, {})"".format(cost, cy, cx)
        if (cy, cx) == goal:
            return cost
        for dy, dx in ((0, 1), (0, -1), (1, 0), (-1, 0)):
            ny, nx = cy + dy, cx + dx
            if 0 <= ny < M and 0 <= nx < N:
                #print ny, nx, condition[ny][nx][cy][cx]
                nc = condition[ny][nx][cy][cx] + D + cost
                if field[ny][nx] == 0:
                    heappush(hq, (nc, ny, nx))
                else:
                    if dy == 0:
                        if (nc / field[ny][nx]) % 2 == 1:
                            heappush(hq, (nc, ny, nx))
                    else:
                        if (nc / field[ny][nx]) % 2 == 0:
                            heappush(hq, (nc, ny, nx))
while True:
    M, N = map(int, raw_input().split())
    if M | N == 0:
        break
    D = input()
    field = [[0] * N for _ in xrange(M)]
    condition = [[[[0] * N for _ in xrange(M)] for _ in xrange(N)] for _ in xrange(M)]
    for _ in xrange(input()):
        p, k = raw_input().split()
        h, v = g(p)
        field[h][v] = int(k)

    for _ in xrange(input()):    
        (h1, v1), (h2, v2) = map(g, raw_input().split())
        condition[h1][v1][h2][v2] = condition[h2][v2][h1][v1] = 1 << 30

    for _ in xrange(input()):
        p1, p2, d = raw_input().split()
        h1, v1 = g(p1)
        h2, v2 = g(p2)
        condition[h1][v1][h2][v2] = condition[h2][v2][h1][v1] = int(d)

    start, goal = map(g, raw_input().split())
    print solve()",1
p00195,"人気の出店は?
会津若松市では、毎年1月10日に「十日市」という初市があります。この十日市は、約600年の歴史があり会津地方最大の初市です。会津地方ではお馴染みの縁起物である、起き上がり小法師(おきあがりこぼし)が売られていることでもよく知られています。起き上がり小法師は、大きさ3cm 程度の重心が底にある張り子で、転がしてもすぐに起きあがることからこの名前が付きました。各家庭では、必ず家族より一個多く買って神棚に供えます。この一個は、 「家族が増えるように」や「厄を背負ってくれる」との意味があります。
十日市実行委員会では、次回の十日市に向けて、起き上がり小法師の販売個数が一番多い出店を調べることになりました。今年の出店の数は5店(A、B、C、D、E:半角英字)で、販売個数は、午前と午後に分けて十日市実行委員会に報告されています。
各出店の情報を入力とし、一日の販売個数が一番多い出店の名前とその個数を出力するプログラムを作成してください。
Input
複数のデータセットの並びが入力として与えられます。入力の終わりはゼロふたつの行で示されます。
各データセットは以下の形式で与えられます。
s1
A
s2
A
s1
B
s2
B
s1
C
s2
C
s1
D
s2
D
s1
E
s2
E
i
行目に、それぞれA, B, C, D, E の午前の販売個数
s1
i
と午後の販売個数
s2
i
(1 ≤
s1
i
,
s2
i
≤ 10000) が与えられます。ただし、一日の販売個数が同じ出店は無いものとします。
データセットの数は 100 を超えません。
Output
データセットごとに、一日の販売個数の一番多い出店の名前とその個数を１行に出力します。
Sample Input
1593 4311
4321 2155
1256 6421
5310 1455
2152 5421
1549 3386
4528 3719
1234 4321
3330 3109
2739 2199
0 0
Output for the Sample Input
C 7677
B 8247",C,"#include <stdio.h>

int main() {
    int s1, s2;
    char stores[] = {'A', 'B', 'C', 'D', 'E'};
    int totals[5];
    
    while(1) {
        scanf(""%d %d"", &s1, &s2);
        if(s1 == 0 && s2 == 0) break;
        
        totals[0] = s1 + s2;
        
        for(int i = 1; i < 5; i++) {
            scanf(""%d %d"", &s1, &s2);
            totals[i] = s1 + s2;
        }
        
        int maxIndex = 0;
        int maxTotal = totals[0];
        
        for(int i = 1; i < 5; i++) {
            if(totals[i] > maxTotal) {
                maxTotal = totals[i];
                maxIndex = i;
            }
        }
        
        printf(""%c %d\n"", stores[maxIndex], maxTotal);
    }
    
    return 0;
}
",0
p00195,"人気の出店は?
会津若松市では、毎年1月10日に「十日市」という初市があります。この十日市は、約600年の歴史があり会津地方最大の初市です。会津地方ではお馴染みの縁起物である、起き上がり小法師(おきあがりこぼし)が売られていることでもよく知られています。起き上がり小法師は、大きさ3cm 程度の重心が底にある張り子で、転がしてもすぐに起きあがることからこの名前が付きました。各家庭では、必ず家族より一個多く買って神棚に供えます。この一個は、 「家族が増えるように」や「厄を背負ってくれる」との意味があります。
十日市実行委員会では、次回の十日市に向けて、起き上がり小法師の販売個数が一番多い出店を調べることになりました。今年の出店の数は5店(A、B、C、D、E:半角英字)で、販売個数は、午前と午後に分けて十日市実行委員会に報告されています。
各出店の情報を入力とし、一日の販売個数が一番多い出店の名前とその個数を出力するプログラムを作成してください。
Input
複数のデータセットの並びが入力として与えられます。入力の終わりはゼロふたつの行で示されます。
各データセットは以下の形式で与えられます。
s1
A
s2
A
s1
B
s2
B
s1
C
s2
C
s1
D
s2
D
s1
E
s2
E
i
行目に、それぞれA, B, C, D, E の午前の販売個数
s1
i
と午後の販売個数
s2
i
(1 ≤
s1
i
,
s2
i
≤ 10000) が与えられます。ただし、一日の販売個数が同じ出店は無いものとします。
データセットの数は 100 を超えません。
Output
データセットごとに、一日の販売個数の一番多い出店の名前とその個数を１行に出力します。
Sample Input
1593 4311
4321 2155
1256 6421
5310 1455
2152 5421
1549 3386
4528 3719
1234 4321
3330 3109
2739 2199
0 0
Output for the Sample Input
C 7677
B 8247",C,"#include<stdio.h>

int main(void){
	
	int i,sum,a,b,c;
	int top,topn;
	
	top = 0;
	
	while(1){
		
		scanf("" %d %d"",&a,&b);
		
		if(a == 0 && b == 0){
			break;
		}
		
		c = a + b;
		
		if(top > c){
			top = c;
			topn = i;
		}
		
		i++;
		
		if(i==5){
			switch(topn){
				case 1:
					printf(""A "");
					break;
				case 2:
					printf(""B "");
					break;
				case 3:
					printf(""C "");
					break;
				case 4:
					printf(""D "");
					break;
				case 5:
					printf(""E "");
					break;
			}
			
			
			printf("" %d"",top);
		}
	}
	
	return(0);
	
}",1
p00195,"人気の出店は?
会津若松市では、毎年1月10日に「十日市」という初市があります。この十日市は、約600年の歴史があり会津地方最大の初市です。会津地方ではお馴染みの縁起物である、起き上がり小法師(おきあがりこぼし)が売られていることでもよく知られています。起き上がり小法師は、大きさ3cm 程度の重心が底にある張り子で、転がしてもすぐに起きあがることからこの名前が付きました。各家庭では、必ず家族より一個多く買って神棚に供えます。この一個は、 「家族が増えるように」や「厄を背負ってくれる」との意味があります。
十日市実行委員会では、次回の十日市に向けて、起き上がり小法師の販売個数が一番多い出店を調べることになりました。今年の出店の数は5店(A、B、C、D、E:半角英字)で、販売個数は、午前と午後に分けて十日市実行委員会に報告されています。
各出店の情報を入力とし、一日の販売個数が一番多い出店の名前とその個数を出力するプログラムを作成してください。
Input
複数のデータセットの並びが入力として与えられます。入力の終わりはゼロふたつの行で示されます。
各データセットは以下の形式で与えられます。
s1
A
s2
A
s1
B
s2
B
s1
C
s2
C
s1
D
s2
D
s1
E
s2
E
i
行目に、それぞれA, B, C, D, E の午前の販売個数
s1
i
と午後の販売個数
s2
i
(1 ≤
s1
i
,
s2
i
≤ 10000) が与えられます。ただし、一日の販売個数が同じ出店は無いものとします。
データセットの数は 100 を超えません。
Output
データセットごとに、一日の販売個数の一番多い出店の名前とその個数を１行に出力します。
Sample Input
1593 4311
4321 2155
1256 6421
5310 1455
2152 5421
1549 3386
4528 3719
1234 4321
3330 3109
2739 2199
0 0
Output for the Sample Input
C 7677
B 8247",Java,"import java.util.Scanner;

public class Main {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        
        while (true) {
            int s1A = sc.nextInt();
            int s2A = sc.nextInt();
            
            if (s1A == 0 && s2A == 0) {
                break;
            }
            
            int s1B = sc.nextInt();
            int s2B = sc.nextInt();
            int s1C = sc.nextInt();
            int s2C = sc.nextInt();
            int s1D = sc.nextInt();
            int s2D = sc.nextInt();
            int s1E = sc.nextInt();
            int s2E = sc.nextInt();
            
            int totalA = s1A + s2A;
            int totalB = s1B + s2B;
            int totalC = s1C + s2C;
            int totalD = s1D + s2D;
            int totalE = s1E + s2E;
            
            int max = totalA;
            String store = ""A"";
            
            if (totalB > max) {
                max = totalB;
                store = ""B"";
            }
            if (totalC > max) {
                max = totalC;
                store = ""C"";
            }
            if (totalD > max) {
                max = totalD;
                store = ""D"";
            }
            if (totalE > max) {
                max = totalE;
                store = ""E"";
            }
            
            System.out.println(store + "" "" + max);
        }
        
        sc.close();
    }
}
",0
p00195,"人気の出店は?
会津若松市では、毎年1月10日に「十日市」という初市があります。この十日市は、約600年の歴史があり会津地方最大の初市です。会津地方ではお馴染みの縁起物である、起き上がり小法師(おきあがりこぼし)が売られていることでもよく知られています。起き上がり小法師は、大きさ3cm 程度の重心が底にある張り子で、転がしてもすぐに起きあがることからこの名前が付きました。各家庭では、必ず家族より一個多く買って神棚に供えます。この一個は、 「家族が増えるように」や「厄を背負ってくれる」との意味があります。
十日市実行委員会では、次回の十日市に向けて、起き上がり小法師の販売個数が一番多い出店を調べることになりました。今年の出店の数は5店(A、B、C、D、E:半角英字)で、販売個数は、午前と午後に分けて十日市実行委員会に報告されています。
各出店の情報を入力とし、一日の販売個数が一番多い出店の名前とその個数を出力するプログラムを作成してください。
Input
複数のデータセットの並びが入力として与えられます。入力の終わりはゼロふたつの行で示されます。
各データセットは以下の形式で与えられます。
s1
A
s2
A
s1
B
s2
B
s1
C
s2
C
s1
D
s2
D
s1
E
s2
E
i
行目に、それぞれA, B, C, D, E の午前の販売個数
s1
i
と午後の販売個数
s2
i
(1 ≤
s1
i
,
s2
i
≤ 10000) が与えられます。ただし、一日の販売個数が同じ出店は無いものとします。
データセットの数は 100 を超えません。
Output
データセットごとに、一日の販売個数の一番多い出店の名前とその個数を１行に出力します。
Sample Input
1593 4311
4321 2155
1256 6421
5310 1455
2152 5421
1549 3386
4528 3719
1234 4321
3330 3109
2739 2199
0 0
Output for the Sample Input
C 7677
B 8247",Java,"import java.util.ArrayList;
import java.util.Scanner;
public class Main {
	
	public static void main(String[] args) {
		Scanner stdIn = new Scanner(System.in);
		String[] k = new String[]{""A"",""B"",""C"",""D"",""E""};
		while(true) {
			int number = 0;
			int max = 0;
			for(int i = 0; i < 5; i++) {
				int tmp = stdIn.nextInt();
				tmp += stdIn.nextInt();
				if(tmp == 0) {
					return;
				}
				
				if(tmp > max) {
					max = tmp;
					number = i;
				}
			}
			
			System.out.println(k[number] + "" "" + max);
		}
	}
}",1
p00195,"人気の出店は?
会津若松市では、毎年1月10日に「十日市」という初市があります。この十日市は、約600年の歴史があり会津地方最大の初市です。会津地方ではお馴染みの縁起物である、起き上がり小法師(おきあがりこぼし)が売られていることでもよく知られています。起き上がり小法師は、大きさ3cm 程度の重心が底にある張り子で、転がしてもすぐに起きあがることからこの名前が付きました。各家庭では、必ず家族より一個多く買って神棚に供えます。この一個は、 「家族が増えるように」や「厄を背負ってくれる」との意味があります。
十日市実行委員会では、次回の十日市に向けて、起き上がり小法師の販売個数が一番多い出店を調べることになりました。今年の出店の数は5店(A、B、C、D、E:半角英字)で、販売個数は、午前と午後に分けて十日市実行委員会に報告されています。
各出店の情報を入力とし、一日の販売個数が一番多い出店の名前とその個数を出力するプログラムを作成してください。
Input
複数のデータセットの並びが入力として与えられます。入力の終わりはゼロふたつの行で示されます。
各データセットは以下の形式で与えられます。
s1
A
s2
A
s1
B
s2
B
s1
C
s2
C
s1
D
s2
D
s1
E
s2
E
i
行目に、それぞれA, B, C, D, E の午前の販売個数
s1
i
と午後の販売個数
s2
i
(1 ≤
s1
i
,
s2
i
≤ 10000) が与えられます。ただし、一日の販売個数が同じ出店は無いものとします。
データセットの数は 100 を超えません。
Output
データセットごとに、一日の販売個数の一番多い出店の名前とその個数を１行に出力します。
Sample Input
1593 4311
4321 2155
1256 6421
5310 1455
2152 5421
1549 3386
4528 3719
1234 4321
3330 3109
2739 2199
0 0
Output for the Sample Input
C 7677
B 8247",Python,"import sys

for line in sys.stdin:
    s1_A, s2_A = map(int, line.split())
    if s1_A == 0 and s2_A == 0:
        break
    
    stores = []
    stores.append(('A', s1_A + s2_A))
    
    for store_name in ['B', 'C', 'D', 'E']:
        s1, s2 = map(int, input().split())
        stores.append((store_name, s1 + s2))
    
    max_store = max(stores, key=lambda x: x[1])
    print(max_store[0], max_store[1])
",0
p00195,"人気の出店は?
会津若松市では、毎年1月10日に「十日市」という初市があります。この十日市は、約600年の歴史があり会津地方最大の初市です。会津地方ではお馴染みの縁起物である、起き上がり小法師(おきあがりこぼし)が売られていることでもよく知られています。起き上がり小法師は、大きさ3cm 程度の重心が底にある張り子で、転がしてもすぐに起きあがることからこの名前が付きました。各家庭では、必ず家族より一個多く買って神棚に供えます。この一個は、 「家族が増えるように」や「厄を背負ってくれる」との意味があります。
十日市実行委員会では、次回の十日市に向けて、起き上がり小法師の販売個数が一番多い出店を調べることになりました。今年の出店の数は5店(A、B、C、D、E:半角英字)で、販売個数は、午前と午後に分けて十日市実行委員会に報告されています。
各出店の情報を入力とし、一日の販売個数が一番多い出店の名前とその個数を出力するプログラムを作成してください。
Input
複数のデータセットの並びが入力として与えられます。入力の終わりはゼロふたつの行で示されます。
各データセットは以下の形式で与えられます。
s1
A
s2
A
s1
B
s2
B
s1
C
s2
C
s1
D
s2
D
s1
E
s2
E
i
行目に、それぞれA, B, C, D, E の午前の販売個数
s1
i
と午後の販売個数
s2
i
(1 ≤
s1
i
,
s2
i
≤ 10000) が与えられます。ただし、一日の販売個数が同じ出店は無いものとします。
データセットの数は 100 を超えません。
Output
データセットごとに、一日の販売個数の一番多い出店の名前とその個数を１行に出力します。
Sample Input
1593 4311
4321 2155
1256 6421
5310 1455
2152 5421
1549 3386
4528 3719
1234 4321
3330 3109
2739 2199
0 0
Output for the Sample Input
C 7677
B 8247",Python,"# Aizu Problem 0195: What is the Most Popular Shop in Tokaichi?
#
import sys, math, os

# read input:
PYDEV = os.environ.get('PYDEV')
if PYDEV==""True"":
    sys.stdin = open(""sample-input.txt"", ""rt"")


while True:
    most = 0
    shop = 'A'
    a, b = [int(_) for _ in input().split()]
    if a == b == 0:
        break
    most = a + b
    for s in range(4):
        a = sum([int(_) for _ in input().split()])
        if a > most:
            most = a
            shop = chr(66 + s)
    print(shop, most)
            ",1
p00196,"野球大会
野球の国別対抗戦 WBC で、日本が2連覇達成!! 野球人気が高まる中、会津学園高校を会場に野球大会が行われました。この大会では、総当りのリーグ戦を行い、以下のような方法で順位を決めることになりました。
勝ち数の多いチームを上位とする
勝ち数が同数の場合は負け数の少ないチームを上位とする
各チームの成績を入力とし、チーム名を上位のチームから順に出力するプログラムを作成してください。同順位のチームが存在する場合は、入力順に出力してください。ただし、チーム数
n
は 2 以上 10 以下の整数、チーム名
t
は 1 文字の半角英字、試合毎の成績
r
は
n
- 1 個の数字で表され、勝ちの場合は 0 、負けの場合は 1 、引き分けの場合は 2 とします。また、チーム名に重複はないものとします。
Input
複数のデータセットの並びが入力として与えられます。入力の終わりはゼロひとつの行で示されます。
各データセットは以下の形式で与えられます。
n
score
1
score
2
:
score
n
1 行目にチームの数
n
(2 ≤
n
≤ 10) 、続く
n
行に第
i
のチームの成績
score
i
が与えられます。各成績は次の形式で与えられます。
t
r
1
r
2
...
r
n−1
チーム名
t
(１文字の半角英字)、
t
の試合毎の成績
r
i
(0, 1, または 2) が空白区切りで与えられます。
データセットの数は 50 を超えません。
Output
データセットごとに、チーム名を上位のチームから順に出力します。
Sample Input
6
A 1 0 0 2 0
B 0 0 1 1 0
C 1 1 1 1 1
D 1 0 0 1 2
E 2 0 0 0 0
F 1 1 0 2 1
4
g 1 1 1
h 0 1 2
w 0 0 0
b 0 2 1
0
Output for the Sample Input
E
A
B
D
F
C
w
h
b
g",C,"#include <stdio.h>
#include <string.h>

typedef struct {
    char name;
    int wins;
    int losses;
    int order;
} Team;

int compare(const void *a, const void *b) {
    Team *ta = (Team *)a;
    Team *tb = (Team *)b;
    
    if (ta->wins != tb->wins) {
        return tb->wins - ta->wins;
    }
    if (ta->losses != tb->losses) {
        return ta->losses - tb->losses;
    }
    return ta->order - tb->order;
}

int main() {
    int n;
    
    while (scanf(""%d"", &n) == 1 && n != 0) {
        Team teams[10];
        
        for (int i = 0; i < n; i++) {
            char name;
            scanf("" %c"", &name);
            
            teams[i].name = name;
            teams[i].wins = 0;
            teams[i].losses = 0;
            teams[i].order = i;
            
            for (int j = 0; j < n - 1; j++) {
                int result;
                scanf(""%d"", &result);
                
                if (result == 0) {
                    teams[i].wins++;
                } else if (result == 1) {
                    teams[i].losses++;
                }
            }
        }
        
        qsort(teams, n, sizeof(Team), compare);
        
        for (int i = 0; i < n; i++) {
            printf(""%c\n"", teams[i].name);
        }
    }
    
    return 0;
}
",0
p00196,"野球大会
野球の国別対抗戦 WBC で、日本が2連覇達成!! 野球人気が高まる中、会津学園高校を会場に野球大会が行われました。この大会では、総当りのリーグ戦を行い、以下のような方法で順位を決めることになりました。
勝ち数の多いチームを上位とする
勝ち数が同数の場合は負け数の少ないチームを上位とする
各チームの成績を入力とし、チーム名を上位のチームから順に出力するプログラムを作成してください。同順位のチームが存在する場合は、入力順に出力してください。ただし、チーム数
n
は 2 以上 10 以下の整数、チーム名
t
は 1 文字の半角英字、試合毎の成績
r
は
n
- 1 個の数字で表され、勝ちの場合は 0 、負けの場合は 1 、引き分けの場合は 2 とします。また、チーム名に重複はないものとします。
Input
複数のデータセットの並びが入力として与えられます。入力の終わりはゼロひとつの行で示されます。
各データセットは以下の形式で与えられます。
n
score
1
score
2
:
score
n
1 行目にチームの数
n
(2 ≤
n
≤ 10) 、続く
n
行に第
i
のチームの成績
score
i
が与えられます。各成績は次の形式で与えられます。
t
r
1
r
2
...
r
n−1
チーム名
t
(１文字の半角英字)、
t
の試合毎の成績
r
i
(0, 1, または 2) が空白区切りで与えられます。
データセットの数は 50 を超えません。
Output
データセットごとに、チーム名を上位のチームから順に出力します。
Sample Input
6
A 1 0 0 2 0
B 0 0 1 1 0
C 1 1 1 1 1
D 1 0 0 1 2
E 2 0 0 0 0
F 1 1 0 2 1
4
g 1 1 1
h 0 1 2
w 0 0 0
b 0 2 1
0
Output for the Sample Input
E
A
B
D
F
C
w
h
b
g",C,"// Aizu Vol-1 0196: Baseball Championship
// 2017.8.3

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <ctype.h>

char *gets(char *);
char buf[500], *p;

int getInt(void)
{
	int n = 0;
	while (isspace(*p)) p++;
	return *p++ - '0';
}

char getStr(void)
{
	while (isspace(*p)) p++;
	return *p++;
}

typedef struct { char a; int k, w, l; } T;
T t[15];

int main()
{
	int i, j, k, n;
	T tmp, *tp, *tt;

	while (1) {
		gets(buf);
		if (!(n = atoi(buf))) break;
		for (i = 0, tp = t; i < n; i++, tp++) {
			gets(p = buf);
			tp->a = getStr(), tp->k = i, tp->w = tp->l = 0;
			for (j = 1; j < n; j++) {
				k = getInt();
				if (k == 0) tp->w++;
				else if (k == 1) tp->l++;
			}
		}
		for (i = 0; i < n; i++) {
			tp = t + i;
			for (j = i+1, tt = tp+1; j < n; j++, tt++) {
				if (tt->w > tp->w) tp = tt;
				else if (tt->w == tp->w) {
					if (tt->l < tp->l) tp = tt;
					else if (tt->l == tp->l && tt->k < tp->k) tp = tt;
				}
			}
			if (tp != t + i) {
				memcpy(&tmp, t+i, sizeof(tmp));
				memcpy(t+i, tp, sizeof(tmp));
				memcpy(tp, &tmp, sizeof(tmp));
			}
		}
		for (i = 0; i < n; i++) putchar(t[i].a), putchar('\n');
	}
	return 0;
}",1
p00196,"野球大会
野球の国別対抗戦 WBC で、日本が2連覇達成!! 野球人気が高まる中、会津学園高校を会場に野球大会が行われました。この大会では、総当りのリーグ戦を行い、以下のような方法で順位を決めることになりました。
勝ち数の多いチームを上位とする
勝ち数が同数の場合は負け数の少ないチームを上位とする
各チームの成績を入力とし、チーム名を上位のチームから順に出力するプログラムを作成してください。同順位のチームが存在する場合は、入力順に出力してください。ただし、チーム数
n
は 2 以上 10 以下の整数、チーム名
t
は 1 文字の半角英字、試合毎の成績
r
は
n
- 1 個の数字で表され、勝ちの場合は 0 、負けの場合は 1 、引き分けの場合は 2 とします。また、チーム名に重複はないものとします。
Input
複数のデータセットの並びが入力として与えられます。入力の終わりはゼロひとつの行で示されます。
各データセットは以下の形式で与えられます。
n
score
1
score
2
:
score
n
1 行目にチームの数
n
(2 ≤
n
≤ 10) 、続く
n
行に第
i
のチームの成績
score
i
が与えられます。各成績は次の形式で与えられます。
t
r
1
r
2
...
r
n−1
チーム名
t
(１文字の半角英字)、
t
の試合毎の成績
r
i
(0, 1, または 2) が空白区切りで与えられます。
データセットの数は 50 を超えません。
Output
データセットごとに、チーム名を上位のチームから順に出力します。
Sample Input
6
A 1 0 0 2 0
B 0 0 1 1 0
C 1 1 1 1 1
D 1 0 0 1 2
E 2 0 0 0 0
F 1 1 0 2 1
4
g 1 1 1
h 0 1 2
w 0 0 0
b 0 2 1
0
Output for the Sample Input
E
A
B
D
F
C
w
h
b
g",Java,"import java.util.*;

public class Main {
    static class Team {
        String name;
        int wins;
        int losses;
        int order;
        
        Team(String name, int wins, int losses, int order) {
            this.name = name;
            this.wins = wins;
            this.losses = losses;
            this.order = order;
        }
    }
    
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        
        while (true) {
            int n = sc.nextInt();
            if (n == 0) break;
            
            List<Team> teams = new ArrayList<>();
            
            for (int i = 0; i < n; i++) {
                String teamName = sc.next();
                int wins = 0;
                int losses = 0;
                
                for (int j = 0; j < n - 1; j++) {
                    int result = sc.nextInt();
                    if (result == 0) {
                        wins++;
                    } else if (result == 1) {
                        losses++;
                    }
                }
                
                teams.add(new Team(teamName, wins, losses, i));
            }
            
            Collections.sort(teams, new Comparator<Team>() {
                @Override
                public int compare(Team t1, Team t2) {
                    if (t1.wins != t2.wins) {
                        return t2.wins - t1.wins;
                    }
                    if (t1.losses != t2.losses) {
                        return t1.losses - t2.losses;
                    }
                    return t1.order - t2.order;
                }
            });
            
            for (Team team : teams) {
                System.out.println(team.name);
            }
        }
        
        sc.close();
    }
}
",0
p00196,"野球大会
野球の国別対抗戦 WBC で、日本が2連覇達成!! 野球人気が高まる中、会津学園高校を会場に野球大会が行われました。この大会では、総当りのリーグ戦を行い、以下のような方法で順位を決めることになりました。
勝ち数の多いチームを上位とする
勝ち数が同数の場合は負け数の少ないチームを上位とする
各チームの成績を入力とし、チーム名を上位のチームから順に出力するプログラムを作成してください。同順位のチームが存在する場合は、入力順に出力してください。ただし、チーム数
n
は 2 以上 10 以下の整数、チーム名
t
は 1 文字の半角英字、試合毎の成績
r
は
n
- 1 個の数字で表され、勝ちの場合は 0 、負けの場合は 1 、引き分けの場合は 2 とします。また、チーム名に重複はないものとします。
Input
複数のデータセットの並びが入力として与えられます。入力の終わりはゼロひとつの行で示されます。
各データセットは以下の形式で与えられます。
n
score
1
score
2
:
score
n
1 行目にチームの数
n
(2 ≤
n
≤ 10) 、続く
n
行に第
i
のチームの成績
score
i
が与えられます。各成績は次の形式で与えられます。
t
r
1
r
2
...
r
n−1
チーム名
t
(１文字の半角英字)、
t
の試合毎の成績
r
i
(0, 1, または 2) が空白区切りで与えられます。
データセットの数は 50 を超えません。
Output
データセットごとに、チーム名を上位のチームから順に出力します。
Sample Input
6
A 1 0 0 2 0
B 0 0 1 1 0
C 1 1 1 1 1
D 1 0 0 1 2
E 2 0 0 0 0
F 1 1 0 2 1
4
g 1 1 1
h 0 1 2
w 0 0 0
b 0 2 1
0
Output for the Sample Input
E
A
B
D
F
C
w
h
b
g",Java,"
import java.io.*;
import java.util.*;


// 2011/10/23

// 0196 ìåï
public class Main {
	
	
	class Team implements Comparable<Team> {
		String name;
		int win;
		int lose;
		public Team(String name, int win, int lose) {
			this.name = name;
			this.win = win;
			this.lose = lose;
		}
		@Override
		public int compareTo(Team o) {
			if (win != o.win) {
				return -(win - o.win);
			}
			else
				return (lose - o.lose);
		}
		
	}
	

	// C return falseÅ¨µÜ¢
	boolean main() throws IOException {

		int n = readIntArray()[0];
		if (n == 0)
			return false;
		
		List<Team> list = new ArrayList<Team>();
		for(int i = 0; i < n; i++) {
			String s = reader.readLine();
			String[] sp = s.split("" "");
			
			int win = 0;
			int lose = 0;
			for(int j = 0; j < n - 1; j++) {
				String r = sp[j + 1];
				if (r.equals(""0"")) {
					win++;
				}
				else if (r.equals(""1"")) {
					lose++;
				}
			}
			list.add(new Team(sp[0], win, lose));
		}	
		
		Collections.sort(list);
		
		for(Team t: list) {
			System.out.printf(""%s\n"", t.name);
		}
		
//		System.out.printf(""%d\n"", sum / size);
		
		return true; // ³íI¹ Ö
	}
	

//	private final static boolean DEBUG = true;  // debug
	private final static boolean DEBUG = false; // release

	public static void main(String[] args) throws IOException {

		if (DEBUG) {
			log = System.out;
			
			String inputStr = ""1:15:"";

			inputStr = inputStr.replace("":"", ""\n"");

			reader = new BufferedReader(new StringReader(inputStr)); 

		}
		else {
			log = new PrintStream(new OutputStream() { public void write(int b) {} } ); // «ÌÄ
			reader = new BufferedReader(new InputStreamReader(System.in)); // R\[©ç
		}
		
		int N = Integer.MAX_VALUE;
		//int N = readIntArray()[0];

		for(int i = 0; i < N; i++) {
			boolean b = new Main().main();
			if (!b)
				break;
		}		
		
		reader.close();
	}

	
	static PrintStream log;
	static BufferedReader reader;
	

	// WüÍæè1sªÌæØè¶æØèÅÌ®lðÇÞ
	// EOFÌêÍnullðÔ·
	private static int[] readIntArray() throws IOException {

		String s = null;
		for(;;) {
			s = reader.readLine();
//			log.printf(""%s\n"", s);
			if (s == null)
				return null;
			s = s.trim();
			if (s.length() != 0) // ¦¦¦@Ç¤àËRósðÇÞ±Æª éBÇÝòÎ·Æ¤Ü­¢­çµ¢BBBB
				break;
		}
		
		String[] sp = s.split(""[ ,]""); // æØè¶ÍXy[X©J}
		int[] a = new int[sp.length];
		for(int i = 0; i < sp.length; i++) {
			a[i] = Integer.parseInt(sp[i]);
		}
		return a;
	}
		
}",1
p00196,"野球大会
野球の国別対抗戦 WBC で、日本が2連覇達成!! 野球人気が高まる中、会津学園高校を会場に野球大会が行われました。この大会では、総当りのリーグ戦を行い、以下のような方法で順位を決めることになりました。
勝ち数の多いチームを上位とする
勝ち数が同数の場合は負け数の少ないチームを上位とする
各チームの成績を入力とし、チーム名を上位のチームから順に出力するプログラムを作成してください。同順位のチームが存在する場合は、入力順に出力してください。ただし、チーム数
n
は 2 以上 10 以下の整数、チーム名
t
は 1 文字の半角英字、試合毎の成績
r
は
n
- 1 個の数字で表され、勝ちの場合は 0 、負けの場合は 1 、引き分けの場合は 2 とします。また、チーム名に重複はないものとします。
Input
複数のデータセットの並びが入力として与えられます。入力の終わりはゼロひとつの行で示されます。
各データセットは以下の形式で与えられます。
n
score
1
score
2
:
score
n
1 行目にチームの数
n
(2 ≤
n
≤ 10) 、続く
n
行に第
i
のチームの成績
score
i
が与えられます。各成績は次の形式で与えられます。
t
r
1
r
2
...
r
n−1
チーム名
t
(１文字の半角英字)、
t
の試合毎の成績
r
i
(0, 1, または 2) が空白区切りで与えられます。
データセットの数は 50 を超えません。
Output
データセットごとに、チーム名を上位のチームから順に出力します。
Sample Input
6
A 1 0 0 2 0
B 0 0 1 1 0
C 1 1 1 1 1
D 1 0 0 1 2
E 2 0 0 0 0
F 1 1 0 2 1
4
g 1 1 1
h 0 1 2
w 0 0 0
b 0 2 1
0
Output for the Sample Input
E
A
B
D
F
C
w
h
b
g",Python,"while True:
    n = int(input())
    if n == 0:
        break
    
    teams = []
    for i in range(n):
        line = input().split()
        name = line[0]
        results = list(map(int, line[1:]))
        
        wins = results.count(0)
        losses = results.count(1)
        
        teams.append((name, wins, losses, i))
    
    # Sort by wins (descending), then losses (ascending), then input order (ascending)
    teams.sort(key=lambda x: (-x[1], x[2], x[3]))
    
    for team in teams:
        print(team[0])
",0
p00196,"野球大会
野球の国別対抗戦 WBC で、日本が2連覇達成!! 野球人気が高まる中、会津学園高校を会場に野球大会が行われました。この大会では、総当りのリーグ戦を行い、以下のような方法で順位を決めることになりました。
勝ち数の多いチームを上位とする
勝ち数が同数の場合は負け数の少ないチームを上位とする
各チームの成績を入力とし、チーム名を上位のチームから順に出力するプログラムを作成してください。同順位のチームが存在する場合は、入力順に出力してください。ただし、チーム数
n
は 2 以上 10 以下の整数、チーム名
t
は 1 文字の半角英字、試合毎の成績
r
は
n
- 1 個の数字で表され、勝ちの場合は 0 、負けの場合は 1 、引き分けの場合は 2 とします。また、チーム名に重複はないものとします。
Input
複数のデータセットの並びが入力として与えられます。入力の終わりはゼロひとつの行で示されます。
各データセットは以下の形式で与えられます。
n
score
1
score
2
:
score
n
1 行目にチームの数
n
(2 ≤
n
≤ 10) 、続く
n
行に第
i
のチームの成績
score
i
が与えられます。各成績は次の形式で与えられます。
t
r
1
r
2
...
r
n−1
チーム名
t
(１文字の半角英字)、
t
の試合毎の成績
r
i
(0, 1, または 2) が空白区切りで与えられます。
データセットの数は 50 を超えません。
Output
データセットごとに、チーム名を上位のチームから順に出力します。
Sample Input
6
A 1 0 0 2 0
B 0 0 1 1 0
C 1 1 1 1 1
D 1 0 0 1 2
E 2 0 0 0 0
F 1 1 0 2 1
4
g 1 1 1
h 0 1 2
w 0 0 0
b 0 2 1
0
Output for the Sample Input
E
A
B
D
F
C
w
h
b
g",Python,"while True:
    n = int(raw_input())
    if n == 0: break
    ans = [[0]*4 for i in range(n)]
    for i in range(n):
        line = raw_input().split()
        ans[i][2] = -i
        ans[i][3] = line[0]
        for c in line[1:]:
            if c == '0':
                ans[i][0] += 1
            elif c == '1':
                ans[i][1] -= 1
    for a in sorted(ans, key=lambda x: (x[0], x[1], x[2]), reverse=True):
        print a[3]",1
p00197,"最大公約数-ユークリッドの互除法
最大公約数は、コンピュータ上で扱う数学には欠かせない要素です。最大公約 数を使うことで、計算の効率が大きく変動することもあります。最大公約数を求めるアルゴリズムのひとつが「ユークリッドの互除法」です。その処理 の流れを以下に示します。
例えば 1071 と 1029 の場合、1071 を
X
、1029 を
Y
に代入して、
1071 ÷ 1029 の余りは 42 、
X
に 42 を代入して
X
と
Y
を入れ替える。 (1 ステップ)
1029 ÷   42 の余りは 21 、
X
に 21 を代入して
X
と
Y
を入れ替える。 (2 ステップ)
42 ÷   21 の余りは  0 、
X
に  0 を代入して
X
と
Y
を入れ替える。 (3 ステップ)
Y
が 0 になったので、この時の
X
が最大公約数となる。よって最大公約数は 21 。
このように、たったの 3 ステップで 1071 と 1029 の最大公約数を求めることが出来ました。ユークリッドの互除法は約数を出して比較していく方法に比べ、圧倒的に早く結果を出してくれます。
２つの整数を入力とし、ユークリッドの互除法を用いて最大公約数を求め、その最大公約数と計算にかかったステップ数を出力するプログラムを作成してください。
Input
複数のデータセットの並びが入力として与えられます。入力の終わりはゼロふたつの行で示されます。
各データセットとして２つの整数
a, b
(2 ≤
a, b
≤ 2
31
-1) が１行に与えられます。
データセットの数は 1000 を超えません。
Output
データセットごとに、入力された２つの整数の最大公約数と、計算にかかったユークリッドの互除法のステップ数を空白区切りで１行に出力します。
Sample Input
1071 1029
5 5
0 0
Output for the Sample Input
21 3
5 1",C,"#include <stdio.h>

int main() {
    long long a, b;
    
    while (1) {
        scanf(""%lld %lld"", &a, &b);
        
        if (a == 0 && b == 0) {
            break;
        }
        
        long long x = a;
        long long y = b;
        int steps = 0;
        long long temp;
        
        while (y != 0) {
            temp = x % y;
            x = y;
            y = temp;
            steps++;
        }
        
        printf(""%lld %d\n"", x, steps);
    }
    
    return 0;
}
",0
p00197,"最大公約数-ユークリッドの互除法
最大公約数は、コンピュータ上で扱う数学には欠かせない要素です。最大公約 数を使うことで、計算の効率が大きく変動することもあります。最大公約数を求めるアルゴリズムのひとつが「ユークリッドの互除法」です。その処理 の流れを以下に示します。
例えば 1071 と 1029 の場合、1071 を
X
、1029 を
Y
に代入して、
1071 ÷ 1029 の余りは 42 、
X
に 42 を代入して
X
と
Y
を入れ替える。 (1 ステップ)
1029 ÷   42 の余りは 21 、
X
に 21 を代入して
X
と
Y
を入れ替える。 (2 ステップ)
42 ÷   21 の余りは  0 、
X
に  0 を代入して
X
と
Y
を入れ替える。 (3 ステップ)
Y
が 0 になったので、この時の
X
が最大公約数となる。よって最大公約数は 21 。
このように、たったの 3 ステップで 1071 と 1029 の最大公約数を求めることが出来ました。ユークリッドの互除法は約数を出して比較していく方法に比べ、圧倒的に早く結果を出してくれます。
２つの整数を入力とし、ユークリッドの互除法を用いて最大公約数を求め、その最大公約数と計算にかかったステップ数を出力するプログラムを作成してください。
Input
複数のデータセットの並びが入力として与えられます。入力の終わりはゼロふたつの行で示されます。
各データセットとして２つの整数
a, b
(2 ≤
a, b
≤ 2
31
-1) が１行に与えられます。
データセットの数は 1000 を超えません。
Output
データセットごとに、入力された２つの整数の最大公約数と、計算にかかったユークリッドの互除法のステップ数を空白区切りで１行に出力します。
Sample Input
1071 1029
5 5
0 0
Output for the Sample Input
21 3
5 1",C,"#include <stdio.h>
int main(void)
{    
    int a, b, r;
    int count = 1;
        
    while(scanf(""%d %d"", &a, &b) != EOF)
    {     
        if(a == 0 && b == 0)
        {        
            break;
        }
        
        r = a % b;        
        while(r!=0){            
            a = b;            
            b = r;            
            r = a % b;            
            count++;  
            
            
        }
        printf(""%d %d\n"",b,count);
    }        
      
    return(0);
    
}
",1
p00197,"最大公約数-ユークリッドの互除法
最大公約数は、コンピュータ上で扱う数学には欠かせない要素です。最大公約 数を使うことで、計算の効率が大きく変動することもあります。最大公約数を求めるアルゴリズムのひとつが「ユークリッドの互除法」です。その処理 の流れを以下に示します。
例えば 1071 と 1029 の場合、1071 を
X
、1029 を
Y
に代入して、
1071 ÷ 1029 の余りは 42 、
X
に 42 を代入して
X
と
Y
を入れ替える。 (1 ステップ)
1029 ÷   42 の余りは 21 、
X
に 21 を代入して
X
と
Y
を入れ替える。 (2 ステップ)
42 ÷   21 の余りは  0 、
X
に  0 を代入して
X
と
Y
を入れ替える。 (3 ステップ)
Y
が 0 になったので、この時の
X
が最大公約数となる。よって最大公約数は 21 。
このように、たったの 3 ステップで 1071 と 1029 の最大公約数を求めることが出来ました。ユークリッドの互除法は約数を出して比較していく方法に比べ、圧倒的に早く結果を出してくれます。
２つの整数を入力とし、ユークリッドの互除法を用いて最大公約数を求め、その最大公約数と計算にかかったステップ数を出力するプログラムを作成してください。
Input
複数のデータセットの並びが入力として与えられます。入力の終わりはゼロふたつの行で示されます。
各データセットとして２つの整数
a, b
(2 ≤
a, b
≤ 2
31
-1) が１行に与えられます。
データセットの数は 1000 を超えません。
Output
データセットごとに、入力された２つの整数の最大公約数と、計算にかかったユークリッドの互除法のステップ数を空白区切りで１行に出力します。
Sample Input
1071 1029
5 5
0 0
Output for the Sample Input
21 3
5 1",Java,"import java.util.Scanner;

public class Main {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        
        while (true) {
            long a = sc.nextLong();
            long b = sc.nextLong();
            
            if (a == 0 && b == 0) {
                break;
            }
            
            long x = a;
            long y = b;
            int steps = 0;
            
            while (y != 0) {
                long temp = x % y;
                x = y;
                y = temp;
                steps++;
            }
            
            System.out.println(x + "" "" + steps);
        }
        
        sc.close();
    }
}
",0
p00197,"最大公約数-ユークリッドの互除法
最大公約数は、コンピュータ上で扱う数学には欠かせない要素です。最大公約 数を使うことで、計算の効率が大きく変動することもあります。最大公約数を求めるアルゴリズムのひとつが「ユークリッドの互除法」です。その処理 の流れを以下に示します。
例えば 1071 と 1029 の場合、1071 を
X
、1029 を
Y
に代入して、
1071 ÷ 1029 の余りは 42 、
X
に 42 を代入して
X
と
Y
を入れ替える。 (1 ステップ)
1029 ÷   42 の余りは 21 、
X
に 21 を代入して
X
と
Y
を入れ替える。 (2 ステップ)
42 ÷   21 の余りは  0 、
X
に  0 を代入して
X
と
Y
を入れ替える。 (3 ステップ)
Y
が 0 になったので、この時の
X
が最大公約数となる。よって最大公約数は 21 。
このように、たったの 3 ステップで 1071 と 1029 の最大公約数を求めることが出来ました。ユークリッドの互除法は約数を出して比較していく方法に比べ、圧倒的に早く結果を出してくれます。
２つの整数を入力とし、ユークリッドの互除法を用いて最大公約数を求め、その最大公約数と計算にかかったステップ数を出力するプログラムを作成してください。
Input
複数のデータセットの並びが入力として与えられます。入力の終わりはゼロふたつの行で示されます。
各データセットとして２つの整数
a, b
(2 ≤
a, b
≤ 2
31
-1) が１行に与えられます。
データセットの数は 1000 を超えません。
Output
データセットごとに、入力された２つの整数の最大公約数と、計算にかかったユークリッドの互除法のステップ数を空白区切りで１行に出力します。
Sample Input
1071 1029
5 5
0 0
Output for the Sample Input
21 3
5 1",Java,"import java.util.*;
public class Main {
 
         
        public static void main(String[] args) throws java.io.IOException{
            Scanner scan = new Scanner(System.in);
            while(true){
                int a =scan.nextInt();
                int b = scan.nextInt();
                if((a|b)==0)break;
                if(b>a){
                    a=a^b;
                    b=a^b;
                    a=a^b;
                }
                int c=0;
                while(b!=0){
                    a=a%b;
                    a=a^b;
                    b=a^b;
                    a=a^b;
                    c++;
                }
                System.out.println(a+"" ""+c);
            }
  
        }
   
}",1
p00197,"最大公約数-ユークリッドの互除法
最大公約数は、コンピュータ上で扱う数学には欠かせない要素です。最大公約 数を使うことで、計算の効率が大きく変動することもあります。最大公約数を求めるアルゴリズムのひとつが「ユークリッドの互除法」です。その処理 の流れを以下に示します。
例えば 1071 と 1029 の場合、1071 を
X
、1029 を
Y
に代入して、
1071 ÷ 1029 の余りは 42 、
X
に 42 を代入して
X
と
Y
を入れ替える。 (1 ステップ)
1029 ÷   42 の余りは 21 、
X
に 21 を代入して
X
と
Y
を入れ替える。 (2 ステップ)
42 ÷   21 の余りは  0 、
X
に  0 を代入して
X
と
Y
を入れ替える。 (3 ステップ)
Y
が 0 になったので、この時の
X
が最大公約数となる。よって最大公約数は 21 。
このように、たったの 3 ステップで 1071 と 1029 の最大公約数を求めることが出来ました。ユークリッドの互除法は約数を出して比較していく方法に比べ、圧倒的に早く結果を出してくれます。
２つの整数を入力とし、ユークリッドの互除法を用いて最大公約数を求め、その最大公約数と計算にかかったステップ数を出力するプログラムを作成してください。
Input
複数のデータセットの並びが入力として与えられます。入力の終わりはゼロふたつの行で示されます。
各データセットとして２つの整数
a, b
(2 ≤
a, b
≤ 2
31
-1) が１行に与えられます。
データセットの数は 1000 を超えません。
Output
データセットごとに、入力された２つの整数の最大公約数と、計算にかかったユークリッドの互除法のステップ数を空白区切りで１行に出力します。
Sample Input
1071 1029
5 5
0 0
Output for the Sample Input
21 3
5 1",Python,"while True:
    a, b = map(int, input().split())
    if a == 0 and b == 0:
        break
    
    x, y = a, b
    steps = 0
    
    while y != 0:
        remainder = x % y
        x = remainder
        x, y = y, x
        steps += 1
    
    print(x, steps)
",0
p00197,"最大公約数-ユークリッドの互除法
最大公約数は、コンピュータ上で扱う数学には欠かせない要素です。最大公約 数を使うことで、計算の効率が大きく変動することもあります。最大公約数を求めるアルゴリズムのひとつが「ユークリッドの互除法」です。その処理 の流れを以下に示します。
例えば 1071 と 1029 の場合、1071 を
X
、1029 を
Y
に代入して、
1071 ÷ 1029 の余りは 42 、
X
に 42 を代入して
X
と
Y
を入れ替える。 (1 ステップ)
1029 ÷   42 の余りは 21 、
X
に 21 を代入して
X
と
Y
を入れ替える。 (2 ステップ)
42 ÷   21 の余りは  0 、
X
に  0 を代入して
X
と
Y
を入れ替える。 (3 ステップ)
Y
が 0 になったので、この時の
X
が最大公約数となる。よって最大公約数は 21 。
このように、たったの 3 ステップで 1071 と 1029 の最大公約数を求めることが出来ました。ユークリッドの互除法は約数を出して比較していく方法に比べ、圧倒的に早く結果を出してくれます。
２つの整数を入力とし、ユークリッドの互除法を用いて最大公約数を求め、その最大公約数と計算にかかったステップ数を出力するプログラムを作成してください。
Input
複数のデータセットの並びが入力として与えられます。入力の終わりはゼロふたつの行で示されます。
各データセットとして２つの整数
a, b
(2 ≤
a, b
≤ 2
31
-1) が１行に与えられます。
データセットの数は 1000 を超えません。
Output
データセットごとに、入力された２つの整数の最大公約数と、計算にかかったユークリッドの互除法のステップ数を空白区切りで１行に出力します。
Sample Input
1071 1029
5 5
0 0
Output for the Sample Input
21 3
5 1",Python,"import sys
def f(d,x,y):
    t = x % y
    x = y
    y = t
    if y != 0:
        return f(d+1,x,y)
    else:
        return (x,d+1)

while 1:
    y,x = sorted(list(map(int, input().split())))
    if x == 0: break
    ans = f(0,x,y)
    print(ans[0],ans[1])


",1
p00198,"立方体の作品
芸術家品川は
n
点の作品を出展するように依頼されました。そこで、立方体の 6 面をペンキで色付けしたものを作品として出展することにしました。作品は、Red、Yellow、Blue、Magenta、Green、Cyan の 6 色全てが使われていて、各面は 1 色で塗りつぶされています。品川は形が同じ立方体の作品でも色の配置の仕方を変え、異なる作品として
n
点作成しました。
彼の友人であるあなたは、友人のよしみで作品を出展前に閲覧させてもらいましたが、そこであることに気が付きました。それらの作品の中に異なる色付けをされているように見えても、実は同じ色の組み合わせをした立方体が存在していたのです。このままでは、
n
点の作品を出展することできなくなってしまいます。
作成した作品の数と各作品の色の情報を入力とし、出展するためにあと何点必要かを出力するプログラムを作成してください。
立方体の各面の色は c1 から c6 までの記号で表され、 以下のような配置となっています。また、c1 から c6 のそれぞれは Red、Yellow、Blue、Magenta、Green、Cyan のいずれか 1 色となります。
Input
複数のデータセットの並びが入力として与えられます。 入力の終わりはゼロひとつの行で示されます。
各データセットは以下の形式で与えられます。
n
cube
1
cube
2
:
cube
n
１行目に作品の数
n
(1 ≤
n
≤ 30)、続く
n
行に
i
番目の作品の情報が与えられます。各作品の情報は次の形式で与えられます。
c1 c2 c3 c4 c5 c6
作品の色の配置 c
i
が空白区切りで与えられます。
データセットの数は 100 を超えません。
Output
データセットごとに、出展するのにあと何点の作品が必要かを１行に出力します。
Sample Input
3
Cyan Yellow Red Magenta Green Blue
Cyan Yellow Red Magenta Green Blue
Red Yellow Magenta Blue Green Cyan
4
Red Magenta Blue Green Yellow Cyan
Red Yellow Magenta Blue Green Cyan
Magenta Green Red Cyan Yellow Blue
Cyan Green Yellow Blue Magenta Red
0
Output for the Sample Input
1
1",C,"#include <stdio.h>
#include <string.h>

typedef struct {
    char faces[6][10];
} Cube;

void rotateCube(Cube *c, Cube *result, int rotation) {
    // 24 rotations of a cube
    int rotations[24][6] = {
        {0,1,2,3,4,5}, {0,2,4,1,3,5}, {0,3,1,4,2,5}, {0,4,3,2,1,5},
        {1,0,3,2,5,4}, {1,2,0,5,3,4}, {1,3,5,0,2,4}, {1,5,2,3,0,4},
        {2,0,1,4,5,3}, {2,1,5,0,4,3}, {2,4,0,5,1,3}, {2,5,4,1,0,3},
        {3,0,4,1,5,2}, {3,1,0,5,4,2}, {3,4,5,0,1,2}, {3,5,1,4,0,2},
        {4,0,2,3,5,1}, {4,2,5,0,3,1}, {4,3,0,5,2,1}, {4,5,3,2,0,1},
        {5,1,3,2,4,0}, {5,2,1,4,3,0}, {5,3,4,1,2,0}, {5,4,2,3,1,0}
    };
    
    for (int i = 0; i < 6; i++) {
        strcpy(result->faces[i], c->faces[rotations[rotation][i]]);
    }
}

int compareCubes(Cube *c1, Cube *c2) {
    for (int i = 0; i < 6; i++) {
        int cmp = strcmp(c1->faces[i], c2->faces[i]);
        if (cmp != 0) return cmp;
    }
    return 0;
}

int areSameCube(Cube *c1, Cube *c2) {
    Cube rotated;
    for (int r = 0; r < 24; r++) {
        rotateCube(c1, &rotated, r);
        if (compareCubes(&rotated, c2) == 0) {
            return 1;
        }
    }
    return 0;
}

int main() {
    int n;
    while (scanf(""%d"", &n) == 1 && n != 0) {
        Cube cubes[30];
        
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < 6; j++) {
                scanf(""%s"", cubes[i].faces[j]);
            }
        }
        
        int unique[30];
        int uniqueCount = 0;
        
        for (int i = 0; i < n; i++) {
            int isUnique = 1;
            for (int j = 0; j < uniqueCount; j++) {
                if (areSameCube(&cubes[i], &cubes[unique[j]])) {
                    isUnique = 0;
                    break;
                }
            }
            if (isUnique) {
                unique[uniqueCount++] = i;
            }
        }
        
        printf(""%d\n"", n - uniqueCount);
    }
    
    return 0;
}
",0
p00198,"立方体の作品
芸術家品川は
n
点の作品を出展するように依頼されました。そこで、立方体の 6 面をペンキで色付けしたものを作品として出展することにしました。作品は、Red、Yellow、Blue、Magenta、Green、Cyan の 6 色全てが使われていて、各面は 1 色で塗りつぶされています。品川は形が同じ立方体の作品でも色の配置の仕方を変え、異なる作品として
n
点作成しました。
彼の友人であるあなたは、友人のよしみで作品を出展前に閲覧させてもらいましたが、そこであることに気が付きました。それらの作品の中に異なる色付けをされているように見えても、実は同じ色の組み合わせをした立方体が存在していたのです。このままでは、
n
点の作品を出展することできなくなってしまいます。
作成した作品の数と各作品の色の情報を入力とし、出展するためにあと何点必要かを出力するプログラムを作成してください。
立方体の各面の色は c1 から c6 までの記号で表され、 以下のような配置となっています。また、c1 から c6 のそれぞれは Red、Yellow、Blue、Magenta、Green、Cyan のいずれか 1 色となります。
Input
複数のデータセットの並びが入力として与えられます。 入力の終わりはゼロひとつの行で示されます。
各データセットは以下の形式で与えられます。
n
cube
1
cube
2
:
cube
n
１行目に作品の数
n
(1 ≤
n
≤ 30)、続く
n
行に
i
番目の作品の情報が与えられます。各作品の情報は次の形式で与えられます。
c1 c2 c3 c4 c5 c6
作品の色の配置 c
i
が空白区切りで与えられます。
データセットの数は 100 を超えません。
Output
データセットごとに、出展するのにあと何点の作品が必要かを１行に出力します。
Sample Input
3
Cyan Yellow Red Magenta Green Blue
Cyan Yellow Red Magenta Green Blue
Red Yellow Magenta Blue Green Cyan
4
Red Magenta Blue Green Yellow Cyan
Red Yellow Magenta Blue Green Cyan
Magenta Green Red Cyan Yellow Blue
Cyan Green Yellow Blue Magenta Red
0
Output for the Sample Input
1
1",C,"#include<stdio.h>
int main(void)
{
	int n,i,j,z;
	char c1[1001],c2[1001],c3[1001],c4[1001],c5[1001],c6[1001];
	while(n!=0){
	scanf(""%d"",&n);
	for(i=0;i<n;i++){
		scanf(""%s %s %s %s %s %s"",&c1[i],&c2[i],&c3[i],&c4[i],&c5[i],&c6[i]);
	}
	for(i=0;i<n;i++){
		z=0;
		for(j=0;j<n;j++){
		if(c1[i]==c1[j] && c2[i]==c2[j] && c3[i]==c3[j] && c4[i]==c4[j] && c5[i]==c5[j] && c6[i]==c6[j]){
			z=z+1;
		}
		else if(c4[i]==c4[j] && c1[i]==c1[j] && c3[i]==c3[j] && c6[i]==c6[j]){
			if(c5[i]==c5[j] && c2[i]==c2[j]){
				z=z+1;
			}
		}
		else if(c4[i]==c6[j] && c1[i]==c3[j] && c3[i]==c1[j] && c6[i]==c4[j]){
			if(c5[i]==c2[j] && c2[i]==c5[j]){
				z=z+1;
			}
		}
		else if(c6[i]==c6[j] && c3[i]==c3[j] && c1[i]==c1[j] && c4[i]==c4[j]){
			if(c5[i]==c5[j] && c2[i]==c2[j]){
				z=z+1;
			}
		}
		else if(c6[i]==c4[j] && c3[i]==c1[j] && c1[i]==c3[j] && c4[i]==c6[j]){
			if(c2[i]==c5[j] && c5[i]==c2[j]){
				z=z+1;
			}
		}
		else if(c2[i]==c2[j] && c1[i]==c1[j] && c5[i]==c5[j] && c6[i]==c6[j]){
			if(c4[i]==c4[j] && c3[i]==c3[j]){
				z=z+1;
			}
		}
		else if(c2[i]==c6[j] && c1[i]==c5[j] && c5[i]==c1[j] && c6[i]==c2[j]){
			if(c4[i]==c3[j] && c3[i]==c4[j]){
				z=z+1;
			}
		}
		else if(c6[i]==c6[j] && c5[i]==c5[j] && c1[i]==c1[j] && c2[i]==c2[j]){
			if(c3[i]==c3[j] && c4[i]==c4[j]){
				z=z+1;
			}
		}
		else if(c6[i]==c2[j] && c5[i]==c1[j] && c1[i]==c5[j] && c2[i]==c6[j]){
			if(c3[i]==c4[j] && c4[i]==c3[j]){
				z=z+1;
			}
		}
		}
	}
	printf(""%d\n"",n);
	scanf(""%d"",&n);
	}
	return 0;
}",1
p00198,"立方体の作品
芸術家品川は
n
点の作品を出展するように依頼されました。そこで、立方体の 6 面をペンキで色付けしたものを作品として出展することにしました。作品は、Red、Yellow、Blue、Magenta、Green、Cyan の 6 色全てが使われていて、各面は 1 色で塗りつぶされています。品川は形が同じ立方体の作品でも色の配置の仕方を変え、異なる作品として
n
点作成しました。
彼の友人であるあなたは、友人のよしみで作品を出展前に閲覧させてもらいましたが、そこであることに気が付きました。それらの作品の中に異なる色付けをされているように見えても、実は同じ色の組み合わせをした立方体が存在していたのです。このままでは、
n
点の作品を出展することできなくなってしまいます。
作成した作品の数と各作品の色の情報を入力とし、出展するためにあと何点必要かを出力するプログラムを作成してください。
立方体の各面の色は c1 から c6 までの記号で表され、 以下のような配置となっています。また、c1 から c6 のそれぞれは Red、Yellow、Blue、Magenta、Green、Cyan のいずれか 1 色となります。
Input
複数のデータセットの並びが入力として与えられます。 入力の終わりはゼロひとつの行で示されます。
各データセットは以下の形式で与えられます。
n
cube
1
cube
2
:
cube
n
１行目に作品の数
n
(1 ≤
n
≤ 30)、続く
n
行に
i
番目の作品の情報が与えられます。各作品の情報は次の形式で与えられます。
c1 c2 c3 c4 c5 c6
作品の色の配置 c
i
が空白区切りで与えられます。
データセットの数は 100 を超えません。
Output
データセットごとに、出展するのにあと何点の作品が必要かを１行に出力します。
Sample Input
3
Cyan Yellow Red Magenta Green Blue
Cyan Yellow Red Magenta Green Blue
Red Yellow Magenta Blue Green Cyan
4
Red Magenta Blue Green Yellow Cyan
Red Yellow Magenta Blue Green Cyan
Magenta Green Red Cyan Yellow Blue
Cyan Green Yellow Blue Magenta Red
0
Output for the Sample Input
1
1",Java,"import java.util.*;

public class Main {
    static class Cube {
        String[] faces = new String[6];
        
        Cube(String[] f) {
            faces = f.clone();
        }
        
        // Generate all 24 rotations of the cube
        List<String> getAllRotations() {
            Set<String> rotations = new HashSet<>();
            
            // All 24 orientations of a cube
            int[][] orientations = {
                {0,1,2,3,4,5}, {0,2,4,1,3,5}, {0,3,1,4,2,5}, {0,4,3,2,1,5},
                {1,0,3,2,5,4}, {1,2,0,5,3,4}, {1,3,5,0,2,4}, {1,5,2,3,0,4},
                {2,0,1,4,5,3}, {2,1,5,0,4,3}, {2,4,0,5,1,3}, {2,5,4,1,0,3},
                {3,0,4,1,5,2}, {3,1,0,5,4,2}, {3,4,5,0,1,2}, {3,5,1,4,0,2},
                {4,0,2,3,5,1}, {4,2,5,0,3,1}, {4,3,0,5,2,1}, {4,5,3,2,0,1},
                {5,1,3,2,4,0}, {5,2,1,4,3,0}, {5,3,4,1,2,0}, {5,4,2,3,1,0}
            };
            
            for (int[] orient : orientations) {
                StringBuilder sb = new StringBuilder();
                for (int i = 0; i < 6; i++) {
                    if (i > 0) sb.append("" "");
                    sb.append(faces[orient[i]]);
                }
                rotations.add(sb.toString());
            }
            
            return new ArrayList<>(rotations);
        }
        
        String getCanonical() {
            List<String> rotations = getAllRotations();
            Collections.sort(rotations);
            return rotations.get(0);
        }
    }
    
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        
        while (true) {
            int n = sc.nextInt();
            if (n == 0) break;
            sc.nextLine();
            
            Set<String> uniqueCubes = new HashSet<>();
            
            for (int i = 0; i < n; i++) {
                String[] colors = sc.nextLine().split("" "");
                Cube cube = new Cube(colors);
                String canonical = cube.getCanonical();
                uniqueCubes.add(canonical);
            }
            
            int needed = n - uniqueCubes.size();
            System.out.println(needed);
        }
        
        sc.close();
    }
}
",0
p00198,"立方体の作品
芸術家品川は
n
点の作品を出展するように依頼されました。そこで、立方体の 6 面をペンキで色付けしたものを作品として出展することにしました。作品は、Red、Yellow、Blue、Magenta、Green、Cyan の 6 色全てが使われていて、各面は 1 色で塗りつぶされています。品川は形が同じ立方体の作品でも色の配置の仕方を変え、異なる作品として
n
点作成しました。
彼の友人であるあなたは、友人のよしみで作品を出展前に閲覧させてもらいましたが、そこであることに気が付きました。それらの作品の中に異なる色付けをされているように見えても、実は同じ色の組み合わせをした立方体が存在していたのです。このままでは、
n
点の作品を出展することできなくなってしまいます。
作成した作品の数と各作品の色の情報を入力とし、出展するためにあと何点必要かを出力するプログラムを作成してください。
立方体の各面の色は c1 から c6 までの記号で表され、 以下のような配置となっています。また、c1 から c6 のそれぞれは Red、Yellow、Blue、Magenta、Green、Cyan のいずれか 1 色となります。
Input
複数のデータセットの並びが入力として与えられます。 入力の終わりはゼロひとつの行で示されます。
各データセットは以下の形式で与えられます。
n
cube
1
cube
2
:
cube
n
１行目に作品の数
n
(1 ≤
n
≤ 30)、続く
n
行に
i
番目の作品の情報が与えられます。各作品の情報は次の形式で与えられます。
c1 c2 c3 c4 c5 c6
作品の色の配置 c
i
が空白区切りで与えられます。
データセットの数は 100 を超えません。
Output
データセットごとに、出展するのにあと何点の作品が必要かを１行に出力します。
Sample Input
3
Cyan Yellow Red Magenta Green Blue
Cyan Yellow Red Magenta Green Blue
Red Yellow Magenta Blue Green Cyan
4
Red Magenta Blue Green Yellow Cyan
Red Yellow Magenta Blue Green Cyan
Magenta Green Red Cyan Yellow Blue
Cyan Green Yellow Blue Magenta Red
0
Output for the Sample Input
1
1",Java,"import java.util.*;

public class Main{

    ArrayList<char[]> color,list;
    ArrayList<String> clist;

    void solve(){
        Scanner sc = new Scanner(System.in);

        clist = new ArrayList<String>();
        clist.add(""Red"");
        clist.add(""Yellow"");
        clist.add(""Blue"");
        clist.add(""Magenta"");
        clist.add(""Green"");
        clist.add(""Cyan"");

        while(true){
            int n = sc.nextInt();
            if(n==0) break;

            color = new ArrayList<char[]>();
            int cnt = 0;
            for(int i=0; i<n; i++){
                char[] c = new char[6];
                for(int j=0; j<6; j++) c[j] = (char)clist.indexOf(sc.next());
                if(same(c)) cnt++;
                else color.add(c);
            }

            System.out.println(cnt);
        }
    }

    int[][] rotate = {{1,2,4,3},{0,4,5,1},{0,2,5,3}};

    boolean same(char[] dice){
        list = new ArrayList<char[]>();
        for(int i=0; i<4; i++){
            dice = rotate(dice,0);
            for(int j=0; j<4; j++){
                dice = rotate(dice,1);
                for(int l=0; l<4; l++){
                    dice = rotate(dice,2);
                    list.add(dice);
                }
            }
        }

        for(int i=0; i<list.size(); i++){
            char[] s1 = list.get(i);
            for(int j=0; j<color.size(); j++){
                boolean boo = false;
                char[] s2 = color.get(j);
                for(int k=0; k<6; k++){
                    if(s1[k]!=s2[k]){
                        boo = false;
                        break;
                    }
                    boo = true;
                }
                if(boo) return true;
            }
        }
        return false;
    }

    char[] rotate(char[] dice, int idx){
        char[] res = new char[6];
        for(int i=0; i<6; i++) res[i] = dice[i];

        char tmp = res[rotate[idx][3]];
        for(int i=3; i>0; i--) res[rotate[idx][i]] = res[rotate[idx][i-1]];
        res[rotate[idx][0]] = tmp;
        return res;
    }

    public static void main(String[] args){
        new Main().solve();
    }
}",1
p00198,"立方体の作品
芸術家品川は
n
点の作品を出展するように依頼されました。そこで、立方体の 6 面をペンキで色付けしたものを作品として出展することにしました。作品は、Red、Yellow、Blue、Magenta、Green、Cyan の 6 色全てが使われていて、各面は 1 色で塗りつぶされています。品川は形が同じ立方体の作品でも色の配置の仕方を変え、異なる作品として
n
点作成しました。
彼の友人であるあなたは、友人のよしみで作品を出展前に閲覧させてもらいましたが、そこであることに気が付きました。それらの作品の中に異なる色付けをされているように見えても、実は同じ色の組み合わせをした立方体が存在していたのです。このままでは、
n
点の作品を出展することできなくなってしまいます。
作成した作品の数と各作品の色の情報を入力とし、出展するためにあと何点必要かを出力するプログラムを作成してください。
立方体の各面の色は c1 から c6 までの記号で表され、 以下のような配置となっています。また、c1 から c6 のそれぞれは Red、Yellow、Blue、Magenta、Green、Cyan のいずれか 1 色となります。
Input
複数のデータセットの並びが入力として与えられます。 入力の終わりはゼロひとつの行で示されます。
各データセットは以下の形式で与えられます。
n
cube
1
cube
2
:
cube
n
１行目に作品の数
n
(1 ≤
n
≤ 30)、続く
n
行に
i
番目の作品の情報が与えられます。各作品の情報は次の形式で与えられます。
c1 c2 c3 c4 c5 c6
作品の色の配置 c
i
が空白区切りで与えられます。
データセットの数は 100 を超えません。
Output
データセットごとに、出展するのにあと何点の作品が必要かを１行に出力します。
Sample Input
3
Cyan Yellow Red Magenta Green Blue
Cyan Yellow Red Magenta Green Blue
Red Yellow Magenta Blue Green Cyan
4
Red Magenta Blue Green Yellow Cyan
Red Yellow Magenta Blue Green Cyan
Magenta Green Red Cyan Yellow Blue
Cyan Green Yellow Blue Magenta Red
0
Output for the Sample Input
1
1",Python,"def normalize_cube(colors):
    # Colors: [top, front, right, left, back, bottom]
    # Indices:  0     1      2     3     4      5
    
    # Generate all 24 orientations of the cube
    orientations = []
    
    # Original orientation
    c = colors
    
    # All 24 rotations of a cube
    # 4 rotations with each of the 6 faces as top
    
    def rotate_x(cube):
        # Rotate around x-axis (right face axis) by 90 degrees
        return [cube[1], cube[5], cube[2], cube[3], cube[0], cube[4]]
    
    def rotate_y(cube):
        # Rotate around y-axis (top face axis) by 90 degrees
        return [cube[0], cube[2], cube[4], cube[1], cube[3], cube[5]]
    
    def rotate_z(cube):
        # Rotate around z-axis (front face axis) by 90 degrees
        return [cube[3], cube[1], cube[0], cube[5], cube[4], cube[2]]
    
    # Generate all 24 orientations
    current = colors[:]
    
    for _ in range(4):
        orientations.append(tuple(current))
        for _ in range(3):
            current = rotate_z(current)
            orientations.append(tuple(current))
        current = rotate_y(current)
    
    current = rotate_x(colors[:])
    for _ in range(3):
        current = rotate_z(current)
        orientations.append(tuple(current))
    
    current = rotate_x(rotate_x(rotate_x(colors[:])))
    for _ in range(3):
        current = rotate_z(current)
        orientations.append(tuple(current))
    
    # Return the lexicographically smallest orientation
    return min(orientations)

def get_all_orientations(colors):
    orientations = set()
    
    def rotate_x(cube):
        return [cube[1], cube[5], cube[2], cube[3], cube[0], cube[4]]
    
    def rotate_y(cube):
        return [cube[0], cube[2], cube[4], cube[1], cube[3], cube[5]]
    
    def rotate_z(cube):
        return [cube[3], cube[1], cube[0], cube[5], cube[4], cube[2]]
    
    current = colors[:]
    for _ in range(4):
        orientations.add(tuple(current))
        for _ in range(3):
            current = rotate_z(current)
            orientations.add(tuple(current))
        current = rotate_y(current)
    
    current = rotate_x(colors[:])
    for _ in range(3):
        current = rotate_z(current)
        orientations.add(tuple(current))
    
    current = rotate_x(rotate_x(rotate_x(colors[:])))
    for _ in range(3):
        current = rotate_z(current)
        orientations.add(tuple(current))
    
    return orientations

while True:
    n = int(input())
    if n == 0:
        break
    
    cubes = []
    for _ in range(n):
        colors = input().split()
        cubes.append(colors)
    
    unique_cubes = set()
    
    for cube in cubes:
        canonical = normalize_cube(cube)
        unique_cubes.add(canonical)
    
    needed = n - len(unique_cubes)
    print(needed)
",0
p00198,"立方体の作品
芸術家品川は
n
点の作品を出展するように依頼されました。そこで、立方体の 6 面をペンキで色付けしたものを作品として出展することにしました。作品は、Red、Yellow、Blue、Magenta、Green、Cyan の 6 色全てが使われていて、各面は 1 色で塗りつぶされています。品川は形が同じ立方体の作品でも色の配置の仕方を変え、異なる作品として
n
点作成しました。
彼の友人であるあなたは、友人のよしみで作品を出展前に閲覧させてもらいましたが、そこであることに気が付きました。それらの作品の中に異なる色付けをされているように見えても、実は同じ色の組み合わせをした立方体が存在していたのです。このままでは、
n
点の作品を出展することできなくなってしまいます。
作成した作品の数と各作品の色の情報を入力とし、出展するためにあと何点必要かを出力するプログラムを作成してください。
立方体の各面の色は c1 から c6 までの記号で表され、 以下のような配置となっています。また、c1 から c6 のそれぞれは Red、Yellow、Blue、Magenta、Green、Cyan のいずれか 1 色となります。
Input
複数のデータセットの並びが入力として与えられます。 入力の終わりはゼロひとつの行で示されます。
各データセットは以下の形式で与えられます。
n
cube
1
cube
2
:
cube
n
１行目に作品の数
n
(1 ≤
n
≤ 30)、続く
n
行に
i
番目の作品の情報が与えられます。各作品の情報は次の形式で与えられます。
c1 c2 c3 c4 c5 c6
作品の色の配置 c
i
が空白区切りで与えられます。
データセットの数は 100 を超えません。
Output
データセットごとに、出展するのにあと何点の作品が必要かを１行に出力します。
Sample Input
3
Cyan Yellow Red Magenta Green Blue
Cyan Yellow Red Magenta Green Blue
Red Yellow Magenta Blue Green Cyan
4
Red Magenta Blue Green Yellow Cyan
Red Yellow Magenta Blue Green Cyan
Magenta Green Red Cyan Yellow Blue
Cyan Green Yellow Blue Magenta Red
0
Output for the Sample Input
1
1",Python,"def equal(B):
    temp=B[:]
    S=set()
    for i in range(4):
        for j in range(4):
            for k in range(4):
                roll(0,2,5,3,temp)
                S.add(tuple(temp))
            roll(0,1,5,4,temp)
        roll(1,2,4,3,temp)
    return S

def roll(i,j,k,l,temp):
    t=temp[i]
    temp[i]=temp[j]
    temp[j]=temp[k]
    temp[k]=temp[l]
    temp[l]=t

while True:
    n=input()
    if n==0:break
    L=[raw_input().split() for i in range(n)]
    cnt=0
    for i in range(n-1):
        for j in range(i+1,n):
            S=equal(L[j])
            if tuple(L[i]) in S:
                cnt+=1
    print cnt",1
p00199,"難儀な人たちが座る椅子
4つの国の中心にある中立都市アイズシティには、大陸横断列車バンダイ号のホームがあります。 ホームには、バンダイ号を待つ乗客用の椅子が一列に用意されており、ホームに入ってきた人は自由に椅子を利用することができます。
このバンダイ号、安いし早いし快適ということで、周囲の4つの国からの利用者が絶えません。今日は開通記念日ということで、ホームに座っている人たちに特別なことをしてあげようと思っています。そのためには、改札を通った人たちがどこに座っているか把握しなければなりません。4つの国の人たちの難儀な性格を考慮して、椅子がどのように埋まっているかをシミュレートするプログラムを作成してください。改札を通った人たちは、次々に一列に並んだ椅子に座っていきます。4つの国の人たちは、国ごとに決まった性格と座り方があります。それぞれの座り方は以下の通りです。
A国人の性格
A 国人は座れればいい。左端から見ていき空いている椅子に座る。
B国人の性格
B 国人は A 国人が苦手。 A 国人の隣以外で、右端から空いている椅子に座る。ただし、 A国人の隣しか空いていない場合、我慢して左端から空いている椅子に座る。
C国人の性格
C 国人は人の隣に座りたい。左側から順に座っている人を見ていき、一番左側に座っている人  の右隣に座ろうとするが、そこが埋まっているならその人の左隣に座ろうとする。そこも埋まっ  ているなら次の人の隣に同条件で座ろうとする。どの椅子にも人が座っていなければ真ん中(椅子の数
n
が奇数の場合 (
n
+1)/2 、偶数の場合
n
/2+1 )の椅子に座る。
D国人の性格
D 国人は人の隣に座りたくない。一番近い人との距離が、一番大きくなる椅子に座ろうとする。同条件の椅子が複数ある場合や、どうしても誰かの隣に座らなければならない場合、その中で一番左側にある椅子に座る。誰も座っていない場合は左端の椅子に座る。
バンダイ号に乗ろうとしている乗客の情報を入力とし、 椅子にどのように座っているかを出力するプログラムを作成してください。左から順番に座っている人の国籍を出力します。ただし、空席の場合は # (半角シャープ)を出力してください。
Input
複数のデータセットの並びが入力として与えられます。        入力の終わりはゼロふたつの行で示されます。
各データセットは以下の形式で与えられます。
n
m
a
1
a
2
:
a
m
1 行目に椅子の数
n
(1 ≤
n
≤ 100) と乗客の数
m
(
m
≤
n
) が与えられます。続く
m
行に
i
人目の情報
a
i
が与えられます。
a
i
は１つの文字で、'A' ならば A 国人、'B' ならば B 国人、'C' ならば C 国人、'D' ならば D 国人を表します。
データセットの数は 100 を超えません。
Output
データセットごとに、最終的な椅子の状態を１行に出力します。
Sample Input
5 4
A
B
C
D
5 4
D
C
B
A
0 0
Output for the Sample Input
ACD#B
DCA#B",C,"#include <stdio.h>
#include <string.h>

int main() {
    int n, m;
    
    while(1) {
        scanf(""%d %d"", &n, &m);
        if(n == 0 && m == 0) break;
        
        char seats[101];
        for(int i = 0; i < n; i++) {
            seats[i] = '#';
        }
        
        for(int i = 0; i < m; i++) {
            char type;
            scanf("" %c"", &type);
            
            if(type == 'A') {
                // Left to right, first empty seat
                for(int j = 0; j < n; j++) {
                    if(seats[j] == '#') {
                        seats[j] = 'A';
                        break;
                    }
                }
            }
            else if(type == 'B') {
                // Right to left, not next to A
                int pos = -1;
                for(int j = n-1; j >= 0; j--) {
                    if(seats[j] == '#') {
                        int nextToA = 0;
                        if(j > 0 && seats[j-1] == 'A') nextToA = 1;
                        if(j < n-1 && seats[j+1] == 'A') nextToA = 1;
                        if(!nextToA) {
                            pos = j;
                            break;
                        }
                    }
                }
                if(pos == -1) {
                    // All empty seats are next to A, take leftmost empty
                    for(int j = 0; j < n; j++) {
                        if(seats[j] == '#') {
                            pos = j;
                            break;
                        }
                    }
                }
                seats[pos] = 'B';
            }
            else if(type == 'C') {
                // Next to someone, prefer right then left of leftmost person
                int hasAnyone = 0;
                for(int j = 0; j < n; j++) {
                    if(seats[j] != '#') {
                        hasAnyone = 1;
                        break;
                    }
                }
                
                if(!hasAnyone) {
                    // Sit in middle
                    int mid = (n % 2 == 1) ? (n+1)/2 - 1 : n/2;
                    seats[mid] = 'C';
                } else {
                    int pos = -1;
                    for(int j = 0; j < n; j++) {
                        if(seats[j] != '#') {
                            if(j+1 < n && seats[j+1] == '#') {
                                pos = j+1;
                                break;
                            } else if(j-1 >= 0 && seats[j-1] == '#') {
                                pos = j-1;
                                break;
                            }
                        }
                    }
                    seats[pos] = 'C';
                }
            }
            else if(type == 'D') {
                // Maximize minimum distance to nearest person
                int hasAnyone = 0;
                for(int j = 0; j < n; j++) {
                    if(seats[j] != '#') {
                        hasAnyone = 1;
                        break;
                    }
                }
                
                if(!hasAnyone) {
                    seats[0] = 'D';
                } else {
                    int bestPos = -1;
                    int maxMinDist = -1;
                    
                    for(int j = 0; j < n; j++) {
                        if(seats[j] == '#') {
                            int minDist = n+1;
                            for(int k = 0; k < n; k++) {
                                if(seats[k] != '#') {
                                    int dist = (j > k) ? (j - k) : (k - j);
                                    if(dist < minDist) minDist = dist;
                                }
                            }
                            if(minDist > maxMinDist) {
                                maxMinDist = minDist;
                                bestPos = j;
                            }
                        }
                    }
                    seats[bestPos] = 'D';
                }
            }
        }
        
        for(int i = 0; i < n; i++) {
            printf(""%c"", seats[i]);
        }
        printf(""\n"");
    }
    
    return 0;
}
",0
p00199,"難儀な人たちが座る椅子
4つの国の中心にある中立都市アイズシティには、大陸横断列車バンダイ号のホームがあります。 ホームには、バンダイ号を待つ乗客用の椅子が一列に用意されており、ホームに入ってきた人は自由に椅子を利用することができます。
このバンダイ号、安いし早いし快適ということで、周囲の4つの国からの利用者が絶えません。今日は開通記念日ということで、ホームに座っている人たちに特別なことをしてあげようと思っています。そのためには、改札を通った人たちがどこに座っているか把握しなければなりません。4つの国の人たちの難儀な性格を考慮して、椅子がどのように埋まっているかをシミュレートするプログラムを作成してください。改札を通った人たちは、次々に一列に並んだ椅子に座っていきます。4つの国の人たちは、国ごとに決まった性格と座り方があります。それぞれの座り方は以下の通りです。
A国人の性格
A 国人は座れればいい。左端から見ていき空いている椅子に座る。
B国人の性格
B 国人は A 国人が苦手。 A 国人の隣以外で、右端から空いている椅子に座る。ただし、 A国人の隣しか空いていない場合、我慢して左端から空いている椅子に座る。
C国人の性格
C 国人は人の隣に座りたい。左側から順に座っている人を見ていき、一番左側に座っている人  の右隣に座ろうとするが、そこが埋まっているならその人の左隣に座ろうとする。そこも埋まっ  ているなら次の人の隣に同条件で座ろうとする。どの椅子にも人が座っていなければ真ん中(椅子の数
n
が奇数の場合 (
n
+1)/2 、偶数の場合
n
/2+1 )の椅子に座る。
D国人の性格
D 国人は人の隣に座りたくない。一番近い人との距離が、一番大きくなる椅子に座ろうとする。同条件の椅子が複数ある場合や、どうしても誰かの隣に座らなければならない場合、その中で一番左側にある椅子に座る。誰も座っていない場合は左端の椅子に座る。
バンダイ号に乗ろうとしている乗客の情報を入力とし、 椅子にどのように座っているかを出力するプログラムを作成してください。左から順番に座っている人の国籍を出力します。ただし、空席の場合は # (半角シャープ)を出力してください。
Input
複数のデータセットの並びが入力として与えられます。        入力の終わりはゼロふたつの行で示されます。
各データセットは以下の形式で与えられます。
n
m
a
1
a
2
:
a
m
1 行目に椅子の数
n
(1 ≤
n
≤ 100) と乗客の数
m
(
m
≤
n
) が与えられます。続く
m
行に
i
人目の情報
a
i
が与えられます。
a
i
は１つの文字で、'A' ならば A 国人、'B' ならば B 国人、'C' ならば C 国人、'D' ならば D 国人を表します。
データセットの数は 100 を超えません。
Output
データセットごとに、最終的な椅子の状態を１行に出力します。
Sample Input
5 4
A
B
C
D
5 4
D
C
B
A
0 0
Output for the Sample Input
ACD#B
DCA#B",C,"n,m,p;
char s[2],c[101];
A(){
	for(p=0;c[p]!='#';p++);
}
B(){
	for(p=n-1;p>=0;p--)
		if(c[p]=='#'&&(p+1==n||c[p+1]!='A')&&(p-1<0||c[p-1]!='A'))
			return;
	A();
}
C(){
	for(p=0;p<n;p++){
		if(c[p]!='#'){
			if(p+1!=n&&c[p+1]=='#'){
				p++;
				return;
			}
			if(p-1>=0&&c[p-1]=='#'){
				p--;
				return;
			}
		}
	}
	p=n/2;
}
D(){
	int D[100],d=n,q;
	for(p=-1;++p<n;){
		d++;
		if(c[p]!='#')
			d=0;
		D[p]=d;
	}
	for(d=0;--p>=0;){
		d++;
		if(c[p]!='#')
			d=0;
		if(d<D[p])
			D[p]=d;
	}
	for(p=q=0;q<n;q++)
		if(D[q]>D[p])
			p=q;
}
main(){
	for(;scanf(""%d%d"",&n,&m),n;){
		memset(c,'#',100);
		c[n]=0;
		for(;m--;){
			scanf(""%s"",s);
			if(s[0]=='A')
				A();
			if(s[0]=='B')
				B();
			if(s[0]=='C')
				C();
			if(s[0]=='D')
				D();
			c[p]=s[0];
		}
		puts(c);
	}
	exit(0);
}",1
p00199,"難儀な人たちが座る椅子
4つの国の中心にある中立都市アイズシティには、大陸横断列車バンダイ号のホームがあります。 ホームには、バンダイ号を待つ乗客用の椅子が一列に用意されており、ホームに入ってきた人は自由に椅子を利用することができます。
このバンダイ号、安いし早いし快適ということで、周囲の4つの国からの利用者が絶えません。今日は開通記念日ということで、ホームに座っている人たちに特別なことをしてあげようと思っています。そのためには、改札を通った人たちがどこに座っているか把握しなければなりません。4つの国の人たちの難儀な性格を考慮して、椅子がどのように埋まっているかをシミュレートするプログラムを作成してください。改札を通った人たちは、次々に一列に並んだ椅子に座っていきます。4つの国の人たちは、国ごとに決まった性格と座り方があります。それぞれの座り方は以下の通りです。
A国人の性格
A 国人は座れればいい。左端から見ていき空いている椅子に座る。
B国人の性格
B 国人は A 国人が苦手。 A 国人の隣以外で、右端から空いている椅子に座る。ただし、 A国人の隣しか空いていない場合、我慢して左端から空いている椅子に座る。
C国人の性格
C 国人は人の隣に座りたい。左側から順に座っている人を見ていき、一番左側に座っている人  の右隣に座ろうとするが、そこが埋まっているならその人の左隣に座ろうとする。そこも埋まっ  ているなら次の人の隣に同条件で座ろうとする。どの椅子にも人が座っていなければ真ん中(椅子の数
n
が奇数の場合 (
n
+1)/2 、偶数の場合
n
/2+1 )の椅子に座る。
D国人の性格
D 国人は人の隣に座りたくない。一番近い人との距離が、一番大きくなる椅子に座ろうとする。同条件の椅子が複数ある場合や、どうしても誰かの隣に座らなければならない場合、その中で一番左側にある椅子に座る。誰も座っていない場合は左端の椅子に座る。
バンダイ号に乗ろうとしている乗客の情報を入力とし、 椅子にどのように座っているかを出力するプログラムを作成してください。左から順番に座っている人の国籍を出力します。ただし、空席の場合は # (半角シャープ)を出力してください。
Input
複数のデータセットの並びが入力として与えられます。        入力の終わりはゼロふたつの行で示されます。
各データセットは以下の形式で与えられます。
n
m
a
1
a
2
:
a
m
1 行目に椅子の数
n
(1 ≤
n
≤ 100) と乗客の数
m
(
m
≤
n
) が与えられます。続く
m
行に
i
人目の情報
a
i
が与えられます。
a
i
は１つの文字で、'A' ならば A 国人、'B' ならば B 国人、'C' ならば C 国人、'D' ならば D 国人を表します。
データセットの数は 100 を超えません。
Output
データセットごとに、最終的な椅子の状態を１行に出力します。
Sample Input
5 4
A
B
C
D
5 4
D
C
B
A
0 0
Output for the Sample Input
ACD#B
DCA#B",Java,"import java.util.*;

public class Main {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        
        while (true) {
            int n = sc.nextInt();
            int m = sc.nextInt();
            
            if (n == 0 && m == 0) break;
            
            char[] chairs = new char[n];
            Arrays.fill(chairs, '#');
            
            for (int i = 0; i < m; i++) {
                String nationality = sc.next();
                char person = nationality.charAt(0);
                
                if (person == 'A') {
                    // Left to right, first empty chair
                    for (int j = 0; j < n; j++) {
                        if (chairs[j] == '#') {
                            chairs[j] = 'A';
                            break;
                        }
                    }
                } else if (person == 'B') {
                    // Right to left, not next to A
                    boolean found = false;
                    for (int j = n - 1; j >= 0; j--) {
                        if (chairs[j] == '#') {
                            boolean nextToA = false;
                            if (j > 0 && chairs[j - 1] == 'A') nextToA = true;
                            if (j < n - 1 && chairs[j + 1] == 'A') nextToA = true;
                            
                            if (!nextToA) {
                                chairs[j] = 'B';
                                found = true;
                                break;
                            }
                        }
                    }
                    
                    if (!found) {
                        // Must sit next to A, left to right
                        for (int j = 0; j < n; j++) {
                            if (chairs[j] == '#') {
                                chairs[j] = 'B';
                                break;
                            }
                        }
                    }
                } else if (person == 'C') {
                    // Next to someone, prefer right then left
                    boolean found = false;
                    
                    // Check if anyone is sitting
                    boolean anyoneSeated = false;
                    for (int j = 0; j < n; j++) {
                        if (chairs[j] != '#') {
                            anyoneSeated = true;
                            break;
                        }
                    }
                    
                    if (!anyoneSeated) {
                        // Sit in middle
                        int middle = (n % 2 == 1) ? n / 2 : n / 2;
                        chairs[middle] = 'C';
                    } else {
                        // Find leftmost person and try right, then left
                        for (int j = 0; j < n; j++) {
                            if (chairs[j] != '#') {
                                // Try right
                                if (j + 1 < n && chairs[j + 1] == '#') {
                                    chairs[j + 1] = 'C';
                                    found = true;
                                    break;
                                }
                                // Try left
                                if (j - 1 >= 0 && chairs[j - 1] == '#') {
                                    chairs[j - 1] = 'C';
                                    found = true;
                                    break;
                                }
                            }
                        }
                    }
                } else if (person == 'D') {
                    // Maximize minimum distance
                    boolean anyoneSeated = false;
                    for (int j = 0; j < n; j++) {
                        if (chairs[j] != '#') {
                            anyoneSeated = true;
                            break;
                        }
                    }
                    
                    if (!anyoneSeated) {
                        chairs[0] = 'D';
                    } else {
                        int bestPos = -1;
                        int maxMinDist = -1;
                        
                        for (int j = 0; j < n; j++) {
                            if (chairs[j] == '#') {
                                int minDist = Integer.MAX_VALUE;
                                
                                for (int k = 0; k < n; k++) {
                                    if (chairs[k] != '#') {
                                        minDist = Math.min(minDist, Math.abs(j - k));
                                    }
                                }
                                
                                if (minDist > maxMinDist) {
                                    maxMinDist = minDist;
                                    bestPos = j;
                                }
                            }
                        }
                        
                        chairs[bestPos] = 'D';
                    }
                }
            }
            
            System.out.println(new String(chairs));
        }
        
        sc.close();
    }
}
",0
p00199,"難儀な人たちが座る椅子
4つの国の中心にある中立都市アイズシティには、大陸横断列車バンダイ号のホームがあります。 ホームには、バンダイ号を待つ乗客用の椅子が一列に用意されており、ホームに入ってきた人は自由に椅子を利用することができます。
このバンダイ号、安いし早いし快適ということで、周囲の4つの国からの利用者が絶えません。今日は開通記念日ということで、ホームに座っている人たちに特別なことをしてあげようと思っています。そのためには、改札を通った人たちがどこに座っているか把握しなければなりません。4つの国の人たちの難儀な性格を考慮して、椅子がどのように埋まっているかをシミュレートするプログラムを作成してください。改札を通った人たちは、次々に一列に並んだ椅子に座っていきます。4つの国の人たちは、国ごとに決まった性格と座り方があります。それぞれの座り方は以下の通りです。
A国人の性格
A 国人は座れればいい。左端から見ていき空いている椅子に座る。
B国人の性格
B 国人は A 国人が苦手。 A 国人の隣以外で、右端から空いている椅子に座る。ただし、 A国人の隣しか空いていない場合、我慢して左端から空いている椅子に座る。
C国人の性格
C 国人は人の隣に座りたい。左側から順に座っている人を見ていき、一番左側に座っている人  の右隣に座ろうとするが、そこが埋まっているならその人の左隣に座ろうとする。そこも埋まっ  ているなら次の人の隣に同条件で座ろうとする。どの椅子にも人が座っていなければ真ん中(椅子の数
n
が奇数の場合 (
n
+1)/2 、偶数の場合
n
/2+1 )の椅子に座る。
D国人の性格
D 国人は人の隣に座りたくない。一番近い人との距離が、一番大きくなる椅子に座ろうとする。同条件の椅子が複数ある場合や、どうしても誰かの隣に座らなければならない場合、その中で一番左側にある椅子に座る。誰も座っていない場合は左端の椅子に座る。
バンダイ号に乗ろうとしている乗客の情報を入力とし、 椅子にどのように座っているかを出力するプログラムを作成してください。左から順番に座っている人の国籍を出力します。ただし、空席の場合は # (半角シャープ)を出力してください。
Input
複数のデータセットの並びが入力として与えられます。        入力の終わりはゼロふたつの行で示されます。
各データセットは以下の形式で与えられます。
n
m
a
1
a
2
:
a
m
1 行目に椅子の数
n
(1 ≤
n
≤ 100) と乗客の数
m
(
m
≤
n
) が与えられます。続く
m
行に
i
人目の情報
a
i
が与えられます。
a
i
は１つの文字で、'A' ならば A 国人、'B' ならば B 国人、'C' ならば C 国人、'D' ならば D 国人を表します。
データセットの数は 100 を超えません。
Output
データセットごとに、最終的な椅子の状態を１行に出力します。
Sample Input
5 4
A
B
C
D
5 4
D
C
B
A
0 0
Output for the Sample Input
ACD#B
DCA#B",Java,"import java.util.*;

public class Main {
	
	public static void main(String[] args) {
		Scanner sc = new Scanner(System.in);
		
		while(true){
			int n = sc.nextInt();
			int m = sc.nextInt();
			if(n==0 && m==0) break;
			
			char[] a = new char[n+2];
			Arrays.fill(a,'#');
			a[0] = 'X';
			a[n+1] = 'X';
			for(int i=0;i<m;i++){
				char c = sc.next().charAt(0);
				if(c=='A'){
					for(int j=1;j<=n;j++){
						if(a[j]=='#'){
							a[j] = c;
							break;
						}
					}
				}else if(c=='B'){
					boolean flag = true;
					for(int j=n;j>0;j--){
						if(a[j]=='#' && a[j-1]!='A' && a[j+1]!='A'){
							a[j] = c;
							flag = false;
							break;
						}
					}
					if(flag==true){
						for(int j=1;j<=n;j++){
							if(a[j]=='#'){
								a[j] = c;
								break;
							}
						}
					}
				}else if(c=='C'){
					if(i==0){
						if(n%2==0) a[(n+1)/2] = c;
						else a[n/2+1] = c;
					}else{
						for(int j=1;j<=n;j++){
							if(a[j]!='#'){
								if(a[j+1]=='#'){
									a[j+1] = c;
									break;
								}
								if(a[j-1]=='#'){
									a[j-1] = c;
									break;
								}
							}
						}
					}
				}else if(c=='D'){
					if(i==0){
						a[1] = c;
					}else{
						int max = -1;
						int p = -1;
						for(int j=1;j<=n;j++){
							if(a[j]=='#'){
								int min = Integer.MAX_VALUE;
								for(int k=j-1;k>=0;k--){
									if(k==0) break;
									if(a[k]!='#'){
										min = Math.min(min, j-k+1);
										break;
									}
								}
								for(int k=j+1;k<=n+1;k++){
									if(k==n+1) break;
									if(a[k]!='#'){
										min = Math.min(min, k-j+1);
										break;
									}
								}
								if(min>max){
									max = min;
									p = j;
								}
							}
						}
						a[p] = c;
					}
				}
			}
			for(int i=1;i<=n;i++) System.out.print(a[i]);
			System.out.println();
		}
	}
}",1
p00199,"難儀な人たちが座る椅子
4つの国の中心にある中立都市アイズシティには、大陸横断列車バンダイ号のホームがあります。 ホームには、バンダイ号を待つ乗客用の椅子が一列に用意されており、ホームに入ってきた人は自由に椅子を利用することができます。
このバンダイ号、安いし早いし快適ということで、周囲の4つの国からの利用者が絶えません。今日は開通記念日ということで、ホームに座っている人たちに特別なことをしてあげようと思っています。そのためには、改札を通った人たちがどこに座っているか把握しなければなりません。4つの国の人たちの難儀な性格を考慮して、椅子がどのように埋まっているかをシミュレートするプログラムを作成してください。改札を通った人たちは、次々に一列に並んだ椅子に座っていきます。4つの国の人たちは、国ごとに決まった性格と座り方があります。それぞれの座り方は以下の通りです。
A国人の性格
A 国人は座れればいい。左端から見ていき空いている椅子に座る。
B国人の性格
B 国人は A 国人が苦手。 A 国人の隣以外で、右端から空いている椅子に座る。ただし、 A国人の隣しか空いていない場合、我慢して左端から空いている椅子に座る。
C国人の性格
C 国人は人の隣に座りたい。左側から順に座っている人を見ていき、一番左側に座っている人  の右隣に座ろうとするが、そこが埋まっているならその人の左隣に座ろうとする。そこも埋まっ  ているなら次の人の隣に同条件で座ろうとする。どの椅子にも人が座っていなければ真ん中(椅子の数
n
が奇数の場合 (
n
+1)/2 、偶数の場合
n
/2+1 )の椅子に座る。
D国人の性格
D 国人は人の隣に座りたくない。一番近い人との距離が、一番大きくなる椅子に座ろうとする。同条件の椅子が複数ある場合や、どうしても誰かの隣に座らなければならない場合、その中で一番左側にある椅子に座る。誰も座っていない場合は左端の椅子に座る。
バンダイ号に乗ろうとしている乗客の情報を入力とし、 椅子にどのように座っているかを出力するプログラムを作成してください。左から順番に座っている人の国籍を出力します。ただし、空席の場合は # (半角シャープ)を出力してください。
Input
複数のデータセットの並びが入力として与えられます。        入力の終わりはゼロふたつの行で示されます。
各データセットは以下の形式で与えられます。
n
m
a
1
a
2
:
a
m
1 行目に椅子の数
n
(1 ≤
n
≤ 100) と乗客の数
m
(
m
≤
n
) が与えられます。続く
m
行に
i
人目の情報
a
i
が与えられます。
a
i
は１つの文字で、'A' ならば A 国人、'B' ならば B 国人、'C' ならば C 国人、'D' ならば D 国人を表します。
データセットの数は 100 を超えません。
Output
データセットごとに、最終的な椅子の状態を１行に出力します。
Sample Input
5 4
A
B
C
D
5 4
D
C
B
A
0 0
Output for the Sample Input
ACD#B
DCA#B",Python,"import sys

def solve(n, m, passengers):
    seats = ['#'] * n  # 0-indexed
    
    for passenger in passengers:
        if passenger == 'A':
            # Left to right, first empty
            for i in range(n):
                if seats[i] == '#':
                    seats[i] = 'A'
                    break
                    
        elif passenger == 'B':
            # Avoid A, right to left
            # First try to find seat not adjacent to A
            found = False
            for i in range(n-1, -1, -1):
                if seats[i] == '#':
                    # Check if adjacent to A
                    adjacent_to_a = False
                    if i > 0 and seats[i-1] == 'A':
                        adjacent_to_a = True
                    if i < n-1 and seats[i+1] == 'A':
                        adjacent_to_a = True
                    
                    if not adjacent_to_a:
                        seats[i] = 'B'
                        found = True
                        break
            
            # If not found, sit left to right (adjacent to A is ok)
            if not found:
                for i in range(n):
                    if seats[i] == '#':
                        seats[i] = 'B'
                        break
                        
        elif passenger == 'C':
            # Sit next to someone
            # Find leftmost person, try right then left
            found = False
            
            # Check if anyone is seated
            someone_seated = any(s != '#' for s in seats)
            
            if someone_seated:
                for i in range(n):
                    if seats[i] != '#':
                        # Try right
                        if i < n-1 and seats[i+1] == '#':
                            seats[i+1] = 'C'
                            found = True
                            break
                        # Try left
                        elif i > 0 and seats[i-1] == '#':
                            seats[i-1] = 'C'
                            found = True
                            break
            
            if not found:
                # Sit in middle
                if n % 2 == 1:
                    mid = n // 2
                else:
                    mid = n // 2
                seats[mid] = 'C'
                
        elif passenger == 'D':
            # Maximize minimum distance
            # If no one seated, sit at left end
            someone_seated = any(s != '#' for s in seats)
            
            if not someone_seated:
                seats[0] = 'D'
            else:
                # Find empty seat with max min distance
                best_seat = -1
                best_min_dist = -1
                
                for i in range(n):
                    if seats[i] == '#':
                        # Calculate min distance to any occupied seat
                        min_dist = float('inf')
                        for j in range(n):
                            if seats[j] != '#':
                                min_dist = min(min_dist, abs(i - j))
                        
                        if min_dist > best_min_dist:
                            best_min_dist = min_dist
                            best_seat = i
                
                seats[best_seat] = 'D'
    
    return ''.join(seats)

# Read input
lines = []
for line in sys.stdin:
    lines.append(line.strip())

i = 0
while i < len(lines):
    parts = lines[i].split()
    n, m = int(parts[0]), int(parts[1])
    
    if n == 0 and m == 0:
        break
    
    i += 1
    passengers = []
    for j in range(m):
        passengers.append(lines[i])
        i += 1
    
    result = solve(n, m, passengers)
    print(result)
",0
p00199,"難儀な人たちが座る椅子
4つの国の中心にある中立都市アイズシティには、大陸横断列車バンダイ号のホームがあります。 ホームには、バンダイ号を待つ乗客用の椅子が一列に用意されており、ホームに入ってきた人は自由に椅子を利用することができます。
このバンダイ号、安いし早いし快適ということで、周囲の4つの国からの利用者が絶えません。今日は開通記念日ということで、ホームに座っている人たちに特別なことをしてあげようと思っています。そのためには、改札を通った人たちがどこに座っているか把握しなければなりません。4つの国の人たちの難儀な性格を考慮して、椅子がどのように埋まっているかをシミュレートするプログラムを作成してください。改札を通った人たちは、次々に一列に並んだ椅子に座っていきます。4つの国の人たちは、国ごとに決まった性格と座り方があります。それぞれの座り方は以下の通りです。
A国人の性格
A 国人は座れればいい。左端から見ていき空いている椅子に座る。
B国人の性格
B 国人は A 国人が苦手。 A 国人の隣以外で、右端から空いている椅子に座る。ただし、 A国人の隣しか空いていない場合、我慢して左端から空いている椅子に座る。
C国人の性格
C 国人は人の隣に座りたい。左側から順に座っている人を見ていき、一番左側に座っている人  の右隣に座ろうとするが、そこが埋まっているならその人の左隣に座ろうとする。そこも埋まっ  ているなら次の人の隣に同条件で座ろうとする。どの椅子にも人が座っていなければ真ん中(椅子の数
n
が奇数の場合 (
n
+1)/2 、偶数の場合
n
/2+1 )の椅子に座る。
D国人の性格
D 国人は人の隣に座りたくない。一番近い人との距離が、一番大きくなる椅子に座ろうとする。同条件の椅子が複数ある場合や、どうしても誰かの隣に座らなければならない場合、その中で一番左側にある椅子に座る。誰も座っていない場合は左端の椅子に座る。
バンダイ号に乗ろうとしている乗客の情報を入力とし、 椅子にどのように座っているかを出力するプログラムを作成してください。左から順番に座っている人の国籍を出力します。ただし、空席の場合は # (半角シャープ)を出力してください。
Input
複数のデータセットの並びが入力として与えられます。        入力の終わりはゼロふたつの行で示されます。
各データセットは以下の形式で与えられます。
n
m
a
1
a
2
:
a
m
1 行目に椅子の数
n
(1 ≤
n
≤ 100) と乗客の数
m
(
m
≤
n
) が与えられます。続く
m
行に
i
人目の情報
a
i
が与えられます。
a
i
は１つの文字で、'A' ならば A 国人、'B' ならば B 国人、'C' ならば C 国人、'D' ならば D 国人を表します。
データセットの数は 100 を超えません。
Output
データセットごとに、最終的な椅子の状態を１行に出力します。
Sample Input
5 4
A
B
C
D
5 4
D
C
B
A
0 0
Output for the Sample Input
ACD#B
DCA#B",Python,"INF = 10 ** 20

while True:
  n, m = map(int, input().split())
  if not n:
    break

  chairs = list(""#"" * n)

  def sit(s):
    if s == ""A"":
      chairs[chairs.index(""#"")] = ""A""
    elif s == ""B"":
      for i in range(n - 1, -1, -1):
        if chairs[i] == ""#"" and (i == 0 or chairs[i - 1] != ""A"") and (i == n - 1 or chairs[i + 1] != ""A""):
          chairs[i] = ""B""
          break
      else:
        chairs[chairs.index(""#"")] = ""B""

    elif s == ""C"":
      for i in range(1, n):
        if chairs[i] == ""#"" and chairs[i - 1] != ""#"":
          chairs[i] = ""C""
          break

    else:
      score = [INF for _ in range(n)]
      dist = INF
      for i in range(n):
        if chairs[i] == ""#"":
          dist += 1
        else:
          dist = 0
        score[i] = dist

      dist = INF
      for i in range(n - 1, -1, -1):
        if chairs[i] == ""#"":
          dist += 1
        else:
          dist = 0
        score[i] = min(score[i], dist)
      high_score = max(score)
      chairs[score.index(high_score)] = ""D""
  
  first = input()
  if first in [""A"", ""D""]:
    chairs[0] = first
  elif first == ""B"":
    chairs[-1] = ""B""
  else:
    chairs[n // 2] = ""C""
  for _ in range(m - 1):
    sit(input())

  print("""".join(chairs))

",1
p00200,"青春の片道切符
太郎君は夏休みに電車で長旅をする計画を立てています。しかし高校生の身である太郎君が一ヵ月しかない夏休みで可能な限り遠くに旅をするには、出来るだけ安い行き方と出来るだけ早い行き方をそれぞれ見つけなければうまく計画が立てられません。太郎君が素敵な旅を満喫できるように、太郎君の計画の助けになるプログラムを作ってあげましょう。
線路の情報、駅の数を入力とし、問い合わせに応じて、最小金額または最短時間を出力するプログラムを作成してください。
Input
複数のデータセットの並びが入力として与えられます。入力の終わりはゼロふたつの行で示されます。各データセットは以下の形式で与えられます。
n
m
a
1
b
1
cost
1
time
1
a
2
b
2
cost
2
time
2
:
a
n
b
n
cost
n
time
n
k
p
1
q
1
r
1
p
2
q
2
r
2
:
p
k
q
k
r
k
1 行目に線路の情報の数
n
(1 ≤
n
≤ 3000)と駅の数
m
(1 ≤
m
≤ 100) が与えられます。
続く
n
行に
i
番目の路線の情報が与えられます。各路線の情報として、路線がつなぐ２つの駅の番号
a
i
,
b
i
(1 ≤
a
i
,
b
i
≤
m
)、料金
cost
i
(1 ≤
cost
i
≤ 1000)、移動時間
time
i
(1 ≤
time
i
≤ 1000) が与えられます。ただし、各駅は 1 から
m
まで順番に番号が付けられているものとします。
なお、
a
i
と
b
i
が線路でつながっていれば、
a
i
から
b
i
、
b
i
から
a
i
の両方の移動が同じ料金と時間で可能とします。
続く行に問い合わせの数
k
(1 ≤
k
≤ 200) が与えられます。続く
k
行に
i
番目の問い合わせが与えられます。各問合わせとして、出発駅
p
i
、到着駅
q
i
、出力する値の種類
r
i
(0 または 1)が与えられます。なお、問い合わせには必ず経路があるものとします。
データセットの数は 50 を超えない。
Output
データセットごとに、最小金額もしくは最短時間を１行に出力します。
r
i
が 0 の時は最小金額を、 1 の時は最短時間を出力します。
Sample Input
6 5
1 2 200 10
1 4 400 15
1 3 250 25
2 4 100 10
4 5 150 20
3 5 300 20
2
1 5 0
1 5 1
0 0
Output for the Sample Input
450
35",C,"#include <stdio.h>
#include <string.h>
#include <limits.h>

#define MAX_M 105
#define INF 1000000000

int n, m, k;
int cost_graph[MAX_M][MAX_M];
int time_graph[MAX_M][MAX_M];

int dijkstra(int graph[MAX_M][MAX_M], int start, int end) {
    int dist[MAX_M];
    int visited[MAX_M];
    int i, j;
    
    for (i = 1; i <= m; i++) {
        dist[i] = INF;
        visited[i] = 0;
    }
    
    dist[start] = 0;
    
    for (i = 0; i < m; i++) {
        int min_dist = INF;
        int u = -1;
        
        for (j = 1; j <= m; j++) {
            if (!visited[j] && dist[j] < min_dist) {
                min_dist = dist[j];
                u = j;
            }
        }
        
        if (u == -1) break;
        
        visited[u] = 1;
        
        for (j = 1; j <= m; j++) {
            if (!visited[j] && graph[u][j] != INF) {
                if (dist[u] + graph[u][j] < dist[j]) {
                    dist[j] = dist[u] + graph[u][j];
                }
            }
        }
    }
    
    return dist[end];
}

int main() {
    while (1) {
        scanf(""%d %d"", &n, &m);
        if (n == 0 && m == 0) break;
        
        int i, j;
        
        for (i = 1; i <= m; i++) {
            for (j = 1; j <= m; j++) {
                if (i == j) {
                    cost_graph[i][j] = 0;
                    time_graph[i][j] = 0;
                } else {
                    cost_graph[i][j] = INF;
                    time_graph[i][j] = INF;
                }
            }
        }
        
        for (i = 0; i < n; i++) {
            int a, b, cost, time;
            scanf(""%d %d %d %d"", &a, &b, &cost, &time);
            
            if (cost < cost_graph[a][b]) {
                cost_graph[a][b] = cost;
                cost_graph[b][a] = cost;
            }
            
            if (time < time_graph[a][b]) {
                time_graph[a][b] = time;
                time_graph[b][a] = time;
            }
        }
        
        scanf(""%d"", &k);
        
        for (i = 0; i < k; i++) {
            int p, q, r;
            scanf(""%d %d %d"", &p, &q, &r);
            
            if (r == 0) {
                printf(""%d\n"", dijkstra(cost_graph, p, q));
            } else {
                printf(""%d\n"", dijkstra(time_graph, p, q));
            }
        }
    }
    
    return 0;
}
",0
p00200,"青春の片道切符
太郎君は夏休みに電車で長旅をする計画を立てています。しかし高校生の身である太郎君が一ヵ月しかない夏休みで可能な限り遠くに旅をするには、出来るだけ安い行き方と出来るだけ早い行き方をそれぞれ見つけなければうまく計画が立てられません。太郎君が素敵な旅を満喫できるように、太郎君の計画の助けになるプログラムを作ってあげましょう。
線路の情報、駅の数を入力とし、問い合わせに応じて、最小金額または最短時間を出力するプログラムを作成してください。
Input
複数のデータセットの並びが入力として与えられます。入力の終わりはゼロふたつの行で示されます。各データセットは以下の形式で与えられます。
n
m
a
1
b
1
cost
1
time
1
a
2
b
2
cost
2
time
2
:
a
n
b
n
cost
n
time
n
k
p
1
q
1
r
1
p
2
q
2
r
2
:
p
k
q
k
r
k
1 行目に線路の情報の数
n
(1 ≤
n
≤ 3000)と駅の数
m
(1 ≤
m
≤ 100) が与えられます。
続く
n
行に
i
番目の路線の情報が与えられます。各路線の情報として、路線がつなぐ２つの駅の番号
a
i
,
b
i
(1 ≤
a
i
,
b
i
≤
m
)、料金
cost
i
(1 ≤
cost
i
≤ 1000)、移動時間
time
i
(1 ≤
time
i
≤ 1000) が与えられます。ただし、各駅は 1 から
m
まで順番に番号が付けられているものとします。
なお、
a
i
と
b
i
が線路でつながっていれば、
a
i
から
b
i
、
b
i
から
a
i
の両方の移動が同じ料金と時間で可能とします。
続く行に問い合わせの数
k
(1 ≤
k
≤ 200) が与えられます。続く
k
行に
i
番目の問い合わせが与えられます。各問合わせとして、出発駅
p
i
、到着駅
q
i
、出力する値の種類
r
i
(0 または 1)が与えられます。なお、問い合わせには必ず経路があるものとします。
データセットの数は 50 を超えない。
Output
データセットごとに、最小金額もしくは最短時間を１行に出力します。
r
i
が 0 の時は最小金額を、 1 の時は最短時間を出力します。
Sample Input
6 5
1 2 200 10
1 4 400 15
1 3 250 25
2 4 100 10
4 5 150 20
3 5 300 20
2
1 5 0
1 5 1
0 0
Output for the Sample Input
450
35",C,"#include<stdio.h>
int main(){
  int i,j,k,l,n,m;
  int d[2][100][100]={0};
  while(scanf(""%d %d"",&m,&n),n||m){
    for(i=0;i<100;i++){
      for(j=0;j<100;j++)d[0][i][j]=d[1][i][j]=100000000;
      d[0][i][i]=d[1][i][i]=0;
    }
    while(m--){
      scanf(""%d %d %d %d"",&i,&j,&k,&l);
      d[0][i-1][j-1]=d[0][j-1][i-1]=k;
      d[1][i-1][j-1]=d[1][j-1][i-1]=l;
    }
    for(l=0;l<n;l++){
      //for(i=0;i<2;i++){
      for(j=0;j<n;j++){
	for(k=0;k<n;k++){
	  //for(l=0;l<n;l++){
	  for(i=0;i<2;i++){
	    if(d[i][j][k]>d[i][j][l]+d[i][l][k]){
	       d[i][j][k]=d[i][j][l]+d[i][l][k];
	    }
	  }
	}
      }
    }
    scanf(""%d"",&l);
    while(l--){
      scanf(""%d %d %d"",&i,&j,&k);
      printf(""%d\n"",d[k][i-1][j-1]);
    }
  }
  return 0;
}
      ",1
p00200,"青春の片道切符
太郎君は夏休みに電車で長旅をする計画を立てています。しかし高校生の身である太郎君が一ヵ月しかない夏休みで可能な限り遠くに旅をするには、出来るだけ安い行き方と出来るだけ早い行き方をそれぞれ見つけなければうまく計画が立てられません。太郎君が素敵な旅を満喫できるように、太郎君の計画の助けになるプログラムを作ってあげましょう。
線路の情報、駅の数を入力とし、問い合わせに応じて、最小金額または最短時間を出力するプログラムを作成してください。
Input
複数のデータセットの並びが入力として与えられます。入力の終わりはゼロふたつの行で示されます。各データセットは以下の形式で与えられます。
n
m
a
1
b
1
cost
1
time
1
a
2
b
2
cost
2
time
2
:
a
n
b
n
cost
n
time
n
k
p
1
q
1
r
1
p
2
q
2
r
2
:
p
k
q
k
r
k
1 行目に線路の情報の数
n
(1 ≤
n
≤ 3000)と駅の数
m
(1 ≤
m
≤ 100) が与えられます。
続く
n
行に
i
番目の路線の情報が与えられます。各路線の情報として、路線がつなぐ２つの駅の番号
a
i
,
b
i
(1 ≤
a
i
,
b
i
≤
m
)、料金
cost
i
(1 ≤
cost
i
≤ 1000)、移動時間
time
i
(1 ≤
time
i
≤ 1000) が与えられます。ただし、各駅は 1 から
m
まで順番に番号が付けられているものとします。
なお、
a
i
と
b
i
が線路でつながっていれば、
a
i
から
b
i
、
b
i
から
a
i
の両方の移動が同じ料金と時間で可能とします。
続く行に問い合わせの数
k
(1 ≤
k
≤ 200) が与えられます。続く
k
行に
i
番目の問い合わせが与えられます。各問合わせとして、出発駅
p
i
、到着駅
q
i
、出力する値の種類
r
i
(0 または 1)が与えられます。なお、問い合わせには必ず経路があるものとします。
データセットの数は 50 を超えない。
Output
データセットごとに、最小金額もしくは最短時間を１行に出力します。
r
i
が 0 の時は最小金額を、 1 の時は最短時間を出力します。
Sample Input
6 5
1 2 200 10
1 4 400 15
1 3 250 25
2 4 100 10
4 5 150 20
3 5 300 20
2
1 5 0
1 5 1
0 0
Output for the Sample Input
450
35",Java,"import java.util.*;

public class Main {
    static class Edge {
        int to, cost, time;
        Edge(int to, int cost, int time) {
            this.to = to;
            this.cost = cost;
            this.time = time;
        }
    }
    
    static class State implements Comparable<State> {
        int node, value;
        State(int node, int value) {
            this.node = node;
            this.value = value;
        }
        public int compareTo(State other) {
            return this.value - other.value;
        }
    }
    
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        
        while (true) {
            int n = sc.nextInt();
            int m = sc.nextInt();
            
            if (n == 0 && m == 0) break;
            
            List<Edge>[] graph = new ArrayList[m + 1];
            for (int i = 0; i <= m; i++) {
                graph[i] = new ArrayList<>();
            }
            
            for (int i = 0; i < n; i++) {
                int a = sc.nextInt();
                int b = sc.nextInt();
                int cost = sc.nextInt();
                int time = sc.nextInt();
                graph[a].add(new Edge(b, cost, time));
                graph[b].add(new Edge(a, cost, time));
            }
            
            int k = sc.nextInt();
            for (int i = 0; i < k; i++) {
                int p = sc.nextInt();
                int q = sc.nextInt();
                int r = sc.nextInt();
                
                if (r == 0) {
                    System.out.println(dijkstra(graph, m, p, q, true));
                } else {
                    System.out.println(dijkstra(graph, m, p, q, false));
                }
            }
        }
        sc.close();
    }
    
    static int dijkstra(List<Edge>[] graph, int m, int start, int end, boolean useCost) {
        int[] dist = new int[m + 1];
        Arrays.fill(dist, Integer.MAX_VALUE);
        dist[start] = 0;
        
        PriorityQueue<State> pq = new PriorityQueue<>();
        pq.offer(new State(start, 0));
        
        while (!pq.isEmpty()) {
            State current = pq.poll();
            int u = current.node;
            int d = current.value;
            
            if (d > dist[u]) continue;
            
            for (Edge edge : graph[u]) {
                int v = edge.to;
                int weight = useCost ? edge.cost : edge.time;
                
                if (dist[u] + weight < dist[v]) {
                    dist[v] = dist[u] + weight;
                    pq.offer(new State(v, dist[v]));
                }
            }
        }
        
        return dist[end];
    }
}
",0
p00200,"青春の片道切符
太郎君は夏休みに電車で長旅をする計画を立てています。しかし高校生の身である太郎君が一ヵ月しかない夏休みで可能な限り遠くに旅をするには、出来るだけ安い行き方と出来るだけ早い行き方をそれぞれ見つけなければうまく計画が立てられません。太郎君が素敵な旅を満喫できるように、太郎君の計画の助けになるプログラムを作ってあげましょう。
線路の情報、駅の数を入力とし、問い合わせに応じて、最小金額または最短時間を出力するプログラムを作成してください。
Input
複数のデータセットの並びが入力として与えられます。入力の終わりはゼロふたつの行で示されます。各データセットは以下の形式で与えられます。
n
m
a
1
b
1
cost
1
time
1
a
2
b
2
cost
2
time
2
:
a
n
b
n
cost
n
time
n
k
p
1
q
1
r
1
p
2
q
2
r
2
:
p
k
q
k
r
k
1 行目に線路の情報の数
n
(1 ≤
n
≤ 3000)と駅の数
m
(1 ≤
m
≤ 100) が与えられます。
続く
n
行に
i
番目の路線の情報が与えられます。各路線の情報として、路線がつなぐ２つの駅の番号
a
i
,
b
i
(1 ≤
a
i
,
b
i
≤
m
)、料金
cost
i
(1 ≤
cost
i
≤ 1000)、移動時間
time
i
(1 ≤
time
i
≤ 1000) が与えられます。ただし、各駅は 1 から
m
まで順番に番号が付けられているものとします。
なお、
a
i
と
b
i
が線路でつながっていれば、
a
i
から
b
i
、
b
i
から
a
i
の両方の移動が同じ料金と時間で可能とします。
続く行に問い合わせの数
k
(1 ≤
k
≤ 200) が与えられます。続く
k
行に
i
番目の問い合わせが与えられます。各問合わせとして、出発駅
p
i
、到着駅
q
i
、出力する値の種類
r
i
(0 または 1)が与えられます。なお、問い合わせには必ず経路があるものとします。
データセットの数は 50 を超えない。
Output
データセットごとに、最小金額もしくは最短時間を１行に出力します。
r
i
が 0 の時は最小金額を、 1 の時は最短時間を出力します。
Sample Input
6 5
1 2 200 10
1 4 400 15
1 3 250 25
2 4 100 10
4 5 150 20
3 5 300 20
2
1 5 0
1 5 1
0 0
Output for the Sample Input
450
35",Java,"import java.util.Arrays;
import java.util.Scanner;

public class Main {
	static final int INF = 1000000000;
	public static void main(String[] args) {
		// TODO Auto-generated method stub
		Scanner sc = new Scanner(System.in);
		
		while(true){
			int n = sc.nextInt();
			int m = sc.nextInt();
			if(n == 0 && m == 0){
				break;
			}
			
			int[][] cost = new int[m][m];
			int[][] time = new int[m][m];
			for(int i = 0; i < m; i++){
				for(int j = 0; j < m; j++){
					cost[i][j] = INF;
					time[i][j] = INF;
				}
			}
			for(int i = 0; i < n; i++){
				int a = sc.nextInt() - 1;
				int b = sc.nextInt() - 1;
				cost[a][b] = sc.nextInt();
				cost[b][a] = cost[a][b];
				time[a][b] = sc.nextInt();
				time[b][a] = time[a][b];
			}
			for(int k = 0; k < m; k++){
				for(int i = 0; i < m; i++){
					for(int j = i; j < m; j++){
						cost[i][j] = Math.min(cost[i][j], cost[i][k] + cost[k][j]);
						cost[j][i] = cost[i][j];
						time[i][j] = Math.min(time[i][j], time[i][k] + time[k][j]);
						time[j][i] = time[i][j];
					}
				}
			}
			int k = sc.nextInt();
			for(int i = 0; i < k; i++){
				int p = sc.nextInt() - 1;
				int q = sc.nextInt() - 1;
				int r = sc.nextInt();
				if(r == 0){
					System.out.println(cost[p][q]);
				}else if(r == 1){
					System.out.println(time[p][q]);
				}
			}
		}
		
		sc.close();
	}

}",1
p00200,"青春の片道切符
太郎君は夏休みに電車で長旅をする計画を立てています。しかし高校生の身である太郎君が一ヵ月しかない夏休みで可能な限り遠くに旅をするには、出来るだけ安い行き方と出来るだけ早い行き方をそれぞれ見つけなければうまく計画が立てられません。太郎君が素敵な旅を満喫できるように、太郎君の計画の助けになるプログラムを作ってあげましょう。
線路の情報、駅の数を入力とし、問い合わせに応じて、最小金額または最短時間を出力するプログラムを作成してください。
Input
複数のデータセットの並びが入力として与えられます。入力の終わりはゼロふたつの行で示されます。各データセットは以下の形式で与えられます。
n
m
a
1
b
1
cost
1
time
1
a
2
b
2
cost
2
time
2
:
a
n
b
n
cost
n
time
n
k
p
1
q
1
r
1
p
2
q
2
r
2
:
p
k
q
k
r
k
1 行目に線路の情報の数
n
(1 ≤
n
≤ 3000)と駅の数
m
(1 ≤
m
≤ 100) が与えられます。
続く
n
行に
i
番目の路線の情報が与えられます。各路線の情報として、路線がつなぐ２つの駅の番号
a
i
,
b
i
(1 ≤
a
i
,
b
i
≤
m
)、料金
cost
i
(1 ≤
cost
i
≤ 1000)、移動時間
time
i
(1 ≤
time
i
≤ 1000) が与えられます。ただし、各駅は 1 から
m
まで順番に番号が付けられているものとします。
なお、
a
i
と
b
i
が線路でつながっていれば、
a
i
から
b
i
、
b
i
から
a
i
の両方の移動が同じ料金と時間で可能とします。
続く行に問い合わせの数
k
(1 ≤
k
≤ 200) が与えられます。続く
k
行に
i
番目の問い合わせが与えられます。各問合わせとして、出発駅
p
i
、到着駅
q
i
、出力する値の種類
r
i
(0 または 1)が与えられます。なお、問い合わせには必ず経路があるものとします。
データセットの数は 50 を超えない。
Output
データセットごとに、最小金額もしくは最短時間を１行に出力します。
r
i
が 0 の時は最小金額を、 1 の時は最短時間を出力します。
Sample Input
6 5
1 2 200 10
1 4 400 15
1 3 250 25
2 4 100 10
4 5 150 20
3 5 300 20
2
1 5 0
1 5 1
0 0
Output for the Sample Input
450
35",Python,"import heapq
from collections import defaultdict
import sys

def dijkstra(graph, start, end, mode):
    # mode: 0 for cost, 1 for time
    pq = [(0, start)]
    visited = set()
    dist = defaultdict(lambda: float('inf'))
    dist[start] = 0
    
    while pq:
        current_dist, node = heapq.heappop(pq)
        
        if node in visited:
            continue
            
        visited.add(node)
        
        if node == end:
            return current_dist
        
        for neighbor, cost, time in graph[node]:
            weight = cost if mode == 0 else time
            new_dist = current_dist + weight
            
            if new_dist < dist[neighbor]:
                dist[neighbor] = new_dist
                heapq.heappush(pq, (new_dist, neighbor))
    
    return dist[end]

while True:
    line = sys.stdin.readline().strip()
    if not line:
        break
    n = int(line)
    m = int(sys.stdin.readline().strip())
    
    if n == 0 and m == 0:
        break
    
    graph = defaultdict(list)
    
    for _ in range(n):
        parts = list(map(int, sys.stdin.readline().strip().split()))
        a, b, cost, time = parts[0], parts[1], parts[2], parts[3]
        graph[a].append((b, cost, time))
        graph[b].append((a, cost, time))
    
    k = int(sys.stdin.readline().strip())
    
    for _ in range(k):
        parts = list(map(int, sys.stdin.readline().strip().split()))
        p, q, r = parts[0], parts[1], parts[2]
        result = dijkstra(graph, p, q, r)
        print(result)
",0
p00200,"青春の片道切符
太郎君は夏休みに電車で長旅をする計画を立てています。しかし高校生の身である太郎君が一ヵ月しかない夏休みで可能な限り遠くに旅をするには、出来るだけ安い行き方と出来るだけ早い行き方をそれぞれ見つけなければうまく計画が立てられません。太郎君が素敵な旅を満喫できるように、太郎君の計画の助けになるプログラムを作ってあげましょう。
線路の情報、駅の数を入力とし、問い合わせに応じて、最小金額または最短時間を出力するプログラムを作成してください。
Input
複数のデータセットの並びが入力として与えられます。入力の終わりはゼロふたつの行で示されます。各データセットは以下の形式で与えられます。
n
m
a
1
b
1
cost
1
time
1
a
2
b
2
cost
2
time
2
:
a
n
b
n
cost
n
time
n
k
p
1
q
1
r
1
p
2
q
2
r
2
:
p
k
q
k
r
k
1 行目に線路の情報の数
n
(1 ≤
n
≤ 3000)と駅の数
m
(1 ≤
m
≤ 100) が与えられます。
続く
n
行に
i
番目の路線の情報が与えられます。各路線の情報として、路線がつなぐ２つの駅の番号
a
i
,
b
i
(1 ≤
a
i
,
b
i
≤
m
)、料金
cost
i
(1 ≤
cost
i
≤ 1000)、移動時間
time
i
(1 ≤
time
i
≤ 1000) が与えられます。ただし、各駅は 1 から
m
まで順番に番号が付けられているものとします。
なお、
a
i
と
b
i
が線路でつながっていれば、
a
i
から
b
i
、
b
i
から
a
i
の両方の移動が同じ料金と時間で可能とします。
続く行に問い合わせの数
k
(1 ≤
k
≤ 200) が与えられます。続く
k
行に
i
番目の問い合わせが与えられます。各問合わせとして、出発駅
p
i
、到着駅
q
i
、出力する値の種類
r
i
(0 または 1)が与えられます。なお、問い合わせには必ず経路があるものとします。
データセットの数は 50 を超えない。
Output
データセットごとに、最小金額もしくは最短時間を１行に出力します。
r
i
が 0 の時は最小金額を、 1 の時は最短時間を出力します。
Sample Input
6 5
1 2 200 10
1 4 400 15
1 3 250 25
2 4 100 10
4 5 150 20
3 5 300 20
2
1 5 0
1 5 1
0 0
Output for the Sample Input
450
35",Python,"
from copy import deepcopy
INF = 1000000000
def dj(s, e, r):
  d = [INF] * 100
  done = [0] * 100
  d[s] = 0
  while True:
    v = -1
    for i in VL:
      if not done[i] and (v == -1 or d[i] < d[v]):
        v = i
    if v == e:
      return d[e]
    done[v] = True
    for i in VL:
      d[i] = min(d[i], d[v] + cost[v][i][r])

L100 = range(100)
costPre = [[[INF for k in range(2)] for j in L100] for i in L100]
while True:
  E, V = map(int, raw_input().split())
  cost = deepcopy(costPre)
  VL = range(V)
  if not E:
    break
  for i in range(E):
    a, b, c, d = map(int, raw_input().split())
    a -= 1
    b -= 1
    cost[a][b][0] = cost[b][a][0] = c
    cost[a][b][1] = cost[b][a][1] = d
  k = input()
  for i in range(k):
    p, q, r = map(int, raw_input().split())
    p -= 1
    q -= 1
    print dj(p, q, r)",1
p00201,"錬金マスター
あなたはついに魔法の釜、錬金釜を手に入れました。錬金釜に複数のアイテムを入れると、新しいア イテムを作ることができます。新しく作ったアイテムは、他のアイテムを作るために錬金釜へ入れることもできます。アイテムを作るために必要なアイテムのリストを記したものを錬金レシピと呼ぶことにします。以下の 3 つは錬金レシピの例です。
木片と糸でラケットができる。
お米と水でおにぎりができる。
ラケットとマイクとおにぎりでギターができる。
アイテムはお金を使って手にいれることもできますが、錬金釜で作った方が安くすむ場合もあります。例えば、各アイテムの購入価格が以下のように与えられているとします。
アイテム名
購入価格(円)
木片
3,000
糸
800
お米
36
水
0
ラケット
5,000
マイク
9,800
おにぎり
140
ギター
98,000
ラケットは 5,000 円で購入できますが、木片と糸を購入して錬金すれば 3,800 円で手に入れられます。更に、錬金を重ねることによりとてもお得にアイテムを手に入れられます。図 1 は上記 3 つの錬金レシピ例を組み合わせたものです。ギターは 98,000 円で購入できますが、木片、糸、お米、水、マイクを購入して錬金すれば、たったの 13,636 円で手に入れられます。
図 1
あなたは冒険を楽に進めるため、なるべく安く目的のアイテムを手に入れようと考えました。 アイテムのリスト、錬金レシピのリスト、指定されたアイテムを入力とし、指定されたアイテムを作るために必要な金額の最小値を出力するプログラムを作成して下さい。
各アイテムの数量に限りはないものとします。アイテムは複数のレシピに使われることがありますが、1 つのアイテムを作るためのレシピはたかだか 1 つです。また、あるアイテムを起点としてレシピをたどっていったとき、そのアイテムが再びレシピに現れることはありません。
Input
複数のデータセットの並びが入力として与えられます。入力の終わりはゼロひとつの行で示されます。各データセットは以下の形式で与えられます。
n
s
1
p
1
s
2
p
2
:
s
n
p
n
m
o
1
k
1
q
1
q
2
...
q
k
1
o
2
k
2
q
1
q
2
...
q
k
2
:
o
m
k
m
q
1
q
2
...
q
k
m
t
1 行目にリストに含まれるアイテムの種類数
n
(1 ≤
n
≤ 100) が与えられます。続く
n
行に
i
番目のアイテムの名前
s
i
(1 文字以上 100 文字以下のアルファベットからなる半角文字列) とそれを購入する場合の値段
p
i
(0 ≤
p
i
≤ 1000000)が与えられます。
続く行に錬金レシピの数
m
(0 ≤
m
≤ 100) が与えられます。続く
m
行に
i
番目のレシピの情報が与えられます。各レシピとして、アイテムの名前
o
i
、それを作るために必要なアイテムの個数
k
i
(1 ≤
k
i
≤ 100) 、
k
i
個のアイテム名
q
1
,
q
2
...
q
k
i
が与えられます。
最後の行に指定されたアイテム名
t
が与えられます。
データセットの数は 30 を超えません。
Output
入力データセットごとに、最小の値段を１行に出力します。
Sample Input
8
wood 3000
string 800
rice 36
water 0
racket 5000
microphone 9800
onigiri 140
guitar 98000
3
racket 2 wood string
onigiri 2 rice water
guitar 3 racket microphone onigiri
guitar
1
computer 300000
0
computer
0
Output for the Sample Input
13636
300000",C,"#include <stdio.h>
#include <string.h>
#include <stdlib.h>

#define MAX_ITEMS 100
#define MAX_NAME 101

typedef struct {
    char name[MAX_NAME];
    int price;
    int has_recipe;
    int num_ingredients;
    int ingredients[MAX_ITEMS];
} Item;

Item items[MAX_ITEMS];
int n, m;
int memo[MAX_ITEMS];
int computed[MAX_ITEMS];

int find_item(char *name) {
    for (int i = 0; i < n; i++) {
        if (strcmp(items[i].name, name) == 0) {
            return i;
        }
    }
    return -1;
}

int min_cost(int idx) {
    if (computed[idx]) {
        return memo[idx];
    }
    
    computed[idx] = 1;
    int buy_cost = items[idx].price;
    
    if (!items[idx].has_recipe) {
        memo[idx] = buy_cost;
        return buy_cost;
    }
    
    int craft_cost = 0;
    for (int i = 0; i < items[idx].num_ingredients; i++) {
        craft_cost += min_cost(items[idx].ingredients[i]);
    }
    
    memo[idx] = (buy_cost < craft_cost) ? buy_cost : craft_cost;
    return memo[idx];
}

int main() {
    while (1) {
        scanf(""%d"", &n);
        if (n == 0) break;
        
        for (int i = 0; i < n; i++) {
            scanf(""%s %d"", items[i].name, &items[i].price);
            items[i].has_recipe = 0;
            items[i].num_ingredients = 0;
            computed[i] = 0;
        }
        
        scanf(""%d"", &m);
        for (int i = 0; i < m; i++) {
            char output[MAX_NAME];
            int k;
            scanf(""%s %d"", output, &k);
            
            int out_idx = find_item(output);
            items[out_idx].has_recipe = 1;
            items[out_idx].num_ingredients = k;
            
            for (int j = 0; j < k; j++) {
                char ingredient[MAX_NAME];
                scanf(""%s"", ingredient);
                int ing_idx = find_item(ingredient);
                items[out_idx].ingredients[j] = ing_idx;
            }
        }
        
        char target[MAX_NAME];
        scanf(""%s"", target);
        int target_idx = find_item(target);
        
        printf(""%d\n"", min_cost(target_idx));
    }
    
    return 0;
}
",0
p00201,"錬金マスター
あなたはついに魔法の釜、錬金釜を手に入れました。錬金釜に複数のアイテムを入れると、新しいア イテムを作ることができます。新しく作ったアイテムは、他のアイテムを作るために錬金釜へ入れることもできます。アイテムを作るために必要なアイテムのリストを記したものを錬金レシピと呼ぶことにします。以下の 3 つは錬金レシピの例です。
木片と糸でラケットができる。
お米と水でおにぎりができる。
ラケットとマイクとおにぎりでギターができる。
アイテムはお金を使って手にいれることもできますが、錬金釜で作った方が安くすむ場合もあります。例えば、各アイテムの購入価格が以下のように与えられているとします。
アイテム名
購入価格(円)
木片
3,000
糸
800
お米
36
水
0
ラケット
5,000
マイク
9,800
おにぎり
140
ギター
98,000
ラケットは 5,000 円で購入できますが、木片と糸を購入して錬金すれば 3,800 円で手に入れられます。更に、錬金を重ねることによりとてもお得にアイテムを手に入れられます。図 1 は上記 3 つの錬金レシピ例を組み合わせたものです。ギターは 98,000 円で購入できますが、木片、糸、お米、水、マイクを購入して錬金すれば、たったの 13,636 円で手に入れられます。
図 1
あなたは冒険を楽に進めるため、なるべく安く目的のアイテムを手に入れようと考えました。 アイテムのリスト、錬金レシピのリスト、指定されたアイテムを入力とし、指定されたアイテムを作るために必要な金額の最小値を出力するプログラムを作成して下さい。
各アイテムの数量に限りはないものとします。アイテムは複数のレシピに使われることがありますが、1 つのアイテムを作るためのレシピはたかだか 1 つです。また、あるアイテムを起点としてレシピをたどっていったとき、そのアイテムが再びレシピに現れることはありません。
Input
複数のデータセットの並びが入力として与えられます。入力の終わりはゼロひとつの行で示されます。各データセットは以下の形式で与えられます。
n
s
1
p
1
s
2
p
2
:
s
n
p
n
m
o
1
k
1
q
1
q
2
...
q
k
1
o
2
k
2
q
1
q
2
...
q
k
2
:
o
m
k
m
q
1
q
2
...
q
k
m
t
1 行目にリストに含まれるアイテムの種類数
n
(1 ≤
n
≤ 100) が与えられます。続く
n
行に
i
番目のアイテムの名前
s
i
(1 文字以上 100 文字以下のアルファベットからなる半角文字列) とそれを購入する場合の値段
p
i
(0 ≤
p
i
≤ 1000000)が与えられます。
続く行に錬金レシピの数
m
(0 ≤
m
≤ 100) が与えられます。続く
m
行に
i
番目のレシピの情報が与えられます。各レシピとして、アイテムの名前
o
i
、それを作るために必要なアイテムの個数
k
i
(1 ≤
k
i
≤ 100) 、
k
i
個のアイテム名
q
1
,
q
2
...
q
k
i
が与えられます。
最後の行に指定されたアイテム名
t
が与えられます。
データセットの数は 30 を超えません。
Output
入力データセットごとに、最小の値段を１行に出力します。
Sample Input
8
wood 3000
string 800
rice 36
water 0
racket 5000
microphone 9800
onigiri 140
guitar 98000
3
racket 2 wood string
onigiri 2 rice water
guitar 3 racket microphone onigiri
guitar
1
computer 300000
0
computer
0
Output for the Sample Input
13636
300000",C,"// Aizu Vol-2 0201: Wrought Gold Master
// 2017.8.17 bal4u@uu
// ??¢?????????????????????????????\????????????????????£?????????

#include <stdio.h>
#include <string.h>

#define HSIZ 499
typedef struct { char *w; int k; } HASH;
HASH hash[HSIZ + 5];

int lookup(char *w)
{
	int i, l;
	HASH *tp;
	i = (101 * *w + 103 * *(w + (l = strlen(w)) - 1) + 107 * l) % HSIZ;
	tp = hash + i;
	if (tp->w != NULL) {
		int inc = *w + (*(w + 1) << 1);
		while (1) {
			if (!strcmp(tp->w, w)) return tp->k;
			i += inc; if (i >= HSIZ) i -= HSIZ;
			tp = hash + i;
			if (tp->w == NULL) break;
		}
	}
	return -1;
}

int insert(char *w, int k)
{
	int i, l;
	HASH *tp;
	i = (101 * *w + 103 * *(w + (l = strlen(w)) - 1) + 107 * l) % HSIZ;
	tp = hash + i;
	if (tp->w != NULL) {
		int inc = *w + (*(w + 1) << 1);
		while (1) {
			if (!strcmp(tp->w, w)) return -1;
			i += inc; if (i >= HSIZ) i -= HSIZ;
			tp = hash + i;
			if (tp->w == NULL) break;
		}
	}
	tp->w = w, tp->k = k;
	return 0;
}

typedef struct { char a[102]; int m, k, i[102]; } MONO;
MONO mono[205]; int no;

int combi(int a)
{
	int i, k, c = -1;
	k = mono[a].k;
	if (k > 0) for (c = i = 0; i < k; i++) c += combi(mono[a].i[i]);
	if (c < 0 || (mono[a].m >= 0 && mono[a].m < c)) c = mono[a].m;
	return c;
}

int main()
{
	int i, j, k, N, M;
	char b[102];

	while (scanf(""%d"", &N) == 1 && N) {
		memset(hash, 0, sizeof(hash)), no = 0;
		while (N-- > 0) {
			scanf(""%s%d"", mono[no].a, &(mono[no].m));
			mono[no].k = 0; insert(mono[no].a, no);
			no++;
		}
		scanf(""%d"", &M);
		while (M--) {
			scanf(""%s%d"", mono[no].a, &k);
			if ((i = lookup(mono[no].a)) < 0) insert(mono[no].a, no), mono[no].m = -1, i = no++;
			mono[i].k = k;
			for (j = 0; j < mono[i].k; j++) scanf(""%s"", b), mono[i].i[j] = lookup(b);
		}
		scanf(""%s"", b);
		printf(""%d\n"", combi(lookup(b)));
	}
	return 0;
}",1
p00201,"錬金マスター
あなたはついに魔法の釜、錬金釜を手に入れました。錬金釜に複数のアイテムを入れると、新しいア イテムを作ることができます。新しく作ったアイテムは、他のアイテムを作るために錬金釜へ入れることもできます。アイテムを作るために必要なアイテムのリストを記したものを錬金レシピと呼ぶことにします。以下の 3 つは錬金レシピの例です。
木片と糸でラケットができる。
お米と水でおにぎりができる。
ラケットとマイクとおにぎりでギターができる。
アイテムはお金を使って手にいれることもできますが、錬金釜で作った方が安くすむ場合もあります。例えば、各アイテムの購入価格が以下のように与えられているとします。
アイテム名
購入価格(円)
木片
3,000
糸
800
お米
36
水
0
ラケット
5,000
マイク
9,800
おにぎり
140
ギター
98,000
ラケットは 5,000 円で購入できますが、木片と糸を購入して錬金すれば 3,800 円で手に入れられます。更に、錬金を重ねることによりとてもお得にアイテムを手に入れられます。図 1 は上記 3 つの錬金レシピ例を組み合わせたものです。ギターは 98,000 円で購入できますが、木片、糸、お米、水、マイクを購入して錬金すれば、たったの 13,636 円で手に入れられます。
図 1
あなたは冒険を楽に進めるため、なるべく安く目的のアイテムを手に入れようと考えました。 アイテムのリスト、錬金レシピのリスト、指定されたアイテムを入力とし、指定されたアイテムを作るために必要な金額の最小値を出力するプログラムを作成して下さい。
各アイテムの数量に限りはないものとします。アイテムは複数のレシピに使われることがありますが、1 つのアイテムを作るためのレシピはたかだか 1 つです。また、あるアイテムを起点としてレシピをたどっていったとき、そのアイテムが再びレシピに現れることはありません。
Input
複数のデータセットの並びが入力として与えられます。入力の終わりはゼロひとつの行で示されます。各データセットは以下の形式で与えられます。
n
s
1
p
1
s
2
p
2
:
s
n
p
n
m
o
1
k
1
q
1
q
2
...
q
k
1
o
2
k
2
q
1
q
2
...
q
k
2
:
o
m
k
m
q
1
q
2
...
q
k
m
t
1 行目にリストに含まれるアイテムの種類数
n
(1 ≤
n
≤ 100) が与えられます。続く
n
行に
i
番目のアイテムの名前
s
i
(1 文字以上 100 文字以下のアルファベットからなる半角文字列) とそれを購入する場合の値段
p
i
(0 ≤
p
i
≤ 1000000)が与えられます。
続く行に錬金レシピの数
m
(0 ≤
m
≤ 100) が与えられます。続く
m
行に
i
番目のレシピの情報が与えられます。各レシピとして、アイテムの名前
o
i
、それを作るために必要なアイテムの個数
k
i
(1 ≤
k
i
≤ 100) 、
k
i
個のアイテム名
q
1
,
q
2
...
q
k
i
が与えられます。
最後の行に指定されたアイテム名
t
が与えられます。
データセットの数は 30 を超えません。
Output
入力データセットごとに、最小の値段を１行に出力します。
Sample Input
8
wood 3000
string 800
rice 36
water 0
racket 5000
microphone 9800
onigiri 140
guitar 98000
3
racket 2 wood string
onigiri 2 rice water
guitar 3 racket microphone onigiri
guitar
1
computer 300000
0
computer
0
Output for the Sample Input
13636
300000",Java,"import java.util.*;

public class Main {
    static Map<String, Integer> itemPrice;
    static Map<String, List<String>> recipes;
    static Map<String, Integer> memo;
    
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        
        while (true) {
            int n = sc.nextInt();
            if (n == 0) break;
            
            itemPrice = new HashMap<>();
            recipes = new HashMap<>();
            memo = new HashMap<>();
            
            for (int i = 0; i < n; i++) {
                String name = sc.next();
                int price = sc.nextInt();
                itemPrice.put(name, price);
            }
            
            int m = sc.nextInt();
            for (int i = 0; i < m; i++) {
                String output = sc.next();
                int k = sc.nextInt();
                List<String> inputs = new ArrayList<>();
                for (int j = 0; j < k; j++) {
                    inputs.add(sc.next());
                }
                recipes.put(output, inputs);
            }
            
            String target = sc.next();
            System.out.println(getMinCost(target));
        }
        
        sc.close();
    }
    
    static int getMinCost(String item) {
        if (memo.containsKey(item)) {
            return memo.get(item);
        }
        
        int buyPrice = itemPrice.get(item);
        int minCost = buyPrice;
        
        if (recipes.containsKey(item)) {
            List<String> ingredients = recipes.get(item);
            int craftCost = 0;
            for (String ingredient : ingredients) {
                craftCost += getMinCost(ingredient);
            }
            minCost = Math.min(minCost, craftCost);
        }
        
        memo.put(item, minCost);
        return minCost;
    }
}
",0
p00201,"錬金マスター
あなたはついに魔法の釜、錬金釜を手に入れました。錬金釜に複数のアイテムを入れると、新しいア イテムを作ることができます。新しく作ったアイテムは、他のアイテムを作るために錬金釜へ入れることもできます。アイテムを作るために必要なアイテムのリストを記したものを錬金レシピと呼ぶことにします。以下の 3 つは錬金レシピの例です。
木片と糸でラケットができる。
お米と水でおにぎりができる。
ラケットとマイクとおにぎりでギターができる。
アイテムはお金を使って手にいれることもできますが、錬金釜で作った方が安くすむ場合もあります。例えば、各アイテムの購入価格が以下のように与えられているとします。
アイテム名
購入価格(円)
木片
3,000
糸
800
お米
36
水
0
ラケット
5,000
マイク
9,800
おにぎり
140
ギター
98,000
ラケットは 5,000 円で購入できますが、木片と糸を購入して錬金すれば 3,800 円で手に入れられます。更に、錬金を重ねることによりとてもお得にアイテムを手に入れられます。図 1 は上記 3 つの錬金レシピ例を組み合わせたものです。ギターは 98,000 円で購入できますが、木片、糸、お米、水、マイクを購入して錬金すれば、たったの 13,636 円で手に入れられます。
図 1
あなたは冒険を楽に進めるため、なるべく安く目的のアイテムを手に入れようと考えました。 アイテムのリスト、錬金レシピのリスト、指定されたアイテムを入力とし、指定されたアイテムを作るために必要な金額の最小値を出力するプログラムを作成して下さい。
各アイテムの数量に限りはないものとします。アイテムは複数のレシピに使われることがありますが、1 つのアイテムを作るためのレシピはたかだか 1 つです。また、あるアイテムを起点としてレシピをたどっていったとき、そのアイテムが再びレシピに現れることはありません。
Input
複数のデータセットの並びが入力として与えられます。入力の終わりはゼロひとつの行で示されます。各データセットは以下の形式で与えられます。
n
s
1
p
1
s
2
p
2
:
s
n
p
n
m
o
1
k
1
q
1
q
2
...
q
k
1
o
2
k
2
q
1
q
2
...
q
k
2
:
o
m
k
m
q
1
q
2
...
q
k
m
t
1 行目にリストに含まれるアイテムの種類数
n
(1 ≤
n
≤ 100) が与えられます。続く
n
行に
i
番目のアイテムの名前
s
i
(1 文字以上 100 文字以下のアルファベットからなる半角文字列) とそれを購入する場合の値段
p
i
(0 ≤
p
i
≤ 1000000)が与えられます。
続く行に錬金レシピの数
m
(0 ≤
m
≤ 100) が与えられます。続く
m
行に
i
番目のレシピの情報が与えられます。各レシピとして、アイテムの名前
o
i
、それを作るために必要なアイテムの個数
k
i
(1 ≤
k
i
≤ 100) 、
k
i
個のアイテム名
q
1
,
q
2
...
q
k
i
が与えられます。
最後の行に指定されたアイテム名
t
が与えられます。
データセットの数は 30 を超えません。
Output
入力データセットごとに、最小の値段を１行に出力します。
Sample Input
8
wood 3000
string 800
rice 36
water 0
racket 5000
microphone 9800
onigiri 140
guitar 98000
3
racket 2 wood string
onigiri 2 rice water
guitar 3 racket microphone onigiri
guitar
1
computer 300000
0
computer
0
Output for the Sample Input
13636
300000",Java,"import java.util.*;

public class Main{
	public static void main(String[] args){
		Scanner sc = new Scanner(System.in);

		while(true){
			int n = sc.nextInt();
			if(n == 0) break;

			price = new HashMap<String,Integer>();
			while(n-- > 0){
				price.put(sc.next(),sc.nextInt());
			}

			n = sc.nextInt();
			map = new HashMap<String,ArrayList<String>>();
			while(n-- > 0){
				String s = sc.next();
				int m = sc.nextInt();
				map.put(s,new ArrayList<String>());
				while(m-- > 0){
					map.get(s).add(sc.next());
				}
			}

			dp = new HashMap<String,Integer>();
			System.out.println(minCost(sc.next()));
		}
	}

	private static HashMap<String,Integer> price;
	private static HashMap<String,ArrayList<String>> map;
	private static HashMap<String,Integer> dp;

	private static int minCost(String s){
		if(map.get(s) == null) return price.get(s);
		if(dp.get(s) != null) return dp.get(s);

		int sum = 0;

		for(String tmp : map.get(s)){
			sum += minCost(tmp);
		}

		dp.put(s, price.get(s) == null ? sum : Math.min(sum,price.get(s)));

		return dp.get(s);
	}
}",1
p00201,"錬金マスター
あなたはついに魔法の釜、錬金釜を手に入れました。錬金釜に複数のアイテムを入れると、新しいア イテムを作ることができます。新しく作ったアイテムは、他のアイテムを作るために錬金釜へ入れることもできます。アイテムを作るために必要なアイテムのリストを記したものを錬金レシピと呼ぶことにします。以下の 3 つは錬金レシピの例です。
木片と糸でラケットができる。
お米と水でおにぎりができる。
ラケットとマイクとおにぎりでギターができる。
アイテムはお金を使って手にいれることもできますが、錬金釜で作った方が安くすむ場合もあります。例えば、各アイテムの購入価格が以下のように与えられているとします。
アイテム名
購入価格(円)
木片
3,000
糸
800
お米
36
水
0
ラケット
5,000
マイク
9,800
おにぎり
140
ギター
98,000
ラケットは 5,000 円で購入できますが、木片と糸を購入して錬金すれば 3,800 円で手に入れられます。更に、錬金を重ねることによりとてもお得にアイテムを手に入れられます。図 1 は上記 3 つの錬金レシピ例を組み合わせたものです。ギターは 98,000 円で購入できますが、木片、糸、お米、水、マイクを購入して錬金すれば、たったの 13,636 円で手に入れられます。
図 1
あなたは冒険を楽に進めるため、なるべく安く目的のアイテムを手に入れようと考えました。 アイテムのリスト、錬金レシピのリスト、指定されたアイテムを入力とし、指定されたアイテムを作るために必要な金額の最小値を出力するプログラムを作成して下さい。
各アイテムの数量に限りはないものとします。アイテムは複数のレシピに使われることがありますが、1 つのアイテムを作るためのレシピはたかだか 1 つです。また、あるアイテムを起点としてレシピをたどっていったとき、そのアイテムが再びレシピに現れることはありません。
Input
複数のデータセットの並びが入力として与えられます。入力の終わりはゼロひとつの行で示されます。各データセットは以下の形式で与えられます。
n
s
1
p
1
s
2
p
2
:
s
n
p
n
m
o
1
k
1
q
1
q
2
...
q
k
1
o
2
k
2
q
1
q
2
...
q
k
2
:
o
m
k
m
q
1
q
2
...
q
k
m
t
1 行目にリストに含まれるアイテムの種類数
n
(1 ≤
n
≤ 100) が与えられます。続く
n
行に
i
番目のアイテムの名前
s
i
(1 文字以上 100 文字以下のアルファベットからなる半角文字列) とそれを購入する場合の値段
p
i
(0 ≤
p
i
≤ 1000000)が与えられます。
続く行に錬金レシピの数
m
(0 ≤
m
≤ 100) が与えられます。続く
m
行に
i
番目のレシピの情報が与えられます。各レシピとして、アイテムの名前
o
i
、それを作るために必要なアイテムの個数
k
i
(1 ≤
k
i
≤ 100) 、
k
i
個のアイテム名
q
1
,
q
2
...
q
k
i
が与えられます。
最後の行に指定されたアイテム名
t
が与えられます。
データセットの数は 30 を超えません。
Output
入力データセットごとに、最小の値段を１行に出力します。
Sample Input
8
wood 3000
string 800
rice 36
water 0
racket 5000
microphone 9800
onigiri 140
guitar 98000
3
racket 2 wood string
onigiri 2 rice water
guitar 3 racket microphone onigiri
guitar
1
computer 300000
0
computer
0
Output for the Sample Input
13636
300000",Python,"import sys
from collections import defaultdict

def solve():
    while True:
        n = int(input())
        if n == 0:
            break
        
        # Read items and their prices
        prices = {}
        for _ in range(n):
            line = input().split()
            item_name = line[0]
            price = int(line[1])
            prices[item_name] = price
        
        # Read recipes
        m = int(input())
        recipes = {}
        for _ in range(m):
            line = input().split()
            output_item = line[0]
            k = int(line[1])
            ingredients = line[2:2+k]
            recipes[output_item] = ingredients
        
        # Read target item
        target = input().strip()
        
        # Memoization for minimum cost
        memo = {}
        
        def min_cost(item):
            if item in memo:
                return memo[item]
            
            # Option 1: Buy directly
            buy_cost = prices[item]
            
            # Option 2: Craft using recipe (if available)
            if item in recipes:
                craft_cost = 0
                for ingredient in recipes[item]:
                    craft_cost += min_cost(ingredient)
                result = min(buy_cost, craft_cost)
            else:
                result = buy_cost
            
            memo[item] = result
            return result
        
        print(min_cost(target))

solve()
",0
p00201,"錬金マスター
あなたはついに魔法の釜、錬金釜を手に入れました。錬金釜に複数のアイテムを入れると、新しいア イテムを作ることができます。新しく作ったアイテムは、他のアイテムを作るために錬金釜へ入れることもできます。アイテムを作るために必要なアイテムのリストを記したものを錬金レシピと呼ぶことにします。以下の 3 つは錬金レシピの例です。
木片と糸でラケットができる。
お米と水でおにぎりができる。
ラケットとマイクとおにぎりでギターができる。
アイテムはお金を使って手にいれることもできますが、錬金釜で作った方が安くすむ場合もあります。例えば、各アイテムの購入価格が以下のように与えられているとします。
アイテム名
購入価格(円)
木片
3,000
糸
800
お米
36
水
0
ラケット
5,000
マイク
9,800
おにぎり
140
ギター
98,000
ラケットは 5,000 円で購入できますが、木片と糸を購入して錬金すれば 3,800 円で手に入れられます。更に、錬金を重ねることによりとてもお得にアイテムを手に入れられます。図 1 は上記 3 つの錬金レシピ例を組み合わせたものです。ギターは 98,000 円で購入できますが、木片、糸、お米、水、マイクを購入して錬金すれば、たったの 13,636 円で手に入れられます。
図 1
あなたは冒険を楽に進めるため、なるべく安く目的のアイテムを手に入れようと考えました。 アイテムのリスト、錬金レシピのリスト、指定されたアイテムを入力とし、指定されたアイテムを作るために必要な金額の最小値を出力するプログラムを作成して下さい。
各アイテムの数量に限りはないものとします。アイテムは複数のレシピに使われることがありますが、1 つのアイテムを作るためのレシピはたかだか 1 つです。また、あるアイテムを起点としてレシピをたどっていったとき、そのアイテムが再びレシピに現れることはありません。
Input
複数のデータセットの並びが入力として与えられます。入力の終わりはゼロひとつの行で示されます。各データセットは以下の形式で与えられます。
n
s
1
p
1
s
2
p
2
:
s
n
p
n
m
o
1
k
1
q
1
q
2
...
q
k
1
o
2
k
2
q
1
q
2
...
q
k
2
:
o
m
k
m
q
1
q
2
...
q
k
m
t
1 行目にリストに含まれるアイテムの種類数
n
(1 ≤
n
≤ 100) が与えられます。続く
n
行に
i
番目のアイテムの名前
s
i
(1 文字以上 100 文字以下のアルファベットからなる半角文字列) とそれを購入する場合の値段
p
i
(0 ≤
p
i
≤ 1000000)が与えられます。
続く行に錬金レシピの数
m
(0 ≤
m
≤ 100) が与えられます。続く
m
行に
i
番目のレシピの情報が与えられます。各レシピとして、アイテムの名前
o
i
、それを作るために必要なアイテムの個数
k
i
(1 ≤
k
i
≤ 100) 、
k
i
個のアイテム名
q
1
,
q
2
...
q
k
i
が与えられます。
最後の行に指定されたアイテム名
t
が与えられます。
データセットの数は 30 を超えません。
Output
入力データセットごとに、最小の値段を１行に出力します。
Sample Input
8
wood 3000
string 800
rice 36
water 0
racket 5000
microphone 9800
onigiri 140
guitar 98000
3
racket 2 wood string
onigiri 2 rice water
guitar 3 racket microphone onigiri
guitar
1
computer 300000
0
computer
0
Output for the Sample Input
13636
300000",Python,"while True:
  count = int(input())
  if count == 0: break 
  thing,money=[],[]
  for i in range(count):
    hoge = map(str,raw_input().split())
    t = int(hoge[1])
    thing.append(hoge[0])
    money.append(t)
  count = int(input())
  if count == 0:
    hoge = raw_input()
    if hoge not in thing:
      print 0
      continue
    t = thing.index(hoge)
    print money[t]
  else:
    for i in range(count):
      hoge = map(str,raw_input().split())
      if hoge[0] not in thing:
        print 0
      t = int(hoge[1])
      x,y = 2,0
      for j in range(t):
        r = thing.index(hoge[x])
        y += money[r]
        x+=1
      e = thing.index(hoge[0])
      money[e]= y
    g = raw_input()
    ans = thing.index(g)
    print money[ans]",1
p00202,"上司のおごり
会津太郎さんの会社には、割り切れない事が大嫌いな上司がいます。太郎さんがその上司と食事に行くときは、割り勘で会計をしているのですが、支払金額が参加人数で割り切れないときは、いつも上司がおごってくれています。
ある日、太郎さんは食事会の幹事になりました。お金の少ない太郎さんは、その上司を誘ってなんとかおごってもらえるように出来ないか考えました。もう料理屋に注文をしなければならないのですが、まだ何人参加するかは分からないので、どんな人数が参加してもおごってもらえるような注文をしておきたいようです。太郎さんの同期で、同じく食事会に参加する予定のあなたは、太郎さんに協力して、予算額以下で最大のどんな人数でも割り切れない金額を算出することにしました。
料理の種類、各料理の料金、予算額を入力とし、予算額以下で最大のどんな数字でも割り切れない合計金額(ただし、 1 と合計金額は除く)を出力するプログラムを作成してください。なお、各種類の料理は複数個注文できますが、全種類の料理を注文する必要はありません。ただし、このような合計金額がない場合は、 NA と出力してください。
Input
複数のデータセットの並びが入力として与えられます。  入力の終わりはゼロふたつの行で示されます。
各データセットは以下の形式で与えられます。
n
x
v
1
v
2
:
v
n
1 行目に料理の種類
n
(1 ≤
n
≤ 30) と予算額
x
(1 ≤
x
≤ 1000000) が空白区切りで与えられます。続く
n
行に
i
種類目の料理の金額を表す整数
v
i
(1 ≤
v
i
≤ 1000000) が与えられます。
データセットの数は 100 を超えません。
Output
入力データセットごとに、予算額に最も近い合計金額、または NA を１行に出力します。
Sample Input
4 15000
305
260
129
500
3 400
10
20
30
3 200909
5
9
12
0 0
Output for the Sample Input
14983
NA
200909",C,"#include <stdio.h>
#include <string.h>
#include <stdbool.h>

int gcd(int a, int b) {
    while (b != 0) {
        int temp = b;
        b = a % b;
        a = temp;
    }
    return a;
}

bool isNotDivisibleByAny(int num) {
    if (num <= 1) return false;
    for (int i = 2; i * i <= num; i++) {
        if (num % i == 0) return false;
    }
    return true;
}

int main() {
    int n, x;
    
    while (scanf(""%d %d"", &n, &x) == 2) {
        if (n == 0 && x == 0) break;
        
        int v[30];
        for (int i = 0; i < n; i++) {
            scanf(""%d"", &v[i]);
        }
        
        bool *possible = (bool *)calloc(x + 1, sizeof(bool));
        possible[0] = true;
        
        for (int i = 0; i < n; i++) {
            for (int j = v[i]; j <= x; j++) {
                if (possible[j - v[i]]) {
                    possible[j] = true;
                }
            }
        }
        
        int result = -1;
        for (int i = x; i >= 1; i--) {
            if (possible[i]) {
                bool divisible = false;
                for (int d = 2; d <= i; d++) {
                    if (i % d == 0) {
                        divisible = true;
                        break;
                    }
                }
                if (!divisible && i > 1) {
                    result = i;
                    break;
                }
            }
        }
        
        if (result == -1) {
            printf(""NA\n"");
        } else {
            printf(""%d\n"", result);
        }
        
        free(possible);
    }
    
    return 0;
}
",0
p00202,"上司のおごり
会津太郎さんの会社には、割り切れない事が大嫌いな上司がいます。太郎さんがその上司と食事に行くときは、割り勘で会計をしているのですが、支払金額が参加人数で割り切れないときは、いつも上司がおごってくれています。
ある日、太郎さんは食事会の幹事になりました。お金の少ない太郎さんは、その上司を誘ってなんとかおごってもらえるように出来ないか考えました。もう料理屋に注文をしなければならないのですが、まだ何人参加するかは分からないので、どんな人数が参加してもおごってもらえるような注文をしておきたいようです。太郎さんの同期で、同じく食事会に参加する予定のあなたは、太郎さんに協力して、予算額以下で最大のどんな人数でも割り切れない金額を算出することにしました。
料理の種類、各料理の料金、予算額を入力とし、予算額以下で最大のどんな数字でも割り切れない合計金額(ただし、 1 と合計金額は除く)を出力するプログラムを作成してください。なお、各種類の料理は複数個注文できますが、全種類の料理を注文する必要はありません。ただし、このような合計金額がない場合は、 NA と出力してください。
Input
複数のデータセットの並びが入力として与えられます。  入力の終わりはゼロふたつの行で示されます。
各データセットは以下の形式で与えられます。
n
x
v
1
v
2
:
v
n
1 行目に料理の種類
n
(1 ≤
n
≤ 30) と予算額
x
(1 ≤
x
≤ 1000000) が空白区切りで与えられます。続く
n
行に
i
種類目の料理の金額を表す整数
v
i
(1 ≤
v
i
≤ 1000000) が与えられます。
データセットの数は 100 を超えません。
Output
入力データセットごとに、予算額に最も近い合計金額、または NA を１行に出力します。
Sample Input
4 15000
305
260
129
500
3 400
10
20
30
3 200909
5
9
12
0 0
Output for the Sample Input
14983
NA
200909",C,"#include <stdio.h>
#include <string.h>

#define MAX_PRIME	(1000000)
#define IS_PRIME(n)	(prime[j]==0?1:0)

int prime[MAX_PRIME + 1];
int fare[MAX_PRIME + 1];
int fare_next[MAX_PRIME + 1];


void make_prime(void)
{
    int i;
    int j;
    int n;
    int c;
    
    for (i = 2; i * i <= MAX_PRIME; i++){
        if (prime[i] == 0){
            for (j = i * 2; j <= MAX_PRIME; j += i){
				prime[j] = 1;
            }
        }
    }
}


int main(void)
{
	int n, x;
	int price[30];
	int i, j, k;
	
	make_prime();
	
	while (1){
		scanf(""%d%d"", &n, &x);
		if (n == 0 && x == 0){
			break;
		}
		
		for (i = 0; i < n; i++){
			scanf(""%d"", &price[i]);
		}
		
		memset(fare_next, 0, sizeof(fare_next));
		fare_next[0] = 1;
		for (i = 0; i < n; i++){

			memcpy(fare, fare_next, sizeof(fare_next));
			for (j = price[i]; j <= x; j += price[i]){
				for (k = 0; k <= x; k++){
					if (fare[k] != 0){
						if (k + j <= x){
							fare_next[k + j] = 1;
						}
					}
				}
			}
		}
		memcpy(fare, fare_next, sizeof(fare_next));
		
//for (i = 1; i <= x; i++){
//	printf(""[%d=%d]"", i, fare[i]);
//}

		for (i = x; i >= 1; i--){
			if (fare[i] != 0 && prime[i] == 0){
				printf(""%d\n"", i);
				break;
			}
		}
		if (i == 0){
			printf(""NA\n"");
		}
	}
	return (0);
}",1
p00202,"上司のおごり
会津太郎さんの会社には、割り切れない事が大嫌いな上司がいます。太郎さんがその上司と食事に行くときは、割り勘で会計をしているのですが、支払金額が参加人数で割り切れないときは、いつも上司がおごってくれています。
ある日、太郎さんは食事会の幹事になりました。お金の少ない太郎さんは、その上司を誘ってなんとかおごってもらえるように出来ないか考えました。もう料理屋に注文をしなければならないのですが、まだ何人参加するかは分からないので、どんな人数が参加してもおごってもらえるような注文をしておきたいようです。太郎さんの同期で、同じく食事会に参加する予定のあなたは、太郎さんに協力して、予算額以下で最大のどんな人数でも割り切れない金額を算出することにしました。
料理の種類、各料理の料金、予算額を入力とし、予算額以下で最大のどんな数字でも割り切れない合計金額(ただし、 1 と合計金額は除く)を出力するプログラムを作成してください。なお、各種類の料理は複数個注文できますが、全種類の料理を注文する必要はありません。ただし、このような合計金額がない場合は、 NA と出力してください。
Input
複数のデータセットの並びが入力として与えられます。  入力の終わりはゼロふたつの行で示されます。
各データセットは以下の形式で与えられます。
n
x
v
1
v
2
:
v
n
1 行目に料理の種類
n
(1 ≤
n
≤ 30) と予算額
x
(1 ≤
x
≤ 1000000) が空白区切りで与えられます。続く
n
行に
i
種類目の料理の金額を表す整数
v
i
(1 ≤
v
i
≤ 1000000) が与えられます。
データセットの数は 100 を超えません。
Output
入力データセットごとに、予算額に最も近い合計金額、または NA を１行に出力します。
Sample Input
4 15000
305
260
129
500
3 400
10
20
30
3 200909
5
9
12
0 0
Output for the Sample Input
14983
NA
200909",Java,"import java.util.*;

public class Main {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        
        while (true) {
            int n = sc.nextInt();
            int x = sc.nextInt();
            
            if (n == 0 && x == 0) break;
            
            int[] prices = new int[n];
            for (int i = 0; i < n; i++) {
                prices[i] = sc.nextInt();
            }
            
            // Find all possible sums up to budget x
            boolean[] possible = new boolean[x + 1];
            possible[0] = true;
            
            for (int i = 0; i < n; i++) {
                for (int j = prices[i]; j <= x; j++) {
                    if (possible[j - prices[i]]) {
                        possible[j] = true;
                    }
                }
            }
            
            // Find the maximum sum that is not divisible by any number from 2 to itself-1
            int result = -1;
            for (int sum = x; sum >= 2; sum--) {
                if (possible[sum] && isPrime(sum)) {
                    result = sum;
                    break;
                }
            }
            
            if (result == -1) {
                System.out.println(""NA"");
            } else {
                System.out.println(result);
            }
        }
        
        sc.close();
    }
    
    private static boolean isPrime(int num) {
        if (num < 2) return false;
        if (num == 2) return true;
        if (num % 2 == 0) return false;
        
        for (int i = 3; i * i <= num; i += 2) {
            if (num % i == 0) return false;
        }
        return true;
    }
}
",0
p00202,"上司のおごり
会津太郎さんの会社には、割り切れない事が大嫌いな上司がいます。太郎さんがその上司と食事に行くときは、割り勘で会計をしているのですが、支払金額が参加人数で割り切れないときは、いつも上司がおごってくれています。
ある日、太郎さんは食事会の幹事になりました。お金の少ない太郎さんは、その上司を誘ってなんとかおごってもらえるように出来ないか考えました。もう料理屋に注文をしなければならないのですが、まだ何人参加するかは分からないので、どんな人数が参加してもおごってもらえるような注文をしておきたいようです。太郎さんの同期で、同じく食事会に参加する予定のあなたは、太郎さんに協力して、予算額以下で最大のどんな人数でも割り切れない金額を算出することにしました。
料理の種類、各料理の料金、予算額を入力とし、予算額以下で最大のどんな数字でも割り切れない合計金額(ただし、 1 と合計金額は除く)を出力するプログラムを作成してください。なお、各種類の料理は複数個注文できますが、全種類の料理を注文する必要はありません。ただし、このような合計金額がない場合は、 NA と出力してください。
Input
複数のデータセットの並びが入力として与えられます。  入力の終わりはゼロふたつの行で示されます。
各データセットは以下の形式で与えられます。
n
x
v
1
v
2
:
v
n
1 行目に料理の種類
n
(1 ≤
n
≤ 30) と予算額
x
(1 ≤
x
≤ 1000000) が空白区切りで与えられます。続く
n
行に
i
種類目の料理の金額を表す整数
v
i
(1 ≤
v
i
≤ 1000000) が与えられます。
データセットの数は 100 を超えません。
Output
入力データセットごとに、予算額に最も近い合計金額、または NA を１行に出力します。
Sample Input
4 15000
305
260
129
500
3 400
10
20
30
3 200909
5
9
12
0 0
Output for the Sample Input
14983
NA
200909",Java,"
import java.io.IOException;
import java.util.Arrays;
import java.util.Scanner;

public class Main {

	public static void main(String[] args) throws IOException {
		new Main().run();
	}

	private void run() throws IOException {
		Scanner scanner = new Scanner(System.in);
		int MAX = 1000000;
		boolean[] prime = new boolean[MAX + 1];
		for (int i = 4; i <= MAX; i += 2) {
			prime[i] = true;
		}
		for (int i = 3; i <= Math.sqrt(MAX); i += 2) {
			if (!prime[i]) {
				for (int j = i * 3; j <= MAX; j += i * 2) {
					prime[j] = true;
				}
			}
		}
		while (true) {
			int n = scanner.nextInt();
			int m = scanner.nextInt();
			if ((n | m) == 0)
				break;
			int[] a = new int[n];
			int min = Integer.MAX_VALUE;
			boolean[] f = new boolean[m + 1];
			for (int i = 0; i < n; i++) {
				int s = scanner.nextInt();
				min = Math.min(s, min);
				a[i] = s;
				for (int j = s; j <= m; j += s) {
					f[j] = true;
				}
			}
			Arrays.sort(a);
			int max = 0;
			for (int i = min; i <= m; i++) {
				if (!f[i])
					for (int j = 0; j < n; j++) {
						if (i - a[j] >= 0 && f[i - a[j]]) {
							f[i] = true;
							break;
						}
					}
				if (f[i] && !prime[i])
					max = i;
			}
			System.out.println(max == 0 ? ""NA"" : max);

		}

	}
}",1
p00202,"上司のおごり
会津太郎さんの会社には、割り切れない事が大嫌いな上司がいます。太郎さんがその上司と食事に行くときは、割り勘で会計をしているのですが、支払金額が参加人数で割り切れないときは、いつも上司がおごってくれています。
ある日、太郎さんは食事会の幹事になりました。お金の少ない太郎さんは、その上司を誘ってなんとかおごってもらえるように出来ないか考えました。もう料理屋に注文をしなければならないのですが、まだ何人参加するかは分からないので、どんな人数が参加してもおごってもらえるような注文をしておきたいようです。太郎さんの同期で、同じく食事会に参加する予定のあなたは、太郎さんに協力して、予算額以下で最大のどんな人数でも割り切れない金額を算出することにしました。
料理の種類、各料理の料金、予算額を入力とし、予算額以下で最大のどんな数字でも割り切れない合計金額(ただし、 1 と合計金額は除く)を出力するプログラムを作成してください。なお、各種類の料理は複数個注文できますが、全種類の料理を注文する必要はありません。ただし、このような合計金額がない場合は、 NA と出力してください。
Input
複数のデータセットの並びが入力として与えられます。  入力の終わりはゼロふたつの行で示されます。
各データセットは以下の形式で与えられます。
n
x
v
1
v
2
:
v
n
1 行目に料理の種類
n
(1 ≤
n
≤ 30) と予算額
x
(1 ≤
x
≤ 1000000) が空白区切りで与えられます。続く
n
行に
i
種類目の料理の金額を表す整数
v
i
(1 ≤
v
i
≤ 1000000) が与えられます。
データセットの数は 100 を超えません。
Output
入力データセットごとに、予算額に最も近い合計金額、または NA を１行に出力します。
Sample Input
4 15000
305
260
129
500
3 400
10
20
30
3 200909
5
9
12
0 0
Output for the Sample Input
14983
NA
200909",Python,"import math
from functools import reduce

def gcd(a, b):
    while b:
        a, b = b, a % b
    return a

def solve(n, budget, prices):
    # Dynamic programming to find all possible sums
    possible = [False] * (budget + 1)
    possible[0] = True
    
    for price in prices:
        for total in range(budget, price - 1, -1):
            if possible[total - price]:
                possible[total] = True
    
    # Find the largest sum that is not divisible by all numbers from 2 to sum
    for total in range(budget, 0, -1):
        if not possible[total]:
            continue
        
        # Check if total is not divisible by any number from 2 to total-1
        is_prime_like = True
        for divisor in range(2, int(math.sqrt(total)) + 1):
            if total % divisor == 0:
                is_prime_like = False
                break
        
        if is_prime_like and total > 1:
            return total
    
    return ""NA""

def is_not_divisible_by_any(num):
    # A number is not divisible by any number except 1 and itself if it's prime
    if num <= 1:
        return False
    if num == 2:
        return True
    if num % 2 == 0:
        return False
    for i in range(3, int(math.sqrt(num)) + 1, 2):
        if num % i == 0:
            return False
    return True

def solve2(n, budget, prices):
    # Dynamic programming to find all possible sums
    possible = set([0])
    
    for price in prices:
        new_possible = set()
        for p in possible:
            amount = p
            while amount + price <= budget:
                amount += price
                new_possible.add(amount)
        possible.update(new_possible)
    
    # Find the largest sum that is prime
    for total in range(budget, 1, -1):
        if total in possible and is_not_divisible_by_any(total):
            return total
    
    return ""NA""

while True:
    line = input().split()
    n, x = int(line[0]), int(line[1])
    
    if n == 0 and x == 0:
        break
    
    prices = []
    for _ in range(n):
        prices.append(int(input()))
    
    print(solve2(n, x, prices))
",0
p00202,"上司のおごり
会津太郎さんの会社には、割り切れない事が大嫌いな上司がいます。太郎さんがその上司と食事に行くときは、割り勘で会計をしているのですが、支払金額が参加人数で割り切れないときは、いつも上司がおごってくれています。
ある日、太郎さんは食事会の幹事になりました。お金の少ない太郎さんは、その上司を誘ってなんとかおごってもらえるように出来ないか考えました。もう料理屋に注文をしなければならないのですが、まだ何人参加するかは分からないので、どんな人数が参加してもおごってもらえるような注文をしておきたいようです。太郎さんの同期で、同じく食事会に参加する予定のあなたは、太郎さんに協力して、予算額以下で最大のどんな人数でも割り切れない金額を算出することにしました。
料理の種類、各料理の料金、予算額を入力とし、予算額以下で最大のどんな数字でも割り切れない合計金額(ただし、 1 と合計金額は除く)を出力するプログラムを作成してください。なお、各種類の料理は複数個注文できますが、全種類の料理を注文する必要はありません。ただし、このような合計金額がない場合は、 NA と出力してください。
Input
複数のデータセットの並びが入力として与えられます。  入力の終わりはゼロふたつの行で示されます。
各データセットは以下の形式で与えられます。
n
x
v
1
v
2
:
v
n
1 行目に料理の種類
n
(1 ≤
n
≤ 30) と予算額
x
(1 ≤
x
≤ 1000000) が空白区切りで与えられます。続く
n
行に
i
種類目の料理の金額を表す整数
v
i
(1 ≤
v
i
≤ 1000000) が与えられます。
データセットの数は 100 を超えません。
Output
入力データセットごとに、予算額に最も近い合計金額、または NA を１行に出力します。
Sample Input
4 15000
305
260
129
500
3 400
10
20
30
3 200909
5
9
12
0 0
Output for the Sample Input
14983
NA
200909",Python,"from array import array
PRIME_MAX = 1000001
isPrime = array('b', [1] * PRIME_MAX)
isPrime[0] = 0
isPrime[1] = 0
for i in xrange(2, PRIME_MAX):
	if not isPrime[i]: continue
	for j in xrange(i << 1, PRIME_MAX, i):
		isPrime[j] = 0
while True:
	n, x = map(int, raw_input().split())
	if n == x == 0: break
	menu = [input() for i in xrange(n)]
	result = 0
	exists = set()
	exists.add(0)
	for i in xrange(x + 1):
		if i in exists:
			exists.remove(i)
			for v in menu:
				exists.add(i + v)
			if isPrime[i]:
				result = i
	if result:
		print result
	else:
		print ""NA""",1
p00203,"会津山スキー場の新企画
会津山スキー場の経営者である油木屋さんは、上級者向けとして障害物やジャンプ台を配置したコースを用意しました。コースにはいろいろな滑り方があり、シーズン中に全てのパターンの滑り方が出来た利用者には、プレゼントを贈ることになっています。
油木屋さんのために、コースの見取り図をもとに滑り方のパターン数を出力するプログラムを作ってあげましょう。
コースは上図のような
X × Y
個のマスからなるグリッドで表されます。左上を原点とし、x 座標は右に行くにつれて大きくなり、y 座標は下にいくにつれて大きくなるものとします。
各滑り方のパターンは、最も高いところ(
y = 1
、ただし障害物の無いところ) からスタートし、ゴール(
y = Y
) に向かって進んでいきます。グリッドのマス(
x, y
) にいる滑走者は、(
x − 1, y + 1
)、(
x, y + 1
)、 (
x + 1, y + 1
) のいずれかに移動することができます。マスには、障害物やジャンプ台があり、障害物のあるマスには進入できず、ジャンプ台があるマスに進入すると(
x, y + 2
) へ移動します。ただし、いちばん高いマス (
y = 1
のマス) にはジャンプ台は存在せず、ジャンプ台のあるマスに進入する際には x 座標が同じマスからしか進入できません。コースの上端(
y = 1
) からスタートし、コースからはずれることなく下端を超えれば(
y ≥ Y
) 1つの滑り方とみなし、滑り終わります。
コースの情報を入力とし、滑り方の総数を出力するプログラムを作成してください。
Input
複数のデータセットの並びが入力として与えられます。入力の終わりはゼロふたつの行で示されます。各データセットは以下の形式で与えられます。
X
Y
c
11
c
21
...
c
X1
c
12
c
22
...
c
X2
:
c
1Y
c
2Y
...
c
XY
1 行目にコースの大きさ
X, Y
(1 ≤
X, Y
≤ 15) が与えられます。続く
Y
行にコースの情報が与えられます。
c
ij
(0 , 1 , 2 のいずれか) は
x = i, y = j
のマスの情報を表す整数で、0 が移動可能なマス、1 が障害物があるマス、2 がジャンプ台があるマスを表します。
データセットの数は 50 を超えません。
Output
入力データセットごとに、コースの滑り方のパターン数を1行に出力します。
Sample Input
5 5
0 0 0 0 1
2 1 0 2 0
1 0 0 1 1
0 2 1 2 0
0 1 0 0 0
5 5
0 0 1 0 0
2 1 0 2 0
1 0 0 1 1
0 2 1 2 0
0 1 0 0 0
15 15
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0
Output for the Sample Input
8
6
52694573",C,"#include <stdio.h>
#include <string.h>

int X, Y;
int course[16][16];
long long dp[16][16];

long long countPaths() {
    memset(dp, 0, sizeof(dp));
    
    // Initialize first row (y=1)
    for (int x = 1; x <= X; x++) {
        if (course[x][1] != 1) {  // Not an obstacle
            dp[x][1] = 1;
        }
    }
    
    // Fill the dp table
    for (int y = 1; y < Y; y++) {
        for (int x = 1; x <= X; x++) {
            if (dp[x][y] == 0) continue;
            
            if (course[x][y] == 2) {  // Jump platform
                // Jump to (x, y+2)
                if (y + 2 <= Y) {
                    if (course[x][y+2] != 1) {
                        dp[x][y+2] += dp[x][y];
                    }
                } else {
                    // Jump goes beyond Y, count as reaching goal
                    dp[x][Y] += dp[x][y];
                }
            } else {  // Normal cell (0)
                // Move to (x-1, y+1), (x, y+1), (x+1, y+1)
                for (int dx = -1; dx <= 1; dx++) {
                    int nx = x + dx;
                    int ny = y + 1;
                    
                    if (nx < 1 || nx > X) continue;
                    
                    if (ny > Y) {
                        // Reached goal
                        dp[x][Y] += dp[x][y];
                    } else {
                        if (course[nx][ny] == 1) {  // Obstacle
                            continue;
                        }
                        if (course[nx][ny] == 2) {  // Jump platform
                            // Can only enter jump platform from directly above (dx == 0)
                            if (dx == 0) {
                                dp[nx][ny] += dp[x][y];
                            }
                        } else {  // Normal cell
                            dp[nx][ny] += dp[x][y];
                        }
                    }
                }
            }
        }
    }
    
    // Sum all paths that reached Y
    long long total = 0;
    for (int x = 1; x <= X; x++) {
        total += dp[x][Y];
    }
    
    return total;
}

int main() {
    while (1) {
        scanf(""%d %d"", &X, &Y);
        if (X == 0 && Y == 0) break;
        
        for (int y = 1; y <= Y; y++) {
            for (int x = 1; x <= X; x++) {
                scanf(""%d"", &course[x][y]);
            }
        }
        
        printf(""%lld\n"", countPaths());
    }
    
    return 0;
}
",0
p00203,"会津山スキー場の新企画
会津山スキー場の経営者である油木屋さんは、上級者向けとして障害物やジャンプ台を配置したコースを用意しました。コースにはいろいろな滑り方があり、シーズン中に全てのパターンの滑り方が出来た利用者には、プレゼントを贈ることになっています。
油木屋さんのために、コースの見取り図をもとに滑り方のパターン数を出力するプログラムを作ってあげましょう。
コースは上図のような
X × Y
個のマスからなるグリッドで表されます。左上を原点とし、x 座標は右に行くにつれて大きくなり、y 座標は下にいくにつれて大きくなるものとします。
各滑り方のパターンは、最も高いところ(
y = 1
、ただし障害物の無いところ) からスタートし、ゴール(
y = Y
) に向かって進んでいきます。グリッドのマス(
x, y
) にいる滑走者は、(
x − 1, y + 1
)、(
x, y + 1
)、 (
x + 1, y + 1
) のいずれかに移動することができます。マスには、障害物やジャンプ台があり、障害物のあるマスには進入できず、ジャンプ台があるマスに進入すると(
x, y + 2
) へ移動します。ただし、いちばん高いマス (
y = 1
のマス) にはジャンプ台は存在せず、ジャンプ台のあるマスに進入する際には x 座標が同じマスからしか進入できません。コースの上端(
y = 1
) からスタートし、コースからはずれることなく下端を超えれば(
y ≥ Y
) 1つの滑り方とみなし、滑り終わります。
コースの情報を入力とし、滑り方の総数を出力するプログラムを作成してください。
Input
複数のデータセットの並びが入力として与えられます。入力の終わりはゼロふたつの行で示されます。各データセットは以下の形式で与えられます。
X
Y
c
11
c
21
...
c
X1
c
12
c
22
...
c
X2
:
c
1Y
c
2Y
...
c
XY
1 行目にコースの大きさ
X, Y
(1 ≤
X, Y
≤ 15) が与えられます。続く
Y
行にコースの情報が与えられます。
c
ij
(0 , 1 , 2 のいずれか) は
x = i, y = j
のマスの情報を表す整数で、0 が移動可能なマス、1 が障害物があるマス、2 がジャンプ台があるマスを表します。
データセットの数は 50 を超えません。
Output
入力データセットごとに、コースの滑り方のパターン数を1行に出力します。
Sample Input
5 5
0 0 0 0 1
2 1 0 2 0
1 0 0 1 1
0 2 1 2 0
0 1 0 0 0
5 5
0 0 1 0 0
2 1 0 2 0
1 0 0 1 1
0 2 1 2 0
0 1 0 0 0
15 15
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0
Output for the Sample Input
8
6
52694573",C,"#include<stdio.h>
	int w,h,xd[]={1,0,-1},p,u[20][20];
	void ret(int x,int y){
		int i,s=x;
		if(h-1<=y)
			p++;
		else if(u[y][x]==2)
			ret(x,y+2);
		else if(u[y][x]==0){
			y++;
			for(i=0;i<3;i++){
				x=s+xd[i];
				if(x>=0&&x<=w-1){
					if(u[y][x]==2&&i==1)
						ret(x,y+2);
					else if(u[y][x]==0)
						ret(x,y);
				}
			}
		}
	}
	int main(){
		int i,j,x,y;
		while(scanf(""%d %d"",&w,&h),w||h){
			p=0;
			for(i=0;i<h;i++){
				for(j=0;j<w-1;j++)
				scanf(""%d "",&u[i][j]);
				scanf(""%d"",&u[i][w-1]);
			}
			for(i=0;i<w;i++){
				if(u[0][i]==0){
					x=i;
					y=0;
					ret(x,y);
				}
				else if(u[0][i]==2){
					x=i;
					y=2;
					ret(x,y);
				}
			}
			printf(""%d\n"",p);
		}
		return 0;
	}",1
p00203,"会津山スキー場の新企画
会津山スキー場の経営者である油木屋さんは、上級者向けとして障害物やジャンプ台を配置したコースを用意しました。コースにはいろいろな滑り方があり、シーズン中に全てのパターンの滑り方が出来た利用者には、プレゼントを贈ることになっています。
油木屋さんのために、コースの見取り図をもとに滑り方のパターン数を出力するプログラムを作ってあげましょう。
コースは上図のような
X × Y
個のマスからなるグリッドで表されます。左上を原点とし、x 座標は右に行くにつれて大きくなり、y 座標は下にいくにつれて大きくなるものとします。
各滑り方のパターンは、最も高いところ(
y = 1
、ただし障害物の無いところ) からスタートし、ゴール(
y = Y
) に向かって進んでいきます。グリッドのマス(
x, y
) にいる滑走者は、(
x − 1, y + 1
)、(
x, y + 1
)、 (
x + 1, y + 1
) のいずれかに移動することができます。マスには、障害物やジャンプ台があり、障害物のあるマスには進入できず、ジャンプ台があるマスに進入すると(
x, y + 2
) へ移動します。ただし、いちばん高いマス (
y = 1
のマス) にはジャンプ台は存在せず、ジャンプ台のあるマスに進入する際には x 座標が同じマスからしか進入できません。コースの上端(
y = 1
) からスタートし、コースからはずれることなく下端を超えれば(
y ≥ Y
) 1つの滑り方とみなし、滑り終わります。
コースの情報を入力とし、滑り方の総数を出力するプログラムを作成してください。
Input
複数のデータセットの並びが入力として与えられます。入力の終わりはゼロふたつの行で示されます。各データセットは以下の形式で与えられます。
X
Y
c
11
c
21
...
c
X1
c
12
c
22
...
c
X2
:
c
1Y
c
2Y
...
c
XY
1 行目にコースの大きさ
X, Y
(1 ≤
X, Y
≤ 15) が与えられます。続く
Y
行にコースの情報が与えられます。
c
ij
(0 , 1 , 2 のいずれか) は
x = i, y = j
のマスの情報を表す整数で、0 が移動可能なマス、1 が障害物があるマス、2 がジャンプ台があるマスを表します。
データセットの数は 50 を超えません。
Output
入力データセットごとに、コースの滑り方のパターン数を1行に出力します。
Sample Input
5 5
0 0 0 0 1
2 1 0 2 0
1 0 0 1 1
0 2 1 2 0
0 1 0 0 0
5 5
0 0 1 0 0
2 1 0 2 0
1 0 0 1 1
0 2 1 2 0
0 1 0 0 0
15 15
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0
Output for the Sample Input
8
6
52694573",Java,"import java.util.*;

public class Main {
    static int X, Y;
    static int[][] course;
    static long[][] memo;
    
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        
        while (true) {
            X = sc.nextInt();
            Y = sc.nextInt();
            
            if (X == 0 && Y == 0) break;
            
            course = new int[X + 1][Y + 1];
            memo = new long[X + 1][Y + 1];
            
            for (int y = 1; y <= Y; y++) {
                for (int x = 1; x <= X; x++) {
                    course[x][y] = sc.nextInt();
                    memo[x][y] = -1;
                }
            }
            
            long total = 0;
            for (int x = 1; x <= X; x++) {
                if (course[x][1] != 1) {
                    total += dfs(x, 1);
                }
            }
            
            System.out.println(total);
        }
        
        sc.close();
    }
    
    static long dfs(int x, int y) {
        if (y >= Y) {
            return 1;
        }
        
        if (memo[x][y] != -1) {
            return memo[x][y];
        }
        
        long count = 0;
        
        if (course[x][y] == 2) {
            // Jump platform - skip to y+2
            int nextY = y + 2;
            if (nextY >= Y) {
                count = 1;
            } else if (course[x][nextY] != 1) {
                if (course[x][nextY] == 2) {
                    count = dfs(x, nextY);
                } else {
                    count = dfs(x, nextY);
                }
            }
        } else {
            // Normal movement to y+1
            int nextY = y + 1;
            
            // Move to (x-1, y+1)
            if (x - 1 >= 1 && course[x - 1][nextY] != 1) {
                if (course[x - 1][nextY] == 2) {
                    // Can't enter jump platform from diagonal
                } else {
                    count += dfs(x - 1, nextY);
                }
            }
            
            // Move to (x, y+1)
            if (course[x][nextY] != 1) {
                count += dfs(x, nextY);
            }
            
            // Move to (x+1, y+1)
            if (x + 1 <= X && course[x + 1][nextY] != 1) {
                if (course[x + 1][nextY] == 2) {
                    // Can't enter jump platform from diagonal
                } else {
                    count += dfs(x + 1, nextY);
                }
            }
        }
        
        memo[x][y] = count;
        return count;
    }
}
",0
p00203,"会津山スキー場の新企画
会津山スキー場の経営者である油木屋さんは、上級者向けとして障害物やジャンプ台を配置したコースを用意しました。コースにはいろいろな滑り方があり、シーズン中に全てのパターンの滑り方が出来た利用者には、プレゼントを贈ることになっています。
油木屋さんのために、コースの見取り図をもとに滑り方のパターン数を出力するプログラムを作ってあげましょう。
コースは上図のような
X × Y
個のマスからなるグリッドで表されます。左上を原点とし、x 座標は右に行くにつれて大きくなり、y 座標は下にいくにつれて大きくなるものとします。
各滑り方のパターンは、最も高いところ(
y = 1
、ただし障害物の無いところ) からスタートし、ゴール(
y = Y
) に向かって進んでいきます。グリッドのマス(
x, y
) にいる滑走者は、(
x − 1, y + 1
)、(
x, y + 1
)、 (
x + 1, y + 1
) のいずれかに移動することができます。マスには、障害物やジャンプ台があり、障害物のあるマスには進入できず、ジャンプ台があるマスに進入すると(
x, y + 2
) へ移動します。ただし、いちばん高いマス (
y = 1
のマス) にはジャンプ台は存在せず、ジャンプ台のあるマスに進入する際には x 座標が同じマスからしか進入できません。コースの上端(
y = 1
) からスタートし、コースからはずれることなく下端を超えれば(
y ≥ Y
) 1つの滑り方とみなし、滑り終わります。
コースの情報を入力とし、滑り方の総数を出力するプログラムを作成してください。
Input
複数のデータセットの並びが入力として与えられます。入力の終わりはゼロふたつの行で示されます。各データセットは以下の形式で与えられます。
X
Y
c
11
c
21
...
c
X1
c
12
c
22
...
c
X2
:
c
1Y
c
2Y
...
c
XY
1 行目にコースの大きさ
X, Y
(1 ≤
X, Y
≤ 15) が与えられます。続く
Y
行にコースの情報が与えられます。
c
ij
(0 , 1 , 2 のいずれか) は
x = i, y = j
のマスの情報を表す整数で、0 が移動可能なマス、1 が障害物があるマス、2 がジャンプ台があるマスを表します。
データセットの数は 50 を超えません。
Output
入力データセットごとに、コースの滑り方のパターン数を1行に出力します。
Sample Input
5 5
0 0 0 0 1
2 1 0 2 0
1 0 0 1 1
0 2 1 2 0
0 1 0 0 0
5 5
0 0 1 0 0
2 1 0 2 0
1 0 0 1 1
0 2 1 2 0
0 1 0 0 0
15 15
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0
Output for the Sample Input
8
6
52694573",Java,"import java.util.Scanner;

public class Main {

	static int H,W;
	static int[][] field;
	static int[][] dp;
	public static void main(String[] args) {
		Scanner cin = new Scanner(System.in);
		for(;;){
			W=cin.nextInt();
			H=cin.nextInt();
			if(W+H==0)break;
			field=new int[H+2][W];
			dp=new int[H+2][W];
			for(int i=0;i<H;i++){
				for(int j=0;j<W;j++){
					field[i][j]=cin.nextInt();
				}
			}
			for(int i=0;i<W;i++){
				if(field[0][i]==0)dp[0][i]=1;
			}
			for(int i=0;i<H;i++){
				for(int j=0;j<W;j++){
					if(field[i][j]==0){
						if(i!=H-1){
							for(int k=-1;k<=1;k++){
								if(j+k<0||j+k>=W)continue;
								if(field[i+1][j+k]==1)continue;
								if(k!=0&&field[i+1][j+k]==2)continue;
								dp[i+1][j+k]+=dp[i][j];
							}							
						}
						else{
							dp[i+1][j]+=dp[i][j];
						}
					}
					else if(field[i][j]==2){
						dp[i+2][j]+=dp[i][j];
					}
				}
			}
			int ans=0;
			for(int i=H;i<H+2;i++){
				for(int j=0;j<W;j++){
					ans+=dp[i][j];
				}
			}
			System.out.println(ans);
			
		}
	}

}",1
p00203,"会津山スキー場の新企画
会津山スキー場の経営者である油木屋さんは、上級者向けとして障害物やジャンプ台を配置したコースを用意しました。コースにはいろいろな滑り方があり、シーズン中に全てのパターンの滑り方が出来た利用者には、プレゼントを贈ることになっています。
油木屋さんのために、コースの見取り図をもとに滑り方のパターン数を出力するプログラムを作ってあげましょう。
コースは上図のような
X × Y
個のマスからなるグリッドで表されます。左上を原点とし、x 座標は右に行くにつれて大きくなり、y 座標は下にいくにつれて大きくなるものとします。
各滑り方のパターンは、最も高いところ(
y = 1
、ただし障害物の無いところ) からスタートし、ゴール(
y = Y
) に向かって進んでいきます。グリッドのマス(
x, y
) にいる滑走者は、(
x − 1, y + 1
)、(
x, y + 1
)、 (
x + 1, y + 1
) のいずれかに移動することができます。マスには、障害物やジャンプ台があり、障害物のあるマスには進入できず、ジャンプ台があるマスに進入すると(
x, y + 2
) へ移動します。ただし、いちばん高いマス (
y = 1
のマス) にはジャンプ台は存在せず、ジャンプ台のあるマスに進入する際には x 座標が同じマスからしか進入できません。コースの上端(
y = 1
) からスタートし、コースからはずれることなく下端を超えれば(
y ≥ Y
) 1つの滑り方とみなし、滑り終わります。
コースの情報を入力とし、滑り方の総数を出力するプログラムを作成してください。
Input
複数のデータセットの並びが入力として与えられます。入力の終わりはゼロふたつの行で示されます。各データセットは以下の形式で与えられます。
X
Y
c
11
c
21
...
c
X1
c
12
c
22
...
c
X2
:
c
1Y
c
2Y
...
c
XY
1 行目にコースの大きさ
X, Y
(1 ≤
X, Y
≤ 15) が与えられます。続く
Y
行にコースの情報が与えられます。
c
ij
(0 , 1 , 2 のいずれか) は
x = i, y = j
のマスの情報を表す整数で、0 が移動可能なマス、1 が障害物があるマス、2 がジャンプ台があるマスを表します。
データセットの数は 50 を超えません。
Output
入力データセットごとに、コースの滑り方のパターン数を1行に出力します。
Sample Input
5 5
0 0 0 0 1
2 1 0 2 0
1 0 0 1 1
0 2 1 2 0
0 1 0 0 0
5 5
0 0 1 0 0
2 1 0 2 0
1 0 0 1 1
0 2 1 2 0
0 1 0 0 0
15 15
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0
Output for the Sample Input
8
6
52694573",Python,"import sys

def solve(X, Y, grid):
    # dp[y][x] = number of ways to reach position (x, y)
    dp = [[0] * X for _ in range(Y + 1)]
    
    # Initialize starting positions at y=0 (0-indexed, which is y=1 in problem)
    for x in range(X):
        if grid[0][x] != 1:  # not an obstacle
            dp[0][x] = 1
    
    # Process each row
    for y in range(Y):
        for x in range(X):
            if dp[y][x] == 0:
                continue
            
            # Check if current position has a jump platform
            if grid[y][x] == 2:
                # Jump to (x, y+2)
                target_y = y + 2
                if target_y < Y:
                    if grid[target_y][x] != 1:  # not an obstacle
                        dp[target_y][x] += dp[y][x]
                else:
                    # Reached beyond Y, count as completion
                    # We need to track completions separately
                    pass
            else:
                # Normal movement to (x-1, y+1), (x, y+1), (x+1, y+1)
                target_y = y + 1
                if target_y < Y:
                    # Move to (x-1, y+1)
                    if x - 1 >= 0:
                        if grid[target_y][x-1] == 2:
                            # Can't enter jump platform from diagonal
                            pass
                        elif grid[target_y][x-1] != 1:
                            dp[target_y][x-1] += dp[y][x]
                    
                    # Move to (x, y+1)
                    if grid[target_y][x] != 1:
                        dp[target_y][x] += dp[y][x]
                    
                    # Move to (x+1, y+1)
                    if x + 1 < X:
                        if grid[target_y][x+1] == 2:
                            # Can't enter jump platform from diagonal
                            pass
                        elif grid[target_y][x+1] != 1:
                            dp[target_y][x+1] += dp[y][x]
    
    # Count paths that reach y >= Y
    total = 0
    
    # Add paths from y = Y-1
    for x in range(X):
        if dp[Y-1][x] > 0:
            if grid[Y-1][x] == 2:
                # Jump from Y-1 goes to Y+1, which is >= Y
                total += dp[Y-1][x]
            else:
                # Normal movement from Y-1 goes to Y, which is >= Y
                total += dp[Y-1][x]
    
    # Add paths from y = Y-2 that jump
    if Y >= 2:
        for x in range(X):
            if dp[Y-2][x] > 0 and grid[Y-2][x] == 2:
                # Jump from Y-2 goes to Y, which is >= Y
                # But we need to check if this was already counted
                # Actually, when we process Y-2, we add to dp[Y][x] if Y < Y, which is false
                # So we need to handle this separately
                pass
    
    return total

# Read input
while True:
    line = input().split()
    X, Y = int(line[0]), int(line[1])
    
    if X == 0 and Y == 0:
        break
    
    grid = []
    for y in range(Y):
        row = list(map(int, input().split()))
        grid.append(row)
    
    # Re-implement with better logic
    dp = [[0] * X for _ in range(Y + 2)]
    
    # Initialize
    for x in range(X):
        if grid[0][x] != 1:
            dp[0][x] = 1
    
    for y in range(Y + 1):
        for x in range(X):
            if dp[y][x] == 0:
                continue
            
            if y >= Y:
                continue
            
            if grid[y][x] == 2:
                # Jump
                target_y = y + 2
                if target_y <= Y:
                    dp[target_y][x] += dp[y][x]
            else:
                # Normal move
                target_y = y + 1
                if target_y <= Y:
                    for dx in [-1, 0, 1]:
                        nx = x + dx
                        if 0 <= nx < X:
                            if target_y < Y:
                                if grid[target_y][nx] == 2 and dx != 0:
                                    continue
                                if grid[target_y][nx] != 1:
                                    dp[target_y][nx] += dp[y][x]
                            else:
                                dp[target_y][nx] += dp[y][x]
    
    result = sum(dp[Y])
    print(result)
",0
p00203,"会津山スキー場の新企画
会津山スキー場の経営者である油木屋さんは、上級者向けとして障害物やジャンプ台を配置したコースを用意しました。コースにはいろいろな滑り方があり、シーズン中に全てのパターンの滑り方が出来た利用者には、プレゼントを贈ることになっています。
油木屋さんのために、コースの見取り図をもとに滑り方のパターン数を出力するプログラムを作ってあげましょう。
コースは上図のような
X × Y
個のマスからなるグリッドで表されます。左上を原点とし、x 座標は右に行くにつれて大きくなり、y 座標は下にいくにつれて大きくなるものとします。
各滑り方のパターンは、最も高いところ(
y = 1
、ただし障害物の無いところ) からスタートし、ゴール(
y = Y
) に向かって進んでいきます。グリッドのマス(
x, y
) にいる滑走者は、(
x − 1, y + 1
)、(
x, y + 1
)、 (
x + 1, y + 1
) のいずれかに移動することができます。マスには、障害物やジャンプ台があり、障害物のあるマスには進入できず、ジャンプ台があるマスに進入すると(
x, y + 2
) へ移動します。ただし、いちばん高いマス (
y = 1
のマス) にはジャンプ台は存在せず、ジャンプ台のあるマスに進入する際には x 座標が同じマスからしか進入できません。コースの上端(
y = 1
) からスタートし、コースからはずれることなく下端を超えれば(
y ≥ Y
) 1つの滑り方とみなし、滑り終わります。
コースの情報を入力とし、滑り方の総数を出力するプログラムを作成してください。
Input
複数のデータセットの並びが入力として与えられます。入力の終わりはゼロふたつの行で示されます。各データセットは以下の形式で与えられます。
X
Y
c
11
c
21
...
c
X1
c
12
c
22
...
c
X2
:
c
1Y
c
2Y
...
c
XY
1 行目にコースの大きさ
X, Y
(1 ≤
X, Y
≤ 15) が与えられます。続く
Y
行にコースの情報が与えられます。
c
ij
(0 , 1 , 2 のいずれか) は
x = i, y = j
のマスの情報を表す整数で、0 が移動可能なマス、1 が障害物があるマス、2 がジャンプ台があるマスを表します。
データセットの数は 50 を超えません。
Output
入力データセットごとに、コースの滑り方のパターン数を1行に出力します。
Sample Input
5 5
0 0 0 0 1
2 1 0 2 0
1 0 0 1 1
0 2 1 2 0
0 1 0 0 0
5 5
0 0 1 0 0
2 1 0 2 0
1 0 0 1 1
0 2 1 2 0
0 1 0 0 0
15 15
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0
Output for the Sample Input
8
6
52694573",Python,"while 1:
	X,Y = map(int,raw_input().split())
	if X == 0: break
	A = [[0]+map(int,raw_input().split())+[0] for i in range(Y)]
	S = [[0]*(X+2) for i in range(Y)]
	for x in range(1,X+1): S[0][x] = 1 if A[0][x] != 1 else 0
	for y in range(1,Y):
		for x in range(1,X+1):
			if A[y][x] == 0:
				for i in range(-1,2):
					S[y][x] += (S[y-1][x-i] if A[y-1][x-i] == 0 else 0)
			if A[y][x] == 2:
				S[y][x] += S[y-1][x-1]
				if y+2 < Y and A[y+2][x] != 1:
					S[y+2][x] = S[y][x]
	ans = 0
	for x in range(1,X+1):
		ans += S[Y-1][x] + (S[Y-2][x] if A[Y-2][x] == 2 else 0)
	print ans",1
p00204,"UFO 撃墜作戦
40XX 年、地球は宇宙人の侵攻を受けていた!すでに地球のほとんどは宇宙人により制圧されており、残る防衛拠点は鶴ヶ城要塞のみになってしまった。その鶴ヶ城要塞にも、制圧部隊が次々に迫ってきている。
しかし、希望は残されている。防衛軍の最終兵器、超長距離貫通レーザー砲が完成したのだ。欠点といえば、   威力が出るまでに一定の距離が必要で、          近すぎる敵はただ通りぬけてしまうということだ。  威力が出ない範囲に侵入した敵は、他の戦力でどうにかするしかない。防衛軍の参謀は、侵入して来た UFO に対処するために、その数を知らなければならないのだが、あまりにも敵が多いせいでうまく数えられそうにない。そこで参謀はあなたに、レーザーに撃墜されなかった UFO の数を出力するプログラムを用意するように命令した。戦闘開始までにプログラムを作成し、鶴ヶ城要塞を守る力となろう。
敵の UFO はただまっすぐにレーザー砲のある拠点を目指して突撃してくる(UFO には互いにすり抜ける処理が施されており、衝突してしまうことはない) 。レーザー砲は、初期状態から 1 分後に最も近い UFO の中心を狙ってレーザーを発射し始め、それから 1 分ごとに同じ条件でレーザーを発射し続ける。レーザーは貫通し、その先にある UFO もレーザーがかすっただけで撃墜することができる。しかし、このレーザーには威力の出ない範囲があり、その範囲に入ってしまったUFO は狙っても意味がないため、狙わないように設計されている。撃墜できるだけ撃墜したとき、レーザーの威力が出ない範囲には何機の UFO が侵入しただろうか。
レーザーの威力が出ない範囲の半径
R
と、襲来する UFO の情報を入力とし、撃墜されず侵入している UFO が何機いるかを出力するプログラムを作成してください。 襲来する UFO の情報は、UFO の数
N
、各 UFO の初期座標 (
x0, y0
)、各 UFO の半径
r
、各 UFO の分速
v
で構成されます。
座標の原点 (0 , 0) をレーザー砲の位置とします。レーザー砲と UFO の距離は原点から UFO の中心までの距離で与えられ、この距離が
R
以下の UFO はレーザーの威力が出ない範囲に入ったとします。狙うべき対象が同時に複数存在する場合はないものとして考えます。計算は全て平面上で考え、入力はすべて整数で与えられます。
Input
複数のデータセットの並びが入力として与えられます。 入力の終わりはゼロふたつの行で示されます。
各データセットは以下の形式で与えられます。
R
N
x0
1
y0
1
r
1
v
1
x0
2
y0
2
r
2
v
2
:
x0
N
y0
N
r
N
v
N
1 行目にレーザーの威力が出ない範囲の半径
R
(1 ≤
R
≤ 500) とUFO の数
N
(1 ≤
N
≤ 100) が与えられます。続く
N
行に
i
機目の UFO の情報
x0
i
,
y0
i
(-100 ≤
x0
i
,
y0
i
≤ 1000),
r
i
,
v
i
(1 ≤
r
i
,
v
i
≤ 500) が与えられます。
データセットの数は 50 を超えません。
Output
入力データセットごとに、レーザーの威力が出ない範囲に侵入した UFO の数を1行に出力します。
Sample Input
100 5
101 101 5 5
110 110 2 3
-112 -100 9 11
-208 160 82 90
-110 108 10 2
10 11
15 0 5 1
25 0 5 1
35 0 5 1
45 0 5 1
55 0 5 1
65 0 5 1
75 0 5 1
85 0 5 1
95 0 5 1
-20 0 5 20
-30 0 500 5
0 0
Output for the Sample Input
1
1",C,"#include <stdio.h>
#include <math.h>
#include <stdbool.h>

#define MAX_N 100
#define INF 1e9

typedef struct {
    double x, y;
    double r;
    double v;
    bool destroyed;
    bool entered;
} UFO;

double distance(double x, double y) {
    return sqrt(x * x + y * y);
}

double distancePointToLine(double px, double py, double lx, double ly) {
    if (lx == 0 && ly == 0) return INF;
    double dot = px * lx + py * ly;
    if (dot < 0) return INF;
    double len = sqrt(lx * lx + ly * ly);
    return fabs(px * ly - py * lx) / len;
}

int main() {
    int R, N;
    
    while (scanf(""%d %d"", &R, &N) == 2) {
        if (R == 0 && N == 0) break;
        
        UFO ufos[MAX_N];
        for (int i = 0; i < N; i++) {
            scanf(""%lf %lf %lf %lf"", &ufos[i].x, &ufos[i].y, &ufos[i].r, &ufos[i].v);
            ufos[i].destroyed = false;
            ufos[i].entered = false;
        }
        
        int time = 1;
        while (true) {
            bool any_outside = false;
            for (int i = 0; i < N; i++) {
                if (ufos[i].destroyed || ufos[i].entered) continue;
                
                double dx = -ufos[i].x;
                double dy = -ufos[i].y;
                double len = sqrt(dx * dx + dy * dy);
                dx /= len;
                dy /= len;
                
                double curr_x = ufos[i].x + dx * ufos[i].v * time;
                double curr_y = ufos[i].y + dy * ufos[i].v * time;
                double dist = distance(curr_x, curr_y);
                
                if (dist > R) {
                    any_outside = true;
                    break;
                }
            }
            
            if (!any_outside) break;
            
            int target = -1;
            double min_dist = INF;
            
            for (int i = 0; i < N; i++) {
                if (ufos[i].destroyed || ufos[i].entered) continue;
                
                double dx = -ufos[i].x;
                double dy = -ufos[i].y;
                double len = sqrt(dx * dx + dy * dy);
                dx /= len;
                dy /= len;
                
                double curr_x = ufos[i].x + dx * ufos[i].v * time;
                double curr_y = ufos[i].y + dy * ufos[i].v * time;
                double dist = distance(curr_x, curr_y);
                
                if (dist > R && dist < min_dist) {
                    min_dist = dist;
                    target = i;
                }
            }
            
            if (target != -1) {
                double dx = -ufos[target].x;
                double dy = -ufos[target].y;
                double len = sqrt(dx * dx + dy * dy);
                dx /= len;
                dy /= len;
                
                double target_x = ufos[target].x + dx * ufos[target].v * time;
                double target_y = ufos[target].y + dy * ufos[target].v * time;
                
                for (int i = 0; i < N; i++) {
                    if (ufos[i].destroyed || ufos[i].entered) continue;
                    
                    double dx2 = -ufos[i].x;
                    double dy2 = -ufos[i].y;
                    double len2 = sqrt(dx2 * dx2 + dy2 * dy2);
                    dx2 /= len2;
                    dy2 /= len2;
                    
                    double curr_x = ufos[i].x + dx2 * ufos[i].v * time;
                    double curr_y = ufos[i].y + dy2 * ufos[i].v * time;
                    
                    double dist_to_laser = distancePointToLine(curr_x, curr_y, target_x, target_y);
                    
                    if (dist_to_laser <= ufos[i].r) {
                        ufos[i].destroyed = true;
                    }
                }
            }
            
            for (int i = 0; i < N; i++) {
                if (ufos[i].destroyed || ufos[i].entered) continue;
                
                double dx = -ufos[i].x;
                double dy = -ufos[i].y;
                double len = sqrt(dx * dx + dy * dy);
                dx /= len;
                dy /= len;
                
                double curr_x = ufos[i].x + dx * ufos[i].v * time;
                double curr_y = ufos[i].y + dy * ufos[i].v * time;
                double dist = distance(curr_x, curr_y);
                
                if (dist <= R) {
                    ufos[i].entered = true;
                }
            }
            
            time++;
        }
        
        int count = 0;
        for (int i = 0; i < N; i++) {
            if (ufos[i].entered) count++;
        }
        
        printf(""%d\n"", count);
    }
    
    return 0;
}
",0
p00204,"UFO 撃墜作戦
40XX 年、地球は宇宙人の侵攻を受けていた!すでに地球のほとんどは宇宙人により制圧されており、残る防衛拠点は鶴ヶ城要塞のみになってしまった。その鶴ヶ城要塞にも、制圧部隊が次々に迫ってきている。
しかし、希望は残されている。防衛軍の最終兵器、超長距離貫通レーザー砲が完成したのだ。欠点といえば、   威力が出るまでに一定の距離が必要で、          近すぎる敵はただ通りぬけてしまうということだ。  威力が出ない範囲に侵入した敵は、他の戦力でどうにかするしかない。防衛軍の参謀は、侵入して来た UFO に対処するために、その数を知らなければならないのだが、あまりにも敵が多いせいでうまく数えられそうにない。そこで参謀はあなたに、レーザーに撃墜されなかった UFO の数を出力するプログラムを用意するように命令した。戦闘開始までにプログラムを作成し、鶴ヶ城要塞を守る力となろう。
敵の UFO はただまっすぐにレーザー砲のある拠点を目指して突撃してくる(UFO には互いにすり抜ける処理が施されており、衝突してしまうことはない) 。レーザー砲は、初期状態から 1 分後に最も近い UFO の中心を狙ってレーザーを発射し始め、それから 1 分ごとに同じ条件でレーザーを発射し続ける。レーザーは貫通し、その先にある UFO もレーザーがかすっただけで撃墜することができる。しかし、このレーザーには威力の出ない範囲があり、その範囲に入ってしまったUFO は狙っても意味がないため、狙わないように設計されている。撃墜できるだけ撃墜したとき、レーザーの威力が出ない範囲には何機の UFO が侵入しただろうか。
レーザーの威力が出ない範囲の半径
R
と、襲来する UFO の情報を入力とし、撃墜されず侵入している UFO が何機いるかを出力するプログラムを作成してください。 襲来する UFO の情報は、UFO の数
N
、各 UFO の初期座標 (
x0, y0
)、各 UFO の半径
r
、各 UFO の分速
v
で構成されます。
座標の原点 (0 , 0) をレーザー砲の位置とします。レーザー砲と UFO の距離は原点から UFO の中心までの距離で与えられ、この距離が
R
以下の UFO はレーザーの威力が出ない範囲に入ったとします。狙うべき対象が同時に複数存在する場合はないものとして考えます。計算は全て平面上で考え、入力はすべて整数で与えられます。
Input
複数のデータセットの並びが入力として与えられます。 入力の終わりはゼロふたつの行で示されます。
各データセットは以下の形式で与えられます。
R
N
x0
1
y0
1
r
1
v
1
x0
2
y0
2
r
2
v
2
:
x0
N
y0
N
r
N
v
N
1 行目にレーザーの威力が出ない範囲の半径
R
(1 ≤
R
≤ 500) とUFO の数
N
(1 ≤
N
≤ 100) が与えられます。続く
N
行に
i
機目の UFO の情報
x0
i
,
y0
i
(-100 ≤
x0
i
,
y0
i
≤ 1000),
r
i
,
v
i
(1 ≤
r
i
,
v
i
≤ 500) が与えられます。
データセットの数は 50 を超えません。
Output
入力データセットごとに、レーザーの威力が出ない範囲に侵入した UFO の数を1行に出力します。
Sample Input
100 5
101 101 5 5
110 110 2 3
-112 -100 9 11
-208 160 82 90
-110 108 10 2
10 11
15 0 5 1
25 0 5 1
35 0 5 1
45 0 5 1
55 0 5 1
65 0 5 1
75 0 5 1
85 0 5 1
95 0 5 1
-20 0 5 20
-30 0 500 5
0 0
Output for the Sample Input
1
1",C,"#include <stdio.h>
#include <math.h>

#define EPS (1e-8)

typedef struct {
	double x,y;
	double angle;
	int r;
	int v;
	int arrive;
} ufo_t;

int N;
ufo_t ufo[100];
int R;

double get_dist(double mx,double my,double x,double y) {
	return fabs(my*x-mx*y)/sqrt(my*my+mx*mx);
}

int main(void) {
	int i;
	int target;
	double target_dist;
	int count;
	while(1) {
		scanf(""%d%d"",&R,&N);
		if(R==0 && N==0)break;
		for(i=0;i<N;i++) {
			scanf(""%lf%lf%d%d"",
				&ufo[i].x,&ufo[i].y,&ufo[i].r,&ufo[i].v);
			ufo[i].arrive=1;
			ufo[i].angle=atan2(ufo[i].y,ufo[i].x);
		}
		target=0;
		while(target>=0) {
			for(i=0;i<N;i++) {
				if(R+EPS<sqrt(ufo[i].x*ufo[i].x+ufo[i].y*ufo[i].y)) {
					double prev_x,prev_y;
					prev_x=ufo[i].x;
					prev_y=ufo[i].y;
					ufo[i].x-=ufo[i].v*cos(ufo[i].angle);
					ufo[i].y-=ufo[i].v*sin(ufo[i].angle);
					if(prev_x*ufo[i].x<0)ufo[i].x=0;
					if(prev_y*ufo[i].y<0)ufo[i].y=0;
				}
			}
			target=-1;
			target_dist=1000*1000;
			for(i=0;i<N;i++) {
				double dist;
				if(!ufo[i].arrive)continue;
				dist=sqrt(ufo[i].x*ufo[i].x+ufo[i].y*ufo[i].y);
				if(dist<target_dist+EPS && R+EPS<dist) {
					target_dist=dist;
					target=i;
				}
			}
			if(target<0)break;
			for(i=0;i<N;i++) {
				if(sqrt(ufo[i].x*ufo[i].x+
					ufo[i].y*ufo[i].y)<R+EPS)continue;
				if(get_dist(ufo[target].x,ufo[target].y,
						ufo[i].x,ufo[i].y)<ufo[i].r+EPS &&
						ufo[target].x*ufo[i].x>=0 &&
						ufo[target].y*ufo[i].y>=0) {
					ufo[i].arrive=0;
				}
			}
		}
		count=0;
		for(i=0;i<N;i++) {
			if(ufo[i].arrive)count++;
		}
		printf(""%d\n"",count);
	}
	return 0;
}",1
p00204,"UFO 撃墜作戦
40XX 年、地球は宇宙人の侵攻を受けていた!すでに地球のほとんどは宇宙人により制圧されており、残る防衛拠点は鶴ヶ城要塞のみになってしまった。その鶴ヶ城要塞にも、制圧部隊が次々に迫ってきている。
しかし、希望は残されている。防衛軍の最終兵器、超長距離貫通レーザー砲が完成したのだ。欠点といえば、   威力が出るまでに一定の距離が必要で、          近すぎる敵はただ通りぬけてしまうということだ。  威力が出ない範囲に侵入した敵は、他の戦力でどうにかするしかない。防衛軍の参謀は、侵入して来た UFO に対処するために、その数を知らなければならないのだが、あまりにも敵が多いせいでうまく数えられそうにない。そこで参謀はあなたに、レーザーに撃墜されなかった UFO の数を出力するプログラムを用意するように命令した。戦闘開始までにプログラムを作成し、鶴ヶ城要塞を守る力となろう。
敵の UFO はただまっすぐにレーザー砲のある拠点を目指して突撃してくる(UFO には互いにすり抜ける処理が施されており、衝突してしまうことはない) 。レーザー砲は、初期状態から 1 分後に最も近い UFO の中心を狙ってレーザーを発射し始め、それから 1 分ごとに同じ条件でレーザーを発射し続ける。レーザーは貫通し、その先にある UFO もレーザーがかすっただけで撃墜することができる。しかし、このレーザーには威力の出ない範囲があり、その範囲に入ってしまったUFO は狙っても意味がないため、狙わないように設計されている。撃墜できるだけ撃墜したとき、レーザーの威力が出ない範囲には何機の UFO が侵入しただろうか。
レーザーの威力が出ない範囲の半径
R
と、襲来する UFO の情報を入力とし、撃墜されず侵入している UFO が何機いるかを出力するプログラムを作成してください。 襲来する UFO の情報は、UFO の数
N
、各 UFO の初期座標 (
x0, y0
)、各 UFO の半径
r
、各 UFO の分速
v
で構成されます。
座標の原点 (0 , 0) をレーザー砲の位置とします。レーザー砲と UFO の距離は原点から UFO の中心までの距離で与えられ、この距離が
R
以下の UFO はレーザーの威力が出ない範囲に入ったとします。狙うべき対象が同時に複数存在する場合はないものとして考えます。計算は全て平面上で考え、入力はすべて整数で与えられます。
Input
複数のデータセットの並びが入力として与えられます。 入力の終わりはゼロふたつの行で示されます。
各データセットは以下の形式で与えられます。
R
N
x0
1
y0
1
r
1
v
1
x0
2
y0
2
r
2
v
2
:
x0
N
y0
N
r
N
v
N
1 行目にレーザーの威力が出ない範囲の半径
R
(1 ≤
R
≤ 500) とUFO の数
N
(1 ≤
N
≤ 100) が与えられます。続く
N
行に
i
機目の UFO の情報
x0
i
,
y0
i
(-100 ≤
x0
i
,
y0
i
≤ 1000),
r
i
,
v
i
(1 ≤
r
i
,
v
i
≤ 500) が与えられます。
データセットの数は 50 を超えません。
Output
入力データセットごとに、レーザーの威力が出ない範囲に侵入した UFO の数を1行に出力します。
Sample Input
100 5
101 101 5 5
110 110 2 3
-112 -100 9 11
-208 160 82 90
-110 108 10 2
10 11
15 0 5 1
25 0 5 1
35 0 5 1
45 0 5 1
55 0 5 1
65 0 5 1
75 0 5 1
85 0 5 1
95 0 5 1
-20 0 5 20
-30 0 500 5
0 0
Output for the Sample Input
1
1",Java,"import java.util.*;
import java.io.*;

public class Main {
    static class UFO {
        double x, y;
        double r;
        double v;
        boolean destroyed;
        int id;
        
        UFO(double x, double y, double r, double v, int id) {
            this.x = x;
            this.y = y;
            this.r = r;
            this.v = v;
            this.destroyed = false;
            this.id = id;
        }
        
        double distanceFromOrigin() {
            return Math.sqrt(x * x + y * y);
        }
        
        void moveTowardsOrigin(double time) {
            if (destroyed) return;
            double dist = distanceFromOrigin();
            if (dist == 0) return;
            double moveAmount = v * time;
            if (moveAmount >= dist) {
                x = 0;
                y = 0;
            } else {
                double ratio = moveAmount / dist;
                x -= x * ratio;
                y -= y * ratio;
            }
        }
    }
    
    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        String line;
        
        while ((line = br.readLine()) != null) {
            String[] parts = line.trim().split(""\\s+"");
            int R = Integer.parseInt(parts[0]);
            int N = Integer.parseInt(parts[1]);
            
            if (R == 0 && N == 0) break;
            
            List<UFO> ufos = new ArrayList<>();
            for (int i = 0; i < N; i++) {
                line = br.readLine();
                parts = line.trim().split(""\\s+"");
                double x0 = Double.parseDouble(parts[0]);
                double y0 = Double.parseDouble(parts[1]);
                double r = Double.parseDouble(parts[2]);
                double v = Double.parseDouble(parts[3]);
                ufos.add(new UFO(x0, y0, r, v, i));
            }
            
            int time = 1;
            while (true) {
                // Move all UFOs
                for (UFO ufo : ufos) {
                    ufo.moveTowardsOrigin(1);
                }
                
                // Find closest UFO outside R
                UFO target = null;
                double minDist = Double.MAX_VALUE;
                
                for (UFO ufo : ufos) {
                    if (!ufo.destroyed && ufo.distanceFromOrigin() > R) {
                        double dist = ufo.distanceFromOrigin();
                        if (dist < minDist) {
                            minDist = dist;
                            target = ufo;
                        }
                    }
                }
                
                if (target == null) break;
                
                // Shoot laser through target
                double tx = target.x;
                double ty = target.y;
                
                for (UFO ufo : ufos) {
                    if (!ufo.destroyed && ufo.distanceFromOrigin() > R) {
                        if (laserHits(tx, ty, ufo)) {
                            ufo.destroyed = true;
                        }
                    }
                }
                
                time++;
                if (time > 10000) break;
            }
            
            int count = 0;
            for (UFO ufo : ufos) {
                if (!ufo.destroyed) {
                    count++;
                }
            }
            
            System.out.println(count);
        }
    }
    
    static boolean laserHits(double lx, double ly, UFO ufo) {
        // Laser goes from origin through (lx, ly)
        // Check if it intersects circle at (ufo.x, ufo.y) with radius ufo.r
        
        double laserLen = Math.sqrt(lx * lx + ly * ly);
        if (laserLen == 0) return false;
        
        // Normalize laser direction
        double ldx = lx / laserLen;
        double ldy = ly / laserLen;
        
        // Distance from ufo center to laser line
        double dist = Math.abs(ldy * ufo.x - ldx * ufo.y);
        
        if (dist > ufo.r) return false;
        
        // Check if UFO is in the direction of the laser
        double dot = ufo.x * ldx + ufo.y * ldy;
        return dot > 0;
    }
}
",0
p00204,"UFO 撃墜作戦
40XX 年、地球は宇宙人の侵攻を受けていた!すでに地球のほとんどは宇宙人により制圧されており、残る防衛拠点は鶴ヶ城要塞のみになってしまった。その鶴ヶ城要塞にも、制圧部隊が次々に迫ってきている。
しかし、希望は残されている。防衛軍の最終兵器、超長距離貫通レーザー砲が完成したのだ。欠点といえば、   威力が出るまでに一定の距離が必要で、          近すぎる敵はただ通りぬけてしまうということだ。  威力が出ない範囲に侵入した敵は、他の戦力でどうにかするしかない。防衛軍の参謀は、侵入して来た UFO に対処するために、その数を知らなければならないのだが、あまりにも敵が多いせいでうまく数えられそうにない。そこで参謀はあなたに、レーザーに撃墜されなかった UFO の数を出力するプログラムを用意するように命令した。戦闘開始までにプログラムを作成し、鶴ヶ城要塞を守る力となろう。
敵の UFO はただまっすぐにレーザー砲のある拠点を目指して突撃してくる(UFO には互いにすり抜ける処理が施されており、衝突してしまうことはない) 。レーザー砲は、初期状態から 1 分後に最も近い UFO の中心を狙ってレーザーを発射し始め、それから 1 分ごとに同じ条件でレーザーを発射し続ける。レーザーは貫通し、その先にある UFO もレーザーがかすっただけで撃墜することができる。しかし、このレーザーには威力の出ない範囲があり、その範囲に入ってしまったUFO は狙っても意味がないため、狙わないように設計されている。撃墜できるだけ撃墜したとき、レーザーの威力が出ない範囲には何機の UFO が侵入しただろうか。
レーザーの威力が出ない範囲の半径
R
と、襲来する UFO の情報を入力とし、撃墜されず侵入している UFO が何機いるかを出力するプログラムを作成してください。 襲来する UFO の情報は、UFO の数
N
、各 UFO の初期座標 (
x0, y0
)、各 UFO の半径
r
、各 UFO の分速
v
で構成されます。
座標の原点 (0 , 0) をレーザー砲の位置とします。レーザー砲と UFO の距離は原点から UFO の中心までの距離で与えられ、この距離が
R
以下の UFO はレーザーの威力が出ない範囲に入ったとします。狙うべき対象が同時に複数存在する場合はないものとして考えます。計算は全て平面上で考え、入力はすべて整数で与えられます。
Input
複数のデータセットの並びが入力として与えられます。 入力の終わりはゼロふたつの行で示されます。
各データセットは以下の形式で与えられます。
R
N
x0
1
y0
1
r
1
v
1
x0
2
y0
2
r
2
v
2
:
x0
N
y0
N
r
N
v
N
1 行目にレーザーの威力が出ない範囲の半径
R
(1 ≤
R
≤ 500) とUFO の数
N
(1 ≤
N
≤ 100) が与えられます。続く
N
行に
i
機目の UFO の情報
x0
i
,
y0
i
(-100 ≤
x0
i
,
y0
i
≤ 1000),
r
i
,
v
i
(1 ≤
r
i
,
v
i
≤ 500) が与えられます。
データセットの数は 50 を超えません。
Output
入力データセットごとに、レーザーの威力が出ない範囲に侵入した UFO の数を1行に出力します。
Sample Input
100 5
101 101 5 5
110 110 2 3
-112 -100 9 11
-208 160 82 90
-110 108 10 2
10 11
15 0 5 1
25 0 5 1
35 0 5 1
45 0 5 1
55 0 5 1
65 0 5 1
75 0 5 1
85 0 5 1
95 0 5 1
-20 0 5 20
-30 0 500 5
0 0
Output for the Sample Input
1
1",Java,"import java.util.Scanner;

public class Main {
	public static void main(String[] args) {
		Scanner s = new Scanner(System.in);
		int r, n;
		while ((r = s.nextInt()) != 0 && (n = s.nextInt()) != 0) {
			double[][] ufo = new double[n][6];  // x, y, r, v(, dis, fin_step)
			for (int i = 0; i < n; i++) {
				for (int j = 0; j < 4; j++)
					ufo[i][j] = s.nextInt();
				ufo[i][4] = Math.hypot(ufo[i][0], ufo[i][1]); // £
				ufo[i][5] = Math.floor((Math.abs(ufo[i][4]) - r) / ufo[i][3]); // NüÔ
			}

			int[] st = new int[n];
			for (int i = 0; i < n; i++)	st[i] = 0;
			
			for (int i = 0; i < n; i++) { // step				
				 // Åàß¢UFOðTµA¯ÉNüµ½UFOÉ}[N
				int near = -1;
				for (int j = 0; j < n; j++) {
					if (st[j] != 0) continue; // ùÉNüorÄ
					if (ufo[j][5] < i) st[j] = 1;  // Nüµ½
					else if (near == -1 || ufo[near][4] > ufo[j][4])
						near = j; // Åàß¢UFO
				}
				if (near == -1) break;
				double x0 = ufo[near][0]; // Åàß¢UFO
				double y0 = ufo[near][1];

				// UFOðÄ
				for (int j = 0; j < n; j++) {
					if (st[j] != 0) continue; // ùÉNü©ÄóÔÈçX[
					double x1 = ufo[j][0];
					double y1 = ufo[j][1];
					
					if (y0 == 0) {
						if ((x0 >= 0 && x1 >= 0) || (x0 < 0 && x1 < 0)) // ¯¶ü«
							if (Math.abs(y1) <= r) st[j] = 2; // Ä
					} else if (x0 == 0) {
						if ((y0 >= 0 && y1 >= 0) || (y0 < 0 && y1 < 0)) // ¯¶ü«
							if (Math.abs(x1) <= r) st[j] = 2; // Ä
					} else {
						double a = y0 / x0; // X«
						if ((x0 >= 0 && x1 >= 0) || (x0 < 0 && x1 < 0)) // ¯¶ü«
							if ((y0 >= 0 && y1 >= 0) || (y0 < 0 && y1 < 0))
								if (Math.abs(y1 - a * x1) <= r) st[j] = 2; // Ä
					}
				}
				
				for (int j = 0; j < n; j++) { // UFOÚ®
					if (st[j] != 0) continue; // ùÉNü©ÄóÔÈçX[
					ufo[j][4] -= ufo[j][3];
				}
			}
			
			int sum = 0;
			for (int j = 0; j < n; j++)
				if (st[j] == 1) sum++;
			System.out.println(sum);
		}
	}
}",1
p00204,"UFO 撃墜作戦
40XX 年、地球は宇宙人の侵攻を受けていた!すでに地球のほとんどは宇宙人により制圧されており、残る防衛拠点は鶴ヶ城要塞のみになってしまった。その鶴ヶ城要塞にも、制圧部隊が次々に迫ってきている。
しかし、希望は残されている。防衛軍の最終兵器、超長距離貫通レーザー砲が完成したのだ。欠点といえば、   威力が出るまでに一定の距離が必要で、          近すぎる敵はただ通りぬけてしまうということだ。  威力が出ない範囲に侵入した敵は、他の戦力でどうにかするしかない。防衛軍の参謀は、侵入して来た UFO に対処するために、その数を知らなければならないのだが、あまりにも敵が多いせいでうまく数えられそうにない。そこで参謀はあなたに、レーザーに撃墜されなかった UFO の数を出力するプログラムを用意するように命令した。戦闘開始までにプログラムを作成し、鶴ヶ城要塞を守る力となろう。
敵の UFO はただまっすぐにレーザー砲のある拠点を目指して突撃してくる(UFO には互いにすり抜ける処理が施されており、衝突してしまうことはない) 。レーザー砲は、初期状態から 1 分後に最も近い UFO の中心を狙ってレーザーを発射し始め、それから 1 分ごとに同じ条件でレーザーを発射し続ける。レーザーは貫通し、その先にある UFO もレーザーがかすっただけで撃墜することができる。しかし、このレーザーには威力の出ない範囲があり、その範囲に入ってしまったUFO は狙っても意味がないため、狙わないように設計されている。撃墜できるだけ撃墜したとき、レーザーの威力が出ない範囲には何機の UFO が侵入しただろうか。
レーザーの威力が出ない範囲の半径
R
と、襲来する UFO の情報を入力とし、撃墜されず侵入している UFO が何機いるかを出力するプログラムを作成してください。 襲来する UFO の情報は、UFO の数
N
、各 UFO の初期座標 (
x0, y0
)、各 UFO の半径
r
、各 UFO の分速
v
で構成されます。
座標の原点 (0 , 0) をレーザー砲の位置とします。レーザー砲と UFO の距離は原点から UFO の中心までの距離で与えられ、この距離が
R
以下の UFO はレーザーの威力が出ない範囲に入ったとします。狙うべき対象が同時に複数存在する場合はないものとして考えます。計算は全て平面上で考え、入力はすべて整数で与えられます。
Input
複数のデータセットの並びが入力として与えられます。 入力の終わりはゼロふたつの行で示されます。
各データセットは以下の形式で与えられます。
R
N
x0
1
y0
1
r
1
v
1
x0
2
y0
2
r
2
v
2
:
x0
N
y0
N
r
N
v
N
1 行目にレーザーの威力が出ない範囲の半径
R
(1 ≤
R
≤ 500) とUFO の数
N
(1 ≤
N
≤ 100) が与えられます。続く
N
行に
i
機目の UFO の情報
x0
i
,
y0
i
(-100 ≤
x0
i
,
y0
i
≤ 1000),
r
i
,
v
i
(1 ≤
r
i
,
v
i
≤ 500) が与えられます。
データセットの数は 50 を超えません。
Output
入力データセットごとに、レーザーの威力が出ない範囲に侵入した UFO の数を1行に出力します。
Sample Input
100 5
101 101 5 5
110 110 2 3
-112 -100 9 11
-208 160 82 90
-110 108 10 2
10 11
15 0 5 1
25 0 5 1
35 0 5 1
45 0 5 1
55 0 5 1
65 0 5 1
75 0 5 1
85 0 5 1
95 0 5 1
-20 0 5 20
-30 0 500 5
0 0
Output for the Sample Input
1
1",Python,"import math

def distance(x, y):
    return math.sqrt(x*x + y*y)

def line_circle_intersection(x0, y0, r, px, py):
    # Check if line from origin through (px, py) intersects circle at (x0, y0) with radius r
    # Line can be parameterized as (t*px, t*py) for t >= 0
    # Circle: (x-x0)^2 + (y-y0)^2 = r^2
    # Substitute: (t*px - x0)^2 + (t*py - y0)^2 = r^2
    
    if px == 0 and py == 0:
        return distance(x0, y0) <= r
    
    # Line direction vector (px, py)
    # Distance from point (x0, y0) to line through origin with direction (px, py)
    # d = |x0*py - y0*px| / sqrt(px^2 + py^2)
    
    d = abs(x0 * py - y0 * px) / math.sqrt(px*px + py*py)
    
    return d <= r

while True:
    line = input().split()
    R = int(line[0])
    N = int(line[1])
    
    if R == 0 and N == 0:
        break
    
    ufos = []
    for i in range(N):
        parts = list(map(int, input().split()))
        x0, y0, r, v = parts[0], parts[1], parts[2], parts[3]
        ufos.append([x0, y0, r, v, True])  # True means not destroyed
    
    time = 1
    invaded = 0
    
    while True:
        # Move all UFOs
        for i in range(N):
            if ufos[i][4]:  # If not destroyed
                x0, y0, r, v = ufos[i][0], ufos[i][1], ufos[i][2], ufos[i][3]
                dist = distance(x0, y0)
                if dist > 0:
                    # Move towards origin
                    dx = -x0 / dist
                    dy = -y0 / dist
                    ufos[i][0] += dx * v * time
                    ufos[i][1] += dy * v * time
        
        # Check for invaded UFOs
        for i in range(N):
            if ufos[i][4]:
                dist = distance(ufos[i][0], ufos[i][1])
                if dist <= R:
                    invaded += 1
                    ufos[i][4] = False
        
        # Find closest UFO outside R
        min_dist = float('inf')
        target_idx = -1
        for i in range(N):
            if ufos[i][4]:
                dist = distance(ufos[i][0], ufos[i][1])
                if dist > R and dist < min_dist:
                    min_dist = dist
                    target_idx = i
        
        if target_idx == -1:
            break
        
        # Fire laser at target
        tx, ty = ufos[target_idx][0], ufos[target_idx][1]
        
        # Destroy all UFOs that intersect with this laser line
        for i in range(N):
            if ufos[i][4]:
                dist = distance(ufos[i][0], ufos[i][1])
                if dist > R:
                    if line_circle_intersection(ufos[i][0], ufos[i][1], ufos[i][2], tx, ty):
                        ufos[i][4] = False
        
        time = 1
    
    print(invaded)
",0
p00204,"UFO 撃墜作戦
40XX 年、地球は宇宙人の侵攻を受けていた!すでに地球のほとんどは宇宙人により制圧されており、残る防衛拠点は鶴ヶ城要塞のみになってしまった。その鶴ヶ城要塞にも、制圧部隊が次々に迫ってきている。
しかし、希望は残されている。防衛軍の最終兵器、超長距離貫通レーザー砲が完成したのだ。欠点といえば、   威力が出るまでに一定の距離が必要で、          近すぎる敵はただ通りぬけてしまうということだ。  威力が出ない範囲に侵入した敵は、他の戦力でどうにかするしかない。防衛軍の参謀は、侵入して来た UFO に対処するために、その数を知らなければならないのだが、あまりにも敵が多いせいでうまく数えられそうにない。そこで参謀はあなたに、レーザーに撃墜されなかった UFO の数を出力するプログラムを用意するように命令した。戦闘開始までにプログラムを作成し、鶴ヶ城要塞を守る力となろう。
敵の UFO はただまっすぐにレーザー砲のある拠点を目指して突撃してくる(UFO には互いにすり抜ける処理が施されており、衝突してしまうことはない) 。レーザー砲は、初期状態から 1 分後に最も近い UFO の中心を狙ってレーザーを発射し始め、それから 1 分ごとに同じ条件でレーザーを発射し続ける。レーザーは貫通し、その先にある UFO もレーザーがかすっただけで撃墜することができる。しかし、このレーザーには威力の出ない範囲があり、その範囲に入ってしまったUFO は狙っても意味がないため、狙わないように設計されている。撃墜できるだけ撃墜したとき、レーザーの威力が出ない範囲には何機の UFO が侵入しただろうか。
レーザーの威力が出ない範囲の半径
R
と、襲来する UFO の情報を入力とし、撃墜されず侵入している UFO が何機いるかを出力するプログラムを作成してください。 襲来する UFO の情報は、UFO の数
N
、各 UFO の初期座標 (
x0, y0
)、各 UFO の半径
r
、各 UFO の分速
v
で構成されます。
座標の原点 (0 , 0) をレーザー砲の位置とします。レーザー砲と UFO の距離は原点から UFO の中心までの距離で与えられ、この距離が
R
以下の UFO はレーザーの威力が出ない範囲に入ったとします。狙うべき対象が同時に複数存在する場合はないものとして考えます。計算は全て平面上で考え、入力はすべて整数で与えられます。
Input
複数のデータセットの並びが入力として与えられます。 入力の終わりはゼロふたつの行で示されます。
各データセットは以下の形式で与えられます。
R
N
x0
1
y0
1
r
1
v
1
x0
2
y0
2
r
2
v
2
:
x0
N
y0
N
r
N
v
N
1 行目にレーザーの威力が出ない範囲の半径
R
(1 ≤
R
≤ 500) とUFO の数
N
(1 ≤
N
≤ 100) が与えられます。続く
N
行に
i
機目の UFO の情報
x0
i
,
y0
i
(-100 ≤
x0
i
,
y0
i
≤ 1000),
r
i
,
v
i
(1 ≤
r
i
,
v
i
≤ 500) が与えられます。
データセットの数は 50 を超えません。
Output
入力データセットごとに、レーザーの威力が出ない範囲に侵入した UFO の数を1行に出力します。
Sample Input
100 5
101 101 5 5
110 110 2 3
-112 -100 9 11
-208 160 82 90
-110 108 10 2
10 11
15 0 5 1
25 0 5 1
35 0 5 1
45 0 5 1
55 0 5 1
65 0 5 1
75 0 5 1
85 0 5 1
95 0 5 1
-20 0 5 20
-30 0 500 5
0 0
Output for the Sample Input
1
1",Python,"from math import sqrt
while 1:
    R, N = map(int, raw_input().split())
    if R == N == 0:
        break
    P = []
    for i in xrange(N):
        x, y, r, v = map(int, raw_input().split())
        P.append((sqrt(x**2+y**2), x**2+y**2, x, y, r, v, i))
    kill = [0]*N
    ans = 0
    for t in xrange(1, N+1):
        j = None; mi = 10**9
        for l, ll, x, y, r, v, i in P:
            if kill[i]:
                continue
            if ll < (R + t*v)**2:
                kill[i] = 1
                ans += 1

            if not kill[i] and l - t*v < mi:
                mi = l - t*v
                j = i
        if j is None:
            break
        l0, ll0, x0, y0, r0, v0, j = P[j]
        for l, ll, x, y, r, v, i in P:
            if kill[i]:
                continue
            if (l - t*v)*abs(x0*y - x*y0) < r*l*l0 + 1e-8:
                kill[i] = 1
    print ans",1
p00205,"じゃんけん
仲良し 5 人組でじゃんけんをすることになりました。じゃんけんとは、グー、チョキ、パーという 3つの手があり、グーとチョキの勝負ならグーが「勝ち」・チョキが「負け」、チョキとパーなら、チョキが「勝ち」・パーが「負け」、パーとグーならパーが「勝ち」・グーが「負け」というルールです。全員が同じ手、またはグー、チョキ、パー全てが出た場合は「あいこ」となります。
5 人のじゃんけんの手を入力とし、それぞれの人の勝敗を出力するプログラムを作成してください。じゃんけんの手は、グーは 1、チョキは 2、パーは 3 の数字で表します。勝敗は「勝ち」を 1、「負け」を 2、「あいこ」を 3 の数字で表し、入力順に従って出力します。
Input
複数のデータセットの並びが入力として与えられます。入力の終わりはゼロひとつの行で示されます。
各データセットは以下の形式で与えられます。
h
1
h
2
h
3
h
4
h
5
i
行目に
i
人目の手
h
i
(1, 2 または 3) が与えられます。
データセットの数は 200 を超えません。
Output
入力データセットごとに、5 人の勝敗を出力します。
i
行目に
i
人目の勝敗(1, 2 または 3) を出力してください。
Sample Input
1
2
3
2
1
1
2
2
2
1
0
Output for the Sample Input
3
3
3
3
3
1
2
2
2
1",C,"#include <stdio.h>

int main() {
    int h[5];
    
    while(1) {
        scanf(""%d"", &h[0]);
        if(h[0] == 0) break;
        
        for(int i = 1; i < 5; i++) {
            scanf(""%d"", &h[i]);
        }
        
        int count[4] = {0};
        for(int i = 0; i < 5; i++) {
            count[h[i]]++;
        }
        
        int types = 0;
        for(int i = 1; i <= 3; i++) {
            if(count[i] > 0) types++;
        }
        
        if(types == 1 || types == 3) {
            for(int i = 0; i < 5; i++) {
                printf(""3\n"");
            }
        } else {
            int winning_hand;
            if(count[1] > 0 && count[2] > 0) {
                winning_hand = 1;
            } else if(count[2] > 0 && count[3] > 0) {
                winning_hand = 2;
            } else {
                winning_hand = 3;
            }
            
            for(int i = 0; i < 5; i++) {
                if(h[i] == winning_hand) {
                    printf(""1\n"");
                } else {
                    printf(""2\n"");
                }
            }
        }
    }
    
    return 0;
}
",0
p00205,"じゃんけん
仲良し 5 人組でじゃんけんをすることになりました。じゃんけんとは、グー、チョキ、パーという 3つの手があり、グーとチョキの勝負ならグーが「勝ち」・チョキが「負け」、チョキとパーなら、チョキが「勝ち」・パーが「負け」、パーとグーならパーが「勝ち」・グーが「負け」というルールです。全員が同じ手、またはグー、チョキ、パー全てが出た場合は「あいこ」となります。
5 人のじゃんけんの手を入力とし、それぞれの人の勝敗を出力するプログラムを作成してください。じゃんけんの手は、グーは 1、チョキは 2、パーは 3 の数字で表します。勝敗は「勝ち」を 1、「負け」を 2、「あいこ」を 3 の数字で表し、入力順に従って出力します。
Input
複数のデータセットの並びが入力として与えられます。入力の終わりはゼロひとつの行で示されます。
各データセットは以下の形式で与えられます。
h
1
h
2
h
3
h
4
h
5
i
行目に
i
人目の手
h
i
(1, 2 または 3) が与えられます。
データセットの数は 200 を超えません。
Output
入力データセットごとに、5 人の勝敗を出力します。
i
行目に
i
人目の勝敗(1, 2 または 3) を出力してください。
Sample Input
1
2
3
2
1
1
2
2
2
1
0
Output for the Sample Input
3
3
3
3
3
1
2
2
2
1",C,"#include<stdio.h>
int main(void){
        int point[10][10]={0};
        int person=0,endFlag=0,result=0,count,repeat,versusCount,myGTP,theyGTP;
        printf(""入力\n"");
        for(count=0; endFlag==0; count++){
                for(person=0; person<5 && endFlag==0; person++){
                        scanf(""%d"",&point[count][person]);
                        if(point[count][person]<0||point[count][person]>3){
                        printf(""エラー、終了します。"");
                        exit(1);
                                }
                        if(point[count][person]==0){
                                endFlag=1;
                                }
                        }
                }
        repeat=count;
        printf(""\n出力\n"");
        for(count=0; count<repeat; count++){
                for(person=0; point[count][person]!=0; person++){
                        for(versusCount=0; point[count][versusCount]!=0; versusCount++){
                        myGTP=point[count][person];
                        theyGTP=point[count][versusCount];
                        if(person!=versusCount){
                        if(((myGTP+1==theyGTP)||(myGTP-2==theyGTP))&&(result!=1)&&(result!=3)){
                                result+=1;
                                }
                        if(((myGTP+2==theyGTP)||(myGTP-1==theyGTP))&&(result!=2)&&(result!=3)){
                                result+=2;
                                }
                        }
                        }
                if(result==0){
                        result=3;
                        }
                                printf(""\n%d"",result);
                                result=0;
                                }
                        }
        return 0;
}",1
p00205,"じゃんけん
仲良し 5 人組でじゃんけんをすることになりました。じゃんけんとは、グー、チョキ、パーという 3つの手があり、グーとチョキの勝負ならグーが「勝ち」・チョキが「負け」、チョキとパーなら、チョキが「勝ち」・パーが「負け」、パーとグーならパーが「勝ち」・グーが「負け」というルールです。全員が同じ手、またはグー、チョキ、パー全てが出た場合は「あいこ」となります。
5 人のじゃんけんの手を入力とし、それぞれの人の勝敗を出力するプログラムを作成してください。じゃんけんの手は、グーは 1、チョキは 2、パーは 3 の数字で表します。勝敗は「勝ち」を 1、「負け」を 2、「あいこ」を 3 の数字で表し、入力順に従って出力します。
Input
複数のデータセットの並びが入力として与えられます。入力の終わりはゼロひとつの行で示されます。
各データセットは以下の形式で与えられます。
h
1
h
2
h
3
h
4
h
5
i
行目に
i
人目の手
h
i
(1, 2 または 3) が与えられます。
データセットの数は 200 を超えません。
Output
入力データセットごとに、5 人の勝敗を出力します。
i
行目に
i
人目の勝敗(1, 2 または 3) を出力してください。
Sample Input
1
2
3
2
1
1
2
2
2
1
0
Output for the Sample Input
3
3
3
3
3
1
2
2
2
1",Java,"import java.util.Scanner;

public class Main {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        
        while (true) {
            int h1 = sc.nextInt();
            if (h1 == 0) break;
            
            int h2 = sc.nextInt();
            int h3 = sc.nextInt();
            int h4 = sc.nextInt();
            int h5 = sc.nextInt();
            
            int[] hands = {h1, h2, h3, h4, h5};
            
            boolean hasRock = false;
            boolean hasScissors = false;
            boolean hasPaper = false;
            
            for (int hand : hands) {
                if (hand == 1) hasRock = true;
                else if (hand == 2) hasScissors = true;
                else if (hand == 3) hasPaper = true;
            }
            
            int distinctCount = 0;
            if (hasRock) distinctCount++;
            if (hasScissors) distinctCount++;
            if (hasPaper) distinctCount++;
            
            if (distinctCount == 1 || distinctCount == 3) {
                for (int i = 0; i < 5; i++) {
                    System.out.println(3);
                }
            } else {
                int winningHand;
                if (hasRock && hasScissors) {
                    winningHand = 1;
                } else if (hasScissors && hasPaper) {
                    winningHand = 2;
                } else {
                    winningHand = 3;
                }
                
                for (int hand : hands) {
                    if (hand == winningHand) {
                        System.out.println(1);
                    } else {
                        System.out.println(2);
                    }
                }
            }
        }
        
        sc.close();
    }
}
",0
p00205,"じゃんけん
仲良し 5 人組でじゃんけんをすることになりました。じゃんけんとは、グー、チョキ、パーという 3つの手があり、グーとチョキの勝負ならグーが「勝ち」・チョキが「負け」、チョキとパーなら、チョキが「勝ち」・パーが「負け」、パーとグーならパーが「勝ち」・グーが「負け」というルールです。全員が同じ手、またはグー、チョキ、パー全てが出た場合は「あいこ」となります。
5 人のじゃんけんの手を入力とし、それぞれの人の勝敗を出力するプログラムを作成してください。じゃんけんの手は、グーは 1、チョキは 2、パーは 3 の数字で表します。勝敗は「勝ち」を 1、「負け」を 2、「あいこ」を 3 の数字で表し、入力順に従って出力します。
Input
複数のデータセットの並びが入力として与えられます。入力の終わりはゼロひとつの行で示されます。
各データセットは以下の形式で与えられます。
h
1
h
2
h
3
h
4
h
5
i
行目に
i
人目の手
h
i
(1, 2 または 3) が与えられます。
データセットの数は 200 を超えません。
Output
入力データセットごとに、5 人の勝敗を出力します。
i
行目に
i
人目の勝敗(1, 2 または 3) を出力してください。
Sample Input
1
2
3
2
1
1
2
2
2
1
0
Output for the Sample Input
3
3
3
3
3
1
2
2
2
1",Java,"//Volume2-0205
import java.util.Scanner;

class Main {

	private static int[] cnt,
             		     player,
		                 result;

	public static void main(String[] args){
		int   victory,loss;

		Scanner sc = new Scanner(System.in);

		while(true){
			cnt    = new int[4];
			player = new int[5];
			result = new int[5];
			player[0] = sc.nextInt();
			if(player[0] == 0){break;}
			cnt[player[0]]++;
			for(int i=1;i<5;i++){
				player[i] = sc.nextInt();
				cnt[player[i]]++;
			}
			scape : {
				if(cnt[1] == 5 || cnt[2] == 5 || cnt[3] == 5 ||
				  (cnt[1] != 0 && cnt[2] != 0 && cnt[3] != 0    )){
					for(int j=0;j<5;j++){result[j] = 3;}
					break scape;
				}
				victory = 0; loss = 0;
				if       (cnt[1] != 0 && cnt[2] != 0){
					victory = 1;
					loss    = 2;
				} else if(cnt[2] != 0 && cnt[3] != 0){
					victory = 2;
					loss    = 3;
				} else if(cnt[1] != 0 && cnt[3] != 0){
					victory = 3;
					loss    = 1;
				}
				for(int j=0;j<5;j++){
					if        (player[j] == victory){
						result[j] = 1;
					} else if (player[j] == loss){
						result[j] = 2;
					}
				}
			}
			for(int i:result){System.out.println(i);}
		}
	}
}",1
p00205,"じゃんけん
仲良し 5 人組でじゃんけんをすることになりました。じゃんけんとは、グー、チョキ、パーという 3つの手があり、グーとチョキの勝負ならグーが「勝ち」・チョキが「負け」、チョキとパーなら、チョキが「勝ち」・パーが「負け」、パーとグーならパーが「勝ち」・グーが「負け」というルールです。全員が同じ手、またはグー、チョキ、パー全てが出た場合は「あいこ」となります。
5 人のじゃんけんの手を入力とし、それぞれの人の勝敗を出力するプログラムを作成してください。じゃんけんの手は、グーは 1、チョキは 2、パーは 3 の数字で表します。勝敗は「勝ち」を 1、「負け」を 2、「あいこ」を 3 の数字で表し、入力順に従って出力します。
Input
複数のデータセットの並びが入力として与えられます。入力の終わりはゼロひとつの行で示されます。
各データセットは以下の形式で与えられます。
h
1
h
2
h
3
h
4
h
5
i
行目に
i
人目の手
h
i
(1, 2 または 3) が与えられます。
データセットの数は 200 を超えません。
Output
入力データセットごとに、5 人の勝敗を出力します。
i
行目に
i
人目の勝敗(1, 2 または 3) を出力してください。
Sample Input
1
2
3
2
1
1
2
2
2
1
0
Output for the Sample Input
3
3
3
3
3
1
2
2
2
1",Python,"while True:
    h1 = int(input())
    if h1 == 0:
        break
    
    hands = [h1]
    for _ in range(4):
        hands.append(int(input()))
    
    unique_hands = set(hands)
    
    # Check if it's a draw (all same or all three types)
    if len(unique_hands) == 1 or len(unique_hands) == 3:
        for _ in range(5):
            print(3)
    else:
        # Two types of hands - determine winner
        hand_list = list(unique_hands)
        h_a, h_b = hand_list[0], hand_list[1]
        
        # Determine which hand wins
        # 1 (rock) beats 2 (scissors)
        # 2 (scissors) beats 3 (paper)
        # 3 (paper) beats 1 (rock)
        if (h_a == 1 and h_b == 2) or (h_a == 2 and h_b == 1):
            winning_hand = 1
        elif (h_a == 2 and h_b == 3) or (h_a == 3 and h_b == 2):
            winning_hand = 2
        else:  # (h_a == 3 and h_b == 1) or (h_a == 1 and h_b == 3)
            winning_hand = 3
        
        for hand in hands:
            if hand == winning_hand:
                print(1)
            else:
                print(2)
",0
p00205,"じゃんけん
仲良し 5 人組でじゃんけんをすることになりました。じゃんけんとは、グー、チョキ、パーという 3つの手があり、グーとチョキの勝負ならグーが「勝ち」・チョキが「負け」、チョキとパーなら、チョキが「勝ち」・パーが「負け」、パーとグーならパーが「勝ち」・グーが「負け」というルールです。全員が同じ手、またはグー、チョキ、パー全てが出た場合は「あいこ」となります。
5 人のじゃんけんの手を入力とし、それぞれの人の勝敗を出力するプログラムを作成してください。じゃんけんの手は、グーは 1、チョキは 2、パーは 3 の数字で表します。勝敗は「勝ち」を 1、「負け」を 2、「あいこ」を 3 の数字で表し、入力順に従って出力します。
Input
複数のデータセットの並びが入力として与えられます。入力の終わりはゼロひとつの行で示されます。
各データセットは以下の形式で与えられます。
h
1
h
2
h
3
h
4
h
5
i
行目に
i
人目の手
h
i
(1, 2 または 3) が与えられます。
データセットの数は 200 を超えません。
Output
入力データセットごとに、5 人の勝敗を出力します。
i
行目に
i
人目の勝敗(1, 2 または 3) を出力してください。
Sample Input
1
2
3
2
1
1
2
2
2
1
0
Output for the Sample Input
3
3
3
3
3
1
2
2
2
1",Python,"#5個のうち1番目の入力が0なら処理を終わる。
while True:
    line = []
    line.append(int(input()))
    if line[0] == 0:break

    #標準入力をしリストをセットにしたものを作る。
    for _ in range(4):line.append(int(input()))
    se = set(line)
    
    #全員が同じ数を出すか3種類の手が出たら5こ""3""を出力する。
    if len(se) == 1 or len(se) == 3:
        for _ in range(5):print(""3"")
        """"
    #じゃんけんの勝敗に基づき勝ちだったら""1""負けだったら""2""を出力する
    else:
        if sum(se) == 3:
            for i in line:
                if i == 1:print(""1"")
                else:print(""2"")
        if sum(se) == 4:
            for i in line:
                if i == 3:print(""1"")
                else:print(""2"")
        if sum(se) == 5:
            for i in line:
                if i == 2:print(""1"")
                else:print(""2"")
",1
p00206,"旅行はいつ?
あなたは友人と旅行に行きたいと考えています。ところが、浪費癖のある友人はなかなか旅行費用を貯めることができません。友人が今の生活を続けていると、旅行に行くのはいつになってしまうか分かりません。そこで、早く旅行に行きたいあなたは、友人が計画的に貯蓄することを助けるプログラムを作成することにしました。
友人のある月のお小遣いを
M
円、その月に使うお金を
N
円とすると、その月は (
M
-
N
) 円貯蓄されます。毎月の収支情報
M
、
N
を入力とし、貯蓄額が旅行費用
L
に達するのにかかる月数を出力するプログラムを作成してください。ただし、12 ヶ月を過ぎても貯蓄額が旅行費用に達しなかった場合はNA と出力してください。
Input
複数のデータセットの並びが入力として与えられます。     入力の終わりはゼロひとつの行で示されます。
各データセットは以下の形式で与えられます。
L
M
1
N
1
M
2
N
2
:
M
12
N
12
1 行目に旅行費用
L
(1 ≤
L
≤ 1000000, 整数) が与えられます。続く 12 行に、
i
月目の収支情報
M
i
,
N
i
(0 ≤
M
i
, N
i
≤ 100000,
N
i
≤
M
i
, 整数) が与えられます。
データセットの数は 1000 を超えません。
Output
入力データセットごとに、貯蓄額が旅行費用に達するのにかかる月数を１行に出力します。
Sample Input
10000
5000 3150
5000 5000
0 0
5000 1050
5000 3980
5000 210
5000 5000
5000 5000
0 0
5000 2100
5000 2100
5000 2100
29170
100000 100000
100000 100000
100000 100000
100000 100000
100000 100000
100000 100000
100000 100000
100000 100000
100000 100000
100000 100000
100000 100000
100000 70831
0
Output for the Sample Input
6
NA",C,"#include <stdio.h>

int main() {
    int L;
    
    while (scanf(""%d"", &L) == 1 && L != 0) {
        int savings = 0;
        int month = 0;
        int found = 0;
        
        for (int i = 1; i <= 12; i++) {
            int M, N;
            scanf(""%d %d"", &M, &N);
            
            if (!found) {
                savings += (M - N);
                if (savings >= L) {
                    month = i;
                    found = 1;
                }
            }
        }
        
        if (found) {
            printf(""%d\n"", month);
        } else {
            printf(""NA\n"");
        }
    }
    
    return 0;
}
",0
p00206,"旅行はいつ?
あなたは友人と旅行に行きたいと考えています。ところが、浪費癖のある友人はなかなか旅行費用を貯めることができません。友人が今の生活を続けていると、旅行に行くのはいつになってしまうか分かりません。そこで、早く旅行に行きたいあなたは、友人が計画的に貯蓄することを助けるプログラムを作成することにしました。
友人のある月のお小遣いを
M
円、その月に使うお金を
N
円とすると、その月は (
M
-
N
) 円貯蓄されます。毎月の収支情報
M
、
N
を入力とし、貯蓄額が旅行費用
L
に達するのにかかる月数を出力するプログラムを作成してください。ただし、12 ヶ月を過ぎても貯蓄額が旅行費用に達しなかった場合はNA と出力してください。
Input
複数のデータセットの並びが入力として与えられます。     入力の終わりはゼロひとつの行で示されます。
各データセットは以下の形式で与えられます。
L
M
1
N
1
M
2
N
2
:
M
12
N
12
1 行目に旅行費用
L
(1 ≤
L
≤ 1000000, 整数) が与えられます。続く 12 行に、
i
月目の収支情報
M
i
,
N
i
(0 ≤
M
i
, N
i
≤ 100000,
N
i
≤
M
i
, 整数) が与えられます。
データセットの数は 1000 を超えません。
Output
入力データセットごとに、貯蓄額が旅行費用に達するのにかかる月数を１行に出力します。
Sample Input
10000
5000 3150
5000 5000
0 0
5000 1050
5000 3980
5000 210
5000 5000
5000 5000
0 0
5000 2100
5000 2100
5000 2100
29170
100000 100000
100000 100000
100000 100000
100000 100000
100000 100000
100000 100000
100000 100000
100000 100000
100000 100000
100000 100000
100000 100000
100000 70831
0
Output for the Sample Input
6
NA",C,"#include<stdio.h>
int main(){
	int i=0,l,n,m,a[12],b;
	while(1){
		b=0;
		scanf(""%d"",&l);
		if(l==0){
			break;
		}
		for(i=0;i<12;i++){
			scanf(""%d%d"",&m,&n);
			a[i]=m-n;
		}
		for(i=0;i<12;i++){
			b=b+a[i];
			if(b>=l){
				printf(""%d\n"",i+1);
				break;
			}
		}
		if(b<l){
			printf(""NA\n"");
		}
	}
}",1
p00206,"旅行はいつ?
あなたは友人と旅行に行きたいと考えています。ところが、浪費癖のある友人はなかなか旅行費用を貯めることができません。友人が今の生活を続けていると、旅行に行くのはいつになってしまうか分かりません。そこで、早く旅行に行きたいあなたは、友人が計画的に貯蓄することを助けるプログラムを作成することにしました。
友人のある月のお小遣いを
M
円、その月に使うお金を
N
円とすると、その月は (
M
-
N
) 円貯蓄されます。毎月の収支情報
M
、
N
を入力とし、貯蓄額が旅行費用
L
に達するのにかかる月数を出力するプログラムを作成してください。ただし、12 ヶ月を過ぎても貯蓄額が旅行費用に達しなかった場合はNA と出力してください。
Input
複数のデータセットの並びが入力として与えられます。     入力の終わりはゼロひとつの行で示されます。
各データセットは以下の形式で与えられます。
L
M
1
N
1
M
2
N
2
:
M
12
N
12
1 行目に旅行費用
L
(1 ≤
L
≤ 1000000, 整数) が与えられます。続く 12 行に、
i
月目の収支情報
M
i
,
N
i
(0 ≤
M
i
, N
i
≤ 100000,
N
i
≤
M
i
, 整数) が与えられます。
データセットの数は 1000 を超えません。
Output
入力データセットごとに、貯蓄額が旅行費用に達するのにかかる月数を１行に出力します。
Sample Input
10000
5000 3150
5000 5000
0 0
5000 1050
5000 3980
5000 210
5000 5000
5000 5000
0 0
5000 2100
5000 2100
5000 2100
29170
100000 100000
100000 100000
100000 100000
100000 100000
100000 100000
100000 100000
100000 100000
100000 100000
100000 100000
100000 100000
100000 100000
100000 70831
0
Output for the Sample Input
6
NA",Java,"import java.util.Scanner;

public class Main {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        
        while (true) {
            int L = sc.nextInt();
            if (L == 0) break;
            
            int savings = 0;
            int month = 0;
            boolean found = false;
            
            for (int i = 1; i <= 12; i++) {
                int M = sc.nextInt();
                int N = sc.nextInt();
                savings += (M - N);
                
                if (!found && savings >= L) {
                    month = i;
                    found = true;
                }
            }
            
            if (found) {
                System.out.println(month);
            } else {
                System.out.println(""NA"");
            }
        }
        
        sc.close();
    }
}
",0
p00206,"旅行はいつ?
あなたは友人と旅行に行きたいと考えています。ところが、浪費癖のある友人はなかなか旅行費用を貯めることができません。友人が今の生活を続けていると、旅行に行くのはいつになってしまうか分かりません。そこで、早く旅行に行きたいあなたは、友人が計画的に貯蓄することを助けるプログラムを作成することにしました。
友人のある月のお小遣いを
M
円、その月に使うお金を
N
円とすると、その月は (
M
-
N
) 円貯蓄されます。毎月の収支情報
M
、
N
を入力とし、貯蓄額が旅行費用
L
に達するのにかかる月数を出力するプログラムを作成してください。ただし、12 ヶ月を過ぎても貯蓄額が旅行費用に達しなかった場合はNA と出力してください。
Input
複数のデータセットの並びが入力として与えられます。     入力の終わりはゼロひとつの行で示されます。
各データセットは以下の形式で与えられます。
L
M
1
N
1
M
2
N
2
:
M
12
N
12
1 行目に旅行費用
L
(1 ≤
L
≤ 1000000, 整数) が与えられます。続く 12 行に、
i
月目の収支情報
M
i
,
N
i
(0 ≤
M
i
, N
i
≤ 100000,
N
i
≤
M
i
, 整数) が与えられます。
データセットの数は 1000 を超えません。
Output
入力データセットごとに、貯蓄額が旅行費用に達するのにかかる月数を１行に出力します。
Sample Input
10000
5000 3150
5000 5000
0 0
5000 1050
5000 3980
5000 210
5000 5000
5000 5000
0 0
5000 2100
5000 2100
5000 2100
29170
100000 100000
100000 100000
100000 100000
100000 100000
100000 100000
100000 100000
100000 100000
100000 100000
100000 100000
100000 100000
100000 100000
100000 70831
0
Output for the Sample Input
6
NA",Java,"import java.util.Scanner;
class Main{
	static Scanner sc;
	static int L,M,N,T,mth;
	
	public static void main(String[]args){
		sc=new Scanner(System.in);
		
		while(sc.hasNext()){
			L=sc.nextInt();
			mth=0;
			T=0;M=0;N=0;
			for(int i=0;i<12;i++){
				M=sc.nextInt();
				N=sc.nextInt();
				T=T+M-N;
				if(T>=L && mth==0){
					mth=i+1;
				}
			}
			if(mth==0){System.out.println(""NA"");}
			else{System.out.println(mth);}
		}
	}
}",1
p00206,"旅行はいつ?
あなたは友人と旅行に行きたいと考えています。ところが、浪費癖のある友人はなかなか旅行費用を貯めることができません。友人が今の生活を続けていると、旅行に行くのはいつになってしまうか分かりません。そこで、早く旅行に行きたいあなたは、友人が計画的に貯蓄することを助けるプログラムを作成することにしました。
友人のある月のお小遣いを
M
円、その月に使うお金を
N
円とすると、その月は (
M
-
N
) 円貯蓄されます。毎月の収支情報
M
、
N
を入力とし、貯蓄額が旅行費用
L
に達するのにかかる月数を出力するプログラムを作成してください。ただし、12 ヶ月を過ぎても貯蓄額が旅行費用に達しなかった場合はNA と出力してください。
Input
複数のデータセットの並びが入力として与えられます。     入力の終わりはゼロひとつの行で示されます。
各データセットは以下の形式で与えられます。
L
M
1
N
1
M
2
N
2
:
M
12
N
12
1 行目に旅行費用
L
(1 ≤
L
≤ 1000000, 整数) が与えられます。続く 12 行に、
i
月目の収支情報
M
i
,
N
i
(0 ≤
M
i
, N
i
≤ 100000,
N
i
≤
M
i
, 整数) が与えられます。
データセットの数は 1000 を超えません。
Output
入力データセットごとに、貯蓄額が旅行費用に達するのにかかる月数を１行に出力します。
Sample Input
10000
5000 3150
5000 5000
0 0
5000 1050
5000 3980
5000 210
5000 5000
5000 5000
0 0
5000 2100
5000 2100
5000 2100
29170
100000 100000
100000 100000
100000 100000
100000 100000
100000 100000
100000 100000
100000 100000
100000 100000
100000 100000
100000 100000
100000 100000
100000 70831
0
Output for the Sample Input
6
NA",Python,"while True:
    L = int(input())
    if L == 0:
        break
    
    savings = 0
    months = 0
    found = False
    
    for month in range(1, 13):
        M, N = map(int, input().split())
        savings += (M - N)
        if savings >= L and not found:
            months = month
            found = True
    
    if found:
        print(months)
    else:
        print(""NA"")
",0
p00206,"旅行はいつ?
あなたは友人と旅行に行きたいと考えています。ところが、浪費癖のある友人はなかなか旅行費用を貯めることができません。友人が今の生活を続けていると、旅行に行くのはいつになってしまうか分かりません。そこで、早く旅行に行きたいあなたは、友人が計画的に貯蓄することを助けるプログラムを作成することにしました。
友人のある月のお小遣いを
M
円、その月に使うお金を
N
円とすると、その月は (
M
-
N
) 円貯蓄されます。毎月の収支情報
M
、
N
を入力とし、貯蓄額が旅行費用
L
に達するのにかかる月数を出力するプログラムを作成してください。ただし、12 ヶ月を過ぎても貯蓄額が旅行費用に達しなかった場合はNA と出力してください。
Input
複数のデータセットの並びが入力として与えられます。     入力の終わりはゼロひとつの行で示されます。
各データセットは以下の形式で与えられます。
L
M
1
N
1
M
2
N
2
:
M
12
N
12
1 行目に旅行費用
L
(1 ≤
L
≤ 1000000, 整数) が与えられます。続く 12 行に、
i
月目の収支情報
M
i
,
N
i
(0 ≤
M
i
, N
i
≤ 100000,
N
i
≤
M
i
, 整数) が与えられます。
データセットの数は 1000 を超えません。
Output
入力データセットごとに、貯蓄額が旅行費用に達するのにかかる月数を１行に出力します。
Sample Input
10000
5000 3150
5000 5000
0 0
5000 1050
5000 3980
5000 210
5000 5000
5000 5000
0 0
5000 2100
5000 2100
5000 2100
29170
100000 100000
100000 100000
100000 100000
100000 100000
100000 100000
100000 100000
100000 100000
100000 100000
100000 100000
100000 100000
100000 100000
100000 70831
0
Output for the Sample Input
6
NA",Python,"while True:
    L = int(input())
    if L == 0:
        break
    
    flag = True
    ans = -1
    d = 0
    for i in range(12):
        M,N = [int(i) for i in input().split()]
        d = d + M - N
        if d >= L and flag:
            ans = i+1
            flag = False
    
    if ans >= 0:
        print(ans)
    else:
        print(""NA"")

",1
p00207,"ブロック
A さんの家に親戚の B 君がやってきました。彼は 3 歳でブロックが大好きです。彼が持っているブロックは図 1 のような形をしています。
図1
B 君はボードの上にブロックを敷き詰めています。彼に「何を作っているの?」と聞くと、彼は「迷路!!」と元気よく答えました。彼の言う迷路とは、スタートからゴールまで側面が接している、同じ色のブロックだけでたどることができるブロックの配置のことだそうです。図 2 は黄色のブロックにより、左上(スタート)から右下(ゴール)へ迷路ができていることを表しています。
図2
無邪気に遊んでいる B 君を横目に、プログラマーであるあなたは、ブロックの並びが迷路となっているかを確かめてみることにしました。
ブロックの情報とスタート、ゴールの座標を入力とし、ブロックが迷路となっていれば OK 、なっていなければ NG を出力するプログラムを作成してください。 ボードは横方向に
w
、縦方向に
h
の大きさをもち、 左上の座標は(1 , 1)、右下の座標は(
w, h
)とします。ブロックは
2 × 4
の長方形ですべて同じ大きさです。ブロックの色
c
は 1 (白)、2 (黄)、3 (緑)、4 (青)、5 (赤) のいずれかです。ブロックのボード上での向き
d
は 横方向に長い場合 0 、 縦方向に長い場合 1 とします。 ブロックの位置はブロックの左上の座標 (
x, y
) によって表されます。なお、ブロックの位置は他のブロックと重なることは無く、ボードからはみ出すこともありません。
Input
複数のデータセットの並びが入力として与えられます。        入力の終わりはゼロふたつの行で示されます。
各データセットは以下の形式で与えられます。
w
h
xs
ys
xg
yg
n
c
1
d
1
x
1
y
1
c
2
d
2
x
2
y
2
:
c
n
d
n
x
n
y
n
1 行目にボードの大きさ
w, h
(4 ≤
w, h
≤ 100) が与えられます。2 行目にスタートの座標
xs, ys
、3 行目にゴールの座標
xg, yg
が与えられます。
4 行目にブロックの個数
n
が与えられます。続く
n
行に
i
番目のブロックの色
c
i
、向き
d
i
、位置
x
i
, y
i
が与えられます。
データセットの数は 30 を超えません。
Output
入力データセットごとに、判別結果を１行に出力します。
Sample Input
20 20 
1 1
9 9
7
2 0 1 1
5 1 1 3
2 1 3 3
1 1 5 2
5 1 7 3
2 0 2 7
2 0 6 8
20 20
9 9
1 1
6
2 0 1 1
1 0 5 1
2 1 1 3
5 0 1 7
3 1 5 5
4 1 8 5
0 0
Output for the Sample Input
OK
NG",C,"#include <stdio.h>
#include <string.h>

int w, h, xs, ys, xg, yg, n;
int board[105][105];
int visited[105][105];

int dx[] = {0, 0, 1, -1};
int dy[] = {1, -1, 0, 0};

int dfs(int x, int y, int color) {
    if (x == xg && y == yg) {
        return 1;
    }
    
    visited[y][x] = 1;
    
    for (int i = 0; i < 4; i++) {
        int nx = x + dx[i];
        int ny = y + dy[i];
        
        if (nx >= 1 && nx <= w && ny >= 1 && ny <= h) {
            if (!visited[ny][nx] && board[ny][nx] == color) {
                if (dfs(nx, ny, color)) {
                    return 1;
                }
            }
        }
    }
    
    return 0;
}

int main() {
    while (1) {
        scanf(""%d %d"", &w, &h);
        if (w == 0 && h == 0) break;
        
        scanf(""%d %d"", &xs, &ys);
        scanf(""%d %d"", &xg, &yg);
        scanf(""%d"", &n);
        
        memset(board, 0, sizeof(board));
        memset(visited, 0, sizeof(visited));
        
        for (int i = 0; i < n; i++) {
            int c, d, x, y;
            scanf(""%d %d %d %d"", &c, &d, &x, &y);
            
            if (d == 0) {
                // horizontal: 4 wide, 2 tall
                for (int py = y; py < y + 2 && py <= h; py++) {
                    for (int px = x; px < x + 4 && px <= w; px++) {
                        board[py][px] = c;
                    }
                }
            } else {
                // vertical: 2 wide, 4 tall
                for (int py = y; py < y + 4 && py <= h; py++) {
                    for (int px = x; px < x + 2 && px <= w; px++) {
                        board[py][px] = c;
                    }
                }
            }
        }
        
        int startColor = board[ys][xs];
        
        if (startColor == 0 || board[yg][xg] != startColor) {
            printf(""NG\n"");
        } else {
            if (dfs(xs, ys, startColor)) {
                printf(""OK\n"");
            } else {
                printf(""NG\n"");
            }
        }
    }
    
    return 0;
}
",0
p00207,"ブロック
A さんの家に親戚の B 君がやってきました。彼は 3 歳でブロックが大好きです。彼が持っているブロックは図 1 のような形をしています。
図1
B 君はボードの上にブロックを敷き詰めています。彼に「何を作っているの?」と聞くと、彼は「迷路!!」と元気よく答えました。彼の言う迷路とは、スタートからゴールまで側面が接している、同じ色のブロックだけでたどることができるブロックの配置のことだそうです。図 2 は黄色のブロックにより、左上(スタート)から右下(ゴール)へ迷路ができていることを表しています。
図2
無邪気に遊んでいる B 君を横目に、プログラマーであるあなたは、ブロックの並びが迷路となっているかを確かめてみることにしました。
ブロックの情報とスタート、ゴールの座標を入力とし、ブロックが迷路となっていれば OK 、なっていなければ NG を出力するプログラムを作成してください。 ボードは横方向に
w
、縦方向に
h
の大きさをもち、 左上の座標は(1 , 1)、右下の座標は(
w, h
)とします。ブロックは
2 × 4
の長方形ですべて同じ大きさです。ブロックの色
c
は 1 (白)、2 (黄)、3 (緑)、4 (青)、5 (赤) のいずれかです。ブロックのボード上での向き
d
は 横方向に長い場合 0 、 縦方向に長い場合 1 とします。 ブロックの位置はブロックの左上の座標 (
x, y
) によって表されます。なお、ブロックの位置は他のブロックと重なることは無く、ボードからはみ出すこともありません。
Input
複数のデータセットの並びが入力として与えられます。        入力の終わりはゼロふたつの行で示されます。
各データセットは以下の形式で与えられます。
w
h
xs
ys
xg
yg
n
c
1
d
1
x
1
y
1
c
2
d
2
x
2
y
2
:
c
n
d
n
x
n
y
n
1 行目にボードの大きさ
w, h
(4 ≤
w, h
≤ 100) が与えられます。2 行目にスタートの座標
xs, ys
、3 行目にゴールの座標
xg, yg
が与えられます。
4 行目にブロックの個数
n
が与えられます。続く
n
行に
i
番目のブロックの色
c
i
、向き
d
i
、位置
x
i
, y
i
が与えられます。
データセットの数は 30 を超えません。
Output
入力データセットごとに、判別結果を１行に出力します。
Sample Input
20 20 
1 1
9 9
7
2 0 1 1
5 1 1 3
2 1 3 3
1 1 5 2
5 1 7 3
2 0 2 7
2 0 6 8
20 20
9 9
1 1
6
2 0 1 1
1 0 5 1
2 1 1 3
5 0 1 7
3 1 5 5
4 1 8 5
0 0
Output for the Sample Input
OK
NG",C,"/*
AizuOnline A0207
Title Block
*/
#include <stdio.h>
// Select Below
//#include <stdlib.h>
//#include <string.h>
//#include <float.h>
//#include <math.h>
//#include <limits.h>
#include <setjmp.h>
//Global data section
int w,h;
int xs,ys;
int xg,yg;
int n;
int c[100];
int d[100];
int x[100],y[100];
int bd[100][100];
jmp_buf env;

//
void init()
{
  int i,j;
  for(i=0;i<h;i++)
    for(j=0;j<w;j++)
      bd[i][j]=0;
  for(i=0;i<100;i++)
    {
      x[i]=y[i]=d[i]=c[i]=0;
    }
}
int get_block(int px,int py)
{
  int i;
  // printf(""GB%d,%d\n"",px,py);
  for(i=0;i<n;i++)
    if(d[i]==0)         // yokonaga
	{
	  if(px-x[i] >=0 && px-x[i] <=3 && 
	     py-y[i] >=0 && py-y[i] <= 1)
	    return(i);
	}
    else if(d[i]==1)         // tatenaga
      {
	if(px-x[i] >=0 && px-x[i] <=1 && 
	   py-y[i] >=0 && py-y[i] <=3)
	  return(i);
      }
  return(-1);
}
int show()
{
  int i,j;
  for(i=1;i<=h;i++)
    {
      for(j=1;j<=w;j++)
	printf(""%d"",bd[i][j]);
      printf(""\n"");
    }
  printf(""\n"");
}
void paint0(int px,int py,int col,int ww,int hh)
{
  int i,j;
  //printf(""P0 %d %d\n"",px,py);

    for(i=0;i<hh;i++)
      for(j=0;j<ww;j++)
	bd[py+i][px+j]=col;
}
int paint(int px,int py,int col)
{
  int cc,blk,dir,bx,by,w0,h0,i,j;
  //printf(""xyc=%d %d %d\n"",px,py,col);

  if(px < 1 ||py < 1) //out of bound
    return(0);
  if(bd[py][px])  // already painted
    return(0);
  blk=get_block(px,py);  // get block no of this place
  //printf(""blk=%d\n"",blk);
  if(blk<0)
    return(0);
  cc=c[blk];
  dir=d[blk];
  if(cc != col)
    return(0);             // different color

  bx=x[blk];
  by=y[blk];
   if(dir==0)         // yokonaga
     { w0=4;h0=2;}
   else
     { w0=2;h0=4;}

  paint0(bx,by,col,w0,h0); // paint this block

  if(xg >= bx && xg <= bx+w0 && 
     yg >= by && yg <= by+h0 )     // reach the goal
    {
      longjmp(env,1);
    }

   for(i=-1;i<w0+1;i++)
     if(i==-1||i==w0)
       for(j=0;j<h0;j++)
	 paint(bx+i,by+j,col);
     else
       for(j=-1;j<h0+1;j++)
	 paint(bx+i,by+j,col);

   return(0);
}
main()
{
  int i,bl,col,dir,ret;
  while(EOF != scanf(""%d %d"",&w,&h) && (w || h))
    {
      init();
      scanf(""%d %d"",&xs,&ys);
      scanf(""%d %d"",&xg,&yg);
      scanf(""%d"",&n);
      for(i=0;i<n;i++)
	scanf(""%d %d %d %d"",&(c[i]),&(d[i]),&(x[i]),&(y[i]));
      
      bl = get_block(xs,ys);
      col=c[bl];
      if(setjmp(env)==0)
	{
	  ret = paint(xs,ys,col);
	}
      else
	ret=-1;
      
      paint(1,1,2);
      show();
      printf(""%s\n"",ret?""OK"":""NG"");
    }
return(0);
}",1
p00207,"ブロック
A さんの家に親戚の B 君がやってきました。彼は 3 歳でブロックが大好きです。彼が持っているブロックは図 1 のような形をしています。
図1
B 君はボードの上にブロックを敷き詰めています。彼に「何を作っているの?」と聞くと、彼は「迷路!!」と元気よく答えました。彼の言う迷路とは、スタートからゴールまで側面が接している、同じ色のブロックだけでたどることができるブロックの配置のことだそうです。図 2 は黄色のブロックにより、左上(スタート)から右下(ゴール)へ迷路ができていることを表しています。
図2
無邪気に遊んでいる B 君を横目に、プログラマーであるあなたは、ブロックの並びが迷路となっているかを確かめてみることにしました。
ブロックの情報とスタート、ゴールの座標を入力とし、ブロックが迷路となっていれば OK 、なっていなければ NG を出力するプログラムを作成してください。 ボードは横方向に
w
、縦方向に
h
の大きさをもち、 左上の座標は(1 , 1)、右下の座標は(
w, h
)とします。ブロックは
2 × 4
の長方形ですべて同じ大きさです。ブロックの色
c
は 1 (白)、2 (黄)、3 (緑)、4 (青)、5 (赤) のいずれかです。ブロックのボード上での向き
d
は 横方向に長い場合 0 、 縦方向に長い場合 1 とします。 ブロックの位置はブロックの左上の座標 (
x, y
) によって表されます。なお、ブロックの位置は他のブロックと重なることは無く、ボードからはみ出すこともありません。
Input
複数のデータセットの並びが入力として与えられます。        入力の終わりはゼロふたつの行で示されます。
各データセットは以下の形式で与えられます。
w
h
xs
ys
xg
yg
n
c
1
d
1
x
1
y
1
c
2
d
2
x
2
y
2
:
c
n
d
n
x
n
y
n
1 行目にボードの大きさ
w, h
(4 ≤
w, h
≤ 100) が与えられます。2 行目にスタートの座標
xs, ys
、3 行目にゴールの座標
xg, yg
が与えられます。
4 行目にブロックの個数
n
が与えられます。続く
n
行に
i
番目のブロックの色
c
i
、向き
d
i
、位置
x
i
, y
i
が与えられます。
データセットの数は 30 を超えません。
Output
入力データセットごとに、判別結果を１行に出力します。
Sample Input
20 20 
1 1
9 9
7
2 0 1 1
5 1 1 3
2 1 3 3
1 1 5 2
5 1 7 3
2 0 2 7
2 0 6 8
20 20
9 9
1 1
6
2 0 1 1
1 0 5 1
2 1 1 3
5 0 1 7
3 1 5 5
4 1 8 5
0 0
Output for the Sample Input
OK
NG",Java,"import java.util.*;

public class Main {
    static class Block {
        int color;
        int dir;
        int x;
        int y;
        
        Block(int color, int dir, int x, int y) {
            this.color = color;
            this.dir = dir;
            this.x = x;
            this.y = y;
        }
    }
    
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        
        while (true) {
            int w = sc.nextInt();
            int h = sc.nextInt();
            
            if (w == 0 && h == 0) break;
            
            int xs = sc.nextInt();
            int ys = sc.nextInt();
            int xg = sc.nextInt();
            int yg = sc.nextInt();
            int n = sc.nextInt();
            
            int[][] board = new int[h + 1][w + 1];
            
            for (int i = 0; i < n; i++) {
                int c = sc.nextInt();
                int d = sc.nextInt();
                int x = sc.nextInt();
                int y = sc.nextInt();
                
                if (d == 0) { // horizontal (2 high, 4 wide)
                    for (int dy = 0; dy < 2; dy++) {
                        for (int dx = 0; dx < 4; dx++) {
                            if (y + dy <= h && x + dx <= w) {
                                board[y + dy][x + dx] = c;
                            }
                        }
                    }
                } else { // vertical (4 high, 2 wide)
                    for (int dy = 0; dy < 4; dy++) {
                        for (int dx = 0; dx < 2; dx++) {
                            if (y + dy <= h && x + dx <= w) {
                                board[y + dy][x + dx] = c;
                            }
                        }
                    }
                }
            }
            
            int startColor = board[ys][xs];
            int goalColor = board[yg][xg];
            
            if (startColor == 0 || goalColor == 0 || startColor != goalColor) {
                System.out.println(""NG"");
                continue;
            }
            
            boolean[][] visited = new boolean[h + 1][w + 1];
            Queue<int[]> queue = new LinkedList<>();
            queue.offer(new int[]{xs, ys});
            visited[ys][xs] = true;
            
            boolean found = false;
            int[] dx = {0, 0, 1, -1};
            int[] dy = {1, -1, 0, 0};
            
            while (!queue.isEmpty()) {
                int[] curr = queue.poll();
                int cx = curr[0];
                int cy = curr[1];
                
                if (cx == xg && cy == yg) {
                    found = true;
                    break;
                }
                
                for (int dir = 0; dir < 4; dir++) {
                    int nx = cx + dx[dir];
                    int ny = cy + dy[dir];
                    
                    if (nx >= 1 && nx <= w && ny >= 1 && ny <= h 
                        && !visited[ny][nx] 
                        && board[ny][nx] == startColor) {
                        visited[ny][nx] = true;
                        queue.offer(new int[]{nx, ny});
                    }
                }
            }
            
            System.out.println(found ? ""OK"" : ""NG"");
        }
        
        sc.close();
    }
}
",0
p00207,"ブロック
A さんの家に親戚の B 君がやってきました。彼は 3 歳でブロックが大好きです。彼が持っているブロックは図 1 のような形をしています。
図1
B 君はボードの上にブロックを敷き詰めています。彼に「何を作っているの?」と聞くと、彼は「迷路!!」と元気よく答えました。彼の言う迷路とは、スタートからゴールまで側面が接している、同じ色のブロックだけでたどることができるブロックの配置のことだそうです。図 2 は黄色のブロックにより、左上(スタート)から右下(ゴール)へ迷路ができていることを表しています。
図2
無邪気に遊んでいる B 君を横目に、プログラマーであるあなたは、ブロックの並びが迷路となっているかを確かめてみることにしました。
ブロックの情報とスタート、ゴールの座標を入力とし、ブロックが迷路となっていれば OK 、なっていなければ NG を出力するプログラムを作成してください。 ボードは横方向に
w
、縦方向に
h
の大きさをもち、 左上の座標は(1 , 1)、右下の座標は(
w, h
)とします。ブロックは
2 × 4
の長方形ですべて同じ大きさです。ブロックの色
c
は 1 (白)、2 (黄)、3 (緑)、4 (青)、5 (赤) のいずれかです。ブロックのボード上での向き
d
は 横方向に長い場合 0 、 縦方向に長い場合 1 とします。 ブロックの位置はブロックの左上の座標 (
x, y
) によって表されます。なお、ブロックの位置は他のブロックと重なることは無く、ボードからはみ出すこともありません。
Input
複数のデータセットの並びが入力として与えられます。        入力の終わりはゼロふたつの行で示されます。
各データセットは以下の形式で与えられます。
w
h
xs
ys
xg
yg
n
c
1
d
1
x
1
y
1
c
2
d
2
x
2
y
2
:
c
n
d
n
x
n
y
n
1 行目にボードの大きさ
w, h
(4 ≤
w, h
≤ 100) が与えられます。2 行目にスタートの座標
xs, ys
、3 行目にゴールの座標
xg, yg
が与えられます。
4 行目にブロックの個数
n
が与えられます。続く
n
行に
i
番目のブロックの色
c
i
、向き
d
i
、位置
x
i
, y
i
が与えられます。
データセットの数は 30 を超えません。
Output
入力データセットごとに、判別結果を１行に出力します。
Sample Input
20 20 
1 1
9 9
7
2 0 1 1
5 1 1 3
2 1 3 3
1 1 5 2
5 1 7 3
2 0 2 7
2 0 6 8
20 20
9 9
1 1
6
2 0 1 1
1 0 5 1
2 1 1 3
5 0 1 7
3 1 5 5
4 1 8 5
0 0
Output for the Sample Input
OK
NG",Java,"import java.util.*;
public class Main{
    public static void main(String[] args){
	new Main().run();
    }
    Scanner sc = new Scanner(System.in);

    int w, h, xs, ys, xg, yg, n;
    int c, d, x, y;

    int[][] block;
    boolean[][] route;
    int[] dirX = {1, 0, -1, 0};
    int[] dirY = {0, 1, 0, -1};

    void run(){
	while(sc.hasNext()){
	    w = sc.nextInt()+1;
	    h = sc.nextInt()+1;
	    if(w==1 && h==1) break;
	    put();
	    makeRoute();
	    //show();

	    if(!route[ys][xs] || !route[yg][xg]){
		System.out.println(""NG"");
		continue;
	    }
	    else System.out.println(search(xs, ys) ? ""OK"":""NG"");
	}
    }

    /*
      マンハッタン距離が近くなるように道を選ぶ
      (マンハッタン短縮を見つけられなければ)行ける所に行く
      どこにも行けなければほげ。
    */
    boolean search(int x, int y){
	int d = getD(x, y);
	boolean[] goodRoute = new boolean[4];
	boolean[] canRoute = new boolean[4];
	int gc = 0;
	int cc = 0;
	if(d==0) return true;

	for(int i=0; i<dirX.length; i++){
	    int a = x+dirX[i];
	    int b = y+dirY[i];
	    if(a>0 && a<w && b>0 && b<h && route[b][a]){
		canRoute[i] = true;
		cc++;
		if(getD(a, b)<d){
		    goodRoute[i] = true;
		    gc++;
		}
	    }
	}
	
	if(gc!=0){
	    for(int i=0; i<4; i++)
		if(goodRoute[i]) 
		    if(search(x+dirX[i], y+dirY[i])) return true;
	}
	else if(cc!=0){
	    for(int i=0; i<4; i++)
		if(canRoute[i]) 
		    if(search(x+dirX[i], y+dirY[i])) return true;
	}
		    
	return false;
    }

    int getD(int x, int y){ return Math.abs(xg-x) + Math.abs(yg-y); }

    void show(){
	for(int i=1; i<w; i++){
	    for(int k=1; k<h; k++)
		System.out.print(route[i][k] ? ""□"":""■"");
	    System.out.println();
	}
	System.out.println(""----------------"");
    }

    void put(){
	xs = sc.nextInt();
	ys = sc.nextInt();
	xg = sc.nextInt();
	yg = sc.nextInt();
	n = sc.nextInt();

	block = new int[h][w];
	route = new boolean[h][w];

	for(int i=0; i<n; i++){
	    c = sc.nextInt();
	    d = sc.nextInt();
	    x = sc.nextInt();
	    y = sc.nextInt();
	    if(d==0)
		for(int a=x; a<x+4; a++)
		    for(int b=y; b<y+2; b++)
			block[b][a] = c;    
	    else
		for(int a=x; a<x+2; a++)
		    for(int b=y; b<y+4; b++)
			block[b][a] = c;
	}
    }

    void makeRoute(){
	int tcolor = block[ys][xs];
	for(int i=0; i<w; i++)
	    for(int k=0; k<h; k++)
		if(block[k][i]==tcolor) route[k][i] = true;
    }
}",1
p00207,"ブロック
A さんの家に親戚の B 君がやってきました。彼は 3 歳でブロックが大好きです。彼が持っているブロックは図 1 のような形をしています。
図1
B 君はボードの上にブロックを敷き詰めています。彼に「何を作っているの?」と聞くと、彼は「迷路!!」と元気よく答えました。彼の言う迷路とは、スタートからゴールまで側面が接している、同じ色のブロックだけでたどることができるブロックの配置のことだそうです。図 2 は黄色のブロックにより、左上(スタート)から右下(ゴール)へ迷路ができていることを表しています。
図2
無邪気に遊んでいる B 君を横目に、プログラマーであるあなたは、ブロックの並びが迷路となっているかを確かめてみることにしました。
ブロックの情報とスタート、ゴールの座標を入力とし、ブロックが迷路となっていれば OK 、なっていなければ NG を出力するプログラムを作成してください。 ボードは横方向に
w
、縦方向に
h
の大きさをもち、 左上の座標は(1 , 1)、右下の座標は(
w, h
)とします。ブロックは
2 × 4
の長方形ですべて同じ大きさです。ブロックの色
c
は 1 (白)、2 (黄)、3 (緑)、4 (青)、5 (赤) のいずれかです。ブロックのボード上での向き
d
は 横方向に長い場合 0 、 縦方向に長い場合 1 とします。 ブロックの位置はブロックの左上の座標 (
x, y
) によって表されます。なお、ブロックの位置は他のブロックと重なることは無く、ボードからはみ出すこともありません。
Input
複数のデータセットの並びが入力として与えられます。        入力の終わりはゼロふたつの行で示されます。
各データセットは以下の形式で与えられます。
w
h
xs
ys
xg
yg
n
c
1
d
1
x
1
y
1
c
2
d
2
x
2
y
2
:
c
n
d
n
x
n
y
n
1 行目にボードの大きさ
w, h
(4 ≤
w, h
≤ 100) が与えられます。2 行目にスタートの座標
xs, ys
、3 行目にゴールの座標
xg, yg
が与えられます。
4 行目にブロックの個数
n
が与えられます。続く
n
行に
i
番目のブロックの色
c
i
、向き
d
i
、位置
x
i
, y
i
が与えられます。
データセットの数は 30 を超えません。
Output
入力データセットごとに、判別結果を１行に出力します。
Sample Input
20 20 
1 1
9 9
7
2 0 1 1
5 1 1 3
2 1 3 3
1 1 5 2
5 1 7 3
2 0 2 7
2 0 6 8
20 20
9 9
1 1
6
2 0 1 1
1 0 5 1
2 1 1 3
5 0 1 7
3 1 5 5
4 1 8 5
0 0
Output for the Sample Input
OK
NG",Python,"from collections import deque

def solve():
    while True:
        w, h = map(int, input().split())
        if w == 0 and h == 0:
            break
        
        xs, ys = map(int, input().split())
        xg, yg = map(int, input().split())
        n = int(input())
        
        # Create board to store color at each position
        board = [[0] * (w + 1) for _ in range(h + 1)]
        
        for _ in range(n):
            c, d, x, y = map(int, input().split())
            if d == 0:  # horizontal (2 height, 4 width)
                for dy in range(2):
                    for dx in range(4):
                        if 1 <= y + dy <= h and 1 <= x + dx <= w:
                            board[y + dy][x + dx] = c
            else:  # vertical (4 height, 2 width)
                for dy in range(4):
                    for dx in range(2):
                        if 1 <= y + dy <= h and 1 <= x + dx <= w:
                            board[y + dy][x + dx] = c
        
        # BFS from start to goal
        start_color = board[ys][xs]
        if start_color == 0 or board[yg][xg] != start_color:
            print(""NG"")
            continue
        
        visited = [[False] * (w + 1) for _ in range(h + 1)]
        queue = deque([(xs, ys)])
        visited[ys][xs] = True
        found = False
        
        while queue:
            x, y = queue.popleft()
            if x == xg and y == yg:
                found = True
                break
            
            # Check 4 adjacent cells
            for dx, dy in [(0, 1), (0, -1), (1, 0), (-1, 0)]:
                nx, ny = x + dx, y + dy
                if 1 <= nx <= w and 1 <= ny <= h:
                    if not visited[ny][nx] and board[ny][nx] == start_color:
                        visited[ny][nx] = True
                        queue.append((nx, ny))
        
        print(""OK"" if found else ""NG"")

solve()
",0
p00207,"ブロック
A さんの家に親戚の B 君がやってきました。彼は 3 歳でブロックが大好きです。彼が持っているブロックは図 1 のような形をしています。
図1
B 君はボードの上にブロックを敷き詰めています。彼に「何を作っているの?」と聞くと、彼は「迷路!!」と元気よく答えました。彼の言う迷路とは、スタートからゴールまで側面が接している、同じ色のブロックだけでたどることができるブロックの配置のことだそうです。図 2 は黄色のブロックにより、左上(スタート)から右下(ゴール)へ迷路ができていることを表しています。
図2
無邪気に遊んでいる B 君を横目に、プログラマーであるあなたは、ブロックの並びが迷路となっているかを確かめてみることにしました。
ブロックの情報とスタート、ゴールの座標を入力とし、ブロックが迷路となっていれば OK 、なっていなければ NG を出力するプログラムを作成してください。 ボードは横方向に
w
、縦方向に
h
の大きさをもち、 左上の座標は(1 , 1)、右下の座標は(
w, h
)とします。ブロックは
2 × 4
の長方形ですべて同じ大きさです。ブロックの色
c
は 1 (白)、2 (黄)、3 (緑)、4 (青)、5 (赤) のいずれかです。ブロックのボード上での向き
d
は 横方向に長い場合 0 、 縦方向に長い場合 1 とします。 ブロックの位置はブロックの左上の座標 (
x, y
) によって表されます。なお、ブロックの位置は他のブロックと重なることは無く、ボードからはみ出すこともありません。
Input
複数のデータセットの並びが入力として与えられます。        入力の終わりはゼロふたつの行で示されます。
各データセットは以下の形式で与えられます。
w
h
xs
ys
xg
yg
n
c
1
d
1
x
1
y
1
c
2
d
2
x
2
y
2
:
c
n
d
n
x
n
y
n
1 行目にボードの大きさ
w, h
(4 ≤
w, h
≤ 100) が与えられます。2 行目にスタートの座標
xs, ys
、3 行目にゴールの座標
xg, yg
が与えられます。
4 行目にブロックの個数
n
が与えられます。続く
n
行に
i
番目のブロックの色
c
i
、向き
d
i
、位置
x
i
, y
i
が与えられます。
データセットの数は 30 を超えません。
Output
入力データセットごとに、判別結果を１行に出力します。
Sample Input
20 20 
1 1
9 9
7
2 0 1 1
5 1 1 3
2 1 3 3
1 1 5 2
5 1 7 3
2 0 2 7
2 0 6 8
20 20
9 9
1 1
6
2 0 1 1
1 0 5 1
2 1 1 3
5 0 1 7
3 1 5 5
4 1 8 5
0 0
Output for the Sample Input
OK
NG",Python,"sys.setrecursionlimit(10000) 

def tansaku(cl,nc,ok,goal): #currentlocation,nonchecked,ok,goal
    [clx,cly]=cl
    for i in range(clx-1,clx+2):
        for j in range(cly-1,cly+2):
            if [i,j] in nc:
                nc.remove([i,j])
                ok.append([i,j])
                tansaku([i,j],nc,ok,goal)


while(1):
    [boardw,boardh]=[int(x) for x in raw_input().split()]
    if boardw==0 and boardh==0:
        break
    else:
        [startx,starty]=[int(x) for x in raw_input().split()]
        [goalx,goaly]=[int(x) for x in raw_input().split()]
        blockn=int(raw_input())
        blist={1:[],2:[],3:[],4:[],5:[]}
        startc=-1
        goalc=-1
        #mark location of block
        for i in range(blockn):
            [c,d,x,y]=[int(x) for x in raw_input().split()]
            if d: #d=1,tatenaga
                for xx in range(x,x+2):
                    for yy in range(y,y+4):
                        blist[c].append([xx,yy])
                        if [xx,yy]==[startx,starty]:
                            startc=c
                        if [xx,yy]==[goalx,goaly]:
                            goalc=c
            else:
                for xx in range(x,x+4):
                    for yy in range(y,y+2):
                        blist[c].append([xx,yy])
                        if [xx,yy]==[startx,starty]:
                            startc=c
                        if [xx,yy]==[goalx,goaly]:
                            goalc=c
        if startc==-1 or goalc==-1:
            print ""NG""
        elif startc != goalc:
            print ""NG""
        else:
            #check if connected
            cl=[startx,starty]
            nc=blist[c]
            nc.remove(cl)
            ok=[cl]
            goal=[goalx,goaly]
            tansaku(cl,nc,ok,goal)
            if goal in ok:
                print ""OK""
            else:
                print ""NG""",1
p00208,"病院の部屋番号
ウォーターデブンに住む建築家のデブンキーさんのもとに、古い大病院を改装する仕事の依頼が舞い込んできました。
国によっては忌み数(いみかず)として嫌われる数字を部屋番号に用いたくない人がいます(日本では 4 と 9 が有名です)。しかし、この病院の部屋番号は忌み数に関係なく、1 から順番に付けられていました。
それが気になったデブンキーさんは、機材やベッドの入れ替えが全て終わる前にウォーターデブンの忌み数である「4」と「6」を除いた数字で部屋番号を付けなおしてしまいました。しかし、入れ替え作業は旧部屋番号で計画していたので、残りの作業を確実に行うには旧部屋番号を新部屋番号に変換する必要があります。計算が苦手なデブンキーさんはこのことに気づいて愕然としています。
そんなデブンキーさんのために、旧部屋番号を入力とし対応する新部屋番号を出力するプログラムを作成してください。
15 番目までの部屋番号の対応表は以下のようになります。
旧部屋番号
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
新部屋番号
1
2
3
5
7
8
9
10
11
12
13
15
17
18
19
Input
複数のデータセットの並びが入力として与えられます。入力の終わりはゼロひとつの行で示されます。
各データセットとして、旧部屋番号を表す整数
n
(1 ≤
n
≤ 1,000,000,000) が１行に与えられます。
データセットの数は 30000 を超えません。
Output
入力データセットごとに、新部屋番号を１行に出力します。
Sample Input
15
100
1000000000
3
0
Output for the Sample Input
19
155
9358757000
3",C,"#include <stdio.h>

long long convert(long long n) {
    long long result = 0;
    long long base = 1;
    
    while (n > 0) {
        long long digit = n % 10;
        n /= 10;
        
        if (digit >= 4) digit++;
        if (digit >= 6) digit++;
        
        result = digit * base + result;
        base *= 10;
    }
    
    return result;
}

long long solve(long long n) {
    long long left = 1, right = 10000000000LL;
    long long answer = 1;
    
    while (left <= right) {
        long long mid = left + (right - left) / 2;
        long long converted = convert(mid);
        
        if (converted == n) {
            return n;
        } else if (converted < n) {
            answer = converted;
            left = mid + 1;
        } else {
            right = mid - 1;
        }
    }
    
    return answer;
}

long long count_valid(long long n) {
    if (n == 0) return 0;
    
    long long result = 0;
    long long power = 1;
    long long temp = n;
    int digits = 0;
    
    while (temp > 0) {
        digits++;
        temp /= 10;
    }
    
    for (int d = 1; d < digits; d++) {
        long long count = 1;
        for (int i = 0; i < d; i++) {
            count *= 8;
        }
        result += count;
    }
    
    temp = n;
    long long prefix = 0;
    for (int pos = digits; pos >= 1; pos--) {
        long long divisor = 1;
        for (int i = 1; i < pos; i++) {
            divisor *= 10;
        }
        
        long long digit = temp / divisor;
        temp %= divisor;
        
        long long count_before = digit;
        if (digit > 4) count_before--;
        if (digit > 6) count_before--;
        
        long long suffix_count = 1;
        for (int i = 1; i < pos; i++) {
            suffix_count *= 8;
        }
        
        result += count_before * suffix_count;
        
        if (digit == 4 || digit == 6) {
            return result;
        }
    }
    
    result++;
    return result;
}

long long find_nth(long long n) {
    long long left = 1, right = 10000000000LL;
    long long answer = 1;
    
    while (left <= right) {
        long long mid = left + (right - left) / 2;
        long long count = count_valid(mid);
        
        if (count == n) {
            while (mid % 10 == 4 || mid % 10 == 6) {
                mid--;
            }
            long long temp = mid;
            int has_4_or_6 = 0;
            while (temp > 0) {
                int d = temp % 10;
                if (d == 4 || d == 6) {
                    has_4_or_6 = 1;
                    break;
                }
                temp /= 10;
            }
            if (!has_4_or_6) {
                return mid;
            }
            right = mid - 1;
        } else if (count < n) {
            left = mid + 1;
        } else {
            answer = mid;
            right = mid - 1;
        }
    }
    
    while (left <= 10000000000LL) {
        long long count = count_valid(left);
        if (count == n) {
            long long temp = left;
            int has_4_or_6 = 0;
            while (temp > 0) {
                int d = temp % 10;
                if (d == 4 || d == 6) {
                    has_4_or_6 = 1;
                    break;
                }
                temp /= 10;
            }
            if (!has_4_or_6) {
                return left;
            }
        }
        left++;
    }
    
    return answer;
}

int main() {
    long long n;
    while (scanf(""%lld"", &n) == 1 && n != 0) {
        printf(""%lld\n"", find_nth(n));
    }
    return 0;
}
",0
p00208,"病院の部屋番号
ウォーターデブンに住む建築家のデブンキーさんのもとに、古い大病院を改装する仕事の依頼が舞い込んできました。
国によっては忌み数(いみかず)として嫌われる数字を部屋番号に用いたくない人がいます(日本では 4 と 9 が有名です)。しかし、この病院の部屋番号は忌み数に関係なく、1 から順番に付けられていました。
それが気になったデブンキーさんは、機材やベッドの入れ替えが全て終わる前にウォーターデブンの忌み数である「4」と「6」を除いた数字で部屋番号を付けなおしてしまいました。しかし、入れ替え作業は旧部屋番号で計画していたので、残りの作業を確実に行うには旧部屋番号を新部屋番号に変換する必要があります。計算が苦手なデブンキーさんはこのことに気づいて愕然としています。
そんなデブンキーさんのために、旧部屋番号を入力とし対応する新部屋番号を出力するプログラムを作成してください。
15 番目までの部屋番号の対応表は以下のようになります。
旧部屋番号
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
新部屋番号
1
2
3
5
7
8
9
10
11
12
13
15
17
18
19
Input
複数のデータセットの並びが入力として与えられます。入力の終わりはゼロひとつの行で示されます。
各データセットとして、旧部屋番号を表す整数
n
(1 ≤
n
≤ 1,000,000,000) が１行に与えられます。
データセットの数は 30000 を超えません。
Output
入力データセットごとに、新部屋番号を１行に出力します。
Sample Input
15
100
1000000000
3
0
Output for the Sample Input
19
155
9358757000
3",C,"long long table[8]={0,1,2,3,5,7,8,9},r;main(n,i){for(;scanf(""%d"",&n),n;printf(""%lld\n"",r))for(r=0,i=1;n;n/=8,i*=10)r+=table[n&7]*i;exit(0);}",1
p00208,"病院の部屋番号
ウォーターデブンに住む建築家のデブンキーさんのもとに、古い大病院を改装する仕事の依頼が舞い込んできました。
国によっては忌み数(いみかず)として嫌われる数字を部屋番号に用いたくない人がいます(日本では 4 と 9 が有名です)。しかし、この病院の部屋番号は忌み数に関係なく、1 から順番に付けられていました。
それが気になったデブンキーさんは、機材やベッドの入れ替えが全て終わる前にウォーターデブンの忌み数である「4」と「6」を除いた数字で部屋番号を付けなおしてしまいました。しかし、入れ替え作業は旧部屋番号で計画していたので、残りの作業を確実に行うには旧部屋番号を新部屋番号に変換する必要があります。計算が苦手なデブンキーさんはこのことに気づいて愕然としています。
そんなデブンキーさんのために、旧部屋番号を入力とし対応する新部屋番号を出力するプログラムを作成してください。
15 番目までの部屋番号の対応表は以下のようになります。
旧部屋番号
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
新部屋番号
1
2
3
5
7
8
9
10
11
12
13
15
17
18
19
Input
複数のデータセットの並びが入力として与えられます。入力の終わりはゼロひとつの行で示されます。
各データセットとして、旧部屋番号を表す整数
n
(1 ≤
n
≤ 1,000,000,000) が１行に与えられます。
データセットの数は 30000 を超えません。
Output
入力データセットごとに、新部屋番号を１行に出力します。
Sample Input
15
100
1000000000
3
0
Output for the Sample Input
19
155
9358757000
3",Java,"import java.util.*;

public class Main {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        
        while (true) {
            long n = sc.nextLong();
            if (n == 0) break;
            
            System.out.println(convertToNewRoomNumber(n));
        }
        
        sc.close();
    }
    
    static long convertToNewRoomNumber(long oldNumber) {
        long result = 0;
        long multiplier = 1;
        long remaining = oldNumber;
        
        while (remaining > 0) {
            long digit = remaining % 10;
            remaining /= 10;
            
            // Map digit to new system (base 8 excluding 4 and 6)
            // 0->0, 1->1, 2->2, 3->3, 4->5, 5->7, 6->8, 7->9
            long mappedDigit;
            if (digit <= 3) {
                mappedDigit = digit;
            } else if (digit == 4) {
                mappedDigit = 5;
            } else if (digit == 5) {
                mappedDigit = 7;
            } else if (digit == 6) {
                mappedDigit = 8;
            } else {
                mappedDigit = 9;
            }
            
            result += mappedDigit * multiplier;
            multiplier *= 10;
        }
        
        return result;
    }
}
",0
p00208,"病院の部屋番号
ウォーターデブンに住む建築家のデブンキーさんのもとに、古い大病院を改装する仕事の依頼が舞い込んできました。
国によっては忌み数(いみかず)として嫌われる数字を部屋番号に用いたくない人がいます(日本では 4 と 9 が有名です)。しかし、この病院の部屋番号は忌み数に関係なく、1 から順番に付けられていました。
それが気になったデブンキーさんは、機材やベッドの入れ替えが全て終わる前にウォーターデブンの忌み数である「4」と「6」を除いた数字で部屋番号を付けなおしてしまいました。しかし、入れ替え作業は旧部屋番号で計画していたので、残りの作業を確実に行うには旧部屋番号を新部屋番号に変換する必要があります。計算が苦手なデブンキーさんはこのことに気づいて愕然としています。
そんなデブンキーさんのために、旧部屋番号を入力とし対応する新部屋番号を出力するプログラムを作成してください。
15 番目までの部屋番号の対応表は以下のようになります。
旧部屋番号
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
新部屋番号
1
2
3
5
7
8
9
10
11
12
13
15
17
18
19
Input
複数のデータセットの並びが入力として与えられます。入力の終わりはゼロひとつの行で示されます。
各データセットとして、旧部屋番号を表す整数
n
(1 ≤
n
≤ 1,000,000,000) が１行に与えられます。
データセットの数は 30000 を超えません。
Output
入力データセットごとに、新部屋番号を１行に出力します。
Sample Input
15
100
1000000000
3
0
Output for the Sample Input
19
155
9358757000
3",Java,"import java.util.Scanner;
import java.util.regex.Pattern;

class Main{
	public static void main(String[] args){
		Scanner stdIn = new Scanner(System.in);
		Pattern pattern = Pattern.compile(""^4|^6"");
		Pattern pattern2 = Pattern.compile("".*4.*|.*6.*"");

		while(true){
			long oldNumber = stdIn.nextLong();
			long newNumber = 0;

			if(oldNumber == 0){break;}

			int count = 0;
			while(count < oldNumber){
				newNumber++;
				String stringNewNumber = Long.toString(newNumber);
				if(pattern.matcher(stringNewNumber).find()){
					newNumber += Math.pow(10, stringNewNumber.length()-1);
				}else if(pattern2.matcher(stringNewNumber).find()){
					while(pattern2.matcher(Long.toString(newNumber)).find()){
						newNumber++;
					}
				}
				count++;
			}
			System.out.println(newNumber);
		}
	}
}",1
p00208,"病院の部屋番号
ウォーターデブンに住む建築家のデブンキーさんのもとに、古い大病院を改装する仕事の依頼が舞い込んできました。
国によっては忌み数(いみかず)として嫌われる数字を部屋番号に用いたくない人がいます(日本では 4 と 9 が有名です)。しかし、この病院の部屋番号は忌み数に関係なく、1 から順番に付けられていました。
それが気になったデブンキーさんは、機材やベッドの入れ替えが全て終わる前にウォーターデブンの忌み数である「4」と「6」を除いた数字で部屋番号を付けなおしてしまいました。しかし、入れ替え作業は旧部屋番号で計画していたので、残りの作業を確実に行うには旧部屋番号を新部屋番号に変換する必要があります。計算が苦手なデブンキーさんはこのことに気づいて愕然としています。
そんなデブンキーさんのために、旧部屋番号を入力とし対応する新部屋番号を出力するプログラムを作成してください。
15 番目までの部屋番号の対応表は以下のようになります。
旧部屋番号
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
新部屋番号
1
2
3
5
7
8
9
10
11
12
13
15
17
18
19
Input
複数のデータセットの並びが入力として与えられます。入力の終わりはゼロひとつの行で示されます。
各データセットとして、旧部屋番号を表す整数
n
(1 ≤
n
≤ 1,000,000,000) が１行に与えられます。
データセットの数は 30000 を超えません。
Output
入力データセットごとに、新部屋番号を１行に出力します。
Sample Input
15
100
1000000000
3
0
Output for the Sample Input
19
155
9358757000
3",Python,"def convert_to_new_room(n):
    # Convert n to base-8 representation, treating digits 0-7 as valid
    # Then map: 0->1, 1->2, 2->3, 3->5, 4->7, 5->8, 6->9, 7->10
    # This is essentially converting to a number system without 4 and 6
    
    # First, convert n to base 8
    if n == 0:
        return 0
    
    result = 0
    multiplier = 1
    temp_n = n
    
    while temp_n > 0:
        digit = temp_n % 8
        temp_n //= 8
        
        # Map the digit (0-7 in base 8 concept) to actual digit without 4 and 6
        # digit 0 -> 1, 1 -> 2, 2 -> 3, 3 -> 5, 4 -> 7, 5 -> 8, 6 -> 9, 7 -> 10
        if digit == 0:
            mapped = 1
        elif digit == 1:
            mapped = 2
        elif digit == 2:
            mapped = 3
        elif digit == 3:
            mapped = 5
        elif digit == 4:
            mapped = 7
        elif digit == 5:
            mapped = 8
        elif digit == 6:
            mapped = 9
        else:  # digit == 7
            mapped = 10
        
        result += mapped * multiplier
        multiplier *= 10
    
    return result

while True:
    n = int(input())
    if n == 0:
        break
    print(convert_to_new_room(n))
",0
p00208,"病院の部屋番号
ウォーターデブンに住む建築家のデブンキーさんのもとに、古い大病院を改装する仕事の依頼が舞い込んできました。
国によっては忌み数(いみかず)として嫌われる数字を部屋番号に用いたくない人がいます(日本では 4 と 9 が有名です)。しかし、この病院の部屋番号は忌み数に関係なく、1 から順番に付けられていました。
それが気になったデブンキーさんは、機材やベッドの入れ替えが全て終わる前にウォーターデブンの忌み数である「4」と「6」を除いた数字で部屋番号を付けなおしてしまいました。しかし、入れ替え作業は旧部屋番号で計画していたので、残りの作業を確実に行うには旧部屋番号を新部屋番号に変換する必要があります。計算が苦手なデブンキーさんはこのことに気づいて愕然としています。
そんなデブンキーさんのために、旧部屋番号を入力とし対応する新部屋番号を出力するプログラムを作成してください。
15 番目までの部屋番号の対応表は以下のようになります。
旧部屋番号
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
新部屋番号
1
2
3
5
7
8
9
10
11
12
13
15
17
18
19
Input
複数のデータセットの並びが入力として与えられます。入力の終わりはゼロひとつの行で示されます。
各データセットとして、旧部屋番号を表す整数
n
(1 ≤
n
≤ 1,000,000,000) が１行に与えられます。
データセットの数は 30000 を超えません。
Output
入力データセットごとに、新部屋番号を１行に出力します。
Sample Input
15
100
1000000000
3
0
Output for the Sample Input
19
155
9358757000
3",Python,"def testcase_ends():
    n = int(input())
    if n == 0:
        return 1

    n = oct(n)[2:]
    n = n.replace('7', '9')
    n = n.replace('6', '8')
    n = n.replace('5', '7')
    n = n.replace('4', '5')
    print(n)
    return 0

def main():
    while not testcase_ends():
        pass

if __name__ == '__main__':
    main()

",1
p00210,"ザ・スクエアーズ
この度、有名なテーマパークに、巨大迷路ザ・スクエアーズが新しく完成しました。 消防署の指導により避難訓練をしなければなりませんが、巨大迷路なだけに訓練にかかる時間を予測することができません。そこで、あなたは以下の仕様をもとに避難訓練シミュレータを開発することになりました。
巨大迷路は図 1 に示すように、横
W
、縦
H
の
W × H
個のマス目で表わされます。各マス目は、通路(白いマス目)、壁(茶色いマス目)  、非常口(緑のマス目)のいずれかです。図中の○は人を表し、その中の英小文字(E、W、S、N)はその人が向いている方角(東西南北)を表しています。図は上方向が北になるように描かれています。
図1
巨大迷路内にいる人は最初、東西南北のいずれかの方向を向いて立っています。各人は 1 秒単位で同時に次に示す手順で移動を試みます。
現在向いている方向の、右、前、左、後のマス目を順番に調べ、最初に見つけた、空いている通路または非常口の方向に向きを変えます。そのようなマス目が無い場合は向きを変えません。
目の前のマス目が空いていて、他の人の目の前のマス目になっていない場合は移動します。同じマス目を目の前のマスとする人が複数いる場合は、そのマス目の、東、北、西、南のマス目にいる人の順で選択された 1 人が移動します。
移動後に非常口に到着した人は、無事避難し迷路内から消えます。
与えられた巨大迷路と人の位置情報を入力とし、全ての人が避難し終える時間を出力するプログラムを作成してください。   脱出に 180 秒より長い時間を要する場合は NA と出力して下さい。  迷路と人の位置情報は、
H
行
W
列の文字によって与えられます。各文字の意味は以下のとおりです。
#
: 壁
.
: 床
X
: 非常口
E
: 東を向いている人
N
: 北を向いている人
W
: 西を向いている人
S
: 南を向いている人
なお、迷路と外部との境界は壁
#
または非常口
X
のいずれかです。また、巨大迷路の中には、人が必ず１人以上います。
Input
複数のデータセットの並びが入力として与えられます。      入力の終わりはゼロふたつの行で示されます。
各データセットは以下の形式で与えられます。
W
H
str
1
str
2
:
str
H
1 行目に迷路の横方向の大きさ
W
、縦方向の大きさ
H
(1 ≤
W, H
≤ 30) が与えられます。続く
H
行に迷路の
i
行目を表す文字列
str
i
(長さ
W
) が与えられます。
データセットの数は 50 を超えません。
Output
入力データセットごとに、全ての人が避難し終える時間を１行に出力します。
Sample Input
10 3
##########
#E.......X
##########
4 4
####
#N.#
#..X
####
5 5
#####
#N..#
###.X
#S..#
#####
6 6
######
#..#X#
#.EE.#
####N#
#....#
######
8 8
##X#####
#....E.#
#####.##
#.#...##
#.W.#..#
#.#.N#.X
#X##.#.#
########
0 0
Output for the Sample Input
8
NA
9
16
10",C,"#include <stdio.h>
#include <string.h>

#define MAX 30

typedef struct {
    int x, y;
    char dir;
} Person;

char grid[MAX][MAX];
int W, H;
Person people[MAX*MAX];
int num_people;

int dx[] = {1, 0, -1, 0}; // E, N, W, S
int dy[] = {0, -1, 0, 1};
char dirs[] = ""ENWS"";

int get_dir_idx(char d) {
    for(int i = 0; i < 4; i++) {
        if(dirs[i] == d) return i;
    }
    return 0;
}

int is_passable(int x, int y) {
    if(x < 0 || x >= W || y < 0 || y >= H) return 0;
    return grid[y][x] == '.' || grid[y][x] == 'X';
}

void simulate() {
    int time = 0;
    
    while(num_people > 0 && time <= 180) {
        time++;
        
        // Step 1: Change direction
        for(int i = 0; i < num_people; i++) {
            int dir_idx = get_dir_idx(people[i].dir);
            int found = 0;
            
            // Check right, front, left, back
            int order[] = {(dir_idx + 3) % 4, dir_idx, (dir_idx + 1) % 4, (dir_idx + 2) % 4};
            
            for(int j = 0; j < 4; j++) {
                int d = order[j];
                int nx = people[i].x + dx[d];
                int ny = people[i].y + dy[d];
                
                if(is_passable(nx, ny)) {
                    people[i].dir = dirs[d];
                    found = 1;
                    break;
                }
            }
        }
        
        // Step 2: Move
        int target_count[MAX][MAX];
        int target_who[MAX][MAX][4];
        memset(target_count, 0, sizeof(target_count));
        
        for(int i = 0; i < num_people; i++) {
            int dir_idx = get_dir_idx(people[i].dir);
            int nx = people[i].x + dx[dir_idx];
            int ny = people[i].y + dy[dir_idx];
            
            if(is_passable(nx, ny)) {
                target_who[ny][nx][target_count[ny][nx]++] = i;
            }
        }
        
        int moved[MAX*MAX];
        memset(moved, 0, sizeof(moved));
        
        for(int y = 0; y < H; y++) {
            for(int x = 0; x < W; x++) {
                if(target_count[y][x] > 1) {
                    // Multiple people want this spot
                    // Priority: E, N, W, S of the target
                    int priority_order[] = {0, 1, 2, 3}; // E, N, W, S
                    int selected = -1;
                    
                    for(int p = 0; p < 4; p++) {
                        int check_x = x - dx[priority_order[p]];
                        int check_y = y - dy[priority_order[p]];
                        
                        for(int k = 0; k < target_count[y][x]; k++) {
                            int who = target_who[y][x][k];
                            if(people[who].x == check_x && people[who].y == check_y) {
                                selected = who;
                                break;
                            }
                        }
                        if(selected != -1) break;
                    }
                    
                    if(selected != -1) {
                        moved[selected] = 1;
                    }
                } else if(target_count[y][x] == 1) {
                    moved[target_who[y][x][0]] = 1;
                }
            }
        }
        
        // Apply moves
        for(int i = 0; i < num_people; i++) {
            if(moved[i]) {
                int dir_idx = get_dir_idx(people[i].dir);
                people[i].x += dx[dir_idx];
                people[i].y += dy[dir_idx];
            }
        }
        
        // Remove people at exits
        int new_num = 0;
        for(int i = 0; i < num_people; i++) {
            if(grid[people[i].y][people[i].x] != 'X') {
                people[new_num++] = people[i];
            }
        }
        num_people = new_num;
    }
    
    if(num_people == 0) {
        printf(""%d\n"", time);
    } else {
        printf(""NA\n"");
    }
}

int main() {
    while(1) {
        scanf(""%d %d"", &W, &H);
        if(W == 0 && H == 0) break;
        
        num_people = 0;
        for(int i = 0; i < H; i++) {
            scanf(""%s"", grid[i]);
            for(int j = 0; j < W; j++) {
                if(grid[i][j] == 'E' || grid[i][j] == 'N' || 
                   grid[i][j] == 'W' || grid[i][j] == 'S') {
                    people[num_people].x = j;
                    people[num_people].y = i;
                    people[num_people].dir = grid[i][j];
                    num_people++;
                    grid[i][j] = '.';
                }
            }
        }
        
        simulate();
    }
    
    return 0;
}
",0
p00210,"ザ・スクエアーズ
この度、有名なテーマパークに、巨大迷路ザ・スクエアーズが新しく完成しました。 消防署の指導により避難訓練をしなければなりませんが、巨大迷路なだけに訓練にかかる時間を予測することができません。そこで、あなたは以下の仕様をもとに避難訓練シミュレータを開発することになりました。
巨大迷路は図 1 に示すように、横
W
、縦
H
の
W × H
個のマス目で表わされます。各マス目は、通路(白いマス目)、壁(茶色いマス目)  、非常口(緑のマス目)のいずれかです。図中の○は人を表し、その中の英小文字(E、W、S、N)はその人が向いている方角(東西南北)を表しています。図は上方向が北になるように描かれています。
図1
巨大迷路内にいる人は最初、東西南北のいずれかの方向を向いて立っています。各人は 1 秒単位で同時に次に示す手順で移動を試みます。
現在向いている方向の、右、前、左、後のマス目を順番に調べ、最初に見つけた、空いている通路または非常口の方向に向きを変えます。そのようなマス目が無い場合は向きを変えません。
目の前のマス目が空いていて、他の人の目の前のマス目になっていない場合は移動します。同じマス目を目の前のマスとする人が複数いる場合は、そのマス目の、東、北、西、南のマス目にいる人の順で選択された 1 人が移動します。
移動後に非常口に到着した人は、無事避難し迷路内から消えます。
与えられた巨大迷路と人の位置情報を入力とし、全ての人が避難し終える時間を出力するプログラムを作成してください。   脱出に 180 秒より長い時間を要する場合は NA と出力して下さい。  迷路と人の位置情報は、
H
行
W
列の文字によって与えられます。各文字の意味は以下のとおりです。
#
: 壁
.
: 床
X
: 非常口
E
: 東を向いている人
N
: 北を向いている人
W
: 西を向いている人
S
: 南を向いている人
なお、迷路と外部との境界は壁
#
または非常口
X
のいずれかです。また、巨大迷路の中には、人が必ず１人以上います。
Input
複数のデータセットの並びが入力として与えられます。      入力の終わりはゼロふたつの行で示されます。
各データセットは以下の形式で与えられます。
W
H
str
1
str
2
:
str
H
1 行目に迷路の横方向の大きさ
W
、縦方向の大きさ
H
(1 ≤
W, H
≤ 30) が与えられます。続く
H
行に迷路の
i
行目を表す文字列
str
i
(長さ
W
) が与えられます。
データセットの数は 50 を超えません。
Output
入力データセットごとに、全ての人が避難し終える時間を１行に出力します。
Sample Input
10 3
##########
#E.......X
##########
4 4
####
#N.#
#..X
####
5 5
#####
#N..#
###.X
#S..#
#####
6 6
######
#..#X#
#.EE.#
####N#
#....#
######
8 8
##X#####
#....E.#
#####.##
#.#...##
#.W.#..#
#.#.N#.X
#X##.#.#
########
0 0
Output for the Sample Input
8
NA
9
16
10",C,"#include<stdio.h>


typedef struct{
  int x;
  int y;
  int ny;
  int nx;
  char dir;
  int movable;
}man;
typedef struct{
  int x;
  int y;
}d;

char map[30][31];
int w,h;
man ms[900];
int msize;
d dir[4]={{1,0},{0,-1},{-1,0},{0,1}};
//memo 0:east 1:north 2:west 3:south
char n2d(int d){
  return d==0?'E':d==1?'N':d==2?'W':'S';
}
int d2n(char d){
  return d=='E'?0:d=='N'?1:d=='W'?2:d=='S'?3:-1;
}
int main(){
  int i,j,l,k,nx,ny;
  do{
    scanf(""%d %d"",&w,&h);
    if(w==0&&h==0) break;
    msize=0;
    for(i=0;i<h;i++){      
      scanf(""%s"",map+i);
      for(j=0;j<w;j++){
	if(map[i][j]!='#'&&map[i][j]!='.'&&map[i][j]!='X'){
	  ms[msize].x=j;
	  ms[msize].y=i;
	  ms[msize].dir=d2n(map[i][j]);
	  msize++;
	}
      }
    }
    for(i=1;i<181;i++){
      /*            for(j=0;j<h;j++)
	printf(""%s\n"",map+j);
	printf(""\n"");*/
      for(j=0;j<msize;j++){
	ms[j].movable=0;
	for(k=-1;k<3;k++){
	  ms[j].nx=ms[j].x+dir[(4+ms[j].dir+k)%4].x;
	  ms[j].ny=ms[j].y+dir[(4+ms[j].dir+k)%4].y;
	  if(map[ms[j].ny][ms[j].nx]=='X'){
	    ms[j].movable=1;
	    break;	    
	  }else if(map[ms[j].ny][ms[j].nx]=='.'){
	    ms[j].dir=(4+ms[j].dir+k)%4;
	    ms[j].movable=1;
	    break;
	  }	  
	}
      }
      for(j=0;j<msize;j++){
	if(map[ms[j].ny][ms[j].nx]!='X'&&ms[j].movable)
	  for(k=0;k<4;k++){
	    nx=ms[j].nx+dir[k].x;
	    ny=ms[j].ny+dir[k].y;
	    //	    printf(""(%d %d %c) "",ny,nx,map[ny][nx]);
	    if(isalpha(map[ny][nx])
	       &&map[ny][nx]!='X'
	       &&((d2n(map[ny][nx])+2)%4)==k){
//	      printf(""%d %d %c\n"",ny,nx,map[ny][nx]);
	      if(ms[j].x!=nx||ms[j].y!=ny){
		ms[j].movable=0;		
	      }
	      break;
	    }else if(ms[j].x==nx&&ms[j].y==ny){
	      map[ms[j].y][ms[j].x]=n2d(ms[j].dir);
	      break;
	    }
	  }
	//	printf(""\n"");
      }
      for(j=0;j<msize;j++){
	if(map[ms[j].ny][ms[j].nx]=='X'){
	  map[ms[j].y][ms[j].x]='.';
	  for(l=j;l<msize;l++){
	    ms[l]=ms[l+1];
	  }	    
	  j--;
	  msize--;
	}else if(ms[j].movable){
	  map[ms[j].y][ms[j].x]='.';
	  map[ms[j].ny][ms[j].nx]=n2d(ms[j].dir);
	  ms[j].x=ms[j].nx;
	  ms[j].y=ms[j].ny;
	}
      }
      if(msize==0){
	printf(""%d\n"",i);
	break;
      }
    }
    if(i==181)
      printf(""NA\n"");
  }while(1);
  return 0;
}",1
p00210,"ザ・スクエアーズ
この度、有名なテーマパークに、巨大迷路ザ・スクエアーズが新しく完成しました。 消防署の指導により避難訓練をしなければなりませんが、巨大迷路なだけに訓練にかかる時間を予測することができません。そこで、あなたは以下の仕様をもとに避難訓練シミュレータを開発することになりました。
巨大迷路は図 1 に示すように、横
W
、縦
H
の
W × H
個のマス目で表わされます。各マス目は、通路(白いマス目)、壁(茶色いマス目)  、非常口(緑のマス目)のいずれかです。図中の○は人を表し、その中の英小文字(E、W、S、N)はその人が向いている方角(東西南北)を表しています。図は上方向が北になるように描かれています。
図1
巨大迷路内にいる人は最初、東西南北のいずれかの方向を向いて立っています。各人は 1 秒単位で同時に次に示す手順で移動を試みます。
現在向いている方向の、右、前、左、後のマス目を順番に調べ、最初に見つけた、空いている通路または非常口の方向に向きを変えます。そのようなマス目が無い場合は向きを変えません。
目の前のマス目が空いていて、他の人の目の前のマス目になっていない場合は移動します。同じマス目を目の前のマスとする人が複数いる場合は、そのマス目の、東、北、西、南のマス目にいる人の順で選択された 1 人が移動します。
移動後に非常口に到着した人は、無事避難し迷路内から消えます。
与えられた巨大迷路と人の位置情報を入力とし、全ての人が避難し終える時間を出力するプログラムを作成してください。   脱出に 180 秒より長い時間を要する場合は NA と出力して下さい。  迷路と人の位置情報は、
H
行
W
列の文字によって与えられます。各文字の意味は以下のとおりです。
#
: 壁
.
: 床
X
: 非常口
E
: 東を向いている人
N
: 北を向いている人
W
: 西を向いている人
S
: 南を向いている人
なお、迷路と外部との境界は壁
#
または非常口
X
のいずれかです。また、巨大迷路の中には、人が必ず１人以上います。
Input
複数のデータセットの並びが入力として与えられます。      入力の終わりはゼロふたつの行で示されます。
各データセットは以下の形式で与えられます。
W
H
str
1
str
2
:
str
H
1 行目に迷路の横方向の大きさ
W
、縦方向の大きさ
H
(1 ≤
W, H
≤ 30) が与えられます。続く
H
行に迷路の
i
行目を表す文字列
str
i
(長さ
W
) が与えられます。
データセットの数は 50 を超えません。
Output
入力データセットごとに、全ての人が避難し終える時間を１行に出力します。
Sample Input
10 3
##########
#E.......X
##########
4 4
####
#N.#
#..X
####
5 5
#####
#N..#
###.X
#S..#
#####
6 6
######
#..#X#
#.EE.#
####N#
#....#
######
8 8
##X#####
#....E.#
#####.##
#.#...##
#.W.#..#
#.#.N#.X
#X##.#.#
########
0 0
Output for the Sample Input
8
NA
9
16
10",Java,"import java.util.*;
import java.io.*;

public class Main {
    static class Person {
        int x, y;
        char dir;
        
        Person(int x, int y, char dir) {
            this.x = x;
            this.y = y;
            this.dir = dir;
        }
    }
    
    static int[] dx = {1, 0, -1, 0}; // E, N, W, S
    static int[] dy = {0, -1, 0, 1};
    static Map<Character, Integer> dirMap = new HashMap<>();
    
    static {
        dirMap.put('E', 0);
        dirMap.put('N', 1);
        dirMap.put('W', 2);
        dirMap.put('S', 3);
    }
    
    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        String line;
        
        while ((line = br.readLine()) != null) {
            String[] parts = line.trim().split("" "");
            int W = Integer.parseInt(parts[0]);
            int H = Integer.parseInt(parts[1]);
            
            if (W == 0 && H == 0) break;
            
            char[][] grid = new char[H][W];
            List<Person> people = new ArrayList<>();
            
            for (int i = 0; i < H; i++) {
                String str = br.readLine();
                for (int j = 0; j < W; j++) {
                    grid[i][j] = str.charAt(j);
                    if (dirMap.containsKey(grid[i][j])) {
                        people.add(new Person(j, i, grid[i][j]));
                        grid[i][j] = '.';
                    }
                }
            }
            
            int result = simulate(grid, people, W, H);
            if (result > 180) {
                System.out.println(""NA"");
            } else {
                System.out.println(result);
            }
        }
    }
    
    static int simulate(char[][] grid, List<Person> people, int W, int H) {
        int time = 0;
        
        while (!people.isEmpty() && time <= 180) {
            time++;
            
            // Step 1: Update directions
            for (Person p : people) {
                int currentDir = dirMap.get(p.dir);
                int[] checkOrder = {(currentDir + 3) % 4, currentDir, (currentDir + 1) % 4, (currentDir + 2) % 4};
                
                for (int d : checkOrder) {
                    int nx = p.x + dx[d];
                    int ny = p.y + dy[d];
                    
                    if (nx >= 0 && nx < W && ny >= 0 && ny < H && 
                        (grid[ny][nx] == '.' || grid[ny][nx] == 'X')) {
                        p.dir = getDir(d);
                        break;
                    }
                }
            }
            
            // Step 2: Determine moves
            Map<String, List<Person>> targetMap = new HashMap<>();
            
            for (Person p : people) {
                int d = dirMap.get(p.dir);
                int nx = p.x + dx[d];
                int ny = p.y + dy[d];
                
                if (nx >= 0 && nx < W && ny >= 0 && ny < H && 
                    (grid[ny][nx] == '.' || grid[ny][nx] == 'X')) {
                    String key = nx + "","" + ny;
                    targetMap.putIfAbsent(key, new ArrayList<>());
                    targetMap.get(key).add(p);
                }
            }
            
            // Step 3: Move people
            Set<Person> toRemove = new HashSet<>();
            
            for (String key : targetMap.keySet()) {
                List<Person> candidates = targetMap.get(key);
                
                if (candidates.size() == 1) {
                    Person p = candidates.get(0);
                    String[] coords = key.split("","");
                    p.x = Integer.parseInt(coords[0]);
                    p.y = Integer.parseInt(coords[1]);
                    
                    if (grid[p.y][p.x] == 'X') {
                        toRemove.add(p);
                    }
                } else {
                    // Priority: E, N, W, S (by position of source)
                    Person selected = null;
                    int[] priority = {0, 1, 2, 3}; // E, N, W, S
                    
                    for (int pri : priority) {
                        for (Person p : candidates) {
                            int d = dirMap.get(p.dir);
                            if (d == pri) {
                                selected = p;
                                break;
                            }
                        }
                        if (selected != null) break;
                    }
                    
                    if (selected != null) {
                        String[] coords = key.split("","");
                        selected.x = Integer.parseInt(coords[0]);
                        selected.y = Integer.parseInt(coords[1]);
                        
                        if (grid[selected.y][selected.x] == 'X') {
                            toRemove.add(selected);
                        }
                    }
                }
            }
            
            people.removeAll(toRemove);
        }
        
        return time;
    }
    
    static char getDir(int d) {
        switch (d) {
            case 0: return 'E';
            case 1: return 'N';
            case 2: return 'W';
            case 3: return 'S';
        }
        return 'E';
    }
}
",0
p00210,"ザ・スクエアーズ
この度、有名なテーマパークに、巨大迷路ザ・スクエアーズが新しく完成しました。 消防署の指導により避難訓練をしなければなりませんが、巨大迷路なだけに訓練にかかる時間を予測することができません。そこで、あなたは以下の仕様をもとに避難訓練シミュレータを開発することになりました。
巨大迷路は図 1 に示すように、横
W
、縦
H
の
W × H
個のマス目で表わされます。各マス目は、通路(白いマス目)、壁(茶色いマス目)  、非常口(緑のマス目)のいずれかです。図中の○は人を表し、その中の英小文字(E、W、S、N)はその人が向いている方角(東西南北)を表しています。図は上方向が北になるように描かれています。
図1
巨大迷路内にいる人は最初、東西南北のいずれかの方向を向いて立っています。各人は 1 秒単位で同時に次に示す手順で移動を試みます。
現在向いている方向の、右、前、左、後のマス目を順番に調べ、最初に見つけた、空いている通路または非常口の方向に向きを変えます。そのようなマス目が無い場合は向きを変えません。
目の前のマス目が空いていて、他の人の目の前のマス目になっていない場合は移動します。同じマス目を目の前のマスとする人が複数いる場合は、そのマス目の、東、北、西、南のマス目にいる人の順で選択された 1 人が移動します。
移動後に非常口に到着した人は、無事避難し迷路内から消えます。
与えられた巨大迷路と人の位置情報を入力とし、全ての人が避難し終える時間を出力するプログラムを作成してください。   脱出に 180 秒より長い時間を要する場合は NA と出力して下さい。  迷路と人の位置情報は、
H
行
W
列の文字によって与えられます。各文字の意味は以下のとおりです。
#
: 壁
.
: 床
X
: 非常口
E
: 東を向いている人
N
: 北を向いている人
W
: 西を向いている人
S
: 南を向いている人
なお、迷路と外部との境界は壁
#
または非常口
X
のいずれかです。また、巨大迷路の中には、人が必ず１人以上います。
Input
複数のデータセットの並びが入力として与えられます。      入力の終わりはゼロふたつの行で示されます。
各データセットは以下の形式で与えられます。
W
H
str
1
str
2
:
str
H
1 行目に迷路の横方向の大きさ
W
、縦方向の大きさ
H
(1 ≤
W, H
≤ 30) が与えられます。続く
H
行に迷路の
i
行目を表す文字列
str
i
(長さ
W
) が与えられます。
データセットの数は 50 を超えません。
Output
入力データセットごとに、全ての人が避難し終える時間を１行に出力します。
Sample Input
10 3
##########
#E.......X
##########
4 4
####
#N.#
#..X
####
5 5
#####
#N..#
###.X
#S..#
#####
6 6
######
#..#X#
#.EE.#
####N#
#....#
######
8 8
##X#####
#....E.#
#####.##
#.#...##
#.W.#..#
#.#.N#.X
#X##.#.#
########
0 0
Output for the Sample Input
8
NA
9
16
10",Java,"import java.util.*;
public class Main {
	int [] vx = {1,0,-1,0};
	int [] vy = {0,-1,0,1};
	boolean [] isgoal;
	
	class C{
		int x,y,dir;
		public C(int x, int y, int dir) {
			this.x = x;this.y = y;
			if(dir == 'E')
				dir = 0;
			else if(dir == 'N')
				dir = 1;
			else if(dir == 'S')
				dir = 3;
			else if(dir == 'W')
				dir = 2;
			else{
				
			}
			this.dir = dir;
		}
		public String toString() {
			return ""C [x="" + x + "", y="" + y + "", dir="" + dir + ""]"";
		}
		
	}

	private void doit(){
		Scanner sc=new Scanner(System.in);
		while(true){
			int w = sc.nextInt(), h = sc.nextInt();
			if((w|h) == 0) break;
			char [][] map = new char[h][w];
			ArrayList<C> humlist = new ArrayList<C>();
			for(int i=0; i < h;i++){
				String line = sc.next();
				for(int j=0; j < w;j++){
					char c = line.charAt(j);
					if(c == 'E' || c == 'N' || c == 'W' || c == 'S'){
						humlist.add(new C(j,i,(int)c));
						map[i][j] = '.';
					}
					else{
						map[i][j] = c;
					}
				}
			}
//			//debug
//			for(int i=0; i < h; i++){
//				for(int j = 0; j < w; j++){
//					System.out.print(map[i][j]);
//				}
//				System.out.println();
//			}
//			System.out.println();
//			System.out.println(""list= "" + humlist.toString());
			int step = 0;
			LinkedList<Integer> open = new LinkedList<Integer>();
			open.add(step);
			int len = humlist.size();
			isgoal = new boolean[len];
			boolean isachieve = true;
			while(! open.isEmpty()){
				step = open.removeFirst();
				//debug
				//System.out.println(humlist.toString());
				//change dir
				for(int i = 0; i < len;i++){
					if(isgoal[i])continue;
					C nowhum = humlist.get(i);
					int nowdir = nowhum.dir;
					for(int j = 0; j < 4; j++){
						nowdir = (j + 4 + nowhum.dir - 1) % 4;
						int xx = nowhum.x + vx[nowdir];
						int yy = nowhum.y + vy[nowdir];
						if(map[yy][xx] == '#') continue;
						if((map[yy][xx] == 'X' || map[yy][xx] == '.') && ! isin(xx,yy,humlist)){
							break;
						}
					}
					nowhum.dir = nowdir;
					humlist.set(i, nowhum);
				}
				
				//move
				ArrayList<C> humlistrecord = valueC(humlist);
				for(int i=0; i < len; i++){
					if(isgoal[i]) continue;
					C nowhum = humlist.get(i);
					int xx = nowhum.x + vx[nowhum.dir];
					int yy = nowhum.y + vy[nowhum.dir];
					if(map[yy][xx] == '#' || isin(xx,yy,humlist)) continue;
					int movehum = getmove(xx,yy,humlistrecord);
					if(movehum == i){
						nowhum.x = xx;
						nowhum.y = yy;
						humlist.set(i, nowhum);
					}
				}
				
				//escape
				for(int i = 0; i < len;i++){
					C nowhum = humlist.get(i);
					int humx = nowhum.x,humy = nowhum.y;
					if(map[humy][humx] == 'X'){
						isgoal[i] = true;
					}
				}
				
				//fin
				if(isAllGoal()){
					break;
				}
				if(step + 1 > 180){
					isachieve = false;
					break;
				}
				open.add(step + 1);
			}
			if(isachieve){
				if(humlist.size() == 0){
					System.out.println(0);
				}
				else{
					System.out.println(step + 1);
				}
				
			}
			else{
				System.out.println(""NA"");
			}
		}
	}
	
	private boolean isAllGoal(){
		for(int i=0; i < isgoal.length;i++){
			if(! isgoal[i]) return false;
		}
		return true;
	}
	
	private int getmove(int x, int y, ArrayList<C> list){
		for(int i=0; i < 4;i++){
			int xx = x + vx[i];
			int yy = y + vy[i];
			for(int j=0; j < list.size(); j++){
				if(isgoal[j])continue;
				C now = list.get(j);
				boolean cond1 = (xx == now.x && yy == now.y);
				boolean cond2 = ((now.x + vx[now.dir]) == x && (now.y + vy[now.dir]) == y);
				if(cond1 && cond2){
					return j;
				}
			}
		}
		return -1;
	}
	private ArrayList<C> valueC(ArrayList<C> list){
		ArrayList<C> res =  new ArrayList<C>();
		for(int i = 0; i < list.size(); i++){
			C now = list.get(i);
			res.add(new C(now.x, now.y, now.dir));
		}
		return res;
	}
	
	private boolean isin(int x, int y,ArrayList<C> list){
		for(int i=0; i < list.size();i++){
			if(isgoal[i])continue;
			C now = list.get(i);
			if(now.x == x && now.y == y){
				return true;
			}
		}
		return false;
	}


	public static void main(String[] args) {
		Main obj = new Main();
		obj.doit();
	}
}",1
p00210,"ザ・スクエアーズ
この度、有名なテーマパークに、巨大迷路ザ・スクエアーズが新しく完成しました。 消防署の指導により避難訓練をしなければなりませんが、巨大迷路なだけに訓練にかかる時間を予測することができません。そこで、あなたは以下の仕様をもとに避難訓練シミュレータを開発することになりました。
巨大迷路は図 1 に示すように、横
W
、縦
H
の
W × H
個のマス目で表わされます。各マス目は、通路(白いマス目)、壁(茶色いマス目)  、非常口(緑のマス目)のいずれかです。図中の○は人を表し、その中の英小文字(E、W、S、N)はその人が向いている方角(東西南北)を表しています。図は上方向が北になるように描かれています。
図1
巨大迷路内にいる人は最初、東西南北のいずれかの方向を向いて立っています。各人は 1 秒単位で同時に次に示す手順で移動を試みます。
現在向いている方向の、右、前、左、後のマス目を順番に調べ、最初に見つけた、空いている通路または非常口の方向に向きを変えます。そのようなマス目が無い場合は向きを変えません。
目の前のマス目が空いていて、他の人の目の前のマス目になっていない場合は移動します。同じマス目を目の前のマスとする人が複数いる場合は、そのマス目の、東、北、西、南のマス目にいる人の順で選択された 1 人が移動します。
移動後に非常口に到着した人は、無事避難し迷路内から消えます。
与えられた巨大迷路と人の位置情報を入力とし、全ての人が避難し終える時間を出力するプログラムを作成してください。   脱出に 180 秒より長い時間を要する場合は NA と出力して下さい。  迷路と人の位置情報は、
H
行
W
列の文字によって与えられます。各文字の意味は以下のとおりです。
#
: 壁
.
: 床
X
: 非常口
E
: 東を向いている人
N
: 北を向いている人
W
: 西を向いている人
S
: 南を向いている人
なお、迷路と外部との境界は壁
#
または非常口
X
のいずれかです。また、巨大迷路の中には、人が必ず１人以上います。
Input
複数のデータセットの並びが入力として与えられます。      入力の終わりはゼロふたつの行で示されます。
各データセットは以下の形式で与えられます。
W
H
str
1
str
2
:
str
H
1 行目に迷路の横方向の大きさ
W
、縦方向の大きさ
H
(1 ≤
W, H
≤ 30) が与えられます。続く
H
行に迷路の
i
行目を表す文字列
str
i
(長さ
W
) が与えられます。
データセットの数は 50 を超えません。
Output
入力データセットごとに、全ての人が避難し終える時間を１行に出力します。
Sample Input
10 3
##########
#E.......X
##########
4 4
####
#N.#
#..X
####
5 5
#####
#N..#
###.X
#S..#
#####
6 6
######
#..#X#
#.EE.#
####N#
#....#
######
8 8
##X#####
#....E.#
#####.##
#.#...##
#.W.#..#
#.#.N#.X
#X##.#.#
########
0 0
Output for the Sample Input
8
NA
9
16
10",Python,"from collections import deque

def solve():
    while True:
        W, H = map(int, input().split())
        if W == 0 and H == 0:
            break
        
        grid = []
        people = []
        
        for i in range(H):
            row = input().strip()
            grid.append(list(row))
            for j in range(len(row)):
                if row[j] in 'ENSW':
                    people.append([i, j, row[j]])
                    grid[i][j] = '.'
        
        # Direction mappings
        dir_map = {
            'E': (0, 1),
            'W': (0, -1),
            'N': (-1, 0),
            'S': (1, 0)
        }
        
        dir_names = ['E', 'W', 'N', 'S']
        
        # Right, front, left, back relative to current direction
        turn_order = {
            'E': ['S', 'E', 'N', 'W'],
            'W': ['N', 'W', 'S', 'E'],
            'N': ['E', 'N', 'W', 'S'],
            'S': ['W', 'S', 'E', 'N']
        }
        
        time = 0
        
        while people and time <= 180:
            # Step 1: Update directions
            new_people = []
            for person in people:
                r, c, facing = person
                
                # Check right, front, left, back
                found_dir = None
                for check_dir in turn_order[facing]:
                    dr, dc = dir_map[check_dir]
                    nr, nc = r + dr, c + dc
                    
                    if 0 <= nr < H and 0 <= nc < W:
                        cell = grid[nr][nc]
                        if cell == '.' or cell == 'X':
                            # Check if occupied by another person
                            occupied = False
                            for other in people:
                                if other[0] == nr and other[1] == nc:
                                    occupied = True
                                    break
                            
                            if not occupied:
                                found_dir = check_dir
                                break
                
                if found_dir:
                    new_people.append([r, c, found_dir])
                else:
                    new_people.append([r, c, facing])
            
            people = new_people
            
            # Step 2: Move people
            # Calculate target positions for each person
            targets = {}
            for idx, person in enumerate(people):
                r, c, facing = person
                dr, dc = dir_map[facing]
                nr, nc = r + dr, c + dc
                
                if 0 <= nr < H and 0 <= nc < W:
                    cell = grid[nr][nc]
                    if cell == '.' or cell == 'X':
                        if (nr, nc) not in targets:
                            targets[(nr, nc)] = []
                        targets[(nr, nc)].append((idx, r, c))
            
            # Resolve conflicts
            moved = set()
            new_people = []
            
            for target, candidates in targets.items():
                if len(candidates) == 1:
                    idx, r, c = candidates[0]
                    moved.add(idx)
                else:
                    # Priority: E, N, W, S
                    priority_order = [(0, 1), (-1, 0), (0, -1), (1, 0)]
                    tr, tc = target
                    
                    selected = None
                    for dr, dc in priority_order:
                        sr, sc = tr - dr, tc - dc
                        for idx, r, c in candidates:
                            if r == sr and c == sc:
                                selected = idx
                                break
                        if selected is not None:
                            break
                    
                    if selected is not None:
                        moved.add(selected)
            
            # Update people positions
            final_people = []
            for idx, person in enumerate(people):
                r, c, facing = person
                if idx in moved:
                    dr, dc = dir_map[facing]
                    nr, nc = r + dr, c + dc
                    
                    # Check if it's an exit
                    if grid[nr][nc] == 'X':
                        # Person escapes
                        continue
                    else:
                        final_people.append([nr, nc, facing])
                else:
                    final_people.append([r, c, facing])
            
            people = final_people
            time += 1
        
        if people:
            print(""NA"")
        else:
            print(time)

solve()
",0
p00210,"ザ・スクエアーズ
この度、有名なテーマパークに、巨大迷路ザ・スクエアーズが新しく完成しました。 消防署の指導により避難訓練をしなければなりませんが、巨大迷路なだけに訓練にかかる時間を予測することができません。そこで、あなたは以下の仕様をもとに避難訓練シミュレータを開発することになりました。
巨大迷路は図 1 に示すように、横
W
、縦
H
の
W × H
個のマス目で表わされます。各マス目は、通路(白いマス目)、壁(茶色いマス目)  、非常口(緑のマス目)のいずれかです。図中の○は人を表し、その中の英小文字(E、W、S、N)はその人が向いている方角(東西南北)を表しています。図は上方向が北になるように描かれています。
図1
巨大迷路内にいる人は最初、東西南北のいずれかの方向を向いて立っています。各人は 1 秒単位で同時に次に示す手順で移動を試みます。
現在向いている方向の、右、前、左、後のマス目を順番に調べ、最初に見つけた、空いている通路または非常口の方向に向きを変えます。そのようなマス目が無い場合は向きを変えません。
目の前のマス目が空いていて、他の人の目の前のマス目になっていない場合は移動します。同じマス目を目の前のマスとする人が複数いる場合は、そのマス目の、東、北、西、南のマス目にいる人の順で選択された 1 人が移動します。
移動後に非常口に到着した人は、無事避難し迷路内から消えます。
与えられた巨大迷路と人の位置情報を入力とし、全ての人が避難し終える時間を出力するプログラムを作成してください。   脱出に 180 秒より長い時間を要する場合は NA と出力して下さい。  迷路と人の位置情報は、
H
行
W
列の文字によって与えられます。各文字の意味は以下のとおりです。
#
: 壁
.
: 床
X
: 非常口
E
: 東を向いている人
N
: 北を向いている人
W
: 西を向いている人
S
: 南を向いている人
なお、迷路と外部との境界は壁
#
または非常口
X
のいずれかです。また、巨大迷路の中には、人が必ず１人以上います。
Input
複数のデータセットの並びが入力として与えられます。      入力の終わりはゼロふたつの行で示されます。
各データセットは以下の形式で与えられます。
W
H
str
1
str
2
:
str
H
1 行目に迷路の横方向の大きさ
W
、縦方向の大きさ
H
(1 ≤
W, H
≤ 30) が与えられます。続く
H
行に迷路の
i
行目を表す文字列
str
i
(長さ
W
) が与えられます。
データセットの数は 50 を超えません。
Output
入力データセットごとに、全ての人が避難し終える時間を１行に出力します。
Sample Input
10 3
##########
#E.......X
##########
4 4
####
#N.#
#..X
####
5 5
#####
#N..#
###.X
#S..#
#####
6 6
######
#..#X#
#.EE.#
####N#
#....#
######
8 8
##X#####
#....E.#
#####.##
#.#...##
#.W.#..#
#.#.N#.X
#X##.#.#
########
0 0
Output for the Sample Input
8
NA
9
16
10",Python,"import sys

direction = {'N' : 0, 'E' : 1, 'S' : 2, 'W' : 3}
step = [( -1, 0 ), ( 0, 1 ), ( 1, 0 ), ( 0, -1 )]
vv = []

while True:
    W, H = map( int, sys.stdin.readline().rstrip().split() )
    if W == 0 and H == 0: break
    m = [ list( sys.stdin.readline().strip() ) for i in xrange( H ) ]
    people = [ ( i, j, direction[ m[i][j] ] ) for i in xrange( H ) for j in range( W )
               if m[i][j] in ""NESW"" ]
    time = 0
    while any( people ):
        time += 1
        if time > 180:
            time = -1
            break
        sched = []
        for n in xrange( len( people ) ):
            if people[n] is None: continue
            x, y, d = people[n]
            for i in range(1, -3, -1):
                    dx, dy = step[(d + i) % 4]
                    if 0 <= x+dx < H and 0 <= y+dy < W and m[x+dx][y+dy] in ""X."":
                        people[n][2] = (d + i) % 4
                        beat = True
                        for k in range( len( sched ) ):
                            xx, yy, dd = sched[k][1:]
                            if ( x+dx, y+dy ) == ( xx, yy ):
                                if dd < (d + i) % 4:
                                    sched[k] = ( n, x+dx, y+dy, (d + i) % 4 )
                                    beat = False
                                    break
                                else:
                                    beat = False
                                    break
                        if beat:
                            sched.append( ( n, x+dx, y+dy, (d + i) % 4 ) )
			break
        for ( k, x, y, d ) in sched:
            m[ people[k][0] ][ people[k][1] ] = '.'
            if m[x][y] == 'X':
                people[k] = None
            else:
                m[x][y] = 'H'
                people[k] = x, y, d
    if time >= 0:
        vv.append(time)
    else:
        vv.append('NA')

for v in vv:
    print v",1
p00211,"みんなでジョギング
赤ベコ小学校では、生徒全員が参加する、ちょっと変わったジョギングをします。生徒は、それぞれ独自の周回コースを、自分のペースで走ります。それぞれ自分のコースを 1 周すると小学校に戻ってきます。全員が小学校を同時にスタートしてから、全員が同時に小学校で最初に出会うのは、それぞれ何周したときでしょうか?
生徒の人数
n
、各生徒のコースの 1 周の距離
d
(km)  、各生徒の走る速さ
v
(km/時間)を入力とし、全員が小学校を同時にスタートしてから次に同時に小学校に位置するのは、各生徒がそれぞれ何周したときかを出力するプログラムを作成してください。なお、各生徒は 2
31
-1 周を超えて走ることはありません。
Input
複数のデータセットの並びが入力として与えられます。入力の終わりはゼロひとつの行で示されます。
各データセットは以下の形式で与えられます。
n
d
1
v
1
d
2
v
2
:
d
n
v
n
1 行目に生徒の人数
n
(2 ≤
n
≤ 10) が与えられます。続く
n
行に
i
人目の生徒のコースの１周の距離
d
i
(1 ≤
d
i
≤ 10000) と走る速さ
v
i
(1 ≤
v
i
≤ 10000) が与えられます。
データセットの数は 2000 を超えません。
Output
入力データセットごとに、各生徒の周回数を出力します。各生徒の周回数は入力の順番に従ってそれぞれ１行に出力してください。
Sample Input
2
4 3
5 4
5
789 289
166 46
9 4
617 252
972 303
2
8 5
32 20
0
Output for the Sample Input
15
16
1598397732
1209243492
1939462992
1782294192
1360317793
1
1",C,"#include <stdio.h>

long long gcd(long long a, long long b) {
    while (b != 0) {
        long long temp = b;
        b = a % b;
        a = temp;
    }
    return a;
}

long long lcm(long long a, long long b) {
    return (a / gcd(a, b)) * b;
}

int main() {
    int n;
    while (scanf(""%d"", &n) == 1 && n != 0) {
        long long times[10];
        long long d, v;
        
        for (int i = 0; i < n; i++) {
            scanf(""%lld %lld"", &d, &v);
            long long g = gcd(d, v);
            d /= g;
            v /= g;
            times[i] = d;
        }
        
        long long lcm_time = times[0];
        for (int i = 1; i < n; i++) {
            lcm_time = lcm(lcm_time, times[i]);
        }
        
        for (int i = 0; i < n; i++) {
            printf(""%lld\n"", lcm_time / times[i]);
        }
    }
    
    return 0;
}
",0
p00211,"みんなでジョギング
赤ベコ小学校では、生徒全員が参加する、ちょっと変わったジョギングをします。生徒は、それぞれ独自の周回コースを、自分のペースで走ります。それぞれ自分のコースを 1 周すると小学校に戻ってきます。全員が小学校を同時にスタートしてから、全員が同時に小学校で最初に出会うのは、それぞれ何周したときでしょうか?
生徒の人数
n
、各生徒のコースの 1 周の距離
d
(km)  、各生徒の走る速さ
v
(km/時間)を入力とし、全員が小学校を同時にスタートしてから次に同時に小学校に位置するのは、各生徒がそれぞれ何周したときかを出力するプログラムを作成してください。なお、各生徒は 2
31
-1 周を超えて走ることはありません。
Input
複数のデータセットの並びが入力として与えられます。入力の終わりはゼロひとつの行で示されます。
各データセットは以下の形式で与えられます。
n
d
1
v
1
d
2
v
2
:
d
n
v
n
1 行目に生徒の人数
n
(2 ≤
n
≤ 10) が与えられます。続く
n
行に
i
人目の生徒のコースの１周の距離
d
i
(1 ≤
d
i
≤ 10000) と走る速さ
v
i
(1 ≤
v
i
≤ 10000) が与えられます。
データセットの数は 2000 を超えません。
Output
入力データセットごとに、各生徒の周回数を出力します。各生徒の周回数は入力の順番に従ってそれぞれ１行に出力してください。
Sample Input
2
4 3
5 4
5
789 289
166 46
9 4
617 252
972 303
2
8 5
32 20
0
Output for the Sample Input
15
16
1598397732
1209243492
1939462992
1782294192
1360317793
1
1",C,"#include<stdio.h>
#define N 10
typedef unsigned long long int INT;
INT GCD(INT a, INT b){
	if( b == 0 ) return a;
	else return GCD(b,a%b);
}
INT LCM(INT a, INT b){
	return (a/GCD(a,b))*b;
}
int main(){
	while(1){
		int i,n;
		INT d[N];
		INT v[N];
		INT Rates[N];
		INT lcmV = 1;
		INT gcdRates = 1;
		INT lcmRates = 1;

		scanf(""%d"",&n);
		if(0==n)break;

		for(i = 0; i < n; ++i){
			int td, tv;
			int gcd;
			scanf(""%d%d"",&td,&tv);
			gcd = GCD(td,tv);
			d[i] = (INT)td/gcd;
			v[i] = (INT)tv/gcd;
		}
		
		lcmV = LCM( v[0], v[1] );
		for(i = 2; i < n; ++i){
			lcmV = LCM( lcmV, v[i] );
		}
		for(i = 0; i < n; ++i){
			Rates[i] = (lcmV / v[i])*d[i];
		}
		gcdRates = GCD( Rates[0], Rates[1] );
		for(i = 2; i < n; ++i){
			gcdRates = GCD( gcdRates, Rates[i] );
		}
		for(i = 0; i < n; ++i){
			Rates[i] /= gcdRates;
		}
		lcmRates = LCM( Rates[0], Rates[1] );
		for(i = 2; i < n; ++i){
			lcmRates = LCM( lcmRates, Rates[i] );
		}
		for(i = 0; i < n; ++i){
			printf(""%u\n"", (unsigned int)(lcmRates / Rates[i]));
		}
	}
	return 0;
}",1
p00211,"みんなでジョギング
赤ベコ小学校では、生徒全員が参加する、ちょっと変わったジョギングをします。生徒は、それぞれ独自の周回コースを、自分のペースで走ります。それぞれ自分のコースを 1 周すると小学校に戻ってきます。全員が小学校を同時にスタートしてから、全員が同時に小学校で最初に出会うのは、それぞれ何周したときでしょうか?
生徒の人数
n
、各生徒のコースの 1 周の距離
d
(km)  、各生徒の走る速さ
v
(km/時間)を入力とし、全員が小学校を同時にスタートしてから次に同時に小学校に位置するのは、各生徒がそれぞれ何周したときかを出力するプログラムを作成してください。なお、各生徒は 2
31
-1 周を超えて走ることはありません。
Input
複数のデータセットの並びが入力として与えられます。入力の終わりはゼロひとつの行で示されます。
各データセットは以下の形式で与えられます。
n
d
1
v
1
d
2
v
2
:
d
n
v
n
1 行目に生徒の人数
n
(2 ≤
n
≤ 10) が与えられます。続く
n
行に
i
人目の生徒のコースの１周の距離
d
i
(1 ≤
d
i
≤ 10000) と走る速さ
v
i
(1 ≤
v
i
≤ 10000) が与えられます。
データセットの数は 2000 を超えません。
Output
入力データセットごとに、各生徒の周回数を出力します。各生徒の周回数は入力の順番に従ってそれぞれ１行に出力してください。
Sample Input
2
4 3
5 4
5
789 289
166 46
9 4
617 252
972 303
2
8 5
32 20
0
Output for the Sample Input
15
16
1598397732
1209243492
1939462992
1782294192
1360317793
1
1",Java,"import java.util.*;
import java.io.*;

public class Main {
    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        String line;
        
        while ((line = br.readLine()) != null) {
            int n = Integer.parseInt(line.trim());
            if (n == 0) break;
            
            long[] d = new long[n];
            long[] v = new long[n];
            
            for (int i = 0; i < n; i++) {
                String[] parts = br.readLine().trim().split(""\\s+"");
                d[i] = Long.parseLong(parts[0]);
                v[i] = Long.parseLong(parts[1]);
            }
            
            // Calculate time for each student to complete one lap
            // time = distance / speed = d / v
            // We need to find LCM of all times
            // time_i = d_i / v_i
            // To avoid floating point, we work with fractions
            
            // Reduce each fraction d_i / v_i
            long[] numerators = new long[n];
            long[] denominators = new long[n];
            
            for (int i = 0; i < n; i++) {
                long g = gcd(d[i], v[i]);
                numerators[i] = d[i] / g;
                denominators[i] = v[i] / g;
            }
            
            // Find LCM of fractions: LCM(a/b, c/d) = LCM(a,c) / GCD(b,d)
            long lcmNum = numerators[0];
            long lcmDen = denominators[0];
            
            for (int i = 1; i < n; i++) {
                lcmNum = lcm(lcmNum, numerators[i]);
                lcmDen = gcd(lcmDen, denominators[i]);
            }
            
            // The total time when all meet is lcmNum / lcmDen
            // Number of laps for student i = (lcmNum / lcmDen) / (numerators[i] / denominators[i])
            //                               = (lcmNum / lcmDen) * (denominators[i] / numerators[i])
            //                               = (lcmNum * denominators[i]) / (lcmDen * numerators[i])
            
            for (int i = 0; i < n; i++) {
                long laps = (lcmNum * denominators[i]) / (lcmDen * numerators[i]);
                System.out.println(laps);
            }
        }
    }
    
    static long gcd(long a, long b) {
        while (b != 0) {
            long temp = b;
            b = a % b;
            a = temp;
        }
        return a;
    }
    
    static long lcm(long a, long b) {
        return a / gcd(a, b) * b;
    }
}
",0
p00211,"みんなでジョギング
赤ベコ小学校では、生徒全員が参加する、ちょっと変わったジョギングをします。生徒は、それぞれ独自の周回コースを、自分のペースで走ります。それぞれ自分のコースを 1 周すると小学校に戻ってきます。全員が小学校を同時にスタートしてから、全員が同時に小学校で最初に出会うのは、それぞれ何周したときでしょうか?
生徒の人数
n
、各生徒のコースの 1 周の距離
d
(km)  、各生徒の走る速さ
v
(km/時間)を入力とし、全員が小学校を同時にスタートしてから次に同時に小学校に位置するのは、各生徒がそれぞれ何周したときかを出力するプログラムを作成してください。なお、各生徒は 2
31
-1 周を超えて走ることはありません。
Input
複数のデータセットの並びが入力として与えられます。入力の終わりはゼロひとつの行で示されます。
各データセットは以下の形式で与えられます。
n
d
1
v
1
d
2
v
2
:
d
n
v
n
1 行目に生徒の人数
n
(2 ≤
n
≤ 10) が与えられます。続く
n
行に
i
人目の生徒のコースの１周の距離
d
i
(1 ≤
d
i
≤ 10000) と走る速さ
v
i
(1 ≤
v
i
≤ 10000) が与えられます。
データセットの数は 2000 を超えません。
Output
入力データセットごとに、各生徒の周回数を出力します。各生徒の周回数は入力の順番に従ってそれぞれ１行に出力してください。
Sample Input
2
4 3
5 4
5
789 289
166 46
9 4
617 252
972 303
2
8 5
32 20
0
Output for the Sample Input
15
16
1598397732
1209243492
1939462992
1782294192
1360317793
1
1",Java,"import java.io.*;
import java.util.Scanner;
import java.math.BigInteger;

public class Main
{	
	public static void main(String[] args)
	{
		Scanner cin = new Scanner(System.in);
		
		int n;
		while(true)
		{
			n = cin.nextInt();
			if(n==0) break;
	
			BigInteger   p = new BigInteger(""1""); 
			BigInteger[] s = new BigInteger[10];
			BigInteger[] t = new BigInteger[10];

			for(int i=0; i<n; i++)
			{
				s[i] = new BigInteger(cin.next());
				t[i] = new BigInteger(cin.next());
				
				p = t[i].multiply( p.divide( p.gcd(t[i]) ));
			}

			for(int i=0; i<n; i++)
			{
				s[i] = s[i].multiply( p.divide(t[i]) );
			}
			
			p = new BigInteger(""1"");
			for(int i=0; i<n; i++)
			{
				p = s[i].multiply( p.divide( p.gcd(s[i]) ));
			}			
			
			for(int i=0; i<n; i++)
			{
				System.out.println(p.divide(s[i]));
			}
		}
	}
}",1
p00211,"みんなでジョギング
赤ベコ小学校では、生徒全員が参加する、ちょっと変わったジョギングをします。生徒は、それぞれ独自の周回コースを、自分のペースで走ります。それぞれ自分のコースを 1 周すると小学校に戻ってきます。全員が小学校を同時にスタートしてから、全員が同時に小学校で最初に出会うのは、それぞれ何周したときでしょうか?
生徒の人数
n
、各生徒のコースの 1 周の距離
d
(km)  、各生徒の走る速さ
v
(km/時間)を入力とし、全員が小学校を同時にスタートしてから次に同時に小学校に位置するのは、各生徒がそれぞれ何周したときかを出力するプログラムを作成してください。なお、各生徒は 2
31
-1 周を超えて走ることはありません。
Input
複数のデータセットの並びが入力として与えられます。入力の終わりはゼロひとつの行で示されます。
各データセットは以下の形式で与えられます。
n
d
1
v
1
d
2
v
2
:
d
n
v
n
1 行目に生徒の人数
n
(2 ≤
n
≤ 10) が与えられます。続く
n
行に
i
人目の生徒のコースの１周の距離
d
i
(1 ≤
d
i
≤ 10000) と走る速さ
v
i
(1 ≤
v
i
≤ 10000) が与えられます。
データセットの数は 2000 を超えません。
Output
入力データセットごとに、各生徒の周回数を出力します。各生徒の周回数は入力の順番に従ってそれぞれ１行に出力してください。
Sample Input
2
4 3
5 4
5
789 289
166 46
9 4
617 252
972 303
2
8 5
32 20
0
Output for the Sample Input
15
16
1598397732
1209243492
1939462992
1782294192
1360317793
1
1",Python,"from math import gcd
from fractions import Fraction

def lcm(a, b):
    return a * b // gcd(a, b)

def lcm_multiple(numbers):
    result = numbers[0]
    for num in numbers[1:]:
        result = lcm(result, num)
    return result

while True:
    n = int(input())
    if n == 0:
        break
    
    students = []
    for _ in range(n):
        d, v = map(int, input().split())
        students.append((d, v))
    
    # Calculate time for one lap for each student as a fraction
    times = []
    for d, v in students:
        times.append(Fraction(d, v))
    
    # Find LCM of all times
    # LCM of fractions a/b and c/d is LCM(a,c)/GCD(b,d)
    numerators = [t.numerator for t in times]
    denominators = [t.denominator for t in times]
    
    lcm_num = lcm_multiple(numerators)
    gcd_den = denominators[0]
    for den in denominators[1:]:
        gcd_den = gcd(gcd_den, den)
    
    meeting_time = Fraction(lcm_num, gcd_den)
    
    # Calculate laps for each student
    for time in times:
        laps = meeting_time / time
        print(int(laps))
",0
p00211,"みんなでジョギング
赤ベコ小学校では、生徒全員が参加する、ちょっと変わったジョギングをします。生徒は、それぞれ独自の周回コースを、自分のペースで走ります。それぞれ自分のコースを 1 周すると小学校に戻ってきます。全員が小学校を同時にスタートしてから、全員が同時に小学校で最初に出会うのは、それぞれ何周したときでしょうか?
生徒の人数
n
、各生徒のコースの 1 周の距離
d
(km)  、各生徒の走る速さ
v
(km/時間)を入力とし、全員が小学校を同時にスタートしてから次に同時に小学校に位置するのは、各生徒がそれぞれ何周したときかを出力するプログラムを作成してください。なお、各生徒は 2
31
-1 周を超えて走ることはありません。
Input
複数のデータセットの並びが入力として与えられます。入力の終わりはゼロひとつの行で示されます。
各データセットは以下の形式で与えられます。
n
d
1
v
1
d
2
v
2
:
d
n
v
n
1 行目に生徒の人数
n
(2 ≤
n
≤ 10) が与えられます。続く
n
行に
i
人目の生徒のコースの１周の距離
d
i
(1 ≤
d
i
≤ 10000) と走る速さ
v
i
(1 ≤
v
i
≤ 10000) が与えられます。
データセットの数は 2000 を超えません。
Output
入力データセットごとに、各生徒の周回数を出力します。各生徒の周回数は入力の順番に従ってそれぞれ１行に出力してください。
Sample Input
2
4 3
5 4
5
789 289
166 46
9 4
617 252
972 303
2
8 5
32 20
0
Output for the Sample Input
15
16
1598397732
1209243492
1939462992
1782294192
1360317793
1
1",Python,""""""" Created by Jieyi on 10/4/16. """"""
import io
import sys

if len(sys.argv) > 1:
    filename = sys.argv[1]
    inp = ''.join(open(filename, ""r"").readlines())
    sys.stdin = io.StringIO(inp)


def gcd(x, y):
    while y:
        x, y = y, x % y

    return x


def lcm(x, y):
    l_lcm = (x * y) // gcd(x, y)
    return l_lcm


def mul_lcm(array):
    l = lcm(array[0], array[1])
    if len(array) > 3:
        for i in range(2, len(array)):
            l = lcm(array[i], l)
    return l


def algorithm(students):
    denominator_lcm = mul_lcm([y for _, y in students])
    for i in range(len(students)):
        students[i][0] *= int(denominator_lcm / students[i][1])
    molecular_lcm = mul_lcm([x for x, _ in students])

    return [int(molecular_lcm / students[i][0]) for i in range(len(students))]


def input_sample():
    while True:
        n = int(input())
        if n == 0:
            break

        students = []
        for _ in range(n):
            students.append(list(map(int, input().split())))
        answer_list = algorithm(students)
        for ans in answer_list:
            print(ans)


def main():
    input_sample()


if __name__ == '__main__':
    main()",1
p00212,"高速バス
A 君は高校の休みを利用して、高速バス(以下、「バス」 )で一人旅をする計画を立てています。まず、A 君は一番行ってみたい町を選んでそこを目的地にしました。次に出発地から目的地までバスを乗り継いでいくルートを決めなければなりません。乗り継ぎをするときは、バスを降りてから別のバスに乗り換えるので、それぞれのバスの乗車券が必要になります。
A 君は親戚のおじさんからバスの割引券を何枚かもらいました。   この券を 1 枚使うと乗車券 1 枚を半額で購入できます。例えば、図 1 の出発地5から目的地1へ行く場合には、5→4→6→2→1と5→3→1の二つの経路が考えられます。割引券が 2 枚あるとすると、交通費を最も安くするには5→4→6→2→1の経路をたどった場合、4→6と6→2の路線に割引を利用し、合計料金は 4600円となります。一方、5→3→1の経路をたどった場合、5→3と3→1の路線に割引を利用し、合計料金は 3750 円となります。
A 君は観光にお金を回したいので、交通費はできるだけ少なくしようと考えています。そこで A 君は、出発地から目的地までの最も安い交通費を求めるプログラムを作成することにしました。
図1
割引券の枚数、バスがつなぐ町の数、バスの路線数、各バスの路線情報を入力とし、出発地から目的地までの最も安い交通費を出力するプログラムを作成してください。各バスは双方向に同一料金で運行しています。また、町の数を
n
とすると、町にはそれぞれ異なる 1 から
n
までの番号が振られています。出発地から目的地までの経路は必ず存在するものとします。
Input
複数のデータセットの並びが入力として与えられます。         入力の終わりはゼロが５つの行で示されます。
各データセットは以下の形式で与えられます。
c
n
m
s
d
a
1
b
1
f
1
a
2
b
2
f
2
:
a
m
b
m
f
m
1 行目に割引券の枚数
c
(1 ≤
c
≤ 10)、バスがつなぐ町の数
n
(2 ≤
n
≤ 100)、バスの路線数
m
(1 ≤
m
≤ 500)、出発地の町番号
s
と目的地の町番号
d
(
s ≠ d
)  が与えられます。
続く
m
行に第
i
のバスの路線情報
a
i
, b
i
, f
i
(1 ≤
a
i
, b
i
≤
n
, 1000 ≤
f
i
≤ 10000) が与えられます。
a
i
, b
i
はバスの路線の始点と終点の町番号、
f
i
はこの路線の料金を表す100 刻みの整数です。
データセットの数は 100 を超えません。
Output
入力データセットごとに、最も安い交通費を１行に出力します。
Sample Input
1 3 3 1 3
1 3 2000
1 2 1000
2 3 1000
2 3 3 1 3
1 3 2300
1 2 1000
2 3 1200
2 6 6 5 1
1 2 1500
1 3 4500
2 6 2000
5 4 1000
6 4 2200
3 5 3000
0 0 0 0 0
Output for the Sample Input
1000
1100
3750",C,"#include <stdio.h>
#include <string.h>
#include <limits.h>

#define MAX_N 101
#define MAX_M 501
#define INF INT_MAX

typedef struct {
    int to;
    int cost;
} Edge;

Edge edges[MAX_M * 2];
int head[MAX_N];
int next_edge[MAX_M * 2];
int edge_count;

void add_edge(int from, int to, int cost) {
    edges[edge_count].to = to;
    edges[edge_count].cost = cost;
    next_edge[edge_count] = head[from];
    head[from] = edge_count;
    edge_count++;
}

typedef struct {
    int node;
    int tickets_used;
    int cost;
} State;

State queue[MAX_N * 12];
int queue_start, queue_end;

void enqueue(int node, int tickets, int cost) {
    queue[queue_end].node = node;
    queue[queue_end].tickets_used = tickets;
    queue[queue_end].cost = cost;
    queue_end++;
}

State dequeue() {
    return queue[queue_start++];
}

int min_cost[MAX_N][12];

int dijkstra(int n, int s, int d, int c) {
    for (int i = 0; i <= n; i++) {
        for (int j = 0; j <= c; j++) {
            min_cost[i][j] = INF;
        }
    }
    
    queue_start = 0;
    queue_end = 0;
    enqueue(s, 0, 0);
    min_cost[s][0] = 0;
    
    while (queue_start < queue_end) {
        State current = dequeue();
        int u = current.node;
        int tickets = current.tickets_used;
        int curr_cost = current.cost;
        
        if (curr_cost > min_cost[u][tickets]) {
            continue;
        }
        
        for (int e = head[u]; e != -1; e = next_edge[e]) {
            int v = edges[e].to;
            int edge_cost = edges[e].cost;
            
            // Without using discount
            int new_cost = curr_cost + edge_cost;
            if (new_cost < min_cost[v][tickets]) {
                min_cost[v][tickets] = new_cost;
                enqueue(v, tickets, new_cost);
            }
            
            // With discount
            if (tickets < c) {
                int discounted_cost = curr_cost + edge_cost / 2;
                if (discounted_cost < min_cost[v][tickets + 1]) {
                    min_cost[v][tickets + 1] = discounted_cost;
                    enqueue(v, tickets + 1, discounted_cost);
                }
            }
        }
    }
    
    int result = INF;
    for (int i = 0; i <= c; i++) {
        if (min_cost[d][i] < result) {
            result = min_cost[d][i];
        }
    }
    return result;
}

int main() {
    int c, n, m, s, d;
    
    while (1) {
        scanf(""%d %d %d %d %d"", &c, &n, &m, &s, &d);
        if (c == 0 && n == 0 && m == 0 && s == 0 && d == 0) {
            break;
        }
        
        edge_count = 0;
        for (int i = 0; i <= n; i++) {
            head[i] = -1;
        }
        
        for (int i = 0; i < m; i++) {
            int a, b, f;
            scanf(""%d %d %d"", &a, &b, &f);
            add_edge(a, b, f);
            add_edge(b, a, f);
        }
        
        int result = dijkstra(n, s, d, c);
        printf(""%d\n"", result);
    }
    
    return 0;
}
",0
p00212,"高速バス
A 君は高校の休みを利用して、高速バス(以下、「バス」 )で一人旅をする計画を立てています。まず、A 君は一番行ってみたい町を選んでそこを目的地にしました。次に出発地から目的地までバスを乗り継いでいくルートを決めなければなりません。乗り継ぎをするときは、バスを降りてから別のバスに乗り換えるので、それぞれのバスの乗車券が必要になります。
A 君は親戚のおじさんからバスの割引券を何枚かもらいました。   この券を 1 枚使うと乗車券 1 枚を半額で購入できます。例えば、図 1 の出発地5から目的地1へ行く場合には、5→4→6→2→1と5→3→1の二つの経路が考えられます。割引券が 2 枚あるとすると、交通費を最も安くするには5→4→6→2→1の経路をたどった場合、4→6と6→2の路線に割引を利用し、合計料金は 4600円となります。一方、5→3→1の経路をたどった場合、5→3と3→1の路線に割引を利用し、合計料金は 3750 円となります。
A 君は観光にお金を回したいので、交通費はできるだけ少なくしようと考えています。そこで A 君は、出発地から目的地までの最も安い交通費を求めるプログラムを作成することにしました。
図1
割引券の枚数、バスがつなぐ町の数、バスの路線数、各バスの路線情報を入力とし、出発地から目的地までの最も安い交通費を出力するプログラムを作成してください。各バスは双方向に同一料金で運行しています。また、町の数を
n
とすると、町にはそれぞれ異なる 1 から
n
までの番号が振られています。出発地から目的地までの経路は必ず存在するものとします。
Input
複数のデータセットの並びが入力として与えられます。         入力の終わりはゼロが５つの行で示されます。
各データセットは以下の形式で与えられます。
c
n
m
s
d
a
1
b
1
f
1
a
2
b
2
f
2
:
a
m
b
m
f
m
1 行目に割引券の枚数
c
(1 ≤
c
≤ 10)、バスがつなぐ町の数
n
(2 ≤
n
≤ 100)、バスの路線数
m
(1 ≤
m
≤ 500)、出発地の町番号
s
と目的地の町番号
d
(
s ≠ d
)  が与えられます。
続く
m
行に第
i
のバスの路線情報
a
i
, b
i
, f
i
(1 ≤
a
i
, b
i
≤
n
, 1000 ≤
f
i
≤ 10000) が与えられます。
a
i
, b
i
はバスの路線の始点と終点の町番号、
f
i
はこの路線の料金を表す100 刻みの整数です。
データセットの数は 100 を超えません。
Output
入力データセットごとに、最も安い交通費を１行に出力します。
Sample Input
1 3 3 1 3
1 3 2000
1 2 1000
2 3 1000
2 3 3 1 3
1 3 2300
1 2 1000
2 3 1200
2 6 6 5 1
1 2 1500
1 3 4500
2 6 2000
5 4 1000
6 4 2200
3 5 3000
0 0 0 0 0
Output for the Sample Input
1000
1100
3750",C,"#include <stdio.h>

#define INF 100000000

struct NODE {
    int distance;
    int state;
} vertex[11][101];

int W[101][101];
int c, V, n, s, d;

int min(int a, int b) {
    return (a > b ? b : a);
}

void dijkstra(int start) {
    int i, x, p, step;
    for (i = 0; i <= c; i++) {
	for (x = 1; x <= n; x++) {
	    vertex[i][x].distance = INF; vertex[i][x].state = 0;
	}
	vertex[i][start].distance = 0; 
    }
    for (i = 0; i <= c; i++) {
	for (step = 1; step <= n; step++) {
	    int minimum = INF;
	    for (x = 1; x <= n; x++)
		if (vertex[i][x].state == 0 && vertex[i][x].distance < minimum) {
		    p = x; minimum = vertex[i][x].distance;
		}
	    vertex[i][p].state = 1;
	    for (x = 1 ; x <= n; x++)
		if (vertex[i][x].state == 0) {
		    if (i == 0)
			vertex[i][x].distance = min(vertex[i][x].distance, 
						    vertex[i][p].distance+W[p][x]);
		    else
			vertex[i][x].distance = min(vertex[i][x].distance, 
						    min(vertex[i][p].distance+W[p][x],
							vertex[i-1][p].distance+W[p][x]/2));
		}
	}
    }
}

int main(void) {
    int i, j;
    int from, to, m;
     
    while (1) {
	scanf(""%d%d%d%d%d"", &c, &V, &n, &s, &d);
        if (c + V + n + s + d == 0) break;
         
        for (i = 0; i <= V; i++)
            for (j = 0; j <= V; j++)
                W[i][j] = INF;
         
	for (i = 0; i < n; i++) {
            scanf(""%d%d%d"", &from, &to, &m);
            W[from][to] = m;
	    W[to][from] = m;
        }
         
        dijkstra(s);
	printf(""%d\n"", vertex[c][d].distance);
    }
    return 0;
}",1
p00212,"高速バス
A 君は高校の休みを利用して、高速バス(以下、「バス」 )で一人旅をする計画を立てています。まず、A 君は一番行ってみたい町を選んでそこを目的地にしました。次に出発地から目的地までバスを乗り継いでいくルートを決めなければなりません。乗り継ぎをするときは、バスを降りてから別のバスに乗り換えるので、それぞれのバスの乗車券が必要になります。
A 君は親戚のおじさんからバスの割引券を何枚かもらいました。   この券を 1 枚使うと乗車券 1 枚を半額で購入できます。例えば、図 1 の出発地5から目的地1へ行く場合には、5→4→6→2→1と5→3→1の二つの経路が考えられます。割引券が 2 枚あるとすると、交通費を最も安くするには5→4→6→2→1の経路をたどった場合、4→6と6→2の路線に割引を利用し、合計料金は 4600円となります。一方、5→3→1の経路をたどった場合、5→3と3→1の路線に割引を利用し、合計料金は 3750 円となります。
A 君は観光にお金を回したいので、交通費はできるだけ少なくしようと考えています。そこで A 君は、出発地から目的地までの最も安い交通費を求めるプログラムを作成することにしました。
図1
割引券の枚数、バスがつなぐ町の数、バスの路線数、各バスの路線情報を入力とし、出発地から目的地までの最も安い交通費を出力するプログラムを作成してください。各バスは双方向に同一料金で運行しています。また、町の数を
n
とすると、町にはそれぞれ異なる 1 から
n
までの番号が振られています。出発地から目的地までの経路は必ず存在するものとします。
Input
複数のデータセットの並びが入力として与えられます。         入力の終わりはゼロが５つの行で示されます。
各データセットは以下の形式で与えられます。
c
n
m
s
d
a
1
b
1
f
1
a
2
b
2
f
2
:
a
m
b
m
f
m
1 行目に割引券の枚数
c
(1 ≤
c
≤ 10)、バスがつなぐ町の数
n
(2 ≤
n
≤ 100)、バスの路線数
m
(1 ≤
m
≤ 500)、出発地の町番号
s
と目的地の町番号
d
(
s ≠ d
)  が与えられます。
続く
m
行に第
i
のバスの路線情報
a
i
, b
i
, f
i
(1 ≤
a
i
, b
i
≤
n
, 1000 ≤
f
i
≤ 10000) が与えられます。
a
i
, b
i
はバスの路線の始点と終点の町番号、
f
i
はこの路線の料金を表す100 刻みの整数です。
データセットの数は 100 を超えません。
Output
入力データセットごとに、最も安い交通費を１行に出力します。
Sample Input
1 3 3 1 3
1 3 2000
1 2 1000
2 3 1000
2 3 3 1 3
1 3 2300
1 2 1000
2 3 1200
2 6 6 5 1
1 2 1500
1 3 4500
2 6 2000
5 4 1000
6 4 2200
3 5 3000
0 0 0 0 0
Output for the Sample Input
1000
1100
3750",Java,"import java.util.*;

public class Main {
    static class Edge {
        int to, cost;
        Edge(int to, int cost) {
            this.to = to;
            this.cost = cost;
        }
    }
    
    static class State implements Comparable<State> {
        int node, couponsUsed, cost;
        
        State(int node, int couponsUsed, int cost) {
            this.node = node;
            this.couponsUsed = couponsUsed;
            this.cost = cost;
        }
        
        @Override
        public int compareTo(State other) {
            return Integer.compare(this.cost, other.cost);
        }
    }
    
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        
        while (true) {
            int c = sc.nextInt();
            int n = sc.nextInt();
            int m = sc.nextInt();
            int s = sc.nextInt();
            int d = sc.nextInt();
            
            if (c == 0 && n == 0 && m == 0 && s == 0 && d == 0) {
                break;
            }
            
            List<List<Edge>> graph = new ArrayList<>();
            for (int i = 0; i <= n; i++) {
                graph.add(new ArrayList<>());
            }
            
            for (int i = 0; i < m; i++) {
                int a = sc.nextInt();
                int b = sc.nextInt();
                int f = sc.nextInt();
                graph.get(a).add(new Edge(b, f));
                graph.get(b).add(new Edge(a, f));
            }
            
            int result = dijkstra(graph, n, c, s, d);
            System.out.println(result);
        }
        
        sc.close();
    }
    
    static int dijkstra(List<List<Edge>> graph, int n, int c, int s, int d) {
        int[][] dist = new int[n + 1][c + 1];
        for (int i = 0; i <= n; i++) {
            Arrays.fill(dist[i], Integer.MAX_VALUE);
        }
        
        PriorityQueue<State> pq = new PriorityQueue<>();
        pq.offer(new State(s, 0, 0));
        dist[s][0] = 0;
        
        while (!pq.isEmpty()) {
            State current = pq.poll();
            
            if (current.node == d) {
                return current.cost;
            }
            
            if (current.cost > dist[current.node][current.couponsUsed]) {
                continue;
            }
            
            for (Edge edge : graph.get(current.node)) {
                // Without using coupon
                int newCost = current.cost + edge.cost;
                if (newCost < dist[edge.to][current.couponsUsed]) {
                    dist[edge.to][current.couponsUsed] = newCost;
                    pq.offer(new State(edge.to, current.couponsUsed, newCost));
                }
                
                // With using coupon
                if (current.couponsUsed < c) {
                    int discountedCost = current.cost + edge.cost / 2;
                    if (discountedCost < dist[edge.to][current.couponsUsed + 1]) {
                        dist[edge.to][current.couponsUsed + 1] = discountedCost;
                        pq.offer(new State(edge.to, current.couponsUsed + 1, discountedCost));
                    }
                }
            }
        }
        
        int minCost = Integer.MAX_VALUE;
        for (int i = 0; i <= c; i++) {
            minCost = Math.min(minCost, dist[d][i]);
        }
        
        return minCost;
    }
}
",0
p00212,"高速バス
A 君は高校の休みを利用して、高速バス(以下、「バス」 )で一人旅をする計画を立てています。まず、A 君は一番行ってみたい町を選んでそこを目的地にしました。次に出発地から目的地までバスを乗り継いでいくルートを決めなければなりません。乗り継ぎをするときは、バスを降りてから別のバスに乗り換えるので、それぞれのバスの乗車券が必要になります。
A 君は親戚のおじさんからバスの割引券を何枚かもらいました。   この券を 1 枚使うと乗車券 1 枚を半額で購入できます。例えば、図 1 の出発地5から目的地1へ行く場合には、5→4→6→2→1と5→3→1の二つの経路が考えられます。割引券が 2 枚あるとすると、交通費を最も安くするには5→4→6→2→1の経路をたどった場合、4→6と6→2の路線に割引を利用し、合計料金は 4600円となります。一方、5→3→1の経路をたどった場合、5→3と3→1の路線に割引を利用し、合計料金は 3750 円となります。
A 君は観光にお金を回したいので、交通費はできるだけ少なくしようと考えています。そこで A 君は、出発地から目的地までの最も安い交通費を求めるプログラムを作成することにしました。
図1
割引券の枚数、バスがつなぐ町の数、バスの路線数、各バスの路線情報を入力とし、出発地から目的地までの最も安い交通費を出力するプログラムを作成してください。各バスは双方向に同一料金で運行しています。また、町の数を
n
とすると、町にはそれぞれ異なる 1 から
n
までの番号が振られています。出発地から目的地までの経路は必ず存在するものとします。
Input
複数のデータセットの並びが入力として与えられます。         入力の終わりはゼロが５つの行で示されます。
各データセットは以下の形式で与えられます。
c
n
m
s
d
a
1
b
1
f
1
a
2
b
2
f
2
:
a
m
b
m
f
m
1 行目に割引券の枚数
c
(1 ≤
c
≤ 10)、バスがつなぐ町の数
n
(2 ≤
n
≤ 100)、バスの路線数
m
(1 ≤
m
≤ 500)、出発地の町番号
s
と目的地の町番号
d
(
s ≠ d
)  が与えられます。
続く
m
行に第
i
のバスの路線情報
a
i
, b
i
, f
i
(1 ≤
a
i
, b
i
≤
n
, 1000 ≤
f
i
≤ 10000) が与えられます。
a
i
, b
i
はバスの路線の始点と終点の町番号、
f
i
はこの路線の料金を表す100 刻みの整数です。
データセットの数は 100 を超えません。
Output
入力データセットごとに、最も安い交通費を１行に出力します。
Sample Input
1 3 3 1 3
1 3 2000
1 2 1000
2 3 1000
2 3 3 1 3
1 3 2300
1 2 1000
2 3 1200
2 6 6 5 1
1 2 1500
1 3 4500
2 6 2000
5 4 1000
6 4 2200
3 5 3000
0 0 0 0 0
Output for the Sample Input
1000
1100
3750",Java,"import java.util.Arrays;
import java.util.Scanner;
public class Main
{
	public static void main(String arg[])
	{
		Scanner in=new Scanner(System.in);
		int M=1000001;
		for(;;)
		{
			int c=in.nextInt();//チケットの数
			int n=in.nextInt(),m=in.nextInt();//バス停の数,道の数
			int s=in.nextInt(),d=in.nextInt();//スタート&ゴール
			if((c|n|m|s|d)==0)
				return;
			int cost[][]=new int[n+1][n+1];
			for(int i=0;i<=n;i++)
				Arrays.fill(cost[i], M);
			for(int q[]: cost) {
				Arrays.fill(q, M);
			}
			for(int i=0;i<=n;i++)
				cost[i][i]=0;
			for(int i=0;i<m;i++)
			{
				int a=in.nextInt();
				int b=in.nextInt();
				int f=in.nextInt();
				cost[a][b]=f;
				cost[b][a]=f;
			}
			int p=0,w=0;
			int v[][] = new int[n+1][c+1];// decision flag
			int leng[][]=new int[n+1][c+1];// minimum distance
			for(int i=0;i<=n;i++)
				for(int k=0;k<=c;k++)
				{
					leng[i][k]=M;
					v[i][k]=0;
				}
			leng[s][c]=0;
			for(;;)
			{
				int min=M;//最小の節点を探す
				for(int l=1;l<=n;l++)
					for(int k=1;k<=c;k++)
					{
						if(v[l][k]==0&&leng[l][k]<min)
						{
							p=l;
							w=k;
							min=leng[l][k];
						}
					}
				if(min==M)
					break;
				v[p][w]=1;//確定フラグ
				for(int l=1;l<=n;l++) //pを経由してlに至る長さがそれまでの最短経路より小さければ更新
				{
					leng[l][w]=Math.min(leng[l][w], leng[p][w]+cost[p][l]);
					if (w>0)
						leng[l][w-1]=Math.min(leng[l][w-1], leng[p][w]+cost[p][l]/2);
				}
			}
			System.out.println(leng[d][0]);
		}
	}
}",1
p00212,"高速バス
A 君は高校の休みを利用して、高速バス(以下、「バス」 )で一人旅をする計画を立てています。まず、A 君は一番行ってみたい町を選んでそこを目的地にしました。次に出発地から目的地までバスを乗り継いでいくルートを決めなければなりません。乗り継ぎをするときは、バスを降りてから別のバスに乗り換えるので、それぞれのバスの乗車券が必要になります。
A 君は親戚のおじさんからバスの割引券を何枚かもらいました。   この券を 1 枚使うと乗車券 1 枚を半額で購入できます。例えば、図 1 の出発地5から目的地1へ行く場合には、5→4→6→2→1と5→3→1の二つの経路が考えられます。割引券が 2 枚あるとすると、交通費を最も安くするには5→4→6→2→1の経路をたどった場合、4→6と6→2の路線に割引を利用し、合計料金は 4600円となります。一方、5→3→1の経路をたどった場合、5→3と3→1の路線に割引を利用し、合計料金は 3750 円となります。
A 君は観光にお金を回したいので、交通費はできるだけ少なくしようと考えています。そこで A 君は、出発地から目的地までの最も安い交通費を求めるプログラムを作成することにしました。
図1
割引券の枚数、バスがつなぐ町の数、バスの路線数、各バスの路線情報を入力とし、出発地から目的地までの最も安い交通費を出力するプログラムを作成してください。各バスは双方向に同一料金で運行しています。また、町の数を
n
とすると、町にはそれぞれ異なる 1 から
n
までの番号が振られています。出発地から目的地までの経路は必ず存在するものとします。
Input
複数のデータセットの並びが入力として与えられます。         入力の終わりはゼロが５つの行で示されます。
各データセットは以下の形式で与えられます。
c
n
m
s
d
a
1
b
1
f
1
a
2
b
2
f
2
:
a
m
b
m
f
m
1 行目に割引券の枚数
c
(1 ≤
c
≤ 10)、バスがつなぐ町の数
n
(2 ≤
n
≤ 100)、バスの路線数
m
(1 ≤
m
≤ 500)、出発地の町番号
s
と目的地の町番号
d
(
s ≠ d
)  が与えられます。
続く
m
行に第
i
のバスの路線情報
a
i
, b
i
, f
i
(1 ≤
a
i
, b
i
≤
n
, 1000 ≤
f
i
≤ 10000) が与えられます。
a
i
, b
i
はバスの路線の始点と終点の町番号、
f
i
はこの路線の料金を表す100 刻みの整数です。
データセットの数は 100 を超えません。
Output
入力データセットごとに、最も安い交通費を１行に出力します。
Sample Input
1 3 3 1 3
1 3 2000
1 2 1000
2 3 1000
2 3 3 1 3
1 3 2300
1 2 1000
2 3 1200
2 6 6 5 1
1 2 1500
1 3 4500
2 6 2000
5 4 1000
6 4 2200
3 5 3000
0 0 0 0 0
Output for the Sample Input
1000
1100
3750",Python,"import heapq
from sys import stdin

def solve(c, n, m, s, d, edges):
    # Build adjacency list
    graph = [[] for _ in range(n + 1)]
    for a, b, f in edges:
        graph[a].append((b, f))
        graph[b].append((a, f))
    
    # Dijkstra with state (cost, node, discounts_used)
    # We need to track how many discounts we've used
    dist = {}  # (node, discounts_used) -> min_cost
    pq = [(0, s, 0)]  # (cost, node, discounts_used)
    dist[(s, 0)] = 0
    
    while pq:
        cost, node, discounts_used = heapq.heappop(pq)
        
        if node == d:
            continue
        
        if (node, discounts_used) in dist and dist[(node, discounts_used)] < cost:
            continue
        
        for next_node, fare in graph[node]:
            # Option 1: Don't use discount
            new_cost = cost + fare
            if (next_node, discounts_used) not in dist or dist[(next_node, discounts_used)] > new_cost:
                dist[(next_node, discounts_used)] = new_cost
                heapq.heappush(pq, (new_cost, next_node, discounts_used))
            
            # Option 2: Use discount if available
            if discounts_used < c:
                new_cost = cost + fare // 2
                if (next_node, discounts_used + 1) not in dist or dist[(next_node, discounts_used + 1)] > new_cost:
                    dist[(next_node, discounts_used + 1)] = new_cost
                    heapq.heappush(pq, (new_cost, next_node, discounts_used + 1))
    
    # Find minimum cost to reach destination with any number of discounts used
    min_cost = float('inf')
    for i in range(c + 1):
        if (d, i) in dist:
            min_cost = min(min_cost, dist[(d, i)])
    
    return min_cost

# Read input
lines = []
for line in stdin:
    lines.append(line.strip())

i = 0
while i < len(lines):
    parts = lines[i].split()
    c, n, m, s, d = map(int, parts)
    if c == 0 and n == 0 and m == 0 and s == 0 and d == 0:
        break
    
    edges = []
    for j in range(m):
        i += 1
        a, b, f = map(int, lines[i].split())
        edges.append((a, b, f))
    
    result = solve(c, n, m, s, d, edges)
    print(result)
    
    i += 1
",0
p00212,"高速バス
A 君は高校の休みを利用して、高速バス(以下、「バス」 )で一人旅をする計画を立てています。まず、A 君は一番行ってみたい町を選んでそこを目的地にしました。次に出発地から目的地までバスを乗り継いでいくルートを決めなければなりません。乗り継ぎをするときは、バスを降りてから別のバスに乗り換えるので、それぞれのバスの乗車券が必要になります。
A 君は親戚のおじさんからバスの割引券を何枚かもらいました。   この券を 1 枚使うと乗車券 1 枚を半額で購入できます。例えば、図 1 の出発地5から目的地1へ行く場合には、5→4→6→2→1と5→3→1の二つの経路が考えられます。割引券が 2 枚あるとすると、交通費を最も安くするには5→4→6→2→1の経路をたどった場合、4→6と6→2の路線に割引を利用し、合計料金は 4600円となります。一方、5→3→1の経路をたどった場合、5→3と3→1の路線に割引を利用し、合計料金は 3750 円となります。
A 君は観光にお金を回したいので、交通費はできるだけ少なくしようと考えています。そこで A 君は、出発地から目的地までの最も安い交通費を求めるプログラムを作成することにしました。
図1
割引券の枚数、バスがつなぐ町の数、バスの路線数、各バスの路線情報を入力とし、出発地から目的地までの最も安い交通費を出力するプログラムを作成してください。各バスは双方向に同一料金で運行しています。また、町の数を
n
とすると、町にはそれぞれ異なる 1 から
n
までの番号が振られています。出発地から目的地までの経路は必ず存在するものとします。
Input
複数のデータセットの並びが入力として与えられます。         入力の終わりはゼロが５つの行で示されます。
各データセットは以下の形式で与えられます。
c
n
m
s
d
a
1
b
1
f
1
a
2
b
2
f
2
:
a
m
b
m
f
m
1 行目に割引券の枚数
c
(1 ≤
c
≤ 10)、バスがつなぐ町の数
n
(2 ≤
n
≤ 100)、バスの路線数
m
(1 ≤
m
≤ 500)、出発地の町番号
s
と目的地の町番号
d
(
s ≠ d
)  が与えられます。
続く
m
行に第
i
のバスの路線情報
a
i
, b
i
, f
i
(1 ≤
a
i
, b
i
≤
n
, 1000 ≤
f
i
≤ 10000) が与えられます。
a
i
, b
i
はバスの路線の始点と終点の町番号、
f
i
はこの路線の料金を表す100 刻みの整数です。
データセットの数は 100 を超えません。
Output
入力データセットごとに、最も安い交通費を１行に出力します。
Sample Input
1 3 3 1 3
1 3 2000
1 2 1000
2 3 1000
2 3 3 1 3
1 3 2300
1 2 1000
2 3 1200
2 6 6 5 1
1 2 1500
1 3 4500
2 6 2000
5 4 1000
6 4 2200
3 5 3000
0 0 0 0 0
Output for the Sample Input
1000
1100
3750",Python,"from sys import stdin
readline = stdin.readline



from collections import namedtuple
Runner = namedtuple('Runner', 'd v')

def main():
    while True:
        ticket, vertex, edge, start, destination = map(int, readline().split())
        if ticket == 0:
            break

        start -= 1
        destination -= 1
        g = defaultdict(list)
        for i in range(edge):
            s, t, length = map(int, readline().split())
            s -= 1
            t -= 1
            g[s].append((length, t))
            g[t].append((length, s))
        
        d = ex_dijkstra(g, vertex, start, ticket)
        print(min(d[destination]))



from heapq import heappush, heappop
from collections import defaultdict
def ex_dijkstra(g, size, start, ticket):
    d = [[float('inf')] * (ticket + 1) for i in range(size)]
    d[start][ticket] = 0
    heap = [(d[start][ticket], start, ticket)]
    while heap:
        du, u, ticket = heappop(heap)
        for length, v in g[u]:
            if d[v][ticket] > du + length:
                d[v][ticket] = du + length
                heappush(heap,(d[v][ticket], v, ticket))
            if ticket and d[v][ticket - 1] > du + length // 2:
                d[v][ticket - 1] = du + length // 2
                heappush(heap,(d[v][ticket - 1], v, ticket - 1))

    return d

main()",1
p00213,">土地分割
ハウジングメーカーの山田ハウスは、新たな目玉商品として、学校や病院など環境が充実している緑ホームタウンの分譲地を売り出しました。この分譲地は複数の区画に分割されており、好きなだけ購入できますが、購入する区画を合わせた土地の形状は長方形(正方形を含む)でなければなりません。
山田ハウスは、全区画が完売した分譲地を管理するため購入者ごとに境界線を引き、その区画の 1つに購入者番号を書いた看板を設置しておきました。境界線は地面に木の枝で線を引いただけのものであったため、数日後の豪雨により消えてしまい看板だけが残りました。図 1 は看板のあった区画に、その区画を買った購入者番号を記したものです。これでは分譲地がどのように買われたか分かりません。救いは事務所の引き出しにあった購入者番号
b
と購入区画数
k
のメモ(図 2)が見つかったことです。
図１（左）：看板の配置、図2（右）：メモ
プログラマーであるあなたは、プログラムを書いて山田ハウスを助けることになりました。分譲地の大きさ
X × Y
、購入者数
n
、メモの情報
b
、
k
、及び看板の位置情報
s
を入力とし、図 3 に示すように各区画の購入者を出力するプログラムを作成してください。
図3：各区画の購入者
与えられた情報について、以下の場合は NA と出力します。
区画を区別する方法が存在しない場合
区画を区別する方法が複数存在する場合
Input
複数のデータセットの並びが入力として与えられます。入力の終わりはゼロが３つの行で示されます。各データセットは以下の形式で与えられます。
X
Y
n
b
1
k
1
b
2
k
2
:
b
n
k
n
s
11
s
21
...
s
X1
s
12
s
22
...
s
X2
:
s
1Y
s
2Y
...
s
XY
1 行目に
X, Y, n
(1 ≤
X, Y
≤ 10, 1 ≤
n
≤ 15) が与えられます。続く
n
行にメモの
i
行目に書かれた情報
b
i
(1 ≤
b
i
≤
n
),
k
i
(1 ≤
k
i
≤ 100) が与えられます。
続く
Y
行に区画情報の
i
行目の情報
s
ij
が与えられます。
s
ij
は
i
行目の左から
j
番目の区画の看板情報を表します。看板の情報
s
ij
として、その区画に看板が無い場合は 0 、看板がある場合はその区画の購入者番号が与えられます。
データセットの数は 50  を超えません。
Output
入力データセットごとに、購入者情報またはNA を出力します。
Sample Input
5 4 6
1 6
2 4
3 3
4 4
5 1
6 2
0 0 1 0 0
0 0 0 2 0
0 0 0 3 0
0 4 5 0 6
3 3 1
1 9
0 0 1
0 0 0
0 0 0
4 4 4
1 6
2 2
3 4
4 4
0 1 0 0
0 0 0 2
0 0 3 0
0 4 0 0
0 0 0
Output for the Sample Input
1 1 1 2 2
1 1 1 2 2
4 4 3 3 3
4 4 5 6 6
1 1 1
1 1 1
1 1 1
NA",C,"#include <stdio.h>
#include <string.h>

int X, Y, n;
int b[16], k[16];
int s[11][11];
int grid[11][11];
int solutions;

int isValidRectangle(int buyer, int x1, int y1, int x2, int y2) {
    int count = 0;
    int hasSign = 0;
    
    for (int i = x1; i <= x2; i++) {
        for (int j = y1; j <= y2; j++) {
            if (grid[i][j] != 0) return 0;
            count++;
            if (s[i][j] == buyer) hasSign = 1;
        }
    }
    
    if (count != k[buyer] || !hasSign) return 0;
    return 1;
}

void fillRectangle(int x1, int y1, int x2, int y2, int buyer) {
    for (int i = x1; i <= x2; i++) {
        for (int j = y1; j <= y2; j++) {
            grid[i][j] = buyer;
        }
    }
}

void clearRectangle(int x1, int y1, int x2, int y2) {
    for (int i = x1; i <= x2; i++) {
        for (int j = y1; j <= y2; j++) {
            grid[i][j] = 0;
        }
    }
}

void solve(int buyer) {
    if (solutions > 1) return;
    
    if (buyer > n) {
        solutions++;
        return;
    }
    
    for (int x1 = 1; x1 <= X; x1++) {
        for (int y1 = 1; y1 <= Y; y1++) {
            for (int x2 = x1; x2 <= X; x2++) {
                for (int y2 = y1; y2 <= Y; y2++) {
                    if (isValidRectangle(buyer, x1, y1, x2, y2)) {
                        fillRectangle(x1, y1, x2, y2, buyer);
                        solve(buyer + 1);
                        if (solutions > 1) {
                            clearRectangle(x1, y1, x2, y2);
                            return;
                        }
                        clearRectangle(x1, y1, x2, y2);
                    }
                }
            }
        }
    }
}

int main() {
    while (1) {
        scanf(""%d %d %d"", &X, &Y, &n);
        if (X == 0 && Y == 0 && n == 0) break;
        
        for (int i = 1; i <= n; i++) {
            scanf(""%d %d"", &b[i], &k[i]);
        }
        
        for (int j = 1; j <= Y; j++) {
            for (int i = 1; i <= X; i++) {
                scanf(""%d"", &s[i][j]);
            }
        }
        
        memset(grid, 0, sizeof(grid));
        solutions = 0;
        solve(1);
        
        if (solutions == 1) {
            for (int j = 1; j <= Y; j++) {
                for (int i = 1; i <= X; i++) {
                    if (i > 1) printf("" "");
                    printf(""%d"", grid[i][j]);
                }
                printf(""\n"");
            }
        } else {
            printf(""NA\n"");
        }
    }
    
    return 0;
}
",0
p00213,">土地分割
ハウジングメーカーの山田ハウスは、新たな目玉商品として、学校や病院など環境が充実している緑ホームタウンの分譲地を売り出しました。この分譲地は複数の区画に分割されており、好きなだけ購入できますが、購入する区画を合わせた土地の形状は長方形(正方形を含む)でなければなりません。
山田ハウスは、全区画が完売した分譲地を管理するため購入者ごとに境界線を引き、その区画の 1つに購入者番号を書いた看板を設置しておきました。境界線は地面に木の枝で線を引いただけのものであったため、数日後の豪雨により消えてしまい看板だけが残りました。図 1 は看板のあった区画に、その区画を買った購入者番号を記したものです。これでは分譲地がどのように買われたか分かりません。救いは事務所の引き出しにあった購入者番号
b
と購入区画数
k
のメモ(図 2)が見つかったことです。
図１（左）：看板の配置、図2（右）：メモ
プログラマーであるあなたは、プログラムを書いて山田ハウスを助けることになりました。分譲地の大きさ
X × Y
、購入者数
n
、メモの情報
b
、
k
、及び看板の位置情報
s
を入力とし、図 3 に示すように各区画の購入者を出力するプログラムを作成してください。
図3：各区画の購入者
与えられた情報について、以下の場合は NA と出力します。
区画を区別する方法が存在しない場合
区画を区別する方法が複数存在する場合
Input
複数のデータセットの並びが入力として与えられます。入力の終わりはゼロが３つの行で示されます。各データセットは以下の形式で与えられます。
X
Y
n
b
1
k
1
b
2
k
2
:
b
n
k
n
s
11
s
21
...
s
X1
s
12
s
22
...
s
X2
:
s
1Y
s
2Y
...
s
XY
1 行目に
X, Y, n
(1 ≤
X, Y
≤ 10, 1 ≤
n
≤ 15) が与えられます。続く
n
行にメモの
i
行目に書かれた情報
b
i
(1 ≤
b
i
≤
n
),
k
i
(1 ≤
k
i
≤ 100) が与えられます。
続く
Y
行に区画情報の
i
行目の情報
s
ij
が与えられます。
s
ij
は
i
行目の左から
j
番目の区画の看板情報を表します。看板の情報
s
ij
として、その区画に看板が無い場合は 0 、看板がある場合はその区画の購入者番号が与えられます。
データセットの数は 50  を超えません。
Output
入力データセットごとに、購入者情報またはNA を出力します。
Sample Input
5 4 6
1 6
2 4
3 3
4 4
5 1
6 2
0 0 1 0 0
0 0 0 2 0
0 0 0 3 0
0 4 5 0 6
3 3 1
1 9
0 0 1
0 0 0
0 0 0
4 4 4
1 6
2 2
3 4
4 4
0 1 0 0
0 0 0 2
0 0 3 0
0 4 0 0
0 0 0
Output for the Sample Input
1 1 1 2 2
1 1 1 2 2
4 4 3 3 3
4 4 5 6 6
1 1 1
1 1 1
1 1 1
NA",C,"// Aizu 0213: Subdivide The Land
// 2017.9.24 bal4u@uu

#include <stdio.h>
#include <stdlib.h>
#include <string.h>

typedef struct { int id, x, y, k; } T;
T tbl[16]; 
int X, Y, n;
char map[10][10];
char ans[10][10], cnt;
int pair[101][13][2], plen[101];

int cmp(T *a, T *b) { if (a->y - b->y) return a->y - b->y; return a->x - b->x; }

void mark(int c, int x, int y, int w, int h)
{
	int yy;
	for (yy = 0; yy < h; yy++) memset(map[y+yy]+x, c, w);
}

int check(int c, int x, int y, int w, int h)
{
	int xx, yy;
	for (yy = 0; yy < h; yy++) for (xx = 0; xx < w; xx++) 
		if (map[y+yy][x+xx] > 0 && map[y+yy][x+xx] != c) return 0;
	return 1;
}

int combi(int i)
{
	int x, y, x0, y0, id, x1, y1, h, w, j, k;

	if (i == n+1) {
		if (cnt) return 0;
		cnt = 1, memcpy(ans, map, sizeof(map));
		return 1;
	}
	k = tbl[i].k;
	if (k == 1) return combi(i+1);
	x0 = tbl[i].x, y0 = tbl[i].y, id = tbl[i].id;

	for (j = 0; j < plen[k]; j++) {
		w = pair[k][j][0], h = pair[k][j][1];
		x1 = x0 - w + 1, y1 = y0 - h + 1;
		if (x1 < 0) x1 = 0; if (y1 < 0) y1 = 0;
		for (y = y1; y <= y0; y++) for (x = x1; x <= x0; x++) {
			if (x + w > X || y + h > Y) goto Next;
			if (!check(id, x, y, w, h)) continue;
			mark(id, x, y, w, h);
			if (!combi(i+1)) return 0;
			mark(0, x, y, w, h);
		}
Next:;
	}
	return 1;
}

int main()
{
    int i, b, t, s, x, y;

	for (x = 1; x <= 100; x++) for (y = 1; y <= 100; y++)
		if ((t = x * y) <= 100) pair[t][plen[t]][0] = x, pair[t][plen[t]++][1] = y;

	while (scanf(""%d%d%d"", &X, &Y, &n) && n > 0) {
		for (s = i = 0; i < n; i++) {
			scanf(""%d%d"", &b, &t);
			tbl[b].k = t, tbl[b].id = b;
			s += t;
		}
		for (y = 0; y < Y; y++) for (x = 0; x < X; x++) {
			scanf(""%d"", &b), map[y][x] = b;
			if (b > 0) tbl[b].x = x, tbl[b].y = y;
		}
		if (s != X*Y) { puts(""NA""); continue; }
		qsort(tbl+1, n, sizeof(T), cmp);

		cnt = 0;
		if (!combi(1)) puts(""NA"");
		else for (y = 0; y < Y; y++) {
			printf(""%d"", ans[y][0]);
			for (x = 1; x < X; x++) printf("" %d"", ans[y][x]);
			printf(""\n"");
		}
	}
	return 0;
}",1
p00213,">土地分割
ハウジングメーカーの山田ハウスは、新たな目玉商品として、学校や病院など環境が充実している緑ホームタウンの分譲地を売り出しました。この分譲地は複数の区画に分割されており、好きなだけ購入できますが、購入する区画を合わせた土地の形状は長方形(正方形を含む)でなければなりません。
山田ハウスは、全区画が完売した分譲地を管理するため購入者ごとに境界線を引き、その区画の 1つに購入者番号を書いた看板を設置しておきました。境界線は地面に木の枝で線を引いただけのものであったため、数日後の豪雨により消えてしまい看板だけが残りました。図 1 は看板のあった区画に、その区画を買った購入者番号を記したものです。これでは分譲地がどのように買われたか分かりません。救いは事務所の引き出しにあった購入者番号
b
と購入区画数
k
のメモ(図 2)が見つかったことです。
図１（左）：看板の配置、図2（右）：メモ
プログラマーであるあなたは、プログラムを書いて山田ハウスを助けることになりました。分譲地の大きさ
X × Y
、購入者数
n
、メモの情報
b
、
k
、及び看板の位置情報
s
を入力とし、図 3 に示すように各区画の購入者を出力するプログラムを作成してください。
図3：各区画の購入者
与えられた情報について、以下の場合は NA と出力します。
区画を区別する方法が存在しない場合
区画を区別する方法が複数存在する場合
Input
複数のデータセットの並びが入力として与えられます。入力の終わりはゼロが３つの行で示されます。各データセットは以下の形式で与えられます。
X
Y
n
b
1
k
1
b
2
k
2
:
b
n
k
n
s
11
s
21
...
s
X1
s
12
s
22
...
s
X2
:
s
1Y
s
2Y
...
s
XY
1 行目に
X, Y, n
(1 ≤
X, Y
≤ 10, 1 ≤
n
≤ 15) が与えられます。続く
n
行にメモの
i
行目に書かれた情報
b
i
(1 ≤
b
i
≤
n
),
k
i
(1 ≤
k
i
≤ 100) が与えられます。
続く
Y
行に区画情報の
i
行目の情報
s
ij
が与えられます。
s
ij
は
i
行目の左から
j
番目の区画の看板情報を表します。看板の情報
s
ij
として、その区画に看板が無い場合は 0 、看板がある場合はその区画の購入者番号が与えられます。
データセットの数は 50  を超えません。
Output
入力データセットごとに、購入者情報またはNA を出力します。
Sample Input
5 4 6
1 6
2 4
3 3
4 4
5 1
6 2
0 0 1 0 0
0 0 0 2 0
0 0 0 3 0
0 4 5 0 6
3 3 1
1 9
0 0 1
0 0 0
0 0 0
4 4 4
1 6
2 2
3 4
4 4
0 1 0 0
0 0 0 2
0 0 3 0
0 4 0 0
0 0 0
Output for the Sample Input
1 1 1 2 2
1 1 1 2 2
4 4 3 3 3
4 4 5 6 6
1 1 1
1 1 1
1 1 1
NA",Java,"import java.util.*;

public class Main {
    static int X, Y, n;
    static int[] buyers;
    static int[] counts;
    static int[][] signs;
    static List<int[][]> validSolutions;
    
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        
        while (true) {
            X = sc.nextInt();
            Y = sc.nextInt();
            n = sc.nextInt();
            
            if (X == 0 && Y == 0 && n == 0) break;
            
            buyers = new int[n];
            counts = new int[n];
            
            for (int i = 0; i < n; i++) {
                buyers[i] = sc.nextInt();
                counts[i] = sc.nextInt();
            }
            
            signs = new int[Y][X];
            for (int i = 0; i < Y; i++) {
                for (int j = 0; j < X; j++) {
                    signs[i][j] = sc.nextInt();
                }
            }
            
            validSolutions = new ArrayList<>();
            int[][] grid = new int[Y][X];
            boolean[] used = new boolean[n];
            
            backtrack(grid, used, 0);
            
            if (validSolutions.size() == 0) {
                System.out.println(""NA"");
            } else if (validSolutions.size() > 1) {
                System.out.println(""NA"");
            } else {
                int[][] sol = validSolutions.get(0);
                for (int i = 0; i < Y; i++) {
                    for (int j = 0; j < X; j++) {
                        if (j > 0) System.out.print("" "");
                        System.out.print(sol[i][j]);
                    }
                    System.out.println();
                }
            }
        }
    }
    
    static void backtrack(int[][] grid, boolean[] used, int buyerIdx) {
        if (buyerIdx == n) {
            if (isValidComplete(grid)) {
                int[][] copy = new int[Y][X];
                for (int i = 0; i < Y; i++) {
                    for (int j = 0; j < X; j++) {
                        copy[i][j] = grid[i][j];
                    }
                }
                validSolutions.add(copy);
            }
            return;
        }
        
        if (validSolutions.size() > 1) return;
        
        int buyer = -1;
        for (int i = 0; i < n; i++) {
            if (!used[i]) {
                buyer = i;
                break;
            }
        }
        
        if (buyer == -1) return;
        
        int buyerNum = buyers[buyer];
        int count = counts[buyer];
        
        for (int y1 = 0; y1 < Y; y1++) {
            for (int x1 = 0; x1 < X; x1++) {
                for (int y2 = y1; y2 < Y; y2++) {
                    for (int x2 = x1; x2 < X; x2++) {
                        int w = x2 - x1 + 1;
                        int h = y2 - y1 + 1;
                        if (w * h != count) continue;
                        
                        if (canPlace(grid, x1, y1, x2, y2, buyerNum)) {
                            place(grid, x1, y1, x2, y2, buyerNum);
                            used[buyer] = true;
                            backtrack(grid, used, buyerIdx + 1);
                            used[buyer] = false;
                            place(grid, x1, y1, x2, y2, 0);
                            
                            if (validSolutions.size() > 1) return;
                        }
                    }
                }
            }
        }
    }
    
    static boolean canPlace(int[][] grid, int x1, int y1, int x2, int y2, int buyerNum) {
        boolean hasSign = false;
        for (int y = y1; y <= y2; y++) {
            for (int x = x1; x <= x2; x++) {
                if (grid[y][x] != 0) return false;
                if (signs[y][x] != 0) {
                    if (signs[y][x] != buyerNum) return false;
                    hasSign = true;
                }
            }
        }
        return hasSign;
    }
    
    static void place(int[][] grid, int x1, int y1, int x2, int y2, int buyerNum) {
        for (int y = y1; y <= y2; y++) {
            for (int x = x1; x <= x2; x++) {
                grid[y][x] = buyerNum;
            }
        }
    }
    
    static boolean isValidComplete(int[][] grid) {
        for (int i = 0; i < Y; i++) {
            for (int j = 0; j < X; j++) {
                if (grid[i][j] == 0) return false;
            }
        }
        return true;
    }
}
",0
p00213,">土地分割
ハウジングメーカーの山田ハウスは、新たな目玉商品として、学校や病院など環境が充実している緑ホームタウンの分譲地を売り出しました。この分譲地は複数の区画に分割されており、好きなだけ購入できますが、購入する区画を合わせた土地の形状は長方形(正方形を含む)でなければなりません。
山田ハウスは、全区画が完売した分譲地を管理するため購入者ごとに境界線を引き、その区画の 1つに購入者番号を書いた看板を設置しておきました。境界線は地面に木の枝で線を引いただけのものであったため、数日後の豪雨により消えてしまい看板だけが残りました。図 1 は看板のあった区画に、その区画を買った購入者番号を記したものです。これでは分譲地がどのように買われたか分かりません。救いは事務所の引き出しにあった購入者番号
b
と購入区画数
k
のメモ(図 2)が見つかったことです。
図１（左）：看板の配置、図2（右）：メモ
プログラマーであるあなたは、プログラムを書いて山田ハウスを助けることになりました。分譲地の大きさ
X × Y
、購入者数
n
、メモの情報
b
、
k
、及び看板の位置情報
s
を入力とし、図 3 に示すように各区画の購入者を出力するプログラムを作成してください。
図3：各区画の購入者
与えられた情報について、以下の場合は NA と出力します。
区画を区別する方法が存在しない場合
区画を区別する方法が複数存在する場合
Input
複数のデータセットの並びが入力として与えられます。入力の終わりはゼロが３つの行で示されます。各データセットは以下の形式で与えられます。
X
Y
n
b
1
k
1
b
2
k
2
:
b
n
k
n
s
11
s
21
...
s
X1
s
12
s
22
...
s
X2
:
s
1Y
s
2Y
...
s
XY
1 行目に
X, Y, n
(1 ≤
X, Y
≤ 10, 1 ≤
n
≤ 15) が与えられます。続く
n
行にメモの
i
行目に書かれた情報
b
i
(1 ≤
b
i
≤
n
),
k
i
(1 ≤
k
i
≤ 100) が与えられます。
続く
Y
行に区画情報の
i
行目の情報
s
ij
が与えられます。
s
ij
は
i
行目の左から
j
番目の区画の看板情報を表します。看板の情報
s
ij
として、その区画に看板が無い場合は 0 、看板がある場合はその区画の購入者番号が与えられます。
データセットの数は 50  を超えません。
Output
入力データセットごとに、購入者情報またはNA を出力します。
Sample Input
5 4 6
1 6
2 4
3 3
4 4
5 1
6 2
0 0 1 0 0
0 0 0 2 0
0 0 0 3 0
0 4 5 0 6
3 3 1
1 9
0 0 1
0 0 0
0 0 0
4 4 4
1 6
2 2
3 4
4 4
0 1 0 0
0 0 0 2
0 0 3 0
0 4 0 0
0 0 0
Output for the Sample Input
1 1 1 2 2
1 1 1 2 2
4 4 3 3 3
4 4 5 6 6
1 1 1
1 1 1
1 1 1
NA",Java,"
import java.io.IOException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import java.util.PriorityQueue;
import java.util.Scanner;

import scala.languageFeature.postfixOps;
import sun.tools.jar.resources.jar;
import lombok.Data;

public class Main {

	public static void main(String[] args) throws IOException {
		new Main().run();
	}

	private void run() throws IOException {
		Scanner scanner = new Scanner(System.in);
		while (true) {
			w = scanner.nextInt();
			h = scanner.nextInt();
			n = scanner.nextInt();
			if ((w | h | n) == 0)
				break;
			size = new int[n + 1];
			pos = new int[n + 1][2];
			for (int i = 0; i < n; i++) {
				int b = scanner.nextInt();
				int k = scanner.nextInt();
				size[b] = k;
			}
			m = new int[h][w];
			
			for (int[] a : m)
				Arrays.fill(a, -1);
			for (int i = 0; i < h; i++) {
				for (int j = 0; j < w; j++) {
					int x = scanner.nextInt();
					m[i][j] = x;
					if (x > 0) {
						pos[x][0] = i;
						pos[x][1] = j;
					}
				}
			}
			assign = new int[n + 1][4];
			c = 0;
			ans = new int[h][w];
			f(1);
			if (c == 1) {
				for (int i = 0; i < h; i++) {
					for (int j = 0; j < w; j++) {
						if (j > 0)
							System.out.print("" "");
						System.out.print(ans[i][j]);
					}
					System.out.println();
				}
			} else {
				System.out.println(""NA"");
			}

		}
	}

	private void f(int k) {
		if (k == n + 1) {
			c++;
			if (c == 2)
				return;
			for (int i = 0; i < h; i++) {
				for (int j = 0; j < w; j++) {
					int a = m[i][j];
					ans[i][j] = a >= 100 ? a / 100 : a;
				}
			}
			return;
		}
		int s = size[k];
		for (int x = 1; x <= s; x++) {
			if (s % x != 0)
				continue;
			for (int lj = pos[k][1] + 1 - x; lj <= pos[k][1]; lj++) {
				if (lj < 0 || lj > w)
					continue;
				loop: for (int li = pos[k][0] + 1 - s / x; li <= pos[k][0]; li++) {
					if (li < 0 || li > h)
						continue;
					int rj = lj + x;
					int ri = li + s / x;
					if (rj > w)
						continue;
					if (ri > h)
						continue;
					for (int i = li; i < ri; i++) {
						for (int j = lj; j < rj; j++) {
							if (m[i][j] != 0 && m[i][j] != k)
								continue loop;

						}
					}
					for (int i = li; i < ri; i++) {
						for (int j = lj; j < rj; j++) {
							if (m[i][j] != k)
								m[i][j] = k * 100;
						}
					}
					f(k + 1);
					if (c == 2)
						return;
					for (int i = li; i < ri; i++) {
						for (int j = lj; j < rj; j++) {
							if (m[i][j] != k)
								m[i][j] = 0;
						}
					}
				}
			}

		}

	}

	int[][] m;
	int[] size;
	int[][] pos;
	int[][] assign;
	int w, h, n, c;
	int[][] ans;
}",1
p00213,">土地分割
ハウジングメーカーの山田ハウスは、新たな目玉商品として、学校や病院など環境が充実している緑ホームタウンの分譲地を売り出しました。この分譲地は複数の区画に分割されており、好きなだけ購入できますが、購入する区画を合わせた土地の形状は長方形(正方形を含む)でなければなりません。
山田ハウスは、全区画が完売した分譲地を管理するため購入者ごとに境界線を引き、その区画の 1つに購入者番号を書いた看板を設置しておきました。境界線は地面に木の枝で線を引いただけのものであったため、数日後の豪雨により消えてしまい看板だけが残りました。図 1 は看板のあった区画に、その区画を買った購入者番号を記したものです。これでは分譲地がどのように買われたか分かりません。救いは事務所の引き出しにあった購入者番号
b
と購入区画数
k
のメモ(図 2)が見つかったことです。
図１（左）：看板の配置、図2（右）：メモ
プログラマーであるあなたは、プログラムを書いて山田ハウスを助けることになりました。分譲地の大きさ
X × Y
、購入者数
n
、メモの情報
b
、
k
、及び看板の位置情報
s
を入力とし、図 3 に示すように各区画の購入者を出力するプログラムを作成してください。
図3：各区画の購入者
与えられた情報について、以下の場合は NA と出力します。
区画を区別する方法が存在しない場合
区画を区別する方法が複数存在する場合
Input
複数のデータセットの並びが入力として与えられます。入力の終わりはゼロが３つの行で示されます。各データセットは以下の形式で与えられます。
X
Y
n
b
1
k
1
b
2
k
2
:
b
n
k
n
s
11
s
21
...
s
X1
s
12
s
22
...
s
X2
:
s
1Y
s
2Y
...
s
XY
1 行目に
X, Y, n
(1 ≤
X, Y
≤ 10, 1 ≤
n
≤ 15) が与えられます。続く
n
行にメモの
i
行目に書かれた情報
b
i
(1 ≤
b
i
≤
n
),
k
i
(1 ≤
k
i
≤ 100) が与えられます。
続く
Y
行に区画情報の
i
行目の情報
s
ij
が与えられます。
s
ij
は
i
行目の左から
j
番目の区画の看板情報を表します。看板の情報
s
ij
として、その区画に看板が無い場合は 0 、看板がある場合はその区画の購入者番号が与えられます。
データセットの数は 50  を超えません。
Output
入力データセットごとに、購入者情報またはNA を出力します。
Sample Input
5 4 6
1 6
2 4
3 3
4 4
5 1
6 2
0 0 1 0 0
0 0 0 2 0
0 0 0 3 0
0 4 5 0 6
3 3 1
1 9
0 0 1
0 0 0
0 0 0
4 4 4
1 6
2 2
3 4
4 4
0 1 0 0
0 0 0 2
0 0 3 0
0 4 0 0
0 0 0
Output for the Sample Input
1 1 1 2 2
1 1 1 2 2
4 4 3 3 3
4 4 5 6 6
1 1 1
1 1 1
1 1 1
NA",Python,"import sys
from itertools import product

def read_input():
    datasets = []
    lines = sys.stdin.read().strip().split('\n')
    i = 0
    while i < len(lines):
        parts = lines[i].split()
        X, Y, n = int(parts[0]), int(parts[1]), int(parts[2])
        if X == 0 and Y == 0 and n == 0:
            break
        
        i += 1
        memo = []
        for _ in range(n):
            b, k = map(int, lines[i].split())
            memo.append((b, k))
            i += 1
        
        signs = []
        for _ in range(Y):
            row = list(map(int, lines[i].split()))
            signs.append(row)
            i += 1
        
        datasets.append((X, Y, n, memo, signs))
    
    return datasets

def get_all_rectangles(X, Y):
    rectangles = []
    for x1 in range(X):
        for y1 in range(Y):
            for x2 in range(x1, X):
                for y2 in range(y1, Y):
                    rectangles.append((x1, y1, x2, y2))
    return rectangles

def solve(X, Y, n, memo, signs):
    rectangles = get_all_rectangles(X, Y)
    
    # Group rectangles by size
    size_to_rects = {}
    for rect in rectangles:
        x1, y1, x2, y2 = rect
        size = (x2 - x1 + 1) * (y2 - y1 + 1)
        if size not in size_to_rects:
            size_to_rects[size] = []
        size_to_rects[size].append(rect)
    
    # For each buyer, get possible rectangles
    buyer_rects = {}
    for b, k in memo:
        if k in size_to_rects:
            buyer_rects[b] = size_to_rects[k]
        else:
            return ""NA""
    
    # Try all combinations
    def check_assignment(assignment):
        grid = [[0] * Y for _ in range(X)]
        
        for buyer, rect in assignment.items():
            x1, y1, x2, y2 = rect
            for x in range(x1, x2 + 1):
                for y in range(y1, y2 + 1):
                    if grid[x][y] != 0:
                        return None
                    grid[x][y] = buyer
        
        # Check if signs match
        for x in range(X):
            for y in range(Y):
                if signs[y][x] != 0:
                    if grid[x][y] != signs[y][x]:
                        return None
        
        return grid
    
    valid_grids = []
    
    def backtrack(buyers, assignment):
        if not buyers:
            grid = check_assignment(assignment)
            if grid:
                valid_grids.append(grid)
            return
        
        buyer = buyers[0]
        for rect in buyer_rects[buyer]:
            assignment[buyer] = rect
            backtrack(buyers[1:], assignment)
            del assignment[buyer]
    
    buyers = [b for b, k in memo]
    backtrack(buyers, {})
    
    if len(valid_grids) == 0:
        return ""NA""
    elif len(valid_grids) == 1:
        grid = valid_grids[0]
        result = []
        for y in range(Y):
            row = []
            for x in range(X):
                row.append(str(grid[x][y]))
            result.append(' '.join(row))
        return '\n'.join(result)
    else:
        return ""NA""

datasets = read_input()
for X, Y, n, memo, signs in datasets:
    result = solve(X, Y, n, memo, signs)
    print(result)
",0
p00213,">土地分割
ハウジングメーカーの山田ハウスは、新たな目玉商品として、学校や病院など環境が充実している緑ホームタウンの分譲地を売り出しました。この分譲地は複数の区画に分割されており、好きなだけ購入できますが、購入する区画を合わせた土地の形状は長方形(正方形を含む)でなければなりません。
山田ハウスは、全区画が完売した分譲地を管理するため購入者ごとに境界線を引き、その区画の 1つに購入者番号を書いた看板を設置しておきました。境界線は地面に木の枝で線を引いただけのものであったため、数日後の豪雨により消えてしまい看板だけが残りました。図 1 は看板のあった区画に、その区画を買った購入者番号を記したものです。これでは分譲地がどのように買われたか分かりません。救いは事務所の引き出しにあった購入者番号
b
と購入区画数
k
のメモ(図 2)が見つかったことです。
図１（左）：看板の配置、図2（右）：メモ
プログラマーであるあなたは、プログラムを書いて山田ハウスを助けることになりました。分譲地の大きさ
X × Y
、購入者数
n
、メモの情報
b
、
k
、及び看板の位置情報
s
を入力とし、図 3 に示すように各区画の購入者を出力するプログラムを作成してください。
図3：各区画の購入者
与えられた情報について、以下の場合は NA と出力します。
区画を区別する方法が存在しない場合
区画を区別する方法が複数存在する場合
Input
複数のデータセットの並びが入力として与えられます。入力の終わりはゼロが３つの行で示されます。各データセットは以下の形式で与えられます。
X
Y
n
b
1
k
1
b
2
k
2
:
b
n
k
n
s
11
s
21
...
s
X1
s
12
s
22
...
s
X2
:
s
1Y
s
2Y
...
s
XY
1 行目に
X, Y, n
(1 ≤
X, Y
≤ 10, 1 ≤
n
≤ 15) が与えられます。続く
n
行にメモの
i
行目に書かれた情報
b
i
(1 ≤
b
i
≤
n
),
k
i
(1 ≤
k
i
≤ 100) が与えられます。
続く
Y
行に区画情報の
i
行目の情報
s
ij
が与えられます。
s
ij
は
i
行目の左から
j
番目の区画の看板情報を表します。看板の情報
s
ij
として、その区画に看板が無い場合は 0 、看板がある場合はその区画の購入者番号が与えられます。
データセットの数は 50  を超えません。
Output
入力データセットごとに、購入者情報またはNA を出力します。
Sample Input
5 4 6
1 6
2 4
3 3
4 4
5 1
6 2
0 0 1 0 0
0 0 0 2 0
0 0 0 3 0
0 4 5 0 6
3 3 1
1 9
0 0 1
0 0 0
0 0 0
4 4 4
1 6
2 2
3 4
4 4
0 1 0 0
0 0 0 2
0 0 3 0
0 4 0 0
0 0 0
Output for the Sample Input
1 1 1 2 2
1 1 1 2 2
4 4 3 3 3
4 4 5 6 6
1 1 1
1 1 1
1 1 1
NA",Python,"import copy

def main(land, b):
    for h in range(H):
        for w in range(W):
            if land[h][w] == b:
                if f1(land, h, w, b, data[land[h][w]]):
                    return
            
def f1(land, h, w, b, k):
    for q in range(1, k+1):
        if k%q == 0:
            if f2(land, h, w, q, k/q, b):
                return True
    else:
        return
        
def f2(land, h, w, r, c, b):
    for _h in range(r):
        for _w in range(c):
            if 0 <= h-_h and 0 <= w-_w:
                if f3(land, h-_h, w-_w, r, c, b):
                    return True
    else:
        return
                
def f3(land, h, w, r, c, b):
    _land = copy.deepcopy(land)
    for _h in range(r):
        for _w in range(c):
            if 0 <= h+_h <= H-1 and 0 <= w+_w <= W-1:
                if _land[h+_h][w+_w] == 0 or _land[h+_h][w+_w] == b:
                    _land[h+_h][w+_w] = b
                else:
                    return
            else:
                return
    else:
        if b < n:
            return main(_land, b+1)
        else:
            for line in _land:
                print ' '.join(map(str, line))
            return True

while True:
    W, H, n = map(int, raw_input().split())
    if H == W == n == 0: break
    data = {}
    for i in range(n):
        b, k = map(int, raw_input().split())
        data[b] = k
    land = [map(int, raw_input().split()) for i in range(H)]
    main(land, 1)",1
p00214,"秋のイルミネーション
四角形が大好きな人が多く住む四角町では、四角形の電光板を組み合わせたイルミネーションで町中を彩るお祭りが開催されます。
この電光板は電気を流すと発光し、発光している板に接している板も発光します。したがって、電光板を何枚使っても、すべてがひとかたまりに接していれば電源がひとつで済むという優れものです。
お祭り実行委員会では、四角形を組み合わせたデザインを町民から募集し多数のイルミネーションを作成します。各イルミネーションは、デザインを構成する四角形の配置によって必要となる電源の個数が変わるため、必要な電源の個数を把握する作業に
大きな手間がかかります。
そこで、
あなたは四角形の配置を調べ、必要な電源の個数を計算するプログラムを作成して実行委員会を手助けすることにしました。
イルミネーションの個数、各イルミネーションを構成する四角形の情報を入力とし、イルミネーションごとに必要な電源の個数を出力するプログラムを作成してください。重なっていたり接していたりする四角形を 1 つのまとまりと考え、1 つのまとまりに対して電源の個数は 1 つと数えてください。
Input
複数のデータセットの並びが入力として与えられます。入力の終わりはゼロひとつの行で示されます。各データセットは以下の形式で与えられます。
N
M
1
xa
1
ya
1
xb
1
yb
1
xc
1
yc
1
xd
1
yd
1
xa
2
ya
2
xb
2
yb
2
xc
2
yc
2
xd
2
yd
2
:
xa
M
1
ya
M
1
xb
M
1
yb
M
1
xc
M
1
yc
M
1
xd
M
1
yd
M
1
M
2
:
:
M
N
:
:
1 行目にイルミネーションの個数
N
(1 ≤
N
≤ 100) が与えられます。続いて、
N
個のイルミネーションの情報が与えられます。第
i
のイルミネーションの情報として、イルミネーションを構成する四角形の個数
M
i
(1 ≤
M
i
≤ 100) が１行に与えられます。続く
M
i
行に
j
個目の四角形の頂点
xa
j
,
ya
j
,
xb
j
,
yb
j
,
xc
j
,
yc
j
,
xd
j
,
yd
j
(-1000 以上 1000 以下の整数) が与えられます。
入力される四角形の頂点座標は、時計回りの順に従って入力されます。ただし、入力データの四角形はすべて凸な四角形とします。
データセットの数は 10 を超えません。
Output
入力データセットごとに、イルミネーションごとに必要な電源の個数を出力します。出力する電源の個数は各イルミネーションが入力された順番に従ってください。
Sample Input
3
1
0 0 0 1 1 1 1 0
2
0 0 0 1 1 1 1 0
100 100 100 200 200 200 200 100
2
0 0 0 100 100 100 100 0
10 10 10 20 20 20 20 10
2
1
30 40 40 50 40 20 20 10
1
30 40 40 50 40 20 20 10
0
Output for the Sample Input
1
2
1
1
1",C,"#include <stdio.h>
#include <stdlib.h>
#include <stdbool.h>

typedef struct {
    int x, y;
} Point;

typedef struct {
    Point vertices[4];
} Rectangle;

bool segmentsIntersect(Point p1, Point q1, Point p2, Point q2) {
    int d1 = (q1.x - p1.x) * (p2.y - p1.y) - (q1.y - p1.y) * (p2.x - p1.x);
    int d2 = (q1.x - p1.x) * (q2.y - p1.y) - (q1.y - p1.y) * (q2.x - p1.x);
    int d3 = (q2.x - p2.x) * (p1.y - p2.y) - (q2.y - p2.y) * (p1.x - p2.x);
    int d4 = (q2.x - p2.x) * (q1.y - p2.y) - (q2.y - p2.y) * (q1.x - p2.x);
    
    if (((d1 > 0 && d2 < 0) || (d1 < 0 && d2 > 0)) &&
        ((d3 > 0 && d4 < 0) || (d3 < 0 && d4 > 0))) {
        return true;
    }
    
    return false;
}

bool pointOnSegment(Point p, Point q, Point r) {
    if (q.x <= (p.x > r.x ? p.x : r.x) && q.x >= (p.x < r.x ? p.x : r.x) &&
        q.y <= (p.y > r.y ? p.y : r.y) && q.y >= (p.y < r.y ? p.y : r.y))
        return true;
    return false;
}

bool segmentsTouchOrIntersect(Point p1, Point q1, Point p2, Point q2) {
    long long d1 = (long long)(q1.x - p1.x) * (p2.y - p1.y) - (long long)(q1.y - p1.y) * (p2.x - p1.x);
    long long d2 = (long long)(q1.x - p1.x) * (q2.y - p1.y) - (long long)(q1.y - p1.y) * (q2.x - p1.x);
    long long d3 = (long long)(q2.x - p2.x) * (p1.y - p2.y) - (long long)(q2.y - p2.y) * (p1.x - p2.x);
    long long d4 = (long long)(q2.x - p2.x) * (q1.y - p2.y) - (long long)(q2.y - p2.y) * (q1.x - p2.x);
    
    if (((d1 > 0 && d2 < 0) || (d1 < 0 && d2 > 0)) &&
        ((d3 > 0 && d4 < 0) || (d3 < 0 && d4 > 0))) {
        return true;
    }
    
    if (d1 == 0 && pointOnSegment(p1, p2, q1)) return true;
    if (d2 == 0 && pointOnSegment(p1, q2, q1)) return true;
    if (d3 == 0 && pointOnSegment(p2, p1, q2)) return true;
    if (d4 == 0 && pointOnSegment(p2, q1, q2)) return true;
    
    return false;
}

bool pointInRectangle(Point p, Rectangle r) {
    int crossings = 0;
    for (int i = 0; i < 4; i++) {
        Point p1 = r.vertices[i];
        Point p2 = r.vertices[(i + 1) % 4];
        
        if ((p1.y <= p.y && p2.y > p.y) || (p1.y > p.y && p2.y <= p.y)) {
            double vt = (double)(p.y - p1.y) / (p2.y - p1.y);
            if (p.x < p1.x + vt * (p2.x - p1.x)) {
                crossings++;
            }
        }
    }
    return (crossings % 2) == 1;
}

bool rectanglesTouchOrOverlap(Rectangle r1, Rectangle r2) {
    for (int i = 0; i < 4; i++) {
        if (pointInRectangle(r1.vertices[i], r2)) return true;
        if (pointInRectangle(r2.vertices[i], r1)) return true;
    }
    
    for (int i = 0; i < 4; i++) {
        for (int j = 0; j < 4; j++) {
            if (segmentsTouchOrIntersect(r1.vertices[i], r1.vertices[(i+1)%4],
                                        r2.vertices[j], r2.vertices[(j+1)%4])) {
                return true;
            }
        }
    }
    
    return false;
}

int find(int parent[], int i) {
    if (parent[i] != i)
        parent[i] = find(parent, parent[i]);
    return parent[i];
}

void unionSet(int parent[], int rank[], int x, int y) {
    int xroot = find(parent, x);
    int yroot = find(parent, y);
    
    if (rank[xroot] < rank[yroot])
        parent[xroot] = yroot;
    else if (rank[xroot] > rank[yroot])
        parent[yroot] = xroot;
    else {
        parent[yroot] = xroot;
        rank[xroot]++;
    }
}

int main() {
    int N;
    
    while (scanf(""%d"", &N) && N != 0) {
        for (int i = 0; i < N; i++) {
            int M;
            scanf(""%d"", &M);
            
            Rectangle rectangles[100];
            for (int j = 0; j < M; j++) {
                for (int k = 0; k < 4; k++) {
                    scanf(""%d %d"", &rectangles[j].vertices[k].x, &rectangles[j].vertices[k].y);
                }
            }
            
            int parent[100], rank[100];
            for (int j = 0; j < M; j++) {
                parent[j] = j;
                rank[j] = 0;
            }
            
            for (int j = 0; j < M; j++) {
                for (int k = j + 1; k < M; k++) {
                    if (rectanglesTouchOrOverlap(rectangles[j], rectangles[k])) {
                        unionSet(parent, rank, j, k);
                    }
                }
            }
            
            int count = 0;
            for (int j = 0; j < M; j++) {
                if (find(parent, j) == j) {
                    count++;
                }
            }
            
            printf(""%d\n"", count);
        }
    }
    
    return 0;
}
",0
p00214,"秋のイルミネーション
四角形が大好きな人が多く住む四角町では、四角形の電光板を組み合わせたイルミネーションで町中を彩るお祭りが開催されます。
この電光板は電気を流すと発光し、発光している板に接している板も発光します。したがって、電光板を何枚使っても、すべてがひとかたまりに接していれば電源がひとつで済むという優れものです。
お祭り実行委員会では、四角形を組み合わせたデザインを町民から募集し多数のイルミネーションを作成します。各イルミネーションは、デザインを構成する四角形の配置によって必要となる電源の個数が変わるため、必要な電源の個数を把握する作業に
大きな手間がかかります。
そこで、
あなたは四角形の配置を調べ、必要な電源の個数を計算するプログラムを作成して実行委員会を手助けすることにしました。
イルミネーションの個数、各イルミネーションを構成する四角形の情報を入力とし、イルミネーションごとに必要な電源の個数を出力するプログラムを作成してください。重なっていたり接していたりする四角形を 1 つのまとまりと考え、1 つのまとまりに対して電源の個数は 1 つと数えてください。
Input
複数のデータセットの並びが入力として与えられます。入力の終わりはゼロひとつの行で示されます。各データセットは以下の形式で与えられます。
N
M
1
xa
1
ya
1
xb
1
yb
1
xc
1
yc
1
xd
1
yd
1
xa
2
ya
2
xb
2
yb
2
xc
2
yc
2
xd
2
yd
2
:
xa
M
1
ya
M
1
xb
M
1
yb
M
1
xc
M
1
yc
M
1
xd
M
1
yd
M
1
M
2
:
:
M
N
:
:
1 行目にイルミネーションの個数
N
(1 ≤
N
≤ 100) が与えられます。続いて、
N
個のイルミネーションの情報が与えられます。第
i
のイルミネーションの情報として、イルミネーションを構成する四角形の個数
M
i
(1 ≤
M
i
≤ 100) が１行に与えられます。続く
M
i
行に
j
個目の四角形の頂点
xa
j
,
ya
j
,
xb
j
,
yb
j
,
xc
j
,
yc
j
,
xd
j
,
yd
j
(-1000 以上 1000 以下の整数) が与えられます。
入力される四角形の頂点座標は、時計回りの順に従って入力されます。ただし、入力データの四角形はすべて凸な四角形とします。
データセットの数は 10 を超えません。
Output
入力データセットごとに、イルミネーションごとに必要な電源の個数を出力します。出力する電源の個数は各イルミネーションが入力された順番に従ってください。
Sample Input
3
1
0 0 0 1 1 1 1 0
2
0 0 0 1 1 1 1 0
100 100 100 200 200 200 200 100
2
0 0 0 100 100 100 100 0
10 10 10 20 20 20 20 10
2
1
30 40 40 50 40 20 20 10
1
30 40 40 50 40 20 20 10
0
Output for the Sample Input
1
2
1
1
1",C,"#include <stdio.h>

long z(long a,long b,long c,long d,long e,long f){
    return (c-a)*(f-b)-(e-a)*(d-b);
}
int x(int (*a)[8],int (*b)[8]){
    int i,j;
    for(i=0;i<4;i++){
        for(j=0;j<4;j++){
            if(z((*a)[j*2],(*a)[j*2+1],(*a)[(j*2+2)%8],(*a)[(j*2+2)%8+1],(*b)[i*2],(*b)[i*2+1])>0)break;
        }
        if(j==4)return 1;
    }
    return 0;
}

int main(){
    int n,m;
    int a[100],l[100][8],b[100];
    int i,j,k;
    int min,ii,jj,kk;
    while(scanf(""%d"",&n)&&n){
        while(n--){
            scanf(""%d"",&m);
            for(i=0;i<m;i++){
                a[i]=i;
                for(j=0;j<8;j++)scanf(""%d"",&l[i][j]);
            }
            for(i=0;i<m;i++){
                for(j=i+1;j<m;j++){
                    if(x(&l[i],&l[j])){
                        k=0;
                        ii=i;
                        while((b[k++]=ii),a[ii]!=ii)ii=a[ii];
                        jj=j;
                        while((b[k++]=jj),a[jj]!=jj)jj=a[jj];
                        min=ii<jj?ii:jj;
                        for(kk=0;kk<k;kk++)a[b[kk]]=min;
                    }
                }
            }
            for(i=0;i<m;i++){
                j=i;
                while(a[j]!=j)j=a[j];
                a[i]=j;
            }
            k=0;
            for(i=0;i<m;i++){
                for(j=0;j<i;j++){
                    if(a[i]==a[j])break;
                }
                if(j==i)k++;
            }
            printf(""%d\n"",k);
        }
    }
    return 0;
}",1
p00214,"秋のイルミネーション
四角形が大好きな人が多く住む四角町では、四角形の電光板を組み合わせたイルミネーションで町中を彩るお祭りが開催されます。
この電光板は電気を流すと発光し、発光している板に接している板も発光します。したがって、電光板を何枚使っても、すべてがひとかたまりに接していれば電源がひとつで済むという優れものです。
お祭り実行委員会では、四角形を組み合わせたデザインを町民から募集し多数のイルミネーションを作成します。各イルミネーションは、デザインを構成する四角形の配置によって必要となる電源の個数が変わるため、必要な電源の個数を把握する作業に
大きな手間がかかります。
そこで、
あなたは四角形の配置を調べ、必要な電源の個数を計算するプログラムを作成して実行委員会を手助けすることにしました。
イルミネーションの個数、各イルミネーションを構成する四角形の情報を入力とし、イルミネーションごとに必要な電源の個数を出力するプログラムを作成してください。重なっていたり接していたりする四角形を 1 つのまとまりと考え、1 つのまとまりに対して電源の個数は 1 つと数えてください。
Input
複数のデータセットの並びが入力として与えられます。入力の終わりはゼロひとつの行で示されます。各データセットは以下の形式で与えられます。
N
M
1
xa
1
ya
1
xb
1
yb
1
xc
1
yc
1
xd
1
yd
1
xa
2
ya
2
xb
2
yb
2
xc
2
yc
2
xd
2
yd
2
:
xa
M
1
ya
M
1
xb
M
1
yb
M
1
xc
M
1
yc
M
1
xd
M
1
yd
M
1
M
2
:
:
M
N
:
:
1 行目にイルミネーションの個数
N
(1 ≤
N
≤ 100) が与えられます。続いて、
N
個のイルミネーションの情報が与えられます。第
i
のイルミネーションの情報として、イルミネーションを構成する四角形の個数
M
i
(1 ≤
M
i
≤ 100) が１行に与えられます。続く
M
i
行に
j
個目の四角形の頂点
xa
j
,
ya
j
,
xb
j
,
yb
j
,
xc
j
,
yc
j
,
xd
j
,
yd
j
(-1000 以上 1000 以下の整数) が与えられます。
入力される四角形の頂点座標は、時計回りの順に従って入力されます。ただし、入力データの四角形はすべて凸な四角形とします。
データセットの数は 10 を超えません。
Output
入力データセットごとに、イルミネーションごとに必要な電源の個数を出力します。出力する電源の個数は各イルミネーションが入力された順番に従ってください。
Sample Input
3
1
0 0 0 1 1 1 1 0
2
0 0 0 1 1 1 1 0
100 100 100 200 200 200 200 100
2
0 0 0 100 100 100 100 0
10 10 10 20 20 20 20 10
2
1
30 40 40 50 40 20 20 10
1
30 40 40 50 40 20 20 10
0
Output for the Sample Input
1
2
1
1
1",Java,"import java.util.*;
import java.io.*;

public class Main {
    static class Point {
        double x, y;
        Point(double x, double y) {
            this.x = x;
            this.y = y;
        }
    }
    
    static class Quad {
        Point[] points;
        Quad(Point[] points) {
            this.points = points;
        }
    }
    
    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        String line;
        
        while ((line = br.readLine()) != null) {
            int n = Integer.parseInt(line.trim());
            if (n == 0) break;
            
            for (int i = 0; i < n; i++) {
                int m = Integer.parseInt(br.readLine().trim());
                Quad[] quads = new Quad[m];
                
                for (int j = 0; j < m; j++) {
                    String[] tokens = br.readLine().trim().split(""\\s+"");
                    Point[] points = new Point[4];
                    for (int k = 0; k < 4; k++) {
                        points[k] = new Point(
                            Double.parseDouble(tokens[k * 2]),
                            Double.parseDouble(tokens[k * 2 + 1])
                        );
                    }
                    quads[j] = new Quad(points);
                }
                
                int components = countComponents(quads);
                System.out.println(components);
            }
        }
    }
    
    static int countComponents(Quad[] quads) {
        int n = quads.length;
        boolean[] visited = new boolean[n];
        int count = 0;
        
        for (int i = 0; i < n; i++) {
            if (!visited[i]) {
                dfs(i, quads, visited);
                count++;
            }
        }
        
        return count;
    }
    
    static void dfs(int idx, Quad[] quads, boolean[] visited) {
        visited[idx] = true;
        
        for (int i = 0; i < quads.length; i++) {
            if (!visited[i] && intersectsOrTouches(quads[idx], quads[i])) {
                dfs(i, quads, visited);
            }
        }
    }
    
    static boolean intersectsOrTouches(Quad q1, Quad q2) {
        // Check if q1 and q2 overlap or touch
        if (polygonsIntersect(q1.points, q2.points)) return true;
        if (polygonContainsPolygon(q1.points, q2.points)) return true;
        if (polygonContainsPolygon(q2.points, q1.points)) return true;
        return false;
    }
    
    static boolean polygonsIntersect(Point[] p1, Point[] p2) {
        // Check edge intersections or touching
        for (int i = 0; i < 4; i++) {
            for (int j = 0; j < 4; j++) {
                if (segmentsIntersectOrTouch(p1[i], p1[(i+1)%4], p2[j], p2[(j+1)%4])) {
                    return true;
                }
            }
        }
        
        // Check if any vertex of one is inside the other
        for (int i = 0; i < 4; i++) {
            if (pointInOrOnPolygon(p1[i], p2)) return true;
            if (pointInOrOnPolygon(p2[i], p1)) return true;
        }
        
        return false;
    }
    
    static boolean polygonContainsPolygon(Point[] p1, Point[] p2) {
        for (int i = 0; i < 4; i++) {
            if (pointInPolygon(p2[i], p1)) return true;
        }
        return false;
    }
    
    static boolean segmentsIntersectOrTouch(Point p1, Point p2, Point p3, Point p4) {
        double d1 = direction(p3, p4, p1);
        double d2 = direction(p3, p4, p2);
        double d3 = direction(p1, p2, p3);
        double d4 = direction(p1, p2, p4);
        
        if (((d1 > 0 && d2 < 0) || (d1 < 0 && d2 > 0)) &&
            ((d3 > 0 && d4 < 0) || (d3 < 0 && d4 > 0))) {
            return true;
        }
        
        if (Math.abs(d1) < 1e-9 && onSegment(p3, p4, p1)) return true;
        if (Math.abs(d2) < 1e-9 && onSegment(p3, p4, p2)) return true;
        if (Math.abs(d3) < 1e-9 && onSegment(p1, p2, p3)) return true;
        if (Math.abs(d4) < 1e-9 && onSegment(p1, p2, p4)) return true;
        
        return false;
    }
    
    static double direction(Point p1, Point p2, Point p3) {
        return (p3.x - p1.x) * (p2.y - p1.y) - (p2.x - p1.x) * (p3.y - p1.y);
    }
    
    static boolean onSegment(Point p1, Point p2, Point p) {
        return Math.min(p1.x, p2.x) <= p.x + 1e-9 && p.x <= Math.max(p1.x, p2.x) + 1e-9 &&
               Math.min(p1.y, p2.y) <= p.y + 1e-9 && p.y <= Math.max(p1.y, p2.y) + 1e-9;
    }
    
    static boolean pointInOrOnPolygon(Point p, Point[] poly) {
        return pointInPolygon(p, poly) || pointOnPolygonBoundary(p, poly);
    }
    
    static boolean pointInPolygon(Point p, Point[] poly) {
        int n = poly.length;
        boolean inside = false;
        for (int i = 0, j = n - 1; i < n; j = i++) {
            if ((poly[i].y > p.y) != (poly[j].y > p.y) &&
                p.x < (poly[j].x - poly[i].x) * (p.y - poly[i].y) / (poly[j].y - poly[i].y) + poly[i].x) {
                inside = !inside;
            }
        }
        return inside;
    }
    
    static boolean pointOnPolygonBoundary(Point p, Point[] poly) {
        int n = poly.length;
        for (int i = 0; i < n; i++) {
            if (Math.abs(direction(poly[i], poly[(i+1)%n], p)) < 1e-9 &&
                onSegment(poly[i], poly[(i+1)%n], p)) {
                return true;
            }
        }
        return false;
    }
}
",0
p00214,"秋のイルミネーション
四角形が大好きな人が多く住む四角町では、四角形の電光板を組み合わせたイルミネーションで町中を彩るお祭りが開催されます。
この電光板は電気を流すと発光し、発光している板に接している板も発光します。したがって、電光板を何枚使っても、すべてがひとかたまりに接していれば電源がひとつで済むという優れものです。
お祭り実行委員会では、四角形を組み合わせたデザインを町民から募集し多数のイルミネーションを作成します。各イルミネーションは、デザインを構成する四角形の配置によって必要となる電源の個数が変わるため、必要な電源の個数を把握する作業に
大きな手間がかかります。
そこで、
あなたは四角形の配置を調べ、必要な電源の個数を計算するプログラムを作成して実行委員会を手助けすることにしました。
イルミネーションの個数、各イルミネーションを構成する四角形の情報を入力とし、イルミネーションごとに必要な電源の個数を出力するプログラムを作成してください。重なっていたり接していたりする四角形を 1 つのまとまりと考え、1 つのまとまりに対して電源の個数は 1 つと数えてください。
Input
複数のデータセットの並びが入力として与えられます。入力の終わりはゼロひとつの行で示されます。各データセットは以下の形式で与えられます。
N
M
1
xa
1
ya
1
xb
1
yb
1
xc
1
yc
1
xd
1
yd
1
xa
2
ya
2
xb
2
yb
2
xc
2
yc
2
xd
2
yd
2
:
xa
M
1
ya
M
1
xb
M
1
yb
M
1
xc
M
1
yc
M
1
xd
M
1
yd
M
1
M
2
:
:
M
N
:
:
1 行目にイルミネーションの個数
N
(1 ≤
N
≤ 100) が与えられます。続いて、
N
個のイルミネーションの情報が与えられます。第
i
のイルミネーションの情報として、イルミネーションを構成する四角形の個数
M
i
(1 ≤
M
i
≤ 100) が１行に与えられます。続く
M
i
行に
j
個目の四角形の頂点
xa
j
,
ya
j
,
xb
j
,
yb
j
,
xc
j
,
yc
j
,
xd
j
,
yd
j
(-1000 以上 1000 以下の整数) が与えられます。
入力される四角形の頂点座標は、時計回りの順に従って入力されます。ただし、入力データの四角形はすべて凸な四角形とします。
データセットの数は 10 を超えません。
Output
入力データセットごとに、イルミネーションごとに必要な電源の個数を出力します。出力する電源の個数は各イルミネーションが入力された順番に従ってください。
Sample Input
3
1
0 0 0 1 1 1 1 0
2
0 0 0 1 1 1 1 0
100 100 100 200 200 200 200 100
2
0 0 0 100 100 100 100 0
10 10 10 20 20 20 20 10
2
1
30 40 40 50 40 20 20 10
1
30 40 40 50 40 20 20 10
0
Output for the Sample Input
1
2
1
1
1",Java,"import java.util.Arrays;
import java.util.Scanner;

//Autumnal Illumination
public class Main{

	int n;
	int[][][] p;
	
	int cross(int[] s, int[] t, int[] r){
		int x1 = t[0]-s[0], y1 = t[1]-s[1], x2 = r[0]-s[0], y2 = r[1]-s[1];
		return x1*y2-x2*y1;
	}
	boolean online(int[] s, int[] t, int[] r){
		if(cross(s, t, r)!=0)return false;
		int minx = Math.min(s[0], t[0]), maxx = Math.max(s[0], t[0]);
		int miny = Math.min(s[1], t[1]), maxy = Math.max(s[1], t[1]);
		return minx<=r[0]&&r[0]<=maxx&&miny<=r[1]&&r[1]<=maxy;
	}
	boolean isCross(int[] a, int[] b, int[] s, int[] t){
		if(cross(a, b, s)*cross(a, b, t)>=0)return false;
		return cross(b, a, s)*cross(b, a, t)<0;
	}
	
	boolean col(int a, int b){
		for(int i=0;i<4;i++)for(int j=0;j<4;j++){
			if(online(p[a][i], p[a][(i+1)%4], p[b][j]))return true;
			if(online(p[b][i], p[b][(i+1)%4], p[a][j]))return true;
			if(isCross(p[a][i], p[a][(i+1)%4], p[b][j], p[b][(j+1)%4]))return true;
		}
		for(int j=0;j<4;j++){
			boolean in = true;
			for(int i=0;i<4;i++)if(cross(p[a][i], p[a][(i+1)%4], p[b][j])>=0)in = false;
			if(in)return true;
		}
		return false;
	}
	
	void run(){
		Scanner sc = new Scanner(System.in);
		for(;;){
			int m = sc.nextInt();
			if(m==0)break;
			while(m--!=0){
				n = sc.nextInt();
				p = new int[n][4][2];
				for(int i=0;i<n;i++)for(int j=0;j<4;j++)for(int k=0;k<2;k++)p[i][j][k]=sc.nextInt();
				UnionFind u = new UnionFind(n);
				for(int i=0;i<n;i++)for(int j=0;j<n;j++){
					if(u.find(i, j))continue;
					if(col(i, j))u.union(i, j);
				}
				System.out.println(u.num);
			}
		}
	}
	
	class UnionFind {
		final int[] tree;
		int num;
		public UnionFind(int n) {
			this.tree = new int[n];
			Arrays.fill(tree, -1);
			num=n;
		}
		void union(int x, int y) {
			x = root(x);
			y = root(y);
			if(x != y) {
				if(tree[x] < tree[y]) {
					x ^= y; y ^= x; x^= y;
				}
				tree[x] += tree[y];
				tree[y] = x;
				num--;
			}
		}
		boolean find(int x, int y) {
			return root(x) == root(y);
		}
		int root(int x) {
			return tree[x] < 0 ? x : (tree[x] = root(tree[x]));
		}
		int size(int x) {
			return -tree[root(x)];
		}
		int getNum() {
			return num;
		}
	}
	
	public static void main(String[] args) {
		new Main().run();
	}
}",1
p00214,"秋のイルミネーション
四角形が大好きな人が多く住む四角町では、四角形の電光板を組み合わせたイルミネーションで町中を彩るお祭りが開催されます。
この電光板は電気を流すと発光し、発光している板に接している板も発光します。したがって、電光板を何枚使っても、すべてがひとかたまりに接していれば電源がひとつで済むという優れものです。
お祭り実行委員会では、四角形を組み合わせたデザインを町民から募集し多数のイルミネーションを作成します。各イルミネーションは、デザインを構成する四角形の配置によって必要となる電源の個数が変わるため、必要な電源の個数を把握する作業に
大きな手間がかかります。
そこで、
あなたは四角形の配置を調べ、必要な電源の個数を計算するプログラムを作成して実行委員会を手助けすることにしました。
イルミネーションの個数、各イルミネーションを構成する四角形の情報を入力とし、イルミネーションごとに必要な電源の個数を出力するプログラムを作成してください。重なっていたり接していたりする四角形を 1 つのまとまりと考え、1 つのまとまりに対して電源の個数は 1 つと数えてください。
Input
複数のデータセットの並びが入力として与えられます。入力の終わりはゼロひとつの行で示されます。各データセットは以下の形式で与えられます。
N
M
1
xa
1
ya
1
xb
1
yb
1
xc
1
yc
1
xd
1
yd
1
xa
2
ya
2
xb
2
yb
2
xc
2
yc
2
xd
2
yd
2
:
xa
M
1
ya
M
1
xb
M
1
yb
M
1
xc
M
1
yc
M
1
xd
M
1
yd
M
1
M
2
:
:
M
N
:
:
1 行目にイルミネーションの個数
N
(1 ≤
N
≤ 100) が与えられます。続いて、
N
個のイルミネーションの情報が与えられます。第
i
のイルミネーションの情報として、イルミネーションを構成する四角形の個数
M
i
(1 ≤
M
i
≤ 100) が１行に与えられます。続く
M
i
行に
j
個目の四角形の頂点
xa
j
,
ya
j
,
xb
j
,
yb
j
,
xc
j
,
yc
j
,
xd
j
,
yd
j
(-1000 以上 1000 以下の整数) が与えられます。
入力される四角形の頂点座標は、時計回りの順に従って入力されます。ただし、入力データの四角形はすべて凸な四角形とします。
データセットの数は 10 を超えません。
Output
入力データセットごとに、イルミネーションごとに必要な電源の個数を出力します。出力する電源の個数は各イルミネーションが入力された順番に従ってください。
Sample Input
3
1
0 0 0 1 1 1 1 0
2
0 0 0 1 1 1 1 0
100 100 100 200 200 200 200 100
2
0 0 0 100 100 100 100 0
10 10 10 20 20 20 20 10
2
1
30 40 40 50 40 20 20 10
1
30 40 40 50 40 20 20 10
0
Output for the Sample Input
1
2
1
1
1",Python,"def rectangles_overlap_or_touch(rect1, rect2):
    # Check if two rectangles overlap or touch (including edges)
    # rect is list of 4 points [(x1,y1), (x2,y2), (x3,y3), (x4,y4)]
    
    # Check if rectangles are separated (no overlap or touch)
    # Use Separating Axis Theorem (SAT)
    
    def get_edges(rect):
        edges = []
        for i in range(4):
            p1 = rect[i]
            p2 = rect[(i+1)%4]
            edges.append((p2[0]-p1[0], p2[1]-p1[1]))
        return edges
    
    def get_normals(edges):
        normals = []
        for edge in edges:
            normals.append((-edge[1], edge[0]))
        return normals
    
    def project(rect, axis):
        dots = []
        for point in rect:
            dots.append(point[0]*axis[0] + point[1]*axis[1])
        return min(dots), max(dots)
    
    def overlap(proj1, proj2):
        return proj1[1] >= proj2[0] and proj2[1] >= proj1[0]
    
    edges1 = get_edges(rect1)
    edges2 = get_edges(rect2)
    normals = get_normals(edges1) + get_normals(edges2)
    
    for normal in normals:
        proj1 = project(rect1, normal)
        proj2 = project(rect2, normal)
        if not overlap(proj1, proj2):
            return False
    
    return True

def find_connected_components(rectangles):
    n = len(rectangles)
    if n == 0:
        return 0
    
    # Build adjacency list
    adj = [[] for _ in range(n)]
    for i in range(n):
        for j in range(i+1, n):
            if rectangles_overlap_or_touch(rectangles[i], rectangles[j]):
                adj[i].append(j)
                adj[j].append(i)
    
    # DFS to count connected components
    visited = [False] * n
    components = 0
    
    def dfs(node):
        visited[node] = True
        for neighbor in adj[node]:
            if not visited[neighbor]:
                dfs(neighbor)
    
    for i in range(n):
        if not visited[i]:
            dfs(i)
            components += 1
    
    return components

while True:
    n = int(input())
    if n == 0:
        break
    
    for _ in range(n):
        m = int(input())
        rectangles = []
        for _ in range(m):
            coords = list(map(int, input().split()))
            rect = [(coords[i], coords[i+1]) for i in range(0, 8, 2)]
            rectangles.append(rect)
        
        result = find_connected_components(rectangles)
        print(result)
",0
p00214,"秋のイルミネーション
四角形が大好きな人が多く住む四角町では、四角形の電光板を組み合わせたイルミネーションで町中を彩るお祭りが開催されます。
この電光板は電気を流すと発光し、発光している板に接している板も発光します。したがって、電光板を何枚使っても、すべてがひとかたまりに接していれば電源がひとつで済むという優れものです。
お祭り実行委員会では、四角形を組み合わせたデザインを町民から募集し多数のイルミネーションを作成します。各イルミネーションは、デザインを構成する四角形の配置によって必要となる電源の個数が変わるため、必要な電源の個数を把握する作業に
大きな手間がかかります。
そこで、
あなたは四角形の配置を調べ、必要な電源の個数を計算するプログラムを作成して実行委員会を手助けすることにしました。
イルミネーションの個数、各イルミネーションを構成する四角形の情報を入力とし、イルミネーションごとに必要な電源の個数を出力するプログラムを作成してください。重なっていたり接していたりする四角形を 1 つのまとまりと考え、1 つのまとまりに対して電源の個数は 1 つと数えてください。
Input
複数のデータセットの並びが入力として与えられます。入力の終わりはゼロひとつの行で示されます。各データセットは以下の形式で与えられます。
N
M
1
xa
1
ya
1
xb
1
yb
1
xc
1
yc
1
xd
1
yd
1
xa
2
ya
2
xb
2
yb
2
xc
2
yc
2
xd
2
yd
2
:
xa
M
1
ya
M
1
xb
M
1
yb
M
1
xc
M
1
yc
M
1
xd
M
1
yd
M
1
M
2
:
:
M
N
:
:
1 行目にイルミネーションの個数
N
(1 ≤
N
≤ 100) が与えられます。続いて、
N
個のイルミネーションの情報が与えられます。第
i
のイルミネーションの情報として、イルミネーションを構成する四角形の個数
M
i
(1 ≤
M
i
≤ 100) が１行に与えられます。続く
M
i
行に
j
個目の四角形の頂点
xa
j
,
ya
j
,
xb
j
,
yb
j
,
xc
j
,
yc
j
,
xd
j
,
yd
j
(-1000 以上 1000 以下の整数) が与えられます。
入力される四角形の頂点座標は、時計回りの順に従って入力されます。ただし、入力データの四角形はすべて凸な四角形とします。
データセットの数は 10 を超えません。
Output
入力データセットごとに、イルミネーションごとに必要な電源の個数を出力します。出力する電源の個数は各イルミネーションが入力された順番に従ってください。
Sample Input
3
1
0 0 0 1 1 1 1 0
2
0 0 0 1 1 1 1 0
100 100 100 200 200 200 200 100
2
0 0 0 100 100 100 100 0
10 10 10 20 20 20 20 10
2
1
30 40 40 50 40 20 20 10
1
30 40 40 50 40 20 20 10
0
Output for the Sample Input
1
2
1
1
1",Python,"from sys import stdin
from itertools import product

def chk_in_rect(xy1,xy2):
    chk = True
    for i in range(4):
        for j in range(4):
            a = (xy1[(2*i+2)&7]-xy1[(2*i  )&7]) * (xy2[(2*j+1)&7]-xy1[(2*i+1)&7])
            b = (xy1[(2*i+3)&7]-xy1[(2*i+1)&7]) * (xy2[(2*j  )&7]-xy1[(2*i  )&7])
            if a > b: chk = False; break
    if chk: return True
    else: return False

def chk_intersect(xy1,xy2):
    for i,j in product(range(4),repeat=2):
        a = (xy1[(2*i  )&7]-xy1[(2*i+2)&7]) * (xy2[(2*j+1)&7]-xy1[(2*i+3)&7])
        a+= (xy1[(2*i+1)&7]-xy1[(2*i+3)&7]) * (xy2[(2*i  )&7]-xy1[(2*j  )&7])
        b = (xy1[(2*i  )&7]-xy1[(2*i+2)&7]) * (xy2[(2*j+3)&7]-xy1[(2*i+3)&7])
        b+= (xy1[(2*i+1)&7]-xy1[(2*i+3)&7]) * (xy2[(2*i  )&7]-xy1[(2*j+2)&7])
        if a*b < 0 : return True
    else:
        return False

while(True):
    try:
        n = int(stdin.readline())
        if not n: break
    except:
        break
    for _ in range(n):
        m = int(stdin.readline())
        p = list(range(m))
        xys = [ list(map(int, stdin.readline().split())) for i in range(m) ]
        # print(n,m,xys)
        for i in range(m):
            if len(set(p)) == 1: print(1); break
            for j in range(i+1,m):
                if p[i] == p[j]:
                    continue
                if chk_in_rect(xys[i],xys[j]):
                    # print(""in_rect"")
                    p = [i if e==j else e for e in p]
                    continue
                if chk_intersect(xys[i],xys[j]):
                    # print(""intersect"")
                    p = [i if e==j else e for e in p]
                    continue
        else: print(len(set(p)))




",1
p00215,"パチモンクリーチャー
某国で
大人気のゲーム、パチモンクリーチャーが日本でリメイクされて発売されました。 ゲームが大好きなあなたは、  このゲームを
何度もプレイするうちにどうしたら最速でクリアできるのか考えるようになりました。しかし、いくら考えても最速の攻略方法がわからなかったあなたは、どれだけ早くゲームをクリアできるかを求めるプログラムを作成することにしました。
ゲームの詳細は以下の通りです。
パチモンクリーチャー(以下、パチクリ)という生物が多く存在する世界がゲームの舞台です。各パチクリは、火属性、氷属性、木属性、土属性、水属性の 5 種類の属性のいずれか１つの属性を持ちます。ゲームの主人公は、ゲーム開始時に好きな属性のパチクリ一匹を冒険のパートナーとして選びます。そのパチクリと共にゴールを目指し、ゴールにいるライバルを倒してパチクリマスターになることがゲームの目的です。
しかし、ライバルを倒すためには全属性のパチクリがいないと勝てないので、途中で全属性のパチクリを捕まえなければなりません。パチクリを捕まえるには属性がカギとなります。火属性のパチクリは氷属性のパチクリを捕まえることができ、同様に、氷属性は木属性、木属性は土属性、土属性は水属性、水属性は火属性を捕まえることができます。属性の関連は以下の図のようになります。
以下の図はゲームが行われるマップの一例を表しています。
主人公はパチクリを一匹もってスタート地点である「S」から出発し、一マスずつ移動しながらゴール地点である「G」を目指します。その途中で、最初に持っているパチクリ以外の 4 つの属性のパチクリを捕まえ、ゴール地点であるマス目に移動するとゲーム終了となります。
主人公は、今いるマス目から、辺を共有する隣のマス目に移動することができ、それを一回の移動と数えます。主人公がパチクリのいるマスに移動した場合、そのパチクリを捕まえられる属性のパチクリを持っていればそのパチクリを捕まえたことになります。そのマスにいるパチクリを捕まえられるかの可否にかかわらず、すべてのマスに何度でも移動することができます。
マップの大きさ(横方向の列数、縦方向の行数)とマップの初期状態を入力とし、初めに選んだパチクリの属性と、それ以外の 4 つの属性のパチクリを捕まえるのにかかる、スタート地点からゴール地点に至る最小移動数を出力するプログラムを作成してください。
Input
複数のデータセットの並びが入力として与えられます。入力の終りはゼロふたつの行で示されます。各データセットは以下の形式で与えられます。
W
H
c
11
c
12
...
c
1W
c
21
c
22
...
c
2W
:
c
H1
c
H2
...
c
HW
1 行目にマップの横方向の列数
W
と縦方向の行数
H
(2 ≤
W, H
≤ 1000) が与えられます。続く
H
行にマップの
i
行目の情報が与えられます。入力されるマップには各マスの状態が与えられます。     「S」は主人公のスタート地点を、  「G」はゴール地点を、「1」「2」「3」「4」「5」はそこにいるパチクリの属性を( 1:火属性、 2:氷属性、    3:木属性、 4:土属性、 5:水属性 をそれぞれ表します)、 「.(ピリオド) 」は何もないマスをそれぞれ表します。 
各属性のパチクリの数はそれぞれ 0 以上 1000 以下とします。
データセットの数は140 を超えません。また、データセットの 80 % について、
W, H
は100 を超えません。
Output
入力データセットごとに、最初に選んだパチクリの属性と最小移動数を１行に出力します。なお、どのように初めのパチクリを選んでも、どのような経路で移動してもそれら 4 つの属性のパチクリを捕まえることができない場合は NA と出力してください。  また、最小移動数が同じになるような最初のパチクリの選び方が複数ある場合は、属性の数字が小さいものを出力してください。
Sample Input
6 6
S.1..4
3..5..
..4.1.
4....5
.2.32.
5.1..G
3 2
...
S.G
0 0
Output for the Sample Input
2 10
NA",C,"#include <stdio.h>
#include <string.h>
#include <stdlib.h>

#define MAX 1000
#define INF 1000000000

typedef struct {
    int x, y, mask;
} State;

typedef struct {
    int x, y;
} Point;

char map[MAX][MAX];
int W, H;
Point start, goal;
Point creatures[5][MAX];
int creature_count[5];

int dx[] = {0, 0, 1, -1};
int dy[] = {1, -1, 0, 0};

typedef struct {
    State data[MAX * MAX * 32];
    int front, rear;
} Queue;

void init_queue(Queue *q) {
    q->front = 0;
    q->rear = 0;
}

void enqueue(Queue *q, State s) {
    q->data[q->rear++] = s;
}

State dequeue(Queue *q) {
    return q->data[q->front++];
}

int is_empty(Queue *q) {
    return q->front == q->rear;
}

int bfs(int start_attr) {
    int dist[MAX][MAX][32];
    int i, j, k;
    
    for (i = 0; i < H; i++) {
        for (j = 0; j < W; j++) {
            for (k = 0; k < 32; k++) {
                dist[i][j][k] = INF;
            }
        }
    }
    
    Queue q;
    init_queue(&q);
    
    State s;
    s.x = start.x;
    s.y = start.y;
    s.mask = (1 << start_attr);
    dist[s.x][s.y][s.mask] = 0;
    enqueue(&q, s);
    
    while (!is_empty(&q)) {
        State cur = dequeue(&q);
        int cx = cur.x;
        int cy = cur.y;
        int cmask = cur.mask;
        
        if (cx == goal.x && cy == goal.y && cmask == 31) {
            return dist[cx][cy][cmask];
        }
        
        for (i = 0; i < 4; i++) {
            int nx = cx + dx[i];
            int ny = cy + dy[i];
            
            if (nx < 0 || nx >= H || ny < 0 || ny >= W) continue;
            
            int nmask = cmask;
            
            if (map[nx][ny] >= '1' && map[nx][ny] <= '5') {
                int attr = map[nx][ny] - '1';
                int can_catch = 0;
                
                for (j = 0; j < 5; j++) {
                    if (cmask & (1 << j)) {
                        int catchable = (j + 1) % 5;
                        if (catchable == attr) {
                            can_catch = 1;
                            break;
                        }
                    }
                }
                
                if (can_catch) {
                    nmask |= (1 << attr);
                }
            }
            
            if (dist[nx][ny][nmask] > dist[cx][cy][cmask] + 1) {
                dist[nx][ny][nmask] = dist[cx][cy][cmask] + 1;
                State ns;
                ns.x = nx;
                ns.y = ny;
                ns.mask = nmask;
                enqueue(&q, ns);
            }
        }
    }
    
    return INF;
}

int main() {
    while (1) {
        scanf(""%d %d"", &W, &H);
        if (W == 0 && H == 0) break;
        
        int i, j;
        for (i = 0; i < 5; i++) {
            creature_count[i] = 0;
        }
        
        for (i = 0; i < H; i++) {
            scanf(""%s"", map[i]);
            for (j = 0; j < W; j++) {
                if (map[i][j] == 'S') {
                    start.x = i;
                    start.y = j;
                } else if (map[i][j] == 'G') {
                    goal.x = i;
                    goal.y = j;
                } else if (map[i][j] >= '1' && map[i][j] <= '5') {
                    int attr = map[i][j] - '1';
                    creatures[attr][creature_count[attr]].x = i;
                    creatures[attr][creature_count[attr]].y = j;
                    creature_count[attr]++;
                }
            }
        }
        
        int min_dist = INF;
        int best_attr = -1;
        
        for (i = 0; i < 5; i++) {
            int d = bfs(i);
            if (d < min_dist) {
                min_dist = d;
                best_attr = i;
            }
        }
        
        if (min_dist == INF) {
            printf(""NA\n"");
        } else {
            printf(""%d %d\n"", best_attr + 1, min_dist);
        }
    }
    
    return 0;
}
",0
p00215,"パチモンクリーチャー
某国で
大人気のゲーム、パチモンクリーチャーが日本でリメイクされて発売されました。 ゲームが大好きなあなたは、  このゲームを
何度もプレイするうちにどうしたら最速でクリアできるのか考えるようになりました。しかし、いくら考えても最速の攻略方法がわからなかったあなたは、どれだけ早くゲームをクリアできるかを求めるプログラムを作成することにしました。
ゲームの詳細は以下の通りです。
パチモンクリーチャー(以下、パチクリ)という生物が多く存在する世界がゲームの舞台です。各パチクリは、火属性、氷属性、木属性、土属性、水属性の 5 種類の属性のいずれか１つの属性を持ちます。ゲームの主人公は、ゲーム開始時に好きな属性のパチクリ一匹を冒険のパートナーとして選びます。そのパチクリと共にゴールを目指し、ゴールにいるライバルを倒してパチクリマスターになることがゲームの目的です。
しかし、ライバルを倒すためには全属性のパチクリがいないと勝てないので、途中で全属性のパチクリを捕まえなければなりません。パチクリを捕まえるには属性がカギとなります。火属性のパチクリは氷属性のパチクリを捕まえることができ、同様に、氷属性は木属性、木属性は土属性、土属性は水属性、水属性は火属性を捕まえることができます。属性の関連は以下の図のようになります。
以下の図はゲームが行われるマップの一例を表しています。
主人公はパチクリを一匹もってスタート地点である「S」から出発し、一マスずつ移動しながらゴール地点である「G」を目指します。その途中で、最初に持っているパチクリ以外の 4 つの属性のパチクリを捕まえ、ゴール地点であるマス目に移動するとゲーム終了となります。
主人公は、今いるマス目から、辺を共有する隣のマス目に移動することができ、それを一回の移動と数えます。主人公がパチクリのいるマスに移動した場合、そのパチクリを捕まえられる属性のパチクリを持っていればそのパチクリを捕まえたことになります。そのマスにいるパチクリを捕まえられるかの可否にかかわらず、すべてのマスに何度でも移動することができます。
マップの大きさ(横方向の列数、縦方向の行数)とマップの初期状態を入力とし、初めに選んだパチクリの属性と、それ以外の 4 つの属性のパチクリを捕まえるのにかかる、スタート地点からゴール地点に至る最小移動数を出力するプログラムを作成してください。
Input
複数のデータセットの並びが入力として与えられます。入力の終りはゼロふたつの行で示されます。各データセットは以下の形式で与えられます。
W
H
c
11
c
12
...
c
1W
c
21
c
22
...
c
2W
:
c
H1
c
H2
...
c
HW
1 行目にマップの横方向の列数
W
と縦方向の行数
H
(2 ≤
W, H
≤ 1000) が与えられます。続く
H
行にマップの
i
行目の情報が与えられます。入力されるマップには各マスの状態が与えられます。     「S」は主人公のスタート地点を、  「G」はゴール地点を、「1」「2」「3」「4」「5」はそこにいるパチクリの属性を( 1:火属性、 2:氷属性、    3:木属性、 4:土属性、 5:水属性 をそれぞれ表します)、 「.(ピリオド) 」は何もないマスをそれぞれ表します。 
各属性のパチクリの数はそれぞれ 0 以上 1000 以下とします。
データセットの数は140 を超えません。また、データセットの 80 % について、
W, H
は100 を超えません。
Output
入力データセットごとに、最初に選んだパチクリの属性と最小移動数を１行に出力します。なお、どのように初めのパチクリを選んでも、どのような経路で移動してもそれら 4 つの属性のパチクリを捕まえることができない場合は NA と出力してください。  また、最小移動数が同じになるような最初のパチクリの選び方が複数ある場合は、属性の数字が小さいものを出力してください。
Sample Input
6 6
S.1..4
3..5..
..4.1.
4....5
.2.32.
5.1..G
3 2
...
S.G
0 0
Output for the Sample Input
2 10
NA",C,"mx,my;pn[7];px[7][1000],py[7][1000];M[5][7][1000];a0;Calc(a1,a2){int n1,n2,m,mm;for(n2=0;n2<pn[a2];n2++){mm=1e9;for(n1=0;n1<pn[a1];n1++){m=M[a0][a1][n1]+abs(px[a1][n1]-px[a2][n2])+abs(py[a1][n1]-py[a2][n2]);if(m<mm)mm=m;}M[a0][a2][n2]=mm;}}main(){int x,y,c,a,am;for(;scanf(""%d%d\n"",&mx,&my),mx;){memset(pn,0,sizeof(pn));for(y=0;y<my;y++){for(x=0;x<=mx;x++){c=getchar();if(c>='1'){if(c<='5')a=c-'0';else if(c=='S')a=0;else if(c=='G')a=6;px[a][pn[a]]=x;py[a][pn[a]++]=y;}}}am=0;for(a0=0;a0<5;a0++){M[a0][0][0]=0;Calc(0,1+(a0+1)%5);for(a=0;a<3;a++)Calc(1+(a0+a+1)%5,1+(a0+a+2)%5);Calc(1+(a0+4)%5,6);if(M[a0][6][0]<M[am][6][0])am=a0;}printf(M[am][6][0]!=1e9?""%d %d\n"":""NA\n"",1+am,M[am][6][0]);}{int n;for(n=1000000;n--;)getchar();}exit(0);}",1
p00215,"パチモンクリーチャー
某国で
大人気のゲーム、パチモンクリーチャーが日本でリメイクされて発売されました。 ゲームが大好きなあなたは、  このゲームを
何度もプレイするうちにどうしたら最速でクリアできるのか考えるようになりました。しかし、いくら考えても最速の攻略方法がわからなかったあなたは、どれだけ早くゲームをクリアできるかを求めるプログラムを作成することにしました。
ゲームの詳細は以下の通りです。
パチモンクリーチャー(以下、パチクリ)という生物が多く存在する世界がゲームの舞台です。各パチクリは、火属性、氷属性、木属性、土属性、水属性の 5 種類の属性のいずれか１つの属性を持ちます。ゲームの主人公は、ゲーム開始時に好きな属性のパチクリ一匹を冒険のパートナーとして選びます。そのパチクリと共にゴールを目指し、ゴールにいるライバルを倒してパチクリマスターになることがゲームの目的です。
しかし、ライバルを倒すためには全属性のパチクリがいないと勝てないので、途中で全属性のパチクリを捕まえなければなりません。パチクリを捕まえるには属性がカギとなります。火属性のパチクリは氷属性のパチクリを捕まえることができ、同様に、氷属性は木属性、木属性は土属性、土属性は水属性、水属性は火属性を捕まえることができます。属性の関連は以下の図のようになります。
以下の図はゲームが行われるマップの一例を表しています。
主人公はパチクリを一匹もってスタート地点である「S」から出発し、一マスずつ移動しながらゴール地点である「G」を目指します。その途中で、最初に持っているパチクリ以外の 4 つの属性のパチクリを捕まえ、ゴール地点であるマス目に移動するとゲーム終了となります。
主人公は、今いるマス目から、辺を共有する隣のマス目に移動することができ、それを一回の移動と数えます。主人公がパチクリのいるマスに移動した場合、そのパチクリを捕まえられる属性のパチクリを持っていればそのパチクリを捕まえたことになります。そのマスにいるパチクリを捕まえられるかの可否にかかわらず、すべてのマスに何度でも移動することができます。
マップの大きさ(横方向の列数、縦方向の行数)とマップの初期状態を入力とし、初めに選んだパチクリの属性と、それ以外の 4 つの属性のパチクリを捕まえるのにかかる、スタート地点からゴール地点に至る最小移動数を出力するプログラムを作成してください。
Input
複数のデータセットの並びが入力として与えられます。入力の終りはゼロふたつの行で示されます。各データセットは以下の形式で与えられます。
W
H
c
11
c
12
...
c
1W
c
21
c
22
...
c
2W
:
c
H1
c
H2
...
c
HW
1 行目にマップの横方向の列数
W
と縦方向の行数
H
(2 ≤
W, H
≤ 1000) が与えられます。続く
H
行にマップの
i
行目の情報が与えられます。入力されるマップには各マスの状態が与えられます。     「S」は主人公のスタート地点を、  「G」はゴール地点を、「1」「2」「3」「4」「5」はそこにいるパチクリの属性を( 1:火属性、 2:氷属性、    3:木属性、 4:土属性、 5:水属性 をそれぞれ表します)、 「.(ピリオド) 」は何もないマスをそれぞれ表します。 
各属性のパチクリの数はそれぞれ 0 以上 1000 以下とします。
データセットの数は140 を超えません。また、データセットの 80 % について、
W, H
は100 を超えません。
Output
入力データセットごとに、最初に選んだパチクリの属性と最小移動数を１行に出力します。なお、どのように初めのパチクリを選んでも、どのような経路で移動してもそれら 4 つの属性のパチクリを捕まえることができない場合は NA と出力してください。  また、最小移動数が同じになるような最初のパチクリの選び方が複数ある場合は、属性の数字が小さいものを出力してください。
Sample Input
6 6
S.1..4
3..5..
..4.1.
4....5
.2.32.
5.1..G
3 2
...
S.G
0 0
Output for the Sample Input
2 10
NA",Java,"import java.util.*;
import java.io.*;

public class Main {
    static int[] dx = {0, 0, 1, -1};
    static int[] dy = {1, -1, 0, 0};
    
    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        String line;
        
        while ((line = br.readLine()) != null) {
            String[] tokens = line.trim().split(""\\s+"");
            int W = Integer.parseInt(tokens[0]);
            int H = Integer.parseInt(tokens[1]);
            
            if (W == 0 && H == 0) break;
            
            char[][] map = new char[H][W];
            int sx = -1, sy = -1, gx = -1, gy = -1;
            
            for (int i = 0; i < H; i++) {
                String row = br.readLine();
                for (int j = 0; j < W; j++) {
                    map[i][j] = row.charAt(j);
                    if (map[i][j] == 'S') {
                        sx = i;
                        sy = j;
                    } else if (map[i][j] == 'G') {
                        gx = i;
                        gy = j;
                    }
                }
            }
            
            int minDist = Integer.MAX_VALUE;
            int bestAttr = -1;
            
            for (int startAttr = 1; startAttr <= 5; startAttr++) {
                int dist = solve(map, H, W, sx, sy, gx, gy, startAttr);
                if (dist != -1 && dist < minDist) {
                    minDist = dist;
                    bestAttr = startAttr;
                }
            }
            
            if (bestAttr == -1) {
                System.out.println(""NA"");
            } else {
                System.out.println(bestAttr + "" "" + minDist);
            }
        }
    }
    
    static int solve(char[][] map, int H, int W, int sx, int sy, int gx, int gy, int startAttr) {
        int targetMask = 0;
        for (int i = 1; i <= 5; i++) {
            if (i != startAttr) {
                targetMask |= (1 << i);
            }
        }
        
        Queue<State> queue = new LinkedList<>();
        Map<String, Integer> visited = new HashMap<>();
        
        int initialMask = (1 << startAttr);
        State start = new State(sx, sy, initialMask, 0);
        queue.offer(start);
        visited.put(sx + "","" + sy + "","" + initialMask, 0);
        
        while (!queue.isEmpty()) {
            State curr = queue.poll();
            
            if (curr.x == gx && curr.y == gy && (curr.mask & targetMask) == targetMask) {
                return curr.dist;
            }
            
            for (int d = 0; d < 4; d++) {
                int nx = curr.x + dx[d];
                int ny = curr.y + dy[d];
                
                if (nx < 0 || nx >= H || ny < 0 || ny >= W) continue;
                
                int newMask = curr.mask;
                char cell = map[nx][ny];
                
                if (cell >= '1' && cell <= '5') {
                    int attr = cell - '0';
                    if (canCatch(curr.mask, attr)) {
                        newMask |= (1 << attr);
                    }
                }
                
                String key = nx + "","" + ny + "","" + newMask;
                if (!visited.containsKey(key) || visited.get(key) > curr.dist + 1) {
                    visited.put(key, curr.dist + 1);
                    queue.offer(new State(nx, ny, newMask, curr.dist + 1));
                }
            }
        }
        
        return -1;
    }
    
    static boolean canCatch(int mask, int target) {
        int[] catchMap = {0, 2, 3, 4, 5, 1}; // 1->2, 2->3, 3->4, 4->5, 5->1
        for (int i = 1; i <= 5; i++) {
            if ((mask & (1 << i)) != 0 && catchMap[i] == target) {
                return true;
            }
        }
        return false;
    }
    
    static class State {
        int x, y, mask, dist;
        
        State(int x, int y, int mask, int dist) {
            this.x = x;
            this.y = y;
            this.mask = mask;
            this.dist = dist;
        }
    }
}
",0
p00215,"パチモンクリーチャー
某国で
大人気のゲーム、パチモンクリーチャーが日本でリメイクされて発売されました。 ゲームが大好きなあなたは、  このゲームを
何度もプレイするうちにどうしたら最速でクリアできるのか考えるようになりました。しかし、いくら考えても最速の攻略方法がわからなかったあなたは、どれだけ早くゲームをクリアできるかを求めるプログラムを作成することにしました。
ゲームの詳細は以下の通りです。
パチモンクリーチャー(以下、パチクリ)という生物が多く存在する世界がゲームの舞台です。各パチクリは、火属性、氷属性、木属性、土属性、水属性の 5 種類の属性のいずれか１つの属性を持ちます。ゲームの主人公は、ゲーム開始時に好きな属性のパチクリ一匹を冒険のパートナーとして選びます。そのパチクリと共にゴールを目指し、ゴールにいるライバルを倒してパチクリマスターになることがゲームの目的です。
しかし、ライバルを倒すためには全属性のパチクリがいないと勝てないので、途中で全属性のパチクリを捕まえなければなりません。パチクリを捕まえるには属性がカギとなります。火属性のパチクリは氷属性のパチクリを捕まえることができ、同様に、氷属性は木属性、木属性は土属性、土属性は水属性、水属性は火属性を捕まえることができます。属性の関連は以下の図のようになります。
以下の図はゲームが行われるマップの一例を表しています。
主人公はパチクリを一匹もってスタート地点である「S」から出発し、一マスずつ移動しながらゴール地点である「G」を目指します。その途中で、最初に持っているパチクリ以外の 4 つの属性のパチクリを捕まえ、ゴール地点であるマス目に移動するとゲーム終了となります。
主人公は、今いるマス目から、辺を共有する隣のマス目に移動することができ、それを一回の移動と数えます。主人公がパチクリのいるマスに移動した場合、そのパチクリを捕まえられる属性のパチクリを持っていればそのパチクリを捕まえたことになります。そのマスにいるパチクリを捕まえられるかの可否にかかわらず、すべてのマスに何度でも移動することができます。
マップの大きさ(横方向の列数、縦方向の行数)とマップの初期状態を入力とし、初めに選んだパチクリの属性と、それ以外の 4 つの属性のパチクリを捕まえるのにかかる、スタート地点からゴール地点に至る最小移動数を出力するプログラムを作成してください。
Input
複数のデータセットの並びが入力として与えられます。入力の終りはゼロふたつの行で示されます。各データセットは以下の形式で与えられます。
W
H
c
11
c
12
...
c
1W
c
21
c
22
...
c
2W
:
c
H1
c
H2
...
c
HW
1 行目にマップの横方向の列数
W
と縦方向の行数
H
(2 ≤
W, H
≤ 1000) が与えられます。続く
H
行にマップの
i
行目の情報が与えられます。入力されるマップには各マスの状態が与えられます。     「S」は主人公のスタート地点を、  「G」はゴール地点を、「1」「2」「3」「4」「5」はそこにいるパチクリの属性を( 1:火属性、 2:氷属性、    3:木属性、 4:土属性、 5:水属性 をそれぞれ表します)、 「.(ピリオド) 」は何もないマスをそれぞれ表します。 
各属性のパチクリの数はそれぞれ 0 以上 1000 以下とします。
データセットの数は140 を超えません。また、データセットの 80 % について、
W, H
は100 を超えません。
Output
入力データセットごとに、最初に選んだパチクリの属性と最小移動数を１行に出力します。なお、どのように初めのパチクリを選んでも、どのような経路で移動してもそれら 4 つの属性のパチクリを捕まえることができない場合は NA と出力してください。  また、最小移動数が同じになるような最初のパチクリの選び方が複数ある場合は、属性の数字が小さいものを出力してください。
Sample Input
6 6
S.1..4
3..5..
..4.1.
4....5
.2.32.
5.1..G
3 2
...
S.G
0 0
Output for the Sample Input
2 10
NA",Java,"import java.awt.Point;
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.ArrayList;
import java.util.List;

public class Main {

	/** ????§??????? */
	static final String WHITE_SPACE = "" "";

	/** ??????????????????_X */
	static int mapSizeX = 0;

	/** ??????????????????_Y */
	static int mapSizeY = 0;

	/** ??????????????° */
	static int maxNode = 0;

	/** ????????¢??????????????? */
	static List<Point> pachimonList = new ArrayList<Point>();

	/** ?????????????¨??????????????????????????´??????? */
	static boolean[] visited = new boolean[5003];

	/** ??????????????????????????? */
	static int[] cost = new int[5003];

	/** ?????????????????? */
	static int startIdx = 0;

	/** ??´???????????? */
	static int goalIdx = 0;

	/**
	 * @param args
	 * @throws IOException
	 */
	public static void main(String[] args) throws IOException {
		InputStreamReader is = new InputStreamReader(System.in);
		BufferedReader br = new BufferedReader(is);
		String[] mapSizeLine = new String[2];
		Point output = createPos(0, Integer.MAX_VALUE);
		while (true) {
			mapSizeLine = br.readLine().split(WHITE_SPACE);
			mapSizeX = Integer.parseInt(mapSizeLine[0]);
			mapSizeY = Integer.parseInt(mapSizeLine[1]);
			if (mapSizeX == 0 && mapSizeY == 0)
				break;

			readMap(br);
			output.x = 0;
			output.y = Integer.MAX_VALUE;
			if (maxNode > 5) {
				for (int type = 1; type <= 5; type++) {
					// ??????????????????????????¢??????????????????????????????????????????????´¢
					int cost = searchRoute(type);
					if (cost < output.y && cost > 0) {
						output.x = type;
						output.y = cost;
					}
				}
			}

			// ???????????????
			if (output.y == Integer.MAX_VALUE) {
				System.out.println(""NA"");
			} else {
				System.out.println(output.x + WHITE_SPACE + output.y);
			}
		}
	}

	/**
	 * ?????????????????????????????????
	 * @param scanner ????????£??????
	 * @throws IOException
	 */
	private static void readMap(BufferedReader br) throws IOException {
		// ??????????????±????????????
		pachimonList.removeAll(pachimonList);
		maxNode = 0;
		startIdx = 0;

		for (int i = 0; i < mapSizeY; i++) {
			for (int j = 0; j < mapSizeX; j++) {
				int val = convertInt(br.read());
				if (val < 9) {
					// ???????????¢????????°????¨????
					if (val == 0)
						startIdx = pachimonList.size();
					if (val == 6)
						goalIdx = pachimonList.size();
					pachimonList.add(createPos(val, calcIndex(j, i)));
				}
			}
			// ????????????????£???°???
			br.readLine();
		}
		maxNode = pachimonList.size();
	}

	/**
	 * ??¢????????????????????????int??????????????????
	 * @param target ????±??????????
	 * @return ???????????????
	 */
	private static int convertInt(int target) {
		if (target == 83)
			return 0;
		if (target == 71)
			return 6;
		if (target >= 49 && target <= 53)
			return target - 48;
		return 9;
	}

	/**
	 * X????????????????????´?????????????????¢???????±???§????¨????<br>
	 * ????????????:0?????´??????:6???????????¢???????±???§:1???5<br>
	 * Y????????????????????????????????????????´?
	 * @param type ?????????????????´?????????????????¢???????±???§
	 * @param index ??????????????????????????????
	 * @return
	 */
	private static Point createPos(int type, int index) {
		return new Point(type, index);
	}

	/**
	 * ?????¨????????¢???????????????????????????????????????????????¢???????±???§?????????
	 * @param currentType ??????????????????????????¢???????±???§
	 * @return ?????????????????????????????¢???????±???§
	 */
	private static int getNextType(int currentType) {
		if (currentType == 5)
			return 1;
		return currentType + 1;
	}

	/**
	 * ??????????????????????????¢?????????????????????????????????????????¢???????±???§?????????
	 * @param firstType ??????????????????????????¢???????±???§
	 * @return ?????????????????????????????¢???????±???§
	 */
	private static int getEndType(int firstType) {
		if (firstType == 1)
			return 5;
		return firstType - 1;
	}

	/**
	 * ??£??\??????????¨?????????????????????????????????´???????????§???<br>
	 * ????????????????????????????±???????
	 * @param adjacent ??£??\??????
	 * @return ????????????????????????
	 */
	private static int searchRoute(int firstType) {

		for (int i = 0; i < maxNode; i++) {
			cost[i] = Integer.MAX_VALUE;
			visited[i] = false;
		}

		// ??????????????°????????§???????????????0
		cost[startIdx] = 0;

		while (true) {
			// ?¨?????????????????????????????????§?????????????????????????±???????
			int node = minIndex(cost, visited);
			if (node < 0) {
				return cost[goalIdx];
			}
			// ??¢?´¢???????????????????????????????????°????????????
			visited[node] = true;
			for (int j = 0; j < maxNode; j++) {
				if (isLinked(node, j, firstType) && !visited[j]) {
					int nextNodeCost = cost[node] + clucCost(pachimonList.get(node), pachimonList.get(j));
					// ????????§????????¢??????????°????????????°???????????¢??¨???????¨???¶
					if (nextNodeCost < cost[j]) {
						cost[j] = nextNodeCost;
					}
				}
			}
		}
	}

	/**
	 * ?????¨??????????????¨????±??????????????????\?¶?????????????????????????????????\
	 * @param node ?????¨????????????
	 * @param target ????±?????????????
	 * @return ?????\??????
	 */
	private static boolean isLinked(int node, int target, int firstType) {
		int currentType = pachimonList.get(node).x;
		int targetType = pachimonList.get(target).x;
		// ??????????????¢?????¨???????±???§?????????????????????????????????????????\?¶????????????????
		if (currentType == firstType)
			return false;
		// ????±??????????????????¢?????¨???????±???§?????´????????\?¶????????????????
		if (targetType == firstType)
			return false;
		// ??????????????´???????????´????????\?¶??????????????????????????????????
		if (currentType == maxNode)
			return false;

		// ????????????????????????(""0"")?????´??????????±???????????????????????????¢???????±???§????¬?????????\?¶????????????????
		if (currentType == 0)
			return targetType == getNextType(firstType);

		// ?????¨????????????????±???§????????????????????????????????¢????????´????????´??????????????\?¶?
		if (currentType == getEndType(firstType))
			return targetType == 6;

		return getNextType(currentType) == targetType;
	}

	/**
	 * ?¨???????????????????????????????????????????????????????????????????????????????????±???????
	 * @param cost ???????????????????????????
	 * @param visited ?????????????¨??????????????????????????´???????
	 * @return ??????????????????
	 */
	private static int minIndex(int[] cost, boolean[] visited) {
		int index = 0;
		for (; index < maxNode; index++) {
			if (!visited[index])
				break;
		}
		if (index == maxNode)
			return -1;
		for (int i = index + 1; i < maxNode; i++) {
			if (!visited[i] && cost[i] < cost[index])
				index = i;
		}
		return index;
	}

	/**
	 * ????????????????????????????????´???????????§????????????????¨?????????????
	 * @param sx ???????????????X??§?¨?
	 * @param sy ???????????????Y??§?¨?
	 * @param gx ??´?????????X??§?¨?
	 * @param gy ??´?????????Y??§?¨?
	 * @param nextType ?¬????????????????????????¢????±???§
	 */
	private static int clucCost(Point from, Point to) {
		int fx = from.y / mapSizeY;
		int fy = from.y % mapSizeY;
		int tx = to.y / mapSizeY;
		int ty = to.y % mapSizeY;
		return Math.abs(tx - fx) + Math.abs(ty - fy);
	}

	/**
	 * X??§?¨???¨Y??§?¨???????????????£?????????????????????????????????????????´?????????
	 *
	 * @param x X??§?¨?
	 * @param y Y??§?¨?
	 * @return
	 */
	private static int calcIndex(int x, int y) {
		return x * mapSizeY + y;
	}
}",1
p00215,"パチモンクリーチャー
某国で
大人気のゲーム、パチモンクリーチャーが日本でリメイクされて発売されました。 ゲームが大好きなあなたは、  このゲームを
何度もプレイするうちにどうしたら最速でクリアできるのか考えるようになりました。しかし、いくら考えても最速の攻略方法がわからなかったあなたは、どれだけ早くゲームをクリアできるかを求めるプログラムを作成することにしました。
ゲームの詳細は以下の通りです。
パチモンクリーチャー(以下、パチクリ)という生物が多く存在する世界がゲームの舞台です。各パチクリは、火属性、氷属性、木属性、土属性、水属性の 5 種類の属性のいずれか１つの属性を持ちます。ゲームの主人公は、ゲーム開始時に好きな属性のパチクリ一匹を冒険のパートナーとして選びます。そのパチクリと共にゴールを目指し、ゴールにいるライバルを倒してパチクリマスターになることがゲームの目的です。
しかし、ライバルを倒すためには全属性のパチクリがいないと勝てないので、途中で全属性のパチクリを捕まえなければなりません。パチクリを捕まえるには属性がカギとなります。火属性のパチクリは氷属性のパチクリを捕まえることができ、同様に、氷属性は木属性、木属性は土属性、土属性は水属性、水属性は火属性を捕まえることができます。属性の関連は以下の図のようになります。
以下の図はゲームが行われるマップの一例を表しています。
主人公はパチクリを一匹もってスタート地点である「S」から出発し、一マスずつ移動しながらゴール地点である「G」を目指します。その途中で、最初に持っているパチクリ以外の 4 つの属性のパチクリを捕まえ、ゴール地点であるマス目に移動するとゲーム終了となります。
主人公は、今いるマス目から、辺を共有する隣のマス目に移動することができ、それを一回の移動と数えます。主人公がパチクリのいるマスに移動した場合、そのパチクリを捕まえられる属性のパチクリを持っていればそのパチクリを捕まえたことになります。そのマスにいるパチクリを捕まえられるかの可否にかかわらず、すべてのマスに何度でも移動することができます。
マップの大きさ(横方向の列数、縦方向の行数)とマップの初期状態を入力とし、初めに選んだパチクリの属性と、それ以外の 4 つの属性のパチクリを捕まえるのにかかる、スタート地点からゴール地点に至る最小移動数を出力するプログラムを作成してください。
Input
複数のデータセットの並びが入力として与えられます。入力の終りはゼロふたつの行で示されます。各データセットは以下の形式で与えられます。
W
H
c
11
c
12
...
c
1W
c
21
c
22
...
c
2W
:
c
H1
c
H2
...
c
HW
1 行目にマップの横方向の列数
W
と縦方向の行数
H
(2 ≤
W, H
≤ 1000) が与えられます。続く
H
行にマップの
i
行目の情報が与えられます。入力されるマップには各マスの状態が与えられます。     「S」は主人公のスタート地点を、  「G」はゴール地点を、「1」「2」「3」「4」「5」はそこにいるパチクリの属性を( 1:火属性、 2:氷属性、    3:木属性、 4:土属性、 5:水属性 をそれぞれ表します)、 「.(ピリオド) 」は何もないマスをそれぞれ表します。 
各属性のパチクリの数はそれぞれ 0 以上 1000 以下とします。
データセットの数は140 を超えません。また、データセットの 80 % について、
W, H
は100 を超えません。
Output
入力データセットごとに、最初に選んだパチクリの属性と最小移動数を１行に出力します。なお、どのように初めのパチクリを選んでも、どのような経路で移動してもそれら 4 つの属性のパチクリを捕まえることができない場合は NA と出力してください。  また、最小移動数が同じになるような最初のパチクリの選び方が複数ある場合は、属性の数字が小さいものを出力してください。
Sample Input
6 6
S.1..4
3..5..
..4.1.
4....5
.2.32.
5.1..G
3 2
...
S.G
0 0
Output for the Sample Input
2 10
NA",Python,"from collections import deque
import sys

def bfs(grid, start, H, W):
    """"""BFS to find shortest distances from start to all positions""""""
    dist = [[-1] * W for _ in range(H)]
    queue = deque([start])
    dist[start[0]][start[1]] = 0
    
    while queue:
        r, c = queue.popleft()
        for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:
            nr, nc = r + dr, c + dc
            if 0 <= nr < H and 0 <= nc < W and dist[nr][nc] == -1:
                dist[nr][nc] = dist[r][c] + 1
                queue.append((nr, nc))
    
    return dist

def solve(W, H, grid):
    # Find S and G positions
    start = goal = None
    creatures = {1: [], 2: [], 3: [], 4: [], 5: []}
    
    for i in range(H):
        for j in range(W):
            if grid[i][j] == 'S':
                start = (i, j)
            elif grid[i][j] == 'G':
                goal = (i, j)
            elif grid[i][j] in '12345':
                creatures[int(grid[i][j])].append((i, j))
    
    # can_catch[attr] gives which attribute attr can catch
    can_catch = {1: 2, 2: 3, 3: 4, 4: 5, 5: 1}
    
    # Compute distances from start and goal
    dist_from_start = bfs(grid, start, H, W)
    dist_from_goal = bfs(grid, goal, H, W)
    
    # For each creature position, compute distance from start and to goal
    creature_dists = {}
    for attr in range(1, 6):
        creature_dists[attr] = []
        for pos in creatures[attr]:
            ds = dist_from_start[pos[0]][pos[1]]
            dg = dist_from_goal[pos[0]][pos[1]]
            if ds != -1 and dg != -1:
                creature_dists[attr].append((ds, dg, pos))
    
    best_attr = None
    best_dist = float('inf')
    
    # Try each starting attribute
    for start_attr in range(1, 6):
        # Need to catch the other 4 attributes
        to_catch = [attr for attr in range(1, 6) if attr != start_attr]
        
        # Check if we can catch all required attributes
        can_solve = True
        for attr in to_catch:
            if not creature_dists[attr]:
                can_solve = False
                break
        
        if not can_solve:
            continue
        
        # State: (current_attr, caught_set) where caught_set is a frozenset of caught attributes
        # We want to find minimum distance to reach goal with all attributes caught
        
        # Use Dijkstra-like approach with states
        from heapq import heappush, heappop
        
        initial_state = (start_attr, frozenset([start_attr]))
        # dist_state[(attr, caught)] = minimum distance to have attr and caught set
        dist_state = {}
        dist_state[initial_state] = 0
        pq = [(0, start_attr, frozenset([start_attr]))]
        
        min_dist_to_goal = float('inf')
        
        while pq:
            d, curr_attr, caught = heappop(pq)
            
            if d > dist_state.get((curr_attr, caught), float('inf')):
                continue
            
            # Check if we have all attributes and can go to goal
            if len(caught) == 5:
                min_dist_to_goal = min(min_dist_to_goal, d + dist_from_goal[start[0]][start[1]])
                continue
            
            # Try to catch next creature
            next_attr = can_catch[curr_attr]
            if next_attr not in caught and creature_dists[next_attr]:
                # Find closest creature of next_attr from current position
                # We need to track position too...
                
                for ds, dg, pos in creature_dists[next_attr]:
                    new_caught = caught | {next_attr}
                    new_dist = ds  # Distance from start to this creature
                    new_state = (next_attr, new_caught)
                    
                    if new_dist < dist_state.get(new_state, float('inf')):
                        dist_state[new_state] = new_dist
                        heappush(pq, (new_dist, next_attr, new_caught))
        
        # This approach is getting complex. Let me try simpler state space.
        # State: frozenset of caught attributes
        # For each state, track minimum distance and where we are
        
        # Actually, let's use different approach
        # Try all permutations of catching order and compute minimum
        
        from itertools import permutations
        
        for order in permutations(to_catch):
            # Check if this order is valid (can catch in sequence)
            current_attr = start_attr
            valid = True
            for attr in order:
                if can_catch[current_attr] != attr:
                    valid = False
                    break
                current_attr = attr
            
            if not valid:
                continue
            
            # Compute minimum distance for this order
            total_dist = 0
            prev_pos = start
            valid_path = True
            
            for attr in order:
                # Find closest creature of this attribute from prev_pos
                min_d = float('inf')
                next_pos = None
                
                for pos in creatures[attr]:
                    # BFS from prev_pos to pos
                    d = dist_from_start[pos[0]][pos[1]]  # This is wrong, need distance from prev_pos
                    
                # This is getting complicated. Need to precompute all distances
                
        # Let me use a simpler DP approach with memoization
        
    # Simpler approach: try all orderings using DP
    # Actually the constraints make this feasible
    
    # For each starting attribute, do BFS on state space
    for start_attr in range(1, 6):
        # BFS on (position, caught_set)
        initial = (start, frozenset([start_attr]), start_attr)
        queue = deque([initial])
        visited = {(start, frozenset([start_attr]), start_attr): 0}
        
        while queue:
            pos, caught, curr_attr = queue.popleft()
            dist = visited[(pos, caught, curr_attr)]
            
            # If we have all 5 attributes and at goal
            if len(caught) == 5 and pos == goal:
                if dist < best_dist or (dist == best_dist and start_attr < best_attr):
                    best_dist = dist
                    best_attr = start_attr
                continue
            
            # Try moving to adjacent cells
            for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:
                nr, nc = pos[0] + dr, pos[1] + dc
                if 0 <= nr < H and 0 <= nc < W:
                    new_pos = (nr, nc)
                    new_caught = caught
                    new_attr = curr_attr
                    
                    # Check if we catch a creature here
                    cell = grid[nr][nc]
                    if cell in '12345':
                        creature_attr = int(cell)
                        if can_catch[curr_attr] == creature_attr:
                            new_caught = caught | {creature_attr}
                            new_attr = creature_attr
                    
                    new_state = (new_pos, new_caught, new_attr)
                    if new_state not in visited or visited[new_state] > dist + 1:
                        visited[new_state] = dist + 1
                        queue.append(new_state)
    
    if best_attr is None:
        return ""NA""
    else:
        return f""{best_attr} {best_dist}""

while True:
    line = input().split()
    W, H = int(line[0]), int(line[1])
    if W == 0 and H == 0:
        break
    
    grid = []
    for _ in range(H):
        grid.append(input().strip())
    
    print(solve(W, H, grid))
",0
p00215,"パチモンクリーチャー
某国で
大人気のゲーム、パチモンクリーチャーが日本でリメイクされて発売されました。 ゲームが大好きなあなたは、  このゲームを
何度もプレイするうちにどうしたら最速でクリアできるのか考えるようになりました。しかし、いくら考えても最速の攻略方法がわからなかったあなたは、どれだけ早くゲームをクリアできるかを求めるプログラムを作成することにしました。
ゲームの詳細は以下の通りです。
パチモンクリーチャー(以下、パチクリ)という生物が多く存在する世界がゲームの舞台です。各パチクリは、火属性、氷属性、木属性、土属性、水属性の 5 種類の属性のいずれか１つの属性を持ちます。ゲームの主人公は、ゲーム開始時に好きな属性のパチクリ一匹を冒険のパートナーとして選びます。そのパチクリと共にゴールを目指し、ゴールにいるライバルを倒してパチクリマスターになることがゲームの目的です。
しかし、ライバルを倒すためには全属性のパチクリがいないと勝てないので、途中で全属性のパチクリを捕まえなければなりません。パチクリを捕まえるには属性がカギとなります。火属性のパチクリは氷属性のパチクリを捕まえることができ、同様に、氷属性は木属性、木属性は土属性、土属性は水属性、水属性は火属性を捕まえることができます。属性の関連は以下の図のようになります。
以下の図はゲームが行われるマップの一例を表しています。
主人公はパチクリを一匹もってスタート地点である「S」から出発し、一マスずつ移動しながらゴール地点である「G」を目指します。その途中で、最初に持っているパチクリ以外の 4 つの属性のパチクリを捕まえ、ゴール地点であるマス目に移動するとゲーム終了となります。
主人公は、今いるマス目から、辺を共有する隣のマス目に移動することができ、それを一回の移動と数えます。主人公がパチクリのいるマスに移動した場合、そのパチクリを捕まえられる属性のパチクリを持っていればそのパチクリを捕まえたことになります。そのマスにいるパチクリを捕まえられるかの可否にかかわらず、すべてのマスに何度でも移動することができます。
マップの大きさ(横方向の列数、縦方向の行数)とマップの初期状態を入力とし、初めに選んだパチクリの属性と、それ以外の 4 つの属性のパチクリを捕まえるのにかかる、スタート地点からゴール地点に至る最小移動数を出力するプログラムを作成してください。
Input
複数のデータセットの並びが入力として与えられます。入力の終りはゼロふたつの行で示されます。各データセットは以下の形式で与えられます。
W
H
c
11
c
12
...
c
1W
c
21
c
22
...
c
2W
:
c
H1
c
H2
...
c
HW
1 行目にマップの横方向の列数
W
と縦方向の行数
H
(2 ≤
W, H
≤ 1000) が与えられます。続く
H
行にマップの
i
行目の情報が与えられます。入力されるマップには各マスの状態が与えられます。     「S」は主人公のスタート地点を、  「G」はゴール地点を、「1」「2」「3」「4」「5」はそこにいるパチクリの属性を( 1:火属性、 2:氷属性、    3:木属性、 4:土属性、 5:水属性 をそれぞれ表します)、 「.(ピリオド) 」は何もないマスをそれぞれ表します。 
各属性のパチクリの数はそれぞれ 0 以上 1000 以下とします。
データセットの数は140 を超えません。また、データセットの 80 % について、
W, H
は100 を超えません。
Output
入力データセットごとに、最初に選んだパチクリの属性と最小移動数を１行に出力します。なお、どのように初めのパチクリを選んでも、どのような経路で移動してもそれら 4 つの属性のパチクリを捕まえることができない場合は NA と出力してください。  また、最小移動数が同じになるような最初のパチクリの選び方が複数ある場合は、属性の数字が小さいものを出力してください。
Sample Input
6 6
S.1..4
3..5..
..4.1.
4....5
.2.32.
5.1..G
3 2
...
S.G
0 0
Output for the Sample Input
2 10
NA",Python,"from itertools import product
# from line_profiler import LineProfiler
def main():
    while(True):
        W, H = map(int,input().split())
        if not W: break
        # ma = [[-1]*(W+2) for _ in range(H+2)]
        ps = [[] for _ in range(5)]
        ans = 10**10
        for i in range(H):
            for j,a in enumerate(input()):
                if a == ""S"": ss = [[i,j]]
                elif a == ""G"": gg = [[i,j]]
                elif a != ""."": ps[int(a)-1].append([i,j])
        # if [1 for i in range(5) if len(ps[i])==0]:
        #     print(""NA""); continue
        # print(ps)
        B = float(""inf"")
        Bi = -1
        for mon1 in range(5):
            dp = [[float(""inf"")]*1000 for _ in range(5)]
            cand = [[0,ss[0][0],ss[0][1]]]
            for mon2 in range(5):
                dpCacheNow = dp[mon2]
                dpCacheNxt = dp[(mon1+mon2+1)%5]
                dpCacheNow[0] = 0
                nxt = ps[(mon1+mon2+1)%5] if mon2<4 else gg
                # print(nxt)
                # print(cand)
                tmp = []
                for i,[ty,tx] in enumerate(nxt):
                    # if dpCacheNow[i] >= B:
                    #     continue
                    tc = float(""inf"")
                    # for cc,cy,cx in cand:
                    for cc,cy,cx in cand:
                        if cc > B:
                            # print(""a"",end="""")
                            tc = float(""inf"")
                            break
                        else:
                            tc = min(tc,abs(ty-cy)+abs(tx-cx)+cc)
                    tmp.append([tc,ty,tx])
                    dpCacheNxt[i] = min(dpCacheNxt[i],tc)
                cand = tmp
            if cand[0][0] < B:
                B = cand[0][0]
                Bi = mon1
        if(Bi == -1):
            print(""NA"")
        else:
            print(""%d %d""%(Bi+1,B))
        # for mon1 in range(5):
        #     mon2 = (mon1+1)%5
        #     dp = [[10**10]*1000 for _ in range(5)]
        #     for i,yx in enumerate(ps[mon2]):
        #         dp[mon2][i] = abs(ss[0]-yx[0])+abs(ss[1]-yx[1])
        #     mon3 = mon2
        #     for mon3 in range(mon2,mon2+3):
        #         mon3 = mon3%5
        #         mon4 = (mon3+1)%5
        #         for [i,yx],[j,nyx] in product(enumerate(ps[mon3]),enumerate(ps[mon4])):
        #             dp[mon4][j] = min(dp[mon4][j],dp[mon3][i]+abs(yx[0]-nyx[0])+abs(yx[1]-nyx[1]))
        #     mon5 = (mon1-1)%5
        #     for i,yx in enumerate(ps[mon5]):
        #         d = dp[mon5][i] + abs(gg[0]-yx[0])+abs(gg[1]-yx[1])
        #         if ans > d:
        #             ans,ansi = d,mon1
        # print(ansi+1,ans)

if __name__ == ""__main__"":
    # prf = LineProfiler()
    # prf.add_function(main)
    # prf.runcall(main)
    # prf.print_stats()
    main()
",1
p00216,"水道料金
松平さんは、普段からエコに気を付けて生活をしています。先月の水道料金が 4280 円となり、いつも目標としている 4000 円を超えてしまったので、今月は節水に努めてきました。先月と比べて水道料金はどのくらい節約できたのでしょうか。
今月の使用水量
w
[m
3
] を入力とし、先月の水道料金である 4280 円と比較して、どのくらい水道料金を節約できたかを出力するプログラムを作成してください。
なお、水道料金は次のように計算されます。
(水道料金) = (基本料金) + (水量による料金)
水量による料金は下表のように使用量に応じて計算されます。
段階
水量
料金
第 1 段階料金
10 [m
3
] まで
基本料金 1150 円
第 2 段階料金
10 [m
3
] 超過 20 [m
3
] まで
1 [m
3
] あたり 125 円
第 3 段階料金
20 [m
3
] 超過 30 [m
3
] まで
1 [m
3
] あたり 140 円
第 4 段階料金
30 [m
3
] 超過分
1 [m
3
] あたり 160 円
例えば、使用水量 40 [m
3
] の場合は、
基本料金 1150 円(第 1 段階) + 10 [m
3
] × 125 円(第 2 段階) + 10 [m
3
] × 140 円(第 3 段階) + 10 [m
3
] × 160 円(第 4 段階) = 5400 円 

 となります。
Input
複数のデータセットの並びが入力として与えられます。入力の終わりは -1 ひとつの行で示されます。
各データセットとして、 今月の使用水量を表す整数
w
(0 ≤
w
≤ 100) が１行に与えられます。
データセットの数は 200 を超えません。
Output
入力データセットごとに、先月の水道料金との差を1行に出力します。
Sample Input
29
40
0
-1
Output for the Sample Input
620
-1120
3130",C,"#include <stdio.h>

int calculate_bill(int w) {
    int bill = 1150; // base charge
    
    if (w <= 10) {
        return bill;
    }
    
    if (w <= 20) {
        bill += (w - 10) * 125;
        return bill;
    }
    
    bill += 10 * 125;
    
    if (w <= 30) {
        bill += (w - 20) * 140;
        return bill;
    }
    
    bill += 10 * 140;
    bill += (w - 30) * 160;
    
    return bill;
}

int main() {
    int w;
    int last_month = 4280;
    
    while (1) {
        scanf(""%d"", &w);
        if (w == -1) break;
        
        int current_bill = calculate_bill(w);
        int savings = last_month - current_bill;
        
        printf(""%d\n"", savings);
    }
    
    return 0;
}
",0
p00216,"水道料金
松平さんは、普段からエコに気を付けて生活をしています。先月の水道料金が 4280 円となり、いつも目標としている 4000 円を超えてしまったので、今月は節水に努めてきました。先月と比べて水道料金はどのくらい節約できたのでしょうか。
今月の使用水量
w
[m
3
] を入力とし、先月の水道料金である 4280 円と比較して、どのくらい水道料金を節約できたかを出力するプログラムを作成してください。
なお、水道料金は次のように計算されます。
(水道料金) = (基本料金) + (水量による料金)
水量による料金は下表のように使用量に応じて計算されます。
段階
水量
料金
第 1 段階料金
10 [m
3
] まで
基本料金 1150 円
第 2 段階料金
10 [m
3
] 超過 20 [m
3
] まで
1 [m
3
] あたり 125 円
第 3 段階料金
20 [m
3
] 超過 30 [m
3
] まで
1 [m
3
] あたり 140 円
第 4 段階料金
30 [m
3
] 超過分
1 [m
3
] あたり 160 円
例えば、使用水量 40 [m
3
] の場合は、
基本料金 1150 円(第 1 段階) + 10 [m
3
] × 125 円(第 2 段階) + 10 [m
3
] × 140 円(第 3 段階) + 10 [m
3
] × 160 円(第 4 段階) = 5400 円 

 となります。
Input
複数のデータセットの並びが入力として与えられます。入力の終わりは -1 ひとつの行で示されます。
各データセットとして、 今月の使用水量を表す整数
w
(0 ≤
w
≤ 100) が１行に与えられます。
データセットの数は 200 を超えません。
Output
入力データセットごとに、先月の水道料金との差を1行に出力します。
Sample Input
29
40
0
-1
Output for the Sample Input
620
-1120
3130",C,"#include<stdio.h>
int main(void)
{
		int n,t,i,k,j,g,s,r,a,w,z,o;
	while(1)	{
		scanf(""%d"",&t);
		if(t==-1)	break;
		if(10>=t){
			printf(""3130\n"");
			}
		if(t>10&&t<20){
			n=t-10;
			i=4280-(n*125+1150);
			printf(""%d\n"",i);
			}
		if(t>20&&t<30){
			k=t-20;
			j=4280-((k*140)+2400);
			printf(""%d\n"",j);
		}
		if(t>30){
			s=t-30;
			g=4280-((s*160)+3800);
			printf(""%d\n"",g);
		}	
	}
	return 0;
}",1
p00216,"水道料金
松平さんは、普段からエコに気を付けて生活をしています。先月の水道料金が 4280 円となり、いつも目標としている 4000 円を超えてしまったので、今月は節水に努めてきました。先月と比べて水道料金はどのくらい節約できたのでしょうか。
今月の使用水量
w
[m
3
] を入力とし、先月の水道料金である 4280 円と比較して、どのくらい水道料金を節約できたかを出力するプログラムを作成してください。
なお、水道料金は次のように計算されます。
(水道料金) = (基本料金) + (水量による料金)
水量による料金は下表のように使用量に応じて計算されます。
段階
水量
料金
第 1 段階料金
10 [m
3
] まで
基本料金 1150 円
第 2 段階料金
10 [m
3
] 超過 20 [m
3
] まで
1 [m
3
] あたり 125 円
第 3 段階料金
20 [m
3
] 超過 30 [m
3
] まで
1 [m
3
] あたり 140 円
第 4 段階料金
30 [m
3
] 超過分
1 [m
3
] あたり 160 円
例えば、使用水量 40 [m
3
] の場合は、
基本料金 1150 円(第 1 段階) + 10 [m
3
] × 125 円(第 2 段階) + 10 [m
3
] × 140 円(第 3 段階) + 10 [m
3
] × 160 円(第 4 段階) = 5400 円 

 となります。
Input
複数のデータセットの並びが入力として与えられます。入力の終わりは -1 ひとつの行で示されます。
各データセットとして、 今月の使用水量を表す整数
w
(0 ≤
w
≤ 100) が１行に与えられます。
データセットの数は 200 を超えません。
Output
入力データセットごとに、先月の水道料金との差を1行に出力します。
Sample Input
29
40
0
-1
Output for the Sample Input
620
-1120
3130",Java,"import java.util.Scanner;

public class Main {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        
        while (true) {
            int w = sc.nextInt();
            if (w == -1) break;
            
            int currentBill = calculateBill(w);
            int difference = 4280 - currentBill;
            System.out.println(difference);
        }
        
        sc.close();
    }
    
    static int calculateBill(int w) {
        int bill = 1150; // Base charge
        
        if (w <= 10) {
            return bill;
        }
        
        // Second tier: 10 < w <= 20
        if (w <= 20) {
            bill += (w - 10) * 125;
            return bill;
        }
        
        bill += 10 * 125; // Full second tier
        
        // Third tier: 20 < w <= 30
        if (w <= 30) {
            bill += (w - 20) * 140;
            return bill;
        }
        
        bill += 10 * 140; // Full third tier
        
        // Fourth tier: w > 30
        bill += (w - 30) * 160;
        
        return bill;
    }
}
",0
p00216,"水道料金
松平さんは、普段からエコに気を付けて生活をしています。先月の水道料金が 4280 円となり、いつも目標としている 4000 円を超えてしまったので、今月は節水に努めてきました。先月と比べて水道料金はどのくらい節約できたのでしょうか。
今月の使用水量
w
[m
3
] を入力とし、先月の水道料金である 4280 円と比較して、どのくらい水道料金を節約できたかを出力するプログラムを作成してください。
なお、水道料金は次のように計算されます。
(水道料金) = (基本料金) + (水量による料金)
水量による料金は下表のように使用量に応じて計算されます。
段階
水量
料金
第 1 段階料金
10 [m
3
] まで
基本料金 1150 円
第 2 段階料金
10 [m
3
] 超過 20 [m
3
] まで
1 [m
3
] あたり 125 円
第 3 段階料金
20 [m
3
] 超過 30 [m
3
] まで
1 [m
3
] あたり 140 円
第 4 段階料金
30 [m
3
] 超過分
1 [m
3
] あたり 160 円
例えば、使用水量 40 [m
3
] の場合は、
基本料金 1150 円(第 1 段階) + 10 [m
3
] × 125 円(第 2 段階) + 10 [m
3
] × 140 円(第 3 段階) + 10 [m
3
] × 160 円(第 4 段階) = 5400 円 

 となります。
Input
複数のデータセットの並びが入力として与えられます。入力の終わりは -1 ひとつの行で示されます。
各データセットとして、 今月の使用水量を表す整数
w
(0 ≤
w
≤ 100) が１行に与えられます。
データセットの数は 200 を超えません。
Output
入力データセットごとに、先月の水道料金との差を1行に出力します。
Sample Input
29
40
0
-1
Output for the Sample Input
620
-1120
3130",Java,"import java.util.*;
public class Main {
    static Scanner kbd = new Scanner(System.in);
    public static void main(String[] args){
	while(kbd.hasNext()) {
	    int w = kbd.nextInt();
	    if(w!=-1){
		System.out.println(4280-solve(w));
	    }
	}
    }

    static int solve(int w) {
	int r = 0;
	int bill = 0;
	while(w>=0){
	    bill += cost(w, r);
	    w -= 10;
	    r ++;
	    //System.out.println(""p"");
	}
	return bill;
    }

    static int cost(int w, int r){
	if(r==0){ return 1150; }
	else if(r==1){ 
	    if(w>=10) return 125*10;
	    else return 125*w;
	}
	else if(r==2){
	    if(w>=10) return 140*10;
	    else return 140*w;
	}
	else if(r>2){
	    if(w>=10) return 160*10;
	    else return 160*w;
	}
	else return 0;
    }
}",1
p00216,"水道料金
松平さんは、普段からエコに気を付けて生活をしています。先月の水道料金が 4280 円となり、いつも目標としている 4000 円を超えてしまったので、今月は節水に努めてきました。先月と比べて水道料金はどのくらい節約できたのでしょうか。
今月の使用水量
w
[m
3
] を入力とし、先月の水道料金である 4280 円と比較して、どのくらい水道料金を節約できたかを出力するプログラムを作成してください。
なお、水道料金は次のように計算されます。
(水道料金) = (基本料金) + (水量による料金)
水量による料金は下表のように使用量に応じて計算されます。
段階
水量
料金
第 1 段階料金
10 [m
3
] まで
基本料金 1150 円
第 2 段階料金
10 [m
3
] 超過 20 [m
3
] まで
1 [m
3
] あたり 125 円
第 3 段階料金
20 [m
3
] 超過 30 [m
3
] まで
1 [m
3
] あたり 140 円
第 4 段階料金
30 [m
3
] 超過分
1 [m
3
] あたり 160 円
例えば、使用水量 40 [m
3
] の場合は、
基本料金 1150 円(第 1 段階) + 10 [m
3
] × 125 円(第 2 段階) + 10 [m
3
] × 140 円(第 3 段階) + 10 [m
3
] × 160 円(第 4 段階) = 5400 円 

 となります。
Input
複数のデータセットの並びが入力として与えられます。入力の終わりは -1 ひとつの行で示されます。
各データセットとして、 今月の使用水量を表す整数
w
(0 ≤
w
≤ 100) が１行に与えられます。
データセットの数は 200 を超えません。
Output
入力データセットごとに、先月の水道料金との差を1行に出力します。
Sample Input
29
40
0
-1
Output for the Sample Input
620
-1120
3130",Python,"def calculate_water_bill(w):
    if w <= 10:
        return 1150
    elif w <= 20:
        return 1150 + (w - 10) * 125
    elif w <= 30:
        return 1150 + 10 * 125 + (w - 20) * 140
    else:
        return 1150 + 10 * 125 + 10 * 140 + (w - 30) * 160

last_month_bill = 4280

while True:
    w = int(input())
    if w == -1:
        break
    
    current_bill = calculate_water_bill(w)
    savings = last_month_bill - current_bill
    print(savings)
",0
p00216,"水道料金
松平さんは、普段からエコに気を付けて生活をしています。先月の水道料金が 4280 円となり、いつも目標としている 4000 円を超えてしまったので、今月は節水に努めてきました。先月と比べて水道料金はどのくらい節約できたのでしょうか。
今月の使用水量
w
[m
3
] を入力とし、先月の水道料金である 4280 円と比較して、どのくらい水道料金を節約できたかを出力するプログラムを作成してください。
なお、水道料金は次のように計算されます。
(水道料金) = (基本料金) + (水量による料金)
水量による料金は下表のように使用量に応じて計算されます。
段階
水量
料金
第 1 段階料金
10 [m
3
] まで
基本料金 1150 円
第 2 段階料金
10 [m
3
] 超過 20 [m
3
] まで
1 [m
3
] あたり 125 円
第 3 段階料金
20 [m
3
] 超過 30 [m
3
] まで
1 [m
3
] あたり 140 円
第 4 段階料金
30 [m
3
] 超過分
1 [m
3
] あたり 160 円
例えば、使用水量 40 [m
3
] の場合は、
基本料金 1150 円(第 1 段階) + 10 [m
3
] × 125 円(第 2 段階) + 10 [m
3
] × 140 円(第 3 段階) + 10 [m
3
] × 160 円(第 4 段階) = 5400 円 

 となります。
Input
複数のデータセットの並びが入力として与えられます。入力の終わりは -1 ひとつの行で示されます。
各データセットとして、 今月の使用水量を表す整数
w
(0 ≤
w
≤ 100) が１行に与えられます。
データセットの数は 200 を超えません。
Output
入力データセットごとに、先月の水道料金との差を1行に出力します。
Sample Input
29
40
0
-1
Output for the Sample Input
620
-1120
3130",Python,"def fee(w):
    if w>30:
        return (w-30)*160+10*140+10*125+1150
    if w>20:
        return (w-20)*140+10*125+1150
    if w>10:
        return (w-10)*125+1150
    return 1150

prev_m=4280
while True:
    W=int(input())
    if W==-1:
        break
    print(prev_m-fee(W))
    # prev_m=fee(W)

",1
p00217,"ウォーキング
会津リバーサイドホスピタルでは、リハビリと健康増進のため、入院患者が一日二回のウォーキングを行っています。元気に退院するために、ウォーキングで体力を回復しようと頑張る人が日に日に増えきたことから、院長が「一日で一番長い距離を歩いた人にプレゼントをあげよう!」という企画を立ち上げました。
患者の数
n
(1 ≤
n
≤ 10000)、それぞれの患者の番号
p
i
(1 ≤
p
i
≤ 10000)、一回目に歩いた距離
d1
i
、二回目に歩いた距離
d2
i
(0 ≤
d1
i
,
d2
i
≤ 5000) を入力とし、歩いた距離の合計が最も長い患者の番号とその距離を出力するプログラムを作成してください。ただし、一日に歩いた距離が同じ患者はいないものとします。
Input
複数のデータセットの並びが入力として与えられます。入力の終わりはゼロひとつの行で示されます。
各データセットは以下の形式で与えられます。
n
p
1
d1
1
d2
1
p
2
d1
2
d2
2
:
p
n
d1
n
d2
n
入力はすべて整数で与えられます。データセットの数は50 を超えません。
Output
入力データセットごとに、最も長い合計距離を歩いた患者の番号とその歩いた距離を１行に出力します。
Sample Input
5
263 2345 2504
1 3210 1985
5000 1501 4132
10000 503 3107
51 1758 2690
3
345 5000 2396
7 3910 1590
6789 2525 3616
0
Output for the Sample Input
5000 5633
345 7396",C,"#include <stdio.h>

int main() {
    int n;
    
    while(1) {
        scanf(""%d"", &n);
        if(n == 0) break;
        
        int max_id = 0;
        int max_distance = -1;
        
        for(int i = 0; i < n; i++) {
            int p, d1, d2;
            scanf(""%d %d %d"", &p, &d1, &d2);
            int total = d1 + d2;
            
            if(total > max_distance) {
                max_distance = total;
                max_id = p;
            }
        }
        
        printf(""%d %d\n"", max_id, max_distance);
    }
    
    return 0;
}
",0
p00217,"ウォーキング
会津リバーサイドホスピタルでは、リハビリと健康増進のため、入院患者が一日二回のウォーキングを行っています。元気に退院するために、ウォーキングで体力を回復しようと頑張る人が日に日に増えきたことから、院長が「一日で一番長い距離を歩いた人にプレゼントをあげよう!」という企画を立ち上げました。
患者の数
n
(1 ≤
n
≤ 10000)、それぞれの患者の番号
p
i
(1 ≤
p
i
≤ 10000)、一回目に歩いた距離
d1
i
、二回目に歩いた距離
d2
i
(0 ≤
d1
i
,
d2
i
≤ 5000) を入力とし、歩いた距離の合計が最も長い患者の番号とその距離を出力するプログラムを作成してください。ただし、一日に歩いた距離が同じ患者はいないものとします。
Input
複数のデータセットの並びが入力として与えられます。入力の終わりはゼロひとつの行で示されます。
各データセットは以下の形式で与えられます。
n
p
1
d1
1
d2
1
p
2
d1
2
d2
2
:
p
n
d1
n
d2
n
入力はすべて整数で与えられます。データセットの数は50 を超えません。
Output
入力データセットごとに、最も長い合計距離を歩いた患者の番号とその歩いた距離を１行に出力します。
Sample Input
5
263 2345 2504
1 3210 1985
5000 1501 4132
10000 503 3107
51 1758 2690
3
345 5000 2396
7 3910 1590
6789 2525 3616
0
Output for the Sample Input
5000 5633
345 7396",C,"#include<stdio.h>
int main()
{
	int i,a,b,c,d,max=0,s=0;
	scanf(""%d"",&a);
	while(a!=0){
		s=0;
max=0;
	for(i=0;i<a;i++){
		scanf(""%d %d %d"",&b,&c,&d);
		c=c+d;
		if(max<c){
			max=c;
			s=b;
		}
	}
	
	printf(""%d %d\n"",s,max);
	scanf(""%d"",&a);
	}
	return 0;
}",1
p00217,"ウォーキング
会津リバーサイドホスピタルでは、リハビリと健康増進のため、入院患者が一日二回のウォーキングを行っています。元気に退院するために、ウォーキングで体力を回復しようと頑張る人が日に日に増えきたことから、院長が「一日で一番長い距離を歩いた人にプレゼントをあげよう!」という企画を立ち上げました。
患者の数
n
(1 ≤
n
≤ 10000)、それぞれの患者の番号
p
i
(1 ≤
p
i
≤ 10000)、一回目に歩いた距離
d1
i
、二回目に歩いた距離
d2
i
(0 ≤
d1
i
,
d2
i
≤ 5000) を入力とし、歩いた距離の合計が最も長い患者の番号とその距離を出力するプログラムを作成してください。ただし、一日に歩いた距離が同じ患者はいないものとします。
Input
複数のデータセットの並びが入力として与えられます。入力の終わりはゼロひとつの行で示されます。
各データセットは以下の形式で与えられます。
n
p
1
d1
1
d2
1
p
2
d1
2
d2
2
:
p
n
d1
n
d2
n
入力はすべて整数で与えられます。データセットの数は50 を超えません。
Output
入力データセットごとに、最も長い合計距離を歩いた患者の番号とその歩いた距離を１行に出力します。
Sample Input
5
263 2345 2504
1 3210 1985
5000 1501 4132
10000 503 3107
51 1758 2690
3
345 5000 2396
7 3910 1590
6789 2525 3616
0
Output for the Sample Input
5000 5633
345 7396",Java,"import java.util.Scanner;

public class Main {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        
        while (true) {
            int n = sc.nextInt();
            if (n == 0) break;
            
            int maxPatient = 0;
            int maxDistance = 0;
            
            for (int i = 0; i < n; i++) {
                int p = sc.nextInt();
                int d1 = sc.nextInt();
                int d2 = sc.nextInt();
                int total = d1 + d2;
                
                if (total > maxDistance) {
                    maxDistance = total;
                    maxPatient = p;
                }
            }
            
            System.out.println(maxPatient + "" "" + maxDistance);
        }
        
        sc.close();
    }
}
",0
p00217,"ウォーキング
会津リバーサイドホスピタルでは、リハビリと健康増進のため、入院患者が一日二回のウォーキングを行っています。元気に退院するために、ウォーキングで体力を回復しようと頑張る人が日に日に増えきたことから、院長が「一日で一番長い距離を歩いた人にプレゼントをあげよう!」という企画を立ち上げました。
患者の数
n
(1 ≤
n
≤ 10000)、それぞれの患者の番号
p
i
(1 ≤
p
i
≤ 10000)、一回目に歩いた距離
d1
i
、二回目に歩いた距離
d2
i
(0 ≤
d1
i
,
d2
i
≤ 5000) を入力とし、歩いた距離の合計が最も長い患者の番号とその距離を出力するプログラムを作成してください。ただし、一日に歩いた距離が同じ患者はいないものとします。
Input
複数のデータセットの並びが入力として与えられます。入力の終わりはゼロひとつの行で示されます。
各データセットは以下の形式で与えられます。
n
p
1
d1
1
d2
1
p
2
d1
2
d2
2
:
p
n
d1
n
d2
n
入力はすべて整数で与えられます。データセットの数は50 を超えません。
Output
入力データセットごとに、最も長い合計距離を歩いた患者の番号とその歩いた距離を１行に出力します。
Sample Input
5
263 2345 2504
1 3210 1985
5000 1501 4132
10000 503 3107
51 1758 2690
3
345 5000 2396
7 3910 1590
6789 2525 3616
0
Output for the Sample Input
5000 5633
345 7396",Java,"import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.Iterator;


public class Main {

	private BufferedReader reader = new BufferedReader(new InputStreamReader(System.in), 1);

	private String inputData = null;

	public String[] data = null;

	public int num = 0;

	public int count = 0;

	public HashMap<Integer, Integer> humanData = new HashMap<Integer, Integer>();

	public ArrayList<Integer> topId = new ArrayList<Integer>();

	public ArrayList<Integer> topLength = new ArrayList<Integer>();

	public static void main(String[] args) {
		new Main().start();
		System.exit(0);
	}

	public void start() {
		while (true) {
			try {
				this.inputData = reader.readLine();
			} catch (IOException e) {
				e.printStackTrace();
			}

			this.data = this.inputData.split("" "");

			if (this.data.length == 1) {
				if (this.data[0].equals(""0"")) {
					break;
				}
				this.num = Integer.parseInt(this.data[0]);
			}

			this.humanData.clear();

			for (int i = 0; i < this.num; i++) {
				try {
					this.inputData = reader.readLine();
				} catch (IOException e) {
					e.printStackTrace();
				}
				this.data = this.inputData.split("" "");

				this.humanData.put(Integer.parseInt(data[0]),
						Integer.parseInt(data[1]) + Integer.parseInt(data[2]));

			}

			Iterator<Integer> itId = this.humanData.keySet().iterator();
			int numCount = 0;
			while (itId.hasNext()) {
				int id = itId.next();
				if (numCount == 0) {
					this.topId.add(id);
					this.topLength.add(this.humanData.get(id));
				} else {
					if (this.topLength.get(count) <= this.humanData.get(id)) {
						this.topId.set(this.count, id);
						this.topLength.set(this.count, this.humanData.get(id));
					}
				}
				numCount++;
			}

			this.count++;

		}

		for (int i = 0; i < this.topId.size(); i++) {
			System.out.println(this.topId.get(i) + "" "" + this.topLength.get(i));
		}

	}

}",1
p00217,"ウォーキング
会津リバーサイドホスピタルでは、リハビリと健康増進のため、入院患者が一日二回のウォーキングを行っています。元気に退院するために、ウォーキングで体力を回復しようと頑張る人が日に日に増えきたことから、院長が「一日で一番長い距離を歩いた人にプレゼントをあげよう!」という企画を立ち上げました。
患者の数
n
(1 ≤
n
≤ 10000)、それぞれの患者の番号
p
i
(1 ≤
p
i
≤ 10000)、一回目に歩いた距離
d1
i
、二回目に歩いた距離
d2
i
(0 ≤
d1
i
,
d2
i
≤ 5000) を入力とし、歩いた距離の合計が最も長い患者の番号とその距離を出力するプログラムを作成してください。ただし、一日に歩いた距離が同じ患者はいないものとします。
Input
複数のデータセットの並びが入力として与えられます。入力の終わりはゼロひとつの行で示されます。
各データセットは以下の形式で与えられます。
n
p
1
d1
1
d2
1
p
2
d1
2
d2
2
:
p
n
d1
n
d2
n
入力はすべて整数で与えられます。データセットの数は50 を超えません。
Output
入力データセットごとに、最も長い合計距離を歩いた患者の番号とその歩いた距離を１行に出力します。
Sample Input
5
263 2345 2504
1 3210 1985
5000 1501 4132
10000 503 3107
51 1758 2690
3
345 5000 2396
7 3910 1590
6789 2525 3616
0
Output for the Sample Input
5000 5633
345 7396",Python,"while True:
    n = int(input())
    if n == 0:
        break
    
    max_distance = -1
    max_patient = -1
    
    for _ in range(n):
        data = list(map(int, input().split()))
        patient_id = data[0]
        d1 = data[1]
        d2 = data[2]
        total_distance = d1 + d2
        
        if total_distance > max_distance:
            max_distance = total_distance
            max_patient = patient_id
    
    print(max_patient, max_distance)
",0
p00217,"ウォーキング
会津リバーサイドホスピタルでは、リハビリと健康増進のため、入院患者が一日二回のウォーキングを行っています。元気に退院するために、ウォーキングで体力を回復しようと頑張る人が日に日に増えきたことから、院長が「一日で一番長い距離を歩いた人にプレゼントをあげよう!」という企画を立ち上げました。
患者の数
n
(1 ≤
n
≤ 10000)、それぞれの患者の番号
p
i
(1 ≤
p
i
≤ 10000)、一回目に歩いた距離
d1
i
、二回目に歩いた距離
d2
i
(0 ≤
d1
i
,
d2
i
≤ 5000) を入力とし、歩いた距離の合計が最も長い患者の番号とその距離を出力するプログラムを作成してください。ただし、一日に歩いた距離が同じ患者はいないものとします。
Input
複数のデータセットの並びが入力として与えられます。入力の終わりはゼロひとつの行で示されます。
各データセットは以下の形式で与えられます。
n
p
1
d1
1
d2
1
p
2
d1
2
d2
2
:
p
n
d1
n
d2
n
入力はすべて整数で与えられます。データセットの数は50 を超えません。
Output
入力データセットごとに、最も長い合計距離を歩いた患者の番号とその歩いた距離を１行に出力します。
Sample Input
5
263 2345 2504
1 3210 1985
5000 1501 4132
10000 503 3107
51 1758 2690
3
345 5000 2396
7 3910 1590
6789 2525 3616
0
Output for the Sample Input
5000 5633
345 7396",Python,"while True:
    n = int(input())
    if n == 0:
        break

    patients = []
    for _ in range(n):
        p, d1, d2 = map(int, input().split())
        patients.append((p, d1+d2))
    print(*max(patients, key=lambda x: x[1]))",1
p00218,"クラス分け
会津進学塾では、生徒が塾に入る際に実力テストを行ってクラス分けをします。テストは数学、英語、国語の 3 科目行い、生徒を A,B,C クラスにクラス分けします。A クラスのレベルが一番高く、順に低くなっていきます。
クラス分けの判断は以下の表に基づきます。
条件
クラス
100 点の科目がある
A
数学と英語の平均点が 90 点以上
A
3 科目の平均点が 80 点以上
A
3 科目の平均点が 70 点以上
B
3 科目の平均点が 50 点以上で数学か英語が 80 点以上
B
上の条件を満たさない
C
複数の条件を満たす場合は、よりレベルの高いクラスに分けられます。
生徒の人数
n
(1 ≤
n
≤ 10000)、各生徒の数学の点数
pm
i
(0 ≤
pm
i
≤ 100)、英語の点数
pe
i
(0 ≤
pe
i
≤ 100)、国語の点数
pj
i
(0 ≤
pj
i
≤ 100) を入力とし、各生徒のクラスA,B,C (半角英字) を出力するプログラムを作成してください。
Input
複数のデータセットの並びが入力として与えられます。入力の終わりはゼロひとつの行で示されます。
各データセットは以下の形式で与えられます。
n
pm
1
pe
1
pj
1
pm
2
pe
2
pj
2
:
pm
n
pe
n
pj
n
入力はすべて整数で与えられます。データセットの数は 1000 を超えません。
Output
入力データセットごとに、各生徒のクラスを順番に出力します。
Sample Input
4
100 70 20
98 86 55
80 34 36
65 79 65
2
99 81 20
66 72 90
0
Output for the Sample Input
A
A
B
C
A
B",C,"#include <stdio.h>

int main() {
    int n;
    
    while(1) {
        scanf(""%d"", &n);
        if(n == 0) break;
        
        for(int i = 0; i < n; i++) {
            int pm, pe, pj;
            scanf(""%d %d %d"", &pm, &pe, &pj);
            
            char cls = 'C';
            
            // Check conditions for A class
            if(pm == 100 || pe == 100 || pj == 100) {
                cls = 'A';
            }
            else if((pm + pe) / 2.0 >= 90) {
                cls = 'A';
            }
            else if((pm + pe + pj) / 3.0 >= 80) {
                cls = 'A';
            }
            // Check conditions for B class
            else if((pm + pe + pj) / 3.0 >= 70) {
                cls = 'B';
            }
            else if((pm + pe + pj) / 3.0 >= 50 && (pm >= 80 || pe >= 80)) {
                cls = 'B';
            }
            
            printf(""%c\n"", cls);
        }
    }
    
    return 0;
}
",0
p00218,"クラス分け
会津進学塾では、生徒が塾に入る際に実力テストを行ってクラス分けをします。テストは数学、英語、国語の 3 科目行い、生徒を A,B,C クラスにクラス分けします。A クラスのレベルが一番高く、順に低くなっていきます。
クラス分けの判断は以下の表に基づきます。
条件
クラス
100 点の科目がある
A
数学と英語の平均点が 90 点以上
A
3 科目の平均点が 80 点以上
A
3 科目の平均点が 70 点以上
B
3 科目の平均点が 50 点以上で数学か英語が 80 点以上
B
上の条件を満たさない
C
複数の条件を満たす場合は、よりレベルの高いクラスに分けられます。
生徒の人数
n
(1 ≤
n
≤ 10000)、各生徒の数学の点数
pm
i
(0 ≤
pm
i
≤ 100)、英語の点数
pe
i
(0 ≤
pe
i
≤ 100)、国語の点数
pj
i
(0 ≤
pj
i
≤ 100) を入力とし、各生徒のクラスA,B,C (半角英字) を出力するプログラムを作成してください。
Input
複数のデータセットの並びが入力として与えられます。入力の終わりはゼロひとつの行で示されます。
各データセットは以下の形式で与えられます。
n
pm
1
pe
1
pj
1
pm
2
pe
2
pj
2
:
pm
n
pe
n
pj
n
入力はすべて整数で与えられます。データセットの数は 1000 を超えません。
Output
入力データセットごとに、各生徒のクラスを順番に出力します。
Sample Input
4
100 70 20
98 86 55
80 34 36
65 79 65
2
99 81 20
66 72 90
0
Output for the Sample Input
A
A
B
C
A
B",C,"m,e,j,s;main(n){for(;scanf(""%d"",&n)*n;)for(;n--;puts(m>99|e>99|j>99|m+e>179|s>239?""A"":s>209||s>149&&m>79|e>79?""B"":""C""))scanf(""%d%d%d"",&m,&e,&j),s=m+e+j;}",1
p00218,"クラス分け
会津進学塾では、生徒が塾に入る際に実力テストを行ってクラス分けをします。テストは数学、英語、国語の 3 科目行い、生徒を A,B,C クラスにクラス分けします。A クラスのレベルが一番高く、順に低くなっていきます。
クラス分けの判断は以下の表に基づきます。
条件
クラス
100 点の科目がある
A
数学と英語の平均点が 90 点以上
A
3 科目の平均点が 80 点以上
A
3 科目の平均点が 70 点以上
B
3 科目の平均点が 50 点以上で数学か英語が 80 点以上
B
上の条件を満たさない
C
複数の条件を満たす場合は、よりレベルの高いクラスに分けられます。
生徒の人数
n
(1 ≤
n
≤ 10000)、各生徒の数学の点数
pm
i
(0 ≤
pm
i
≤ 100)、英語の点数
pe
i
(0 ≤
pe
i
≤ 100)、国語の点数
pj
i
(0 ≤
pj
i
≤ 100) を入力とし、各生徒のクラスA,B,C (半角英字) を出力するプログラムを作成してください。
Input
複数のデータセットの並びが入力として与えられます。入力の終わりはゼロひとつの行で示されます。
各データセットは以下の形式で与えられます。
n
pm
1
pe
1
pj
1
pm
2
pe
2
pj
2
:
pm
n
pe
n
pj
n
入力はすべて整数で与えられます。データセットの数は 1000 を超えません。
Output
入力データセットごとに、各生徒のクラスを順番に出力します。
Sample Input
4
100 70 20
98 86 55
80 34 36
65 79 65
2
99 81 20
66 72 90
0
Output for the Sample Input
A
A
B
C
A
B",Java,"import java.util.Scanner;

public class Main {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        
        while (true) {
            int n = sc.nextInt();
            if (n == 0) break;
            
            for (int i = 0; i < n; i++) {
                int pm = sc.nextInt();
                int pe = sc.nextInt();
                int pj = sc.nextInt();
                
                String cls = getClass(pm, pe, pj);
                System.out.println(cls);
            }
        }
        
        sc.close();
    }
    
    static String getClass(int pm, int pe, int pj) {
        // Check for class A conditions
        if (pm == 100 || pe == 100 || pj == 100) {
            return ""A"";
        }
        
        double mathEngAvg = (pm + pe) / 2.0;
        if (mathEngAvg >= 90) {
            return ""A"";
        }
        
        double threeAvg = (pm + pe + pj) / 3.0;
        if (threeAvg >= 80) {
            return ""A"";
        }
        
        // Check for class B conditions
        if (threeAvg >= 70) {
            return ""B"";
        }
        
        if (threeAvg >= 50 && (pm >= 80 || pe >= 80)) {
            return ""B"";
        }
        
        // Otherwise class C
        return ""C"";
    }
}
",0
p00218,"クラス分け
会津進学塾では、生徒が塾に入る際に実力テストを行ってクラス分けをします。テストは数学、英語、国語の 3 科目行い、生徒を A,B,C クラスにクラス分けします。A クラスのレベルが一番高く、順に低くなっていきます。
クラス分けの判断は以下の表に基づきます。
条件
クラス
100 点の科目がある
A
数学と英語の平均点が 90 点以上
A
3 科目の平均点が 80 点以上
A
3 科目の平均点が 70 点以上
B
3 科目の平均点が 50 点以上で数学か英語が 80 点以上
B
上の条件を満たさない
C
複数の条件を満たす場合は、よりレベルの高いクラスに分けられます。
生徒の人数
n
(1 ≤
n
≤ 10000)、各生徒の数学の点数
pm
i
(0 ≤
pm
i
≤ 100)、英語の点数
pe
i
(0 ≤
pe
i
≤ 100)、国語の点数
pj
i
(0 ≤
pj
i
≤ 100) を入力とし、各生徒のクラスA,B,C (半角英字) を出力するプログラムを作成してください。
Input
複数のデータセットの並びが入力として与えられます。入力の終わりはゼロひとつの行で示されます。
各データセットは以下の形式で与えられます。
n
pm
1
pe
1
pj
1
pm
2
pe
2
pj
2
:
pm
n
pe
n
pj
n
入力はすべて整数で与えられます。データセットの数は 1000 を超えません。
Output
入力データセットごとに、各生徒のクラスを順番に出力します。
Sample Input
4
100 70 20
98 86 55
80 34 36
65 79 65
2
99 81 20
66 72 90
0
Output for the Sample Input
A
A
B
C
A
B",Java,"import java.util.*;
public class Main {
	public static void main(String[] args) {
		Scanner sc=new Scanner(System.in);
		while(true){
			int n=sc.nextInt();
			if(n==0)break;
			char c[]=new char[n];
			for(int i=0;i<n;i++){
				int pm=sc.nextInt();
				int pe=sc.nextInt();
				int pj=sc.nextInt();
				if(pm==100||pe==100||pj==100)c[i]='A';
				else if((pm+pe)/2>=90)c[i]='A';
				else if((pm+pe+pj)/3>=80)c[i]='A';
				else if((pm+pe+pj)/3>=70)c[i]='B';
				else if((pm+pe+pj)/3>=50&&(pm>=80||pe>=80))c[i]='B';
				else c[i]='C';
				System.out.println(c[i]);
			}
		}
	}
}",1
p00218,"クラス分け
会津進学塾では、生徒が塾に入る際に実力テストを行ってクラス分けをします。テストは数学、英語、国語の 3 科目行い、生徒を A,B,C クラスにクラス分けします。A クラスのレベルが一番高く、順に低くなっていきます。
クラス分けの判断は以下の表に基づきます。
条件
クラス
100 点の科目がある
A
数学と英語の平均点が 90 点以上
A
3 科目の平均点が 80 点以上
A
3 科目の平均点が 70 点以上
B
3 科目の平均点が 50 点以上で数学か英語が 80 点以上
B
上の条件を満たさない
C
複数の条件を満たす場合は、よりレベルの高いクラスに分けられます。
生徒の人数
n
(1 ≤
n
≤ 10000)、各生徒の数学の点数
pm
i
(0 ≤
pm
i
≤ 100)、英語の点数
pe
i
(0 ≤
pe
i
≤ 100)、国語の点数
pj
i
(0 ≤
pj
i
≤ 100) を入力とし、各生徒のクラスA,B,C (半角英字) を出力するプログラムを作成してください。
Input
複数のデータセットの並びが入力として与えられます。入力の終わりはゼロひとつの行で示されます。
各データセットは以下の形式で与えられます。
n
pm
1
pe
1
pj
1
pm
2
pe
2
pj
2
:
pm
n
pe
n
pj
n
入力はすべて整数で与えられます。データセットの数は 1000 を超えません。
Output
入力データセットごとに、各生徒のクラスを順番に出力します。
Sample Input
4
100 70 20
98 86 55
80 34 36
65 79 65
2
99 81 20
66 72 90
0
Output for the Sample Input
A
A
B
C
A
B",Python,"while True:
    n = int(input())
    if n == 0:
        break
    
    for _ in range(n):
        pm, pe, pj = map(int, input().split())
        
        # Check conditions for class A
        if pm == 100 or pe == 100 or pj == 100:
            print(""A"")
            continue
        
        if (pm + pe) / 2 >= 90:
            print(""A"")
            continue
        
        if (pm + pe + pj) / 3 >= 80:
            print(""A"")
            continue
        
        # Check conditions for class B
        if (pm + pe + pj) / 3 >= 70:
            print(""B"")
            continue
        
        if (pm + pe + pj) / 3 >= 50 and (pm >= 80 or pe >= 80):
            print(""B"")
            continue
        
        # Otherwise class C
        print(""C"")
",0
p00218,"クラス分け
会津進学塾では、生徒が塾に入る際に実力テストを行ってクラス分けをします。テストは数学、英語、国語の 3 科目行い、生徒を A,B,C クラスにクラス分けします。A クラスのレベルが一番高く、順に低くなっていきます。
クラス分けの判断は以下の表に基づきます。
条件
クラス
100 点の科目がある
A
数学と英語の平均点が 90 点以上
A
3 科目の平均点が 80 点以上
A
3 科目の平均点が 70 点以上
B
3 科目の平均点が 50 点以上で数学か英語が 80 点以上
B
上の条件を満たさない
C
複数の条件を満たす場合は、よりレベルの高いクラスに分けられます。
生徒の人数
n
(1 ≤
n
≤ 10000)、各生徒の数学の点数
pm
i
(0 ≤
pm
i
≤ 100)、英語の点数
pe
i
(0 ≤
pe
i
≤ 100)、国語の点数
pj
i
(0 ≤
pj
i
≤ 100) を入力とし、各生徒のクラスA,B,C (半角英字) を出力するプログラムを作成してください。
Input
複数のデータセットの並びが入力として与えられます。入力の終わりはゼロひとつの行で示されます。
各データセットは以下の形式で与えられます。
n
pm
1
pe
1
pj
1
pm
2
pe
2
pj
2
:
pm
n
pe
n
pj
n
入力はすべて整数で与えられます。データセットの数は 1000 を超えません。
Output
入力データセットごとに、各生徒のクラスを順番に出力します。
Sample Input
4
100 70 20
98 86 55
80 34 36
65 79 65
2
99 81 20
66 72 90
0
Output for the Sample Input
A
A
B
C
A
B",Python,"while 1:
    n = int(input())
    if n == 0: break
    i = 0
    while True:
        if i == n: break
        m, e, j = map(int, input().split())
        sum = m + e + j
        if m==100 or e==100 or j==100:
            print(""A"")
        elif (m+e)/2 >= 90:
            print(""A"")
        elif sum/3 >= 80:
            print(""A"")
        elif sum/3 >= 70:
            print(""B"")
        elif sum/3 >= 50 and m >= 80 or e >= 80:
            print(""B"")
        else:
            print(""C"")
        i += 1
    
",1
p00219,"ヒストグラム
テンアイスクリームという名前のアイスクリーム屋さんがあります。このお店では常に 10 種類のアイスクリームが店頭に並ぶようにしています。お店の店長は商品開発の参考にするために、アイスクリームの売れ具合を表すグラフを毎日作成しています。
そんな店長のために、あなたは各アイスクリームの販売数をグラフで表示するプログラムを作成することになりました。
一日に販売されるアイスクリームの総数と売れたアイスクリームの番号を入力とし、アイスクリームの種類ごとに販売した数だけ * (半角アスタリスク) を出力するプログラムを作成してください。ただし、アイスクリームの種類を 0 から 9 までの整数で表わします。また、販売個数がゼロのアイスクリームは、- (半角ハイフン) をひとつ出力します。
Input
複数のデータセットの並びが入力として与えられます。入力の終わりはゼロひとつの行で示されます。
各データセットは以下の形式で与えられます。
n
c
1
c
2
:
c
n
1 行目に一日に販売されるアイスクリームの総数
n
(1 ≤
n
≤ 10000) が与えられます。続く
n
行に第
i
のアイスクリームの種類
c
i
(0 ≤
c
i
≤ 9) が与えられます。
データセットの数は 20 を超えません。
Output
入力データセットごとに、各アイスクリームの種類の番号順に販売数を出力します。
Sample Input
15
2
6
7
0
1
9
8
7
3
8
9
4
8
2
2
3
9
1
5
0
Output for the Sample Input
*
*
***
*
*
-
*
**
***
**
-
*
-
-
-
*
-
-
-
*",C,"#include <stdio.h>

int main() {
    int n;
    
    while(scanf(""%d"", &n) == 1 && n != 0) {
        int count[10] = {0};
        
        for(int i = 0; i < n; i++) {
            int c;
            scanf(""%d"", &c);
            count[c]++;
        }
        
        for(int i = 0; i < 10; i++) {
            if(count[i] == 0) {
                printf(""-\n"");
            } else {
                for(int j = 0; j < count[i]; j++) {
                    printf(""*"");
                }
                printf(""\n"");
            }
        }
    }
    
    return 0;
}
",0
p00219,"ヒストグラム
テンアイスクリームという名前のアイスクリーム屋さんがあります。このお店では常に 10 種類のアイスクリームが店頭に並ぶようにしています。お店の店長は商品開発の参考にするために、アイスクリームの売れ具合を表すグラフを毎日作成しています。
そんな店長のために、あなたは各アイスクリームの販売数をグラフで表示するプログラムを作成することになりました。
一日に販売されるアイスクリームの総数と売れたアイスクリームの番号を入力とし、アイスクリームの種類ごとに販売した数だけ * (半角アスタリスク) を出力するプログラムを作成してください。ただし、アイスクリームの種類を 0 から 9 までの整数で表わします。また、販売個数がゼロのアイスクリームは、- (半角ハイフン) をひとつ出力します。
Input
複数のデータセットの並びが入力として与えられます。入力の終わりはゼロひとつの行で示されます。
各データセットは以下の形式で与えられます。
n
c
1
c
2
:
c
n
1 行目に一日に販売されるアイスクリームの総数
n
(1 ≤
n
≤ 10000) が与えられます。続く
n
行に第
i
のアイスクリームの種類
c
i
(0 ≤
c
i
≤ 9) が与えられます。
データセットの数は 20 を超えません。
Output
入力データセットごとに、各アイスクリームの種類の番号順に販売数を出力します。
Sample Input
15
2
6
7
0
1
9
8
7
3
8
9
4
8
2
2
3
9
1
5
0
Output for the Sample Input
*
*
***
*
*
-
*
**
***
**
-
*
-
-
-
*
-
-
-
*",C,"#include <stdio.h>

int main()
{
    int n;
    int c;

    while (scanf(""%d"", &n), n != 0) {
        int cnt[10] = {};

        for (int i = 0; i < n; i++) {
            scanf(""%d"", &c);

            cnt[c]++;
        }

        for (int i = 0; i < 10; i++) {
            if (cnt[i] == 0) {
                putchar('-');
            }
            else {
                for (int j = 0; j < cnt[i]; j++) {
                    putchar('*');
                }
            }

            putchar('\n');
        }
    }

    return 0;
}

",1
p00219,"ヒストグラム
テンアイスクリームという名前のアイスクリーム屋さんがあります。このお店では常に 10 種類のアイスクリームが店頭に並ぶようにしています。お店の店長は商品開発の参考にするために、アイスクリームの売れ具合を表すグラフを毎日作成しています。
そんな店長のために、あなたは各アイスクリームの販売数をグラフで表示するプログラムを作成することになりました。
一日に販売されるアイスクリームの総数と売れたアイスクリームの番号を入力とし、アイスクリームの種類ごとに販売した数だけ * (半角アスタリスク) を出力するプログラムを作成してください。ただし、アイスクリームの種類を 0 から 9 までの整数で表わします。また、販売個数がゼロのアイスクリームは、- (半角ハイフン) をひとつ出力します。
Input
複数のデータセットの並びが入力として与えられます。入力の終わりはゼロひとつの行で示されます。
各データセットは以下の形式で与えられます。
n
c
1
c
2
:
c
n
1 行目に一日に販売されるアイスクリームの総数
n
(1 ≤
n
≤ 10000) が与えられます。続く
n
行に第
i
のアイスクリームの種類
c
i
(0 ≤
c
i
≤ 9) が与えられます。
データセットの数は 20 を超えません。
Output
入力データセットごとに、各アイスクリームの種類の番号順に販売数を出力します。
Sample Input
15
2
6
7
0
1
9
8
7
3
8
9
4
8
2
2
3
9
1
5
0
Output for the Sample Input
*
*
***
*
*
-
*
**
***
**
-
*
-
-
-
*
-
-
-
*",Java,"import java.util.Scanner;

public class Main {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        
        while (true) {
            int n = sc.nextInt();
            if (n == 0) break;
            
            int[] count = new int[10];
            
            for (int i = 0; i < n; i++) {
                int c = sc.nextInt();
                count[c]++;
            }
            
            for (int i = 0; i < 10; i++) {
                if (count[i] == 0) {
                    System.out.println(""-"");
                } else {
                    for (int j = 0; j < count[i]; j++) {
                        System.out.print(""*"");
                    }
                    System.out.println();
                }
            }
        }
        
        sc.close();
    }
}
",0
p00219,"ヒストグラム
テンアイスクリームという名前のアイスクリーム屋さんがあります。このお店では常に 10 種類のアイスクリームが店頭に並ぶようにしています。お店の店長は商品開発の参考にするために、アイスクリームの売れ具合を表すグラフを毎日作成しています。
そんな店長のために、あなたは各アイスクリームの販売数をグラフで表示するプログラムを作成することになりました。
一日に販売されるアイスクリームの総数と売れたアイスクリームの番号を入力とし、アイスクリームの種類ごとに販売した数だけ * (半角アスタリスク) を出力するプログラムを作成してください。ただし、アイスクリームの種類を 0 から 9 までの整数で表わします。また、販売個数がゼロのアイスクリームは、- (半角ハイフン) をひとつ出力します。
Input
複数のデータセットの並びが入力として与えられます。入力の終わりはゼロひとつの行で示されます。
各データセットは以下の形式で与えられます。
n
c
1
c
2
:
c
n
1 行目に一日に販売されるアイスクリームの総数
n
(1 ≤
n
≤ 10000) が与えられます。続く
n
行に第
i
のアイスクリームの種類
c
i
(0 ≤
c
i
≤ 9) が与えられます。
データセットの数は 20 を超えません。
Output
入力データセットごとに、各アイスクリームの種類の番号順に販売数を出力します。
Sample Input
15
2
6
7
0
1
9
8
7
3
8
9
4
8
2
2
3
9
1
5
0
Output for the Sample Input
*
*
***
*
*
-
*
**
***
**
-
*
-
-
-
*
-
-
-
*",Java,"
import java.io.IOException;
import java.util.Arrays;
import java.util.Scanner;

public class Main {

	public static void main(String[] args) throws IOException {
		new Main().run();
	}

	private void run() throws IOException {
		Scanner scanner = new Scanner(System.in);
		while (true) {
			int n = scanner.nextInt();
			if (n == 0)
				break;
			int[] num = new int[10];
			while(n-->0){
				num[scanner.nextInt()]++;
			}
			for(int a:num){
				if(a==0)
					System.out.println('-');
				else{
					char[] c = new char[a];
					Arrays.fill(c, '*');
					System.out.println(c);
				}
			}
		}
	}
}",1
p00219,"ヒストグラム
テンアイスクリームという名前のアイスクリーム屋さんがあります。このお店では常に 10 種類のアイスクリームが店頭に並ぶようにしています。お店の店長は商品開発の参考にするために、アイスクリームの売れ具合を表すグラフを毎日作成しています。
そんな店長のために、あなたは各アイスクリームの販売数をグラフで表示するプログラムを作成することになりました。
一日に販売されるアイスクリームの総数と売れたアイスクリームの番号を入力とし、アイスクリームの種類ごとに販売した数だけ * (半角アスタリスク) を出力するプログラムを作成してください。ただし、アイスクリームの種類を 0 から 9 までの整数で表わします。また、販売個数がゼロのアイスクリームは、- (半角ハイフン) をひとつ出力します。
Input
複数のデータセットの並びが入力として与えられます。入力の終わりはゼロひとつの行で示されます。
各データセットは以下の形式で与えられます。
n
c
1
c
2
:
c
n
1 行目に一日に販売されるアイスクリームの総数
n
(1 ≤
n
≤ 10000) が与えられます。続く
n
行に第
i
のアイスクリームの種類
c
i
(0 ≤
c
i
≤ 9) が与えられます。
データセットの数は 20 を超えません。
Output
入力データセットごとに、各アイスクリームの種類の番号順に販売数を出力します。
Sample Input
15
2
6
7
0
1
9
8
7
3
8
9
4
8
2
2
3
9
1
5
0
Output for the Sample Input
*
*
***
*
*
-
*
**
***
**
-
*
-
-
-
*
-
-
-
*",Python,"while True:
    n = int(input())
    if n == 0:
        break
    
    count = [0] * 10
    for _ in range(n):
        c = int(input())
        count[c] += 1
    
    for i in range(10):
        if count[i] == 0:
            print('-')
        else:
            print('*' * count[i])
",0
p00219,"ヒストグラム
テンアイスクリームという名前のアイスクリーム屋さんがあります。このお店では常に 10 種類のアイスクリームが店頭に並ぶようにしています。お店の店長は商品開発の参考にするために、アイスクリームの売れ具合を表すグラフを毎日作成しています。
そんな店長のために、あなたは各アイスクリームの販売数をグラフで表示するプログラムを作成することになりました。
一日に販売されるアイスクリームの総数と売れたアイスクリームの番号を入力とし、アイスクリームの種類ごとに販売した数だけ * (半角アスタリスク) を出力するプログラムを作成してください。ただし、アイスクリームの種類を 0 から 9 までの整数で表わします。また、販売個数がゼロのアイスクリームは、- (半角ハイフン) をひとつ出力します。
Input
複数のデータセットの並びが入力として与えられます。入力の終わりはゼロひとつの行で示されます。
各データセットは以下の形式で与えられます。
n
c
1
c
2
:
c
n
1 行目に一日に販売されるアイスクリームの総数
n
(1 ≤
n
≤ 10000) が与えられます。続く
n
行に第
i
のアイスクリームの種類
c
i
(0 ≤
c
i
≤ 9) が与えられます。
データセットの数は 20 を超えません。
Output
入力データセットごとに、各アイスクリームの種類の番号順に販売数を出力します。
Sample Input
15
2
6
7
0
1
9
8
7
3
8
9
4
8
2
2
3
9
1
5
0
Output for the Sample Input
*
*
***
*
*
-
*
**
***
**
-
*
-
-
-
*
-
-
-
*",Python,"while True:
    q={}
    a=input()
    if a==0:break
    for i in range(10): q[i]=0
    for i in range(a): q[input()]+=1
    for i in range(10):  print ""*""*q[i] if q[i] != 0 else ""-""",1
p00220,"博士が愛した２進数
「君の靴のサイズはいくつかね」
初対面の私に、いきなり博士は尋ねました。
「 23.5 です」
「ほお、実にきりのいい数字だ。2 の 4 乗に 2 の 2 乗と 2 の 1 乗と 2 の 0 乗と 2 の  -1  乗を 加えた数だ」
続けて博士は尋ねました。
「君、身長はいくつかね」
「はい、158.1 です」
博士は腕組みをして目を閉じました。しばらくの沈黙の後、口を開きました。
「ナァ~」
その後一緒に過ごした時間の中で、博士の行動がだんだん理解できるようになりました。
まず、 私が博士の求めに応じて実数を言います。実数が整数部 8 桁以内で小数部 4 桁以内の 2 進数で表される場合、博士は 2 進数への変換結果を満足げに語ります。そうでない場合、悲しげに「ナァ~」 と鳴きます。これは、私が負の実数を言うまで繰り返されるのです。
さて、博士は年齢とともにだんだんに長い計算が難しくなってきました。そこで、みなさんが博士に代わって、実数を入力し 2 進数に変換・出力するプログラムを作ってあげてください。ただし、2 進表現が制限桁数 (整数部 8 桁以内 + 小数部 4 桁以内) に収まらない場合は、NA (半角英字) を出力してください。入力される実数は整数部 8 桁以内、小数部 4 桁以内に収まるものとし、出力する 2 進表現は整数部 8 桁、小数部 4 桁で出力してください。
Input
複数のデータセットの並びが入力として与えられます。入力の終わりは負の実数ひとつの行で示されます。
各データセットとして１つの実数
n
が１行に与えられます。
データセットの数は 1200 を超えません。
Output
入力データセットごとに 2 進数への変換結果を出力します。
Sample Input
23.5
158.1
-1.0
Output for the Sample Input
00010111.1000
NA",C,"#include <stdio.h>
#include <string.h>
#include <math.h>

int main() {
    double n;
    
    while (scanf(""%lf"", &n) == 1) {
        if (n < 0) break;
        
        // Extract integer and fractional parts
        int int_part = (int)n;
        double frac_part = n - int_part;
        
        // Check if integer part fits in 8 bits
        if (int_part > 255) {
            printf(""NA\n"");
            continue;
        }
        
        // Convert integer part to binary (8 bits)
        char int_binary[9];
        for (int i = 7; i >= 0; i--) {
            int_binary[i] = (int_part % 2) + '0';
            int_part /= 2;
        }
        int_binary[8] = '\0';
        
        // Convert fractional part to binary (4 bits)
        char frac_binary[5];
        int valid = 1;
        double temp_frac = frac_part;
        
        for (int i = 0; i < 4; i++) {
            temp_frac *= 2;
            if (temp_frac >= 1) {
                frac_binary[i] = '1';
                temp_frac -= 1;
            } else {
                frac_binary[i] = '0';
            }
        }
        frac_binary[4] = '\0';
        
        // Check if there's remaining fractional part
        temp_frac *= 2;
        if (temp_frac > 0.0001) {  // Allow small floating point error
            valid = 0;
        }
        
        // Alternative check: reconstruct the number and compare
        double reconstructed = 0;
        int int_val = 0;
        for (int i = 0; i < 8; i++) {
            int_val = int_val * 2 + (int_binary[i] - '0');
        }
        reconstructed = int_val;
        
        double frac_val = 0;
        for (int i = 0; i < 4; i++) {
            frac_val = frac_val + (frac_binary[i] - '0') * pow(0.5, i + 1);
        }
        reconstructed += frac_val;
        
        if (fabs(reconstructed - n) > 0.0001) {
            valid = 0;
        }
        
        if (valid) {
            printf(""%s.%s\n"", int_binary, frac_binary);
        } else {
            printf(""NA\n"");
        }
    }
    
    return 0;
}
",0
p00220,"博士が愛した２進数
「君の靴のサイズはいくつかね」
初対面の私に、いきなり博士は尋ねました。
「 23.5 です」
「ほお、実にきりのいい数字だ。2 の 4 乗に 2 の 2 乗と 2 の 1 乗と 2 の 0 乗と 2 の  -1  乗を 加えた数だ」
続けて博士は尋ねました。
「君、身長はいくつかね」
「はい、158.1 です」
博士は腕組みをして目を閉じました。しばらくの沈黙の後、口を開きました。
「ナァ~」
その後一緒に過ごした時間の中で、博士の行動がだんだん理解できるようになりました。
まず、 私が博士の求めに応じて実数を言います。実数が整数部 8 桁以内で小数部 4 桁以内の 2 進数で表される場合、博士は 2 進数への変換結果を満足げに語ります。そうでない場合、悲しげに「ナァ~」 と鳴きます。これは、私が負の実数を言うまで繰り返されるのです。
さて、博士は年齢とともにだんだんに長い計算が難しくなってきました。そこで、みなさんが博士に代わって、実数を入力し 2 進数に変換・出力するプログラムを作ってあげてください。ただし、2 進表現が制限桁数 (整数部 8 桁以内 + 小数部 4 桁以内) に収まらない場合は、NA (半角英字) を出力してください。入力される実数は整数部 8 桁以内、小数部 4 桁以内に収まるものとし、出力する 2 進表現は整数部 8 桁、小数部 4 桁で出力してください。
Input
複数のデータセットの並びが入力として与えられます。入力の終わりは負の実数ひとつの行で示されます。
各データセットとして１つの実数
n
が１行に与えられます。
データセットの数は 1200 を超えません。
Output
入力データセットごとに 2 進数への変換結果を出力します。
Sample Input
23.5
158.1
-1.0
Output for the Sample Input
00010111.1000
NA",C,"#include<stdio.h>
int main(){
  double n;
  char a[12];
  int m,i;
  while(1){
    scanf(""%lf"",&n);
    if(n<0)break;
    n*=16;
    m=n;
    if(m-n){
      printf(""NA\n"");
      continue;
    }
    for(i=12;i;i--){
      a[i-1]=m%2+'0';
      m/=2;
    }
    if(m){
      printf(""NA\n"");
      continue;
    }
    for(i=0;i<12;i++){
      if(i==8)printf(""."");
      printf(""%c"",a[i]);
    }
    printf(""\n"");
  }
  return 0;
}",1
p00220,"博士が愛した２進数
「君の靴のサイズはいくつかね」
初対面の私に、いきなり博士は尋ねました。
「 23.5 です」
「ほお、実にきりのいい数字だ。2 の 4 乗に 2 の 2 乗と 2 の 1 乗と 2 の 0 乗と 2 の  -1  乗を 加えた数だ」
続けて博士は尋ねました。
「君、身長はいくつかね」
「はい、158.1 です」
博士は腕組みをして目を閉じました。しばらくの沈黙の後、口を開きました。
「ナァ~」
その後一緒に過ごした時間の中で、博士の行動がだんだん理解できるようになりました。
まず、 私が博士の求めに応じて実数を言います。実数が整数部 8 桁以内で小数部 4 桁以内の 2 進数で表される場合、博士は 2 進数への変換結果を満足げに語ります。そうでない場合、悲しげに「ナァ~」 と鳴きます。これは、私が負の実数を言うまで繰り返されるのです。
さて、博士は年齢とともにだんだんに長い計算が難しくなってきました。そこで、みなさんが博士に代わって、実数を入力し 2 進数に変換・出力するプログラムを作ってあげてください。ただし、2 進表現が制限桁数 (整数部 8 桁以内 + 小数部 4 桁以内) に収まらない場合は、NA (半角英字) を出力してください。入力される実数は整数部 8 桁以内、小数部 4 桁以内に収まるものとし、出力する 2 進表現は整数部 8 桁、小数部 4 桁で出力してください。
Input
複数のデータセットの並びが入力として与えられます。入力の終わりは負の実数ひとつの行で示されます。
各データセットとして１つの実数
n
が１行に与えられます。
データセットの数は 1200 を超えません。
Output
入力データセットごとに 2 進数への変換結果を出力します。
Sample Input
23.5
158.1
-1.0
Output for the Sample Input
00010111.1000
NA",Java,"import java.util.Scanner;

public class Main {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        
        while (sc.hasNext()) {
            double n = sc.nextDouble();
            if (n < 0) break;
            
            // Split into integer and fractional parts
            int intPart = (int) n;
            double fracPart = n - intPart;
            
            // Check if integer part fits in 8 bits
            if (intPart > 255) {
                System.out.println(""NA"");
                continue;
            }
            
            // Convert integer part to binary (8 digits)
            String intBinary = String.format(""%8s"", Integer.toBinaryString(intPart)).replace(' ', '0');
            
            // Convert fractional part to binary (4 digits)
            StringBuilder fracBinary = new StringBuilder();
            boolean valid = true;
            double temp = fracPart;
            
            for (int i = 0; i < 4; i++) {
                temp *= 2;
                if (temp >= 1) {
                    fracBinary.append('1');
                    temp -= 1;
                } else {
                    fracBinary.append('0');
                }
            }
            
            // Check if there's remaining fractional part
            if (temp > 1e-9) {
                valid = false;
            }
            
            if (valid) {
                System.out.println(intBinary + ""."" + fracBinary.toString());
            } else {
                System.out.println(""NA"");
            }
        }
        
        sc.close();
    }
}
",0
p00220,"博士が愛した２進数
「君の靴のサイズはいくつかね」
初対面の私に、いきなり博士は尋ねました。
「 23.5 です」
「ほお、実にきりのいい数字だ。2 の 4 乗に 2 の 2 乗と 2 の 1 乗と 2 の 0 乗と 2 の  -1  乗を 加えた数だ」
続けて博士は尋ねました。
「君、身長はいくつかね」
「はい、158.1 です」
博士は腕組みをして目を閉じました。しばらくの沈黙の後、口を開きました。
「ナァ~」
その後一緒に過ごした時間の中で、博士の行動がだんだん理解できるようになりました。
まず、 私が博士の求めに応じて実数を言います。実数が整数部 8 桁以内で小数部 4 桁以内の 2 進数で表される場合、博士は 2 進数への変換結果を満足げに語ります。そうでない場合、悲しげに「ナァ~」 と鳴きます。これは、私が負の実数を言うまで繰り返されるのです。
さて、博士は年齢とともにだんだんに長い計算が難しくなってきました。そこで、みなさんが博士に代わって、実数を入力し 2 進数に変換・出力するプログラムを作ってあげてください。ただし、2 進表現が制限桁数 (整数部 8 桁以内 + 小数部 4 桁以内) に収まらない場合は、NA (半角英字) を出力してください。入力される実数は整数部 8 桁以内、小数部 4 桁以内に収まるものとし、出力する 2 進表現は整数部 8 桁、小数部 4 桁で出力してください。
Input
複数のデータセットの並びが入力として与えられます。入力の終わりは負の実数ひとつの行で示されます。
各データセットとして１つの実数
n
が１行に与えられます。
データセットの数は 1200 を超えません。
Output
入力データセットごとに 2 進数への変換結果を出力します。
Sample Input
23.5
158.1
-1.0
Output for the Sample Input
00010111.1000
NA",Java,"/**
 * Problem E: Binary Digit A Doctor Loved
 */

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;

public class Main {

	public static void main(String[] args) throws IOException {
		BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
		String line = """";

		while ((line = br.readLine()) != null && !line.isEmpty()) {

			if (line.charAt(0) == '-') {
				break;
			}

			int ni;
			double nd;
			ni = Integer.parseInt(line.substring(0, line.indexOf('.')));
			if (line.indexOf('.') != -1) {
				nd = Double.parseDouble(""0""
						+ (line.substring(line.indexOf('.')))) * 16;
			} else {
				nd = 0.0;
			}
			if (ni > 255 || nd % 1.0 > 0.0) {
				System.out.println(""NA"");
			} else {
				char[] si, sd;
				si = new char[8];
				sd = new char[4];

				for (int i = 7; i >= 0; i--) {
					if ((ni & (int) (Math.pow(2, i))) != 0) {
						si[7 - i] = '1';
					} else {
						si[7 - i] = '0';
					}
				}

				for (int i = 3; i >= 0; i--) {
					if (((int) nd & (int) (Math.pow(2, i))) != 0) {
						sd[3 - i] = '1';
					} else {
						sd[3 - i] = '0';
					}
				}
				System.out.println(new String(si) + ""."" + new String(sd));
			}
		}

	}
}",1
p00220,"博士が愛した２進数
「君の靴のサイズはいくつかね」
初対面の私に、いきなり博士は尋ねました。
「 23.5 です」
「ほお、実にきりのいい数字だ。2 の 4 乗に 2 の 2 乗と 2 の 1 乗と 2 の 0 乗と 2 の  -1  乗を 加えた数だ」
続けて博士は尋ねました。
「君、身長はいくつかね」
「はい、158.1 です」
博士は腕組みをして目を閉じました。しばらくの沈黙の後、口を開きました。
「ナァ~」
その後一緒に過ごした時間の中で、博士の行動がだんだん理解できるようになりました。
まず、 私が博士の求めに応じて実数を言います。実数が整数部 8 桁以内で小数部 4 桁以内の 2 進数で表される場合、博士は 2 進数への変換結果を満足げに語ります。そうでない場合、悲しげに「ナァ~」 と鳴きます。これは、私が負の実数を言うまで繰り返されるのです。
さて、博士は年齢とともにだんだんに長い計算が難しくなってきました。そこで、みなさんが博士に代わって、実数を入力し 2 進数に変換・出力するプログラムを作ってあげてください。ただし、2 進表現が制限桁数 (整数部 8 桁以内 + 小数部 4 桁以内) に収まらない場合は、NA (半角英字) を出力してください。入力される実数は整数部 8 桁以内、小数部 4 桁以内に収まるものとし、出力する 2 進表現は整数部 8 桁、小数部 4 桁で出力してください。
Input
複数のデータセットの並びが入力として与えられます。入力の終わりは負の実数ひとつの行で示されます。
各データセットとして１つの実数
n
が１行に与えられます。
データセットの数は 1200 を超えません。
Output
入力データセットごとに 2 進数への変換結果を出力します。
Sample Input
23.5
158.1
-1.0
Output for the Sample Input
00010111.1000
NA",Python,"import sys

def decimal_to_binary(n):
    if n < 0:
        return None
    
    # Split into integer and fractional parts
    integer_part = int(n)
    fractional_part = n - integer_part
    
    # Check if integer part fits in 8 bits
    if integer_part >= 256:  # 2^8
        return ""NA""
    
    # Convert integer part to binary
    int_binary = bin(integer_part)[2:].zfill(8)
    
    # Convert fractional part to binary (up to 4 digits)
    frac_binary = """"
    for _ in range(4):
        fractional_part *= 2
        bit = int(fractional_part)
        frac_binary += str(bit)
        fractional_part -= bit
    
    # Check if there's remaining fractional part (can't be represented exactly)
    if fractional_part > 1e-9:  # small epsilon for floating point errors
        return ""NA""
    
    return int_binary + ""."" + frac_binary

for line in sys.stdin:
    n = float(line.strip())
    if n < 0:
        break
    result = decimal_to_binary(n)
    print(result)
",0
p00220,"博士が愛した２進数
「君の靴のサイズはいくつかね」
初対面の私に、いきなり博士は尋ねました。
「 23.5 です」
「ほお、実にきりのいい数字だ。2 の 4 乗に 2 の 2 乗と 2 の 1 乗と 2 の 0 乗と 2 の  -1  乗を 加えた数だ」
続けて博士は尋ねました。
「君、身長はいくつかね」
「はい、158.1 です」
博士は腕組みをして目を閉じました。しばらくの沈黙の後、口を開きました。
「ナァ~」
その後一緒に過ごした時間の中で、博士の行動がだんだん理解できるようになりました。
まず、 私が博士の求めに応じて実数を言います。実数が整数部 8 桁以内で小数部 4 桁以内の 2 進数で表される場合、博士は 2 進数への変換結果を満足げに語ります。そうでない場合、悲しげに「ナァ~」 と鳴きます。これは、私が負の実数を言うまで繰り返されるのです。
さて、博士は年齢とともにだんだんに長い計算が難しくなってきました。そこで、みなさんが博士に代わって、実数を入力し 2 進数に変換・出力するプログラムを作ってあげてください。ただし、2 進表現が制限桁数 (整数部 8 桁以内 + 小数部 4 桁以内) に収まらない場合は、NA (半角英字) を出力してください。入力される実数は整数部 8 桁以内、小数部 4 桁以内に収まるものとし、出力する 2 進表現は整数部 8 桁、小数部 4 桁で出力してください。
Input
複数のデータセットの並びが入力として与えられます。入力の終わりは負の実数ひとつの行で示されます。
各データセットとして１つの実数
n
が１行に与えられます。
データセットの数は 1200 を超えません。
Output
入力データセットごとに 2 進数への変換結果を出力します。
Sample Input
23.5
158.1
-1.0
Output for the Sample Input
00010111.1000
NA",Python,"# Aizu Problem 0220: Binary Digit A Doctor Loved

import sys, math, os, struct

# read input:
PYDEV = os.environ.get('PYDEV')
if PYDEV==""True"":
    sys.stdin = open(""sample-input.txt"", ""rt"")



while True:
    n = float(input())
    if n < 0:
        break
    pre = int(n)
    post = n - int(n)
    res = bin(pre)[2:].zfill(8) + '.'
    for k in range(4):
        post *= 2
        res += str(int(post))
        post -= int(post)
    if pre > 255 or post > 0:
        print(""NA"")
    else:
        print(res)
    #m = int(n * 16)
    #if n == m / 16. and m < 4096:
    #    res = """"
    #    for k in range(12):
    #        res += str(m % 2)
    #        m //= 2
    #        if k == 7:
    #            res += '.'
    #    print(res)
    #else:
    #    print(""NA"")",1
p00221,"FizzBuzz
「Fizz Buzz」と言われる数字を使ったゲームがあります。このゲームは複数のプレイヤーで数字を1 から順にひとつずつ数え上げていくもので、各プレイヤーは直前のプレイヤーが発言した次の数字をひとつだけ発言します。その時、3 で割り切れる場合は 「Fizz」, 5 で割り切れる場合は 「Buzz」、両者で割り切れる場合は「FizzBuzz」と数の代わりに発言しなければなりません。例えば、最初の 16 までの発言は以下のようになります。
1, 2, Fizz, 4, Buzz, Fizz, 7, 8, Fizz, Buzz, 11, Fizz, 13, 14, FizzBuzz, 16, ・・・
太郎君は友達と「Fizz Buzz」をして遊ぶことにしました。太郎君たちはルールを次のように決めました。
「間違えた人は脱落する。その次の人は間違えた数の次の数から始める。つまり、1, 2, 3 と発言した場合、3 で間違えたので次は 4 から始めることになる。」
このルールに従ってゲームを行うのですが、ゲームに慣れていないため、間違えたことに気付かないことがあり、公平な判断ができません。そこであなたは太郎君たちがこのゲームを楽しめるように、決められた発言回数が終わった時点で残っていた人を出力するプログラムを作成することにしました。
プレイヤー数、ゲーム中に発言された回数、それぞれの発言を入力とし、入力が終わった時点で残っているプレイヤーの番号を小さい順に出力するプログラムを作成してください。ただし、プレイヤーには 1 から番号が割り振られており、発言順番も 1 番目のプレイヤーから順に行い、一通り発言が終わると、再度 1 番目のプレイヤーから発言することとします。順番の回ってきたプレイヤーが既に脱落している場合は、その次のプレイヤーが発言します。また、このプログラムは、プレイヤーが一人になった時点で、その後の発言を無視しなければなりません。
Input
複数のデータセットの並びが入力として与えられます。入力の終わりはゼロふたつの行で示されます。
各データセットは以下の形式で与えられます。
m
n
s
1
s
2
:
s
n
1 行目にプレイヤー数
m
(2 ≤
m
≤ 1000) と発言回数
n
(1 ≤
n
≤ 10000) が与えられます。
続く
n
行に
i
番目の発言
s
1
が与えられます。
s
i
は整数、Fizz、Buzz、または FizzBuzz を示す文字列（8文字以下）です。
データセットの数は 50 を超えません。
Output
入力データセットごとに、指定された発言回数まで入力されたときに残っているプレイヤーの番号を小さい順に出力します。
Sample Input
5 7
1
2
Fizz
4
Buzz
6
7
3 5
1
2
3
4
5
0 0
Output for the Sample Input
2 3 4 5
1",C,"#include <stdio.h>
#include <string.h>

int main() {
    int m, n;
    
    while(1) {
        scanf(""%d %d"", &m, &n);
        if(m == 0 && n == 0) break;
        
        int active[1001];
        for(int i = 1; i <= m; i++) {
            active[i] = 1;
        }
        
        int current_player = 1;
        int current_number = 1;
        int remaining_players = m;
        
        for(int i = 0; i < n; i++) {
            char statement[10];
            scanf(""%s"", statement);
            
            if(remaining_players == 1) {
                continue;
            }
            
            // Find next active player
            while(active[current_player] == 0) {
                current_player++;
                if(current_player > m) current_player = 1;
            }
            
            // Check if statement is correct
            int correct = 0;
            
            if(current_number % 15 == 0) {
                if(strcmp(statement, ""FizzBuzz"") == 0) correct = 1;
            }
            else if(current_number % 3 == 0) {
                if(strcmp(statement, ""Fizz"") == 0) correct = 1;
            }
            else if(current_number % 5 == 0) {
                if(strcmp(statement, ""Buzz"") == 0) correct = 1;
            }
            else {
                int num;
                if(sscanf(statement, ""%d"", &num) == 1 && num == current_number) {
                    correct = 1;
                }
            }
            
            if(!correct) {
                active[current_player] = 0;
                remaining_players--;
            }
            
            current_number++;
            
            // Move to next player
            current_player++;
            if(current_player > m) current_player = 1;
        }
        
        int first = 1;
        for(int i = 1; i <= m; i++) {
            if(active[i]) {
                if(!first) printf("" "");
                printf(""%d"", i);
                first = 0;
            }
        }
        printf(""\n"");
    }
    
    return 0;
}
",0
p00221,"FizzBuzz
「Fizz Buzz」と言われる数字を使ったゲームがあります。このゲームは複数のプレイヤーで数字を1 から順にひとつずつ数え上げていくもので、各プレイヤーは直前のプレイヤーが発言した次の数字をひとつだけ発言します。その時、3 で割り切れる場合は 「Fizz」, 5 で割り切れる場合は 「Buzz」、両者で割り切れる場合は「FizzBuzz」と数の代わりに発言しなければなりません。例えば、最初の 16 までの発言は以下のようになります。
1, 2, Fizz, 4, Buzz, Fizz, 7, 8, Fizz, Buzz, 11, Fizz, 13, 14, FizzBuzz, 16, ・・・
太郎君は友達と「Fizz Buzz」をして遊ぶことにしました。太郎君たちはルールを次のように決めました。
「間違えた人は脱落する。その次の人は間違えた数の次の数から始める。つまり、1, 2, 3 と発言した場合、3 で間違えたので次は 4 から始めることになる。」
このルールに従ってゲームを行うのですが、ゲームに慣れていないため、間違えたことに気付かないことがあり、公平な判断ができません。そこであなたは太郎君たちがこのゲームを楽しめるように、決められた発言回数が終わった時点で残っていた人を出力するプログラムを作成することにしました。
プレイヤー数、ゲーム中に発言された回数、それぞれの発言を入力とし、入力が終わった時点で残っているプレイヤーの番号を小さい順に出力するプログラムを作成してください。ただし、プレイヤーには 1 から番号が割り振られており、発言順番も 1 番目のプレイヤーから順に行い、一通り発言が終わると、再度 1 番目のプレイヤーから発言することとします。順番の回ってきたプレイヤーが既に脱落している場合は、その次のプレイヤーが発言します。また、このプログラムは、プレイヤーが一人になった時点で、その後の発言を無視しなければなりません。
Input
複数のデータセットの並びが入力として与えられます。入力の終わりはゼロふたつの行で示されます。
各データセットは以下の形式で与えられます。
m
n
s
1
s
2
:
s
n
1 行目にプレイヤー数
m
(2 ≤
m
≤ 1000) と発言回数
n
(1 ≤
n
≤ 10000) が与えられます。
続く
n
行に
i
番目の発言
s
1
が与えられます。
s
i
は整数、Fizz、Buzz、または FizzBuzz を示す文字列（8文字以下）です。
データセットの数は 50 を超えません。
Output
入力データセットごとに、指定された発言回数まで入力されたときに残っているプレイヤーの番号を小さい順に出力します。
Sample Input
5 7
1
2
Fizz
4
Buzz
6
7
3 5
1
2
3
4
5
0 0
Output for the Sample Input
2 3 4 5
1",C,"#include<stdio.h>
#include<string.h>
int main(){
  int n,m,t;
  int i,c;
  char s[12];
  while(1){
    scanf(""%d %d"",&n,&m);
    if(n==0&&m==0)break;
    scanf(""\n"");
    t=1;
    c=n;
    int p[1001]={0};
    p[n+1]=-1;
    for(i=1;i<=m;i++){
      if(t==c+1)t=1;
      for(;p[t]==-1;t++);
      if(t==c+1)t=1;
      for(;p[t]==-1;t++);
      fgets(s,10,stdin);
      if(n!=1){
	if(i%3==0){
	  if(i%5==0){
	    if(strcmp(s,""FizzBuzz\n\0"")!=0)p[t]=-1;
	  }
	  else{
	    if(strcmp(s,""Fizz\n\0"")!=0)p[t]=-1;
	  }
	}
	else{
	  if(i%5==0){
	    if(strcmp(s,""Buzz\n\0"")!=0)p[t]=-1;
	  }
	  else{
	    if(!(s[0]==i+'0'&&s[1]==10))p[t]=-1;
	  }
	}
	if(p[t]==-1)n--;
      }
      t++;
    }
    n=0;
    for(i=1;i<=c;i++){
      if(p[i]==0){
	if(n==1)printf("" "");
	printf(""%d"",i);
	n=1;
      }
    }
    printf(""\n"");
  }
  return 0;
}",1
p00221,"FizzBuzz
「Fizz Buzz」と言われる数字を使ったゲームがあります。このゲームは複数のプレイヤーで数字を1 から順にひとつずつ数え上げていくもので、各プレイヤーは直前のプレイヤーが発言した次の数字をひとつだけ発言します。その時、3 で割り切れる場合は 「Fizz」, 5 で割り切れる場合は 「Buzz」、両者で割り切れる場合は「FizzBuzz」と数の代わりに発言しなければなりません。例えば、最初の 16 までの発言は以下のようになります。
1, 2, Fizz, 4, Buzz, Fizz, 7, 8, Fizz, Buzz, 11, Fizz, 13, 14, FizzBuzz, 16, ・・・
太郎君は友達と「Fizz Buzz」をして遊ぶことにしました。太郎君たちはルールを次のように決めました。
「間違えた人は脱落する。その次の人は間違えた数の次の数から始める。つまり、1, 2, 3 と発言した場合、3 で間違えたので次は 4 から始めることになる。」
このルールに従ってゲームを行うのですが、ゲームに慣れていないため、間違えたことに気付かないことがあり、公平な判断ができません。そこであなたは太郎君たちがこのゲームを楽しめるように、決められた発言回数が終わった時点で残っていた人を出力するプログラムを作成することにしました。
プレイヤー数、ゲーム中に発言された回数、それぞれの発言を入力とし、入力が終わった時点で残っているプレイヤーの番号を小さい順に出力するプログラムを作成してください。ただし、プレイヤーには 1 から番号が割り振られており、発言順番も 1 番目のプレイヤーから順に行い、一通り発言が終わると、再度 1 番目のプレイヤーから発言することとします。順番の回ってきたプレイヤーが既に脱落している場合は、その次のプレイヤーが発言します。また、このプログラムは、プレイヤーが一人になった時点で、その後の発言を無視しなければなりません。
Input
複数のデータセットの並びが入力として与えられます。入力の終わりはゼロふたつの行で示されます。
各データセットは以下の形式で与えられます。
m
n
s
1
s
2
:
s
n
1 行目にプレイヤー数
m
(2 ≤
m
≤ 1000) と発言回数
n
(1 ≤
n
≤ 10000) が与えられます。
続く
n
行に
i
番目の発言
s
1
が与えられます。
s
i
は整数、Fizz、Buzz、または FizzBuzz を示す文字列（8文字以下）です。
データセットの数は 50 を超えません。
Output
入力データセットごとに、指定された発言回数まで入力されたときに残っているプレイヤーの番号を小さい順に出力します。
Sample Input
5 7
1
2
Fizz
4
Buzz
6
7
3 5
1
2
3
4
5
0 0
Output for the Sample Input
2 3 4 5
1",Java,"import java.util.*;

public class Main {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        
        while (true) {
            int m = sc.nextInt();
            int n = sc.nextInt();
            
            if (m == 0 && n == 0) break;
            
            boolean[] active = new boolean[m + 1];
            for (int i = 1; i <= m; i++) {
                active[i] = true;
            }
            
            int currentNumber = 1;
            int currentPlayer = 1;
            int activePlayers = m;
            
            for (int i = 0; i < n; i++) {
                String statement = sc.next();
                
                if (activePlayers == 1) {
                    continue;
                }
                
                while (!active[currentPlayer]) {
                    currentPlayer++;
                    if (currentPlayer > m) currentPlayer = 1;
                }
                
                String correct = getCorrectStatement(currentNumber);
                
                if (!statement.equals(correct)) {
                    active[currentPlayer] = false;
                    activePlayers--;
                } else {
                    currentNumber++;
                }
                
                if (activePlayers > 1) {
                    currentPlayer++;
                    if (currentPlayer > m) currentPlayer = 1;
                }
            }
            
            List<Integer> result = new ArrayList<>();
            for (int i = 1; i <= m; i++) {
                if (active[i]) {
                    result.add(i);
                }
            }
            
            for (int i = 0; i < result.size(); i++) {
                if (i > 0) System.out.print("" "");
                System.out.print(result.get(i));
            }
            System.out.println();
        }
        
        sc.close();
    }
    
    static String getCorrectStatement(int num) {
        if (num % 15 == 0) {
            return ""FizzBuzz"";
        } else if (num % 3 == 0) {
            return ""Fizz"";
        } else if (num % 5 == 0) {
            return ""Buzz"";
        } else {
            return String.valueOf(num);
        }
    }
}
",0
p00221,"FizzBuzz
「Fizz Buzz」と言われる数字を使ったゲームがあります。このゲームは複数のプレイヤーで数字を1 から順にひとつずつ数え上げていくもので、各プレイヤーは直前のプレイヤーが発言した次の数字をひとつだけ発言します。その時、3 で割り切れる場合は 「Fizz」, 5 で割り切れる場合は 「Buzz」、両者で割り切れる場合は「FizzBuzz」と数の代わりに発言しなければなりません。例えば、最初の 16 までの発言は以下のようになります。
1, 2, Fizz, 4, Buzz, Fizz, 7, 8, Fizz, Buzz, 11, Fizz, 13, 14, FizzBuzz, 16, ・・・
太郎君は友達と「Fizz Buzz」をして遊ぶことにしました。太郎君たちはルールを次のように決めました。
「間違えた人は脱落する。その次の人は間違えた数の次の数から始める。つまり、1, 2, 3 と発言した場合、3 で間違えたので次は 4 から始めることになる。」
このルールに従ってゲームを行うのですが、ゲームに慣れていないため、間違えたことに気付かないことがあり、公平な判断ができません。そこであなたは太郎君たちがこのゲームを楽しめるように、決められた発言回数が終わった時点で残っていた人を出力するプログラムを作成することにしました。
プレイヤー数、ゲーム中に発言された回数、それぞれの発言を入力とし、入力が終わった時点で残っているプレイヤーの番号を小さい順に出力するプログラムを作成してください。ただし、プレイヤーには 1 から番号が割り振られており、発言順番も 1 番目のプレイヤーから順に行い、一通り発言が終わると、再度 1 番目のプレイヤーから発言することとします。順番の回ってきたプレイヤーが既に脱落している場合は、その次のプレイヤーが発言します。また、このプログラムは、プレイヤーが一人になった時点で、その後の発言を無視しなければなりません。
Input
複数のデータセットの並びが入力として与えられます。入力の終わりはゼロふたつの行で示されます。
各データセットは以下の形式で与えられます。
m
n
s
1
s
2
:
s
n
1 行目にプレイヤー数
m
(2 ≤
m
≤ 1000) と発言回数
n
(1 ≤
n
≤ 10000) が与えられます。
続く
n
行に
i
番目の発言
s
1
が与えられます。
s
i
は整数、Fizz、Buzz、または FizzBuzz を示す文字列（8文字以下）です。
データセットの数は 50 を超えません。
Output
入力データセットごとに、指定された発言回数まで入力されたときに残っているプレイヤーの番号を小さい順に出力します。
Sample Input
5 7
1
2
Fizz
4
Buzz
6
7
3 5
1
2
3
4
5
0 0
Output for the Sample Input
2 3 4 5
1",Java,"import java.util.*;

class Main {
	public static void main (String[] args) {
		Scanner sc = new Scanner(System.in);
		int m,n;
		FizzBuzz fb;
		for(;;) {
			m = sc.nextInt();
			n = sc.nextInt();
			if(m==0 && n==0) {
				break;
			}
			
			fb = new FizzBuzz(m);
			for(int i=0; i<n; i++) {
				if(!fb.sayNextStatement(sc.next())) {
					break;
				}
			}
			
			fb.showPlayer();
		}
	}
}

class FizzBuzz {
	private int current,currentPlayer;
	private int m;
	private int[] player;
	
	public FizzBuzz(int m) {
		current = 0;
		currentPlayer = 0;
		this.m = m;
		player = new int[m];
		for(int i=0; i<m; i++) {
			player[i] = i+1;
		}
	}
	
	public void showPlayer() {
		for(int pl:player){
			if(pl != -1){
				System.out.println(pl);
			}
		}
	}
	
	public boolean sayNextStatement(String statement) {
		try {
			int num = Integer.valueOf(statement);
			if(!checkFizzBuzz(num)) {
				player[currentPlayer] = -1;
			}
		} catch(NumberFormatException e) {
			if(!checkFizzBuzz(statement)) {
				player[currentPlayer] = -1;
			}
		}
		
		if(!setCurrentPlayer()) {
			return false;
		}
		
		return true;
	}
	
	private boolean setCurrentPlayer() {
		int prev = currentPlayer;
		
		if(currentPlayer+1 == m) {
			currentPlayer = 0;
		} else {
			currentPlayer ++;
		}
		
		while(player[currentPlayer] == -1) {
			if(currentPlayer+1 == m) {
				currentPlayer = 0;
			} else {
				currentPlayer ++;
			}
			
			if(prev == currentPlayer) {
				return false;
			}
		}
		
		return true;
	}
	
	private boolean checkFizzBuzz(int statement) {
		current ++;
		
		if((current % 3 == 0) || (current % 5 == 0)) {
			return false;
		} else {
			if(current == statement) {
				return true;
			} else {
				return false;
			}
		}
	}
	
	private boolean checkFizzBuzz(String statement) {
		current ++;
		if((current % 3 == 0) && (current % 5 == 0)) {
			if(statement.equals(""FizzBuzz"")) {
				return true;
			} else {
				return false;
			}
		} else if(current % 3 == 0) {
			if(statement.equals(""Fizz"")) {
				return true;
			} else {
				return false;
			}
		} else if(current % 5 == 0) {
			if(statement.equals(""Buzz"")) {
				return true;
			} else {
				return false;
			}
		} else {
			return false;
		}
	}
}",1
p00221,"FizzBuzz
「Fizz Buzz」と言われる数字を使ったゲームがあります。このゲームは複数のプレイヤーで数字を1 から順にひとつずつ数え上げていくもので、各プレイヤーは直前のプレイヤーが発言した次の数字をひとつだけ発言します。その時、3 で割り切れる場合は 「Fizz」, 5 で割り切れる場合は 「Buzz」、両者で割り切れる場合は「FizzBuzz」と数の代わりに発言しなければなりません。例えば、最初の 16 までの発言は以下のようになります。
1, 2, Fizz, 4, Buzz, Fizz, 7, 8, Fizz, Buzz, 11, Fizz, 13, 14, FizzBuzz, 16, ・・・
太郎君は友達と「Fizz Buzz」をして遊ぶことにしました。太郎君たちはルールを次のように決めました。
「間違えた人は脱落する。その次の人は間違えた数の次の数から始める。つまり、1, 2, 3 と発言した場合、3 で間違えたので次は 4 から始めることになる。」
このルールに従ってゲームを行うのですが、ゲームに慣れていないため、間違えたことに気付かないことがあり、公平な判断ができません。そこであなたは太郎君たちがこのゲームを楽しめるように、決められた発言回数が終わった時点で残っていた人を出力するプログラムを作成することにしました。
プレイヤー数、ゲーム中に発言された回数、それぞれの発言を入力とし、入力が終わった時点で残っているプレイヤーの番号を小さい順に出力するプログラムを作成してください。ただし、プレイヤーには 1 から番号が割り振られており、発言順番も 1 番目のプレイヤーから順に行い、一通り発言が終わると、再度 1 番目のプレイヤーから発言することとします。順番の回ってきたプレイヤーが既に脱落している場合は、その次のプレイヤーが発言します。また、このプログラムは、プレイヤーが一人になった時点で、その後の発言を無視しなければなりません。
Input
複数のデータセットの並びが入力として与えられます。入力の終わりはゼロふたつの行で示されます。
各データセットは以下の形式で与えられます。
m
n
s
1
s
2
:
s
n
1 行目にプレイヤー数
m
(2 ≤
m
≤ 1000) と発言回数
n
(1 ≤
n
≤ 10000) が与えられます。
続く
n
行に
i
番目の発言
s
1
が与えられます。
s
i
は整数、Fizz、Buzz、または FizzBuzz を示す文字列（8文字以下）です。
データセットの数は 50 を超えません。
Output
入力データセットごとに、指定された発言回数まで入力されたときに残っているプレイヤーの番号を小さい順に出力します。
Sample Input
5 7
1
2
Fizz
4
Buzz
6
7
3 5
1
2
3
4
5
0 0
Output for the Sample Input
2 3 4 5
1",Python,"def get_expected(num):
    if num % 15 == 0:
        return ""FizzBuzz""
    elif num % 3 == 0:
        return ""Fizz""
    elif num % 5 == 0:
        return ""Buzz""
    else:
        return str(num)

while True:
    line = input().split()
    m, n = int(line[0]), int(line[1])
    
    if m == 0 and n == 0:
        break
    
    players = set(range(1, m + 1))
    current_num = 1
    current_player = 1
    
    for _ in range(n):
        statement = input().strip()
        
        if len(players) == 1:
            continue
        
        while current_player not in players:
            current_player += 1
            if current_player > m:
                current_player = 1
        
        expected = get_expected(current_num)
        
        if statement != expected:
            players.discard(current_player)
        
        current_num += 1
        current_player += 1
        if current_player > m:
            current_player = 1
    
    result = sorted(list(players))
    print(' '.join(map(str, result)))
",0
p00221,"FizzBuzz
「Fizz Buzz」と言われる数字を使ったゲームがあります。このゲームは複数のプレイヤーで数字を1 から順にひとつずつ数え上げていくもので、各プレイヤーは直前のプレイヤーが発言した次の数字をひとつだけ発言します。その時、3 で割り切れる場合は 「Fizz」, 5 で割り切れる場合は 「Buzz」、両者で割り切れる場合は「FizzBuzz」と数の代わりに発言しなければなりません。例えば、最初の 16 までの発言は以下のようになります。
1, 2, Fizz, 4, Buzz, Fizz, 7, 8, Fizz, Buzz, 11, Fizz, 13, 14, FizzBuzz, 16, ・・・
太郎君は友達と「Fizz Buzz」をして遊ぶことにしました。太郎君たちはルールを次のように決めました。
「間違えた人は脱落する。その次の人は間違えた数の次の数から始める。つまり、1, 2, 3 と発言した場合、3 で間違えたので次は 4 から始めることになる。」
このルールに従ってゲームを行うのですが、ゲームに慣れていないため、間違えたことに気付かないことがあり、公平な判断ができません。そこであなたは太郎君たちがこのゲームを楽しめるように、決められた発言回数が終わった時点で残っていた人を出力するプログラムを作成することにしました。
プレイヤー数、ゲーム中に発言された回数、それぞれの発言を入力とし、入力が終わった時点で残っているプレイヤーの番号を小さい順に出力するプログラムを作成してください。ただし、プレイヤーには 1 から番号が割り振られており、発言順番も 1 番目のプレイヤーから順に行い、一通り発言が終わると、再度 1 番目のプレイヤーから発言することとします。順番の回ってきたプレイヤーが既に脱落している場合は、その次のプレイヤーが発言します。また、このプログラムは、プレイヤーが一人になった時点で、その後の発言を無視しなければなりません。
Input
複数のデータセットの並びが入力として与えられます。入力の終わりはゼロふたつの行で示されます。
各データセットは以下の形式で与えられます。
m
n
s
1
s
2
:
s
n
1 行目にプレイヤー数
m
(2 ≤
m
≤ 1000) と発言回数
n
(1 ≤
n
≤ 10000) が与えられます。
続く
n
行に
i
番目の発言
s
1
が与えられます。
s
i
は整数、Fizz、Buzz、または FizzBuzz を示す文字列（8文字以下）です。
データセットの数は 50 を超えません。
Output
入力データセットごとに、指定された発言回数まで入力されたときに残っているプレイヤーの番号を小さい順に出力します。
Sample Input
5 7
1
2
Fizz
4
Buzz
6
7
3 5
1
2
3
4
5
0 0
Output for the Sample Input
2 3 4 5
1",Python,"# Aizu Problem 0221: Fizz Buzz

import sys, math, os, struct

# read input:
PYDEV = os.environ.get('PYDEV')
if PYDEV==""True"":
    sys.stdin = open(""sample-input.txt"", ""rt"")


def valid(k, a):
    if k % 3 == 0 and k % 5 == 0:
        return a == ""FizzBuzz""
    elif k % 3 == 0:
        return a == ""Fizz""
    elif k % 5 == 0:
        return a == ""Buzz""
    else:
        return int(a) == k

    
def fizz_buzz(m, n, A):
    players = list(range(1, m + 1))
    p = 0
    k = 0
    while len(A) > 0:
        k += 1
        a = A.pop(0)
        if valid(k, a):
            p = (p + 1) % m
        else:
            if len(players) == 0:
                print()
                return
            players.pop(p)
            if len(players) == 1:
                break
            m -= 1
            if p == m:
                p = 0
    print(' '.join([str(p) for p in players]))
    
    
while True:
    m, n = [int(_) for _ in input().split()]
    if m == 0:
        break
    A = [input().strip() for _ in range(n)]
    fizz_buzz(m, n, A)",1
p00222,"四つ子素数
(
a, a+2, a+6, a+8
) のように並んだ 4 つの素数の組を四つ子素数といいます。四つ子素数を構成する四つの素数のうち、最大の数をその四つ子素数の大きさと呼びます。例えば、最も小さい大きさの四つ子素数は、(5, 7, 11, 13) の組であり、その大きさは 13 です。次に大きい四つ子素数は、(11, 13, 17, 19) の組で、その大きさは 19 です。
整数
n
(13 ≤
n
≤ 10,000,000) を入力とし、大きさが
n
以下になるような四つ子素数のうち、最大となるものの大きさを出力するプログラムを作成してください。
Input
複数のデータセットの並びが入力として与えられます。入力の終わりはゼロひとつの行で示されます。
各データセットとして１つの整数
n
が１行に与えられます。
データセットの数は 2000 を超えません。
Output
入力データセットごとに、最大となる四つ子素数の大きさを1行に出力します。
Sample Input
13
14
15
16
17
18
19
20
10000
0
Output for the Sample Input
13
13
13
13
13
13
19
19
9439",C,"#include <stdio.h>
#include <stdbool.h>
#include <string.h>

#define MAX 10000010

bool is_prime[MAX];
int quadruplets[MAX];

void sieve() {
    memset(is_prime, true, sizeof(is_prime));
    is_prime[0] = is_prime[1] = false;
    
    for (int i = 2; i * i < MAX; i++) {
        if (is_prime[i]) {
            for (int j = i * i; j < MAX; j += i) {
                is_prime[j] = false;
            }
        }
    }
}

void find_quadruplets() {
    memset(quadruplets, 0, sizeof(quadruplets));
    
    for (int a = 2; a + 8 < MAX; a++) {
        if (is_prime[a] && is_prime[a+2] && is_prime[a+6] && is_prime[a+8]) {
            int size = a + 8;
            quadruplets[size] = size;
        }
    }
    
    int max_so_far = 0;
    for (int i = 0; i < MAX; i++) {
        if (quadruplets[i] > 0) {
            max_so_far = quadruplets[i];
        }
        quadruplets[i] = max_so_far;
    }
}

int main() {
    sieve();
    find_quadruplets();
    
    int n;
    while (scanf(""%d"", &n) == 1 && n != 0) {
        printf(""%d\n"", quadruplets[n]);
    }
    
    return 0;
}
",0
p00222,"四つ子素数
(
a, a+2, a+6, a+8
) のように並んだ 4 つの素数の組を四つ子素数といいます。四つ子素数を構成する四つの素数のうち、最大の数をその四つ子素数の大きさと呼びます。例えば、最も小さい大きさの四つ子素数は、(5, 7, 11, 13) の組であり、その大きさは 13 です。次に大きい四つ子素数は、(11, 13, 17, 19) の組で、その大きさは 19 です。
整数
n
(13 ≤
n
≤ 10,000,000) を入力とし、大きさが
n
以下になるような四つ子素数のうち、最大となるものの大きさを出力するプログラムを作成してください。
Input
複数のデータセットの並びが入力として与えられます。入力の終わりはゼロひとつの行で示されます。
各データセットとして１つの整数
n
が１行に与えられます。
データセットの数は 2000 を超えません。
Output
入力データセットごとに、最大となる四つ子素数の大きさを1行に出力します。
Sample Input
13
14
15
16
17
18
19
20
10000
0
Output for the Sample Input
13
13
13
13
13
13
19
19
9439",C,"c[1<<23],*p,n=1e7;main(a,b){for(;a+=2,a<n;)for(b=a/2;(b+=a)<n;)c[b]=1;for(;scanf(""%d"",&n)*n;printf(""%d\n"",n))for(;p=c+n/2-4,~n&1|p[4]|p[3]|p[1]|*p;n--);}",1
p00222,"四つ子素数
(
a, a+2, a+6, a+8
) のように並んだ 4 つの素数の組を四つ子素数といいます。四つ子素数を構成する四つの素数のうち、最大の数をその四つ子素数の大きさと呼びます。例えば、最も小さい大きさの四つ子素数は、(5, 7, 11, 13) の組であり、その大きさは 13 です。次に大きい四つ子素数は、(11, 13, 17, 19) の組で、その大きさは 19 です。
整数
n
(13 ≤
n
≤ 10,000,000) を入力とし、大きさが
n
以下になるような四つ子素数のうち、最大となるものの大きさを出力するプログラムを作成してください。
Input
複数のデータセットの並びが入力として与えられます。入力の終わりはゼロひとつの行で示されます。
各データセットとして１つの整数
n
が１行に与えられます。
データセットの数は 2000 を超えません。
Output
入力データセットごとに、最大となる四つ子素数の大きさを1行に出力します。
Sample Input
13
14
15
16
17
18
19
20
10000
0
Output for the Sample Input
13
13
13
13
13
13
19
19
9439",Java,"import java.util.*;

public class Main {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        
        int MAX = 10000000;
        boolean[] isPrime = new boolean[MAX + 10];
        Arrays.fill(isPrime, true);
        isPrime[0] = isPrime[1] = false;
        
        for (int i = 2; i * i <= MAX + 8; i++) {
            if (isPrime[i]) {
                for (int j = i * i; j <= MAX + 8; j += i) {
                    isPrime[j] = false;
                }
            }
        }
        
        List<Integer> quadPrimes = new ArrayList<>();
        for (int a = 2; a <= MAX; a++) {
            if (isPrime[a] && isPrime[a + 2] && isPrime[a + 6] && isPrime[a + 8]) {
                quadPrimes.add(a + 8);
            }
        }
        
        while (true) {
            int n = sc.nextInt();
            if (n == 0) break;
            
            int result = 0;
            for (int size : quadPrimes) {
                if (size <= n) {
                    result = size;
                } else {
                    break;
                }
            }
            
            System.out.println(result);
        }
        
        sc.close();
    }
}
",0
p00222,"四つ子素数
(
a, a+2, a+6, a+8
) のように並んだ 4 つの素数の組を四つ子素数といいます。四つ子素数を構成する四つの素数のうち、最大の数をその四つ子素数の大きさと呼びます。例えば、最も小さい大きさの四つ子素数は、(5, 7, 11, 13) の組であり、その大きさは 13 です。次に大きい四つ子素数は、(11, 13, 17, 19) の組で、その大きさは 19 です。
整数
n
(13 ≤
n
≤ 10,000,000) を入力とし、大きさが
n
以下になるような四つ子素数のうち、最大となるものの大きさを出力するプログラムを作成してください。
Input
複数のデータセットの並びが入力として与えられます。入力の終わりはゼロひとつの行で示されます。
各データセットとして１つの整数
n
が１行に与えられます。
データセットの数は 2000 を超えません。
Output
入力データセットごとに、最大となる四つ子素数の大きさを1行に出力します。
Sample Input
13
14
15
16
17
18
19
20
10000
0
Output for the Sample Input
13
13
13
13
13
13
19
19
9439",Java,"

import java.util.Arrays;
import java.util.Scanner;

public class Main {

	final int MAX = 10000000;

	boolean[] prime = new boolean[MAX + 10];

	void run() {
		Scanner sc = new Scanner(System.in);

		Arrays.fill(prime, true);

		//エラトステネスの篩
		prime[0] = prime[1] = false;
		for (int i = 2; i * i < MAX + 10; i++) {
			if (prime[i]) {
				for (int j = i + i; j < MAX + 10; j += i) {
					prime[j] = false;
				}
			}
		}

		while (true) {
			int n = sc.nextInt();
			int max = 0;

			if (n == 0) {
				break;
			}

			for (int i = n; i >= 8; i--) {
				if (prime[i] && prime[i - 2] && prime[i - 6] && prime[i - 8]) {
					max = i;
					break;
				}
			}
			System.out.println(max);

		}

	}

	public static void main(String[] args) {
		new Main().run();
	}

}",1
p00222,"四つ子素数
(
a, a+2, a+6, a+8
) のように並んだ 4 つの素数の組を四つ子素数といいます。四つ子素数を構成する四つの素数のうち、最大の数をその四つ子素数の大きさと呼びます。例えば、最も小さい大きさの四つ子素数は、(5, 7, 11, 13) の組であり、その大きさは 13 です。次に大きい四つ子素数は、(11, 13, 17, 19) の組で、その大きさは 19 です。
整数
n
(13 ≤
n
≤ 10,000,000) を入力とし、大きさが
n
以下になるような四つ子素数のうち、最大となるものの大きさを出力するプログラムを作成してください。
Input
複数のデータセットの並びが入力として与えられます。入力の終わりはゼロひとつの行で示されます。
各データセットとして１つの整数
n
が１行に与えられます。
データセットの数は 2000 を超えません。
Output
入力データセットごとに、最大となる四つ子素数の大きさを1行に出力します。
Sample Input
13
14
15
16
17
18
19
20
10000
0
Output for the Sample Input
13
13
13
13
13
13
19
19
9439",Python,"def sieve_of_eratosthenes(limit):
    is_prime = [True] * (limit + 1)
    is_prime[0] = is_prime[1] = False
    
    for i in range(2, int(limit**0.5) + 1):
        if is_prime[i]:
            for j in range(i*i, limit + 1, i):
                is_prime[j] = False
    
    return is_prime

def find_quadruplet_primes(limit):
    is_prime = sieve_of_eratosthenes(limit)
    quadruplets = []
    
    for a in range(2, limit - 7):
        if is_prime[a] and is_prime[a+2] and is_prime[a+6] and is_prime[a+8]:
            quadruplets.append(a + 8)
    
    return quadruplets

# Precompute all quadruplet primes up to 10,000,000
MAX_LIMIT = 10000000
quadruplet_sizes = find_quadruplet_primes(MAX_LIMIT)

while True:
    n = int(input())
    if n == 0:
        break
    
    # Binary search for the largest quadruplet size <= n
    result = 0
    for size in quadruplet_sizes:
        if size <= n:
            result = size
        else:
            break
    
    print(result)
",0
p00222,"四つ子素数
(
a, a+2, a+6, a+8
) のように並んだ 4 つの素数の組を四つ子素数といいます。四つ子素数を構成する四つの素数のうち、最大の数をその四つ子素数の大きさと呼びます。例えば、最も小さい大きさの四つ子素数は、(5, 7, 11, 13) の組であり、その大きさは 13 です。次に大きい四つ子素数は、(11, 13, 17, 19) の組で、その大きさは 19 です。
整数
n
(13 ≤
n
≤ 10,000,000) を入力とし、大きさが
n
以下になるような四つ子素数のうち、最大となるものの大きさを出力するプログラムを作成してください。
Input
複数のデータセットの並びが入力として与えられます。入力の終わりはゼロひとつの行で示されます。
各データセットとして１つの整数
n
が１行に与えられます。
データセットの数は 2000 を超えません。
Output
入力データセットごとに、最大となる四つ子素数の大きさを1行に出力します。
Sample Input
13
14
15
16
17
18
19
20
10000
0
Output for the Sample Input
13
13
13
13
13
13
19
19
9439",Python,"def get_quad(n, p):
    for ni in range(n,0,-1):
        if p[ni] and p[ni - 2] and p[ni - 6] and p[ni - 8]:
            return ni
        
def sieve():
    n = 10000001
    p = [1] * n
    p[0] = p[1] = 0
    
    for i in range(int(n ** 0.5)):
        if p[i]:
            for j in range(2 * i, len(p), i):
                p[j] = 0
    return p
import sys
f = sys.stdin

prime = sieve()
while True:
    n = f.readline()
    if not n.isnumeric():
        continue
    n = int(n)
    if n == 0:
        break
    print(get_quad(ni, prime))",1
p00224,"自転車でダイエット
A さんは甘いものが大好きですが、最近は奥さんからダイエットするように言われています。ある日、A さんが自宅から市役所に出かけるとき、奥さんは自転車で行くことを勧めました。そこでA さんはしぶしぶ自転車に乗って出かけましたが、甘い物の好きな A さんは、途中にあるケーキ屋さんに立ち寄りケーキの食べ歩きをしようと思いつきました。
自転車をこげば走行距離に応じてカロリーが消費されますが、ケーキを食べればその分カロリーが摂取されます。正味の消費カロリーは、自転車をこいで消費したカロリーからケーキを食べて摂取したカロリーを引いた値になります。したがって、正味の消費カロリーが 0 より小さくなることもあります。
ケーキ屋さんでケーキを買ったら、 Aさんはその場でケーキを全部食べてしまいます。 Aさんがすべてのケーキ屋さんに立ち寄るとは限りませんが、ケーキ屋さんが存在する地点を通るときには、必ず立ち寄ってケーキを 1 つ買って食べるものとします。ただし、同じケーキ屋さんの前を何度も通るのはさすがに気がひけるので、各ケーキ屋さんに訪れられるのは 1 回だけとします。また、目的地の市役所をいったん通り過ぎてからケーキ屋さんに立ち寄り、その後で市役所に戻って用を済ませてもよいものとし、ケーキ屋さん以外は何度訪れても良いものとします。
A さんの自宅から市役所までの地図情報と、その途中にあるケーキ屋さんで食べられるケーキのカロリーの一覧、単位距離の走行による消費カロリーを入力とし、自宅を出発してから市役所に入るまでの正味の消費カロリーの最小値を出力するプログラムを作成してください。
地図には、A さんの自宅と市役所、ケーキ屋さんとランドマーク(目印)になる建物が書かれています。地図を表す入力データは、A さんの自宅、市役所、ケーキ屋さんとランドマークの各地点の間をつなぐ道があるとき、2 つの地点を表す記号とその間の距離からなる行を含みます。たとえば、5 番目のケーキ屋さんと 3 番目のランドマークの間の距離が 10 なら、入力データは以下のような行を含みます。
C5 L3 10
このようにケーキ屋さんには C、ランドマークには L を番号の前につけて表します。また、A さんの自宅は H、市役所は D で表します。入力データに 2 つの地点とその間の距離が与えられているなら、2 地点の間をどちら向きにも進めます。たとえば、上の例ではケーキ屋さんからランドマークへも、その逆向きへも進むことができます。また、自宅から市役所までは必ずたどり着けるものとします。それ以外に与えられる入力データは、ケーキ屋さんの数
m
、ランドマークの数
n
、単位距離あたりの消費カロリー
k
、 1 番目のケーキ屋さんから
m
番目のケーキ屋さんまでのそれぞれで買えるケーキのカロリーを表す
m
個のデータ、距離のデータの総数
d
です。
Input
複数のデータセットの並びが入力として与えられます。入力の終わりは四つの 0 の行で示されます。
  各データセットは以下の形式で与えられます。
m
n
k
d
c
1
c
2
...
c
m
s
1
t
1
e
1
s
2
t
2
e
2
:
s
d
t
d
e
d
1 行目にケーキ屋さんの数
m
(1 ≤
m
≤ 6)、 ランドマークの数
n
(1 ≤
n
≤ 100) 、単位距離あたりの消費カロリー
k
(1 ≤
k
≤ 5)、距離のデータの総数
d
(5 ≤
d
≤ 256) が与えられます。
2 行目に各ケーキ屋で買うケーキのカロリー
c
i
(1 ≤
c
i
≤ 100) が与えられます。
続く
d
行に
i
番目の 2 つの地点間の距離データ
s
i
,
t
i
,
e
i
(1 ≤
e
i
≤ 20)  が与えられます。
データセットの数は 100 を超えません。
Output
入力データセットごとに、全体の消費カロリーの最小値を１行に出力します。
Sample Input
1 1 2 5
35
H L1 5
C1 D 6
C1 H 12
L1 D 10
C1 L1 20
2 1 4 6
100 70
H L1 5
C1 L1 12
C1 D 11
C2 L1 7
C2 D 15
L1 D 8
0 0 0 0
Output for the Sample Input
1
-2",C,"#include <stdio.h>
#include <string.h>
#include <limits.h>

#define INF 1000000000
#define MAX_NODES 110

int m, n, k, d;
int calories[10];
int dist[MAX_NODES][MAX_NODES];
int H_idx, D_idx;
int C_idx[10];
int L_idx[110];

int parse_node(char *s) {
    if (s[0] == 'H') return H_idx;
    if (s[0] == 'D') return D_idx;
    if (s[0] == 'C') {
        int num;
        sscanf(s + 1, ""%d"", &num);
        return C_idx[num - 1];
    }
    if (s[0] == 'L') {
        int num;
        sscanf(s + 1, ""%d"", &num);
        return L_idx[num - 1];
    }
    return -1;
}

int min(int a, int b) {
    return a < b ? a : b;
}

void floyd_warshall(int nodes) {
    for (int k = 0; k < nodes; k++) {
        for (int i = 0; i < nodes; i++) {
            for (int j = 0; j < nodes; j++) {
                if (dist[i][k] != INF && dist[k][j] != INF) {
                    dist[i][j] = min(dist[i][j], dist[i][k] + dist[k][j]);
                }
            }
        }
    }
}

int main() {
    while (1) {
        scanf(""%d %d %d %d"", &m, &n, &k, &d);
        if (m == 0 && n == 0 && k == 0 && d == 0) break;

        for (int i = 0; i < m; i++) {
            scanf(""%d"", &calories[i]);
        }

        int nodes = 2 + m + n;
        H_idx = 0;
        D_idx = 1;
        for (int i = 0; i < m; i++) C_idx[i] = 2 + i;
        for (int i = 0; i < n; i++) L_idx[i] = 2 + m + i;

        for (int i = 0; i < nodes; i++) {
            for (int j = 0; j < nodes; j++) {
                if (i == j) dist[i][j] = 0;
                else dist[i][j] = INF;
            }
        }

        for (int i = 0; i < d; i++) {
            char s[10], t[10];
            int e;
            scanf(""%s %s %d"", s, t, &e);
            int u = parse_node(s);
            int v = parse_node(t);
            dist[u][v] = min(dist[u][v], e);
            dist[v][u] = min(dist[v][u], e);
        }

        floyd_warshall(nodes);

        int min_cost = INF;
        for (int mask = 0; mask < (1 << m); mask++) {
            int perm[10];
            int cnt = 0;
            for (int i = 0; i < m; i++) {
                if (mask & (1 << i)) {
                    perm[cnt++] = i;
                }
            }

            if (cnt == 0) {
                int total_dist = dist[H_idx][D_idx];
                int cost = total_dist * k;
                min_cost = min(min_cost, cost);
            } else {
                int fact = 1;
                for (int i = 1; i <= cnt; i++) fact *= i;
                
                for (int p = 0; p < fact; p++) {
                    int temp_perm[10];
                    for (int i = 0; i < cnt; i++) temp_perm[i] = perm[i];
                    
                    int temp = p;
                    for (int i = 0; i < cnt; i++) {
                        int j = i + temp % (cnt - i);
                        temp /= (cnt - i);
                        int t = temp_perm[i];
                        temp_perm[i] = temp_perm[j];
                        temp_perm[j] = t;
                    }

                    int total_dist = dist[H_idx][C_idx[temp_perm[0]]];
                    int total_cal = calories[temp_perm[0]];
                    for (int i = 1; i < cnt; i++) {
                        total_dist += dist[C_idx[temp_perm[i - 1]]][C_idx[temp_perm[i]]];
                        total_cal += calories[temp_perm[i]];
                    }
                    total_dist += dist[C_idx[temp_perm[cnt - 1]]][D_idx];

                    int cost = total_dist * k - total_cal;
                    min_cost = min(min_cost, cost);
                }
            }
        }

        printf(""%d\n"", min_cost);
    }
    return 0;
}
",0
p00224,"自転車でダイエット
A さんは甘いものが大好きですが、最近は奥さんからダイエットするように言われています。ある日、A さんが自宅から市役所に出かけるとき、奥さんは自転車で行くことを勧めました。そこでA さんはしぶしぶ自転車に乗って出かけましたが、甘い物の好きな A さんは、途中にあるケーキ屋さんに立ち寄りケーキの食べ歩きをしようと思いつきました。
自転車をこげば走行距離に応じてカロリーが消費されますが、ケーキを食べればその分カロリーが摂取されます。正味の消費カロリーは、自転車をこいで消費したカロリーからケーキを食べて摂取したカロリーを引いた値になります。したがって、正味の消費カロリーが 0 より小さくなることもあります。
ケーキ屋さんでケーキを買ったら、 Aさんはその場でケーキを全部食べてしまいます。 Aさんがすべてのケーキ屋さんに立ち寄るとは限りませんが、ケーキ屋さんが存在する地点を通るときには、必ず立ち寄ってケーキを 1 つ買って食べるものとします。ただし、同じケーキ屋さんの前を何度も通るのはさすがに気がひけるので、各ケーキ屋さんに訪れられるのは 1 回だけとします。また、目的地の市役所をいったん通り過ぎてからケーキ屋さんに立ち寄り、その後で市役所に戻って用を済ませてもよいものとし、ケーキ屋さん以外は何度訪れても良いものとします。
A さんの自宅から市役所までの地図情報と、その途中にあるケーキ屋さんで食べられるケーキのカロリーの一覧、単位距離の走行による消費カロリーを入力とし、自宅を出発してから市役所に入るまでの正味の消費カロリーの最小値を出力するプログラムを作成してください。
地図には、A さんの自宅と市役所、ケーキ屋さんとランドマーク(目印)になる建物が書かれています。地図を表す入力データは、A さんの自宅、市役所、ケーキ屋さんとランドマークの各地点の間をつなぐ道があるとき、2 つの地点を表す記号とその間の距離からなる行を含みます。たとえば、5 番目のケーキ屋さんと 3 番目のランドマークの間の距離が 10 なら、入力データは以下のような行を含みます。
C5 L3 10
このようにケーキ屋さんには C、ランドマークには L を番号の前につけて表します。また、A さんの自宅は H、市役所は D で表します。入力データに 2 つの地点とその間の距離が与えられているなら、2 地点の間をどちら向きにも進めます。たとえば、上の例ではケーキ屋さんからランドマークへも、その逆向きへも進むことができます。また、自宅から市役所までは必ずたどり着けるものとします。それ以外に与えられる入力データは、ケーキ屋さんの数
m
、ランドマークの数
n
、単位距離あたりの消費カロリー
k
、 1 番目のケーキ屋さんから
m
番目のケーキ屋さんまでのそれぞれで買えるケーキのカロリーを表す
m
個のデータ、距離のデータの総数
d
です。
Input
複数のデータセットの並びが入力として与えられます。入力の終わりは四つの 0 の行で示されます。
  各データセットは以下の形式で与えられます。
m
n
k
d
c
1
c
2
...
c
m
s
1
t
1
e
1
s
2
t
2
e
2
:
s
d
t
d
e
d
1 行目にケーキ屋さんの数
m
(1 ≤
m
≤ 6)、 ランドマークの数
n
(1 ≤
n
≤ 100) 、単位距離あたりの消費カロリー
k
(1 ≤
k
≤ 5)、距離のデータの総数
d
(5 ≤
d
≤ 256) が与えられます。
2 行目に各ケーキ屋で買うケーキのカロリー
c
i
(1 ≤
c
i
≤ 100) が与えられます。
続く
d
行に
i
番目の 2 つの地点間の距離データ
s
i
,
t
i
,
e
i
(1 ≤
e
i
≤ 20)  が与えられます。
データセットの数は 100 を超えません。
Output
入力データセットごとに、全体の消費カロリーの最小値を１行に出力します。
Sample Input
1 1 2 5
35
H L1 5
C1 D 6
C1 H 12
L1 D 10
C1 L1 20
2 1 4 6
100 70
H L1 5
C1 L1 12
C1 D 11
C2 L1 7
C2 D 15
L1 D 8
0 0 0 0
Output for the Sample Input
1
-2",C,"#include<stdio.h>
#include<string.h>
#include<stdbool.h>

#define MIN(x,y) (((x)<(y))?(x):(y))
#define INFTY (1<<21)


int m, n, k, d, C[7], G[110][110], N, D[110][64];

int getID(char *str);
int isC(int x);
int bellman(void);

int main(void){
  char source[16], target[16];
  int cost,s,t;
  int i,j;
  while(scanf(""%d%*c%d%*c%d%*c%d%*c"",&m,&n,&k,&d) && m ){
    N = 2 + n + m;
    for(i=1;i<m+1;i++) scanf(""%d%*c"",&C[i]);
    for(i=0;i<N;i++) for(j=0;j<N;j++) G[i][j] = INFTY;
    for(i=0;i<d;i++){
      scanf(""%s%*c%s%*c%d%*c"",source,target,&cost);
      s = getID(source);
      t = getID(target);
      G[t][s] = G[s][t] = MIN(G[s][t], cost * k);
    }
    printf(""%d\n"",bellman());
  }
  return 0;
}

int getID(char *str){
  char num[16];
  if ( str[0] == 'H' ) return 0;
  if ( str[0] == 'D' ) return N - 1;
  strcpy(num,str+1);
  if ( str[0] == 'C' ) return atoi(num);
  return atoi(num) + m;
}

int isC(int x){
  return 1 <= x && x <= m;
}
int bellman(void){
  bool change=0;
  int minv;
  int i,o,u,v,b,j;

  for(i=0;i<N;i++) for(j=0;j<(1<<m);j++) D[i][j] = INFTY;
  D[0][0] = 0;
  for(o=0;o<N*(1<<m);o++){
    for(u=0;u<N;u++){
      for(v=0;v<N;v++){
	if ( u == v || G[u][v] == INFTY ) continue;
	for(b=0;b<(1<<m);b++){
	  if (isC(v) && (b&(1<<(v-1))) != 0 ) continue;
	  if ( isC(v) ) {
	    if ( D[u][b] + G[u][v] - C[v] < D[v][b|(1<<(v-1))] ) {
	      D[v][b|(1<<(v-1))] = D[u][b] + G[u][v] - C[v];
	      change = true;
	    }
	  } else {
	    if ( D[u][b] + G[u][v] < D[v][b] ){
	      D[v][b] = D[u][b] + G[u][v];
	      change = true;
	    }
	  }
	}
      }
    }
    if ( !change ) break;
  }
  minv = INFTY;
  for(i=0;i<(1<<m);i++) minv = MIN(minv, D[N-1][i]);
  return minv;
}",1
p00224,"自転車でダイエット
A さんは甘いものが大好きですが、最近は奥さんからダイエットするように言われています。ある日、A さんが自宅から市役所に出かけるとき、奥さんは自転車で行くことを勧めました。そこでA さんはしぶしぶ自転車に乗って出かけましたが、甘い物の好きな A さんは、途中にあるケーキ屋さんに立ち寄りケーキの食べ歩きをしようと思いつきました。
自転車をこげば走行距離に応じてカロリーが消費されますが、ケーキを食べればその分カロリーが摂取されます。正味の消費カロリーは、自転車をこいで消費したカロリーからケーキを食べて摂取したカロリーを引いた値になります。したがって、正味の消費カロリーが 0 より小さくなることもあります。
ケーキ屋さんでケーキを買ったら、 Aさんはその場でケーキを全部食べてしまいます。 Aさんがすべてのケーキ屋さんに立ち寄るとは限りませんが、ケーキ屋さんが存在する地点を通るときには、必ず立ち寄ってケーキを 1 つ買って食べるものとします。ただし、同じケーキ屋さんの前を何度も通るのはさすがに気がひけるので、各ケーキ屋さんに訪れられるのは 1 回だけとします。また、目的地の市役所をいったん通り過ぎてからケーキ屋さんに立ち寄り、その後で市役所に戻って用を済ませてもよいものとし、ケーキ屋さん以外は何度訪れても良いものとします。
A さんの自宅から市役所までの地図情報と、その途中にあるケーキ屋さんで食べられるケーキのカロリーの一覧、単位距離の走行による消費カロリーを入力とし、自宅を出発してから市役所に入るまでの正味の消費カロリーの最小値を出力するプログラムを作成してください。
地図には、A さんの自宅と市役所、ケーキ屋さんとランドマーク(目印)になる建物が書かれています。地図を表す入力データは、A さんの自宅、市役所、ケーキ屋さんとランドマークの各地点の間をつなぐ道があるとき、2 つの地点を表す記号とその間の距離からなる行を含みます。たとえば、5 番目のケーキ屋さんと 3 番目のランドマークの間の距離が 10 なら、入力データは以下のような行を含みます。
C5 L3 10
このようにケーキ屋さんには C、ランドマークには L を番号の前につけて表します。また、A さんの自宅は H、市役所は D で表します。入力データに 2 つの地点とその間の距離が与えられているなら、2 地点の間をどちら向きにも進めます。たとえば、上の例ではケーキ屋さんからランドマークへも、その逆向きへも進むことができます。また、自宅から市役所までは必ずたどり着けるものとします。それ以外に与えられる入力データは、ケーキ屋さんの数
m
、ランドマークの数
n
、単位距離あたりの消費カロリー
k
、 1 番目のケーキ屋さんから
m
番目のケーキ屋さんまでのそれぞれで買えるケーキのカロリーを表す
m
個のデータ、距離のデータの総数
d
です。
Input
複数のデータセットの並びが入力として与えられます。入力の終わりは四つの 0 の行で示されます。
  各データセットは以下の形式で与えられます。
m
n
k
d
c
1
c
2
...
c
m
s
1
t
1
e
1
s
2
t
2
e
2
:
s
d
t
d
e
d
1 行目にケーキ屋さんの数
m
(1 ≤
m
≤ 6)、 ランドマークの数
n
(1 ≤
n
≤ 100) 、単位距離あたりの消費カロリー
k
(1 ≤
k
≤ 5)、距離のデータの総数
d
(5 ≤
d
≤ 256) が与えられます。
2 行目に各ケーキ屋で買うケーキのカロリー
c
i
(1 ≤
c
i
≤ 100) が与えられます。
続く
d
行に
i
番目の 2 つの地点間の距離データ
s
i
,
t
i
,
e
i
(1 ≤
e
i
≤ 20)  が与えられます。
データセットの数は 100 を超えません。
Output
入力データセットごとに、全体の消費カロリーの最小値を１行に出力します。
Sample Input
1 1 2 5
35
H L1 5
C1 D 6
C1 H 12
L1 D 10
C1 L1 20
2 1 4 6
100 70
H L1 5
C1 L1 12
C1 D 11
C2 L1 7
C2 D 15
L1 D 8
0 0 0 0
Output for the Sample Input
1
-2",Java,"import java.util.*;
import java.io.*;

public class Main {
    static class Edge {
        String to;
        int dist;
        Edge(String to, int dist) {
            this.to = to;
            this.dist = dist;
        }
    }
    
    static Map<String, List<Edge>> graph;
    static int[] cakeCals;
    static int m, n, k, d;
    static Map<String, Integer> nodeToIdx;
    static String[] idxToNode;
    static int numNodes;
    static int[][] dist;
    static final int INF = 1000000000;
    
    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        String line;
        
        while ((line = br.readLine()) != null) {
            String[] parts = line.trim().split(""\\s+"");
            m = Integer.parseInt(parts[0]);
            n = Integer.parseInt(parts[1]);
            k = Integer.parseInt(parts[2]);
            d = Integer.parseInt(parts[3]);
            
            if (m == 0 && n == 0 && k == 0 && d == 0) break;
            
            cakeCals = new int[m + 1];
            parts = br.readLine().trim().split(""\\s+"");
            for (int i = 1; i <= m; i++) {
                cakeCals[i] = Integer.parseInt(parts[i - 1]);
            }
            
            graph = new HashMap<>();
            Set<String> nodes = new HashSet<>();
            
            for (int i = 0; i < d; i++) {
                parts = br.readLine().trim().split(""\\s+"");
                String s = parts[0];
                String t = parts[1];
                int e = Integer.parseInt(parts[2]);
                
                nodes.add(s);
                nodes.add(t);
                
                graph.putIfAbsent(s, new ArrayList<>());
                graph.putIfAbsent(t, new ArrayList<>());
                graph.get(s).add(new Edge(t, e));
                graph.get(t).add(new Edge(s, e));
            }
            
            nodeToIdx = new HashMap<>();
            idxToNode = new String[nodes.size()];
            int idx = 0;
            for (String node : nodes) {
                nodeToIdx.put(node, idx);
                idxToNode[idx] = node;
                idx++;
            }
            numNodes = nodes.size();
            
            // Floyd-Warshall
            dist = new int[numNodes][numNodes];
            for (int i = 0; i < numNodes; i++) {
                Arrays.fill(dist[i], INF);
                dist[i][i] = 0;
            }
            
            for (String from : graph.keySet()) {
                int fromIdx = nodeToIdx.get(from);
                for (Edge e : graph.get(from)) {
                    int toIdx = nodeToIdx.get(e.to);
                    dist[fromIdx][toIdx] = Math.min(dist[fromIdx][toIdx], e.dist);
                }
            }
            
            for (int kk = 0; kk < numNodes; kk++) {
                for (int i = 0; i < numNodes; i++) {
                    for (int j = 0; j < numNodes; j++) {
                        if (dist[i][kk] != INF && dist[kk][j] != INF) {
                            dist[i][j] = Math.min(dist[i][j], dist[i][kk] + dist[kk][j]);
                        }
                    }
                }
            }
            
            int minCal = INF;
            
            // Try all permutations of visiting cake shops
            for (int mask = 0; mask < (1 << m); mask++) {
                List<Integer> cakeShops = new ArrayList<>();
                for (int i = 0; i < m; i++) {
                    if ((mask & (1 << i)) != 0) {
                        cakeShops.add(i + 1);
                    }
                }
                
                if (cakeShops.isEmpty()) {
                    int hIdx = nodeToIdx.get(""H"");
                    int dIdx = nodeToIdx.get(""D"");
                    int totalDist = dist[hIdx][dIdx];
                    int cal = totalDist * k;
                    minCal = Math.min(minCal, cal);
                } else {
                    int[] perm = new int[cakeShops.size()];
                    for (int i = 0; i < cakeShops.size(); i++) {
                        perm[i] = cakeShops.get(i);
                    }
                    
                    permute(perm, 0, minCal);
                }
            }
            
            System.out.println(minCal);
        }
    }
    
    static int minCal;
    
    static void permute(int[] arr, int start, int currentMin) {
        if (start == arr.length) {
            int hIdx = nodeToIdx.get(""H"");
            int dIdx = nodeToIdx.get(""D"");
            
            int totalDist = dist[hIdx][nodeToIdx.get(""C"" + arr[0])];
            int totalCakeCal = cakeCals[arr[0]];
            
            for (int i = 1; i < arr.length; i++) {
                totalDist += dist[nodeToIdx.get(""C"" + arr[i - 1])][nodeToIdx.get(""C"" + arr[i])];
                totalCakeCal += cakeCals[arr[i]];
            }
            
            totalDist += dist[nodeToIdx.get(""C"" + arr[arr.length - 1])][dIdx];
            
            int cal = totalDist * k - totalCakeCal;
            minCal = Math.min(minCal, cal);
            return;
        }
        
        for (int i = start; i < arr.length; i++) {
            swap(arr, i, start);
            permute(arr, start + 1, currentMin);
            swap(arr, i, start);
        }
    }
    
    static void swap(int[] arr, int i, int j) {
        int temp = arr[i];
        arr[i] = arr[j];
        arr[j] = temp;
    }
}
",0
p00224,"自転車でダイエット
A さんは甘いものが大好きですが、最近は奥さんからダイエットするように言われています。ある日、A さんが自宅から市役所に出かけるとき、奥さんは自転車で行くことを勧めました。そこでA さんはしぶしぶ自転車に乗って出かけましたが、甘い物の好きな A さんは、途中にあるケーキ屋さんに立ち寄りケーキの食べ歩きをしようと思いつきました。
自転車をこげば走行距離に応じてカロリーが消費されますが、ケーキを食べればその分カロリーが摂取されます。正味の消費カロリーは、自転車をこいで消費したカロリーからケーキを食べて摂取したカロリーを引いた値になります。したがって、正味の消費カロリーが 0 より小さくなることもあります。
ケーキ屋さんでケーキを買ったら、 Aさんはその場でケーキを全部食べてしまいます。 Aさんがすべてのケーキ屋さんに立ち寄るとは限りませんが、ケーキ屋さんが存在する地点を通るときには、必ず立ち寄ってケーキを 1 つ買って食べるものとします。ただし、同じケーキ屋さんの前を何度も通るのはさすがに気がひけるので、各ケーキ屋さんに訪れられるのは 1 回だけとします。また、目的地の市役所をいったん通り過ぎてからケーキ屋さんに立ち寄り、その後で市役所に戻って用を済ませてもよいものとし、ケーキ屋さん以外は何度訪れても良いものとします。
A さんの自宅から市役所までの地図情報と、その途中にあるケーキ屋さんで食べられるケーキのカロリーの一覧、単位距離の走行による消費カロリーを入力とし、自宅を出発してから市役所に入るまでの正味の消費カロリーの最小値を出力するプログラムを作成してください。
地図には、A さんの自宅と市役所、ケーキ屋さんとランドマーク(目印)になる建物が書かれています。地図を表す入力データは、A さんの自宅、市役所、ケーキ屋さんとランドマークの各地点の間をつなぐ道があるとき、2 つの地点を表す記号とその間の距離からなる行を含みます。たとえば、5 番目のケーキ屋さんと 3 番目のランドマークの間の距離が 10 なら、入力データは以下のような行を含みます。
C5 L3 10
このようにケーキ屋さんには C、ランドマークには L を番号の前につけて表します。また、A さんの自宅は H、市役所は D で表します。入力データに 2 つの地点とその間の距離が与えられているなら、2 地点の間をどちら向きにも進めます。たとえば、上の例ではケーキ屋さんからランドマークへも、その逆向きへも進むことができます。また、自宅から市役所までは必ずたどり着けるものとします。それ以外に与えられる入力データは、ケーキ屋さんの数
m
、ランドマークの数
n
、単位距離あたりの消費カロリー
k
、 1 番目のケーキ屋さんから
m
番目のケーキ屋さんまでのそれぞれで買えるケーキのカロリーを表す
m
個のデータ、距離のデータの総数
d
です。
Input
複数のデータセットの並びが入力として与えられます。入力の終わりは四つの 0 の行で示されます。
  各データセットは以下の形式で与えられます。
m
n
k
d
c
1
c
2
...
c
m
s
1
t
1
e
1
s
2
t
2
e
2
:
s
d
t
d
e
d
1 行目にケーキ屋さんの数
m
(1 ≤
m
≤ 6)、 ランドマークの数
n
(1 ≤
n
≤ 100) 、単位距離あたりの消費カロリー
k
(1 ≤
k
≤ 5)、距離のデータの総数
d
(5 ≤
d
≤ 256) が与えられます。
2 行目に各ケーキ屋で買うケーキのカロリー
c
i
(1 ≤
c
i
≤ 100) が与えられます。
続く
d
行に
i
番目の 2 つの地点間の距離データ
s
i
,
t
i
,
e
i
(1 ≤
e
i
≤ 20)  が与えられます。
データセットの数は 100 を超えません。
Output
入力データセットごとに、全体の消費カロリーの最小値を１行に出力します。
Sample Input
1 1 2 5
35
H L1 5
C1 D 6
C1 H 12
L1 D 10
C1 L1 20
2 1 4 6
100 70
H L1 5
C1 L1 12
C1 D 11
C2 L1 7
C2 D 15
L1 D 8
0 0 0 0
Output for the Sample Input
1
-2",Java,"import java.util.*;
import java.math.*;
public class Main{

	static int INF = 2 << 27;
	static int m;
	static int n;
	static int k;
	static int d;
	public static void main(String[] args) {
		Scanner sc = new Scanner(System.in);
		while(true) {
			m = sc.nextInt();
			n = sc.nextInt();
			k = sc.nextInt();
			d = sc.nextInt();
			if(m == 0 && n == 0 && k == 0 && d == 0) break;
			int[] c = new int[m];
			for(int i = 0; i < m; i++) {
				c[i] = sc.nextInt();
			}
			Node[] node = new Node[m + n + 2];
			for(int i = 0; i < m; i++) {
				node[i] = new Node();
				node[i].type = 2;
			}
			for(int i = m; i < m + n; i++) {
				node[i] = new Node();
				node[i].type = 3;
			}
			node[m + n    ] = new Node();
			node[m + n    ].type = 0;
			node[m + n + 1] = new Node();
			node[m + n + 1].type = 1;
			
			for(int i = 0; i < d; i++) {
				String a = sc.next();
				String b = sc.next();
				int cost = sc.nextInt();
				int idA = -100;
				int idB = -100;
				if(a.length() == 1) {
					if(a.equals(""H"")) idA = m + n;
					else 			  idA = m + n + 1;
				}
				if(b.length() == 1) {
					if(b.equals(""H"")) idB = m + n;
					else			  idB = m + n + 1;
				}
				if(idA == -100) {
					if(a.charAt(0) == 'C') {
						idA = Integer.parseInt(a.substring(1)) - 1;
					}
					else {
						idA = m + Integer.parseInt(a.substring(1)) - 1;
					}
				}
				
				if(idB == -100) {
					if(b.charAt(0) == 'C') {
						idB = Integer.parseInt(b.substring(1)) - 1;
					}
					else {
						idB = m + Integer.parseInt(b.substring(1)) - 1;
					}
				}
				node[idA].edge_to.add(idB);
				node[idA].edge_cost.add(cost);
				node[idB].edge_to.add(idA);
				node[idB].edge_cost.add(cost);
			}
			int[][] dp = new int[n + m + 2][1 << m];
			for(int i = 0; i < dp.length; i++) {
				for(int j = 0; j < dp[i].length; j++) {
					dp[i][j] = INF;
				}
			}
			PriorityQueue<Data> queue = new PriorityQueue<Data>();
			queue.add(new Data(m + n,new boolean[m],0));
			while(!queue.isEmpty()) {
				Data tmp = queue.poll();
				int V = 0;
				for(int i = 0; i < tmp.v.length; i++) {
					if(tmp.v[i]) {
						V |= 1 << i;
					}
				}
				if(dp[tmp.now][V] <= tmp.cost) continue;
				dp[tmp.now][V] = tmp.cost;
				Node now = node[tmp.now];
				for(int i = 0; i < now.edge_to.size(); i++) {
					if(node[now.edge_to.get(i)].type == 2 && tmp.v[now.edge_to.get(i)]) continue;
					if(node[now.edge_to.get(i)].type == 2) {
						boolean[] copy = Arrays.copyOf(tmp.v, tmp.v.length);
						copy[now.edge_to.get(i)] = true; 
						queue.add(new Data(now.edge_to.get(i),copy, tmp.cost - c[now.edge_to.get(i)] + now.edge_cost.get(i) * k));
					}
					else {
						queue.add(new Data(now.edge_to.get(i),tmp.v, tmp.cost + now.edge_cost.get(i) * k));
					}
				}
			}
			int MIN = Integer.MAX_VALUE;
			for(int i = 0; i < dp[m + n + 1].length; i++) {
				MIN = Math.min(MIN, dp[m + n + 1][i]);
			}
			System.out.println(MIN);
		}
	}
	static class Data implements Comparable<Data>{
		int cost;
		boolean[] v;
		int now;
		@Override
		public int compareTo(Data o) {
			return this.cost - o.cost;
		}
		Data(int c, boolean[] b, int a) {
			cost = a;
			v    = b;
			now  = c;
		}
	}
	static class Node {
		int type; // 0 H, 1 D, 2 C, 3 L
		boolean c;
		ArrayList<Integer> edge_to = new ArrayList<Integer>();
		ArrayList<Integer> edge_cost = new ArrayList<Integer>();
	}
}",1
p00224,"自転車でダイエット
A さんは甘いものが大好きですが、最近は奥さんからダイエットするように言われています。ある日、A さんが自宅から市役所に出かけるとき、奥さんは自転車で行くことを勧めました。そこでA さんはしぶしぶ自転車に乗って出かけましたが、甘い物の好きな A さんは、途中にあるケーキ屋さんに立ち寄りケーキの食べ歩きをしようと思いつきました。
自転車をこげば走行距離に応じてカロリーが消費されますが、ケーキを食べればその分カロリーが摂取されます。正味の消費カロリーは、自転車をこいで消費したカロリーからケーキを食べて摂取したカロリーを引いた値になります。したがって、正味の消費カロリーが 0 より小さくなることもあります。
ケーキ屋さんでケーキを買ったら、 Aさんはその場でケーキを全部食べてしまいます。 Aさんがすべてのケーキ屋さんに立ち寄るとは限りませんが、ケーキ屋さんが存在する地点を通るときには、必ず立ち寄ってケーキを 1 つ買って食べるものとします。ただし、同じケーキ屋さんの前を何度も通るのはさすがに気がひけるので、各ケーキ屋さんに訪れられるのは 1 回だけとします。また、目的地の市役所をいったん通り過ぎてからケーキ屋さんに立ち寄り、その後で市役所に戻って用を済ませてもよいものとし、ケーキ屋さん以外は何度訪れても良いものとします。
A さんの自宅から市役所までの地図情報と、その途中にあるケーキ屋さんで食べられるケーキのカロリーの一覧、単位距離の走行による消費カロリーを入力とし、自宅を出発してから市役所に入るまでの正味の消費カロリーの最小値を出力するプログラムを作成してください。
地図には、A さんの自宅と市役所、ケーキ屋さんとランドマーク(目印)になる建物が書かれています。地図を表す入力データは、A さんの自宅、市役所、ケーキ屋さんとランドマークの各地点の間をつなぐ道があるとき、2 つの地点を表す記号とその間の距離からなる行を含みます。たとえば、5 番目のケーキ屋さんと 3 番目のランドマークの間の距離が 10 なら、入力データは以下のような行を含みます。
C5 L3 10
このようにケーキ屋さんには C、ランドマークには L を番号の前につけて表します。また、A さんの自宅は H、市役所は D で表します。入力データに 2 つの地点とその間の距離が与えられているなら、2 地点の間をどちら向きにも進めます。たとえば、上の例ではケーキ屋さんからランドマークへも、その逆向きへも進むことができます。また、自宅から市役所までは必ずたどり着けるものとします。それ以外に与えられる入力データは、ケーキ屋さんの数
m
、ランドマークの数
n
、単位距離あたりの消費カロリー
k
、 1 番目のケーキ屋さんから
m
番目のケーキ屋さんまでのそれぞれで買えるケーキのカロリーを表す
m
個のデータ、距離のデータの総数
d
です。
Input
複数のデータセットの並びが入力として与えられます。入力の終わりは四つの 0 の行で示されます。
  各データセットは以下の形式で与えられます。
m
n
k
d
c
1
c
2
...
c
m
s
1
t
1
e
1
s
2
t
2
e
2
:
s
d
t
d
e
d
1 行目にケーキ屋さんの数
m
(1 ≤
m
≤ 6)、 ランドマークの数
n
(1 ≤
n
≤ 100) 、単位距離あたりの消費カロリー
k
(1 ≤
k
≤ 5)、距離のデータの総数
d
(5 ≤
d
≤ 256) が与えられます。
2 行目に各ケーキ屋で買うケーキのカロリー
c
i
(1 ≤
c
i
≤ 100) が与えられます。
続く
d
行に
i
番目の 2 つの地点間の距離データ
s
i
,
t
i
,
e
i
(1 ≤
e
i
≤ 20)  が与えられます。
データセットの数は 100 を超えません。
Output
入力データセットごとに、全体の消費カロリーの最小値を１行に出力します。
Sample Input
1 1 2 5
35
H L1 5
C1 D 6
C1 H 12
L1 D 10
C1 L1 20
2 1 4 6
100 70
H L1 5
C1 L1 12
C1 D 11
C2 L1 7
C2 D 15
L1 D 8
0 0 0 0
Output for the Sample Input
1
-2",Python,"import sys
from itertools import permutations
from collections import defaultdict
import heapq

def dijkstra(graph, start, end, avoid_set):
    """"""Find shortest path avoiding nodes in avoid_set""""""
    dist = defaultdict(lambda: float('inf'))
    dist[start] = 0
    pq = [(0, start)]
    
    while pq:
        d, u = heapq.heappop(pq)
        if d > dist[u]:
            continue
        if u == end:
            return d
        for v, w in graph[u]:
            if v in avoid_set:
                continue
            if dist[u] + w < dist[v]:
                dist[v] = dist[u] + w
                heapq.heappush(pq, (dist[v], v))
    
    return float('inf')

def solve(m, n, k, d, calories, edges):
    # Build graph
    graph = defaultdict(list)
    for s, t, e in edges:
        graph[s].append((t, e))
        graph[t].append((s, e))
    
    # Get all cake shops
    cake_shops = [f'C{i+1}' for i in range(m)]
    
    min_cost = float('inf')
    
    # Try all subsets of cake shops (including empty set)
    for r in range(m + 1):
        for perm in permutations(cake_shops, r):
            # For this permutation, calculate the cost
            # We need to go from H to each shop in order, then to D
            # avoiding already visited shops
            
            visited_shops = set()
            current = 'H'
            total_distance = 0
            total_calories = 0
            valid = True
            
            for shop in perm:
                # Find shortest path from current to shop, avoiding visited shops
                dist = dijkstra(graph, current, shop, visited_shops)
                if dist == float('inf'):
                    valid = False
                    break
                total_distance += dist
                visited_shops.add(shop)
                # Eat cake at this shop
                shop_idx = int(shop[1:]) - 1
                total_calories += calories[shop_idx]
                current = shop
            
            if not valid:
                continue
            
            # Go from current to D, avoiding visited shops
            dist = dijkstra(graph, current, 'D', visited_shops)
            if dist == float('inf'):
                continue
            total_distance += dist
            
            # Calculate net calorie consumption
            net_calories = total_distance * k - total_calories
            min_cost = min(min_cost, net_calories)
    
    return min_cost

def main():
    while True:
        line = sys.stdin.readline().strip()
        if not line:
            break
        m, n, k, d = map(int, line.split())
        if m == 0 and n == 0 and k == 0 and d == 0:
            break
        
        calories = list(map(int, sys.stdin.readline().split()))
        
        edges = []
        for _ in range(d):
            parts = sys.stdin.readline().split()
            s, t, e = parts[0], parts[1], int(parts[2])
            edges.append((s, t, e))
        
        result = solve(m, n, k, d, calories, edges)
        print(result)

if __name__ == ""__main__"":
    main()
",0
p00224,"自転車でダイエット
A さんは甘いものが大好きですが、最近は奥さんからダイエットするように言われています。ある日、A さんが自宅から市役所に出かけるとき、奥さんは自転車で行くことを勧めました。そこでA さんはしぶしぶ自転車に乗って出かけましたが、甘い物の好きな A さんは、途中にあるケーキ屋さんに立ち寄りケーキの食べ歩きをしようと思いつきました。
自転車をこげば走行距離に応じてカロリーが消費されますが、ケーキを食べればその分カロリーが摂取されます。正味の消費カロリーは、自転車をこいで消費したカロリーからケーキを食べて摂取したカロリーを引いた値になります。したがって、正味の消費カロリーが 0 より小さくなることもあります。
ケーキ屋さんでケーキを買ったら、 Aさんはその場でケーキを全部食べてしまいます。 Aさんがすべてのケーキ屋さんに立ち寄るとは限りませんが、ケーキ屋さんが存在する地点を通るときには、必ず立ち寄ってケーキを 1 つ買って食べるものとします。ただし、同じケーキ屋さんの前を何度も通るのはさすがに気がひけるので、各ケーキ屋さんに訪れられるのは 1 回だけとします。また、目的地の市役所をいったん通り過ぎてからケーキ屋さんに立ち寄り、その後で市役所に戻って用を済ませてもよいものとし、ケーキ屋さん以外は何度訪れても良いものとします。
A さんの自宅から市役所までの地図情報と、その途中にあるケーキ屋さんで食べられるケーキのカロリーの一覧、単位距離の走行による消費カロリーを入力とし、自宅を出発してから市役所に入るまでの正味の消費カロリーの最小値を出力するプログラムを作成してください。
地図には、A さんの自宅と市役所、ケーキ屋さんとランドマーク(目印)になる建物が書かれています。地図を表す入力データは、A さんの自宅、市役所、ケーキ屋さんとランドマークの各地点の間をつなぐ道があるとき、2 つの地点を表す記号とその間の距離からなる行を含みます。たとえば、5 番目のケーキ屋さんと 3 番目のランドマークの間の距離が 10 なら、入力データは以下のような行を含みます。
C5 L3 10
このようにケーキ屋さんには C、ランドマークには L を番号の前につけて表します。また、A さんの自宅は H、市役所は D で表します。入力データに 2 つの地点とその間の距離が与えられているなら、2 地点の間をどちら向きにも進めます。たとえば、上の例ではケーキ屋さんからランドマークへも、その逆向きへも進むことができます。また、自宅から市役所までは必ずたどり着けるものとします。それ以外に与えられる入力データは、ケーキ屋さんの数
m
、ランドマークの数
n
、単位距離あたりの消費カロリー
k
、 1 番目のケーキ屋さんから
m
番目のケーキ屋さんまでのそれぞれで買えるケーキのカロリーを表す
m
個のデータ、距離のデータの総数
d
です。
Input
複数のデータセットの並びが入力として与えられます。入力の終わりは四つの 0 の行で示されます。
  各データセットは以下の形式で与えられます。
m
n
k
d
c
1
c
2
...
c
m
s
1
t
1
e
1
s
2
t
2
e
2
:
s
d
t
d
e
d
1 行目にケーキ屋さんの数
m
(1 ≤
m
≤ 6)、 ランドマークの数
n
(1 ≤
n
≤ 100) 、単位距離あたりの消費カロリー
k
(1 ≤
k
≤ 5)、距離のデータの総数
d
(5 ≤
d
≤ 256) が与えられます。
2 行目に各ケーキ屋で買うケーキのカロリー
c
i
(1 ≤
c
i
≤ 100) が与えられます。
続く
d
行に
i
番目の 2 つの地点間の距離データ
s
i
,
t
i
,
e
i
(1 ≤
e
i
≤ 20)  が与えられます。
データセットの数は 100 を超えません。
Output
入力データセットごとに、全体の消費カロリーの最小値を１行に出力します。
Sample Input
1 1 2 5
35
H L1 5
C1 D 6
C1 H 12
L1 D 10
C1 L1 20
2 1 4 6
100 70
H L1 5
C1 L1 12
C1 D 11
C2 L1 7
C2 D 15
L1 D 8
0 0 0 0
Output for the Sample Input
1
-2",Python,"from itertools import combinations
from heapq import heappop, heappush
import sys
sys.setrecursionlimit(1000000)
INF = 10 ** 20

def convert(s, m, n):
  if s == ""H"":
    return 0
  if s == ""D"":
    return 1
  if s[0] == ""C"":
    return int(s[1]) + 1
  if s[0] == ""L"":
    return int(s[1]) + m + 1

def get_cost(start, m, n, edges):
  cost = [INF] * (m + n + 2)
  cost[start] = 0
  que = []
  heappush(que, (0, start))
  while que:
    total, node = heappop(que)
    for dist, to in edges[node]:
      if cost[to] > total + dist:
        cost[to] = total + dist
        if not (2 <= to <= m + 1):
          heappush(que, (total + dist, to))
  return cost


def shortest_path(start, goal, rest, cakes_dist, dic):
  if not rest:
    return cakes_dist[start][goal]
  if (start, rest) in dic:
    return dic[(now, rest)]
  
  ret = INF
  for to in rest:
    ret = min(ret, shortest_path(to, goal, tuple((i for i in rest if i != to)), cakes_dist, dic) + cakes_dist[start][to])
  dic[(start, rest)] = ret
  return ret

while True:
  m, n, k, d = map(int, input().split())
  if m == 0:
    break
  clst = list(map(int, input().split()))
  """"""
  Home ... 0
  D ... 1
  Cake ... 2, 3, ... m + 1
  Land ... m + 2, m + 3, ... m + n + 1
  """"""
  edges = [[] for _ in range(m + n + 2)]
  for _ in range(d):
    s, t, e = input().split()
    e = int(e)
    s = convert(s, m, n)
    t = convert(t, m, n)
    edges[s].append((e, t))
    edges[t].append((e, s))
  
  cakes_dist = [[INF] * (m + 2) for _ in range(m + 2)]
  for start in range(m + 2):
    cost = get_cost(start, m, n, edges)
    for to in range(m + 2):
      if to != start:
        cakes_dist[start][to] = cost[to]

",1
p00225,"こぶたぬきつねこ
A子さんの家に親戚のB男君がやってきました。彼は3歳で歌が大好きです。彼は幼稚園でならった「こぶたぬきつねこ」(山本直純作詞・作曲)という歌を一生懸命に歌っています。この歌では、4つのことば「こぶた」  「たぬき」 「きつね」「ねこ」が順にしりとりになっていて、さらに最後の音と最初の音が同じになっています。B男君は、A子さんに、同じようなしりとりが、B男君が言った単語から作れるか教えて欲しいと言われました。
そこで、A子さんを助けるために、与えられた単語から、その単語をすべて使って、順にしりとりをつくり、その上で、 第1 の単語の最初の文字と最終の単語の最後の文字が同じであるようにできるか否かを判定するプログラムを作成しましょう。
n
個の単語を入力とし、それらの単語の組からしりとりを作成できるか否かを判定し、可能な場合はOK と、不可能な場合は NG と出力するプログラムを作成してください。
Input
複数のデータセットの並びが入力として与えられます。入力の終わりはゼロひとつの行で示されます。
各データセットは以下の形式で与えられます。
n
word
1
word
2
:
word
n
1 行目に単語の個数
n
(2 ≤
n
≤ 10000) が与えられます。続く
n
行に
n
個の単語
word
i
(32 文字以下の半角英小文字だけからなる文字列) が与えられます。
データセットの数は 50 を超えません。
Output
入力データセットごとに、判定結果を１行に出力します。
Sample Input
5
apple
yellow
georgia
king
email
7
apple
yellow
georgia
king
email
wink
lucky
0
Output for the Sample Input
NG
OK",C,"#include <stdio.h>
#include <string.h>

int main() {
    int n;
    while (scanf(""%d"", &n) == 1 && n != 0) {
        char words[10000][33];
        int first[10000], last[10000];
        
        for (int i = 0; i < n; i++) {
            scanf(""%s"", words[i]);
            first[i] = words[i][0] - 'a';
            last[i] = words[i][strlen(words[i]) - 1] - 'a';
        }
        
        int in_degree[26] = {0};
        int out_degree[26] = {0};
        int char_used[26] = {0};
        
        for (int i = 0; i < n; i++) {
            out_degree[first[i]]++;
            in_degree[last[i]]++;
            char_used[first[i]] = 1;
            char_used[last[i]] = 1;
        }
        
        int start_count = 0;
        int end_count = 0;
        int ok = 1;
        
        for (int i = 0; i < 26; i++) {
            if (out_degree[i] - in_degree[i] == 1) {
                start_count++;
            } else if (in_degree[i] - out_degree[i] == 1) {
                end_count++;
            } else if (in_degree[i] != out_degree[i]) {
                ok = 0;
                break;
            }
        }
        
        if (ok) {
            if (!((start_count == 0 && end_count == 0) || (start_count == 1 && end_count == 1))) {
                ok = 0;
            }
        }
        
        if (ok) {
            int adj[26][26] = {0};
            for (int i = 0; i < n; i++) {
                adj[first[i]][last[i]] = 1;
            }
            
            int visited[26] = {0};
            int start_node = -1;
            for (int i = 0; i < 26; i++) {
                if (char_used[i]) {
                    start_node = i;
                    break;
                }
            }
            
            int stack[26];
            int top = 0;
            stack[top++] = start_node;
            visited[start_node] = 1;
            
            while (top > 0) {
                int node = stack[--top];
                for (int i = 0; i < 26; i++) {
                    if ((adj[node][i] || adj[i][node]) && !visited[i]) {
                        visited[i] = 1;
                        stack[top++] = i;
                    }
                }
            }
            
            for (int i = 0; i < 26; i++) {
                if (char_used[i] && !visited[i]) {
                    ok = 0;
                    break;
                }
            }
        }
        
        printf(""%s\n"", ok ? ""OK"" : ""NG"");
    }
    return 0;
}
",0
p00225,"こぶたぬきつねこ
A子さんの家に親戚のB男君がやってきました。彼は3歳で歌が大好きです。彼は幼稚園でならった「こぶたぬきつねこ」(山本直純作詞・作曲)という歌を一生懸命に歌っています。この歌では、4つのことば「こぶた」  「たぬき」 「きつね」「ねこ」が順にしりとりになっていて、さらに最後の音と最初の音が同じになっています。B男君は、A子さんに、同じようなしりとりが、B男君が言った単語から作れるか教えて欲しいと言われました。
そこで、A子さんを助けるために、与えられた単語から、その単語をすべて使って、順にしりとりをつくり、その上で、 第1 の単語の最初の文字と最終の単語の最後の文字が同じであるようにできるか否かを判定するプログラムを作成しましょう。
n
個の単語を入力とし、それらの単語の組からしりとりを作成できるか否かを判定し、可能な場合はOK と、不可能な場合は NG と出力するプログラムを作成してください。
Input
複数のデータセットの並びが入力として与えられます。入力の終わりはゼロひとつの行で示されます。
各データセットは以下の形式で与えられます。
n
word
1
word
2
:
word
n
1 行目に単語の個数
n
(2 ≤
n
≤ 10000) が与えられます。続く
n
行に
n
個の単語
word
i
(32 文字以下の半角英小文字だけからなる文字列) が与えられます。
データセットの数は 50 を超えません。
Output
入力データセットごとに、判定結果を１行に出力します。
Sample Input
5
apple
yellow
georgia
king
email
7
apple
yellow
georgia
king
email
wink
lucky
0
Output for the Sample Input
NG
OK",C,"/*
AizuOnline A0225
Title
@kankichi573
*/
#include <stdio.h>
// Select Below
//#include <stdlib.h>
#include <string.h>
//#include <float.h>
//#include <math.h>
//#include <limits.h>
//Global data section
int n;
int dir[26];     // in +1 out -1
int alpha[26];   // tunagatte iruka
char buf[33];
char con[26][26];  //char a->b connection
char con_flag[26]; 
//
int count_char()
{
        int i,cnt=0;

        for(i=0;i<26;i++)
        {
                if (alpha[i])
                {
                        cnt ++;
                        //printf(""CH %c\n"",'a'+i);
                }
        }
        return(cnt);
}
int find_first()
{
        int i,cnt=0;

        for(i=0;i<26;i++)
                if(alpha[i]>0)
                        return(i);
        return(-1);
}

int connected()
{
        int from;

        from=find_first();
        //printf(""FF=%c\n"",'a'+from);
        con_flag[from]=1;
        return(connected2(from));
}
int connected2(int node)
{
        int i;
        int cnt=1;
        //printf(""CN2=%c\n"",'a'+node);

        for(i=0;i<26;i++)
        {
                if(i==node)
                        continue;
                if(con[node][i] && !con_flag[i])
                {
                        //printf(""CN2_2=%c\n"",'a'+i);

                        con_flag[i]=1;
                        cnt += connected2(i);
                        con_flag[i]=0;
                }
        }
        return(cnt);
}
main()
{
        int i,j;
        int stt,end,ret,ret1;
        while(EOF!=scanf(""%d"",&n) && n)
        {
                for(i=0;i<26;i++)
                {
                        alpha[i]=0;
                        dir[i]=0;
                        con_flag[i]=0;
                        for(j=0;j<26;j++)
                                con[i][j]=0;
                }
                for(i=0;i<n;i++)
                {
                        scanf(""%s"",buf);
                        stt=buf[0]-'a';
                        end=buf[strlen(buf)-1]-'a';
                        dir[stt]++;
                        dir[end]--;
                        alpha[stt]=alpha[end]=1;
                        con[stt][end]=1;
                }

                ret=connected();   // saisho ni toujou suru
                                   //node to tunagatte iru suu
                ret1=count_char(); // node no kazu

                //printf(""r=%d %d\n"",ret,ret1);

                if(ret != ret1)   // subeteno node ga tunagaruka
                {
                        printf(""NG\n"");
                        continue;
                }

                for(i=0;i<26;i++) //zenbu guuten ka siraberu
                        if(dir[i])
                        {
                                printf(""NG\n"");
                                goto NEXT;
                        }
                printf(""OK\n"");
        NEXT:
                ;
        }
return(0);
}",1
p00225,"こぶたぬきつねこ
A子さんの家に親戚のB男君がやってきました。彼は3歳で歌が大好きです。彼は幼稚園でならった「こぶたぬきつねこ」(山本直純作詞・作曲)という歌を一生懸命に歌っています。この歌では、4つのことば「こぶた」  「たぬき」 「きつね」「ねこ」が順にしりとりになっていて、さらに最後の音と最初の音が同じになっています。B男君は、A子さんに、同じようなしりとりが、B男君が言った単語から作れるか教えて欲しいと言われました。
そこで、A子さんを助けるために、与えられた単語から、その単語をすべて使って、順にしりとりをつくり、その上で、 第1 の単語の最初の文字と最終の単語の最後の文字が同じであるようにできるか否かを判定するプログラムを作成しましょう。
n
個の単語を入力とし、それらの単語の組からしりとりを作成できるか否かを判定し、可能な場合はOK と、不可能な場合は NG と出力するプログラムを作成してください。
Input
複数のデータセットの並びが入力として与えられます。入力の終わりはゼロひとつの行で示されます。
各データセットは以下の形式で与えられます。
n
word
1
word
2
:
word
n
1 行目に単語の個数
n
(2 ≤
n
≤ 10000) が与えられます。続く
n
行に
n
個の単語
word
i
(32 文字以下の半角英小文字だけからなる文字列) が与えられます。
データセットの数は 50 を超えません。
Output
入力データセットごとに、判定結果を１行に出力します。
Sample Input
5
apple
yellow
georgia
king
email
7
apple
yellow
georgia
king
email
wink
lucky
0
Output for the Sample Input
NG
OK",Java,"import java.util.*;

public class Main {
    static Map<Character, List<String>> startMap;
    static Map<Character, List<String>> endMap;
    static Set<String> used;
    static List<String> words;
    static int n;
    
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        
        while (true) {
            n = sc.nextInt();
            if (n == 0) break;
            
            words = new ArrayList<>();
            startMap = new HashMap<>();
            endMap = new HashMap<>();
            
            for (int i = 0; i < n; i++) {
                String word = sc.next();
                words.add(word);
                
                char start = word.charAt(0);
                char end = word.charAt(word.length() - 1);
                
                startMap.putIfAbsent(start, new ArrayList<>());
                startMap.get(start).add(word);
                
                endMap.putIfAbsent(end, new ArrayList<>());
                endMap.get(end).add(word);
            }
            
            boolean found = false;
            for (String firstWord : words) {
                used = new HashSet<>();
                used.add(firstWord);
                char startChar = firstWord.charAt(0);
                char endChar = firstWord.charAt(firstWord.length() - 1);
                
                if (dfs(endChar, startChar, 1)) {
                    found = true;
                    break;
                }
            }
            
            System.out.println(found ? ""OK"" : ""NG"");
        }
        
        sc.close();
    }
    
    static boolean dfs(char currentEnd, char targetStart, int count) {
        if (count == n) {
            return currentEnd == targetStart;
        }
        
        if (!startMap.containsKey(currentEnd)) {
            return false;
        }
        
        for (String word : startMap.get(currentEnd)) {
            if (!used.contains(word)) {
                used.add(word);
                char nextEnd = word.charAt(word.length() - 1);
                if (dfs(nextEnd, targetStart, count + 1)) {
                    return true;
                }
                used.remove(word);
            }
        }
        
        return false;
    }
}
",0
p00225,"こぶたぬきつねこ
A子さんの家に親戚のB男君がやってきました。彼は3歳で歌が大好きです。彼は幼稚園でならった「こぶたぬきつねこ」(山本直純作詞・作曲)という歌を一生懸命に歌っています。この歌では、4つのことば「こぶた」  「たぬき」 「きつね」「ねこ」が順にしりとりになっていて、さらに最後の音と最初の音が同じになっています。B男君は、A子さんに、同じようなしりとりが、B男君が言った単語から作れるか教えて欲しいと言われました。
そこで、A子さんを助けるために、与えられた単語から、その単語をすべて使って、順にしりとりをつくり、その上で、 第1 の単語の最初の文字と最終の単語の最後の文字が同じであるようにできるか否かを判定するプログラムを作成しましょう。
n
個の単語を入力とし、それらの単語の組からしりとりを作成できるか否かを判定し、可能な場合はOK と、不可能な場合は NG と出力するプログラムを作成してください。
Input
複数のデータセットの並びが入力として与えられます。入力の終わりはゼロひとつの行で示されます。
各データセットは以下の形式で与えられます。
n
word
1
word
2
:
word
n
1 行目に単語の個数
n
(2 ≤
n
≤ 10000) が与えられます。続く
n
行に
n
個の単語
word
i
(32 文字以下の半角英小文字だけからなる文字列) が与えられます。
データセットの数は 50 を超えません。
Output
入力データセットごとに、判定結果を１行に出力します。
Sample Input
5
apple
yellow
georgia
king
email
7
apple
yellow
georgia
king
email
wink
lucky
0
Output for the Sample Input
NG
OK",Java,"import java.util.ArrayList;
import java.util.Collections;
import java.util.List;
import java.util.Scanner;

public class Main {
	
	void run() {

		Scanner in = new Scanner(System.in);

		while(true) {

			int N = Integer.parseInt(in.next());
			
			if (N == 0) break;
			
			List<String> wordList = new ArrayList<String>();
			
			for(int i = 0; i < N; i++) {
				String word = in.next();
				wordList.add(word.substring(0, 1));
				wordList.add(word.substring(word.length() - 1, word.length()));
			}
			
			Collections.sort(wordList);
			
			if(check(wordList)) {
				System.out.println(""OK"");
			} else {
				System.out.println(""NG"");
			}
		}
	}
	
	boolean check(List<String> wordList) {
		
		int count = 1;
		String word1 = wordList.get(0);
		for(int i = 1; i < wordList.size(); i++) {
			String word2 = wordList.get(i);
			if(word1.equals(word2)) { 
				count++; 
			} else {
				if(count % 2 != 0) return false;
				word1 = word2;
				count = 1;
			}
		}
		if(count % 2 != 0) { 
			return false;
		} else {
			return true;
		}
	}

	public static void main(String[] args) {
		new Main().run();
	}

}",1
p00225,"こぶたぬきつねこ
A子さんの家に親戚のB男君がやってきました。彼は3歳で歌が大好きです。彼は幼稚園でならった「こぶたぬきつねこ」(山本直純作詞・作曲)という歌を一生懸命に歌っています。この歌では、4つのことば「こぶた」  「たぬき」 「きつね」「ねこ」が順にしりとりになっていて、さらに最後の音と最初の音が同じになっています。B男君は、A子さんに、同じようなしりとりが、B男君が言った単語から作れるか教えて欲しいと言われました。
そこで、A子さんを助けるために、与えられた単語から、その単語をすべて使って、順にしりとりをつくり、その上で、 第1 の単語の最初の文字と最終の単語の最後の文字が同じであるようにできるか否かを判定するプログラムを作成しましょう。
n
個の単語を入力とし、それらの単語の組からしりとりを作成できるか否かを判定し、可能な場合はOK と、不可能な場合は NG と出力するプログラムを作成してください。
Input
複数のデータセットの並びが入力として与えられます。入力の終わりはゼロひとつの行で示されます。
各データセットは以下の形式で与えられます。
n
word
1
word
2
:
word
n
1 行目に単語の個数
n
(2 ≤
n
≤ 10000) が与えられます。続く
n
行に
n
個の単語
word
i
(32 文字以下の半角英小文字だけからなる文字列) が与えられます。
データセットの数は 50 を超えません。
Output
入力データセットごとに、判定結果を１行に出力します。
Sample Input
5
apple
yellow
georgia
king
email
7
apple
yellow
georgia
king
email
wink
lucky
0
Output for the Sample Input
NG
OK",Python,"import sys
from collections import defaultdict, deque

def can_form_shiritori(words):
    if len(words) == 1:
        return words[0][0] == words[0][-1]
    
    # Build graph of first and last characters
    graph = defaultdict(list)
    in_degree = defaultdict(int)
    out_degree = defaultdict(int)
    
    for word in words:
        first = word[0]
        last = word[-1]
        graph[first].append(last)
        out_degree[first] += 1
        in_degree[last] += 1
    
    # Get all vertices
    vertices = set(in_degree.keys()) | set(out_degree.keys())
    
    # Check if Eulerian circuit exists
    # For Eulerian circuit: in_degree == out_degree for all vertices
    for v in vertices:
        if in_degree[v] != out_degree[v]:
            return False
    
    # Check if graph is connected (considering it as undirected for connectivity)
    # We need to check if all edges form one connected component
    if not vertices:
        return True
    
    # Build undirected graph for connectivity check
    undirected = defaultdict(set)
    for word in words:
        first = word[0]
        last = word[-1]
        undirected[first].add(last)
        undirected[last].add(first)
    
    # BFS to check connectivity
    start = next(iter(vertices))
    visited = set()
    queue = deque([start])
    visited.add(start)
    
    while queue:
        node = queue.popleft()
        for neighbor in undirected[node]:
            if neighbor not in visited:
                visited.add(neighbor)
                queue.append(neighbor)
    
    # Check if all vertices with non-zero degree are visited
    return len(visited) == len(vertices)

while True:
    n = int(input())
    if n == 0:
        break
    
    words = []
    for _ in range(n):
        words.append(input().strip())
    
    if can_form_shiritori(words):
        print(""OK"")
    else:
        print(""NG"")
",0
p00225,"こぶたぬきつねこ
A子さんの家に親戚のB男君がやってきました。彼は3歳で歌が大好きです。彼は幼稚園でならった「こぶたぬきつねこ」(山本直純作詞・作曲)という歌を一生懸命に歌っています。この歌では、4つのことば「こぶた」  「たぬき」 「きつね」「ねこ」が順にしりとりになっていて、さらに最後の音と最初の音が同じになっています。B男君は、A子さんに、同じようなしりとりが、B男君が言った単語から作れるか教えて欲しいと言われました。
そこで、A子さんを助けるために、与えられた単語から、その単語をすべて使って、順にしりとりをつくり、その上で、 第1 の単語の最初の文字と最終の単語の最後の文字が同じであるようにできるか否かを判定するプログラムを作成しましょう。
n
個の単語を入力とし、それらの単語の組からしりとりを作成できるか否かを判定し、可能な場合はOK と、不可能な場合は NG と出力するプログラムを作成してください。
Input
複数のデータセットの並びが入力として与えられます。入力の終わりはゼロひとつの行で示されます。
各データセットは以下の形式で与えられます。
n
word
1
word
2
:
word
n
1 行目に単語の個数
n
(2 ≤
n
≤ 10000) が与えられます。続く
n
行に
n
個の単語
word
i
(32 文字以下の半角英小文字だけからなる文字列) が与えられます。
データセットの数は 50 を超えません。
Output
入力データセットごとに、判定結果を１行に出力します。
Sample Input
5
apple
yellow
georgia
king
email
7
apple
yellow
georgia
king
email
wink
lucky
0
Output for the Sample Input
NG
OK",Python,"from collections import defaultdict
while True:
    try:
        n=input()
    except SyntaxError:
        pass
    if n==0:break
    dic=defaultdict(int)
    for i in range(n):
        w=raw_input()
        dic[w[0]]+=1
        dic[w[-1]]+=1
    if len(set(dic.values()))==1:
        print ""OK""
    else:
        print ""NG""",1
p00226,"ヒットアンドブロー
太郎君と花子さんはヒットアンドブローで遊ぶことにしました。ヒットアンドブローのルールは、以下の通りです。
出題者と回答者に分かれて行う。
出題者は、重複した数を含まない 4 桁の数字(正解)を決める。
回答者は、その 4 桁の数字(回答)を言い当てる。
回答に対して、出題者はヒットとブローの数でヒントを与える。
回答と正解を比べて、数と桁位置の両方が同じであることをヒットと呼び、数だけが同じで桁位置が異なることをブローと呼ぶ。たとえば、正解が 1234 で、回答が 1354 なら、出題者は「2 ヒット、1 ブロー」というヒントを与え、正解までこれを繰り返す。
出題者と回答者は交代してゲームを行い、より少ない回答で正解を言い当てた方を勝ちとする。
太郎君と花子さんは、ヒットの数とブローの数をその都度判断することが少し面倒に感じているようです。そんな二人のために、ヒットの数とブローの数が即座に分かるプログラムを作成してあげましょう。
正解
r
と回答
a
を入力とし、ヒットの数とブローの数を出力するプログラムを作成してください。
r
、
a
はそれぞれ 0 から 9 の数字 4 つからなる数字の列です。
Input
複数のデータセットの並びが入力として与えられます。入力の終わりはゼロふたつの行で示されます。各データセットとして、
r
と
a
が空白区切りで１行に与えられます。
データセットの数は 12000 を超えません。
Output
入力データセットごとに、ヒットの数とブローの数を１行に出力します。
Sample Input
1234 5678
1234 1354
1234 1234
1230 1023
0123 1234
0 0
Output for the Sample Input
0 0
2 1
4 0
1 3
0 3",C,"#include <stdio.h>
#include <string.h>

int main() {
    char r[5], a[5];
    
    while (1) {
        scanf(""%s %s"", r, a);
        
        if (strcmp(r, ""0"") == 0 && strcmp(a, ""0"") == 0) {
            break;
        }
        
        int hit = 0, blow = 0;
        
        // Count hits
        for (int i = 0; i < 4; i++) {
            if (r[i] == a[i]) {
                hit++;
            }
        }
        
        // Count blows
        for (int i = 0; i < 4; i++) {
            for (int j = 0; j < 4; j++) {
                if (i != j && r[i] == a[j]) {
                    blow++;
                }
            }
        }
        
        printf(""%d %d\n"", hit, blow);
    }
    
    return 0;
}
",0
p00226,"ヒットアンドブロー
太郎君と花子さんはヒットアンドブローで遊ぶことにしました。ヒットアンドブローのルールは、以下の通りです。
出題者と回答者に分かれて行う。
出題者は、重複した数を含まない 4 桁の数字(正解)を決める。
回答者は、その 4 桁の数字(回答)を言い当てる。
回答に対して、出題者はヒットとブローの数でヒントを与える。
回答と正解を比べて、数と桁位置の両方が同じであることをヒットと呼び、数だけが同じで桁位置が異なることをブローと呼ぶ。たとえば、正解が 1234 で、回答が 1354 なら、出題者は「2 ヒット、1 ブロー」というヒントを与え、正解までこれを繰り返す。
出題者と回答者は交代してゲームを行い、より少ない回答で正解を言い当てた方を勝ちとする。
太郎君と花子さんは、ヒットの数とブローの数をその都度判断することが少し面倒に感じているようです。そんな二人のために、ヒットの数とブローの数が即座に分かるプログラムを作成してあげましょう。
正解
r
と回答
a
を入力とし、ヒットの数とブローの数を出力するプログラムを作成してください。
r
、
a
はそれぞれ 0 から 9 の数字 4 つからなる数字の列です。
Input
複数のデータセットの並びが入力として与えられます。入力の終わりはゼロふたつの行で示されます。各データセットとして、
r
と
a
が空白区切りで１行に与えられます。
データセットの数は 12000 を超えません。
Output
入力データセットごとに、ヒットの数とブローの数を１行に出力します。
Sample Input
1234 5678
1234 1354
1234 1234
1230 1023
0123 1234
0 0
Output for the Sample Input
0 0
2 1
4 0
1 3
0 3",C,"#include<string.h>
#include<stdio.h>
int main()
{
	int h,b,i,j;
	char r[5],a[5];
	while(1){
		scanf(""%s %s"",r,a);
		if(strcmp(r,""0"")==0&&strcmp(a,""0"")==0){
			break;
		}
		h=0;
		b=0;
		for(i=0;i<4;i++){
			if(r[i]==a[i]){
				h++;
				r[i]='r';
				a[i]='a';
			}
		}
		for(i=0;i<4;i++){
			for(j=0;j<4;j++){
				if(r[i]==a[j]){
					b++;
					r[i]='r';
					a[j]='a';
				}
			}
		}
		printf(""%d %d\n"",h,b);
	}
	return 0;
}",1
p00226,"ヒットアンドブロー
太郎君と花子さんはヒットアンドブローで遊ぶことにしました。ヒットアンドブローのルールは、以下の通りです。
出題者と回答者に分かれて行う。
出題者は、重複した数を含まない 4 桁の数字(正解)を決める。
回答者は、その 4 桁の数字(回答)を言い当てる。
回答に対して、出題者はヒットとブローの数でヒントを与える。
回答と正解を比べて、数と桁位置の両方が同じであることをヒットと呼び、数だけが同じで桁位置が異なることをブローと呼ぶ。たとえば、正解が 1234 で、回答が 1354 なら、出題者は「2 ヒット、1 ブロー」というヒントを与え、正解までこれを繰り返す。
出題者と回答者は交代してゲームを行い、より少ない回答で正解を言い当てた方を勝ちとする。
太郎君と花子さんは、ヒットの数とブローの数をその都度判断することが少し面倒に感じているようです。そんな二人のために、ヒットの数とブローの数が即座に分かるプログラムを作成してあげましょう。
正解
r
と回答
a
を入力とし、ヒットの数とブローの数を出力するプログラムを作成してください。
r
、
a
はそれぞれ 0 から 9 の数字 4 つからなる数字の列です。
Input
複数のデータセットの並びが入力として与えられます。入力の終わりはゼロふたつの行で示されます。各データセットとして、
r
と
a
が空白区切りで１行に与えられます。
データセットの数は 12000 を超えません。
Output
入力データセットごとに、ヒットの数とブローの数を１行に出力します。
Sample Input
1234 5678
1234 1354
1234 1234
1230 1023
0123 1234
0 0
Output for the Sample Input
0 0
2 1
4 0
1 3
0 3",Java,"import java.util.Scanner;

public class Main {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        
        while (true) {
            String r = sc.next();
            String a = sc.next();
            
            if (r.equals(""0"") && a.equals(""0"")) {
                break;
            }
            
            int hits = 0;
            int blows = 0;
            
            // Count hits
            for (int i = 0; i < 4; i++) {
                if (r.charAt(i) == a.charAt(i)) {
                    hits++;
                }
            }
            
            // Count blows
            for (int i = 0; i < 4; i++) {
                for (int j = 0; j < 4; j++) {
                    if (i != j && r.charAt(i) == a.charAt(j)) {
                        blows++;
                    }
                }
            }
            
            System.out.println(hits + "" "" + blows);
        }
        
        sc.close();
    }
}
",0
p00226,"ヒットアンドブロー
太郎君と花子さんはヒットアンドブローで遊ぶことにしました。ヒットアンドブローのルールは、以下の通りです。
出題者と回答者に分かれて行う。
出題者は、重複した数を含まない 4 桁の数字(正解)を決める。
回答者は、その 4 桁の数字(回答)を言い当てる。
回答に対して、出題者はヒットとブローの数でヒントを与える。
回答と正解を比べて、数と桁位置の両方が同じであることをヒットと呼び、数だけが同じで桁位置が異なることをブローと呼ぶ。たとえば、正解が 1234 で、回答が 1354 なら、出題者は「2 ヒット、1 ブロー」というヒントを与え、正解までこれを繰り返す。
出題者と回答者は交代してゲームを行い、より少ない回答で正解を言い当てた方を勝ちとする。
太郎君と花子さんは、ヒットの数とブローの数をその都度判断することが少し面倒に感じているようです。そんな二人のために、ヒットの数とブローの数が即座に分かるプログラムを作成してあげましょう。
正解
r
と回答
a
を入力とし、ヒットの数とブローの数を出力するプログラムを作成してください。
r
、
a
はそれぞれ 0 から 9 の数字 4 つからなる数字の列です。
Input
複数のデータセットの並びが入力として与えられます。入力の終わりはゼロふたつの行で示されます。各データセットとして、
r
と
a
が空白区切りで１行に与えられます。
データセットの数は 12000 を超えません。
Output
入力データセットごとに、ヒットの数とブローの数を１行に出力します。
Sample Input
1234 5678
1234 1354
1234 1234
1230 1023
0123 1234
0 0
Output for the Sample Input
0 0
2 1
4 0
1 3
0 3",Java,"import java.util.*;

class Main{
	public static void main(String args[]){
		Scanner s=new Scanner (System.in);
		while(true){
			String a=s.next();
			String b=s.next();
			if(a.length()==1)System.exit(0);
			int hit=0;
			for(int i=0;i<4;i++)if(a.charAt(i)==b.charAt(i))hit++;
			int blow=0;
			for(int i=0;i<4;i++)
				for(int j=0;j<4;j++)
					if(a.charAt(i)==b.charAt(j)&&i!=j)blow++;
			System.out.println(hit+"" ""+blow);
		}
	}
}",1
p00226,"ヒットアンドブロー
太郎君と花子さんはヒットアンドブローで遊ぶことにしました。ヒットアンドブローのルールは、以下の通りです。
出題者と回答者に分かれて行う。
出題者は、重複した数を含まない 4 桁の数字(正解)を決める。
回答者は、その 4 桁の数字(回答)を言い当てる。
回答に対して、出題者はヒットとブローの数でヒントを与える。
回答と正解を比べて、数と桁位置の両方が同じであることをヒットと呼び、数だけが同じで桁位置が異なることをブローと呼ぶ。たとえば、正解が 1234 で、回答が 1354 なら、出題者は「2 ヒット、1 ブロー」というヒントを与え、正解までこれを繰り返す。
出題者と回答者は交代してゲームを行い、より少ない回答で正解を言い当てた方を勝ちとする。
太郎君と花子さんは、ヒットの数とブローの数をその都度判断することが少し面倒に感じているようです。そんな二人のために、ヒットの数とブローの数が即座に分かるプログラムを作成してあげましょう。
正解
r
と回答
a
を入力とし、ヒットの数とブローの数を出力するプログラムを作成してください。
r
、
a
はそれぞれ 0 から 9 の数字 4 つからなる数字の列です。
Input
複数のデータセットの並びが入力として与えられます。入力の終わりはゼロふたつの行で示されます。各データセットとして、
r
と
a
が空白区切りで１行に与えられます。
データセットの数は 12000 を超えません。
Output
入力データセットごとに、ヒットの数とブローの数を１行に出力します。
Sample Input
1234 5678
1234 1354
1234 1234
1230 1023
0123 1234
0 0
Output for the Sample Input
0 0
2 1
4 0
1 3
0 3",Python,"import sys

for line in sys.stdin:
    parts = line.strip().split()
    if len(parts) < 2:
        continue
    r, a = parts[0], parts[1]
    if r == '0' and a == '0':
        break
    
    hits = 0
    blows = 0
    
    for i in range(4):
        if r[i] == a[i]:
            hits += 1
    
    for i in range(4):
        if r[i] != a[i]:
            for j in range(4):
                if i != j and r[i] == a[j] and r[j] != a[j]:
                    blows += 1
                    break
    
    print(hits, blows)
",0
p00226,"ヒットアンドブロー
太郎君と花子さんはヒットアンドブローで遊ぶことにしました。ヒットアンドブローのルールは、以下の通りです。
出題者と回答者に分かれて行う。
出題者は、重複した数を含まない 4 桁の数字(正解)を決める。
回答者は、その 4 桁の数字(回答)を言い当てる。
回答に対して、出題者はヒットとブローの数でヒントを与える。
回答と正解を比べて、数と桁位置の両方が同じであることをヒットと呼び、数だけが同じで桁位置が異なることをブローと呼ぶ。たとえば、正解が 1234 で、回答が 1354 なら、出題者は「2 ヒット、1 ブロー」というヒントを与え、正解までこれを繰り返す。
出題者と回答者は交代してゲームを行い、より少ない回答で正解を言い当てた方を勝ちとする。
太郎君と花子さんは、ヒットの数とブローの数をその都度判断することが少し面倒に感じているようです。そんな二人のために、ヒットの数とブローの数が即座に分かるプログラムを作成してあげましょう。
正解
r
と回答
a
を入力とし、ヒットの数とブローの数を出力するプログラムを作成してください。
r
、
a
はそれぞれ 0 から 9 の数字 4 つからなる数字の列です。
Input
複数のデータセットの並びが入力として与えられます。入力の終わりはゼロふたつの行で示されます。各データセットとして、
r
と
a
が空白区切りで１行に与えられます。
データセットの数は 12000 を超えません。
Output
入力データセットごとに、ヒットの数とブローの数を１行に出力します。
Sample Input
1234 5678
1234 1354
1234 1234
1230 1023
0123 1234
0 0
Output for the Sample Input
0 0
2 1
4 0
1 3
0 3",Python,"while True:
    a,b=raw_input().split()
    if a==b==""0"":break
    hit,blow=0,0
    for i,j in zip(a,b):
        if i==j:
            hit+=1
    for i in a:
        if i in b:
            blow+=1
    print hit,blow-hit",1
p00227,"お客様大感謝祭
悪天候が続き野菜の価格が高騰する中、セブンマートではお客様に野菜のまとめ買いセールを実施しています。 日ごろなかなか店頭に並ばない野菜もお手頃価格で手に入るとあって、        店内はとても賑わっています。
ある日、松長団地に住む仲良し 3 人組がセブンマートの広告を手に話に花を咲かせていました。今回のセールは「お客様大感謝祭」と銘打っただけに、袋詰めした野菜の中で最も安いものが無料になるのが目玉となっています。広告を読んでみると、どうやら以下のようなセールのようです。
1 つの袋には
m
個まで野菜を詰められる。
野菜が
m
個詰めてある袋については、その中で最も安い野菜が無料となる。
野菜の個数が
m
個に達しない袋は割引の対象外。
3人は早速セブンマートへ買い物に行きました。
買い物が終わり、  お店の外で待ち合わせた 3 人は安くてたくさん購入できたことに満足した様子で話をしていると、どうやら 3 人とも同じ野菜を購入していたことが分かりました。ある一人が、「本当に安いわよねぇ。これでXXX円だもの!」と言うと、もう一人は、「え?私はそれより**円高かったわ!どうして?」と驚き、また、残りの一人はレシートを見て自分が一番安く購入したことに気付きました。
さて、どのように袋詰めすれば購入価格を一番安くできるでしょうか。 購入する野菜の個数、袋に入る野菜の個数、各野菜の値段を入力とし、最低購入価格を出力するプログラムを作成してください。
Input
複数のデータセットの並びが入力として与えられます。入力の終わりはゼロふたつの行で示されます。
各データセットは以下の形式で与えられます。
n
m
p
1
p
2
...
p
n
1 行目に購入する野菜の個数
n
(1 ≤
n
≤ 1000) と袋に入る野菜の個数
m
(1 ≤
m
≤ 1000)　が与えられます。２行目に各野菜の値段
p
i
(10 ≤
p
i
≤ 10000) が与えられます。
データセットの数は 100 を超えません。
Output
入力データセットごとに、最低購入価格を１行に出力します。
Sample Input
4 2
50 40 100 80
7 3
400 300 100 700 200 600 500
0 0
Output for the Sample Input
150
2100",C,"#include <stdio.h>
#include <stdlib.h>

int compare(const void *a, const void *b) {
    return (*(int*)b - *(int*)a);
}

int main() {
    int n, m;
    
    while(1) {
        scanf(""%d %d"", &n, &m);
        if(n == 0 && m == 0) break;
        
        int prices[1000];
        for(int i = 0; i < n; i++) {
            scanf(""%d"", &prices[i]);
        }
        
        qsort(prices, n, sizeof(int), compare);
        
        int total = 0;
        int count = 0;
        
        for(int i = 0; i < n; i++) {
            count++;
            if(count == m) {
                count = 0;
            } else {
                total += prices[i];
            }
        }
        
        printf(""%d\n"", total);
    }
    
    return 0;
}
",0
p00227,"お客様大感謝祭
悪天候が続き野菜の価格が高騰する中、セブンマートではお客様に野菜のまとめ買いセールを実施しています。 日ごろなかなか店頭に並ばない野菜もお手頃価格で手に入るとあって、        店内はとても賑わっています。
ある日、松長団地に住む仲良し 3 人組がセブンマートの広告を手に話に花を咲かせていました。今回のセールは「お客様大感謝祭」と銘打っただけに、袋詰めした野菜の中で最も安いものが無料になるのが目玉となっています。広告を読んでみると、どうやら以下のようなセールのようです。
1 つの袋には
m
個まで野菜を詰められる。
野菜が
m
個詰めてある袋については、その中で最も安い野菜が無料となる。
野菜の個数が
m
個に達しない袋は割引の対象外。
3人は早速セブンマートへ買い物に行きました。
買い物が終わり、  お店の外で待ち合わせた 3 人は安くてたくさん購入できたことに満足した様子で話をしていると、どうやら 3 人とも同じ野菜を購入していたことが分かりました。ある一人が、「本当に安いわよねぇ。これでXXX円だもの!」と言うと、もう一人は、「え?私はそれより**円高かったわ!どうして?」と驚き、また、残りの一人はレシートを見て自分が一番安く購入したことに気付きました。
さて、どのように袋詰めすれば購入価格を一番安くできるでしょうか。 購入する野菜の個数、袋に入る野菜の個数、各野菜の値段を入力とし、最低購入価格を出力するプログラムを作成してください。
Input
複数のデータセットの並びが入力として与えられます。入力の終わりはゼロふたつの行で示されます。
各データセットは以下の形式で与えられます。
n
m
p
1
p
2
...
p
n
1 行目に購入する野菜の個数
n
(1 ≤
n
≤ 1000) と袋に入る野菜の個数
m
(1 ≤
m
≤ 1000)　が与えられます。２行目に各野菜の値段
p
i
(10 ≤
p
i
≤ 10000) が与えられます。
データセットの数は 100 を超えません。
Output
入力データセットごとに、最低購入価格を１行に出力します。
Sample Input
4 2
50 40 100 80
7 3
400 300 100 700 200 600 500
0 0
Output for the Sample Input
150
2100",C,"n,m,i,p[1000],P;
//M(int*a){return*1[&a]-*a;}
M(int*a,int*b){return*b-*a;}
main(){
	for(;scanf(""%d%d"",&n,&m),n;){
		for(i=0;i<n;i++){
			scanf(""%d"",p+i);
		}
		qsort(p,n,4,M);
		P=0;
		for(i=0;i<n;i++){
			if(i%m!=m-1)
				P+=p[i];
		}
		printf(""%d\n"",P);
	}
	exit(0);
}",1
p00227,"お客様大感謝祭
悪天候が続き野菜の価格が高騰する中、セブンマートではお客様に野菜のまとめ買いセールを実施しています。 日ごろなかなか店頭に並ばない野菜もお手頃価格で手に入るとあって、        店内はとても賑わっています。
ある日、松長団地に住む仲良し 3 人組がセブンマートの広告を手に話に花を咲かせていました。今回のセールは「お客様大感謝祭」と銘打っただけに、袋詰めした野菜の中で最も安いものが無料になるのが目玉となっています。広告を読んでみると、どうやら以下のようなセールのようです。
1 つの袋には
m
個まで野菜を詰められる。
野菜が
m
個詰めてある袋については、その中で最も安い野菜が無料となる。
野菜の個数が
m
個に達しない袋は割引の対象外。
3人は早速セブンマートへ買い物に行きました。
買い物が終わり、  お店の外で待ち合わせた 3 人は安くてたくさん購入できたことに満足した様子で話をしていると、どうやら 3 人とも同じ野菜を購入していたことが分かりました。ある一人が、「本当に安いわよねぇ。これでXXX円だもの!」と言うと、もう一人は、「え?私はそれより**円高かったわ!どうして?」と驚き、また、残りの一人はレシートを見て自分が一番安く購入したことに気付きました。
さて、どのように袋詰めすれば購入価格を一番安くできるでしょうか。 購入する野菜の個数、袋に入る野菜の個数、各野菜の値段を入力とし、最低購入価格を出力するプログラムを作成してください。
Input
複数のデータセットの並びが入力として与えられます。入力の終わりはゼロふたつの行で示されます。
各データセットは以下の形式で与えられます。
n
m
p
1
p
2
...
p
n
1 行目に購入する野菜の個数
n
(1 ≤
n
≤ 1000) と袋に入る野菜の個数
m
(1 ≤
m
≤ 1000)　が与えられます。２行目に各野菜の値段
p
i
(10 ≤
p
i
≤ 10000) が与えられます。
データセットの数は 100 を超えません。
Output
入力データセットごとに、最低購入価格を１行に出力します。
Sample Input
4 2
50 40 100 80
7 3
400 300 100 700 200 600 500
0 0
Output for the Sample Input
150
2100",Java,"import java.util.*;

public class Main {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        
        while (true) {
            int n = sc.nextInt();
            int m = sc.nextInt();
            
            if (n == 0 && m == 0) {
                break;
            }
            
            Integer[] prices = new Integer[n];
            for (int i = 0; i < n; i++) {
                prices[i] = sc.nextInt();
            }
            
            // Sort in descending order to maximize discount
            Arrays.sort(prices, Collections.reverseOrder());
            
            int totalCost = 0;
            
            // Process full bags of m items
            for (int i = 0; i < n; i++) {
                // Every m-th item (0-indexed: m-1, 2m-1, 3m-1, ...) is free
                if ((i + 1) % m == 0) {
                    // This item is free (cheapest in its bag)
                    continue;
                }
                totalCost += prices[i];
            }
            
            System.out.println(totalCost);
        }
        
        sc.close();
    }
}
",0
p00227,"お客様大感謝祭
悪天候が続き野菜の価格が高騰する中、セブンマートではお客様に野菜のまとめ買いセールを実施しています。 日ごろなかなか店頭に並ばない野菜もお手頃価格で手に入るとあって、        店内はとても賑わっています。
ある日、松長団地に住む仲良し 3 人組がセブンマートの広告を手に話に花を咲かせていました。今回のセールは「お客様大感謝祭」と銘打っただけに、袋詰めした野菜の中で最も安いものが無料になるのが目玉となっています。広告を読んでみると、どうやら以下のようなセールのようです。
1 つの袋には
m
個まで野菜を詰められる。
野菜が
m
個詰めてある袋については、その中で最も安い野菜が無料となる。
野菜の個数が
m
個に達しない袋は割引の対象外。
3人は早速セブンマートへ買い物に行きました。
買い物が終わり、  お店の外で待ち合わせた 3 人は安くてたくさん購入できたことに満足した様子で話をしていると、どうやら 3 人とも同じ野菜を購入していたことが分かりました。ある一人が、「本当に安いわよねぇ。これでXXX円だもの!」と言うと、もう一人は、「え?私はそれより**円高かったわ!どうして?」と驚き、また、残りの一人はレシートを見て自分が一番安く購入したことに気付きました。
さて、どのように袋詰めすれば購入価格を一番安くできるでしょうか。 購入する野菜の個数、袋に入る野菜の個数、各野菜の値段を入力とし、最低購入価格を出力するプログラムを作成してください。
Input
複数のデータセットの並びが入力として与えられます。入力の終わりはゼロふたつの行で示されます。
各データセットは以下の形式で与えられます。
n
m
p
1
p
2
...
p
n
1 行目に購入する野菜の個数
n
(1 ≤
n
≤ 1000) と袋に入る野菜の個数
m
(1 ≤
m
≤ 1000)　が与えられます。２行目に各野菜の値段
p
i
(10 ≤
p
i
≤ 10000) が与えられます。
データセットの数は 100 を超えません。
Output
入力データセットごとに、最低購入価格を１行に出力します。
Sample Input
4 2
50 40 100 80
7 3
400 300 100 700 200 600 500
0 0
Output for the Sample Input
150
2100",Java,"
import java.io.IOException;
import java.util.Arrays;
import java.util.Scanner;

public class Main {

	public static void main(String[] args) throws IOException {
		new Main().run();
	}

	private void run() throws IOException {
		Scanner scanner = new Scanner(System.in);
		while (true) {
			int n = scanner.nextInt();
			int m = scanner.nextInt();
			if ((n | m) == 0)
				break;
			int[] num = new int[n];
			int sum = 0;
			for (int i = 0; i < n; i++) {
				num[i] = scanner.nextInt();
				sum += num[i];
			}
			int mod = n % m;
			Arrays.sort(num);

			for (int i = mod; i < n; i += m) {
				sum -= num[i];
			}
			System.out.println(sum);
		}
	}
}",1
p00227,"お客様大感謝祭
悪天候が続き野菜の価格が高騰する中、セブンマートではお客様に野菜のまとめ買いセールを実施しています。 日ごろなかなか店頭に並ばない野菜もお手頃価格で手に入るとあって、        店内はとても賑わっています。
ある日、松長団地に住む仲良し 3 人組がセブンマートの広告を手に話に花を咲かせていました。今回のセールは「お客様大感謝祭」と銘打っただけに、袋詰めした野菜の中で最も安いものが無料になるのが目玉となっています。広告を読んでみると、どうやら以下のようなセールのようです。
1 つの袋には
m
個まで野菜を詰められる。
野菜が
m
個詰めてある袋については、その中で最も安い野菜が無料となる。
野菜の個数が
m
個に達しない袋は割引の対象外。
3人は早速セブンマートへ買い物に行きました。
買い物が終わり、  お店の外で待ち合わせた 3 人は安くてたくさん購入できたことに満足した様子で話をしていると、どうやら 3 人とも同じ野菜を購入していたことが分かりました。ある一人が、「本当に安いわよねぇ。これでXXX円だもの!」と言うと、もう一人は、「え?私はそれより**円高かったわ!どうして?」と驚き、また、残りの一人はレシートを見て自分が一番安く購入したことに気付きました。
さて、どのように袋詰めすれば購入価格を一番安くできるでしょうか。 購入する野菜の個数、袋に入る野菜の個数、各野菜の値段を入力とし、最低購入価格を出力するプログラムを作成してください。
Input
複数のデータセットの並びが入力として与えられます。入力の終わりはゼロふたつの行で示されます。
各データセットは以下の形式で与えられます。
n
m
p
1
p
2
...
p
n
1 行目に購入する野菜の個数
n
(1 ≤
n
≤ 1000) と袋に入る野菜の個数
m
(1 ≤
m
≤ 1000)　が与えられます。２行目に各野菜の値段
p
i
(10 ≤
p
i
≤ 10000) が与えられます。
データセットの数は 100 を超えません。
Output
入力データセットごとに、最低購入価格を１行に出力します。
Sample Input
4 2
50 40 100 80
7 3
400 300 100 700 200 600 500
0 0
Output for the Sample Input
150
2100",Python,"import sys

def solve(n, m, prices):
    # Sort prices in descending order
    prices.sort(reverse=True)
    
    total = 0
    i = 0
    
    while i < n:
        # Take up to m items for this bag
        bag_size = min(m, n - i)
        
        if bag_size == m:
            # Full bag - the cheapest (last) item is free
            for j in range(bag_size - 1):
                total += prices[i + j]
            # prices[i + bag_size - 1] is free (the cheapest in this bag)
        else:
            # Incomplete bag - no discount
            for j in range(bag_size):
                total += prices[i + j]
        
        i += bag_size
    
    return total

# Read input
lines = []
for line in sys.stdin:
    lines.append(line.strip())

i = 0
while i < len(lines):
    parts = lines[i].split()
    n, m = int(parts[0]), int(parts[1])
    
    if n == 0 and m == 0:
        break
    
    i += 1
    prices = list(map(int, lines[i].split()))
    i += 1
    
    result = solve(n, m, prices)
    print(result)
",0
p00227,"お客様大感謝祭
悪天候が続き野菜の価格が高騰する中、セブンマートではお客様に野菜のまとめ買いセールを実施しています。 日ごろなかなか店頭に並ばない野菜もお手頃価格で手に入るとあって、        店内はとても賑わっています。
ある日、松長団地に住む仲良し 3 人組がセブンマートの広告を手に話に花を咲かせていました。今回のセールは「お客様大感謝祭」と銘打っただけに、袋詰めした野菜の中で最も安いものが無料になるのが目玉となっています。広告を読んでみると、どうやら以下のようなセールのようです。
1 つの袋には
m
個まで野菜を詰められる。
野菜が
m
個詰めてある袋については、その中で最も安い野菜が無料となる。
野菜の個数が
m
個に達しない袋は割引の対象外。
3人は早速セブンマートへ買い物に行きました。
買い物が終わり、  お店の外で待ち合わせた 3 人は安くてたくさん購入できたことに満足した様子で話をしていると、どうやら 3 人とも同じ野菜を購入していたことが分かりました。ある一人が、「本当に安いわよねぇ。これでXXX円だもの!」と言うと、もう一人は、「え?私はそれより**円高かったわ!どうして?」と驚き、また、残りの一人はレシートを見て自分が一番安く購入したことに気付きました。
さて、どのように袋詰めすれば購入価格を一番安くできるでしょうか。 購入する野菜の個数、袋に入る野菜の個数、各野菜の値段を入力とし、最低購入価格を出力するプログラムを作成してください。
Input
複数のデータセットの並びが入力として与えられます。入力の終わりはゼロふたつの行で示されます。
各データセットは以下の形式で与えられます。
n
m
p
1
p
2
...
p
n
1 行目に購入する野菜の個数
n
(1 ≤
n
≤ 1000) と袋に入る野菜の個数
m
(1 ≤
m
≤ 1000)　が与えられます。２行目に各野菜の値段
p
i
(10 ≤
p
i
≤ 10000) が与えられます。
データセットの数は 100 を超えません。
Output
入力データセットごとに、最低購入価格を１行に出力します。
Sample Input
4 2
50 40 100 80
7 3
400 300 100 700 200 600 500
0 0
Output for the Sample Input
150
2100",Python,"while True:
    a = raw_input()
    print 'a'",1
p00228,"7 セグメント
電卓などでよく目にするデジタル数字を表示している画面は、デジタル数字が 7 つの部分(セグメン
ト)で構成されることから、「7セグメントディスプレイ」と呼ばれています。
ワカマツ社で新しく売り出す予定の製品は、
7セグメントディスプレイを製品に組み込むことになり、社員であるあなたは、与えられた数字を 7 セグメントディスプレイに表示するプログラムを作成することになりました。
この7セグメントディスプレイは、次の切り替えの指示が送られてくるまで表示状態は変わりません。7 ビットからなるシグナルを送ることで、それぞれ対応したセグメントの表示情報を切り替える事ができます。ビットとは 1 か 0 の値を持つもので、ここでは 1 が「切り替え」、0 が「そのまま」を表します。
各ビットとセグメントの対応関係は下の図のようになっています。シグナルは 7 つのビットを""gfedcba""の順番に送ります。例えば、非表示の状態から「0」を表示するためには""0111111""をシグナルとしてディスプレイに送らなければなりません。「0」から「5」に変更する場合には""1010010""を送ります。続けて「5」を「1」に変更する場合には""1101011""を送ります。
表示したい
n
(1 ≤
n
≤ 100) 個の数字を入力とし、それらの数字
d
i
(0 ≤
d
i
≤ 9) を順に 7 セグメントディスプレイに正しく表示するために必要なシグナル列を出力するプログラムを作成してください。なお、7 セグメントディスプレイの初期状態は全て非表示の状態であるものとします。
Input
複数のデータセットの並びが入力として与えられます。入力の終わりは-1 ひとつの行で示されます。
各データセットは以下の形式で与えられます。
n
d
1
d
2
:
d
n
データセットの数は 120 を超えません。
Output
入力データセットごとに、数字をディスプレイに正しく出力するために必要なシグナルの列を出力してください。
Sample Input
3
0
5
1
1
0
-1
Output for the Sample Input
0111111
1010010
1101011
0111111",C,"#include <stdio.h>

int main() {
    int segments[10] = {
        0b0111111,  // 0
        0b0000110,  // 1
        0b1011011,  // 2
        0b1001111,  // 3
        0b1100110,  // 4
        0b1101101,  // 5
        0b1111101,  // 6
        0b0000111,  // 7
        0b1111111,  // 8
        0b1101111   // 9
    };
    
    int n;
    while (scanf(""%d"", &n) == 1 && n != -1) {
        int current = 0;  // Initial state: all segments off
        
        for (int i = 0; i < n; i++) {
            int digit;
            scanf(""%d"", &digit);
            
            int target = segments[digit];
            int signal = current ^ target;  // XOR to get the toggle bits
            
            // Print signal in binary (7 bits, from bit 6 to bit 0)
            for (int j = 6; j >= 0; j--) {
                printf(""%d"", (signal >> j) & 1);
            }
            printf(""\n"");
            
            current = target;  // Update current state
        }
    }
    
    return 0;
}
",0
p00228,"7 セグメント
電卓などでよく目にするデジタル数字を表示している画面は、デジタル数字が 7 つの部分(セグメン
ト)で構成されることから、「7セグメントディスプレイ」と呼ばれています。
ワカマツ社で新しく売り出す予定の製品は、
7セグメントディスプレイを製品に組み込むことになり、社員であるあなたは、与えられた数字を 7 セグメントディスプレイに表示するプログラムを作成することになりました。
この7セグメントディスプレイは、次の切り替えの指示が送られてくるまで表示状態は変わりません。7 ビットからなるシグナルを送ることで、それぞれ対応したセグメントの表示情報を切り替える事ができます。ビットとは 1 か 0 の値を持つもので、ここでは 1 が「切り替え」、0 が「そのまま」を表します。
各ビットとセグメントの対応関係は下の図のようになっています。シグナルは 7 つのビットを""gfedcba""の順番に送ります。例えば、非表示の状態から「0」を表示するためには""0111111""をシグナルとしてディスプレイに送らなければなりません。「0」から「5」に変更する場合には""1010010""を送ります。続けて「5」を「1」に変更する場合には""1101011""を送ります。
表示したい
n
(1 ≤
n
≤ 100) 個の数字を入力とし、それらの数字
d
i
(0 ≤
d
i
≤ 9) を順に 7 セグメントディスプレイに正しく表示するために必要なシグナル列を出力するプログラムを作成してください。なお、7 セグメントディスプレイの初期状態は全て非表示の状態であるものとします。
Input
複数のデータセットの並びが入力として与えられます。入力の終わりは-1 ひとつの行で示されます。
各データセットは以下の形式で与えられます。
n
d
1
d
2
:
d
n
データセットの数は 120 を超えません。
Output
入力データセットごとに、数字をディスプレイに正しく出力するために必要なシグナルの列を出力してください。
Sample Input
3
0
5
1
1
0
-1
Output for the Sample Input
0111111
1010010
1101011
0111111",C,"#include<stdio.h>

int main(){
  int i,j,n,num,prev;
  char segment[]=""0000000"";
  char nums[][8]={""0111111"",""0000110"",""1011011"",""1001111"",
		  ""1100110"",""1101101"",""1111101"",""0100111"",
		  ""1111111"",""1101111"",""0000000""};
  do{
    scanf(""%d"",&n);
    if(n==-1) break;
    for(prev=10,i=0;i<n;i++,prev=num){
      scanf(""%d"",&num);
      for(j=0;j<7;j++){
	if(nums[prev][j]==nums[num][j]){
	  segment[j]='0';
	}else{
	  segment[j]='1';
	}
      }
      printf(""%s\n"",segment);
    }
  }while(1);
  return 0;
}",1
p00228,"7 セグメント
電卓などでよく目にするデジタル数字を表示している画面は、デジタル数字が 7 つの部分(セグメン
ト)で構成されることから、「7セグメントディスプレイ」と呼ばれています。
ワカマツ社で新しく売り出す予定の製品は、
7セグメントディスプレイを製品に組み込むことになり、社員であるあなたは、与えられた数字を 7 セグメントディスプレイに表示するプログラムを作成することになりました。
この7セグメントディスプレイは、次の切り替えの指示が送られてくるまで表示状態は変わりません。7 ビットからなるシグナルを送ることで、それぞれ対応したセグメントの表示情報を切り替える事ができます。ビットとは 1 か 0 の値を持つもので、ここでは 1 が「切り替え」、0 が「そのまま」を表します。
各ビットとセグメントの対応関係は下の図のようになっています。シグナルは 7 つのビットを""gfedcba""の順番に送ります。例えば、非表示の状態から「0」を表示するためには""0111111""をシグナルとしてディスプレイに送らなければなりません。「0」から「5」に変更する場合には""1010010""を送ります。続けて「5」を「1」に変更する場合には""1101011""を送ります。
表示したい
n
(1 ≤
n
≤ 100) 個の数字を入力とし、それらの数字
d
i
(0 ≤
d
i
≤ 9) を順に 7 セグメントディスプレイに正しく表示するために必要なシグナル列を出力するプログラムを作成してください。なお、7 セグメントディスプレイの初期状態は全て非表示の状態であるものとします。
Input
複数のデータセットの並びが入力として与えられます。入力の終わりは-1 ひとつの行で示されます。
各データセットは以下の形式で与えられます。
n
d
1
d
2
:
d
n
データセットの数は 120 を超えません。
Output
入力データセットごとに、数字をディスプレイに正しく出力するために必要なシグナルの列を出力してください。
Sample Input
3
0
5
1
1
0
-1
Output for the Sample Input
0111111
1010010
1101011
0111111",Java,"import java.util.Scanner;

public class Main {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        
        // Define 7-segment patterns for digits 0-9
        // Pattern is in order: abcdefg (bits 0-6)
        int[] patterns = {
            0b0111111, // 0
            0b0000110, // 1
            0b1011011, // 2
            0b1001111, // 3
            0b1100110, // 4
            0b1101101, // 5
            0b1111101, // 6
            0b0000111, // 7
            0b1111111, // 8
            0b1101111  // 9
        };
        
        while (true) {
            int n = sc.nextInt();
            if (n == -1) break;
            
            int currentState = 0; // Initially all segments are off
            
            for (int i = 0; i < n; i++) {
                int digit = sc.nextInt();
                int targetState = patterns[digit];
                
                // Calculate XOR to get the signal needed
                int signal = currentState ^ targetState;
                
                // Output the signal in reverse bit order (gfedcba)
                StringBuilder sb = new StringBuilder();
                for (int bit = 6; bit >= 0; bit--) {
                    sb.append((signal >> bit) & 1);
                }
                System.out.println(sb.toString());
                
                // Update current state
                currentState = targetState;
            }
        }
        
        sc.close();
    }
}
",0
p00228,"7 セグメント
電卓などでよく目にするデジタル数字を表示している画面は、デジタル数字が 7 つの部分(セグメン
ト)で構成されることから、「7セグメントディスプレイ」と呼ばれています。
ワカマツ社で新しく売り出す予定の製品は、
7セグメントディスプレイを製品に組み込むことになり、社員であるあなたは、与えられた数字を 7 セグメントディスプレイに表示するプログラムを作成することになりました。
この7セグメントディスプレイは、次の切り替えの指示が送られてくるまで表示状態は変わりません。7 ビットからなるシグナルを送ることで、それぞれ対応したセグメントの表示情報を切り替える事ができます。ビットとは 1 か 0 の値を持つもので、ここでは 1 が「切り替え」、0 が「そのまま」を表します。
各ビットとセグメントの対応関係は下の図のようになっています。シグナルは 7 つのビットを""gfedcba""の順番に送ります。例えば、非表示の状態から「0」を表示するためには""0111111""をシグナルとしてディスプレイに送らなければなりません。「0」から「5」に変更する場合には""1010010""を送ります。続けて「5」を「1」に変更する場合には""1101011""を送ります。
表示したい
n
(1 ≤
n
≤ 100) 個の数字を入力とし、それらの数字
d
i
(0 ≤
d
i
≤ 9) を順に 7 セグメントディスプレイに正しく表示するために必要なシグナル列を出力するプログラムを作成してください。なお、7 セグメントディスプレイの初期状態は全て非表示の状態であるものとします。
Input
複数のデータセットの並びが入力として与えられます。入力の終わりは-1 ひとつの行で示されます。
各データセットは以下の形式で与えられます。
n
d
1
d
2
:
d
n
データセットの数は 120 を超えません。
Output
入力データセットごとに、数字をディスプレイに正しく出力するために必要なシグナルの列を出力してください。
Sample Input
3
0
5
1
1
0
-1
Output for the Sample Input
0111111
1010010
1101011
0111111",Java,"import java.util.*;

public class Main {
	Scanner sc = new Scanner(System.in);
	String [] digit = {""0111111"",""0000110"",""1011011"",""1001111"",""1100110"",
			""1101101"",""1111101"", ""0100111"",""1111111"",""1101111""};
	
	private void doit() {
		while (true) {
			int n = sc.nextInt();
			if(n == -1) break;
			StringBuilder nowstate = new StringBuilder(""0000000"");
			while(n-- > 0){
				int num = sc.nextInt();
				String numstr = digit[num];
				StringBuilder sb = new StringBuilder();
				for(int i = 0; i < numstr.length(); i++){
					if(numstr.charAt(i) == nowstate.charAt(i)){
						sb.append(0);
					}
					else{
						sb.append(1);
					}
				}
				System.out.println(sb.toString());
				nowstate = new StringBuilder(numstr);
			}
		}
	}


	private void debug(Object... o) {
		System.out.println(""debug = "" + Arrays.deepToString(o));
	}

	public static void main(String[] args) {
		new Main().doit();
	}
}",1
p00228,"7 セグメント
電卓などでよく目にするデジタル数字を表示している画面は、デジタル数字が 7 つの部分(セグメン
ト)で構成されることから、「7セグメントディスプレイ」と呼ばれています。
ワカマツ社で新しく売り出す予定の製品は、
7セグメントディスプレイを製品に組み込むことになり、社員であるあなたは、与えられた数字を 7 セグメントディスプレイに表示するプログラムを作成することになりました。
この7セグメントディスプレイは、次の切り替えの指示が送られてくるまで表示状態は変わりません。7 ビットからなるシグナルを送ることで、それぞれ対応したセグメントの表示情報を切り替える事ができます。ビットとは 1 か 0 の値を持つもので、ここでは 1 が「切り替え」、0 が「そのまま」を表します。
各ビットとセグメントの対応関係は下の図のようになっています。シグナルは 7 つのビットを""gfedcba""の順番に送ります。例えば、非表示の状態から「0」を表示するためには""0111111""をシグナルとしてディスプレイに送らなければなりません。「0」から「5」に変更する場合には""1010010""を送ります。続けて「5」を「1」に変更する場合には""1101011""を送ります。
表示したい
n
(1 ≤
n
≤ 100) 個の数字を入力とし、それらの数字
d
i
(0 ≤
d
i
≤ 9) を順に 7 セグメントディスプレイに正しく表示するために必要なシグナル列を出力するプログラムを作成してください。なお、7 セグメントディスプレイの初期状態は全て非表示の状態であるものとします。
Input
複数のデータセットの並びが入力として与えられます。入力の終わりは-1 ひとつの行で示されます。
各データセットは以下の形式で与えられます。
n
d
1
d
2
:
d
n
データセットの数は 120 を超えません。
Output
入力データセットごとに、数字をディスプレイに正しく出力するために必要なシグナルの列を出力してください。
Sample Input
3
0
5
1
1
0
-1
Output for the Sample Input
0111111
1010010
1101011
0111111",Python,"def get_segments(digit):
    segments = {
        0: ""0111111"",
        1: ""0000110"",
        2: ""1011011"",
        3: ""1001111"",
        4: ""1100110"",
        5: ""1101101"",
        6: ""1111101"",
        7: ""0000111"",
        8: ""1111111"",
        9: ""1101111""
    }
    return segments[digit]

def xor_bits(a, b):
    result = """"
    for i in range(7):
        if a[i] != b[i]:
            result += ""1""
        else:
            result += ""0""
    return result

while True:
    n = int(input())
    if n == -1:
        break
    
    current_state = ""0000000""
    
    for _ in range(n):
        digit = int(input())
        target_state = get_segments(digit)
        signal = xor_bits(current_state, target_state)
        print(signal)
        current_state = target_state
",0
p00228,"7 セグメント
電卓などでよく目にするデジタル数字を表示している画面は、デジタル数字が 7 つの部分(セグメン
ト)で構成されることから、「7セグメントディスプレイ」と呼ばれています。
ワカマツ社で新しく売り出す予定の製品は、
7セグメントディスプレイを製品に組み込むことになり、社員であるあなたは、与えられた数字を 7 セグメントディスプレイに表示するプログラムを作成することになりました。
この7セグメントディスプレイは、次の切り替えの指示が送られてくるまで表示状態は変わりません。7 ビットからなるシグナルを送ることで、それぞれ対応したセグメントの表示情報を切り替える事ができます。ビットとは 1 か 0 の値を持つもので、ここでは 1 が「切り替え」、0 が「そのまま」を表します。
各ビットとセグメントの対応関係は下の図のようになっています。シグナルは 7 つのビットを""gfedcba""の順番に送ります。例えば、非表示の状態から「0」を表示するためには""0111111""をシグナルとしてディスプレイに送らなければなりません。「0」から「5」に変更する場合には""1010010""を送ります。続けて「5」を「1」に変更する場合には""1101011""を送ります。
表示したい
n
(1 ≤
n
≤ 100) 個の数字を入力とし、それらの数字
d
i
(0 ≤
d
i
≤ 9) を順に 7 セグメントディスプレイに正しく表示するために必要なシグナル列を出力するプログラムを作成してください。なお、7 セグメントディスプレイの初期状態は全て非表示の状態であるものとします。
Input
複数のデータセットの並びが入力として与えられます。入力の終わりは-1 ひとつの行で示されます。
各データセットは以下の形式で与えられます。
n
d
1
d
2
:
d
n
データセットの数は 120 を超えません。
Output
入力データセットごとに、数字をディスプレイに正しく出力するために必要なシグナルの列を出力してください。
Sample Input
3
0
5
1
1
0
-1
Output for the Sample Input
0111111
1010010
1101011
0111111",Python,"# AOJ 0228: Seven Segments
# Python3 2018.6.25 bal4u
 
p = [[1,1,1,1,1,1,0], [0,1,1,0,0,0,0], [1,1,0,1,1,0,1], [1,1,1,1,0,0,1], [0,1,1,0,0,1,1], \
     [1,0,1,1,0,1,1], [1,0,1,1,1,1,1], [1,1,1,0,0,1,0], [1,1,1,1,1,1,1], [1,1,1,1,0,1,1]]
 
while True:
    n = int(input())
    if n < 0: break
    a = [0]*7
    for i in range(n):
        d = int(input())
        ans = ''
        for j in range(6,-1,-1):
            k = (a[j] ^ p[d][j]) & 1
            ans += '1' if k else '0'
            if k: a[j] = 1-a[j]
        print(ans)
",1
p00229,"大当たり!
あいづ学園大学附属高校の大阿足あたる君は、スロットマシーンで遊ぶことにしました。
このマシーンは、メダルを投入すると、3 つのリールが回転を始め、各リールが自動的に止まります。通常の1ゲーム(通常ゲーム)は 3 枚のメダルを投入し、図柄が揃うと、その図柄に応じて次のとおりメダルが得られます。
図柄の揃い方によっては特別なサービスが開始されます。 7 の図柄が 3 つ揃うとビッグボーナスが始まり、ボーナスゲームを 5 ゲーム行うことができます。また、BAR の図柄が 3 つ揃うとレギュラーボーナスが始まり、ボーナスゲームを 3 ゲーム行うことができます。
スターの図柄が 3 つ揃うと無料ゲームが開始され、メダルを得ることはできませんが、次のゲームをメダルの投入なく始めることができます。
ボーナスゲーム中は 1 ゲームあたり 2 枚のメダルを投入すると、自動でブドウの図柄が 3 つ揃い、メダルを 15 枚得ることができます。
大阿足君は 100 枚のメダルを持ってマシーンで遊び始めました。しばらく遊び、通常ゲームになった状態で終了しました。手元に残ったメダルは何枚となったでしょうか。
プレイ情報を入力とし、手元に残ったメダルの数を出力するプログラムを作成して下さい。 プレイ情報として、ビッグボーナスの回数
b
、レギュラーボーナスの回数
r
、通常ゲーム中にブドウが揃った回数
g
、チェリーが揃った回数
c
、スターが揃った回数
s
、総ゲーム数
t
が与えられます。
なお、
t
にはボーナスゲームの回数を含みます。また、メダルはゲームの途中になくなることはありません。
Input
複数のデータセットの並びが入力として与えられます。入力の終わりはゼロむっつの行で示されます。
各データセットは以下の形式で与えられます。
b
r
g
c
s
t
b, r, g, c, s
はそれぞれ 0 以上 200 以下の整数、
t
は 1000 以下の整数です。
データセットの数は 120 を超えません。
Output
入力データセットごとに、手元に残ったメダルの枚数を１行に出力します。
Sample Input
3 2 30 3 26 226
9 0 18 3 20 118
5 5 12 2 15 203
7 4 19 2 22 197
7 4 24 4 17 209
0 0 0 0 0 0
Output for the Sample Input
127
793
414
629
617",C,"#include <stdio.h>

int main() {
    int b, r, g, c, s, t;
    
    while (1) {
        scanf(""%d %d %d %d %d %d"", &b, &r, &g, &c, &s, &t);
        
        if (b == 0 && r == 0 && g == 0 && c == 0 && s == 0 && t == 0) {
            break;
        }
        
        int medals = 100;
        
        // Big bonus games: 5 games each, 2 medals in, 15 medals out per game
        int big_bonus_games = b * 5;
        medals += big_bonus_games * (15 - 2);
        
        // Regular bonus games: 3 games each, 2 medals in, 15 medals out per game
        int regular_bonus_games = r * 3;
        medals += regular_bonus_games * (15 - 2);
        
        // Total bonus games
        int bonus_games = big_bonus_games + regular_bonus_games;
        
        // Normal games
        int normal_games = t - bonus_games;
        
        // For normal games, we need to account for:
        // - Games that triggered bonuses (b + r games, cost 3 medals each, no payout from trigger itself)
        // - Games with grapes (g games, cost 3 medals, get 15 medals)
        // - Games with cherries (c games, cost 3 medals, get 3 medals)
        // - Games with stars (s games, cost 3 medals first time, get 0 medals but next game is free)
        // - Games that got nothing
        
        // Star games: first star costs 3, gets 0, then next game is free (costs 0)
        // So s stars means s games cost 3 medals and s games cost 0 medals
        // But we need to be careful about counting
        
        // Actually, let's think differently:
        // - b games triggered big bonus: cost 3, no payout
        // - r games triggered regular bonus: cost 3, no payout
        // - g games got grapes: cost 3, payout 15
        // - c games got cherries: cost 3, payout 3
        // - s games got stars: cost 3, payout 0, but next game is free
        // - remaining games got nothing: cost 3, payout 0
        
        // Total normal games played
        // Some of these are free (after stars)
        // Games that cost medals: normal_games - s (since s games following a star are free)
        
        medals -= (normal_games - s) * 3;  // Cost of normal games (excluding free games after stars)
        medals += b * 0;  // Big bonus triggers give no payout
        medals += r * 0;  // Regular bonus triggers give no payout
        medals += g * 15; // Grape payouts in normal games
        medals += c * 3;  // Cherry payouts in normal games
        medals += s * 0;  // Star payouts (none)
        
        printf(""%d\n"", medals);
    }
    
    return 0;
}
",0
p00229,"大当たり!
あいづ学園大学附属高校の大阿足あたる君は、スロットマシーンで遊ぶことにしました。
このマシーンは、メダルを投入すると、3 つのリールが回転を始め、各リールが自動的に止まります。通常の1ゲーム(通常ゲーム)は 3 枚のメダルを投入し、図柄が揃うと、その図柄に応じて次のとおりメダルが得られます。
図柄の揃い方によっては特別なサービスが開始されます。 7 の図柄が 3 つ揃うとビッグボーナスが始まり、ボーナスゲームを 5 ゲーム行うことができます。また、BAR の図柄が 3 つ揃うとレギュラーボーナスが始まり、ボーナスゲームを 3 ゲーム行うことができます。
スターの図柄が 3 つ揃うと無料ゲームが開始され、メダルを得ることはできませんが、次のゲームをメダルの投入なく始めることができます。
ボーナスゲーム中は 1 ゲームあたり 2 枚のメダルを投入すると、自動でブドウの図柄が 3 つ揃い、メダルを 15 枚得ることができます。
大阿足君は 100 枚のメダルを持ってマシーンで遊び始めました。しばらく遊び、通常ゲームになった状態で終了しました。手元に残ったメダルは何枚となったでしょうか。
プレイ情報を入力とし、手元に残ったメダルの数を出力するプログラムを作成して下さい。 プレイ情報として、ビッグボーナスの回数
b
、レギュラーボーナスの回数
r
、通常ゲーム中にブドウが揃った回数
g
、チェリーが揃った回数
c
、スターが揃った回数
s
、総ゲーム数
t
が与えられます。
なお、
t
にはボーナスゲームの回数を含みます。また、メダルはゲームの途中になくなることはありません。
Input
複数のデータセットの並びが入力として与えられます。入力の終わりはゼロむっつの行で示されます。
各データセットは以下の形式で与えられます。
b
r
g
c
s
t
b, r, g, c, s
はそれぞれ 0 以上 200 以下の整数、
t
は 1000 以下の整数です。
データセットの数は 120 を超えません。
Output
入力データセットごとに、手元に残ったメダルの枚数を１行に出力します。
Sample Input
3 2 30 3 26 226
9 0 18 3 20 118
5 5 12 2 15 203
7 4 19 2 22 197
7 4 24 4 17 209
0 0 0 0 0 0
Output for the Sample Input
127
793
414
629
617",C,"main(b,r,g,c,s,t){for(;~scanf(""%d%d%d%d%d%d"",&b,&r,&g,&c,&s,&t)&&t;printf(""%d\n"",b*95+r*63+g*7+c*2+s*3-t*3+100));}",1
p00229,"大当たり!
あいづ学園大学附属高校の大阿足あたる君は、スロットマシーンで遊ぶことにしました。
このマシーンは、メダルを投入すると、3 つのリールが回転を始め、各リールが自動的に止まります。通常の1ゲーム(通常ゲーム)は 3 枚のメダルを投入し、図柄が揃うと、その図柄に応じて次のとおりメダルが得られます。
図柄の揃い方によっては特別なサービスが開始されます。 7 の図柄が 3 つ揃うとビッグボーナスが始まり、ボーナスゲームを 5 ゲーム行うことができます。また、BAR の図柄が 3 つ揃うとレギュラーボーナスが始まり、ボーナスゲームを 3 ゲーム行うことができます。
スターの図柄が 3 つ揃うと無料ゲームが開始され、メダルを得ることはできませんが、次のゲームをメダルの投入なく始めることができます。
ボーナスゲーム中は 1 ゲームあたり 2 枚のメダルを投入すると、自動でブドウの図柄が 3 つ揃い、メダルを 15 枚得ることができます。
大阿足君は 100 枚のメダルを持ってマシーンで遊び始めました。しばらく遊び、通常ゲームになった状態で終了しました。手元に残ったメダルは何枚となったでしょうか。
プレイ情報を入力とし、手元に残ったメダルの数を出力するプログラムを作成して下さい。 プレイ情報として、ビッグボーナスの回数
b
、レギュラーボーナスの回数
r
、通常ゲーム中にブドウが揃った回数
g
、チェリーが揃った回数
c
、スターが揃った回数
s
、総ゲーム数
t
が与えられます。
なお、
t
にはボーナスゲームの回数を含みます。また、メダルはゲームの途中になくなることはありません。
Input
複数のデータセットの並びが入力として与えられます。入力の終わりはゼロむっつの行で示されます。
各データセットは以下の形式で与えられます。
b
r
g
c
s
t
b, r, g, c, s
はそれぞれ 0 以上 200 以下の整数、
t
は 1000 以下の整数です。
データセットの数は 120 を超えません。
Output
入力データセットごとに、手元に残ったメダルの枚数を１行に出力します。
Sample Input
3 2 30 3 26 226
9 0 18 3 20 118
5 5 12 2 15 203
7 4 19 2 22 197
7 4 24 4 17 209
0 0 0 0 0 0
Output for the Sample Input
127
793
414
629
617",Java,"import java.util.Scanner;

public class Main {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        
        while (true) {
            int b = sc.nextInt();
            int r = sc.nextInt();
            int g = sc.nextInt();
            int c = sc.nextInt();
            int s = sc.nextInt();
            int t = sc.nextInt();
            
            if (b == 0 && r == 0 && g == 0 && c == 0 && s == 0 && t == 0) {
                break;
            }
            
            int medals = 100;
            
            // Big bonus games: 5 games each, spend 2 medals, get 15 medals
            int bigBonusGames = b * 5;
            medals += bigBonusGames * (15 - 2);
            
            // Regular bonus games: 3 games each, spend 2 medals, get 15 medals
            int regularBonusGames = r * 3;
            medals += regularBonusGames * (15 - 2);
            
            // Total bonus games
            int totalBonusGames = bigBonusGames + regularBonusGames;
            
            // Normal games
            int normalGames = t - totalBonusGames;
            
            // Calculate medals from normal games
            // Grape in normal game: spend 3, get 15, net +12
            medals += g * (15 - 3);
            
            // Cherry in normal game: spend 3, get 8, net +5
            medals += c * (8 - 3);
            
            // Star in normal game: spend 3, get 0, but next game is free
            // Net effect: -3 for star game, +3 for free game = 0
            // But we need to count that star games are part of normal games
            
            // Games that cost 3 medals (normal games minus free games from stars)
            int paidNormalGames = normalGames - s;
            
            // Games where nothing special happened
            int noWinGames = paidNormalGames - g - c - s;
            
            // These games cost 3 medals with no return
            medals -= noWinGames * 3;
            
            System.out.println(medals);
        }
        
        sc.close();
    }
}
",0
p00229,"大当たり!
あいづ学園大学附属高校の大阿足あたる君は、スロットマシーンで遊ぶことにしました。
このマシーンは、メダルを投入すると、3 つのリールが回転を始め、各リールが自動的に止まります。通常の1ゲーム(通常ゲーム)は 3 枚のメダルを投入し、図柄が揃うと、その図柄に応じて次のとおりメダルが得られます。
図柄の揃い方によっては特別なサービスが開始されます。 7 の図柄が 3 つ揃うとビッグボーナスが始まり、ボーナスゲームを 5 ゲーム行うことができます。また、BAR の図柄が 3 つ揃うとレギュラーボーナスが始まり、ボーナスゲームを 3 ゲーム行うことができます。
スターの図柄が 3 つ揃うと無料ゲームが開始され、メダルを得ることはできませんが、次のゲームをメダルの投入なく始めることができます。
ボーナスゲーム中は 1 ゲームあたり 2 枚のメダルを投入すると、自動でブドウの図柄が 3 つ揃い、メダルを 15 枚得ることができます。
大阿足君は 100 枚のメダルを持ってマシーンで遊び始めました。しばらく遊び、通常ゲームになった状態で終了しました。手元に残ったメダルは何枚となったでしょうか。
プレイ情報を入力とし、手元に残ったメダルの数を出力するプログラムを作成して下さい。 プレイ情報として、ビッグボーナスの回数
b
、レギュラーボーナスの回数
r
、通常ゲーム中にブドウが揃った回数
g
、チェリーが揃った回数
c
、スターが揃った回数
s
、総ゲーム数
t
が与えられます。
なお、
t
にはボーナスゲームの回数を含みます。また、メダルはゲームの途中になくなることはありません。
Input
複数のデータセットの並びが入力として与えられます。入力の終わりはゼロむっつの行で示されます。
各データセットは以下の形式で与えられます。
b
r
g
c
s
t
b, r, g, c, s
はそれぞれ 0 以上 200 以下の整数、
t
は 1000 以下の整数です。
データセットの数は 120 を超えません。
Output
入力データセットごとに、手元に残ったメダルの枚数を１行に出力します。
Sample Input
3 2 30 3 26 226
9 0 18 3 20 118
5 5 12 2 15 203
7 4 19 2 22 197
7 4 24 4 17 209
0 0 0 0 0 0
Output for the Sample Input
127
793
414
629
617",Java,"import java.util.Scanner;

public class Main {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        for(;;) {
         int b=sc.nextInt()*5,r=sc.nextInt()*3,g=sc.nextInt(),c=sc.nextInt(),s=sc.nextInt(),t=sc.nextInt();
         if((b|r|g|c|s|t)==0) {
             break;
         }
         System.out.println(100+b+b*18+r+r*20+g*7+c*2-(t-s)*3);
        }
    }
}
",1
p00229,"大当たり!
あいづ学園大学附属高校の大阿足あたる君は、スロットマシーンで遊ぶことにしました。
このマシーンは、メダルを投入すると、3 つのリールが回転を始め、各リールが自動的に止まります。通常の1ゲーム(通常ゲーム)は 3 枚のメダルを投入し、図柄が揃うと、その図柄に応じて次のとおりメダルが得られます。
図柄の揃い方によっては特別なサービスが開始されます。 7 の図柄が 3 つ揃うとビッグボーナスが始まり、ボーナスゲームを 5 ゲーム行うことができます。また、BAR の図柄が 3 つ揃うとレギュラーボーナスが始まり、ボーナスゲームを 3 ゲーム行うことができます。
スターの図柄が 3 つ揃うと無料ゲームが開始され、メダルを得ることはできませんが、次のゲームをメダルの投入なく始めることができます。
ボーナスゲーム中は 1 ゲームあたり 2 枚のメダルを投入すると、自動でブドウの図柄が 3 つ揃い、メダルを 15 枚得ることができます。
大阿足君は 100 枚のメダルを持ってマシーンで遊び始めました。しばらく遊び、通常ゲームになった状態で終了しました。手元に残ったメダルは何枚となったでしょうか。
プレイ情報を入力とし、手元に残ったメダルの数を出力するプログラムを作成して下さい。 プレイ情報として、ビッグボーナスの回数
b
、レギュラーボーナスの回数
r
、通常ゲーム中にブドウが揃った回数
g
、チェリーが揃った回数
c
、スターが揃った回数
s
、総ゲーム数
t
が与えられます。
なお、
t
にはボーナスゲームの回数を含みます。また、メダルはゲームの途中になくなることはありません。
Input
複数のデータセットの並びが入力として与えられます。入力の終わりはゼロむっつの行で示されます。
各データセットは以下の形式で与えられます。
b
r
g
c
s
t
b, r, g, c, s
はそれぞれ 0 以上 200 以下の整数、
t
は 1000 以下の整数です。
データセットの数は 120 を超えません。
Output
入力データセットごとに、手元に残ったメダルの枚数を１行に出力します。
Sample Input
3 2 30 3 26 226
9 0 18 3 20 118
5 5 12 2 15 203
7 4 19 2 22 197
7 4 24 4 17 209
0 0 0 0 0 0
Output for the Sample Input
127
793
414
629
617",Python,"while True:
    line = input().split()
    b, r, g, c, s, t = map(int, line)
    
    if b == 0 and r == 0 and g == 0 and c == 0 and s == 0 and t == 0:
        break
    
    medals = 100
    
    # Big bonus games: 5 games each
    big_bonus_games = b * 5
    # Regular bonus games: 3 games each
    regular_bonus_games = r * 3
    # Total bonus games
    bonus_games = big_bonus_games + regular_bonus_games
    # Normal games
    normal_games = t - bonus_games
    
    # Bonus games: spend 2, get 15 (net +13 per game)
    medals += bonus_games * (15 - 2)
    
    # Normal games cost 3 medals each
    medals -= normal_games * 3
    
    # Grape in normal games: get 15
    medals += g * 15
    
    # Cherry in normal games: get 8
    medals += c * 8
    
    # Star games are free (refund 3 medals)
    medals += s * 3
    
    print(medals)
",0
p00229,"大当たり!
あいづ学園大学附属高校の大阿足あたる君は、スロットマシーンで遊ぶことにしました。
このマシーンは、メダルを投入すると、3 つのリールが回転を始め、各リールが自動的に止まります。通常の1ゲーム(通常ゲーム)は 3 枚のメダルを投入し、図柄が揃うと、その図柄に応じて次のとおりメダルが得られます。
図柄の揃い方によっては特別なサービスが開始されます。 7 の図柄が 3 つ揃うとビッグボーナスが始まり、ボーナスゲームを 5 ゲーム行うことができます。また、BAR の図柄が 3 つ揃うとレギュラーボーナスが始まり、ボーナスゲームを 3 ゲーム行うことができます。
スターの図柄が 3 つ揃うと無料ゲームが開始され、メダルを得ることはできませんが、次のゲームをメダルの投入なく始めることができます。
ボーナスゲーム中は 1 ゲームあたり 2 枚のメダルを投入すると、自動でブドウの図柄が 3 つ揃い、メダルを 15 枚得ることができます。
大阿足君は 100 枚のメダルを持ってマシーンで遊び始めました。しばらく遊び、通常ゲームになった状態で終了しました。手元に残ったメダルは何枚となったでしょうか。
プレイ情報を入力とし、手元に残ったメダルの数を出力するプログラムを作成して下さい。 プレイ情報として、ビッグボーナスの回数
b
、レギュラーボーナスの回数
r
、通常ゲーム中にブドウが揃った回数
g
、チェリーが揃った回数
c
、スターが揃った回数
s
、総ゲーム数
t
が与えられます。
なお、
t
にはボーナスゲームの回数を含みます。また、メダルはゲームの途中になくなることはありません。
Input
複数のデータセットの並びが入力として与えられます。入力の終わりはゼロむっつの行で示されます。
各データセットは以下の形式で与えられます。
b
r
g
c
s
t
b, r, g, c, s
はそれぞれ 0 以上 200 以下の整数、
t
は 1000 以下の整数です。
データセットの数は 120 を超えません。
Output
入力データセットごとに、手元に残ったメダルの枚数を１行に出力します。
Sample Input
3 2 30 3 26 226
9 0 18 3 20 118
5 5 12 2 15 203
7 4 19 2 22 197
7 4 24 4 17 209
0 0 0 0 0 0
Output for the Sample Input
127
793
414
629
617",Python,"while 1:
    b,r,g,c,s,t=map(int,input().split())
    if [b,r,g,c,s,t].count(0)==6:break
    print(100+(b+r)*15+g*7+c*2+(b*5+r*3)*13-(t-(s+b*5+r*3))*3)",1
p00230,"忍者のビル登り
忍者のあつしさんは、毎日朝早くから夜遅くまで忍者ビルの屋上から町を警備しています。この忍者ビルは、隣接する 2 つの同じ階数のビルであり、あつしさんは警備のために、ビルとビルの間をジャンプしながら屋上へ向かうことを日課としています。
この 2 つのビルは頻繁に清掃が行われるため、ビル登りの助けとなるはしごや障害となる滑りやすい部分があります。  しかも、はしごや滑りやすい部分の位置は毎日変わります。   そのためあつしさんは、屋上へ向かう方法を毎日考えなければいけません。
あつしさんは二つ並んだ同じ階数のビルの壁を跳び移りながら、ビルの屋上を目指します。ジャンプ
はどちらか一方のビルの1階から始められます。向かい側のビルへジャンプするときには、同じ階・1つ上の階・2 つ上の階の、いずれかに飛び移ることができます。
壁には以下の 3 種類があり、それぞれの壁にジャンプした後の移動が決まっています。
0. 普通の壁: 上下の移動はしない。次のジャンプはそこから行う。
1. はしご: はしごは 2 つ以上の階にまたがってかかっており、今いるはしごの一番上まで移動する。次のジャンプはそこから行う。
2. すべる壁: 普通の壁かはしごの一番上まで滑り落ちる。次のジャンプはそこから行う。
また、壁は 1 階から屋上のすぐ下の最上階まであり、屋上へはそのビルの最上階からのみ行くことが
できます。また、ビルの最下階の壁はすべる壁にはなりません。
2 つのビルの階数
n
と 2 つのビルの壁の種類を入力とし、最少で何回目のジャンプで最上階までたどり着き、屋上まで行くことができるかを出力するプログラムを作成してください。なお、どちらのビルの屋上にたどり着いてもよいものとします。ただし、あつしさんがどちらのビルの屋上へもたどり着けない場合は“NA”と出力してください。
Input
複数のデータセットの並びが入力として与えられます。入力の終わりはゼロひとつの行で示されます。
各データセットは以下の形式で与えられます。
n
a
1
a
2
...
a
n
b
1
b
2
...
b
n
１行目にビルの階数
n
(3 ≤
n
≤ 100) が与えられます。２行目に１ つ目のビルの 1 階から
n
階までの壁の情報
a
i
、３行目に２つ目のビルの 1 階から
n
階までの壁の情報
b
i
が与えられます。
a
i
, b
i
は
i
階目の壁の情報を表し、0 が普通の壁、1 がはしご(
i
階と
i
+1 階にまたがる)、2 がすべる壁を表します。
データセットの数は 60 を超えません。
Output
入力データセットごとに、ジャンプの回数を１行に出力します。
Sample Input
8
0 0 0 2 2 2 0 0
1 1 1 1 0 0 0 0
4
1 1 2 2
0 0 2 2
0
Output for the Sample Input
4
NA",C,"#include <stdio.h>
#include <string.h>
#include <stdbool.h>

#define MAX_N 101
#define INF 999999

int n;
int a[MAX_N], b[MAX_N];
int ladder_top[2][MAX_N];
int dist[2][MAX_N];

int process_position(int building, int floor) {
    if (floor > n) return floor;
    
    if (a[floor] == 0 || b[floor] == 0) {
        int wall = (building == 0) ? a[floor] : b[floor];
        if (wall == 0) return floor;
        else if (wall == 1) return ladder_top[building][floor];
        else return floor;
    }
    
    int wall = (building == 0) ? a[floor] : b[floor];
    
    if (wall == 0) {
        return floor;
    } else if (wall == 1) {
        return ladder_top[building][floor];
    } else {
        for (int f = floor - 1; f >= 1; f--) {
            int w = (building == 0) ? a[f] : b[f];
            if (w == 0) return f;
            if (w == 1) return ladder_top[building][f];
        }
        return 1;
    }
}

int main() {
    while (scanf(""%d"", &n) && n != 0) {
        for (int i = 1; i <= n; i++) {
            scanf(""%d"", &a[i]);
        }
        for (int i = 1; i <= n; i++) {
            scanf(""%d"", &b[i]);
        }
        
        for (int building = 0; building < 2; building++) {
            for (int i = 1; i <= n; i++) {
                int wall = (building == 0) ? a[i] : b[i];
                if (wall == 1) {
                    int top = i;
                    while (top < n) {
                        int next_wall = (building == 0) ? a[top + 1] : b[top + 1];
                        if (next_wall == 1) top++;
                        else break;
                    }
                    ladder_top[building][i] = top;
                } else {
                    ladder_top[building][i] = i;
                }
            }
        }
        
        for (int i = 0; i < 2; i++) {
            for (int j = 0; j <= n; j++) {
                dist[i][j] = INF;
            }
        }
        
        int queue[MAX_N * 2][2];
        int front = 0, rear = 0;
        
        int pos0 = process_position(0, 1);
        int pos1 = process_position(1, 1);
        
        dist[0][pos0] = 1;
        queue[rear][0] = 0;
        queue[rear][1] = pos0;
        rear++;
        
        dist[1][pos1] = 1;
        queue[rear][0] = 1;
        queue[rear][1] = pos1;
        rear++;
        
        while (front < rear) {
            int cur_building = queue[front][0];
            int cur_floor = queue[front][1];
            front++;
            
            int other_building = 1 - cur_building;
            
            for (int delta = 0; delta <= 2; delta++) {
                int next_floor = cur_floor + delta;
                int final_floor = process_position(other_building, next_floor);
                
                if (final_floor >= 1 && final_floor <= n) {
                    if (dist[other_building][final_floor] > dist[cur_building][cur_floor] + 1) {
                        dist[other_building][final_floor] = dist[cur_building][cur_floor] + 1;
                        queue[rear][0] = other_building;
                        queue[rear][1] = final_floor;
                        rear++;
                    }
                }
            }
        }
        
        int result = INF;
        if (dist[0][n] < result) result = dist[0][n];
        if (dist[1][n] < result) result = dist[1][n];
        
        if (result == INF) {
            printf(""NA\n"");
        } else {
            printf(""%d\n"", result);
        }
    }
    
    return 0;
}
",0
p00230,"忍者のビル登り
忍者のあつしさんは、毎日朝早くから夜遅くまで忍者ビルの屋上から町を警備しています。この忍者ビルは、隣接する 2 つの同じ階数のビルであり、あつしさんは警備のために、ビルとビルの間をジャンプしながら屋上へ向かうことを日課としています。
この 2 つのビルは頻繁に清掃が行われるため、ビル登りの助けとなるはしごや障害となる滑りやすい部分があります。  しかも、はしごや滑りやすい部分の位置は毎日変わります。   そのためあつしさんは、屋上へ向かう方法を毎日考えなければいけません。
あつしさんは二つ並んだ同じ階数のビルの壁を跳び移りながら、ビルの屋上を目指します。ジャンプ
はどちらか一方のビルの1階から始められます。向かい側のビルへジャンプするときには、同じ階・1つ上の階・2 つ上の階の、いずれかに飛び移ることができます。
壁には以下の 3 種類があり、それぞれの壁にジャンプした後の移動が決まっています。
0. 普通の壁: 上下の移動はしない。次のジャンプはそこから行う。
1. はしご: はしごは 2 つ以上の階にまたがってかかっており、今いるはしごの一番上まで移動する。次のジャンプはそこから行う。
2. すべる壁: 普通の壁かはしごの一番上まで滑り落ちる。次のジャンプはそこから行う。
また、壁は 1 階から屋上のすぐ下の最上階まであり、屋上へはそのビルの最上階からのみ行くことが
できます。また、ビルの最下階の壁はすべる壁にはなりません。
2 つのビルの階数
n
と 2 つのビルの壁の種類を入力とし、最少で何回目のジャンプで最上階までたどり着き、屋上まで行くことができるかを出力するプログラムを作成してください。なお、どちらのビルの屋上にたどり着いてもよいものとします。ただし、あつしさんがどちらのビルの屋上へもたどり着けない場合は“NA”と出力してください。
Input
複数のデータセットの並びが入力として与えられます。入力の終わりはゼロひとつの行で示されます。
各データセットは以下の形式で与えられます。
n
a
1
a
2
...
a
n
b
1
b
2
...
b
n
１行目にビルの階数
n
(3 ≤
n
≤ 100) が与えられます。２行目に１ つ目のビルの 1 階から
n
階までの壁の情報
a
i
、３行目に２つ目のビルの 1 階から
n
階までの壁の情報
b
i
が与えられます。
a
i
, b
i
は
i
階目の壁の情報を表し、0 が普通の壁、1 がはしご(
i
階と
i
+1 階にまたがる)、2 がすべる壁を表します。
データセットの数は 60 を超えません。
Output
入力データセットごとに、ジャンプの回数を１行に出力します。
Sample Input
8
0 0 0 2 2 2 0 0
1 1 1 1 0 0 0 0
4
1 1 2 2
0 0 2 2
0
Output for the Sample Input
4
NA",C,"short*p,v[][99];main(c,n,m,i,y){for(;m=scanf(""%d %[^\n] %[^\n]"",&n,v,v+1)*n;printf(m>n?""NA\n"":""%d\n"",m))for(i=2;i--;m=c)for(c=0,y=n;y>1&c<m;y+=y==n|*p&2?2:*p&p[-1]&1?0:!++c-1)p=--y+v[c+i&1];}",1
p00230,"忍者のビル登り
忍者のあつしさんは、毎日朝早くから夜遅くまで忍者ビルの屋上から町を警備しています。この忍者ビルは、隣接する 2 つの同じ階数のビルであり、あつしさんは警備のために、ビルとビルの間をジャンプしながら屋上へ向かうことを日課としています。
この 2 つのビルは頻繁に清掃が行われるため、ビル登りの助けとなるはしごや障害となる滑りやすい部分があります。  しかも、はしごや滑りやすい部分の位置は毎日変わります。   そのためあつしさんは、屋上へ向かう方法を毎日考えなければいけません。
あつしさんは二つ並んだ同じ階数のビルの壁を跳び移りながら、ビルの屋上を目指します。ジャンプ
はどちらか一方のビルの1階から始められます。向かい側のビルへジャンプするときには、同じ階・1つ上の階・2 つ上の階の、いずれかに飛び移ることができます。
壁には以下の 3 種類があり、それぞれの壁にジャンプした後の移動が決まっています。
0. 普通の壁: 上下の移動はしない。次のジャンプはそこから行う。
1. はしご: はしごは 2 つ以上の階にまたがってかかっており、今いるはしごの一番上まで移動する。次のジャンプはそこから行う。
2. すべる壁: 普通の壁かはしごの一番上まで滑り落ちる。次のジャンプはそこから行う。
また、壁は 1 階から屋上のすぐ下の最上階まであり、屋上へはそのビルの最上階からのみ行くことが
できます。また、ビルの最下階の壁はすべる壁にはなりません。
2 つのビルの階数
n
と 2 つのビルの壁の種類を入力とし、最少で何回目のジャンプで最上階までたどり着き、屋上まで行くことができるかを出力するプログラムを作成してください。なお、どちらのビルの屋上にたどり着いてもよいものとします。ただし、あつしさんがどちらのビルの屋上へもたどり着けない場合は“NA”と出力してください。
Input
複数のデータセットの並びが入力として与えられます。入力の終わりはゼロひとつの行で示されます。
各データセットは以下の形式で与えられます。
n
a
1
a
2
...
a
n
b
1
b
2
...
b
n
１行目にビルの階数
n
(3 ≤
n
≤ 100) が与えられます。２行目に１ つ目のビルの 1 階から
n
階までの壁の情報
a
i
、３行目に２つ目のビルの 1 階から
n
階までの壁の情報
b
i
が与えられます。
a
i
, b
i
は
i
階目の壁の情報を表し、0 が普通の壁、1 がはしご(
i
階と
i
+1 階にまたがる)、2 がすべる壁を表します。
データセットの数は 60 を超えません。
Output
入力データセットごとに、ジャンプの回数を１行に出力します。
Sample Input
8
0 0 0 2 2 2 0 0
1 1 1 1 0 0 0 0
4
1 1 2 2
0 0 2 2
0
Output for the Sample Input
4
NA",Java,"import java.util.*;

public class Main {
    static class State {
        int building; // 0 or 1
        int floor;
        int jumps;
        
        State(int building, int floor, int jumps) {
            this.building = building;
            this.floor = floor;
            this.jumps = jumps;
        }
    }
    
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        
        while (true) {
            int n = sc.nextInt();
            if (n == 0) break;
            
            int[] a = new int[n + 1];
            int[] b = new int[n + 1];
            
            for (int i = 1; i <= n; i++) {
                a[i] = sc.nextInt();
            }
            for (int i = 1; i <= n; i++) {
                b[i] = sc.nextInt();
            }
            
            int result = solve(n, a, b);
            if (result == -1) {
                System.out.println(""NA"");
            } else {
                System.out.println(result);
            }
        }
        sc.close();
    }
    
    static int solve(int n, int[] a, int[] b) {
        int[][] walls = {a, b};
        boolean[][] visited = new boolean[2][n + 1];
        Queue<State> queue = new LinkedList<>();
        
        // Start from floor 1 of either building
        int floor0 = processFloor(0, 1, walls, n);
        int floor1 = processFloor(1, 1, walls, n);
        
        if (floor0 != -1) {
            queue.add(new State(0, floor0, 0));
            visited[0][floor0] = true;
        }
        if (floor1 != -1) {
            queue.add(new State(1, floor1, 0));
            visited[1][floor1] = true;
        }
        
        while (!queue.isEmpty()) {
            State curr = queue.poll();
            
            if (curr.floor == n) {
                return curr.jumps;
            }
            
            int otherBuilding = 1 - curr.building;
            
            // Jump to same floor, +1, or +2
            for (int delta = 0; delta <= 2; delta++) {
                int targetFloor = curr.floor + delta;
                if (targetFloor > n) continue;
                
                int finalFloor = processFloor(otherBuilding, targetFloor, walls, n);
                
                if (finalFloor != -1 && !visited[otherBuilding][finalFloor]) {
                    visited[otherBuilding][finalFloor] = true;
                    queue.add(new State(otherBuilding, finalFloor, curr.jumps + 1));
                }
            }
        }
        
        return -1;
    }
    
    static int processFloor(int building, int floor, int[][] walls, int n) {
        int[] wall = walls[building];
        
        if (wall[floor] == 0) {
            return floor;
        } else if (wall[floor] == 1) {
            // Climb ladder to the top
            int top = floor;
            while (top < n && wall[top] == 1) {
                top++;
            }
            return top;
        } else { // wall[floor] == 2
            // Slide down
            int slideFloor = floor;
            while (slideFloor > 1) {
                slideFloor--;
                if (wall[slideFloor] == 0) {
                    return slideFloor;
                } else if (wall[slideFloor] == 1) {
                    // Find top of ladder
                    int top = slideFloor;
                    while (top < n && wall[top] == 1) {
                        top++;
                    }
                    return top;
                }
                // If wall[slideFloor] == 2, continue sliding
            }
            // Slid all the way to floor 1 or below, cannot start here
            return -1;
        }
    }
}
",0
p00230,"忍者のビル登り
忍者のあつしさんは、毎日朝早くから夜遅くまで忍者ビルの屋上から町を警備しています。この忍者ビルは、隣接する 2 つの同じ階数のビルであり、あつしさんは警備のために、ビルとビルの間をジャンプしながら屋上へ向かうことを日課としています。
この 2 つのビルは頻繁に清掃が行われるため、ビル登りの助けとなるはしごや障害となる滑りやすい部分があります。  しかも、はしごや滑りやすい部分の位置は毎日変わります。   そのためあつしさんは、屋上へ向かう方法を毎日考えなければいけません。
あつしさんは二つ並んだ同じ階数のビルの壁を跳び移りながら、ビルの屋上を目指します。ジャンプ
はどちらか一方のビルの1階から始められます。向かい側のビルへジャンプするときには、同じ階・1つ上の階・2 つ上の階の、いずれかに飛び移ることができます。
壁には以下の 3 種類があり、それぞれの壁にジャンプした後の移動が決まっています。
0. 普通の壁: 上下の移動はしない。次のジャンプはそこから行う。
1. はしご: はしごは 2 つ以上の階にまたがってかかっており、今いるはしごの一番上まで移動する。次のジャンプはそこから行う。
2. すべる壁: 普通の壁かはしごの一番上まで滑り落ちる。次のジャンプはそこから行う。
また、壁は 1 階から屋上のすぐ下の最上階まであり、屋上へはそのビルの最上階からのみ行くことが
できます。また、ビルの最下階の壁はすべる壁にはなりません。
2 つのビルの階数
n
と 2 つのビルの壁の種類を入力とし、最少で何回目のジャンプで最上階までたどり着き、屋上まで行くことができるかを出力するプログラムを作成してください。なお、どちらのビルの屋上にたどり着いてもよいものとします。ただし、あつしさんがどちらのビルの屋上へもたどり着けない場合は“NA”と出力してください。
Input
複数のデータセットの並びが入力として与えられます。入力の終わりはゼロひとつの行で示されます。
各データセットは以下の形式で与えられます。
n
a
1
a
2
...
a
n
b
1
b
2
...
b
n
１行目にビルの階数
n
(3 ≤
n
≤ 100) が与えられます。２行目に１ つ目のビルの 1 階から
n
階までの壁の情報
a
i
、３行目に２つ目のビルの 1 階から
n
階までの壁の情報
b
i
が与えられます。
a
i
, b
i
は
i
階目の壁の情報を表し、0 が普通の壁、1 がはしご(
i
階と
i
+1 階にまたがる)、2 がすべる壁を表します。
データセットの数は 60 を超えません。
Output
入力データセットごとに、ジャンプの回数を１行に出力します。
Sample Input
8
0 0 0 2 2 2 0 0
1 1 1 1 0 0 0 0
4
1 1 2 2
0 0 2 2
0
Output for the Sample Input
4
NA",Java,"import java.util.HashSet;
import java.util.LinkedList;
import java.util.Queue;
import java.util.Scanner;
import java.util.Set;

public class Main {
    Scanner sc = new Scanner(System.in);

    void run() {
        for (;;) {
            // 1 行目 ビルの階数 n(整数)
            // 2 行目 1 つ目のビル a の 1 階から n 階までの壁の情報 a1 a2 ... an(すべて整数;半角空白区切り)
            // 各 ai は、i 階目の壁の情報を表し、意味は以下のとおりです。
            // 0:普通の壁
            // 1:はしご(i 階と i+1 階にまたがる)
            // 2:すべる壁
            // 3 行目 2 つ目のビル b の 1 階から n 階までの壁の情報 b1 b2 ... bn(すべて整数;半角空白区切り)
            int n = sc.nextInt();
            if (n == 0)
                break;
            int fs[][] = new int[2][n];
            for (int i = 0; i < n; i++) {
                fs[0][i] = sc.nextInt();
            }
            for (int i = 0; i < n; i++) {
                fs[1][i] = sc.nextInt();
            }
            Queue<Data> q = new LinkedList<Data>();
            int sfa = 0;
            int sfb = 0;
            if (fs[0][0] == 1)
                while (sfa + 1 < n && fs[0][sfa + 1] == 1)
                    sfa++;
            if (fs[1][0] == 1)
                while (sfb + 1 < n && fs[1][sfb + 1] == 1)
                    sfb++;
            q.add(new Data(0, sfa, 0));
            q.add(new Data(1, sfb, 0));
            Set<String> set = new HashSet<String>();
            boolean na = true;
            while (!q.isEmpty()) {
                Data d = q.poll();
                int b = d.b;
                int f = d.f;
                if (set.contains(b + "" "" + f))
                    continue;
                set.add(b + "" "" + f);
                int t = d.t;
                if (f == n - 1 && fs[b][n - 1] != 2) {
                    System.out.println(t);
                    na = false;
                    break;
                }
                int nb = b ^ 1;
                for (int i = 0; i < 3; i++) {
                    // 向かい側のビルへジャンプするときには、
                    // 同じ階・1つ上の階・2 つ上の階の、いずれかに飛び移ることができます。
                    if (i + f >= n)
                        continue;
                    int nf = f + i;
                    switch (fs[nb][i + f]) {
                    case 0:
                        q.add(new Data(nb, nf, t + 1));
                        break;
                    case 1:
                        while (nf + 1 < n && fs[nb][nf + 1] == 1)
                            nf++;
                        q.add(new Data(nb, nf, t + 1));
                        break;
                    case 2:
                        while (fs[nb][nf] == 2)
                            nf--;
                        q.add(new Data(nb, nf, t + 1));
                        break;
                    }
                }

            }
            if (na)
                System.out.println(""NA"");
        }
    }

    public static void main(String[] args) {
        new Main().run();
    }
}

class Data {
    int b;
    int f;
    int t;

    Data(int b, int f, int t) {
        this.b = b;
        this.f = f;
        this.t = t;
    }

    public String toString() {
        return b + "" "" + f + "" "" + t;
    }
}",1
p00230,"忍者のビル登り
忍者のあつしさんは、毎日朝早くから夜遅くまで忍者ビルの屋上から町を警備しています。この忍者ビルは、隣接する 2 つの同じ階数のビルであり、あつしさんは警備のために、ビルとビルの間をジャンプしながら屋上へ向かうことを日課としています。
この 2 つのビルは頻繁に清掃が行われるため、ビル登りの助けとなるはしごや障害となる滑りやすい部分があります。  しかも、はしごや滑りやすい部分の位置は毎日変わります。   そのためあつしさんは、屋上へ向かう方法を毎日考えなければいけません。
あつしさんは二つ並んだ同じ階数のビルの壁を跳び移りながら、ビルの屋上を目指します。ジャンプ
はどちらか一方のビルの1階から始められます。向かい側のビルへジャンプするときには、同じ階・1つ上の階・2 つ上の階の、いずれかに飛び移ることができます。
壁には以下の 3 種類があり、それぞれの壁にジャンプした後の移動が決まっています。
0. 普通の壁: 上下の移動はしない。次のジャンプはそこから行う。
1. はしご: はしごは 2 つ以上の階にまたがってかかっており、今いるはしごの一番上まで移動する。次のジャンプはそこから行う。
2. すべる壁: 普通の壁かはしごの一番上まで滑り落ちる。次のジャンプはそこから行う。
また、壁は 1 階から屋上のすぐ下の最上階まであり、屋上へはそのビルの最上階からのみ行くことが
できます。また、ビルの最下階の壁はすべる壁にはなりません。
2 つのビルの階数
n
と 2 つのビルの壁の種類を入力とし、最少で何回目のジャンプで最上階までたどり着き、屋上まで行くことができるかを出力するプログラムを作成してください。なお、どちらのビルの屋上にたどり着いてもよいものとします。ただし、あつしさんがどちらのビルの屋上へもたどり着けない場合は“NA”と出力してください。
Input
複数のデータセットの並びが入力として与えられます。入力の終わりはゼロひとつの行で示されます。
各データセットは以下の形式で与えられます。
n
a
1
a
2
...
a
n
b
1
b
2
...
b
n
１行目にビルの階数
n
(3 ≤
n
≤ 100) が与えられます。２行目に１ つ目のビルの 1 階から
n
階までの壁の情報
a
i
、３行目に２つ目のビルの 1 階から
n
階までの壁の情報
b
i
が与えられます。
a
i
, b
i
は
i
階目の壁の情報を表し、0 が普通の壁、1 がはしご(
i
階と
i
+1 階にまたがる)、2 がすべる壁を表します。
データセットの数は 60 を超えません。
Output
入力データセットごとに、ジャンプの回数を１行に出力します。
Sample Input
8
0 0 0 2 2 2 0 0
1 1 1 1 0 0 0 0
4
1 1 2 2
0 0 2 2
0
Output for the Sample Input
4
NA",Python,"from collections import deque

def solve(n, a, b):
    # Preprocess ladders - find top of each ladder
    def find_ladder_top(walls):
        tops = list(range(n))
        i = 0
        while i < n:
            if walls[i] == 1:
                j = i
                while j < n and walls[j] == 1:
                    j += 1
                for k in range(i, j):
                    tops[k] = j - 1
                i = j
            else:
                i += 1
        return tops
    
    ladder_tops_a = find_ladder_top(a)
    ladder_tops_b = find_ladder_top(b)
    
    # Function to find where we end up after landing on floor i of building side
    def land_on(floor, side):
        if side == 0:
            walls = a
            ladder_tops = ladder_tops_a
        else:
            walls = b
            ladder_tops = ladder_tops_b
        
        if walls[floor] == 0:  # Normal wall
            return floor
        elif walls[floor] == 1:  # Ladder
            return ladder_tops[floor]
        else:  # walls[floor] == 2, sliding wall
            # Slide down to normal wall or top of ladder
            for f in range(floor - 1, -1, -1):
                if walls[f] == 0:
                    return f
                elif walls[f] == 1:
                    return ladder_tops[f]
            return -1  # Should not happen as floor 0 is not sliding
    
    # BFS
    queue = deque()
    visited = set()
    
    # Start from floor 0 of either building
    start_a = land_on(0, 0)
    start_b = land_on(0, 1)
    
    if start_a >= 0:
        queue.append((0, start_a, 0))  # (side, floor, jumps)
        visited.add((0, start_a))
    if start_b >= 0:
        queue.append((1, start_b, 0))
        visited.add((1, start_b))
    
    while queue:
        side, floor, jumps = queue.popleft()
        
        # Check if we can reach rooftop
        if floor == n - 1:
            return jumps
        
        # Try jumping to other building
        other_side = 1 - side
        for delta in [0, 1, 2]:
            next_floor = floor + delta
            if next_floor < n:
                final_floor = land_on(next_floor, other_side)
                if final_floor >= 0 and (other_side, final_floor) not in visited:
                    visited.add((other_side, final_floor))
                    queue.append((other_side, final_floor, jumps + 1))
    
    return ""NA""

while True:
    n = int(input())
    if n == 0:
        break
    
    a = list(map(int, input().split()))
    b = list(map(int, input().split()))
    
    result = solve(n, a, b)
    print(result)
",0
p00230,"忍者のビル登り
忍者のあつしさんは、毎日朝早くから夜遅くまで忍者ビルの屋上から町を警備しています。この忍者ビルは、隣接する 2 つの同じ階数のビルであり、あつしさんは警備のために、ビルとビルの間をジャンプしながら屋上へ向かうことを日課としています。
この 2 つのビルは頻繁に清掃が行われるため、ビル登りの助けとなるはしごや障害となる滑りやすい部分があります。  しかも、はしごや滑りやすい部分の位置は毎日変わります。   そのためあつしさんは、屋上へ向かう方法を毎日考えなければいけません。
あつしさんは二つ並んだ同じ階数のビルの壁を跳び移りながら、ビルの屋上を目指します。ジャンプ
はどちらか一方のビルの1階から始められます。向かい側のビルへジャンプするときには、同じ階・1つ上の階・2 つ上の階の、いずれかに飛び移ることができます。
壁には以下の 3 種類があり、それぞれの壁にジャンプした後の移動が決まっています。
0. 普通の壁: 上下の移動はしない。次のジャンプはそこから行う。
1. はしご: はしごは 2 つ以上の階にまたがってかかっており、今いるはしごの一番上まで移動する。次のジャンプはそこから行う。
2. すべる壁: 普通の壁かはしごの一番上まで滑り落ちる。次のジャンプはそこから行う。
また、壁は 1 階から屋上のすぐ下の最上階まであり、屋上へはそのビルの最上階からのみ行くことが
できます。また、ビルの最下階の壁はすべる壁にはなりません。
2 つのビルの階数
n
と 2 つのビルの壁の種類を入力とし、最少で何回目のジャンプで最上階までたどり着き、屋上まで行くことができるかを出力するプログラムを作成してください。なお、どちらのビルの屋上にたどり着いてもよいものとします。ただし、あつしさんがどちらのビルの屋上へもたどり着けない場合は“NA”と出力してください。
Input
複数のデータセットの並びが入力として与えられます。入力の終わりはゼロひとつの行で示されます。
各データセットは以下の形式で与えられます。
n
a
1
a
2
...
a
n
b
1
b
2
...
b
n
１行目にビルの階数
n
(3 ≤
n
≤ 100) が与えられます。２行目に１ つ目のビルの 1 階から
n
階までの壁の情報
a
i
、３行目に２つ目のビルの 1 階から
n
階までの壁の情報
b
i
が与えられます。
a
i
, b
i
は
i
階目の壁の情報を表し、0 が普通の壁、1 がはしご(
i
階と
i
+1 階にまたがる)、2 がすべる壁を表します。
データセットの数は 60 を超えません。
Output
入力データセットごとに、ジャンプの回数を１行に出力します。
Sample Input
8
0 0 0 2 2 2 0 0
1 1 1 1 0 0 0 0
4
1 1 2 2
0 0 2 2
0
Output for the Sample Input
4
NA",Python,"import Queue
while True:
    n = input()
    if n==0:
        break
    a = []
    nxt = [range(n) for i in xrange(2)]
    for i in xrange(2):
        a.append(map(int, raw_input().split()))
    for i in xrange(2):
        back = 0
        for j in xrange(n):
            if a[i][j]==2:
                nxt[i][j] = back
            else:
                back = j
        forw = n-1
        for j in xrange(n-1,-1,-1):
            if a[i][j]==1:
                nxt[i][j] = forw
            else:
                forw = j-1
    cost = [[10**9] * n for i in xrange(2)]
    que = Queue.PriorityQueue()
    que.put((0, 0, 0))
    que.put((0, 1, 0))
    ans = -1
    while not que.empty():
        co, sd, st = que.get()
        if st==n-1:
            ans = co
            break
        if cost[sd][st] < co:
            continue
        for i in xrange(3 if st+2<n else 2):
            step = nxt[sd^1][st+i]
            if co+1 < cost[sd^1][step]:
                cost[sd^1][step] = co+1
                que.put((co+1, sd^1, step))
    print ""NA"" if ans==-1 else ans",1
p00231,"危ない橋
会津若松市よりずっと北に位置する会津古松村では、「ヤ橋(やばし)   」と呼ばれる橋が周辺の村へ移動する唯一の手段となっています。その橋は通行人が多いにも関わらず、今にも壊れそうなほど老朽化が進んでしまっています。
ヤ橋は 150 [kg] まで耐えられる強度を持っています。例えば、80 [kg] の人と 50 [kg] の人が同時に渡ることはできますが、80 [kg] の人が渡っているときに 90 [kg] の人が渡り始めると、ヤ橋は壊れてしまいます。
もしヤ橋が壊れてしまったら、会津古松村の人々は周辺の村へ移動する手段を失ってしまいます。そこで、村で唯一のプログラマーであるあなたは、村民の生活を守るために、橋の渡り方から橋が壊れるか否かを判定するプログラムを作成することにしました。
橋を渡る通行人の人数
n
(1 ≤
n
≤ 100)、各通行人の体重
m
i
(1 ≤
m
i
≤ 100)、橋を渡り始める時刻
a
i
、渡り終える時刻
b
i
(0 ≤
a
i
,
b
i
< 2
31
) を入力とし、橋が壊れない場合は“OK ”と出力し、壊れる場合は“NG ”と出力するプログラムを作成してください。なお、橋の上にいる通行人の体重の総和が 150 [kg] を超えてしまうとヤ橋は壊れてしまいます。また、
a
i
の時点で通行人は橋の上にいますが、
b
i
の時点では橋の上にいません。
Input
複数のデータセットの並びが入力として与えられます。入力の終わりはゼロひとつの行で示されます。各データセットは以下の形式で与えられます。
n
m
1
a
1
b
1
m
2
a
2
b
2
:
m
n
a
n
b
n
データセットの数は 1200 を超えません。
Output
入力データセットごとに、橋が壊れるか否かを1行に出力します。
Sample Input
3
80 0 30
50 5 25
90 27 50
3
80 0 30
70 5 25
71 30 50
0
Output for the Sample Input
NG
OK",C,"#include <stdio.h>
#include <stdlib.h>

typedef struct {
    int time;
    int weight;
    int type; // 0 for start, 1 for end
} Event;

int compare(const void *a, const void *b) {
    Event *ea = (Event *)a;
    Event *eb = (Event *)b;
    if (ea->time != eb->time) {
        return ea->time - eb->time;
    }
    // If times are equal, process end events before start events
    return ea->type - eb->type;
}

int main() {
    int n;
    while (scanf(""%d"", &n) == 1 && n != 0) {
        Event events[200];
        int eventCount = 0;
        
        for (int i = 0; i < n; i++) {
            int m, a, b;
            scanf(""%d %d %d"", &m, &a, &b);
            
            events[eventCount].time = a;
            events[eventCount].weight = m;
            events[eventCount].type = 0;
            eventCount++;
            
            events[eventCount].time = b;
            events[eventCount].weight = m;
            events[eventCount].type = 1;
            eventCount++;
        }
        
        qsort(events, eventCount, sizeof(Event), compare);
        
        int currentWeight = 0;
        int broken = 0;
        
        for (int i = 0; i < eventCount; i++) {
            if (events[i].type == 0) {
                // Person starts crossing
                currentWeight += events[i].weight;
                if (currentWeight > 150) {
                    broken = 1;
                    break;
                }
            } else {
                // Person finishes crossing
                currentWeight -= events[i].weight;
            }
        }
        
        if (broken) {
            printf(""NG\n"");
        } else {
            printf(""OK\n"");
        }
    }
    
    return 0;
}
",0
p00231,"危ない橋
会津若松市よりずっと北に位置する会津古松村では、「ヤ橋(やばし)   」と呼ばれる橋が周辺の村へ移動する唯一の手段となっています。その橋は通行人が多いにも関わらず、今にも壊れそうなほど老朽化が進んでしまっています。
ヤ橋は 150 [kg] まで耐えられる強度を持っています。例えば、80 [kg] の人と 50 [kg] の人が同時に渡ることはできますが、80 [kg] の人が渡っているときに 90 [kg] の人が渡り始めると、ヤ橋は壊れてしまいます。
もしヤ橋が壊れてしまったら、会津古松村の人々は周辺の村へ移動する手段を失ってしまいます。そこで、村で唯一のプログラマーであるあなたは、村民の生活を守るために、橋の渡り方から橋が壊れるか否かを判定するプログラムを作成することにしました。
橋を渡る通行人の人数
n
(1 ≤
n
≤ 100)、各通行人の体重
m
i
(1 ≤
m
i
≤ 100)、橋を渡り始める時刻
a
i
、渡り終える時刻
b
i
(0 ≤
a
i
,
b
i
< 2
31
) を入力とし、橋が壊れない場合は“OK ”と出力し、壊れる場合は“NG ”と出力するプログラムを作成してください。なお、橋の上にいる通行人の体重の総和が 150 [kg] を超えてしまうとヤ橋は壊れてしまいます。また、
a
i
の時点で通行人は橋の上にいますが、
b
i
の時点では橋の上にいません。
Input
複数のデータセットの並びが入力として与えられます。入力の終わりはゼロひとつの行で示されます。各データセットは以下の形式で与えられます。
n
m
1
a
1
b
1
m
2
a
2
b
2
:
m
n
a
n
b
n
データセットの数は 1200 を超えません。
Output
入力データセットごとに、橋が壊れるか否かを1行に出力します。
Sample Input
3
80 0 30
50 5 25
90 27 50
3
80 0 30
70 5 25
71 30 50
0
Output for the Sample Input
NG
OK",C,"m[100],a[100],b[100],i,j,M,B;main(n){for(;scanf(""%d"",&n)*n;puts(B?""NG"":""OK"")){for(i=n;i--;B=0)scanf(""%d%d%d"",m+i,a+i,b+i);for(i=n;i--;B|=M>150)for(M=0,j=n;j--;)M+=a[i]>=a[j]&&a[i]<b[j]?m[j]:0;}}
m[100],a[100],b[100],i,j,M,B;",1
p00231,"危ない橋
会津若松市よりずっと北に位置する会津古松村では、「ヤ橋(やばし)   」と呼ばれる橋が周辺の村へ移動する唯一の手段となっています。その橋は通行人が多いにも関わらず、今にも壊れそうなほど老朽化が進んでしまっています。
ヤ橋は 150 [kg] まで耐えられる強度を持っています。例えば、80 [kg] の人と 50 [kg] の人が同時に渡ることはできますが、80 [kg] の人が渡っているときに 90 [kg] の人が渡り始めると、ヤ橋は壊れてしまいます。
もしヤ橋が壊れてしまったら、会津古松村の人々は周辺の村へ移動する手段を失ってしまいます。そこで、村で唯一のプログラマーであるあなたは、村民の生活を守るために、橋の渡り方から橋が壊れるか否かを判定するプログラムを作成することにしました。
橋を渡る通行人の人数
n
(1 ≤
n
≤ 100)、各通行人の体重
m
i
(1 ≤
m
i
≤ 100)、橋を渡り始める時刻
a
i
、渡り終える時刻
b
i
(0 ≤
a
i
,
b
i
< 2
31
) を入力とし、橋が壊れない場合は“OK ”と出力し、壊れる場合は“NG ”と出力するプログラムを作成してください。なお、橋の上にいる通行人の体重の総和が 150 [kg] を超えてしまうとヤ橋は壊れてしまいます。また、
a
i
の時点で通行人は橋の上にいますが、
b
i
の時点では橋の上にいません。
Input
複数のデータセットの並びが入力として与えられます。入力の終わりはゼロひとつの行で示されます。各データセットは以下の形式で与えられます。
n
m
1
a
1
b
1
m
2
a
2
b
2
:
m
n
a
n
b
n
データセットの数は 1200 を超えません。
Output
入力データセットごとに、橋が壊れるか否かを1行に出力します。
Sample Input
3
80 0 30
50 5 25
90 27 50
3
80 0 30
70 5 25
71 30 50
0
Output for the Sample Input
NG
OK",Java,"import java.util.*;

public class Main {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        
        while (true) {
            int n = sc.nextInt();
            if (n == 0) break;
            
            List<Event> events = new ArrayList<>();
            
            for (int i = 0; i < n; i++) {
                int m = sc.nextInt();
                long a = sc.nextLong();
                long b = sc.nextLong();
                
                events.add(new Event(a, m, true));
                events.add(new Event(b, m, false));
            }
            
            Collections.sort(events);
            
            int currentWeight = 0;
            boolean broken = false;
            
            for (Event e : events) {
                if (e.isEnter) {
                    currentWeight += e.weight;
                    if (currentWeight > 150) {
                        broken = true;
                        break;
                    }
                } else {
                    currentWeight -= e.weight;
                }
            }
            
            System.out.println(broken ? ""NG"" : ""OK"");
        }
        
        sc.close();
    }
    
    static class Event implements Comparable<Event> {
        long time;
        int weight;
        boolean isEnter;
        
        Event(long time, int weight, boolean isEnter) {
            this.time = time;
            this.weight = weight;
            this.isEnter = isEnter;
        }
        
        @Override
        public int compareTo(Event other) {
            if (this.time != other.time) {
                return Long.compare(this.time, other.time);
            }
            // Exit events should come before enter events at the same time
            if (this.isEnter != other.isEnter) {
                return this.isEnter ? 1 : -1;
            }
            return 0;
        }
    }
}
",0
p00231,"危ない橋
会津若松市よりずっと北に位置する会津古松村では、「ヤ橋(やばし)   」と呼ばれる橋が周辺の村へ移動する唯一の手段となっています。その橋は通行人が多いにも関わらず、今にも壊れそうなほど老朽化が進んでしまっています。
ヤ橋は 150 [kg] まで耐えられる強度を持っています。例えば、80 [kg] の人と 50 [kg] の人が同時に渡ることはできますが、80 [kg] の人が渡っているときに 90 [kg] の人が渡り始めると、ヤ橋は壊れてしまいます。
もしヤ橋が壊れてしまったら、会津古松村の人々は周辺の村へ移動する手段を失ってしまいます。そこで、村で唯一のプログラマーであるあなたは、村民の生活を守るために、橋の渡り方から橋が壊れるか否かを判定するプログラムを作成することにしました。
橋を渡る通行人の人数
n
(1 ≤
n
≤ 100)、各通行人の体重
m
i
(1 ≤
m
i
≤ 100)、橋を渡り始める時刻
a
i
、渡り終える時刻
b
i
(0 ≤
a
i
,
b
i
< 2
31
) を入力とし、橋が壊れない場合は“OK ”と出力し、壊れる場合は“NG ”と出力するプログラムを作成してください。なお、橋の上にいる通行人の体重の総和が 150 [kg] を超えてしまうとヤ橋は壊れてしまいます。また、
a
i
の時点で通行人は橋の上にいますが、
b
i
の時点では橋の上にいません。
Input
複数のデータセットの並びが入力として与えられます。入力の終わりはゼロひとつの行で示されます。各データセットは以下の形式で与えられます。
n
m
1
a
1
b
1
m
2
a
2
b
2
:
m
n
a
n
b
n
データセットの数は 1200 を超えません。
Output
入力データセットごとに、橋が壊れるか否かを1行に出力します。
Sample Input
3
80 0 30
50 5 25
90 27 50
3
80 0 30
70 5 25
71 30 50
0
Output for the Sample Input
NG
OK",Java,"import java.util.Scanner;

//Dangerous Bridge
public class Main {

	public static void main(String[] args) {
		Scanner sc = new Scanner(System.in);
		while(true){
			int n = sc.nextInt();
			if(n==0)break;
			boolean[][] map = new boolean[n*2][250];
			int[] w = new int[n];
			for(int i=0;i<n;i++){
				w[i] = sc.nextInt();
				int a = sc.nextInt();
				int b = sc.nextInt();
				for(int j=a;j<b;j++)map[i][j] = true;
			}
			boolean f = true;
			for(int i=0;i<231;i++){
				int sum = 0;
				for(int j=0;j<n;j++){
					if(map[j][i])sum+=w[j];
				}
				if(sum>150){
					f = false;
					break;
				}
			}
			System.out.println(f?""OK"":""NG"");
		}
	}
}",1
p00231,"危ない橋
会津若松市よりずっと北に位置する会津古松村では、「ヤ橋(やばし)   」と呼ばれる橋が周辺の村へ移動する唯一の手段となっています。その橋は通行人が多いにも関わらず、今にも壊れそうなほど老朽化が進んでしまっています。
ヤ橋は 150 [kg] まで耐えられる強度を持っています。例えば、80 [kg] の人と 50 [kg] の人が同時に渡ることはできますが、80 [kg] の人が渡っているときに 90 [kg] の人が渡り始めると、ヤ橋は壊れてしまいます。
もしヤ橋が壊れてしまったら、会津古松村の人々は周辺の村へ移動する手段を失ってしまいます。そこで、村で唯一のプログラマーであるあなたは、村民の生活を守るために、橋の渡り方から橋が壊れるか否かを判定するプログラムを作成することにしました。
橋を渡る通行人の人数
n
(1 ≤
n
≤ 100)、各通行人の体重
m
i
(1 ≤
m
i
≤ 100)、橋を渡り始める時刻
a
i
、渡り終える時刻
b
i
(0 ≤
a
i
,
b
i
< 2
31
) を入力とし、橋が壊れない場合は“OK ”と出力し、壊れる場合は“NG ”と出力するプログラムを作成してください。なお、橋の上にいる通行人の体重の総和が 150 [kg] を超えてしまうとヤ橋は壊れてしまいます。また、
a
i
の時点で通行人は橋の上にいますが、
b
i
の時点では橋の上にいません。
Input
複数のデータセットの並びが入力として与えられます。入力の終わりはゼロひとつの行で示されます。各データセットは以下の形式で与えられます。
n
m
1
a
1
b
1
m
2
a
2
b
2
:
m
n
a
n
b
n
データセットの数は 1200 を超えません。
Output
入力データセットごとに、橋が壊れるか否かを1行に出力します。
Sample Input
3
80 0 30
50 5 25
90 27 50
3
80 0 30
70 5 25
71 30 50
0
Output for the Sample Input
NG
OK",Python,"while True:
    n = int(input())
    if n == 0:
        break
    
    people = []
    for _ in range(n):
        m, a, b = map(int, input().split())
        people.append((m, a, b))
    
    # Collect all time points
    times = set()
    for m, a, b in people:
        times.add(a)
        times.add(b)
    
    times = sorted(times)
    
    broken = False
    for t in times:
        total_weight = 0
        for m, a, b in people:
            if a <= t < b:
                total_weight += m
        if total_weight > 150:
            broken = True
            break
    
    if broken:
        print(""NG"")
    else:
        print(""OK"")
",0
p00231,"危ない橋
会津若松市よりずっと北に位置する会津古松村では、「ヤ橋(やばし)   」と呼ばれる橋が周辺の村へ移動する唯一の手段となっています。その橋は通行人が多いにも関わらず、今にも壊れそうなほど老朽化が進んでしまっています。
ヤ橋は 150 [kg] まで耐えられる強度を持っています。例えば、80 [kg] の人と 50 [kg] の人が同時に渡ることはできますが、80 [kg] の人が渡っているときに 90 [kg] の人が渡り始めると、ヤ橋は壊れてしまいます。
もしヤ橋が壊れてしまったら、会津古松村の人々は周辺の村へ移動する手段を失ってしまいます。そこで、村で唯一のプログラマーであるあなたは、村民の生活を守るために、橋の渡り方から橋が壊れるか否かを判定するプログラムを作成することにしました。
橋を渡る通行人の人数
n
(1 ≤
n
≤ 100)、各通行人の体重
m
i
(1 ≤
m
i
≤ 100)、橋を渡り始める時刻
a
i
、渡り終える時刻
b
i
(0 ≤
a
i
,
b
i
< 2
31
) を入力とし、橋が壊れない場合は“OK ”と出力し、壊れる場合は“NG ”と出力するプログラムを作成してください。なお、橋の上にいる通行人の体重の総和が 150 [kg] を超えてしまうとヤ橋は壊れてしまいます。また、
a
i
の時点で通行人は橋の上にいますが、
b
i
の時点では橋の上にいません。
Input
複数のデータセットの並びが入力として与えられます。入力の終わりはゼロひとつの行で示されます。各データセットは以下の形式で与えられます。
n
m
1
a
1
b
1
m
2
a
2
b
2
:
m
n
a
n
b
n
データセットの数は 1200 を超えません。
Output
入力データセットごとに、橋が壊れるか否かを1行に出力します。
Sample Input
3
80 0 30
50 5 25
90 27 50
3
80 0 30
70 5 25
71 30 50
0
Output for the Sample Input
NG
OK",Python,"while 1:
    n=input()
    if n==0: break
    d=[map(int,raw_input().split()) for i in range(n)]
    w=max([sum([d2[0] for d2 in d if d2[1]<=d1[1]<d2[2]]) for d1 in d])
    print ""OK"" if w<151 else ""NG""",1
p00233,"図書整理
数の表わし方には色々な種類があり、私たちが普段使っている 10 進数は一つの代表的なものでしかありません。コンピュータ関連の知識がある人には、2 進数、16 進数あたりはとても身近なものです。
N さんは司書資格を活かして司書の仕事に就きました。最初の仕事は図書整理です。この図書館では、一冊ごとに一貫して番号が与えられており、それに従って本を整理しています。
この図書館では本の番号をマイナス十進数で表すことになっています。
マイナス十進数は、
a
n
a
n−1
a
n−2
...
a
2
a
1
a
0
(各
a
i
は 0~9 の数字) と表記する方法であり、この数は次の数を表します。
a
n
×(−10)
n
+ a
n−1
×(−10)
n−1
+
...
+ a
2
×(−10)
2
+ a
1
×(−10)
1
+ a
0
×(−10)
0
たとえば、マイナス十進数の 2156 は、以下のとおり十進数の-1944 に対応しています。
2×(-10)
3
+ 1×(-10)
2
+ 5×(-10)
1
+ 6×(-10)
0
=
2×(-1000) + 1×(100) + 5×(-10) + 6×(1) =
-2000 + 100 - 50 + 6 = -1944
十進数の番号をマイナス十進数に直すのは大変なので、N さんは大変不自由な思いをしています。
本の番号を入力とし、 この番号のマイナス十進数表記を出力するプログラムを作成してください。
Input
複数のデータセットの並びが入力として与えられます。入力の終わりはゼロひとつの行で示されます。各データセットとして、本の番号を表す整数
A
(-2
31
≤
A
< 2
31
) が１行に与えられます。
データセットの数は 1200 を超えません。
Output
入力データセットごとに、番号のマイナス十進数表記を１行に出力します。
Sample Input
9
10
-10
-1944
-305432133
0
Output for the Sample Input
9
190
10
2156
1715573947",C,"#include <stdio.h>
#include <string.h>

int main() {
    long long n;
    
    while(scanf(""%lld"", &n) == 1 && n != 0) {
        if(n == 0) {
            printf(""0\n"");
            continue;
        }
        
        char result[100];
        int idx = 0;
        
        long long num = n;
        while(num != 0) {
            long long remainder = num % (-10);
            num = num / (-10);
            
            if(remainder < 0) {
                remainder += 10;
                num += 1;
            }
            
            result[idx++] = '0' + remainder;
        }
        
        for(int i = idx - 1; i >= 0; i--) {
            printf(""%c"", result[i]);
        }
        printf(""\n"");
    }
    
    return 0;
}
",0
p00233,"図書整理
数の表わし方には色々な種類があり、私たちが普段使っている 10 進数は一つの代表的なものでしかありません。コンピュータ関連の知識がある人には、2 進数、16 進数あたりはとても身近なものです。
N さんは司書資格を活かして司書の仕事に就きました。最初の仕事は図書整理です。この図書館では、一冊ごとに一貫して番号が与えられており、それに従って本を整理しています。
この図書館では本の番号をマイナス十進数で表すことになっています。
マイナス十進数は、
a
n
a
n−1
a
n−2
...
a
2
a
1
a
0
(各
a
i
は 0~9 の数字) と表記する方法であり、この数は次の数を表します。
a
n
×(−10)
n
+ a
n−1
×(−10)
n−1
+
...
+ a
2
×(−10)
2
+ a
1
×(−10)
1
+ a
0
×(−10)
0
たとえば、マイナス十進数の 2156 は、以下のとおり十進数の-1944 に対応しています。
2×(-10)
3
+ 1×(-10)
2
+ 5×(-10)
1
+ 6×(-10)
0
=
2×(-1000) + 1×(100) + 5×(-10) + 6×(1) =
-2000 + 100 - 50 + 6 = -1944
十進数の番号をマイナス十進数に直すのは大変なので、N さんは大変不自由な思いをしています。
本の番号を入力とし、 この番号のマイナス十進数表記を出力するプログラムを作成してください。
Input
複数のデータセットの並びが入力として与えられます。入力の終わりはゼロひとつの行で示されます。各データセットとして、本の番号を表す整数
A
(-2
31
≤
A
< 2
31
) が１行に与えられます。
データセットの数は 1200 を超えません。
Output
入力データセットごとに、番号のマイナス十進数表記を１行に出力します。
Sample Input
9
10
-10
-1944
-305432133
0
Output for the Sample Input
9
190
10
2156
1715573947",C,"char z[];n,a;main(r){for(;scanf(""%d"",&a)*a;puts(z+n))for(n=30;a;a=(r-a)/10)r=a%10,z[--n]=r+48;}",1
p00233,"図書整理
数の表わし方には色々な種類があり、私たちが普段使っている 10 進数は一つの代表的なものでしかありません。コンピュータ関連の知識がある人には、2 進数、16 進数あたりはとても身近なものです。
N さんは司書資格を活かして司書の仕事に就きました。最初の仕事は図書整理です。この図書館では、一冊ごとに一貫して番号が与えられており、それに従って本を整理しています。
この図書館では本の番号をマイナス十進数で表すことになっています。
マイナス十進数は、
a
n
a
n−1
a
n−2
...
a
2
a
1
a
0
(各
a
i
は 0~9 の数字) と表記する方法であり、この数は次の数を表します。
a
n
×(−10)
n
+ a
n−1
×(−10)
n−1
+
...
+ a
2
×(−10)
2
+ a
1
×(−10)
1
+ a
0
×(−10)
0
たとえば、マイナス十進数の 2156 は、以下のとおり十進数の-1944 に対応しています。
2×(-10)
3
+ 1×(-10)
2
+ 5×(-10)
1
+ 6×(-10)
0
=
2×(-1000) + 1×(100) + 5×(-10) + 6×(1) =
-2000 + 100 - 50 + 6 = -1944
十進数の番号をマイナス十進数に直すのは大変なので、N さんは大変不自由な思いをしています。
本の番号を入力とし、 この番号のマイナス十進数表記を出力するプログラムを作成してください。
Input
複数のデータセットの並びが入力として与えられます。入力の終わりはゼロひとつの行で示されます。各データセットとして、本の番号を表す整数
A
(-2
31
≤
A
< 2
31
) が１行に与えられます。
データセットの数は 1200 を超えません。
Output
入力データセットごとに、番号のマイナス十進数表記を１行に出力します。
Sample Input
9
10
-10
-1944
-305432133
0
Output for the Sample Input
9
190
10
2156
1715573947",Java,"import java.util.Scanner;

public class Main {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        
        while (true) {
            long A = sc.nextLong();
            if (A == 0) break;
            
            if (A == 0) {
                System.out.println(""0"");
                continue;
            }
            
            StringBuilder result = new StringBuilder();
            long num = A;
            
            while (num != 0) {
                long remainder = num % (-10);
                num = num / (-10);
                
                if (remainder < 0) {
                    remainder += 10;
                    num += 1;
                }
                
                result.append(remainder);
            }
            
            System.out.println(result.reverse().toString());
        }
        
        sc.close();
    }
}
",0
p00233,"図書整理
数の表わし方には色々な種類があり、私たちが普段使っている 10 進数は一つの代表的なものでしかありません。コンピュータ関連の知識がある人には、2 進数、16 進数あたりはとても身近なものです。
N さんは司書資格を活かして司書の仕事に就きました。最初の仕事は図書整理です。この図書館では、一冊ごとに一貫して番号が与えられており、それに従って本を整理しています。
この図書館では本の番号をマイナス十進数で表すことになっています。
マイナス十進数は、
a
n
a
n−1
a
n−2
...
a
2
a
1
a
0
(各
a
i
は 0~9 の数字) と表記する方法であり、この数は次の数を表します。
a
n
×(−10)
n
+ a
n−1
×(−10)
n−1
+
...
+ a
2
×(−10)
2
+ a
1
×(−10)
1
+ a
0
×(−10)
0
たとえば、マイナス十進数の 2156 は、以下のとおり十進数の-1944 に対応しています。
2×(-10)
3
+ 1×(-10)
2
+ 5×(-10)
1
+ 6×(-10)
0
=
2×(-1000) + 1×(100) + 5×(-10) + 6×(1) =
-2000 + 100 - 50 + 6 = -1944
十進数の番号をマイナス十進数に直すのは大変なので、N さんは大変不自由な思いをしています。
本の番号を入力とし、 この番号のマイナス十進数表記を出力するプログラムを作成してください。
Input
複数のデータセットの並びが入力として与えられます。入力の終わりはゼロひとつの行で示されます。各データセットとして、本の番号を表す整数
A
(-2
31
≤
A
< 2
31
) が１行に与えられます。
データセットの数は 1200 を超えません。
Output
入力データセットごとに、番号のマイナス十進数表記を１行に出力します。
Sample Input
9
10
-10
-1944
-305432133
0
Output for the Sample Input
9
190
10
2156
1715573947",Java,"import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.HashMap;
import java.util.Scanner;
import java.util.*;
import java.math.*;
import java.io.*;

public class Main {

	public static void main(String[] args) {
		Scanner sc = new Scanner(System.in);
		while(true) {
			int ss = sc.nextInt();
			if(ss == 0) break;
			boolean minus = false;
			if(ss < 0) minus = true;
			char[] in = String.valueOf(ss).toCharArray();
			int[] ar0 = new int[32];
			int[] ar1 = new int[32];
			for(int i = 0; i < in.length; i++) {
				if(in[in.length - i - 1] == '-') continue;
				ar0[i] = in[in.length -1 - i] - '0';
			}
			int max = 0;
			if(!minus)
			for(int i = 0; i < 32; i++) {
				if(ar0[i] == 0) continue;
				max = i;
				if(i % 2 == 0) {
					if(ar0[i] < 10) {
						ar1[i] += ar0[i];
					}
					else {
						ar0[i+1] += ar0[i]/10;
						ar1[i] += ar0[i] % 10;
					}
				}
				else {
					if(ar0[i] < 10) {
						ar1[i] += 10 - ar0[i] % 10;
						ar0[i+1] += 1;
					}
					else {
						ar0[i+1] += ar0[i] / 10;
						ar1[i] += 10 - ar0[i] % 10;
						if(ar0[i] % 10 != 0)
						ar0[i+1] += 1;
					}
				}
			}
			else {
				for(int i = 0; i < 32; i++) {
					if(ar0[i] == 0) continue;
					if(i % 2 != 0) {
						if(ar0[i] < 10) {
							ar1[i] += ar0[i];
						}
						else {
							ar0[i+1] += ar0[i]/10;
							ar1[i] += ar0[i] % 10;
						}
					}
					else {
						if(ar0[i] < 10) {
							ar1[i] += 10 - ar0[i] % 10;
							ar0[i+1] += 1;
						}
						else {
							ar0[i+1] += ar0[i] / 10;
							ar1[i] += 10 - ar0[i] % 10;
							if(ar0[i] % 10 != 0)
							ar0[i+1] += 1;
						}
					}
				}
			}
			int check = 0;
			for(int i = 0; i < 32; i++) {
				if(ar1[i] != 0) {
					check = i;
				}
			}
			for(int i = check; i >= 0; i--) {
				System.out.print(ar1[i]);
			}
			System.out.println();
			
			
			
			
		}
	}
	
}",1
p00233,"図書整理
数の表わし方には色々な種類があり、私たちが普段使っている 10 進数は一つの代表的なものでしかありません。コンピュータ関連の知識がある人には、2 進数、16 進数あたりはとても身近なものです。
N さんは司書資格を活かして司書の仕事に就きました。最初の仕事は図書整理です。この図書館では、一冊ごとに一貫して番号が与えられており、それに従って本を整理しています。
この図書館では本の番号をマイナス十進数で表すことになっています。
マイナス十進数は、
a
n
a
n−1
a
n−2
...
a
2
a
1
a
0
(各
a
i
は 0~9 の数字) と表記する方法であり、この数は次の数を表します。
a
n
×(−10)
n
+ a
n−1
×(−10)
n−1
+
...
+ a
2
×(−10)
2
+ a
1
×(−10)
1
+ a
0
×(−10)
0
たとえば、マイナス十進数の 2156 は、以下のとおり十進数の-1944 に対応しています。
2×(-10)
3
+ 1×(-10)
2
+ 5×(-10)
1
+ 6×(-10)
0
=
2×(-1000) + 1×(100) + 5×(-10) + 6×(1) =
-2000 + 100 - 50 + 6 = -1944
十進数の番号をマイナス十進数に直すのは大変なので、N さんは大変不自由な思いをしています。
本の番号を入力とし、 この番号のマイナス十進数表記を出力するプログラムを作成してください。
Input
複数のデータセットの並びが入力として与えられます。入力の終わりはゼロひとつの行で示されます。各データセットとして、本の番号を表す整数
A
(-2
31
≤
A
< 2
31
) が１行に与えられます。
データセットの数は 1200 を超えません。
Output
入力データセットごとに、番号のマイナス十進数表記を１行に出力します。
Sample Input
9
10
-10
-1944
-305432133
0
Output for the Sample Input
9
190
10
2156
1715573947",Python,"import sys

def to_negadecimal(n):
    if n == 0:
        return ""0""
    
    result = []
    while n != 0:
        if n > 0:
            remainder = n % (-10)
            n = n // (-10)
            if remainder < 0:
                remainder += 10
                n += 1
        else:
            remainder = n % (-10)
            n = n // (-10)
            if remainder < 0:
                remainder += 10
                n += 1
        result.append(str(remainder))
    
    return ''.join(reversed(result))

for line in sys.stdin:
    a = int(line.strip())
    if a == 0 and line.strip() == ""0"":
        # Check if this is the last zero (terminator)
        break
    print(to_negadecimal(a))
```

Wait, let me reconsider the termination condition:

```python
import sys

def to_negadecimal(n):
    if n == 0:
        return ""0""
    
    result = []
    while n != 0:
        remainder = n % (-10)
        n = n // (-10)
        if remainder < 0:
            remainder += 10
            n += 1
        result.append(str(remainder))
    
    return ''.join(reversed(result))

for line in sys.stdin:
    a = int(line.strip())
    if a == 0:
        break
    print(to_negadecimal(a))
",0
p00233,"図書整理
数の表わし方には色々な種類があり、私たちが普段使っている 10 進数は一つの代表的なものでしかありません。コンピュータ関連の知識がある人には、2 進数、16 進数あたりはとても身近なものです。
N さんは司書資格を活かして司書の仕事に就きました。最初の仕事は図書整理です。この図書館では、一冊ごとに一貫して番号が与えられており、それに従って本を整理しています。
この図書館では本の番号をマイナス十進数で表すことになっています。
マイナス十進数は、
a
n
a
n−1
a
n−2
...
a
2
a
1
a
0
(各
a
i
は 0~9 の数字) と表記する方法であり、この数は次の数を表します。
a
n
×(−10)
n
+ a
n−1
×(−10)
n−1
+
...
+ a
2
×(−10)
2
+ a
1
×(−10)
1
+ a
0
×(−10)
0
たとえば、マイナス十進数の 2156 は、以下のとおり十進数の-1944 に対応しています。
2×(-10)
3
+ 1×(-10)
2
+ 5×(-10)
1
+ 6×(-10)
0
=
2×(-1000) + 1×(100) + 5×(-10) + 6×(1) =
-2000 + 100 - 50 + 6 = -1944
十進数の番号をマイナス十進数に直すのは大変なので、N さんは大変不自由な思いをしています。
本の番号を入力とし、 この番号のマイナス十進数表記を出力するプログラムを作成してください。
Input
複数のデータセットの並びが入力として与えられます。入力の終わりはゼロひとつの行で示されます。各データセットとして、本の番号を表す整数
A
(-2
31
≤
A
< 2
31
) が１行に与えられます。
データセットの数は 1200 を超えません。
Output
入力データセットごとに、番号のマイナス十進数表記を１行に出力します。
Sample Input
9
10
-10
-1944
-305432133
0
Output for the Sample Input
9
190
10
2156
1715573947",Python,"while 1:
	n = raw_input()[::-1]
	if n == ""0"": break
	ans = """"
	m = 1 if n[-1] == ""-"" else 0
	for i in range(0, len(n) - m, 2):
		if int(n[i]) > 0:
			if i < len(n) - 1 - m:
				ans += str(10 - int(n[i])) + str(int(n[i + 1]) + 1)
			else:
				ans += str(10 - int(n[i])) + ""1""
		else:
			ans += ""0"" + n[i + 1]
	if len(n) == 1 or (m == 0 and n[0] == ""0""):
		ans = int(""2""+""0""*len(n)) - int(ans[::-1]) 
	else:
		ans = int(ans[::-1])
	print ans",1
p00234,"会津の埋蔵金
会津には古くから伝わる埋蔵金の伝説があります。あなたは、遂に埋蔵金が埋まっている場所を突き止めました。埋蔵金が埋まっている深さ、掘り進める地層の状態が分かっているので、綿密に計画を立てれば最小費用で埋蔵金まで到達することができます。そこであなたは、地層の状態を読み取って埋蔵金の埋まっている深さまで最小費用で到達するルートを算出するプログラムを作成することにしました。
地層の状態は 2 次元格子状に配置されたセルで表わされ、各セルの位置は座標 (x,y) で表されます。左上を (1,1) とし、x 座標は右に行くにつれて大きくなり、y 座標は下に深くなるにつれて大きくなるものとします。あなたは y 座標の一番小さいセルのうち一つを選んでそこから掘り始め、y 座標の一番大きいセルの一つまで掘り進めます。地層には以下の 2 種類のセルがあります：
土の詰まったセル。掘るのに、セルごとに決められた費用がかかる。
酸素のたまったセル。掘る必要はなく、セルごとに決まった量の酸素を補給できる。一度酸素を補給したセルの酸素はなくなり、再度の補給はできない。また、このセルに辿りついたら必ず酸素の補給をしなければならない。
あるセルから掘ることができるのは左右と下方向のセルのみです。
一度掘ったセルを左右に移動することはできますが、上に移動することはできません。
発掘にあたっては、酸素ボンベを携帯しなければなりません。酸素ボンベの残量が 0 になった瞬間、移動も発掘も酸素の補給もできなくなります。残量はセルを移動するたびに 1 減ります。酸素ボンベの残量が 0 で埋蔵金の埋まっている深さまで到達しても、到達したとみなされません。また、酸素のたまったセルでは酸素を補給することができますが、容量を超えた分は廃棄されます。
地層のサイズ 、発掘費用、酸素ボンベの容量、初期状態で持っている酸素の量、地層の情報を入力とし、一番深いセルまでたどりつくための最小費用を出力するプログラムを作成してください。ただし、最小費用が発掘費用を超えてしまう場合や、どのように掘り進めても埋蔵金にたどりつけない場合は“NA”と出力してください。
Input
複数のデータセットの並びが入力として与えられる。入力の終わりはゼロふたつの行で示される。
各データセットは以下の形式で与えられる。
W
H
f
m
o
c
1,1
c
2,1
...
c
W,1
c
1,2
c
2,2
...
c
W,2
...
c
1,H
c
2,H
...
c
W,H
１行目に地層の横方向のサイズ
W
, 縦方向のサイズ
H
(3 ≤
W
,
H
≤ 10) が与えられる。 ２行目にあなたの発掘費用を表す整数
f
(1 ≤
f
≤ 10000)、酸素ボンベの容量を表す整数
m
(3 ≤
m
≤ 50)、初期状態で持っている酸素の量を表す整数
o
(o ≤
m
) が与えられる。
続く
H
行に地層の情報
c
i,j
が与えられる。
c
i,j
は、座標 (
i
,
j
) に対するセルの情報を表し、以下の形式で与えられる：
負の値の場合、土の詰まったセルで、値は費用を表す
正の値の場合、酸素のたまったセルで、値は酸素の量を表す
ただし、酸素のたまったセルは 50 箇所以内である。
データセットの数は50 を超えない。
Output
データセットごとに、最少費用または NA を1行に出力する。
Sample Input
3 3
100 10 10
-100 -20 -100
-100 -20 -100
-100 -20 -100
3 3
100 10 10
-100 -20 -100
-100 -20 -20
-100 -60 -20
3 3
100 10 3
-100 -20 -100
-20 -20 -20
-20 -100 -20
3 3
100 3 3
-100 -20 -30
-100 -20 2
-100 -20 -20
4 5
1500 5 4
-10 -380 -250 -250
-90 2 -80 8
-250 -130 -330 -120
-120 -40 -50 -20
-250 -10 -20 -150
0 0
Output for the Sample Input
60
80
NA
50
390",C,"#include <stdio.h>
#include <string.h>
#include <limits.h>

#define MAX_W 10
#define MAX_H 10
#define MAX_O 50

int W, H, f, m, o;
int grid[MAX_W + 1][MAX_H + 1];
int visited[MAX_W + 1][MAX_H + 1][MAX_O + 1];
int cost[MAX_W + 1][MAX_H + 1][MAX_O + 1];

typedef struct {
    int x, y, oxygen, c;
} State;

State queue[1000000];
int front, rear;

void enqueue(int x, int y, int oxygen, int c) {
    queue[rear].x = x;
    queue[rear].y = y;
    queue[rear].oxygen = oxygen;
    queue[rear].c = c;
    rear++;
}

State dequeue() {
    return queue[front++];
}

int main() {
    while (1) {
        scanf(""%d %d"", &W, &H);
        if (W == 0 && H == 0) break;
        
        scanf(""%d %d %d"", &f, &m, &o);
        
        for (int j = 1; j <= H; j++) {
            for (int i = 1; i <= W; i++) {
                scanf(""%d"", &grid[i][j]);
            }
        }
        
        memset(visited, 0, sizeof(visited));
        for (int i = 0; i <= W; i++) {
            for (int j = 0; j <= H; j++) {
                for (int k = 0; k <= m; k++) {
                    cost[i][j][k] = INT_MAX;
                }
            }
        }
        
        front = 0;
        rear = 0;
        
        for (int i = 1; i <= W; i++) {
            if (grid[i][1] > 0) {
                int new_o = o - 1 + grid[i][1];
                if (new_o > m) new_o = m;
                if (new_o > 0) {
                    enqueue(i, 1, new_o, 0);
                    cost[i][1][new_o] = 0;
                }
            } else {
                int dig_cost = -grid[i][1];
                if (o > 1) {
                    enqueue(i, 1, o - 1, dig_cost);
                    cost[i][1][o - 1] = dig_cost;
                }
            }
        }
        
        int min_cost = INT_MAX;
        
        while (front < rear) {
            State s = dequeue();
            int x = s.x;
            int y = s.y;
            int oxy = s.oxygen;
            int c = s.c;
            
            if (visited[x][y][oxy]) continue;
            visited[x][y][oxy] = 1;
            
            if (y == H) {
                if (c < min_cost) {
                    min_cost = c;
                }
                continue;
            }
            
            int dx[] = {-1, 1, 0};
            int dy[] = {0, 0, 1};
            
            for (int d = 0; d < 3; d++) {
                int nx = x + dx[d];
                int ny = y + dy[d];
                
                if (nx < 1 || nx > W || ny < 1 || ny > H) continue;
                
                if (grid[nx][ny] > 0) {
                    int new_oxy = oxy - 1 + grid[nx][ny];
                    if (new_oxy > m) new_oxy = m;
                    if (new_oxy > 0 && !visited[nx][ny][new_oxy]) {
                        if (cost[nx][ny][new_oxy] > c) {
                            cost[nx][ny][new_oxy] = c;
                            enqueue(nx, ny, new_oxy, c);
                        }
                    }
                } else {
                    int dig_cost = -grid[nx][ny];
                    int new_cost = c + dig_cost;
                    int new_oxy = oxy - 1;
                    if (new_oxy > 0 && !visited[nx][ny][new_oxy]) {
                        if (cost[nx][ny][new_oxy] > new_cost) {
                            cost[nx][ny][new_oxy] = new_cost;
                            enqueue(nx, ny, new_oxy, new_cost);
                        }
                    }
                }
            }
        }
        
        if (min_cost == INT_MAX || min_cost > f) {
            printf(""NA\n"");
        } else {
            printf(""%d\n"", min_cost);
        }
    }
    
    return 0;
}
",0
p00234,"会津の埋蔵金
会津には古くから伝わる埋蔵金の伝説があります。あなたは、遂に埋蔵金が埋まっている場所を突き止めました。埋蔵金が埋まっている深さ、掘り進める地層の状態が分かっているので、綿密に計画を立てれば最小費用で埋蔵金まで到達することができます。そこであなたは、地層の状態を読み取って埋蔵金の埋まっている深さまで最小費用で到達するルートを算出するプログラムを作成することにしました。
地層の状態は 2 次元格子状に配置されたセルで表わされ、各セルの位置は座標 (x,y) で表されます。左上を (1,1) とし、x 座標は右に行くにつれて大きくなり、y 座標は下に深くなるにつれて大きくなるものとします。あなたは y 座標の一番小さいセルのうち一つを選んでそこから掘り始め、y 座標の一番大きいセルの一つまで掘り進めます。地層には以下の 2 種類のセルがあります：
土の詰まったセル。掘るのに、セルごとに決められた費用がかかる。
酸素のたまったセル。掘る必要はなく、セルごとに決まった量の酸素を補給できる。一度酸素を補給したセルの酸素はなくなり、再度の補給はできない。また、このセルに辿りついたら必ず酸素の補給をしなければならない。
あるセルから掘ることができるのは左右と下方向のセルのみです。
一度掘ったセルを左右に移動することはできますが、上に移動することはできません。
発掘にあたっては、酸素ボンベを携帯しなければなりません。酸素ボンベの残量が 0 になった瞬間、移動も発掘も酸素の補給もできなくなります。残量はセルを移動するたびに 1 減ります。酸素ボンベの残量が 0 で埋蔵金の埋まっている深さまで到達しても、到達したとみなされません。また、酸素のたまったセルでは酸素を補給することができますが、容量を超えた分は廃棄されます。
地層のサイズ 、発掘費用、酸素ボンベの容量、初期状態で持っている酸素の量、地層の情報を入力とし、一番深いセルまでたどりつくための最小費用を出力するプログラムを作成してください。ただし、最小費用が発掘費用を超えてしまう場合や、どのように掘り進めても埋蔵金にたどりつけない場合は“NA”と出力してください。
Input
複数のデータセットの並びが入力として与えられる。入力の終わりはゼロふたつの行で示される。
各データセットは以下の形式で与えられる。
W
H
f
m
o
c
1,1
c
2,1
...
c
W,1
c
1,2
c
2,2
...
c
W,2
...
c
1,H
c
2,H
...
c
W,H
１行目に地層の横方向のサイズ
W
, 縦方向のサイズ
H
(3 ≤
W
,
H
≤ 10) が与えられる。 ２行目にあなたの発掘費用を表す整数
f
(1 ≤
f
≤ 10000)、酸素ボンベの容量を表す整数
m
(3 ≤
m
≤ 50)、初期状態で持っている酸素の量を表す整数
o
(o ≤
m
) が与えられる。
続く
H
行に地層の情報
c
i,j
が与えられる。
c
i,j
は、座標 (
i
,
j
) に対するセルの情報を表し、以下の形式で与えられる：
負の値の場合、土の詰まったセルで、値は費用を表す
正の値の場合、酸素のたまったセルで、値は酸素の量を表す
ただし、酸素のたまったセルは 50 箇所以内である。
データセットの数は50 を超えない。
Output
データセットごとに、最少費用または NA を1行に出力する。
Sample Input
3 3
100 10 10
-100 -20 -100
-100 -20 -100
-100 -20 -100
3 3
100 10 10
-100 -20 -100
-100 -20 -20
-100 -60 -20
3 3
100 10 3
-100 -20 -100
-20 -20 -20
-20 -100 -20
3 3
100 3 3
-100 -20 -30
-100 -20 2
-100 -20 -20
4 5
1500 5 4
-10 -380 -250 -250
-90 2 -80 8
-250 -130 -330 -120
-120 -40 -50 -20
-250 -10 -20 -150
0 0
Output for the Sample Input
60
80
NA
50
390",C,"W,H,m,c[10][10];
DP[10][10][10][10][51];//cà[yÀW][xÀW][¶[][E[][_fcÊ]
#define Update(d,v) ((v)>(d)?d=(v):0)
CalcO(o,x,y){//_fcÊÌvZ
	if(c[x][y]>0){
		o+=c[x][y];
		if(o>m)
			o=m;
	}
	return o;
}
CalcF(f,x,y){//càÌvZ
	if(c[x][y]<0)
		f+=c[x][y];
	return f;
}
main(){
	int x,y,range,d,dx,f,o,xl,xr,fn,on,f0;
	for(;scanf(""%d%d%d%d%d"",&W,&H,&f0,&m,&o),W;){
		for(y=0;y<H;y++)
			for(x=0;x<W;x++)
				scanf(""%d"",&c[x][y]);
		f0++;//cà0ÅàDPÍ1ÆµÄANAÉÈéÌðh®
		for(y=0,x=0;x<W;x++)
			DP[y][x][x][x][CalcO(o-1,x,y)]=CalcF(f0,x,y);
		for(y=0;y<H-1;y++){
			for(range=0;range<W;range++){//¶EÉ@éL³
				for(d=0;d<2;d++){//»ÝÊuxð³¹é
					for(xl=0;xl<W-range;xl++){//¶[
						for(dx=0;dx<=range;dx++){//xÏÊ
							xr=xl+range;
							x=d?xr-dx:xl+dx;
							//printf(""range=%d, d=%d, xl=%d, dx=%d, xr=%d, x=%d\n"",range,d,xl,dx,xr,x);
							for(o=m;o>0;o--){
								if(f=DP[y][x][xl][xr][o]){
									if(x>0){
										if(x==xl){//¶Ö@é
											fn=CalcF(f,x-1,y);
											on=CalcO(o-1,x-1,y);
											Update(DP[y][x-1][x-1][xr][on],fn);
										}else{//¶ÖiÞ
											Update(DP[y][x-1][xl][xr][o-1],f);
										}
									}
									if(x<W-1){
										if(x==xr){//EÖ@é
											fn=CalcF(f,x+1,y);
											on=CalcO(o-1,x+1,y);
											Update(DP[y][x+1][xl][x+1][on],fn);
										}else{//EÖiÞ
											Update(DP[y][x+1][xl][xr][o-1],f);
										}
									}
									//ºÖ@é
									fn=CalcF(f,x,y+1);
									on=CalcO(o-1,x,y+1);
									Update(DP[y+1][x][x][x][on],fn);
									//break;
								}
							}//o
						}//dx
					}//xl
				}//d
			}//range
		}//y
#if 0
		for(y=0;y<H;y++){
			for(x=0;x<W;x++){
				for(o=m;o>0;o--){
					if(f=DP[y][x][x][x][o]){
						printf(""%4d "",f-1);
						break;
					}
				}
				if(o==0)
					printf(""---- "");
			}
			puts("""");
		}
#endif
		fn=0;
		for(x=0;x<W;x++){
			for(o=m;o>0;o--){
				f=DP[H-1][x][x][x][o];
				if(f>fn)
					fn=f;
			}
		}
		printf(fn?""%d\n"":""NA\n"",f0-fn);
		memset(DP,0,sizeof(DP));
	}
	puts("""");
	exit(0);
}",1
p00234,"会津の埋蔵金
会津には古くから伝わる埋蔵金の伝説があります。あなたは、遂に埋蔵金が埋まっている場所を突き止めました。埋蔵金が埋まっている深さ、掘り進める地層の状態が分かっているので、綿密に計画を立てれば最小費用で埋蔵金まで到達することができます。そこであなたは、地層の状態を読み取って埋蔵金の埋まっている深さまで最小費用で到達するルートを算出するプログラムを作成することにしました。
地層の状態は 2 次元格子状に配置されたセルで表わされ、各セルの位置は座標 (x,y) で表されます。左上を (1,1) とし、x 座標は右に行くにつれて大きくなり、y 座標は下に深くなるにつれて大きくなるものとします。あなたは y 座標の一番小さいセルのうち一つを選んでそこから掘り始め、y 座標の一番大きいセルの一つまで掘り進めます。地層には以下の 2 種類のセルがあります：
土の詰まったセル。掘るのに、セルごとに決められた費用がかかる。
酸素のたまったセル。掘る必要はなく、セルごとに決まった量の酸素を補給できる。一度酸素を補給したセルの酸素はなくなり、再度の補給はできない。また、このセルに辿りついたら必ず酸素の補給をしなければならない。
あるセルから掘ることができるのは左右と下方向のセルのみです。
一度掘ったセルを左右に移動することはできますが、上に移動することはできません。
発掘にあたっては、酸素ボンベを携帯しなければなりません。酸素ボンベの残量が 0 になった瞬間、移動も発掘も酸素の補給もできなくなります。残量はセルを移動するたびに 1 減ります。酸素ボンベの残量が 0 で埋蔵金の埋まっている深さまで到達しても、到達したとみなされません。また、酸素のたまったセルでは酸素を補給することができますが、容量を超えた分は廃棄されます。
地層のサイズ 、発掘費用、酸素ボンベの容量、初期状態で持っている酸素の量、地層の情報を入力とし、一番深いセルまでたどりつくための最小費用を出力するプログラムを作成してください。ただし、最小費用が発掘費用を超えてしまう場合や、どのように掘り進めても埋蔵金にたどりつけない場合は“NA”と出力してください。
Input
複数のデータセットの並びが入力として与えられる。入力の終わりはゼロふたつの行で示される。
各データセットは以下の形式で与えられる。
W
H
f
m
o
c
1,1
c
2,1
...
c
W,1
c
1,2
c
2,2
...
c
W,2
...
c
1,H
c
2,H
...
c
W,H
１行目に地層の横方向のサイズ
W
, 縦方向のサイズ
H
(3 ≤
W
,
H
≤ 10) が与えられる。 ２行目にあなたの発掘費用を表す整数
f
(1 ≤
f
≤ 10000)、酸素ボンベの容量を表す整数
m
(3 ≤
m
≤ 50)、初期状態で持っている酸素の量を表す整数
o
(o ≤
m
) が与えられる。
続く
H
行に地層の情報
c
i,j
が与えられる。
c
i,j
は、座標 (
i
,
j
) に対するセルの情報を表し、以下の形式で与えられる：
負の値の場合、土の詰まったセルで、値は費用を表す
正の値の場合、酸素のたまったセルで、値は酸素の量を表す
ただし、酸素のたまったセルは 50 箇所以内である。
データセットの数は50 を超えない。
Output
データセットごとに、最少費用または NA を1行に出力する。
Sample Input
3 3
100 10 10
-100 -20 -100
-100 -20 -100
-100 -20 -100
3 3
100 10 10
-100 -20 -100
-100 -20 -20
-100 -60 -20
3 3
100 10 3
-100 -20 -100
-20 -20 -20
-20 -100 -20
3 3
100 3 3
-100 -20 -30
-100 -20 2
-100 -20 -20
4 5
1500 5 4
-10 -380 -250 -250
-90 2 -80 8
-250 -130 -330 -120
-120 -40 -50 -20
-250 -10 -20 -150
0 0
Output for the Sample Input
60
80
NA
50
390",Java,"import java.util.*;
import java.io.*;

public class Main {
    static class State implements Comparable<State> {
        int x, y, oxygen, cost;
        
        State(int x, int y, int oxygen, int cost) {
            this.x = x;
            this.y = y;
            this.oxygen = oxygen;
            this.cost = cost;
        }
        
        @Override
        public int compareTo(State other) {
            return Integer.compare(this.cost, other.cost);
        }
    }
    
    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        String line;
        
        while ((line = br.readLine()) != null) {
            String[] parts = line.trim().split(""\\s+"");
            int W = Integer.parseInt(parts[0]);
            int H = Integer.parseInt(parts[1]);
            
            if (W == 0 && H == 0) break;
            
            parts = br.readLine().trim().split(""\\s+"");
            int f = Integer.parseInt(parts[0]);
            int m = Integer.parseInt(parts[1]);
            int o = Integer.parseInt(parts[2]);
            
            int[][] grid = new int[H][W];
            for (int j = 0; j < H; j++) {
                parts = br.readLine().trim().split(""\\s+"");
                for (int i = 0; i < W; i++) {
                    grid[j][i] = Integer.parseInt(parts[i]);
                }
            }
            
            int result = solve(W, H, f, m, o, grid);
            if (result == -1) {
                System.out.println(""NA"");
            } else {
                System.out.println(result);
            }
        }
    }
    
    static int solve(int W, int H, int f, int m, int o, int[][] grid) {
        int[][][] dist = new int[H][W][m + 1];
        for (int i = 0; i < H; i++) {
            for (int j = 0; j < W; j++) {
                Arrays.fill(dist[i][j], Integer.MAX_VALUE);
            }
        }
        
        PriorityQueue<State> pq = new PriorityQueue<>();
        
        // Start from any cell in the first row
        for (int x = 0; x < W; x++) {
            int cost = 0;
            int oxygen = o;
            
            if (grid[0][x] < 0) {
                cost = -grid[0][x];
            } else {
                oxygen = Math.min(m, oxygen + grid[0][x]);
            }
            
            if (cost <= f && oxygen > 0) {
                pq.offer(new State(x, 0, oxygen, cost));
                dist[0][x][oxygen] = cost;
            }
        }
        
        int[] dx = {-1, 1, 0};
        int[] dy = {0, 0, 1};
        
        int minCost = Integer.MAX_VALUE;
        
        while (!pq.isEmpty()) {
            State curr = pq.poll();
            
            if (curr.y == H - 1) {
                minCost = Math.min(minCost, curr.cost);
                continue;
            }
            
            if (curr.cost > dist[curr.y][curr.x][curr.oxygen]) {
                continue;
            }
            
            for (int d = 0; d < 3; d++) {
                int nx = curr.x + dx[d];
                int ny = curr.y + dy[d];
                
                if (nx < 0 || nx >= W || ny < 0 || ny >= H) continue;
                
                int newOxygen = curr.oxygen - 1;
                if (newOxygen <= 0) continue;
                
                int newCost = curr.cost;
                
                if (grid[ny][nx] < 0) {
                    newCost += -grid[ny][nx];
                } else {
                    newOxygen = Math.min(m, newOxygen + grid[ny][nx]);
                }
                
                if (newCost > f) continue;
                
                if (newCost < dist[ny][nx][newOxygen]) {
                    dist[ny][nx][newOxygen] = newCost;
                    pq.offer(new State(nx, ny, newOxygen, newCost));
                }
            }
        }
        
        return minCost == Integer.MAX_VALUE ? -1 : minCost;
    }
}
",0
p00234,"会津の埋蔵金
会津には古くから伝わる埋蔵金の伝説があります。あなたは、遂に埋蔵金が埋まっている場所を突き止めました。埋蔵金が埋まっている深さ、掘り進める地層の状態が分かっているので、綿密に計画を立てれば最小費用で埋蔵金まで到達することができます。そこであなたは、地層の状態を読み取って埋蔵金の埋まっている深さまで最小費用で到達するルートを算出するプログラムを作成することにしました。
地層の状態は 2 次元格子状に配置されたセルで表わされ、各セルの位置は座標 (x,y) で表されます。左上を (1,1) とし、x 座標は右に行くにつれて大きくなり、y 座標は下に深くなるにつれて大きくなるものとします。あなたは y 座標の一番小さいセルのうち一つを選んでそこから掘り始め、y 座標の一番大きいセルの一つまで掘り進めます。地層には以下の 2 種類のセルがあります：
土の詰まったセル。掘るのに、セルごとに決められた費用がかかる。
酸素のたまったセル。掘る必要はなく、セルごとに決まった量の酸素を補給できる。一度酸素を補給したセルの酸素はなくなり、再度の補給はできない。また、このセルに辿りついたら必ず酸素の補給をしなければならない。
あるセルから掘ることができるのは左右と下方向のセルのみです。
一度掘ったセルを左右に移動することはできますが、上に移動することはできません。
発掘にあたっては、酸素ボンベを携帯しなければなりません。酸素ボンベの残量が 0 になった瞬間、移動も発掘も酸素の補給もできなくなります。残量はセルを移動するたびに 1 減ります。酸素ボンベの残量が 0 で埋蔵金の埋まっている深さまで到達しても、到達したとみなされません。また、酸素のたまったセルでは酸素を補給することができますが、容量を超えた分は廃棄されます。
地層のサイズ 、発掘費用、酸素ボンベの容量、初期状態で持っている酸素の量、地層の情報を入力とし、一番深いセルまでたどりつくための最小費用を出力するプログラムを作成してください。ただし、最小費用が発掘費用を超えてしまう場合や、どのように掘り進めても埋蔵金にたどりつけない場合は“NA”と出力してください。
Input
複数のデータセットの並びが入力として与えられる。入力の終わりはゼロふたつの行で示される。
各データセットは以下の形式で与えられる。
W
H
f
m
o
c
1,1
c
2,1
...
c
W,1
c
1,2
c
2,2
...
c
W,2
...
c
1,H
c
2,H
...
c
W,H
１行目に地層の横方向のサイズ
W
, 縦方向のサイズ
H
(3 ≤
W
,
H
≤ 10) が与えられる。 ２行目にあなたの発掘費用を表す整数
f
(1 ≤
f
≤ 10000)、酸素ボンベの容量を表す整数
m
(3 ≤
m
≤ 50)、初期状態で持っている酸素の量を表す整数
o
(o ≤
m
) が与えられる。
続く
H
行に地層の情報
c
i,j
が与えられる。
c
i,j
は、座標 (
i
,
j
) に対するセルの情報を表し、以下の形式で与えられる：
負の値の場合、土の詰まったセルで、値は費用を表す
正の値の場合、酸素のたまったセルで、値は酸素の量を表す
ただし、酸素のたまったセルは 50 箇所以内である。
データセットの数は50 を超えない。
Output
データセットごとに、最少費用または NA を1行に出力する。
Sample Input
3 3
100 10 10
-100 -20 -100
-100 -20 -100
-100 -20 -100
3 3
100 10 10
-100 -20 -100
-100 -20 -20
-100 -60 -20
3 3
100 10 3
-100 -20 -100
-20 -20 -20
-20 -100 -20
3 3
100 3 3
-100 -20 -30
-100 -20 2
-100 -20 -20
4 5
1500 5 4
-10 -380 -250 -250
-90 2 -80 8
-250 -130 -330 -120
-120 -40 -50 -20
-250 -10 -20 -150
0 0
Output for the Sample Input
60
80
NA
50
390",Java,"import java.util.*;
import java.math.*;
import java.awt.geom.*;
import java.io.*;
   
   
public class Main {
	static int INF = 2 << 28;
	public static void main(String[] args) {
		Scanner sc = new Scanner(System.in);
		while(true) {
			int w = sc.nextInt();
			int h = sc.nextInt();
			if(w == 0 && h == 0) break;
			int f = sc.nextInt();
			int m = sc.nextInt();
			int o = sc.nextInt();
			
			int[][] map = new int[h][w];
			for(int i = 0; i < h; i++) {
				for(int j = 0; j < w; j++) {
					map[i][j] = sc.nextInt();
				}
			}
			
			int[][][] memo = new int[h][w][m+1];
			for(int i = 0; i < h; i++) {
				for(int j = 0; j < w; j++) {
					Arrays.fill(memo[i][j], INF);
				}
			}
			PriorityQueue<Data> queue = new PriorityQueue<Data>();
			for(int i = 0; i < w; i++) {
				boolean[] tmp = new boolean[w];
				if(map[0][i] > 0) {
					queue.add(new Data(0,i,0,Math.min(m, o - 1 + map[0][i]),tmp));
				}
				else  {
					queue.add(new Data(0,i,-map[0][i],o - 1,tmp));
				}
			}
			
			int ans = -1;
			while(!queue.isEmpty()) {
				Data tmp = queue.poll();
				
				if(tmp.o <= 0) continue;
				tmp.al[tmp.x] = true;
				
				if(tmp.y == h-1) {
					ans = tmp.c;
					queue.clear();
					break;
				}
				
				if(tmp.c >= memo[tmp.y][tmp.x][tmp.o]) continue;
				memo[tmp.y][tmp.x][tmp.o] = tmp.c;
				
				if(tmp.x != w-1) {
					if(tmp.al[tmp.x+1]) {
						    queue.add(new Data(tmp.y,tmp.x+1,tmp.c,tmp.o-1,Arrays.copyOf(tmp.al,tmp.al.length)));
					}
					else {
						if(map[tmp.y][tmp.x+1] > 0 && tmp.o != 1) {
							queue.add(new Data(tmp.y,tmp.x+1,tmp.c,Math.min(m, tmp.o - 1 + map[tmp.y][tmp.x+1]),Arrays.copyOf(tmp.al,tmp.al.length)));
						}
						else if(map[tmp.y][tmp.x+1] < 0){
							queue.add(new Data(tmp.y,tmp.x+1,tmp.c - map[tmp.y][tmp.x+1],tmp.o-1,Arrays.copyOf(tmp.al,tmp.al.length)));
						}
					}
				}
				if(tmp.x != 0) {
					if(tmp.al[tmp.x-1]) {
						queue.add(new Data(tmp.y,tmp.x-1,tmp.c,tmp.o-1,Arrays.copyOf(tmp.al,tmp.al.length)));
					}
					else {
						if(map[tmp.y][tmp.x-1] > 0 && tmp.o != 1) {
							queue.add(new Data(tmp.y,tmp.x-1,tmp.c,Math.min(m, tmp.o - 1 + map[tmp.y][tmp.x-1]),Arrays.copyOf(tmp.al,tmp.al.length)));
						}
						else if(map[tmp.y][tmp.x-1] < 0){
							queue.add(new Data(tmp.y,tmp.x-1,tmp.c - map[tmp.y][tmp.x-1],tmp.o-1,Arrays.copyOf(tmp.al,tmp.al.length)));
						}
					}
				}
				if(tmp.y != h-1) {
					if(map[tmp.y+1][tmp.x] > 0 && tmp.o != 1) {
						queue.add(new Data(tmp.y+1,tmp.x,tmp.c,Math.min(m, tmp.o - 1 + map[tmp.y+1][tmp.x]),new boolean[w]));
					}
					else if(map[tmp.y+1][tmp.x] < 0){
						queue.add(new Data(tmp.y+1,tmp.x,tmp.c - map[tmp.y+1][tmp.x],tmp.o-1,new boolean[w]));
					}
				}
				
			}
			
			if(ans == -1 || ans >= f) {
				System.out.println(""NA"");
			}
			else {
				System.out.println(ans);
			}
		}
		
		
		
		
		
		
		
		
	}
	static class Data implements Comparable<Data> {
		int y;
		int x;
		int c;
		int o;
		boolean[] al;
		
		Data(int y, int x, int c, int o, boolean[] al) {
			this.y = y;
			this.x = x;
			this.c = c;
			this.o = o;
			this.al = al;
		}

		@Override
		public int compareTo(Data o) {
			return this.c - o.c;
		}
		
	}
	
	
	
}",1
p00234,"会津の埋蔵金
会津には古くから伝わる埋蔵金の伝説があります。あなたは、遂に埋蔵金が埋まっている場所を突き止めました。埋蔵金が埋まっている深さ、掘り進める地層の状態が分かっているので、綿密に計画を立てれば最小費用で埋蔵金まで到達することができます。そこであなたは、地層の状態を読み取って埋蔵金の埋まっている深さまで最小費用で到達するルートを算出するプログラムを作成することにしました。
地層の状態は 2 次元格子状に配置されたセルで表わされ、各セルの位置は座標 (x,y) で表されます。左上を (1,1) とし、x 座標は右に行くにつれて大きくなり、y 座標は下に深くなるにつれて大きくなるものとします。あなたは y 座標の一番小さいセルのうち一つを選んでそこから掘り始め、y 座標の一番大きいセルの一つまで掘り進めます。地層には以下の 2 種類のセルがあります：
土の詰まったセル。掘るのに、セルごとに決められた費用がかかる。
酸素のたまったセル。掘る必要はなく、セルごとに決まった量の酸素を補給できる。一度酸素を補給したセルの酸素はなくなり、再度の補給はできない。また、このセルに辿りついたら必ず酸素の補給をしなければならない。
あるセルから掘ることができるのは左右と下方向のセルのみです。
一度掘ったセルを左右に移動することはできますが、上に移動することはできません。
発掘にあたっては、酸素ボンベを携帯しなければなりません。酸素ボンベの残量が 0 になった瞬間、移動も発掘も酸素の補給もできなくなります。残量はセルを移動するたびに 1 減ります。酸素ボンベの残量が 0 で埋蔵金の埋まっている深さまで到達しても、到達したとみなされません。また、酸素のたまったセルでは酸素を補給することができますが、容量を超えた分は廃棄されます。
地層のサイズ 、発掘費用、酸素ボンベの容量、初期状態で持っている酸素の量、地層の情報を入力とし、一番深いセルまでたどりつくための最小費用を出力するプログラムを作成してください。ただし、最小費用が発掘費用を超えてしまう場合や、どのように掘り進めても埋蔵金にたどりつけない場合は“NA”と出力してください。
Input
複数のデータセットの並びが入力として与えられる。入力の終わりはゼロふたつの行で示される。
各データセットは以下の形式で与えられる。
W
H
f
m
o
c
1,1
c
2,1
...
c
W,1
c
1,2
c
2,2
...
c
W,2
...
c
1,H
c
2,H
...
c
W,H
１行目に地層の横方向のサイズ
W
, 縦方向のサイズ
H
(3 ≤
W
,
H
≤ 10) が与えられる。 ２行目にあなたの発掘費用を表す整数
f
(1 ≤
f
≤ 10000)、酸素ボンベの容量を表す整数
m
(3 ≤
m
≤ 50)、初期状態で持っている酸素の量を表す整数
o
(o ≤
m
) が与えられる。
続く
H
行に地層の情報
c
i,j
が与えられる。
c
i,j
は、座標 (
i
,
j
) に対するセルの情報を表し、以下の形式で与えられる：
負の値の場合、土の詰まったセルで、値は費用を表す
正の値の場合、酸素のたまったセルで、値は酸素の量を表す
ただし、酸素のたまったセルは 50 箇所以内である。
データセットの数は50 を超えない。
Output
データセットごとに、最少費用または NA を1行に出力する。
Sample Input
3 3
100 10 10
-100 -20 -100
-100 -20 -100
-100 -20 -100
3 3
100 10 10
-100 -20 -100
-100 -20 -20
-100 -60 -20
3 3
100 10 3
-100 -20 -100
-20 -20 -20
-20 -100 -20
3 3
100 3 3
-100 -20 -30
-100 -20 2
-100 -20 -20
4 5
1500 5 4
-10 -380 -250 -250
-90 2 -80 8
-250 -130 -330 -120
-120 -40 -50 -20
-250 -10 -20 -150
0 0
Output for the Sample Input
60
80
NA
50
390",Python,"import heapq
from collections import defaultdict

def solve(W, H, f, m, o, grid):
    # State: (x, y, oxygen, used_oxygen_cells)
    # used_oxygen_cells is a frozenset of (x, y) tuples
    
    # Priority queue: (cost, x, y, oxygen, used_oxygen_cells)
    pq = []
    
    # Start from any cell in the first row (y=0)
    for x in range(W):
        cell_value = grid[0][x]
        if cell_value < 0:  #土
            cost = -cell_value
            new_oxygen = o - 1
            if new_oxygen >= 0 and cost <= f:
                heapq.heappush(pq, (cost, x, 0, new_oxygen, frozenset()))
        else:  # 酸素
            new_oxygen = min(m, o + cell_value) - 1
            if new_oxygen >= 0:
                heapq.heappush(pq, (0, x, 0, new_oxygen, frozenset([(x, 0)])))
    
    # Best cost for each state (x, y, oxygen, used_oxygen_cells)
    visited = {}
    
    while pq:
        cost, x, y, oxygen, used = heapq.heappop(pq)
        
        # Check if we reached the bottom
        if y == H - 1 and oxygen > 0:
            return cost
        
        # Skip if we've seen this state with better or equal cost
        state = (x, y, oxygen, used)
        if state in visited:
            continue
        visited[state] = cost
        
        # Try moving to adjacent cells: left, right, down
        directions = []
        if x > 0:
            directions.append((x - 1, y))
        if x < W - 1:
            directions.append((x + 1, y))
        if y < H - 1:
            directions.append((x, y + 1))
        
        for nx, ny in directions:
            cell_value = grid[ny][nx]
            
            if cell_value < 0:  # 土
                dig_cost = -cell_value
                new_cost = cost + dig_cost
                new_oxygen = oxygen - 1
                
                if new_oxygen >= 0 and new_cost <= f:
                    new_state = (nx, ny, new_oxygen, used)
                    if new_state not in visited:
                        heapq.heappush(pq, (new_cost, nx, ny, new_oxygen, used))
            else:  # 酸素
                if (nx, ny) in used:
                    # Already used this oxygen cell
                    new_oxygen = oxygen - 1
                    if new_oxygen >= 0:
                        new_state = (nx, ny, new_oxygen, used)
                        if new_state not in visited:
                            heapq.heappush(pq, (cost, nx, ny, new_oxygen, used))
                else:
                    # Use oxygen from this cell
                    new_oxygen = min(m, oxygen + cell_value) - 1
                    if new_oxygen >= 0:
                        new_used = used | frozenset([(nx, ny)])
                        new_state = (nx, ny, new_oxygen, new_used)
                        if new_state not in visited:
                            heapq.heappush(pq, (cost, nx, ny, new_oxygen, new_used))
    
    return None

while True:
    line = input().split()
    W, H = int(line[0]), int(line[1])
    if W == 0 and H == 0:
        break
    
    line = input().split()
    f, m, o = int(line[0]), int(line[1]), int(line[2])
    
    grid = []
    for _ in range(H):
        row = list(map(int, input().split()))
        grid.append(row)
    
    result = solve(W, H, f, m, o, grid)
    if result is None:
        print(""NA"")
    else:
        print(result)
",0
p00234,"会津の埋蔵金
会津には古くから伝わる埋蔵金の伝説があります。あなたは、遂に埋蔵金が埋まっている場所を突き止めました。埋蔵金が埋まっている深さ、掘り進める地層の状態が分かっているので、綿密に計画を立てれば最小費用で埋蔵金まで到達することができます。そこであなたは、地層の状態を読み取って埋蔵金の埋まっている深さまで最小費用で到達するルートを算出するプログラムを作成することにしました。
地層の状態は 2 次元格子状に配置されたセルで表わされ、各セルの位置は座標 (x,y) で表されます。左上を (1,1) とし、x 座標は右に行くにつれて大きくなり、y 座標は下に深くなるにつれて大きくなるものとします。あなたは y 座標の一番小さいセルのうち一つを選んでそこから掘り始め、y 座標の一番大きいセルの一つまで掘り進めます。地層には以下の 2 種類のセルがあります：
土の詰まったセル。掘るのに、セルごとに決められた費用がかかる。
酸素のたまったセル。掘る必要はなく、セルごとに決まった量の酸素を補給できる。一度酸素を補給したセルの酸素はなくなり、再度の補給はできない。また、このセルに辿りついたら必ず酸素の補給をしなければならない。
あるセルから掘ることができるのは左右と下方向のセルのみです。
一度掘ったセルを左右に移動することはできますが、上に移動することはできません。
発掘にあたっては、酸素ボンベを携帯しなければなりません。酸素ボンベの残量が 0 になった瞬間、移動も発掘も酸素の補給もできなくなります。残量はセルを移動するたびに 1 減ります。酸素ボンベの残量が 0 で埋蔵金の埋まっている深さまで到達しても、到達したとみなされません。また、酸素のたまったセルでは酸素を補給することができますが、容量を超えた分は廃棄されます。
地層のサイズ 、発掘費用、酸素ボンベの容量、初期状態で持っている酸素の量、地層の情報を入力とし、一番深いセルまでたどりつくための最小費用を出力するプログラムを作成してください。ただし、最小費用が発掘費用を超えてしまう場合や、どのように掘り進めても埋蔵金にたどりつけない場合は“NA”と出力してください。
Input
複数のデータセットの並びが入力として与えられる。入力の終わりはゼロふたつの行で示される。
各データセットは以下の形式で与えられる。
W
H
f
m
o
c
1,1
c
2,1
...
c
W,1
c
1,2
c
2,2
...
c
W,2
...
c
1,H
c
2,H
...
c
W,H
１行目に地層の横方向のサイズ
W
, 縦方向のサイズ
H
(3 ≤
W
,
H
≤ 10) が与えられる。 ２行目にあなたの発掘費用を表す整数
f
(1 ≤
f
≤ 10000)、酸素ボンベの容量を表す整数
m
(3 ≤
m
≤ 50)、初期状態で持っている酸素の量を表す整数
o
(o ≤
m
) が与えられる。
続く
H
行に地層の情報
c
i,j
が与えられる。
c
i,j
は、座標 (
i
,
j
) に対するセルの情報を表し、以下の形式で与えられる：
負の値の場合、土の詰まったセルで、値は費用を表す
正の値の場合、酸素のたまったセルで、値は酸素の量を表す
ただし、酸素のたまったセルは 50 箇所以内である。
データセットの数は50 を超えない。
Output
データセットごとに、最少費用または NA を1行に出力する。
Sample Input
3 3
100 10 10
-100 -20 -100
-100 -20 -100
-100 -20 -100
3 3
100 10 10
-100 -20 -100
-100 -20 -20
-100 -60 -20
3 3
100 10 3
-100 -20 -100
-20 -20 -20
-20 -100 -20
3 3
100 3 3
-100 -20 -30
-100 -20 2
-100 -20 -20
4 5
1500 5 4
-10 -380 -250 -250
-90 2 -80 8
-250 -130 -330 -120
-120 -40 -50 -20
-250 -10 -20 -150
0 0
Output for the Sample Input
60
80
NA
50
390",Python,"INF = 10 ** 20

def update_state(state, newx):
  tmp = list(state)
  tmp[newx] = 1
  return tuple(tmp)

def get_co(x, y):
  dc = do = 0
  score = mp[y][x]
  if score < 0:
    dc = -score
  else:
    do = score
  return dc, do

def minimum_cost(nowx, nowy, state, ox, goal, dic, w, m):
  if (nowx, nowy, state, ox) in dic:
    return dic[(nowx, nowy, state, ox)]
  if nowy == goal:
    return 0
  if ox <= 1:
    return INF
  
  ret = INF
  
  left = right = None
  for i in range(nowx + 1, w):
    if state[i] == 0:
      right = i
      break

  for i in range(nowx - 1, -1, -1):
    if state[i] == 0:
      left = i
      break

  if left != None:
    dc, do = get_co(left, nowy)
    ret = min(ret, minimum_cost(left, nowy, update_state(state, left), min(ox + do - 1, m), goal, dic, w, m) + dc)
    for i in range(left + 1, nowx):
      ret = min(ret, minimum_cost(i, nowy, state, ox - 1, goal, dic, w, m))
  
  if right != None:
    dc, do = get_co(right, nowy)
    ret = min(ret, minimum_cost(right, nowy, update_state(state, right), min(ox + do - 1, m), goal, dic, w, m) + dc)
    for i in range(nowx + 1, right):
      ret = min(ret, minimum_cost(i, nowy, state, ox - 1, goal, dic, w, m))
  
  dc, do = get_co(nowx, nowy + 1)
  ret = min(ret, minimum_cost(nowx, nowy + 1, tuple((1 if i == nowx else 0 for i in range(w))), min(ox + do - 1, m), goal, dic, w, m) + dc)
  dic[(nowx, nowy, state, ox)] = ret
  return ret

while True:
  w, h = map(int, input().split())
  if w == 0:
    break
  f, m, o = map(int, input().split())
  if o <= 1:
    print(""NA"")
    continue
  mp = [list(map(int, input().split())) for _ in range(h)]
  dic = {}
  ans = INF
  for i in range(w):
    dc, do = get_co(i, 0)
    ans = min(ans, minimum_cost(i, 0, tuple(1 if i == j else 0 for j in range(w)), min(o + do - 1, m), h - 1, dic, w, m) + dc)
  if ans > f:
    print(""NA"")
  else:
    print(ans)
",1
