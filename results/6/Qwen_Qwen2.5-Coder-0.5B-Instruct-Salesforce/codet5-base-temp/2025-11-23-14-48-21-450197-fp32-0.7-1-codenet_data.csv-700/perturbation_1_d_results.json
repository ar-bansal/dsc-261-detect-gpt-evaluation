{"name": "perturbation_1_d", "predictions": {"real": [1.9530532658100128, 2.542672574520111, 3.935584306716919, 1.8063891232013702, 0.8045056462287903, 2.517288386821747, 2.3466876745224, 2.551360309123993, 1.8170431852340698, 1.6728371381759644, 2.606503963470459, 4.310113906860352, 1.887808084487915, 2.91604483127594, -0.5001077651977539, 0.30229341983795166, 1.2336077690124512, 0.7676267623901367, 1.569556713104248, 2.60564124584198, 2.8108065128326416, 1.7242659330368042, 1.6522799730300903, 1.969872772693634, 1.9317349791526794, 2.1196815371513367, 3.1627625226974487, 1.6322482824325562, 3.0324325561523438, 3.159448027610779, 2.1296006441116333, 1.7834774255752563, 2.3201829195022583, 2.03171968460083, 2.038745701313019, 2.962290048599243, 0.8604259490966797, 1.948817253112793, 2.960150718688965, 1.50808447599411, 2.151204526424408, 2.648676872253418, 1.7638133764266968, 1.3419758081436157, 3.820613145828247, 1.9790709018707275, 3.754056751728058, 0.0, 2.1160516142845154, 2.2059841752052307, 3.1508989334106445, 2.5487999320030212, 2.478109359741211, 1.8311010599136353, 3.313968062400818, 2.468242645263672, 3.7386560440063477, 2.3226600289344788, 1.811885952949524, 2.3600553274154663, 1.7314311563968658, 2.2384843826293945, 2.2288923263549805, 1.780998170375824, 1.8812472820281982, 1.9272724390029907, 2.151296019554138, 1.7491993308067322, 2.006988286972046, 1.7066453695297241, 1.7505574822425842, 3.143254518508911, 2.105488359928131, 1.386795997619629, 2.331062912940979, 2.890775680541992, 3.7407448291778564, 2.3428839445114136, 1.0315375328063965, 2.04991352558136, 2.0011428594589233, 1.1167898178100586, 1.9249171018600464, 2.908454418182373, 1.7403595447540283, 2.3884506821632385, 2.2242504358291626, 0.9514415264129639, 0.23969531059265137, 3.015338659286499, 1.1987317204475403, 1.4940527081489563, 1.1143090724945068, 0.33931177854537964, 1.858976423740387, 1.8712811768054962, 1.2762719988822937, 1.9603201150894165, 1.4962736666202545, 1.9586801528930664, 0.9662495851516724, 1.8548595905303955, 0.5626463890075684, 2.2118976712226868, 1.7879493236541748, 1.1962753534317017, 1.9727802276611328, 1.9149084091186523, 1.5704560279846191, 2.036137580871582, 3.744737386703491, 1.9653693437576294, 3.0056461691856384, 4.198019027709961, 1.4948354959487915, 1.5004432201385498, 2.607055962085724, 1.9686729311943054, 1.4445675611495972, 1.9448633790016174, 1.9785231351852417, 1.3932180404663086, 3.33345365524292, 1.4482297003269196, 2.4139567017555237, 2.4463606476783752, 1.6739473342895508, 1.6474047899246216, 3.262451171875, 1.6578179597854614, 1.905680775642395, 1.7088234424591064, 1.4286062717437744, 2.2808746695518494, 1.0035068988800049, 2.0174012184143066, 1.8150758743286133, 2.1563210487365723, 1.9612057209014893, 2.102196216583252, 1.5259391069412231, 0.0, 2.325180470943451, 4.531212568283081, 0.0, 0.7575099468231201, 2.1883713006973267, 1.554265558719635, 1.3876261115074158, 2.1234971284866333, 1.33980393409729, 1.5912551283836365, 0.8715958595275879, 1.3520745635032654, 2.113451361656189, 3.9973011016845703, 1.9039640426635742, 3.206205904483795, 3.6532307267189026, 2.1848490834236145, 2.7042747735977173, 1.5092899799346924, 1.3891727924346924, 2.2619773745536804, 0.7885987758636475, 1.6624234318733215, 1.7002254724502563, 2.2403706312179565, 1.0924156308174133, 1.7214149236679077, 2.205703556537628, 1.6543406248092651, 2.024026036262512, 2.2844873666763306, 1.6798516511917114, 1.9122506380081177, 2.984306573867798, 1.1226173639297485, 1.7212625741958618, 1.5485568046569824, 1.845167636871338, 1.4319042563438416, 2.5468459129333496, 1.7125502228736877, 1.8136494755744934, 2.006529450416565, 0.0, 2.1777780055999756, 0.7286608219146729, 2.4247699975967407, 2.3189404010772705, 2.1313278675079346, 1.2298901081085205, 1.5654346346855164, 1.475524365901947, 2.3529653549194336, 1.9692836999893188, 2.6334818601608276, 1.7110940217971802, 1.5767223834991455, 1.0935626029968262, 2.1882002353668213, 1.88470059633255, 3.0587035417556763, 1.1255918741226196, 1.113445520401001, 2.409522294998169, 0.5677453279495239, 2.6945682764053345, 2.45676052570343, 2.1501089930534363, 1.8040447235107422, 1.9052722454071045, 0.0, 2.3236684799194336, 1.0627590417861938, 0.3783224821090698, 0.828723132610321, 3.715310573577881, 1.0395268201828003, 0.9988493919372559, 0.8696067929267883, 1.5234881043434143, 1.9200332760810852, 1.50580233335495, 0.0, 1.721542239189148, 1.9843196868896484, 2.3641287088394165, 2.5621882677078247, 2.439434051513672, 0.0, 1.8778339624404907, 1.1037640571594238, 2.6524664163589478, 3.3218088150024414, 2.2089619636535645, 2.0732261538505554, 2.0243399143218994, 1.6644375324249268, 1.7999024391174316, 2.8134825825691223, 1.759258508682251, 0.5298198461532593, 2.400097608566284, 1.905073642730713, 1.9728269577026367, 1.6735403537750244, 2.435411214828491, 1.8077257871627808, 1.8647981882095337, 2.4920684099197388, 1.0769041776657104, 2.050837457180023, 2.3341622352600098, 1.973249077796936, 1.5578774213790894, 2.1299126148223877, 1.3677244186401367, 1.56992506980896, 2.2878328561782837, 1.612915277481079, 2.9430073499679565, 0.8718600273132324, 2.0794754028320312, 2.1136074662208557, 2.0240033864974976, 1.5882365703582764, 2.779671549797058, 2.591616630554199, 0.598802387714386, 1.457694262266159, 1.5347248315811157, 1.6365147829055786, 1.967121958732605, 2.3918377161026, 0.7503395080566406, 2.5348169207572937, 2.4616888761520386, 0.2851274013519287, 1.1796138286590576, 2.2508199214935303, 1.1699388027191162, 1.8075858354568481, 2.5779463052749634, 0.9528465270996094, 2.1697774529457092, 1.597797453403473, 2.906759202480316, 2.3571557998657227, 2.8231313228607178, 1.170098900794983, 1.9341430068016052, 1.9201353788375854, 1.6912881731987, 2.0065612196922302, 1.9447418451309204, 0.8795297145843506, 1.989950180053711, 2.245238482952118, 2.0424671173095703, 2.0815541744232178, 2.900794506072998, 1.3124184012413025, 1.5067628622055054, 1.3712636232376099, 1.4959442615509033, 2.4800605177879333, 1.0531489849090576, 1.650596797466278, 1.7219841480255127, 2.378800094127655, 1.4751980304718018, 1.8546065092086792, 2.336221933364868, 0.8676916360855103, 2.112837553024292, 2.5930140018463135, 1.0996710062026978, 2.093463659286499, 1.1809879541397095, 0.48126858472824097, 1.7851690351963043, 1.6649850606918335, 1.969794750213623, 2.0640794038772583, 2.323763132095337, 1.2962998747825623, 2.2839640974998474, 1.8219927549362183, 1.3628391027450562, 1.8085522651672363, 1.8914328813552856, 1.8126240968704224, 1.2217494249343872, 2.279914140701294, 1.3163364827632904, 1.966275155544281, 0.8144289255142212, 1.018653154373169, 1.7475343346595764, 1.8237809538841248, 1.3565389513969421, 1.8757696151733398, 1.6037226915359497, 2.0217113494873047, 2.0606104731559753, 1.98272305727005, 1.6941168308258057, 2.0432112216949463, 1.8559648990631104, 2.2518429160118103, 1.959382176399231, 1.9407442808151245, 2.0239521861076355, 2.3293368816375732, 2.6428818702697754, 1.6052789688110352, 1.449035406112671, 2.313513159751892, 1.0890570282936096, 1.7597380876541138, 2.077749013900757, 1.8170537948608398, 1.7727724313735962, 1.8803796768188477, 1.6678775548934937, 0.62348473072052, 2.2091450691223145, 2.191690146923065, 2.0976970195770264, 1.7395539283752441, 0.0, 2.05490905046463, 1.9034558534622192, 1.8160234093666077, 1.7709674835205078, 1.830084204673767, 2.021167278289795, 1.790226936340332, 1.6469917297363281, 1.772312879562378, 2.443861424922943, 2.7611266374588013, 1.0950366258621216, 2.127771258354187, 2.8096351623535156, 2.181868076324463, 2.3245843648910522, 1.455108880996704, 2.099367082118988, 1.9665004014968872, 1.8376003503799438, 1.2583601474761963, 2.402899920940399, 2.6258095502853394, 1.1135008335113525, 1.9130922555923462, 2.7295563220977783, 1.5707846879959106, 2.040013313293457, 2.597456216812134, 2.1243457794189453, 1.523719310760498, 2.1440459489822388, 1.1123732328414917, 2.19325053691864, 3.2451709508895874, 0.370294451713562, 1.3563621044158936, 1.4874935150146484, 0.0, 1.9292641878128052, 1.5432969331741333, 1.7607030868530273, 2.2127681970596313, 1.4036346673965454, 2.0491228103637695, 2.1315178275108337, 2.6924673914909363, 1.8633946776390076, 0.3233516216278076, 2.841384172439575, 0.9386690855026245, 2.9422448873519897, 1.9974793195724487, 2.277682065963745, 2.0812089443206787, 2.149455189704895, 1.4057666063308716, 2.4285746812820435, 0.3315739631652832, 0.0, 1.3218991160392761, 2.9382742643356323, 1.3176724910736084, 2.4912203550338745, 1.3294003009796143, 1.1785545349121094, 1.5880455672740936, 3.252712845802307, 1.610840380191803, 1.2402024865150452, 0.8830687999725342, 0.0, 1.7327621579170227, 1.4519312381744385, 1.888787031173706, 1.8740400075912476, 2.1287683248519897, 1.7922672033309937, 1.633777141571045, 3.2471104860305786, 1.0476285219192505, 2.078225314617157, 2.324384570121765, 1.8612365126609802, 1.9075194597244263, 2.025128126144409, 0.496734619140625, 2.1535940766334534, 1.8817577362060547, 1.1675508916378021, 1.3763607740402222, 1.4967361688613892, 1.6302483081817627, 2.616242229938507, 2.482365369796753, 0.9037163853645325, 0.9786381125450134, 1.971596360206604, 2.265403628349304, 2.207624673843384, 2.946490168571472, 1.3149493932724, 1.6186636090278625, 1.3553694486618042, 0.0, 2.2027823328971863, 2.676904082298279, 0.0, 1.8984482288360596, 2.330198347568512, 2.149809956550598, 1.8616516590118408, 2.347424626350403, 0.7213289737701416, 1.6786617040634155, 2.0614535808563232, 2.083747625350952, 1.3195730447769165, 3.1851162910461426, 1.9054865837097168, 1.5213807821273804, 3.1131571531295776, 1.0503886938095093, 0.7529957294464111, 2.0561336278915405, 0.5848482251167297, 1.9173572063446045, 1.463035225868225, 1.3928874731063843, 1.6797213554382324, 2.448181927204132, 1.1985628604888916, 1.312782645225525, 2.9286747574806213, 1.9036332368850708, 1.5577623844146729, 1.3514057397842407, 1.9595571756362915, 2.090209424495697, 2.1189422607421875, 1.6580040454864502, 2.0434183478355408, 1.6687110662460327, 0.9046518802642822, 2.0265737771987915, 2.3958903551101685, 0.9539408683776855, 1.8416954278945923, 1.7731962203979492, 1.5395148396492004, 3.120418906211853, 3.067543387413025, 1.5517778396606445, 1.8153235912322998, 1.7024850845336914, 0.0, 2.159414231777191, 2.8942043781280518, 0.838942289352417, 2.0161027312278748, 2.1920636892318726, 1.7610064148902893, 2.1820213198661804, 2.0183827877044678, 2.1308621764183044, 1.8911272287368774, 2.9628714323043823, 1.869559645652771, 1.763548731803894, 2.1679186820983887, 0.9411230087280273, 1.6375582814216614, 2.6350971460342407, 0.0, 1.971074104309082, 1.6835236549377441, 1.0475916862487793, 1.3037577867507935, 2.0664197206497192, 1.3827919960021973, 2.173123359680176, 1.503048300743103, 0.0, 2.0283828377723694, 1.969964623451233, 1.3832203149795532, 2.336371421813965, 3.454014778137207, 1.8297429084777832, 2.1062496304512024, 2.099830150604248, 1.3915719985961914, 2.1721079349517822, 2.286868453025818, 0.0, 2.282425284385681, 2.01379656791687, 1.8152042627334595, 2.104261636734009, 2.218542516231537, 1.0694465637207031, 2.005421459674835, 2.0355794429779053, 1.4356057047843933, 1.5933178067207336, 3.5498913526535034, 1.6498857736587524, 2.251180589199066, 0.6916534900665283, 1.5760221481323242, 1.808667540550232, 2.0778063535690308, 0.0, 0.9113150835037231, 0.22380757331848145, 0.0, 1.6911725997924805, 2.218653082847595, 0.007579326629638672, 1.4411563277244568, 2.605025291442871, 0.0, 1.7457091808319092, 1.8709208965301514, 1.396095871925354, 1.8758793473243713, 2.683948040008545], "samples": [1.9973765313625336, 4.06578403711319, 2.629990816116333, 2.6718294620513916, 2.240519791841507, 1.3634185194969177, 2.9392210245132446, 3.3233336806297302, 3.0068814754486084, 3.016553670167923, 3.0076096057891846, 3.671096086502075, 2.4963287711143494, 2.1657524704933167, 1.090919017791748, 2.0833439230918884, 4.0057066679000854, 2.269956588745117, 2.030471831560135, 2.4843056201934814, 1.8320699334144592, 2.2010442912578583, 2.256309688091278, 2.1403015851974487, 3.4316211938858032, 2.3213696479797363, 3.8778648376464844, 2.046412408351898, 2.2970104217529297, 3.273868680000305, 2.19890558719635, 2.595174252986908, 3.0460498332977295, 2.159054160118103, 1.9123455584049225, 2.4578830003738403, 2.6606470942497253, 2.462143123149872, 3.444191813468933, 2.571058452129364, 2.6519605219364166, 1.8423001766204834, 2.762954831123352, 3.7582415640354156, 3.0621625781059265, 2.0041263699531555, 3.8920852541923523, -0.2088918685913086, 2.2964550256729126, 2.0412906110286713, 2.904360055923462, 2.172478199005127, 2.1898720264434814, 3.363266348838806, 2.221232056617737, 2.508684992790222, 2.9189852476119995, 1.9991389513015747, 2.1275343000888824, 3.719872534275055, 1.667881965637207, 2.1619769632816315, 2.0381866693496704, 2.242116630077362, 2.2187666296958923, 2.579055607318878, 2.1422795355319977, 2.725004732608795, 3.6503429412841797, 1.9608144164085388, 2.6272386014461517, 2.7739710807800293, 1.955068588256836, 2.4655746817588806, 2.662813425064087, 1.951192021369934, 1.2218087315559387, 3.0075128078460693, 2.363090455532074, 2.754262685775757, 1.8316455483436584, 3.0059990286827087, 2.430127054452896, 2.428672432899475, 2.04870742559433, 2.1423323154449463, 3.6215620040893555, 1.8385754227638245, 2.17767333984375, 2.369943380355835, 2.0671466886997223, 1.9657861292362213, 2.209233522415161, 2.148196518421173, 2.683341145515442, 2.570885181427002, 2.2158263325691223, 2.036421984434128, 2.2260034680366516, 2.4388781785964966, 2.860714077949524, 2.7576204538345337, 1.9354971647262573, 2.3800585865974426, 2.0451467037200928, 1.8757344782352448, 2.5057882964611053, 2.4093310832977295, 1.9078444838523865, 2.0147958993911743, 2.408214032649994, 1.6627442240715027, 2.495978891849518, 2.2774852514266968, 1.755764901638031, 2.818687677383423, 2.9310837388038635, 1.8319121599197388, 1.600721299648285, 2.3258473873138428, 1.6519438028335571, 1.7666097581386566, 1.9984420537948608, 2.983511507511139, 1.453077793121338, 2.962062358856201, 1.8408160209655762, 3.3021378815174103, 3.1236671209335327, 2.1595881581306458, 2.1858693659305573, 1.7396147847175598, 2.791426718235016, 2.9588301181793213, 2.639893412590027, 1.924569308757782, 2.6839908361434937, 2.2435798048973083, 2.9826304614543915, 1.94648477435112, 2.016463667154312, 2.2961074113845825, 2.2821702361106873, 3.6625181436538696, 2.2820581197738647, 2.326694071292877, 2.7596376538276672, 2.1921910643577576, 2.647325783967972, 2.0710572600364685, 2.4654229283332825, 2.9341589212417603, 1.7544052600860596, 2.402091920375824, 2.307530462741852, 3.4379665851593018, 1.9534218311309814, 2.5831079483032227, 1.8104058504104614, 2.5921147763729095, 2.3026561737060547, 5.7806971073150635, 2.216695189476013, 2.9091238379478455, 2.2906684279441833, 2.023789882659912, 1.9899526834487915, 2.5837697088718414, 2.353563606739044, 2.050029695034027, 3.3361594676971436, 1.8684673309326172, 2.5343470573425293, 2.690786361694336, 3.165778160095215, 2.455282688140869, 2.8050480484962463, 1.9528009295463562, 2.3430912792682648, 2.718661606311798, 2.4303477108478546, 2.5465795397758484, 2.6774717569351196, 2.0628766417503357, 2.42312091588974, 1.9353291988372803, 2.733915686607361, 2.1444228291511536, 2.263077974319458, 2.3295937180519104, 2.3473703861236572, 2.77821284532547, 1.965422511100769, 2.6001002192497253, 3.0236252546310425, 2.8126593232154846, 2.5714561343193054, 3.4252071380615234, 1.5751285552978516, 2.3639183044433594, 2.6587905287742615, 2.7809125781059265, 1.924584299325943, 2.85689640045166, 1.5708924531936646, 2.5680700540542603, 2.5044849514961243, 2.164414882659912, 1.8096515536308289, 2.7927441000938416, 2.1116462349891663, 2.4583540558815002, 2.9136874675750732, 2.168607324361801, 1.7985925078392029, 3.3359787464141846, 1.2115966081619263, 0.8648964762687683, 1.2901103794574738, 2.373087853193283, 1.9231621325016022, 1.942348599433899, 2.0341628193855286, 2.3291347324848175, 1.9968395233154297, 2.156748652458191, 3.020316779613495, 2.2010373175144196, 1.923780381679535, 2.0751630663871765, 2.102991759777069, 2.702752709388733, 0.9983053207397461, 2.990081787109375, 3.006237506866455, 2.724002957344055, 4.148685574531555, 1.8028917610645294, 2.111392855644226, 2.7903688549995422, 2.3231988847255707, 2.4347126483917236, 2.0775280594825745, 1.7823448777198792, 2.828578770160675, 2.569499135017395, 2.0349732637405396, 2.740726947784424, 2.5513994693756104, 2.252434551715851, 2.7915918231010437, 2.4804906845092773, 2.855531930923462, 2.103753462433815, 2.1171696186065674, 1.3547505736351013, 2.1138654351234436, 3.2075880765914917, 2.016549825668335, 2.5133069157600403, 2.4763776659965515, 2.916196346282959, 2.68259060382843, 2.450471878051758, 2.989567309617996, 2.6792387664318085, 2.2624207139015198, 2.0691022872924805, 2.58026784658432, 2.7635958790779114, 1.3224357962608337, 1.03272145986557, 1.1586124002933502, 2.435722291469574, 3.0808911323547363, 2.5150944590568542, 1.9513755440711975, 2.3678507804870605, 3.2431159019470215, 2.754766970872879, 2.4219579696655273, 2.481895089149475, 1.7694379091262817, 2.176247715950012, 2.8517919778823853, 2.1469293236732483, 2.177632123231888, 2.3919610381126404, 1.6353112757205963, 2.3388956487178802, 2.0026589930057526, 1.8165634274482727, 2.0889676809310913, 2.6475155353546143, 2.122787654399872, 2.08238685131073, 2.838904857635498, 2.01159131526947, 2.174017757177353, 2.7171797156333923, 2.260037899017334, 2.5222617983818054, 2.1694539189338684, 1.542546272277832, 1.5241588354110718, 2.107390522956848, 2.086704522371292, 2.36722794175148, 2.7798911929130554, 2.1227910816669464, 1.8592658936977386, 2.2175371944904327, 2.1129457652568817, 2.1122899800539017, 2.657070904970169, 2.342500865459442, 2.6406643390655518, 2.1944571137428284, 2.212940752506256, 1.9129766821861267, 3.43328320980072, 1.964074432849884, 2.280003845691681, 3.162321984767914, 1.9175979793071747, 2.278046131134033, 2.475737750530243, 2.5409950613975525, 2.238490402698517, 2.2293134331703186, 3.0979710817337036, 1.8245220184326172, 4.558781623840332, 2.3263198733329773, 2.48954439163208, 1.6846933960914612, 2.387553095817566, 2.394203543663025, 2.2904834151268005, 1.8011133670806885, 2.75236576795578, 4.178751587867737, 2.0609593391418457, 2.1618951559066772, 2.3972891569137573, 2.0897162556648254, 2.225112020969391, 2.6353458166122437, 1.856115698814392, 2.127871870994568, 3.012174904346466, 1.977447748184204, 2.113057941198349, 1.9313050508499146, 2.2606312334537506, 2.445825755596161, 2.6519641280174255, 1.917269080877304, 2.176583230495453, 2.3888705372810364, 2.3295719027519226, 3.070725440979004, 2.9970333576202393, 2.2719979882240295, 2.2613431811332703, 2.2413004636764526, 3.5218111276626587, 2.548806309700012, 2.770483613014221, 1.9874376058578491, 2.0970687866210938, 2.211669147014618, 2.148591101169586, 1.9457772970199585, 2.330696403980255, 1.9782891869544983, 1.7887916266918182, 2.8346023559570312, 2.0141662657260895, 1.8682582378387451, 2.126076191663742, 2.270844340324402, 2.3145145773887634, 2.739613175392151, 1.8461581766605377, 2.368385076522827, 2.506135046482086, 2.4147817492485046, 1.9666795432567596, 2.5310864448547363, 2.384384363889694, 2.4989649653434753, 2.537631928920746, 3.028894364833832, 2.0041713416576385, 3.145792782306671, 2.6379268765449524, 2.327580511569977, 3.579172372817993, 1.9838346242904663, 1.448133409023285, 3.5609107613563538, 2.2560580670833588, 1.3252830803394318, 2.8280810117721558, 1.9961938858032227, 2.3454529643058777, 1.8727359771728516, 1.4114173650741577, 1.2167617082595825, 1.7818825840950012, 2.479807138442993, 2.1517879366874695, 2.9617286920547485, 1.8910503685474396, 2.3368815779685974, 2.4094675183296204, 1.9028074145317078, 2.715813636779785, 1.825639694929123, 2.263431668281555, 2.3919888734817505, 2.4464563131332397, 1.4434186816215515, 2.501035153865814, 2.243505358695984, 2.199994385242462, 2.5205530524253845, 3.0232549905776978, 3.152101516723633, 2.131520450115204, 4.264852046966553, 2.85859477519989, 2.6480987071990967, 1.7822127938270569, 2.424058675765991, 3.027066707611084, 3.0081582069396973, 1.757852166891098, 1.8953733444213867, 1.7563121318817139, 1.8370857536792755, 2.0171236097812653, 3.1330663561820984, 2.375351071357727, 2.113608568906784, 2.723153829574585, 1.9538753032684326, 2.4432126581668854, 2.4133731722831726, 1.9778072535991669, 2.098574310541153, 2.0117745995521545, 2.4297435879707336, 2.107346475124359, 3.087442934513092, 2.0692394077777863, 2.224761664867401, 2.3111600279808044, 2.523092269897461, 2.0138150453567505, 2.366751343011856, 1.8934224247932434, 2.3724275529384613, 2.35311496257782, 2.669927656650543, 2.272777557373047, 1.7427170872688293, 1.4227280914783478, 1.8780831694602966, 2.0833374857902527, 2.0484764873981476, 2.575670301914215, 2.872529834508896, 1.9765311479568481, 2.0834614634513855, 2.299793243408203, 2.265594333410263, 1.894020915031433, 2.4309410452842712, 1.9174211025238037, 2.1475295424461365, 2.181092858314514, 2.2051555812358856, 1.8349179923534393, 2.4923728108406067, 1.6400671005249023, 2.348206400871277, 2.6099172234535217, 2.2210652828216553, 2.4414241015911102, 3.0630844831466675, 2.0575511157512665, 2.3411791920661926, 2.4254316091537476, 2.09032142162323, 2.9974164962768555, 2.553347945213318, 1.8185348510742188, 1.6288620829582214, 2.489871919155121, 2.0342100858688354, 2.3516644835472107, 2.4232596158981323, 1.9936454892158508, 2.087148070335388, 3.0620588660240173, 2.3423677682876587, 2.28335839509964, 3.50318706035614, 2.466320663690567, 2.2985619008541107, 2.5536028146743774, 1.953069806098938, 2.272947132587433, 2.133249282836914, 2.0407223403453827, 2.190535306930542, 2.1894665956497192, 2.1573615074157715, 2.5271909534931183, 3.1432085633277893, 1.7049443125724792, 2.691188931465149, 1.6619045734405518, 2.3184094429016113, 2.3304492235183716, 2.614457845687866, 1.8799744844436646, 1.9492138624191284, 2.1526408791542053, 1.866143822669983, 2.1275988817214966, 3.017462432384491, 2.5240814983844757, 2.3840070366859436, 2.904106378555298, 2.4825675785541534, 1.929750770330429, 2.6839067935943604, 2.091273009777069, 2.076256811618805, 2.41413277387619, 1.9107096791267395, 1.7400716841220856, 2.2166417837142944, 2.0232981145381927, 2.6408196091651917, 2.0239486694335938, 2.4735485911369324, 2.374144971370697, 1.8128970861434937, 2.084424376487732, 2.5408186316490173, 2.4986445903778076, 3.0028322339057922, 2.5359804034233093, 1.9520643949508667, 2.153536021709442, 2.825853109359741, 2.9246436953544617, 1.9105268120765686, 2.7896222472190857, 2.0606651306152344, 2.412751019001007, 2.167248249053955, 2.097181737422943, 1.7216280102729797, 2.101681172847748, 1.8010870218276978, 1.86460679769516, 2.138256698846817, 2.3474581241607666, 1.7616645097732544, 2.5020541846752167, 2.7006996870040894, 2.248360514640808, 2.462396800518036, 2.8853498101234436, 2.434404492378235, 2.224932312965393, 3.0944178104400635, 1.9005666375160217, 2.2770132422447205, 2.502542018890381, 2.8091787099838257, 2.2736940383911133, 2.8235344886779785, 2.1786569356918335, 2.2095378637313843, 2.583146095275879, 2.485957682132721, 2.0619630217552185, 2.926024854183197, 2.5086877942085266, 2.610030233860016, 2.8406988382339478, 2.0511501729488373, 2.276108503341675, 1.867131531238556]}, "info": {"pct_words_masked": 0.7, "span_length": 5, "n_perturbations": 1, "n_samples": 700}, "raw_results": [{"original": "#include <stdio.h>\nint main(void)\n{\n\tint a[10];\n\tint i;\n\tint MAX[3];\n\tfor(i = 0; i < 10; i++)\n\t{\n\t\tscanf(\"%d\", &a[i]);\n\t}\n\tfor(i = 0; i < 3; i++)\n\t{\n\t\tMAX[i] = 0;\n\t}\n\tfor(i = 0; i < 10; i++)\n\t{\n\t\tif(MAX[0] < a[i])\n\t\t{\n\t\t\tMAX[0] = a[i];\n\t\t}\n\t}\n\tfor(i = 0; i < 10; i++)\n\t{\n\t\tif(MAX[1] < a[i])\n\t\t{\n\t\t\tif(a[i] < MAX[0])\n\t\t\t{\n\t\t\t\tMAX[1] = a[i];\n\t\t\t}\n\t\t}\n\t}\n\tfor(i = 0; i < 10; i++)\n\t{\n\t\tif(MAX[2] < a[i])\n\t\t{\n\t\t\tif(a[i] < MAX[1])\n\t\t\t{\n\t\t\t\tMAX[2] = a[i];\n\t\t\t}\n\t\t}\n\t}\n\tfor(i = 0; i < 3; i++)\n\t{\n\t\tprintf(\"%d\\n\", MAX[i]);\n\t}\n\treturn 0;\n}", "sampled": "#include <stdio.h>\n\nint main() {\n    int heights[10];\n    int i, j;\n    \n    for (i = 0; i < 10; i++) {\n        scanf(\"%d\", &heights[i]);\n    }\n    \n    for (i = 0; i < 10; i++) {\n        for (j = i + 1; j < 10; j++) {\n            if (heights[i] < heights[j]) {\n                int temp = heights[i];\n                heights[i] = heights[j];\n                heights[j] = temp;\n            }\n        }\n    }\n    \n    printf(\"%d\\n\", heights[0]);\n    printf(\"%d\\n\", heights[1]);\n    printf(\"%d\\n\", heights[2]);\n    \n    return 0;\n}\n", "perturbed_sampled": [" int heights[10];  10; i++) { scanf(\"%d\", &heights[i]);  i < 10; i++) { for (j = i  j++) { if (heights[i]  = heights[i];  temp; } }  }"], "perturbed_original": ["#include <stdio.h> int main(void) <<extra_id_3>{ try{<extra_id_4>int<extra_id_5>0; for<extra_id_6>i=0; i<3; i++) { for(i<extra_id_7>) { if(MAX[i]<extra_id_8>} }<extra_id_9>if(MAX[1] < a[i]) int MAX[3]; for(i = 0; i < 10; <extra_id_10>d: if(d !=<extra_id_11>1;<extra_id_12><<extra_id_13>= 0; FOR(i;<extra_id_14>} return<extra_id_15>-1; case 1:<extra_id_16> < 3; i++) { MAX[i] = 0;  MAX[0] = a[i];  { if(MAX[1] < a[i])  } } for(i = 0; i  < a[i]) {  } for(i  } return 0; }"], "original_ll": -0.3639797866344452, "sampled_ll": -0.3564881384372711, "all_perturbed_sampled_ll": [-2.3538646697998047], "all_perturbed_original_ll": [-2.317033052444458], "perturbed_sampled_ll": -2.3538646697998047, "perturbed_original_ll": -2.317033052444458, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "public class Main{\n\tpublic static void main(String[] a) throws Exception {\n\t\tint[] heights = new int[10];\n\t\tfor (int i = 0; i < 10; i++) {\n\t\t\tBufferedReader height = new BufferedReader(new InputStreamReader(System.in));\t\n\t\t\theights[i] = Integer.parseInt(height.readLine());\n\t\t\tSystem.out.println(heights[i]);\n\t\t}\n\t\tArrays.sort(heights);\n\t\tSystem.out.println(heights[0]);\n\t\tSystem.out.println(heights[1]);\n\t\tSystem.out.println(heights[2]);\n\t}\n}", "sampled": "import java.util.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        Integer[] heights = new Integer[10];\n        \n        for (int i = 0; i < 10; i++) {\n            heights[i] = sc.nextInt();\n        }\n        \n        Arrays.sort(heights, Collections.reverseOrder());\n        \n        System.out.println(heights[0]);\n        System.out.println(heights[1]);\n        System.out.println(heights[2]);\n        \n        sc.close();\n    }\n}\n", "perturbed_sampled": ["import   { Scanner sc = new   0;  heights[i] = sc.nextInt(); }  sc.close(); } }"], "perturbed_original": ["public class Main{ public  Exception { int[] heights = new int[10]; for (int  10; i++)  }"], "original_ll": -0.9742730259895325, "sampled_ll": -0.46829789876937866, "all_perturbed_sampled_ll": [-4.534081935882568], "all_perturbed_original_ll": [-3.5169456005096436], "perturbed_sampled_ll": -4.534081935882568, "perturbed_original_ll": -3.5169456005096436, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import sys\ne = sys.stdin.readlines()\ne = [int(i) for i in e]\nfor i in range(3):\n    m = max(e)\n    e.remove(m)\n    print (m)\n", "sampled": "heights = []\nfor _ in range(10):\n    heights.append(int(input()))\n\nheights.sort(reverse=True)\n\nfor i in range(3):\n    print(heights[i])\n", "perturbed_sampled": ["heights = [] for _ in  in range(3): print(heights[i])"], "perturbed_original": ["import sys e  for i  e.remove(m) print (m)"], "original_ll": -1.5143702030181885, "sampled_ll": -1.0439882278442383, "all_perturbed_sampled_ll": [-3.6739790439605713], "all_perturbed_original_ll": [-5.449954509735107], "perturbed_sampled_ll": -3.6739790439605713, "perturbed_original_ll": -5.449954509735107, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "#include<stdio.h>\n\nint main()\n{\nint N, i, a, b, c, max;\n\nscanf(\"%d\", &N);\n\nfor(i=0; i<N; i++){\nscanf(\"%d %d %d\", &a, &b, &c);\n\nif(a<=b && b<=c){\nmax = c;\nif(c*c==a*a+b*b){\nputs(\"YES\");\n}else{\nputs(\"NO\");\n}\n}\nelse if(a<=c && c<=b){\nmax = b;\nif(b*b==a*a+c*c){\nputs(\"YES\");\n}else{\nputs(\"NO\");\n}\n}\nelse if(b<=c && c<=a){\nmax = a;\nif(a*a==b*b+c*c){\nputs(\"YES\");\n}else{\nputs(\"NO\");\n}\n}\nelse if(b<=a && a<=c){\nmax = c;\nif(c*c==a*a+b*b){\nputs(\"YES\");\n}else{\nputs(\"NO\");\n}\n}\nelse if(c<=a && a<=b){\nmax = b;\nif(b*b==a*a+c*c){\nputs(\"YES\");\n}else{\nputs(\"NO\");\n}\n}\nelse if(c<=b && b<=a){\nmax = a;\nif(a*a==b*b+c*c){\nputs(\"YES\");\n}else{\nputs(\"NO\");\n}\n}\n\n}\n\nreturn 0;\n}", "sampled": "#include <stdio.h>\n\nint main() {\n    int n;\n    scanf(\"%d\", &n);\n    \n    while (n--) {\n        int a, b, c;\n        scanf(\"%d %d %d\", &a, &b, &c);\n        \n        int aa = a * a;\n        int bb = b * b;\n        int cc = c * c;\n        \n        if (aa + bb == cc || aa + cc == bb || bb + cc == aa) {\n            printf(\"YES\\n\");\n        } else {\n            printf(\"NO\\n\");\n        }\n    }\n    \n    return 0;\n}\n", "perturbed_sampled": ["#include <stdio.h> int main() { int n; scanf(\"%d\",   int   b; int cc =  || aa + cc == bb ||  { printf(\"NO\\n\"); } } return 0; }"], "perturbed_original": ["#include<stdio.h> int main() { int  max;  scanf(\"%d %d %d\", &a,  && c<=a){ max  puts(\"NO\"); } } else if(b<=a && a<=c){  }else{  && a<=b){ max  puts(\"NO\"); } } else if(c<=b && b<=a){ max = a;  } } return 0; }"], "original_ll": -0.4624471366405487, "sampled_ll": -0.41610050201416016, "all_perturbed_sampled_ll": [-3.0879299640655518], "all_perturbed_original_ll": [-2.268836259841919], "perturbed_sampled_ll": -3.0879299640655518, "perturbed_original_ll": -2.268836259841919, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import java.util.Scanner;\npublic class Main{\n\n\tpublic static void main(String[] args) {\n\t\t// TODO ?????????????????????????????????????????????\n\t\tScanner kb=new Scanner(System.in);\nint size=kb.nextInt();\nint a[][]=new int[size][3];\nint x,y,z;\nfor(int i=0;i<size;i++){\n\ta[i][0]=kb.nextInt();\n\ta[i][1]=kb.nextInt();\n\ta[i][2]=kb.nextInt();\n}\nfor(int i=0;i<size;i++){\nx=a[i][0];\ny=a[i][1];\nz=a[i][2];\nif(x*x+y*y==z*z||y*y+z*z==x*x||z*z+x*x==y*y){\n\tSystem.out.println(\"YES\");\n}else{\n\tSystem.out.println(\"NO\");\n}\n}\n\t}\n\n}", "sampled": "import java.util.Scanner;\nimport java.util.Arrays;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int n = sc.nextInt();\n        \n        for (int i = 0; i < n; i++) {\n            int[] sides = new int[3];\n            sides[0] = sc.nextInt();\n            sides[1] = sc.nextInt();\n            sides[2] = sc.nextInt();\n            \n            Arrays.sort(sides);\n            \n            if (sides[0] * sides[0] + sides[1] * sides[1] == sides[2] * sides[2]) {\n                System.out.println(\"YES\");\n            } else {\n                System.out.println(\"NO\");\n            }\n        }\n        \n        sc.close();\n    }\n}\n", "perturbed_sampled": ["  Scanner sc = new Scanner(System.in); int  < n;  new int[3]; sides[0] = sc.nextInt(); sides[1]  Arrays.sort(sides); if (sides[0] * sides[0]  sides[2] *  { System.out.println(\"NO\"); } } sc.close(); } }"], "perturbed_original": ["import java.util.Scanner; public  a[][]=new int[size][3]; int x,y,z; for(int i=0;i<size;i++){ a[i][0]=kb.nextInt(); a[i][1]=kb.nextInt(); a[i][2]=kb.nextInt();  z=a[i][2]; if(x*x+y*y==z*z||y*y+z*z==x*x||z*z+x*x==y*y){  } }"], "original_ll": -0.8131423592567444, "sampled_ll": -0.33265969157218933, "all_perturbed_sampled_ll": [-2.5731794834136963], "all_perturbed_original_ll": [-1.6176480054855347], "perturbed_sampled_ll": -2.5731794834136963, "perturbed_original_ll": -1.6176480054855347, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "N = int(input())\nfor i in range(N):\n    triangle = sorted([int(n) for n in input().split()])\n    if triangle[0]**2 + triangle[1]**2 == triangle[2]**2:\n        print('YES')\n    else:\n        print('NO')\n\n", "sampled": "n = int(input())\nfor _ in range(n):\n    sides = list(map(int, input().split()))\n    sides.sort()\n    if sides[0]**2 + sides[1]**2 == sides[2]**2:\n        print(\"YES\")\n    else:\n        print(\"NO\")\n", "perturbed_sampled": ["n  range(n):  if sides[0]**2 + sides[1]**2 == sides[2]**2: print(\"YES\") else: print(\"NO\")"], "perturbed_original": [" sorted([int(n) for n in  == triangle[2]**2: print('YES') else: print('NO')"], "original_ll": -0.9703245759010315, "sampled_ll": -0.6357772946357727, "all_perturbed_sampled_ll": [-1.9991958141326904], "all_perturbed_original_ll": [-3.4876129627227783], "perturbed_sampled_ll": -1.9991958141326904, "perturbed_original_ll": -3.4876129627227783, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "#include <stdio.h>\n\nint main( void )\n{\n    int a,b,c,d,e,f;\n    float x,y;\n    \n    while(scanf(\"%d %d %d %d %d %d\",&a,&b,&c,&d,&e,&f)!=-1){    \n        y = (float)( c*d -a*f ) / (b*d-a*e); \n        x = (float)( c*e -b*f ) / (a*e-b*d);\n        if(-0.0005<x && x<=0 ){\n            x = 0;\n        }\n        if(-0.0005<y && y<=0 ){\n            y = 0;\n        }\n        printf( \"%.3lf %.3f\\n\",x,y); \n    }\n    return 0;\n}", "sampled": "#include <stdio.h>\n\nint main() {\n    double a, b, c, d, e, f;\n    \n    while (scanf(\"%lf %lf %lf %lf %lf %lf\", &a, &b, &c, &d, &e, &f) != EOF) {\n        double x, y;\n        double det = a * e - b * d;\n        \n        x = (c * e - b * f) / det;\n        y = (a * f - c * d) / det;\n        \n        printf(\"%.3f %.3f\\n\", x, y);\n    }\n    \n    return 0;\n}\n", "perturbed_sampled": ["#include  a, b, c, d, e, f; while  a * e - b * d; x = (c * e - b  = (a  d) / det; printf(\"%.3f  0; }"], "perturbed_original": ["#include <stdio.h> int main(  float x,y; while(scanf(\"%d %d  ) / (b*d-a*e); x =  (a*e-b*d);  = 0; } if(-0.0005<y &&  } return 0; }"], "original_ll": -1.2035702466964722, "sampled_ll": -0.6027036905288696, "all_perturbed_sampled_ll": [-3.5419247150421143], "all_perturbed_original_ll": [-3.550257921218872], "perturbed_sampled_ll": -3.5419247150421143, "perturbed_original_ll": -3.550257921218872, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import java.io.*;\n\nclass Main {\n\tpublic static void main(String args[]) {\n\t\ttry {\n\t\t\tBufferedReader reader = new BufferedReader(new InputStreamReader(System.in));\n\t\t\tString t[], s;\n\t\t\tdouble a[] = new double[6];\n\t\t\twhile((s = reader.readLine())  != null) {\n\t\t\t\tt = s.split(\" \");\n\t\t\t\tfor(int i = 0;i < a.length;i++) {\n\t\t\t\t\ta[i] = Double.parseDouble(t[i]);\n\t\t\t\t}\n\t\t\t\tdouble z = a[0]*a[4]-a[1]*a[3];\n\t\t\t\tdouble x = (a[4]*a[2]-a[1]*a[5])/z;\n\t\t\t\tdouble y = (-a[3]*a[2]+a[0]*a[5])/z;\n\n\t\t\t\tif(x == -0.0)\n\t\t\t\t\tx = 0.0;\n\t\t\t\tif(y == -0.0)\n\t\t\t\t\ty = 0.0;\n\t\t\t\tSystem.out.printf(\"%4.3f %4.3f\\n\", x, y);\n\n\t\t\t}\n\n\t\t}\n\t\tcatch(IOException e) {\n\t\t\tSystem.out.println(e);\n\t\t}\n\t}\n}", "sampled": "import java.util.Scanner;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        \n        while (sc.hasNext()) {\n            double a = sc.nextDouble();\n            double b = sc.nextDouble();\n            double c = sc.nextDouble();\n            double d = sc.nextDouble();\n            double e = sc.nextDouble();\n            double f = sc.nextDouble();\n            \n            double det = a * e - b * d;\n            double x = (c * e - b * f) / det;\n            double y = (a * f - c * d) / det;\n            \n            System.out.printf(\"%.3f %.3f%n\", x, y);\n        }\n        \n        sc.close();\n    }\n}\n", "perturbed_sampled": [" main(String[] args) { Scanner  (sc.hasNext()) { double a =  double c =     x = (c * e - b * f)  c * d) / det;  sc.close(); } }"], "perturbed_original": ["import  {  new BufferedReader(new InputStreamReader(System.in));  =  != null) { t  = 0;i < a.length;i++)  double z  (a[4]*a[2]-a[1]*a[5])/z;  == -0.0) x = 0.0; if(y == -0.0) y  y); }  } } }"], "original_ll": -0.8480775952339172, "sampled_ll": -0.502366840839386, "all_perturbed_sampled_ll": [-3.825700521469116], "all_perturbed_original_ll": [-3.39943790435791], "perturbed_sampled_ll": -3.825700521469116, "perturbed_original_ll": -3.39943790435791, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import sys\nfor line in sys.stdin:\n    a,b,c,d,e,f = map(float, line.split())\n    print((c*e-b*f)/(a*e-b*d), (a*f-c*d)/(a*e-b*d))", "sampled": "import sys\n\nfor line in sys.stdin:\n    a, b, c, d, e, f = map(float, line.split())\n    \n    # Using Cramer's rule\n    # ax + by = c\n    # dx + ey = f\n    \n    det = a * e - b * d\n    \n    if det != 0:\n        x = (c * e - b * f) / det\n        y = (a * f - c * d) / det\n    else:\n        # This shouldn't happen as per problem statement (unique solution)\n        x = 0\n        y = 0\n    \n    print(f\"{x:.3f} {y:.3f}\")\n", "perturbed_sampled": ["import  line.split()) # Using Cramer's rule # ax + by = c # dx + ey = f det = a *  if det != 0: x =  * f) / det  /  =  {y:.3f}\")"], "perturbed_original": ["import sys  = map(float, line.split()) print((c*e-b*f)/(a*e-b*d), (a*f-c*d)/(a*e-b*d))"], "original_ll": -1.4892786741256714, "sampled_ll": -0.9531593322753906, "all_perturbed_sampled_ll": [-3.960040807723999], "all_perturbed_original_ll": [-3.306321859359741], "perturbed_sampled_ll": -3.960040807723999, "perturbed_original_ll": -3.306321859359741, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "#include<stdio.h>\n\nint main(void){\n    int a,b,c,tmp,tmp_a,tmp_b;\n    while(scanf(\"%d%d\", &a, &b)!=EOF){\n        c = 1;\n        if(b > a){tmp = a; a = b; b = tmp;}\n        tmp_a = a;\n        tmp_b = b;\n        for(int i=2; i<=tmp_b; i++){\n            while(tmp_b%i==0 && tmp_a%i==0){\n                c = c*i;\n                tmp_b = tmp_b / i;\n                tmp_a = tmp_a / i;\n            }\n        }\n        printf(\"%d %d\\n\", c, tmp_a*tmp_b*c);\n    }\n    return 0;\n}\n\n", "sampled": "#include <stdio.h>\n\nlong long gcd(long long a, long long b) {\n    while (b != 0) {\n        long long temp = b;\n        b = a % b;\n        a = temp;\n    }\n    return a;\n}\n\nint main() {\n    long long a, b;\n    while (scanf(\"%lld %lld\", &a, &b) != EOF) {\n        long long g = gcd(a, b);\n        long long lcm = (a / g) * b;\n        printf(\"%lld %lld\\n\", g, lcm);\n    }\n    return 0;\n}\n", "perturbed_sampled": [" long a, long long b) {  long long temp =  int main()  while (scanf(\"%lld %lld\", &a,  long  long lcm = (a  %lld\\n\", g, lcm); } return 0; }"], "perturbed_original": ["#include<stdio.h> int main(void){ int a,b,c,tmp,tmp_a,tmp_b;  b; b = tmp;} tmp_a = a;   i; } } printf(\"%d %d\\n\", c, tmp_a*tmp_b*c); } return 0; }"], "original_ll": -0.9624162912368774, "sampled_ll": -0.39545580744743347, "all_perturbed_sampled_ll": [-3.4120094776153564], "all_perturbed_original_ll": [-2.635253429412842], "perturbed_sampled_ll": -3.4120094776153564, "perturbed_original_ll": -2.635253429412842, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import java.io.*;\n\npublic class Main{\n\t/*\n\tpublic static long findGcd(long f1, long f2){\n\t\tlong gcd = 1;\n\t\tlong max, min;\n\t\tif(f1 > f2){max = f1; min = f2;}\n\t\telse{max = f2; min = f1;}\n\t\tfor(long i=1; i<=(long)(Math.sqrt(min)+1); i++){\n\t\t\tif(min % i == 0){\n\t\t\t\tlong tmp = min / i;\n\t\t\t\tif((max % tmp) == 0){\n\t\t\t\t\tgcd = tmp;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn gcd;\n\t}\n\t*/\n\tstatic long findGcd(long x, long y){\n        for(long i=1; i<=x; i++){\n            if(y*i%x==0){\n                return y*i;\n            }\n        }\n        return 0;\n    }\n\t\n\tpublic static long findlcm(long f1, long f2){\n\t\tlong lcm = 0;\n\t\tlong max, min;\n\t\tif(f1 > f2){max = f1; min = f2;}\n\t\telse{max = f2; min = f1;}\n\t\tlong i=1;\n\t\twhile(lcm == 0){\n\t\t\tif((max * i)%min == 0){\n\t\t\t\tlcm = max * i;\n\t\t\t}\n\t\t\ti++;\n\t\t}\n\t\treturn lcm;\n\t}\n\t\n\tpublic static void main(String[] argv) throws NumberFormatException, IOException{\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\tString line;\n\t\twhile((line = br.readLine()) != null){\n\t\t\tString[] lineArray = line.split(\" \");\n\t\t\tlong[] factor = {Long.parseLong(lineArray[0]), Long.parseLong(lineArray[1])};\n\t\t\tlong gcd = findGcd(factor[0], factor[1]);\n\t\t\tlong lcm = findlcm(factor[0], factor[1]);\n\t\t\tSystem.out.println(gcd + \" \" + lcm);\n\t\t}\n\t}\n}", "sampled": "import java.util.Scanner;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        \n        while (sc.hasNext()) {\n            long a = sc.nextLong();\n            long b = sc.nextLong();\n            \n            long gcd = gcd(a, b);\n            long lcm = (a / gcd) * b;\n            \n            System.out.println(gcd + \" \" + lcm);\n        }\n        \n        sc.close();\n    }\n    \n    static long gcd(long a, long b) {\n        while (b != 0) {\n            long temp = b;\n            b = a % b;\n            a = temp;\n        }\n        return a;\n    }\n}\n", "perturbed_sampled": ["import java.util.Scanner; public  Scanner sc = new Scanner(System.in); while (sc.hasNext()) {  b   (a / gcd) *  + lcm); }  while (b !=  temp; } return a; } }"], "perturbed_original": ["import java.io.*; public class  findGcd(long f1, long f2){ long gcd =  min = f2;} else{max = f2; min = f1;}  long tmp = min / i; if((max % tmp)  return gcd; }  i<=x; i++){ if(y*i%x==0){ return y*i; }  static long  max,  else{max = f2;  while(lcm ==  * i; } i++; } return lcm;    br.readLine()) !=  {Long.parseLong(lineArray[0]), Long.parseLong(lineArray[1])};  long  + \" \" + lcm); } } }"], "original_ll": -0.7123250961303711, "sampled_ll": -0.36513805389404297, "all_perturbed_sampled_ll": [-3.3727476596832275], "all_perturbed_original_ll": [-3.31882905960083], "perturbed_sampled_ll": -3.3727476596832275, "perturbed_original_ll": -3.31882905960083, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import math\n\ntry:\n while 1:\n  a,b=map(int,input().split())\n  print(math.gcd(a,b),a*b// math.gcd(a, b))\nexcept:\n   pass\n ", "sampled": "import sys\nimport math\n\nfor line in sys.stdin:\n    a, b = map(int, line.split())\n    gcd = math.gcd(a, b)\n    lcm = (a * b) // gcd\n    print(gcd, lcm)\n", "perturbed_sampled": ["import sys import  a,  = math.gcd(a, b) lcm =  print(gcd, lcm)"], "perturbed_original": ["import math try:  b)) except: pass"], "original_ll": -1.984938144683838, "sampled_ll": -0.7474801540374756, "all_perturbed_sampled_ll": [-4.418576240539551], "all_perturbed_original_ll": [-6.2950520515441895], "perturbed_sampled_ll": -4.418576240539551, "perturbed_original_ll": -6.2950520515441895, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "#include<stdio,h>\n#include<string.h>\nint main(){\nchar a[20];\nint l,i;\nscanf(\"%s\",a);\nl=strlen(a);\nfor(i=l-1;i>=0;i--)\nprintf(\"%c\",a[i]);\nreturn 0;\n}", "sampled": "#include <stdio.h>\n#include <string.h>\n\nint main() {\n    char str[21];\n    scanf(\"%s\", str);\n    int len = strlen(str);\n    for (int i = len - 1; i >= 0; i--) {\n        printf(\"%c\", str[i]);\n    }\n    printf(\"\\n\");\n    return 0;\n}\n", "perturbed_sampled": ["#include <stdio.h> #include <string.h> int  str); int len = strlen(str); for   printf(\"\\n\"); return 0; }"], "perturbed_original": [" a[20];  printf(\"%c\",a[i]); return 0; }"], "original_ll": -1.2246224880218506, "sampled_ll": -0.5319109559059143, "all_perturbed_sampled_ll": [-3.0282397270202637], "all_perturbed_original_ll": [-3.1124305725097656], "perturbed_sampled_ll": -3.0282397270202637, "perturbed_original_ll": -3.1124305725097656, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import java.util.*;\n\nclass Main {\n    public static void main (String [] args) {\n\n        Scanner sc = new Scanner(System.in);\n\n        char [] str = sc.next().toCharArray();\n        for(int x = str.length-1; x >= 0; x--) {\n            System.out.print(str[x]);\n        }\n\n        System.out.print(\"\\n\");\n    }\n}", "sampled": "import java.util.Scanner;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        String str = sc.next();\n        StringBuilder sb = new StringBuilder(str);\n        System.out.println(sb.reverse().toString());\n        sc.close();\n    }\n}\n", "perturbed_sampled": ["  = new Scanner(System.in);  sb = new StringBuilder(str); System.out.println(sb.reverse().toString()); sc.close(); } }"], "perturbed_original": ["import  static void main (String [] args) { Scanner sc  x  System.out.print(\"\\n\"); } }"], "original_ll": -1.0607916116714478, "sampled_ll": -0.5665239691734314, "all_perturbed_sampled_ll": [-2.732276439666748], "all_perturbed_original_ll": [-3.9768364429473877], "perturbed_sampled_ll": -2.732276439666748, "perturbed_original_ll": -3.9768364429473877, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "print(input()[::-1])\n", "sampled": "s = input()\nprint(s[::-1])\n", "perturbed_sampled": ["s = input() print(s[::-1])"], "perturbed_original": ["print(input()[::-1])"], "original_ll": -5.215368747711182, "sampled_ll": -2.1085433959960938, "all_perturbed_sampled_ll": [-3.199462413787842], "all_perturbed_original_ll": [-4.715260982513428], "perturbed_sampled_ll": -3.199462413787842, "perturbed_original_ll": -4.715260982513428, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "main(){\n    int n,a=100000; scanf(\"%d\",&n);\n    while(n--){\n        a*=1.05;\n        if(a%1000>0) a=(a/1000+1)*1000;\n        else        a=a/1000*1000;\n    }\n    printf(\"%d\\n\",a);\n    exit(0);\n}", "sampled": "#include <stdio.h>\n\nint main() {\n    int n;\n    scanf(\"%d\", &n);\n    \n    int debt = 100000;\n    \n    for (int i = 0; i < n; i++) {\n        debt = debt * 105 / 100;\n        if (debt % 1000 != 0) {\n            debt = (debt / 1000 + 1) * 1000;\n        }\n    }\n    \n    printf(\"%d\\n\", debt);\n    \n    return 0;\n}\n", "perturbed_sampled": [" int  i = 0; i <  debt * 105 / 100;  0) { debt = (debt / 1000  0; }"], "perturbed_original": [" a*=1.05; if(a%1000>0) a=(a/1000+1)*1000; else a=a/1000*1000; } printf(\"%d\\n\",a); exit(0); }"], "original_ll": -1.2316865921020508, "sampled_ll": -0.6821125149726868, "all_perturbed_sampled_ll": [-2.765456438064575], "all_perturbed_original_ll": [-1.5339800119400024], "perturbed_sampled_ll": -2.765456438064575, "perturbed_original_ll": -1.5339800119400024, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\n\npublic class Main {\n\tpublic static void main(String[] args) throws IOException{\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\n\t\tdouble sum = 100000;   //????????????10??????\n\t\tint ??? = 0;\t\t\t//?????????????????\u00b1???\n\n\t\t??? = Integer.parseInt(br.readLine());\n\n\t\tfor(int i = 0; i < ???; i++){\n\t\t\tsum = sum * 1.05;\n\t\t\tsum = sum / 1000;\n\t\t\tsum = Math.ceil(sum) * 1000;\n\t\t}\n\n\t\tSystem.out.println(sum);\n\t}\n}", "sampled": "import java.util.Scanner;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int n = sc.nextInt();\n        \n        long debt = 100000;\n        \n        for (int i = 0; i < n; i++) {\n            debt = (long) Math.ceil(debt * 1.05 / 1000.0) * 1000;\n        }\n        \n        System.out.println(debt);\n        sc.close();\n    }\n}\n", "perturbed_sampled": [" { public static void  n = sc.nextInt(); long  < n; i++) { debt = (long)  sc.close(); } }"], "perturbed_original": [" java.io.InputStreamReader;  static void  br = new BufferedReader(new InputStreamReader(System.in)); double sum =  0;  = sum * 1.05; sum = sum / 1000; sum  System.out.println(sum); } }"], "original_ll": -1.2653131484985352, "sampled_ll": -0.7248121500015259, "all_perturbed_sampled_ll": [-4.730518817901611], "all_perturbed_original_ll": [-2.4989209175109863], "perturbed_sampled_ll": -4.730518817901611, "perturbed_original_ll": -2.4989209175109863, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "x = 100000\nfor i in range(int(input())):\n    x*=1.05\n    x+=999\n    x=x//1000*1000\nprint(x)", "sampled": "import math\n\nn = int(input())\ndebt = 100000\n\nfor _ in range(n):\n    debt = debt * 1.05\n    debt = math.ceil(debt / 1000) * 1000\n\nprint(int(debt))\n", "perturbed_sampled": ["import math n = int(input()) debt =  / 1000) * 1000 print(int(debt))"], "perturbed_original": [" in range(int(input())): x*=1.05 x+=999 x=x//1000*1000 print(x)"], "original_ll": -1.692051649093628, "sampled_ll": -1.1002912521362305, "all_perturbed_sampled_ll": [-3.3702478408813477], "all_perturbed_original_ll": [-2.4596784114837646], "perturbed_sampled_ll": -3.3702478408813477, "perturbed_original_ll": -2.4596784114837646, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "#include <stdio.h>\n#include <math.h>\n \n#define MAX 1000000\n \nchar Prime[MAX];\n \nvoid PrimeSearch_Eratos( void ) //\u30a8\u30e9\u30c8\u30b9\u30c6\u30cd\u30b9\u306e\u7be9\n{\n    int i = 0, j = 0;\n \n    for( i = 0 ; i < MAX ; i ++ ) Prime[i] = 1;\n \n    Prime[0] = 0;\n    Prime[1] = 0;\n \n    for( i = 2 ; i <= sqrt( ( double )MAX ) + 1 ; i ++ ) //double\u306b\u30ad\u30e3\u30b9\u30c8\u3057\u306a\u3044\u3068\n    {                                                   //\u30aa\u30fc\u30d0\u30fc\u30ed\u30fc\u30c9\u304c\u306a\u3093\u305f\u3089\n        if( !Prime[i] ) continue;                       //\uff08\u3000\u309c\u0434\u309c\uff09\u30dd\u30ab\u30f3\n \n        for( j = i * 2 ; j <= MAX ; j += i )\n        {\n            Prime[j] = 0;\n        }\n    }\n \n    return ;\n}\n \nint main( void )\n{\n    int n = 0;\n \n    PrimeSearch_Eratos();\n \n    while( scanf( \"%d\", &n ) != EOF )\n    {\n        int i = 0;\n        int Count = 0;\n \n        for( i = 0 ; i <= n ; i ++ )\n        {\n            if( Prime[i] ) Count ++;\n        }\n \n        printf( \"%d\\n\", Count );\n    }\n \n    return 0;\n}", "sampled": "#include <stdio.h>\n#include <string.h>\n#include <math.h>\n\n#define MAX 1000000\n\nint is_prime[MAX];\n\nvoid sieve() {\n    memset(is_prime, 1, sizeof(is_prime));\n    is_prime[0] = is_prime[1] = 0;\n    \n    for (int i = 2; i * i < MAX; i++) {\n        if (is_prime[i]) {\n            for (int j = i * i; j < MAX; j += i) {\n                is_prime[j] = 0;\n            }\n        }\n    }\n}\n\nint main() {\n    sieve();\n    \n    int prime_count[MAX];\n    prime_count[0] = 0;\n    for (int i = 1; i < MAX; i++) {\n        prime_count[i] = prime_count[i-1] + is_prime[i];\n    }\n    \n    int n;\n    while (scanf(\"%d\", &n) != EOF) {\n        printf(\"%d\\n\", prime_count[n]);\n    }\n    \n    return 0;\n}\n", "perturbed_sampled": ["#include <extra_id_5>} } if (!is_prime[i)]<extra_id_6>print(\"%d\\n\",<extra_id_7>(int i is_prime[MAX]; void sieve() { memset(is_prime, 1, sizeof(is_prime)); is_prime[0] <extra_id_8>{ printf(\"%d\\n\", is_prime[j]); }<extra_id_9>{ printf(\"%d\\n\", prime_count[j]); }<extra_id_10>return -1;<extra_id_11>i++) { printf(\"%d\\n\",<extra_id_12>prime MAX; i++) { if (is_prime[i]) { for (int  += i) { is_prime[j] = 0;   prime_count[0] = 0; for (int i  i++) {  { printf(\"%d\\n\", prime_count[n]); } return 0; }"], "perturbed_original": ["#include <stdio.h> #include <math.h> #define MAX 1000000 char  //\u30a8\u30e9\u30c8\u30b9\u30c6\u30cd\u30b9\u306e\u7be9 { int i = 0,  = 0  = 1; Prime[0] = 0; Prime[1]  sqrt( ( double )MAX )   !Prime[i]  j = i * 2   } return ; }  PrimeSearch_Eratos(); while( scanf( \"%d\",  { int i =  for( i = 0 ;   printf( \"%d\\n\",  }"], "original_ll": -1.252685308456421, "sampled_ll": -0.414530485868454, "all_perturbed_sampled_ll": [-2.445002317428589], "all_perturbed_original_ll": [-2.822242021560669], "perturbed_sampled_ll": -2.445002317428589, "perturbed_original_ll": -2.822242021560669, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import java.util.*;\nimport java.io.*;\n\npublic class Main {\n\tpublic static void main(String[] args) throws Exception {\n\t\tBufferedReader in = new BufferedReader(new InputStreamReader(System.in));\n\t\tString line = in.readLine();\n\t\twhile (line != null) {\n\t\t\tStringTokenizer tk = new StringTokenizer(line);\n\t\t\tint n = Integer.parseInt(tk.nextToken());\n\t\t\tQueue<Integer> queue = new LinkedList<Integer>();\n\t\t\tfor(int i = 2; i <= n; i++) {\n\t\t\t\tqueue.add(i);\n\t\t\t}\n\t\t\tint p = queue.remove();\n\t\t\tqueue.add(p);\n\t\t\tdo {\n\t\t\t\twhile (queue.element() != p) {\n\t\t\t\t\tint temp = queue.remove();\n\t\t\t\t\tif (temp % p != 0) {\n\t\t\t\t\t\tqueue.add(temp);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tqueue.add(queue.remove());\n\t\t\t\tp = queue.remove();\n\t\t\t\tqueue.add(p);\n\t\t\t} while (p != 2);\n\t\t\t\n\t\t\tint length = 0;\n\t\t\twhile (!queue.isEmpty()){\n\t\t\t\tlength ++;\n\t\t\t\tqueue.remove();\n\t\t\t}\n\t\t\tSystem.out.println(length);\n\t\t\tline = in.readLine();\n\t\t}\n\t}\n}", "sampled": "import java.util.Scanner;\n\npublic class Main {\n    private static final int MAX = 1000000;\n    private static boolean[] isPrime;\n    private static int[] primeCount;\n    \n    static {\n        isPrime = new boolean[MAX + 1];\n        primeCount = new int[MAX + 1];\n        \n        // Sieve of Eratosthenes\n        for (int i = 2; i <= MAX; i++) {\n            isPrime[i] = true;\n        }\n        \n        for (int i = 2; i * i <= MAX; i++) {\n            if (isPrime[i]) {\n                for (int j = i * i; j <= MAX; j += i) {\n                    isPrime[j] = false;\n                }\n            }\n        }\n        \n        // Precompute prime counts\n        int count = 0;\n        for (int i = 0; i <= MAX; i++) {\n            if (i >= 2 && isPrime[i]) {\n                count++;\n            }\n            primeCount[i] = count;\n        }\n    }\n    \n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        \n        while (sc.hasNextInt()) {\n            int n = sc.nextInt();\n            System.out.println(primeCount[n]);\n        }\n        \n        sc.close();\n    }\n}\n", "perturbed_sampled": [" int   primeCount; static { isPrime = new boolean[MAX + 1]; primeCount = new int[MAX + 1];  i <= MAX; i++)  <=   <= MAX; j += i) {  = 0; i <= MAX; i++) { if (i  count++; } primeCount[i]  { Scanner sc  { int n = sc.nextInt(); System.out.println(primeCount[n]); } sc.close(); } }"], "perturbed_original": [" static  new  null) { StringTokenizer tk  = new LinkedList<Integer>(); for(int i = 2; i <= n; i++) { queue.add(i); } int p = queue.remove(); queue.add(p); do { while (queue.element()  =  !=  = 0; while (!queue.isEmpty()){ length ++; queue.remove();  } } }"], "original_ll": -0.7623087167739868, "sampled_ll": -0.3652052879333496, "all_perturbed_sampled_ll": [-2.849510908126831], "all_perturbed_original_ll": [-3.367949962615967], "perturbed_sampled_ll": -2.849510908126831, "perturbed_original_ll": -3.367949962615967, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import math\nimport sys\n\nlst=[0 for _ in xrange(999999+1)]\n\ndef is_prime(num):\n  if num%2==0:\n      return 0\n  for x in range(3, int(num**0.5)+1,2):\n    if num % x==0:\n        return 0\n  return 1\n\nlst[1]=0\nlst[2]=1\nfor idx in range(3, len(lst)):\n  lst[idx] = is_prime(idx) + lst[idx-1]\n\nfor line in sys.stdin:\n  print lst[int(line)]", "sampled": "def sieve_of_eratosthenes(limit):\n    if limit < 2:\n        return []\n    is_prime = [True] * (limit + 1)\n    is_prime[0] = is_prime[1] = False\n    \n    for i in range(2, int(limit**0.5) + 1):\n        if is_prime[i]:\n            for j in range(i*i, limit + 1, i):\n                is_prime[j] = False\n    \n    return is_prime\n\nmax_n = 999999\nis_prime = sieve_of_eratosthenes(max_n)\nprime_count = [0] * (max_n + 1)\n\ncount = 0\nfor i in range(max_n + 1):\n    if is_prime[i]:\n        count += 1\n    prime_count[i] = count\n\nimport sys\nfor line in sys.stdin:\n    n = int(line.strip())\n    print(prime_count[n])\n", "perturbed_sampled": ["def sieve_of_eratosthenes(limit):   range(i*i, limit +  return is_prime max_n = 999999 is_prime = sieve_of_eratosthenes(max_n) prime_count =  1): if is_prime[i]: count += 1 prime_count[i] = count import sys for line in sys.stdin: n = int(line.strip()) print(prime_count[n])"], "perturbed_original": [" for _ in xrange(999999+1)] def is_prime(num): if  num % x==0: return  for  for line in sys.stdin: print lst[int(line)]"], "original_ll": -1.1872968673706055, "sampled_ll": -0.5776638388633728, "all_perturbed_sampled_ll": [-2.409733772277832], "all_perturbed_original_ll": [-3.998103380203247], "perturbed_sampled_ll": -2.409733772277832, "perturbed_original_ll": -3.998103380203247, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "#include <stdio.h>\n#include <math.h>\n\nint main(int argc, const char * argv[])\n{\n\n    double x1, y1, x2, y2, x3, y3;\n    double midx1, midx2, midy1, midy2;\n    double circlex, circley;\n    double slant1, slant2;\n    double slice1, slice2;\n    double radius;\n    int i;\n    int input;\n    \n    scanf(\"%d\", &input);\n    for (i = 0; i < input; i++) {\n        scanf(\"%lf %lf %lf %lf %lf %lf\", &x1, &y1, &x2, &y2, &x3, &y3);\n        midx1 = (x1 + x2) / 2;\n        midy1 = (y1 + y2) / 2;\n        midx2 = (x1 + x3) / 2;\n        midy2 = (y1 + y3) / 2;\n        slant1 = - (x2 - x1) / (y2 - y1);\n        slant2 = - (x3 - x1) / (y3 - y1);\n        slice1 = midy1 - slant1 * midx1;\n        slice2 = midy2 - slant2 * midx2;\n        circlex = (slice2 - slice1) / (slant1 - slant2);\n        circley = slant1 * circlex + slice1;\n        \n        if (x2 == x1) {\n            circley = midy1;\n            circlex = (circley - slice2) / slant2;\n        }\n        else if (y2 == y1) {\n            circlex = midx1;\n            circley = slant2 * circlex + slice2;\n        }\n        if(x3 == x1) {\n            circley = midy2;\n            circlex = (circley - slice1) / slant1;\n        }\n        else if (y3 == y1) {\n            circlex = midx2;\n            circley = slant1 * circlex + slice1;\n        }\n        if (x2 == x1 && y3 == y1) {\n            circley = midy1;\n            circlex = midx2;\n        }\n        else if (x3 == x1 && y2 == y1){\n            circley = midy2;\n            circlex = midx1;\n        }\n        radius = sqrt((circlex - x1) * (circlex - x1) + (circley - y1) * (circley - y1));\n        printf(\"%0.3f %0.3f %0.3f\\n\", circlex, circley, radius);\n    }\n    return 0;\n}", "sampled": "#include <stdio.h>\n#include <math.h>\n\nint main() {\n    int n;\n    scanf(\"%d\", &n);\n    \n    while (n--) {\n        double x1, y1, x2, y2, x3, y3;\n        scanf(\"%lf %lf %lf %lf %lf %lf\", &x1, &y1, &x2, &y2, &x3, &y3);\n        \n        double a = 2 * (x2 - x1);\n        double b = 2 * (y2 - y1);\n        double c = x2 * x2 - x1 * x1 + y2 * y2 - y1 * y1;\n        \n        double d = 2 * (x3 - x1);\n        double e = 2 * (y3 - y1);\n        double f = x3 * x3 - x1 * x1 + y3 * y3 - y1 * y1;\n        \n        double px = (c * e - b * f) / (a * e - b * d);\n        double py = (a * f - c * d) / (a * e - b * d);\n        \n        double r = sqrt((px - x1) * (px - x1) + (py - y1) * (py - y1));\n        \n        printf(\"%.3f %.3f %.3f\\n\", px, py, r);\n    }\n    \n    return 0;\n}\n", "perturbed_sampled": ["#include <stdio.h> #include <math.h>  scanf(\"%d\", &n); while (n--) {  x3, y3; scanf(\"%lf %lf %lf  &x2, &y2, &x3, &y3);  b = 2  x2 - x1 * x1  (y3 - y1); double f = x3  x1 + y3 * y3 -  =   d); double py = (a * f - c *  double r = sqrt((px    r); } return 0; }"], "perturbed_original": ["#include  argv[]) { double x1,  double midx1, midx2, midy1, midy2; double circlex, circley; double slant1,  radius; int  {  &y2, &x3, &y3); midx1 = (x1 + x2) / 2; midy1 = (y1 + y2) / 2; midx2   y1); slant2 =  (y3 - y1); slice1 = midy1 - slant1 * midx1; slice2 = midy2 -  (slice2 - slice1) /  slant1  (x2 == x1) { circley =  * circlex  x1) { circley = midy2; circlex = (circley  y1)   slice1; }  = midx2; } else if (x3 == x1 && y2 == y1){   - x1) + (circley - y1) * (circley  return 0; }"], "original_ll": -0.6058400869369507, "sampled_ll": -0.3719322979450226, "all_perturbed_sampled_ll": [-2.572976589202881], "all_perturbed_original_ll": [-2.330106019973755], "perturbed_sampled_ll": -2.572976589202881, "perturbed_original_ll": -2.330106019973755, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import java.util.Scanner;\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tScanner s=new Scanner(System.in);\n\t\tint n;\n\t\tdouble x1,x2,x3,y1,y2,y3,xp,yp,r,a1,a2,b1,b2,c1,c2,a,b;\n\t\tn=s.nextInt();\n\t\tfor(int i=0;i<n;i++){\n\t\t\tx1=s.nextDouble();\n\t\t\ty1=s.nextDouble();\n\t\t\tx2=s.nextDouble();\n\t\t\ty2=s.nextDouble();\n\t\t\tx3=s.nextDouble();\n\t\t\ty3=s.nextDouble();\n\t\t\t\n\t\t\ta1=2*(x1-x2);//a\n\t\t\tb1=2*(y1-y2);//b\n\t\t\t//c\n\t\t\tc1=(x1*x1)-(x2*x2)+(y1*y1)-(y2*y2);\n\t\t\ta2=2*(x2-x3);//d\n\t\t\tb2=2*(y2-y3);//e\n\t\t\tc2=(x2*x2)-(x3*x3)+(y2*y2)-(y3*y3);\n\t\t\t\n\t\t\tif(c1*b2-b1*c2==0 ||a1*b2-a2*b1==0)xp=0;\n\t\t\telse\n\t\t\txp=(c1*b2-b1*c2)/(a1*b2-a2*b1);\n\t\t\tif(c1*a2-c2*a1==0 ||a2*b1-a1*b2==0)yp=0;\n\t\t\telse\n\t\t\typ=(c1*a2-c2*a1)/(a2*b1-a1*b2);\n\t\t\t\n\t\t\ta=xp-x1;\n\t\t\ta=a*a;\n\t\t\tb=yp-y1;\n\t\t\tb=b*b;\n\t\t\tr=Math.sqrt(a+b);\n\t\t\tif(r==0)\n\t\t\t\tr=0;\n\t\t\tSystem.out.printf(\"%.3f %.3f %.3f\\n\",xp,yp,r);\n\t\t}//for\n\t}\n}", "sampled": "import java.util.Scanner;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int n = sc.nextInt();\n        \n        for (int i = 0; i < n; i++) {\n            double x1 = sc.nextDouble();\n            double y1 = sc.nextDouble();\n            double x2 = sc.nextDouble();\n            double y2 = sc.nextDouble();\n            double x3 = sc.nextDouble();\n            double y3 = sc.nextDouble();\n            \n            double a = 2 * (x2 - x1);\n            double b = 2 * (y2 - y1);\n            double c = x1 * x1 - x2 * x2 + y1 * y1 - y2 * y2;\n            \n            double d = 2 * (x3 - x1);\n            double e = 2 * (y3 - y1);\n            double f = x1 * x1 - x3 * x3 + y1 * y1 - y3 * y3;\n            \n            double px = (b * f - e * c) / (b * d - e * a);\n            double py = (d * c - a * f) / (b * d - e * a);\n            \n            double r = Math.sqrt((x1 - px) * (x1 - px) + (y1 - py) * (y1 - py));\n            \n            System.out.printf(\"%.3f %.3f %.3f\\n\", px, py, r);\n        }\n        \n        sc.close();\n    }\n}\n", "perturbed_sampled": ["import java.util.Scanner; public  void main(String[] args)  sc.nextInt(); for  < n; i++) { double x1 = sc.nextDouble(); double  = sc.nextDouble(); double y2  sc.nextDouble(); double  = 2 *  = x1  x2 + y1  2 * (x3 - x1); double e = 2 * (y3  x1  x3 + y1 * y1 -   e  (d * c - a *  double  * (x1 - px)  (y1  sc.close(); } }"], "perturbed_original": ["import java.util.Scanner; public   s=new Scanner(System.in); int  i=0;i<n;i++){ x1=s.nextDouble(); y1=s.nextDouble(); x2=s.nextDouble(); y2=s.nextDouble(); x3=s.nextDouble();  a2=2*(x2-x3);//d  yp=(c1*a2-c2*a1)/(a2*b1-a1*b2); a=xp-x1; a=a*a; b=yp-y1; b=b*b; r=Math.sqrt(a+b);  }//for } }"], "original_ll": -0.7100802659988403, "sampled_ll": -0.3787868618965149, "all_perturbed_sampled_ll": [-2.635096549987793], "all_perturbed_original_ll": [-2.3623602390289307], "perturbed_sampled_ll": -2.635096549987793, "perturbed_original_ll": -2.3623602390289307, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "# coding: utf-8\n\nimport math\n\nn = int(raw_input())\n\nfor i in range(n):\n\tdata = map(float, raw_input().split())\n\tx1 = data[0]\n\ty1 = data[1]\n\tx2 = data[2]\n\ty2 = data[3]\n\tx3 = data[4]\n\ty3 = data[5]\n\n\tk = 0.5 * ( (x3-x2)*(x3-x1) + (y3-y2)*(y3-y1) ) / ( (x2-x1)*(y3-y1) + (y2-y1)*(x3-x1) )\n\n\tx = 0.5 * (x1 + x2) - k * (y2 - y1)\n\ty = 0.5 * (y1 + y2) + k * (x2 - x1)\n\n\tr = math.sqrt( (x-x1)**2 + (y-y1)**2 )\n\n\tprint(\"{:.3f} {:.3f} {:.3f}\".format(x,y,r))", "sampled": "import math\n\ndef circumcircle(x1, y1, x2, y2, x3, y3):\n    # Calculate D (denominator)\n    D = 2 * (x1 * (y2 - y3) + x2 * (y3 - y1) + x3 * (y1 - y2))\n    \n    # Calculate center coordinates\n    ux = ((x1**2 + y1**2) * (y2 - y3) + (x2**2 + y2**2) * (y3 - y1) + (x3**2 + y3**2) * (y1 - y2)) / D\n    uy = ((x1**2 + y1**2) * (x3 - x2) + (x2**2 + y2**2) * (x1 - x3) + (x3**2 + y3**2) * (x2 - x1)) / D\n    \n    # Calculate radius\n    r = math.sqrt((x1 - ux)**2 + (y1 - uy)**2)\n    \n    return ux, uy, r\n\nn = int(input())\nfor _ in range(n):\n    coords = list(map(float, input().split()))\n    x1, y1, x2, y2, x3, y3 = coords\n    px, py, r = circumcircle(x1, y1, x2, y2, x3, y3)\n    print(f\"{px:.3f} {py:.3f} {r:.3f}\")\n", "perturbed_sampled": ["import math y4 = np._pi<extra_id_1>x3, y3<extra_id_2>)<extra_id_3>=<extra_id_4>if(x3 = 0<extra_id_5>;<extra_id_6>y1=(ux + y3)/1.0,<extra_id_7>=<extra_id_8>)<extra_id_9>y1)*/ # print(coords) # puts(coords)<extra_id_10>}<extra_id_11>(coords[i][0]) if((ux -<extra_id_12>-<extra_id_13>. x ) *<extra_id_14>(y2).x*(uv*uv- x3, y3): #  (y2 - y3) + x2 * (y3 - y1) + x3 * (y1  - y1) + (x3**2 + y3**2) * (y1  * (x3 - x2) + (x2**2 + y2**2)   = math.sqrt((x1 - ux)**2 + (y1 - uy)**2) return  range(n): coords = list(map(float, input().split()))  y3 = coords  y1,  {py:.3f} {r:.3f}\")"], "perturbed_original": [" n = int(raw_input()) for i in  x1 = data[0] y1 = data[1] x2 = data[2] y2 = data[3] x3   x2) - k * (y2 - y1) y   - x1) r = math.sqrt( (x-x1)**2  {:.3f}\".format(x,y,r))"], "original_ll": -0.6766015887260437, "sampled_ll": -0.46626317501068115, "all_perturbed_sampled_ll": [-2.60656476020813], "all_perturbed_original_ll": [-2.6464743614196777], "perturbed_sampled_ll": -2.60656476020813, "perturbed_original_ll": -2.6464743614196777, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "#include <stdio.h>\n\nvoid swap(int *a, int *b){\n  int t=*a;*a=*b;*b=t;\n}\n\nint main(void){\n  int w,n,i,l[31];\n  scanf(\"%d\\n\",&w);\n  scanf(\"%d\\n\",&n);\n  for(i=1;i<=w;i++){\n    l[i]=i;\n  }\n  for(i=0;i<n;i++) {\n    int a,b;\n    scanf(\"%d,%d\\n\",&a,&b);\n    swap(&l[a],&l[b]);\n  }\n  for(i=1;i<=w;i++){\n    printf(\"%d\\n\", l[i]);\n  }\n\n  return 0;\n}", "sampled": "#include <stdio.h>\n\nint main() {\n    int w, n;\n    int lines[31];\n    \n    scanf(\"%d\", &w);\n    scanf(\"%d\", &n);\n    \n    // Initialize vertical lines with numbers 1 to w\n    for (int i = 1; i <= w; i++) {\n        lines[i] = i;\n    }\n    \n    // Process each horizontal line\n    for (int i = 0; i < n; i++) {\n        int a, b;\n        scanf(\"%d,%d\", &a, &b);\n        \n        // Swap the values at positions a and b\n        int temp = lines[a];\n        lines[a] = lines[b];\n        lines[b] = temp;\n    }\n    \n    // Print the final state\n    for (int i = 1; i <= w; i++) {\n        printf(\"%d\\n\", lines[i]);\n    }\n    \n    return 0;\n}\n", "perturbed_sampled": ["#include <stdio.h> int  vertical lines with numbers 1 to w for (int i =  { lines[i] =  horizontal line  { int  // Swap the values at positions a and b  = lines[b];  Print  i  } return 0; }"], "perturbed_original": ["#include <stdio.h> void swap(int  } int main(void){ int  } for(i=0;i<n;i++) { int a,b;  }"], "original_ll": -0.9380918145179749, "sampled_ll": -0.7137984037399292, "all_perturbed_sampled_ll": [-4.145419597625732], "all_perturbed_original_ll": [-2.8698267936706543], "perturbed_sampled_ll": -4.145419597625732, "perturbed_original_ll": -2.8698267936706543, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import java.util.Scanner;\n\npublic class AOJ3_3{\n\tpublic static void main(String[] args){\n\t\tScanner sc = new Scanner(System.in);\n\t\tint w = sc.nextInt();\n\t\tint n = sc.nextInt();\n\t\tint[] values = new int[w];\n\t\tfor(int i=0;i<values.length;i++){\n\t\t\tvalues[i] = i + 1;\n\t\t}\n\t\tfor(int i = 0;i<n;i++){\n\t\t\tString str = sc.next();\n\t\t\tString[] ab = str.split(\",\");\n\t\t\tint a = Integer.parseInt(ab[0]) -1;\n\t\t\tint b = Integer.parseInt(ab[1]) -1;\n\t\t\tint temp = values[a];\n\t\t\tvalues[a] = values[b];\n\t\t\tvalues[b] = temp;\n\t\t}\n\t\tfor(int i = 0;i<w;i++){\n\t\t\tSystem.out.println(values[i]);\n\t\t}\n\t}\n}", "sampled": "import java.util.Scanner;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System);\n        \n        int w = sc.nextInt();\n        int n = sc.nextInt();\n        sc.nextLine();\n        \n        int[] lines = new int[w + 1];\n        for (int i = 1; i <= w; i++) {\n            lines[i] = i;\n        }\n        \n        for (int i = 0; i < n; i++) {\n            String line = sc.nextLine();\n            String[] parts = line.split(\",\");\n            int a = Integer.parseInt(parts[0]);\n            int b = Integer.parseInt(parts[1]);\n            \n            int temp = lines[a];\n            lines[a] = lines[b];\n            lines[b] = temp;\n        }\n        \n        for (int i = 1; i <= w; i++) {\n            System.out.println(lines[i]);\n        }\n        \n        sc.close();\n    }\n}\n", "perturbed_sampled": ["import java.util.Scanner; public class Main { public static void   = sc.nextInt(); int n = sc.nextInt(); sc.nextLine(); int[] lines =  i  = i; } for (int i = 0; i   =  = temp; } for  <=  sc.close(); } }"], "perturbed_original": ["import java.util.Scanner; public class AOJ3_3{ public static void main(String[]   int[] values = new int[w]; for(int i=0;i<values.length;i++){  0;i<n;i++){ String str  Integer.parseInt(ab[0])  -1;  temp; } for(int i = 0;i<w;i++){ System.out.println(values[i]); } } }"], "original_ll": -0.7829795479774475, "sampled_ll": -0.5010590553283691, "all_perturbed_sampled_ll": [-2.8224287033081055], "all_perturbed_original_ll": [-2.902661085128784], "perturbed_sampled_ll": -2.8224287033081055, "perturbed_original_ll": -2.902661085128784, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "# -*- coding: utf-8 -*-\n\n\ndef solve(w, n):\n    l = [i for i in range(1, w+1)]\n    for _ in range(n):\n        a, b = map(int, input().split(','))\n        l[a], l[b] = l[b], l[a]\n\n    print(*l, sep='\\n')\n\nif __name__ == '__main__':\n    w = int(input())\n    n = int(input())\n    solve(w, n)", "sampled": "w = int(input())\nn = int(input())\n\n# Initialize positions: position[i] = number at position i (0-indexed)\npositions = list(range(1, w + 1))\n\n# Process each horizontal line\nfor _ in range(n):\n    line = input().strip()\n    a, b = map(int, line.split(','))\n    # Swap the numbers at positions a-1 and b-1 (converting to 0-indexed)\n    positions[a-1], positions[b-1] = positions[b-1], positions[a-1]\n\n# Output the final positions\nfor num in positions:\n    print(num)\n", "perturbed_sampled": ["  = number at  list(range(1,   in range(n): line = input().strip() a, b =  numbers at positions  the final positions for num in positions: print(num)"], "perturbed_original": ["# -*- coding: utf-8 -*-  [i for i in  sep='\\n') if  int(input()) n = int(input()) solve(w, n)"], "original_ll": -0.8045748472213745, "sampled_ll": -1.1788392066955566, "all_perturbed_sampled_ll": [-5.056704044342041], "all_perturbed_original_ll": [-3.9673373699188232], "perturbed_sampled_ll": -5.056704044342041, "perturbed_original_ll": -3.9673373699188232, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "#include <stdio.h>\n\nint main() {\n\tint i = 0, k = 0, n, car[100] = {0}, out[100] = {0};\n\twhile(scanf(\"%d\", &n)!= EOF) {\n\t\tif(n == 0) {\n\t\t\ti--;\n\t\t\tout[k] = car[i];\n\t\t\tk++;\n\t\t} else {\n\t\t\tcar[i] = n;\n\t\t\ti++;\n\t\t}\n\t}\n\tfor(i = 0; i < k; i++) printf(\"%d\\n\", out[i]);\n\treturn 0;\n}", "sampled": "#include <stdio.h>\n\nint main() {\n    int stack[100];\n    int top = -1;\n    int input;\n    \n    while (scanf(\"%d\", &input) != EOF) {\n        if (input == 0) {\n            printf(\"%d\\n\", stack[top]);\n            top--;\n        } else {\n            top++;\n            stack[top] = input;\n        }\n    }\n    \n    return 0;\n}\n", "perturbed_sampled": ["#include  stack[100]; int  while (scanf(\"%d\", &input)  == 0) { printf(\"%d\\n\", stack[top]); top--; }  0; }"], "perturbed_original": ["#include <stdio.h>  0, n, car[100] = {0}, out[100] = {0}; while(scanf(\"%d\", &n)!= EOF) { if(n     i  return 0; }"], "original_ll": -0.9581671953201294, "sampled_ll": -0.6566348671913147, "all_perturbed_sampled_ll": [-2.703047275543213], "all_perturbed_original_ll": [-2.5904154777526855], "perturbed_sampled_ll": -2.703047275543213, "perturbed_original_ll": -2.5904154777526855, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import java.util.*;\n \npublic class Main {\n    public static void main(String[] args){\n        Scanner sc = new Scanner(System.in);\n        Stack<Integer> stack = new Stack<Integer>();\n        while(sc.hasNextInt()){\n            int a=sc.nextInt();\n            if(a==0){\n                System.out.println(stack.pop());\n            }else{\n                stack.push(a);\n            }\n        }\n    }\n}", "sampled": "import java.util.Scanner;\nimport java.util.Stack;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        Stack<Integer> stack = new Stack<>();\n        \n        while (sc.hasNext()) {\n            int num = sc.nextInt();\n            if (num == 0) {\n                System.out.println(stack.pop());\n            } else {\n                stack.push(num);\n            }\n        }\n        \n        sc.close();\n    }\n}\n", "perturbed_sampled": ["import java.util.Scanner; import  = new Scanner(System.in); Stack<Integer> stack = new Stack<>(); while  0)  stack.push(num); } } sc.close(); } }"], "perturbed_original": ["import java.util.*; public class  main(String[]   Stack<Integer>(); while(sc.hasNextInt()){ int a=sc.nextInt();  } } }"], "original_ll": -0.8031933307647705, "sampled_ll": -0.46601009368896484, "all_perturbed_sampled_ll": [-2.7630205154418945], "all_perturbed_original_ll": [-3.8356258869171143], "perturbed_sampled_ll": -2.7630205154418945, "perturbed_original_ll": -3.8356258869171143, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "a = []\nwhile True:\n    s = int(input())\n    if s != 0:\n        a.append(s)\n    else:\n        print(a.pop())\n    if len(a) == 0:\n        break", "sampled": "import sys\n\nstack = []\nfor line in sys.stdin:\n    num = int(line.strip())\n    if num == 0:\n        print(stack.pop())\n    else:\n        stack.append(num)\n", "perturbed_sampled": ["import  = int(line.strip()) if num == 0: print(stack.pop()) else: stack.append(num)"], "perturbed_original": ["a = [] while True: s = int(input())   0: break"], "original_ll": -1.2479687929153442, "sampled_ll": -1.087868571281433, "all_perturbed_sampled_ll": [-4.361737251281738], "all_perturbed_original_ll": [-4.407416820526123], "perturbed_sampled_ll": -4.361737251281738, "perturbed_original_ll": -4.407416820526123, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "#include <stdio.h>\n\nint main()\n{\n    int n, i;\n    long long int sum;\n    \n    while(scanf(\"%d\", &n) != EOF){\n    \tsum = 0;\n        for (i = n; i <= 600 - n; i += n){\n            sum += i * i;\n        }\n        sum *= n;\n        printf(\"%lld\\n\", sum);\n    }\n    return 0;\n}", "sampled": "#include <stdio.h>\n\nint main() {\n    int d;\n    while (scanf(\"%d\", &d) != EOF) {\n        long long area = 0;\n        for (int x = d; x <= 600 - d; x += d) {\n            area += (long long)d * x * x;\n        }\n        printf(\"%lld\\n\", area);\n    }\n    return 0;\n}\n", "perturbed_sampled": ["#include <stdio.h>  while (scanf(\"%d\", &d) != EOF) { long long area =  - d;   * x; }  }"], "perturbed_original": ["#include  int sum; while(scanf(\"%d\", &n) != EOF){ sum = 0;  i += n){  } sum *=  0; }"], "original_ll": -1.2436610460281372, "sampled_ll": -1.102943778038025, "all_perturbed_sampled_ll": [-3.301849365234375], "all_perturbed_original_ll": [-3.3732616901397705], "perturbed_sampled_ll": -3.301849365234375, "perturbed_original_ll": -3.3732616901397705, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "/**\n * \n * AOJ No. 0014 Integral\n * \n * @author \tyuichirw <y.iky917@gmail.com+>\n * @see\t\thttp://rose.u-aizu.ac.jp/onlinejudge/ProblemSet/description.jsp?id=0014&lang=jp\n */\n\nimport java.util.*;\npublic class Main {\n\t\n\tstatic Scanner sc = new Scanner(System.in);\n\tstatic int d;\n\t\n\tstatic boolean read() {\n\t\tif(!sc.hasNextInt()) return false;\n\t\td = sc.nextInt();\n\t\treturn true;\n\t}\n\t\n\tstatic int solve() {\n\t\tint ans,n;\n\t\tans = 0; n = 600 / d;\n\t\tfor(int x = d; x < 600; x += d) {\n\t\t\tans += d * ((x * x));\n\t\t}\n\t\treturn ans;\n\t}\n\t\n\t\n\tpublic static void main(String[] args) {\n\t\twhile(read()) {\n\t\t\tSystem.out.println(solve());\n\t\t}\n\t}\n\n}", "sampled": "import java.util.Scanner;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        \n        while (sc.hasNext()) {\n            int d = sc.nextInt();\n            long area = 0;\n            \n            for (int x = d; x < 600; x += d) {\n                area += (long) d * x * x;\n            }\n            \n            System.out.println(area);\n        }\n        \n        sc.close();\n    }\n}\n", "perturbed_sampled": ["import java.util.Scanner;  { Scanner sc =  long area = 0; for (int x = d;  d)  } System.out.println(area); } sc.close(); } }"], "perturbed_original": ["/**   <y.iky917@gmail.com+> * @see http://rose.u-aizu.ac.jp/onlinejudge/ProblemSet/description.jsp?id=0014&lang=jp */ import java.util.*; public class Main {  Scanner(System.in); static int d;  return false; d = sc.nextInt();  solve()  600;  += d *  void main(String[] args) { while(read()) { System.out.println(solve()); } } }"], "original_ll": -1.7803517580032349, "sampled_ll": -0.9102402329444885, "all_perturbed_sampled_ll": [-3.5054144859313965], "all_perturbed_original_ll": [-3.563829183578491], "perturbed_sampled_ll": -3.5054144859313965, "perturbed_original_ll": -3.563829183578491, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "#!/usr/bin/env python\n#-*- coding:utf-8 -*-\n\nimport sys\nimport math\n\ndef rectArea(h, w):\n    return h * w\n\n\nfor d in sys.stdin:\n    area = 0\n    d = int(d)\n    for i in range(0, 600, d):\n        area += rectArea(i*i, d)\n\n    print(area)", "sampled": "import sys\n\nfor line in sys.stdin:\n    d = int(line.strip())\n    s = 0\n    x = d\n    while x <= 600 - d:\n        s += d * (x * x)\n        x += d\n    print(s)\n", "perturbed_sampled": ["import sys for line in sys.stdin:   d: s += d *  d print(s)"], "perturbed_original": ["#!/usr/bin/env python #-*- coding:utf-8 -*- import sys import math def rectArea(h,   += rectArea(i*i, d) print(area)"], "original_ll": -1.489491581916809, "sampled_ll": -1.4992849826812744, "all_perturbed_sampled_ll": [-4.545334815979004], "all_perturbed_original_ll": [-3.8096745014190674], "perturbed_sampled_ll": -4.545334815979004, "perturbed_original_ll": -3.8096745014190674, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "#include <stdio.h>\n\nint main(void)\n{\n\t__int64 a, b, sum;\n\tint keta;\n\tint n;\n\tint i;\n\t\n\tscanf(\"%d\", &n);\n\tfor (i = 0; i < n; i++){\n\t\tscanf(\"%I64u\", &a);\n\t\tscanf(\"%I64u\", &b);\n\t\tsum = a + b;\n\t\t\n\t\tketa = 1;\n\t\twhile (sum / 10 > 0){\n\t\t\tketa++;\n\t\t\tsum /= 10;\n\t\t}\n\t\t\n\t\tif (keta > 80){\n\t\t\tprintf(\"overflow\\n\");\n\t\t}\n\t\telse {\n\t\t\tsum = a + b;\n\t\t\tprintf(\"%I64u\\n\", sum);\n\t\t}\n\t}\n\treturn (0);\n}", "sampled": "#include <stdio.h>\n#include <string.h>\n#include <ctype.h>\n\nvoid reverseString(char *str) {\n    int len = strlen(str);\n    for (int i = 0; i < len / 2; i++) {\n        char temp = str[i];\n        str[i] = str[len - 1 - i];\n        str[len - 1 - i] = temp;\n    }\n}\n\nint main() {\n    int N;\n    scanf(\"%d\", &N);\n    \n    while (N--) {\n        char num1[105], num2[105], result[105];\n        scanf(\"%s %s\", num1, num2);\n        \n        int len1 = strlen(num1);\n        int len2 = strlen(num2);\n        \n        // Check if input has more than 80 digits\n        if (len1 > 80 || len2 > 80) {\n            printf(\"overflow\\n\");\n            continue;\n        }\n        \n        // Reverse the strings for easier addition\n        reverseString(num1);\n        reverseString(num2);\n        \n        int maxLen = (len1 > len2) ? len1 : len2;\n        int carry = 0;\n        int resultLen = 0;\n        \n        for (int i = 0; i < maxLen || carry; i++) {\n            int digit1 = (i < len1) ? (num1[i] - '0') : 0;\n            int digit2 = (i < len2) ? (num2[i] - '0') : 0;\n            \n            int sum = digit1 + digit2 + carry;\n            result[resultLen++] = (sum % 10) + '0';\n            carry = sum / 10;\n        }\n        \n        result[resultLen] = '\\0';\n        \n        // Check if result has more than 80 digits\n        if (resultLen > 80) {\n            printf(\"overflow\\n\");\n            continue;\n        }\n        \n        // Reverse result back\n        reverseString(result);\n        \n        printf(\"%s\\n\", result);\n    }\n    \n    return 0;\n}\n", "perturbed_sampled": ["#include <stdio.h> #include <string.h> #include <ctype.h> void reverseString(char  strlen(str); for (int  { char temp = str[i]; str[i] =  i] = temp; }  (N--) { char num1[105], num2[105], result[105];  len1 = strlen(num1); int len2 = strlen(num2); // Check if  80  printf(\"overflow\\n\");   reverseString(num2); int   i < maxLen || carry; i++) { int digit1 = (i < len1)  (i < len2) ? (num2[i] - '0')  digit1 + digit2 + carry; result[resultLen++] = (sum    Reverse  } return 0; }"], "perturbed_original": ["#include <stdio.h> int main(void) { __int64 a, b, sum; int keta; int n;  (i = 0; i  /  } else { sum = a  } return (0); }"], "original_ll": -1.007934331893921, "sampled_ll": -0.4213179349899292, "all_perturbed_sampled_ll": [-2.5803720951080322], "all_perturbed_original_ll": [-3.039654016494751], "perturbed_sampled_ll": -2.5803720951080322, "perturbed_original_ll": -3.039654016494751, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import java.math.BigInteger;\nimport java.util.Scanner;\n\npublic class Main {\n\n\tpublic static void main(String[] args) {\n\n\t\tScanner sc = new Scanner(System.in);\n\n\t\twhile (sc.hasNext()) {\n\t\t\tString s1 = sc.next();\n\t\t\tString s2 = sc.next();\n\t\t\tif (s1.length() > 80 || s2.length() > 80)\n\t\t\t\tSystem.out.println(\"overflow\");\n\t\t\tBigInteger b = new BigInteger(s1).add(new BigInteger(s2));\n\t\t\tSystem.out.println(b.toString().length() > 80 ? \"overflow\" : b);\n\t\t}\n\n\t}\n\n}", "sampled": "import java.util.*;\nimport java.math.BigInteger;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int n = sc.nextInt();\n        sc.nextLine();\n        \n        for (int i = 0; i < n; i++) {\n            String a = sc.nextLine().trim();\n            String b = sc.nextLine().trim();\n            \n            if (a.length() > 80 || b.length() > 80) {\n                System.out.println(\"overflow\");\n                continue;\n            }\n            \n            BigInteger num1 = new BigInteger(a);\n            BigInteger num2 = new BigInteger(b);\n            BigInteger sum = num1.add(num2);\n            \n            String result = sum.toString();\n            if (result.length() > 80) {\n                System.out.println(\"overflow\");\n            } else {\n                System.out.println(result);\n            }\n        }\n        \n        sc.close();\n    }\n}\n", "perturbed_sampled": [" class Main { public static void main(String[] args)  Scanner(System.in);  i++) { String a = sc.nextLine().trim(); String b = sc.nextLine().trim(); if (a.length() > 80 || b.length()  } BigInteger num1 = new BigInteger(a); BigInteger  } }"], "perturbed_original": ["import java.math.BigInteger; import java.util.Scanner; public class Main  =   s2 = sc.next(); if (s1.length() > 80 || s2.length() >  : b); } } }"], "original_ll": -0.9025217890739441, "sampled_ll": -0.46931561827659607, "all_perturbed_sampled_ll": [-2.3816611766815186], "all_perturbed_original_ll": [-2.941267490386963], "perturbed_sampled_ll": -2.3816611766815186, "perturbed_original_ll": -2.941267490386963, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "n = input()\n\nfor i in range(n):\n    a = input(),\n    b = input()\n    c = a + b\n    if len(a) > 80 or len(b) > 80 or len(c) > 80 :\n        print 'overflow'\n    else:\n        print a + b", "sampled": "N = int(input())\nfor _ in range(N):\n    a = input().strip()\n    b = input().strip()\n    \n    # Check if input integers have more than 80 digits\n    if len(a) > 80 or len(b) > 80:\n        print(\"overflow\")\n        continue\n    \n    # Convert to integers and calculate sum\n    num_a = int(a)\n    num_b = int(b)\n    result = num_a + num_b\n    \n    # Check if sum has more than 80 digits\n    if len(str(result)) > 80:\n        print(\"overflow\")\n    else:\n        print(result)\n", "perturbed_sampled": ["N = int(input()) for  input().strip() b = input().strip() #  more than 80  num_b  +  has more than 80 digits if len(str(result)) > 80: print(\"overflow\") else: print(result)"], "perturbed_original": ["n = input() for i  = a + b if  > 80 or  + b"], "original_ll": -1.3746049404144287, "sampled_ll": -0.8419777154922485, "all_perturbed_sampled_ll": [-3.299860715866089], "all_perturbed_original_ll": [-4.336894989013672], "perturbed_sampled_ll": -3.299860715866089, "perturbed_original_ll": -4.336894989013672, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "/*\nAizuOnline A0016\nTresure hunt\n*/\n#include <stdio.h>\n#include <math.h>\n#include <float.h>\n\ndouble x,y;\nint len,arg;\ndouble PAI=3.14159265;\n\nmain()\n{\n  x=0.0; y=0.0;\n  int argsum = 90; \n\n  while(EOF != scanf(\"%d,%d\",&len,&arg) && (len || arg))\n    {\n      x += cos(((double)argsum)*(PAI/180))*(double)len;\n      y += sin(((double)argsum)*(PAI/180))*(double)len;\n\n      //printf(\"%d:%d %d %d %d\\n\",(int)x,(int)y,argsum,len,arg);\n      argsum -= arg;\n    }\n  printf(\"%d\\n%d\\n\",(int)x,(int)y);\nreturn(0);\n}", "sampled": "#include <stdio.h>\n#include <math.h>\n\nint main() {\n    int d, t;\n    double x = 0.0, y = 0.0;\n    double angle = 90.0; // Start facing north (90 degrees from east)\n    \n    while(1) {\n        scanf(\"%d,%d\", &d, &t);\n        if(d == 0 && t == 0) break;\n        \n        // Move d steps in current direction\n        double rad = angle * M_PI / 180.0;\n        x += d * cos(rad);\n        y += d * sin(rad);\n        \n        // Turn clockwise by t degrees (subtract from angle)\n        angle -= t;\n    }\n    \n    printf(\"%d\\n%d\\n\", (int)x, (int)y);\n    \n    return 0;\n}\n", "perturbed_sampled": ["  y =  &t); if(d  direction double rad = angle * M_PI / 180.0; x += d * cos(rad); y += d * sin(rad); // Turn  from angle) angle -= t; }  }"], "perturbed_original": ["/*  #include  x=0.0; y=0.0; int  scanf(\"%d,%d\",&len,&arg) && (len || arg)) { x += cos(((double)argsum)*(PAI/180))*(double)len; y += sin(((double)argsum)*(PAI/180))*(double)len;   }"], "original_ll": -1.846888542175293, "sampled_ll": -0.9779632687568665, "all_perturbed_sampled_ll": [-3.638610363006592], "all_perturbed_original_ll": [-2.7073144912719727], "perturbed_sampled_ll": -3.638610363006592, "perturbed_original_ll": -2.7073144912719727, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\n\n\npublic class Main {\n\tpublic static void main(String[] aegs){\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\tint a = 0,c=0;\n\t\tString t = \"\";\n\t\tdouble counta =0,countb = 0;\n\t\tdouble rad = 90.0;\n\t\tdouble PI = Math.PI;\n\t\t\n\t\twhile(true){\n\t\t\n\t\t\ttry {\n\t\t\t\tt = br.readLine();\n\t\t\t} catch (IOException e) {\n\t\t\t\t// TODO \u81ea\u52d5\u751f\u6210\u3055\u308c\u305f catch \u30d6\u30ed\u30c3\u30af\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t\t\n\t\t\t\n\t\t\tString[] tt = t.split(\",\",0);\n\t\t\ta = Integer.parseInt(tt[0]);\n\t\t\tc = Integer.parseInt(tt[1]);\n\t\t\tif(a == 0 && c == 0){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\n\t\t\t\n\t\t\tcounta +=  (a * Math.sin(rad*PI/180d));\n\t\t\tcountb +=  (a * Math.cos(rad*PI/180d));\n\t\t\trad = rad - c;\n\t\t\t\n\t\t}\n\t\tSystem.out.println((int)countb);\n\t\tSystem.out.println((int)counta);\n\t\t\n\t}\n\n\n}", "sampled": "import java.util.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        \n        double x = 0;\n        double y = 0;\n        double angle = 90; // Starting facing north (90 degrees from east)\n        \n        while (true) {\n            String line = sc.nextLine();\n            String[] parts = line.split(\",\");\n            int d = Integer.parseInt(parts[0].trim());\n            int t = Integer.parseInt(parts[1].trim());\n            \n            if (d == 0 && t == 0) {\n                break;\n            }\n            \n            // Move d steps in current direction\n            double radians = Math.toRadians(angle);\n            x += d * Math.cos(radians);\n            y += d * Math.sin(radians);\n            \n            // Turn clockwise by t degrees (subtract because clockwise is negative rotation)\n            angle -= t;\n        }\n        \n        System.out.println((int)x);\n        System.out.println((int)y);\n    }\n}\n", "perturbed_sampled": ["import java.util.*; public class Main { public static void main(String[] args) { Scanner sc = new Scanner(System.in); double  facing north (90 degrees from east) while  Integer.parseInt(parts[1].trim()); if (d == 0 &&  steps  = Math.toRadians(angle); x  t degrees (subtract because   } }"], "perturbed_original": ["import java.io.BufferedReader; import java.io.IOException; import java.io.InputStreamReader; public class  int a = 0,c=0;  counta =0,countb = 0; double rad  Math.PI;  br.readLine(); } catch  \u81ea\u52d5\u751f\u6210\u3055\u308c\u305f catch \u30d6\u30ed\u30c3\u30af e.printStackTrace(); } String[] tt =    }  - c; } System.out.println((int)countb); System.out.println((int)counta); } }"], "original_ll": -1.1677932739257812, "sampled_ll": -0.9668667912483215, "all_perturbed_sampled_ll": [-3.4290099143981934], "all_perturbed_original_ll": [-3.116610527038574], "perturbed_sampled_ll": -3.4290099143981934, "perturbed_original_ll": -3.116610527038574, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import turtle\nk = turtle.Turtle()\nk.speed(0)\nk.left(90)\nwhile True:\n    x = map(int,raw_input().split(\",\"))\n    if x[0] == 0 and x[1] == 0:\n        break\n    else:\n        k.fd(x[0])\n        k.right(x[1])\n        continue\nprint int(k.xcor())\nprint int(k.ycor())", "sampled": "import math\n\nx = 0.0\ny = 0.0\nangle = 90.0  # Starting direction: north (90 degrees from east)\n\nwhile True:\n    line = input().strip()\n    d, t = map(int, line.split(','))\n    \n    if d == 0 and t == 0:\n        break\n    \n    # Move d steps in current direction\n    x += d * math.cos(math.radians(angle))\n    y += d * math.sin(math.radians(angle))\n    \n    # Turn clockwise by t degrees (subtract because clockwise is negative)\n    angle -= t\n\nprint(int(x))\nprint(int(y))\n", "perturbed_sampled": ["import  = 0.0 angle =  (90 degrees  =   and t == 0: break # Move d steps  # Turn clockwise  clockwise is negative) angle -= t print(int(x)) print(int(y))"], "perturbed_original": ["import  k.left(90)  if x[0] ==  break else: k.fd(x[0])  int(k.ycor())"], "original_ll": -1.2465925216674805, "sampled_ll": -1.2478376626968384, "all_perturbed_sampled_ll": [-4.6920294761657715], "all_perturbed_original_ll": [-4.206743240356445], "perturbed_sampled_ll": -4.6920294761657715, "perturbed_original_ll": -4.206743240356445, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "#include<stdio.h>\nint main(void)\n{\n    int a[5],i,j,k;\n    int x=0;\n\n    for(i=0;i<5;i++){\n        scanf(\"%d\",&a[i]);\n        for(j=0;j<5;j++){\n            if(a[i]>a[j]){\n                x=a[i];\n                a[i]=a[j];\n                a[j]=x;\n            }\n        }\n    }\n    for(k=0;k<5;k++){\n        printf(\"%d \",a[k]);\n    }\n    return 0;\n}", "sampled": "#include <stdio.h>\n\nint main() {\n    int arr[5];\n    int i, j, temp;\n    \n    for(i = 0; i < 5; i++) {\n        scanf(\"%d\", &arr[i]);\n    }\n    \n    for(i = 0; i < 4; i++) {\n        for(j = i + 1; j < 5; j++) {\n            if(arr[i] < arr[j]) {\n                temp = arr[i];\n                arr[i] = arr[j];\n                arr[j] = temp;\n            }\n        }\n    }\n    \n    for(i = 0; i < 5; i++) {\n        if(i > 0) printf(\" \");\n        printf(\"%d\", arr[i]);\n    }\n    printf(\"\\n\");\n    \n    return 0;\n}\n", "perturbed_sampled": ["#include <stdio.h> int main() { int   0;  for(j = i + 1; j  < arr[j]) {  arr[j];   < 5; i++) { if(i  arr[i]); } printf(\"\\n\"); return 0; }"], "perturbed_original": ["#include<stdio.h>  a[j]=x; } } } for(k=0;k<5;k++){ printf(\"%d \",a[k]); } return 0; }"], "original_ll": -0.6816065907478333, "sampled_ll": -0.38891369104385376, "all_perturbed_sampled_ll": [-2.9599721431732178], "all_perturbed_original_ll": [-2.1896910667419434], "perturbed_sampled_ll": -2.9599721431732178, "perturbed_original_ll": -2.1896910667419434, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import java.util.*;\n\nclass Int implements Comparable<Int>{\n\tpublic int i;\n\tInt(int i){this.i = i;}\n\tpublic int compareTo (Int I){return I.i - this.i;}\n}\n\npublic class Main {\n\t\n\tpublic static void main(String[] args) {\n\n\t\t//input\n\t\tScanner sc = new Scanner(System.in).useDelimiter(System.getProperty(\"line.separator\"));\n\t\tString[] s = sc.next().split(\"\\\\s\");\n\t\tInt[] ar = new Int[5];\n\t\tfor(int i=0;i<5;i++){ar[i] = new Int(Integer.parseInt(s[i]));}\n\t\t\n\t\t//calculation\n\t\tArrays.sort(ar);\n\t\t\n\t\t//output\n\t\tfor(int i=0;i<5;i++){\n\t\t\tSystem.out.print(ar[i].i);\n\t\t\tif(i < 4){System.out.print(\" \");}\n\t\t}\n\t\tSystem.out.println();\n\t}\n}", "sampled": "import java.util.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int[] arr = new int[5];\n        for (int i = 0; i < 5; i++) {\n            arr[i] = sc.nextInt();\n        }\n        Arrays.sort(arr);\n        for (int i = 4; i >= 0; i--) {\n            if (i == 4) {\n                System.out.print(arr[i]);\n            } else {\n                System.out.print(\" \" + arr[i]);\n            }\n        }\n        System.out.println();\n        sc.close();\n    }\n}\n", "perturbed_sampled": ["import java.util.*; public class Main {   < 5; i++) { arr[i]  i >= 0; i--) { if (i == 4)   } System.out.println(); sc.close(); } }"], "perturbed_original": ["import  i){this.i = i;}   static void main(String[] args) {  Scanner(System.in).useDelimiter(System.getProperty(\"line.separator\")); String[] s =  Int[5];  //calculation Arrays.sort(ar); //output for(int i=0;i<5;i++){ System.out.print(ar[i].i);  System.out.println(); } }"], "original_ll": -0.9853265881538391, "sampled_ll": -0.39581212401390076, "all_perturbed_sampled_ll": [-3.0477726459503174], "all_perturbed_original_ll": [-3.136531114578247], "perturbed_sampled_ll": -3.0477726459503174, "perturbed_original_ll": -3.136531114578247, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "a = map(int, raw_input().split())\na.sort()\na.reverse()\nprint \" \".join(map(str, a))", "sampled": "numbers = list(map(int, input().split()))\nnumbers.sort(reverse=True)\nprint(' '.join(map(str, numbers)))\n", "perturbed_sampled": [" print(' '.join(map(str, numbers)))"], "perturbed_original": ["a  print \" \".join(map(str, a))"], "original_ll": -1.4211068153381348, "sampled_ll": -1.1664936542510986, "all_perturbed_sampled_ll": [-3.008793830871582], "all_perturbed_original_ll": [-4.069783687591553], "perturbed_sampled_ll": -3.008793830871582, "perturbed_original_ll": -4.069783687591553, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "#include<stdio.h>\n\nint main(void)\n{\nint i,j;\n\nscanf(\"%d\",&i);\nj=1;\nfor(;i>0;i--){\nj*=i;\n}\nprintf(\"%d\\n\",j);\nreturn 0;\n}", "sampled": "#include <stdio.h>\n\nint main() {\n    int n;\n    long long factorial = 1;\n    \n    scanf(\"%d\", &n);\n    \n    for (int i = 1; i <= n; i++) {\n        factorial *= i;\n    }\n    \n    printf(\"%lld\\n\", factorial);\n    \n    return 0;\n}\n", "perturbed_sampled": ["#include <stdio.h>  long long factorial = 1;  = 1; i   return 0; }"], "perturbed_original": ["#include<stdio.h> int main(void) {  0; }"], "original_ll": -1.2943612337112427, "sampled_ll": -0.5640527009963989, "all_perturbed_sampled_ll": [-3.327007532119751], "all_perturbed_original_ll": [-3.0581746101379395], "perturbed_sampled_ll": -3.327007532119751, "perturbed_original_ll": -3.0581746101379395, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import java.util.*;\nimport java.math.*;\n\npublic class Main{\n    public static void main(String[] args){\n\tScanner in = new Scanner(System.in);\n\tint a = in.nextInt();\n\tlong b = 1;\n\n\tfor(int i = 1 ; i <= a ; i++){\n\t    b = b*i;\n\t}\n\tSystem.out.println(b);\n    }\n}", "sampled": "import java.util.Scanner;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int n = sc.nextInt();\n        long factorial = 1;\n        for (int i = 2; i <= n; i++) {\n            factorial *= i;\n        }\n        System.out.println(factorial);\n        sc.close();\n    }\n}\n", "perturbed_sampled": ["import java.util.Scanner; public class  sc = new Scanner(System.in); int n =  i++) { factorial *=  }"], "perturbed_original": [" in = new Scanner(System.in); int a = in.nextInt(); long b = 1; for(int  b = b*i; } System.out.println(b); } }"], "original_ll": -1.1288093328475952, "sampled_ll": -0.3806801736354828, "all_perturbed_sampled_ll": [-4.138921737670898], "all_perturbed_original_ll": [-2.470785140991211], "perturbed_sampled_ll": -4.138921737670898, "perturbed_original_ll": -2.470785140991211, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "s=int(input())\nans=1\nfor i in range(1,s+1):\n    ans *= i\n\nprint(ans)", "sampled": "n = int(input())\nresult = 1\nfor i in range(1, n + 1):\n    result *= i\nprint(result)\n", "perturbed_sampled": ["n = int(input()) result = 1  i print(result)"], "perturbed_original": ["s=int(input()) ans=1  *= i print(ans)"], "original_ll": -1.1240265369415283, "sampled_ll": -0.7729111313819885, "all_perturbed_sampled_ll": [-3.835073709487915], "all_perturbed_original_ll": [-4.944639682769775], "perturbed_sampled_ll": -3.835073709487915, "perturbed_original_ll": -4.944639682769775, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "#include <stdio.h>\n\nint main(void)\n{\n  char ch[81];\n  int i;\n\n  gets(ch);\n  for(i = 0; ch[i] != '\\0'; ++i)\n    {\n      if('a' <= ch[i] && ch[i] <= 'z')\n\t{\n\t  ch[i] -= 32;\n\t}\n    }\n  puts(ch);\n  return 0;\n}", "sampled": "#include <stdio.h>\n#include <ctype.h>\n\nint main() {\n    char c;\n    while ((c = getchar()) != EOF) {\n        putchar(toupper(c));\n    }\n    return 0;\n}\n", "perturbed_sampled": ["#include <stdio.h> #include <ctype.h> int main()  = getchar())  return 0; }"], "perturbed_original": ["#include <stdio.h> int main(void) { char ch[81];  0; ch[i] != '\\0'; ++i) { if('a' <= ch[i]  }"], "original_ll": -0.9261314868927002, "sampled_ll": -0.6540772318840027, "all_perturbed_sampled_ll": [-2.658203601837158], "all_perturbed_original_ll": [-2.9052023887634277], "perturbed_sampled_ll": -2.658203601837158, "perturbed_original_ll": -2.9052023887634277, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import java.util.Scanner;\n\npublic class Main {\n\n    public static void main(String[] args) {\n        Scanner s = new Scanner(System.in);\n\n        String input = s.nextLine();\n        System.out.println(input.toUpperCase());\n    }\n\n}", "sampled": "import java.util.Scanner;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        String text = sc.nextLine();\n        System.out.println(text.toUpperCase());\n        sc.close();\n    }\n}\n", "perturbed_sampled": ["import  public static void  = new Scanner(System.in);  sc.close(); } }"], "perturbed_original": ["import  public static  s  = s.nextLine(); System.out.println(input.toUpperCase()); } }"], "original_ll": -0.8742524981498718, "sampled_ll": -0.5600889325141907, "all_perturbed_sampled_ll": [-4.452174186706543], "all_perturbed_original_ll": [-4.62830924987793], "perturbed_sampled_ll": -4.452174186706543, "perturbed_original_ll": -4.62830924987793, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "print(input().upper())", "sampled": "print(input().upper())\n", "perturbed_sampled": ["print(input().upper())"], "perturbed_original": ["print(input().upper())"], "original_ll": -5.011203765869141, "sampled_ll": -5.220095634460449, "all_perturbed_sampled_ll": [-5.011203765869141], "all_perturbed_original_ll": [-5.011203765869141], "perturbed_sampled_ll": -5.011203765869141, "perturbed_original_ll": -5.011203765869141, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "#include <stdio.h>\n#include <math.h>\n\nconst double eps = 1e-10;\n\nint n;\ndouble x1, x2, x3, x4;\ndouble y1, y2, y3, y4;\n\n//\u5897\u52a0\u7387\u3092\u898b\u308b\u65b9\u6cd5\nint solve1() {\n    double r1 = (y2-y1)/(x2-x1);\n    double r2 = (y4-y3)/(x4-x3);\n    return (fabs(r1-r2) < eps);\n}\n\nint main() {\n    scanf(\"%d\", &n);\n    for(int i=0; i<n; ++i) {\n        scanf(\"%lf %lf %lf %lf %lf %lf %lf %lf\", &x1, &y1, &x2, &y2, &x3, &y3, &x4, &y4);\n\n        if(solve1()) {\n            printf(\"YES\\n\");\n        } else {\n            printf(\"NO\\n\");\n        }\n    }\n}\n", "sampled": "#include <stdio.h>\n#include <math.h>\n\nint main() {\n    int n;\n    double x1, y1, x2, y2, x3, y3, x4, y4;\n    double dx1, dy1, dx2, dy2;\n    double cross;\n    \n    scanf(\"%d\", &n);\n    \n    while (n--) {\n        scanf(\"%lf %lf %lf %lf %lf %lf %lf %lf\", \n              &x1, &y1, &x2, &y2, &x3, &y3, &x4, &y4);\n        \n        dx1 = x2 - x1;\n        dy1 = y2 - y1;\n        dx2 = x4 - x3;\n        dy2 = y4 - y3;\n        \n        cross = dx1 * dy2 - dy1 * dx2;\n        \n        if (fabs(cross) < 1e-9) {\n            printf(\"YES\\n\");\n        } else {\n            printf(\"NO\\n\");\n        }\n    }\n    \n    return 0;\n}\n", "perturbed_sampled": [" main() {  x2,  double dx1, dy1, dx2,   %lf  &x3, &y3, &x4,  x1; dy1 = y2 - y1; dx2 = x4 - x3; dy2 = y4 -  1e-9) { printf(\"YES\\n\"); }  return 0; }"], "perturbed_original": ["#include  n; double x1, x2, x3, x4; double y1, y2, y3,  double r2 =   &n); for(int i=0;  %lf %lf\",   printf(\"YES\\n\"); } else { printf(\"NO\\n\"); } } }"], "original_ll": -0.8315833210945129, "sampled_ll": -0.3878070116043091, "all_perturbed_sampled_ll": [-2.6842620372772217], "all_perturbed_original_ll": [-2.9476349353790283], "perturbed_sampled_ll": -2.6842620372772217, "perturbed_original_ll": -2.9476349353790283, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import java.util.*;\nimport static java.util.Arrays.*;\nimport static java.lang.Math.*;\n\n// AOJ 0021\npublic class Main {\n\n\tstatic Scanner sc = new Scanner(System.in);\n\tstatic int N;\n\tstatic final double EPS = 1e-8;\n\tpublic static void main(String[] args) {\n\t\tN = sc.nextInt();\n\t\tdouble[] x = new double[4], y = new double[4];\n\t\tfor (int i = 0; i < N; i++) {\n\t\t\tfor (int j = 0; j < 4; j++) {\n\t\t\t\tx[j] = sc.nextDouble();\n\t\t\t\ty[j] = sc.nextDouble();\n\t\t\t}\n\t\t\t\n\t\t\tComplex \n\t\t\t\tp1 = new Complex(x[0], y[0]),\n\t\t\t\tp2 = new Complex(x[1], y[1]),\n\t\t\t\tp3 = new Complex(x[2], y[2]),\n\t\t\t\tp4 = new Complex(x[3], y[3]);\n\t\t\t\n\t\t\tif (!isCross(p1, p2, p3, p4)) {\n\t\t\t\tSystem.out.println(\"YES\");\n\t\t\t} else {\n\t\t\t\tSystem.out.println(\"No\");\n\t\t\t}\n\t\t}\n\t}\n\t\n\tstatic boolean isCross(Complex p1, Complex p2, Complex p3, Complex p4) {\n\t\tdouble det = p1.sub(p2).crossProduct(p3.sub(p4));\n\t\tif (Math.abs(det) < Complex.EPS) {\n\t\t\treturn false;\n\t\t} else {\n\t\t\treturn true;\n\t\t}\n\t}\n}\n\nclass Complex {\n\tstatic final double EPS = 1e-10;\n\t\n\tdouble re, im;\n\t\n\tComplex (double r, double i) {\n\t\tre = r; im = i;\n\t}\n\n\tdouble arg() {\n\t\treturn Math.atan2(im, re);\n\t}\n\t\n\tdouble abs2() {\n\t\treturn re * re + im * im;\n\t}\n\t\n\tdouble abs() {\n\t\treturn Math.sqrt(abs2());\n\t}\n\t\n\tdouble innerProdut(Complex o) {\n\t\treturn re * o.re + im * o.im;\n\t}\n\t\n\tdouble crossProduct(Complex o) {\n\t\treturn re * o.im - im * o.re;\n\t}\n\t\n\tstatic Complex polar(double theta, double r) {\n\t\treturn new Complex(r * Math.cos(theta), r * Math.sin(theta));\n\t}\n\t\n\tComplex conj() {\n\t\treturn new Complex(re, -im);\n\t}\n\t\n\tComplex add(Complex o) {\n\t\treturn new Complex(re + o.re, im + o.im);\n\t}\n\n\tComplex sub(Complex o) {\n\t\treturn new Complex(re - o.re, im - o.im);\n\t}\n\t\n\tComplex mul(Complex o) {\n\t\treturn new Complex(re * o.re - im * o.im, re * o.im + im * o.re);\n\t}\n\t\n\tComplex div(Complex o) {\n\t\treturn new Complex((re * o.re + im * o.im) / o.abs2(), (im * o.re - re * o.im) / o.abs2());\n\t}\n}", "sampled": "import java.util.Scanner;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int n = sc.nextInt();\n        \n        for (int i = 0; i < n; i++) {\n            double x1 = sc.nextDouble();\n            double y1 = sc.nextDouble();\n            double x2 = sc.nextDouble();\n            double y2 = sc.nextDouble();\n            double x3 = sc.nextDouble();\n            double y3 = sc.nextDouble();\n            double x4 = sc.nextDouble();\n            double y4 = sc.nextDouble();\n            \n            double dx1 = x2 - x1;\n            double dy1 = y2 - y1;\n            double dx2 = x4 - x3;\n            double dy2 = y4 - y3;\n            \n            double cross = dx1 * dy2 - dy1 * dx2;\n            \n            if (Math.abs(cross) < 1e-9) {\n                System.out.println(\"YES\");\n            } else {\n                System.out.println(\"NO\");\n            }\n        }\n        \n        sc.close();\n    }\n}\n", "perturbed_sampled": ["import java.util.Scanner; public  void main(String[] args) { Scanner sc  =  0; i <  = sc.nextDouble(); double  = sc.nextDouble(); double y2 = sc.nextDouble(); double x3 =  double dx1 = x2 -   dy1 * dx2; if (Math.abs(cross) < 1e-9) { System.out.println(\"YES\"); }  sc.close(); } }"], "perturbed_original": ["import  0021 public class Main { static Scanner  int N; static  sc.nextInt(); double[] x = new double[4], y     = sc.nextDouble(); y[j] = sc.nextDouble(); } Complex p1 = new    System.out.println(\"YES\"); }  p1, Complex p2, Complex p3,  = p1.sub(p2).crossProduct(p3.sub(p4)); if (Math.abs(det) < Complex.EPS) { return false; }  } } class Complex { static final double EPS = 1e-10;  r, double i) { re = r; im = i; } double arg() { return  im;  Math.sqrt(abs2()); }  im  * o.re; } static Complex  return new Complex(r * Math.cos(theta), r    } Complex sub(Complex o) { return new Complex(re - o.re, im     im * o.re); } Complex div(Complex o) { return new Complex((re  * o.re -  } }"], "original_ll": -0.5575758814811707, "sampled_ll": -0.2856425344944, "all_perturbed_sampled_ll": [-2.3269331455230713], "all_perturbed_original_ll": [-2.7635600566864014], "perturbed_sampled_ll": -2.3269331455230713, "perturbed_original_ll": -2.7635600566864014, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "ans = []\nn = input()\nfor i in range(n):\n    x1,y1,x2,y2,x3,y3,x4,y4 = map(float,raw_input().split())\n    if ((y2-y1)/(x2-x1) == (y4-y3)/(x4-x3)):\n        ans.append('YES')\n    else:\n        ans.append('NO')\nfor i in ans:\n    print i", "sampled": "n = int(input())\nfor _ in range(n):\n    coords = list(map(float, input().split()))\n    x1, y1, x2, y2, x3, y3, x4, y4 = coords\n    \n    # Direction vectors\n    dx1 = x2 - x1\n    dy1 = y2 - y1\n    dx2 = x4 - x3\n    dy2 = y4 - y3\n    \n    # Two lines are parallel if their direction vectors are parallel\n    # This means the cross product should be zero\n    cross = dx1 * dy2 - dy1 * dx2\n    \n    if abs(cross) < 1e-9:\n        print(\"YES\")\n    else:\n        print(\"NO\")\n", "perturbed_sampled": ["n = int(input()) for _ in  x1, y1,  y4 =  dy1 =  = y4  # This means the  cross = dx1  dx2 if abs(cross) < 1e-9: print(\"YES\") else: print(\"NO\")"], "perturbed_original": ["ans = [] n = input() for  map(float,raw_input().split()) if  ans: print i"], "original_ll": -1.0076212882995605, "sampled_ll": -0.7236678600311279, "all_perturbed_sampled_ll": [-3.62802791595459], "all_perturbed_original_ll": [-4.158520221710205], "perturbed_sampled_ll": -3.62802791595459, "perturbed_original_ll": -4.158520221710205, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "#include <stdio.h>\n#include <math.h>\n\ntypedef struct\n{\n    double x;\n    double y;\n    double r;\n}circle;\n\nint main(void)\n{\n    int datasets;\n    scanf(\"%d\", &datasets);\n\n    while (datasets--) {\n        circle a, b;\n        scanf(\" %lf %lf %lf\", &(a.x), &(a.y), &(a.r));\n        scanf(\" %lf %lf %lf\", &(b.x), &(b.y), &(b.r));\n\n        double bigr, smallr;\n        if (a.r >=  b.r) {\n            bigr = a.r;\n            smallr = b.r;\n        } else {\n            bigr = b.r;\n            smallr = a.r;\n        }\n\n        double dist = pow(a.x - b.x, 2) + pow(a.y - b.y, 2);\n        dist = sqrt(dist);\n\n        int judge;\n        if (dist > bigr + smallr) {\n            judge = 0;\n        } else if (dist > bigr - smallr) {\n            judge = 1;\n        } else {\n            if (bigr == a.r) {\n                judge = 2;\n            } else {\n                judge = -2;\n            }\n        }\n\n        printf(\"%d\\n\", judge);\n    }\n\n    return 0;\n}", "sampled": "#include <stdio.h>\n#include <math.h>\n\nint main() {\n    int n;\n    scanf(\"%d\", &n);\n    \n    while (n--) {\n        double xa, ya, ra, xb, yb, rb;\n        scanf(\"%lf %lf %lf %lf %lf %lf\", &xa, &ya, &ra, &xb, &yb, &rb);\n        \n        double dist = sqrt((xa - xb) * (xa - xb) + (ya - yb) * (ya - yb));\n        \n        if (dist + rb < ra + 1e-9) {\n            printf(\"2\\n\");\n        } else if (dist + ra < rb + 1e-9) {\n            printf(\"-2\\n\");\n        } else if (dist < ra + rb + 1e-9 && dist + 1e-9 > fabs(ra - rb)) {\n            printf(\"1\\n\");\n        } else {\n            printf(\"0\\n\");\n        }\n    }\n    \n    return 0;\n}\n", "perturbed_sampled": [" { double xa,    &yb, &rb); double dist = sqrt((xa - xb) *  - yb)); if (dist + rb < ra + 1e-9)  rb + 1e-9 && dist + 1e-9 > fabs(ra - rb)) { printf(\"1\\n\"); }  return 0; }"], "perturbed_original": ["#include <stdio.h> #include <math.h> typedef struct { double  int datasets; scanf(\"%d\", &datasets); while (datasets--) { circle  scanf(\" %lf %lf  = a.r; smallr  bigr = b.r; smallr  = pow(a.x -   { judge   } else  { judge = 2; }  } } printf(\"%d\\n\", judge); } return 0; }"], "original_ll": -0.7601574063301086, "sampled_ll": -0.6355171203613281, "all_perturbed_sampled_ll": [-2.807995319366455], "all_perturbed_original_ll": [-3.30895733833313], "perturbed_sampled_ll": -2.807995319366455, "perturbed_original_ll": -3.30895733833313, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import java.util.Scanner;\n\nclass Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int n = sc.nextInt();\n        while (n-- > 0) {\n            Circle a = new Circle(sc.nextDouble(), sc.nextDouble(), sc.nextDouble());\n            Circle b = new Circle(sc.nextDouble(), sc.nextDouble(), sc.nextDouble());\n            double dx = b.x - a.x;\n            double dy = b.y - a.y;\n            double r = a.r + b.r;\n            double d = Math.sqrt(dx * dx + dy * dy);\n            if (d > r) {\n                System.out.println(0);\n            } else {\n                if (a.r < b.r && d + a.r < b.r) {\n                    System.out.println(-2);\n                } else if (a.r > b.r && d + b.r < a.r) {\n                    System.out.println(2);\n                } else {\n                    System.out.println(1);\n                }\n            }\n        }\n    }\n\n    static class Circle {\n        double x;\n        double y;\n        double r;\n\n        Circle(double x, double y, double r) {\n            this.x = x;\n            this.y = y;\n            this.r = r;\n        }\n    }\n}\n\n\n", "sampled": "import java.util.Scanner;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int n = sc.nextInt();\n        \n        for (int i = 0; i < n; i++) {\n            double xa = sc.nextDouble();\n            double ya = sc.nextDouble();\n            double ra = sc.nextDouble();\n            double xb = sc.nextDouble();\n            double yb = sc.nextDouble();\n            double rb = sc.nextDouble();\n            \n            double dist = Math.sqrt((xa - xb) * (xa - xb) + (ya - yb) * (ya - yb));\n            \n            if (dist + rb < ra || Math.abs(dist + rb - ra) < 1e-9) {\n                System.out.println(2);\n            } else if (dist + ra < rb || Math.abs(dist + ra - rb) < 1e-9) {\n                System.out.println(-2);\n            } else if (dist < ra + rb && dist > Math.abs(ra - rb)) {\n                System.out.println(1);\n            } else {\n                System.out.println(0);\n            }\n        }\n        \n        sc.close();\n    }\n}\n", "perturbed_sampled": [" main(String[] args)  sc.nextInt();  i < n; i++)  double  = sc.nextDouble(); double rb  Math.sqrt((xa - xb) * (xa - xb) + (ya  Math.abs(dist  1e-9) {  + ra < rb || Math.abs(dist + ra -  } else  Math.abs(ra - rb)) { System.out.println(1); } else { System.out.println(0); } } sc.close(); } }"], "perturbed_original": ["import java.util.Scanner; class Main { public static void main(String[] args)   Circle b = new Circle(sc.nextDouble(), sc.nextDouble(), sc.nextDouble()); double dx =  = b.y  dx + dy * dy); if (d >  b.r   if (a.r  b.r < a.r)  System.out.println(1); } }  y; double r; Circle(double x,  this.x =  = r; } } }"], "original_ll": -0.5142626762390137, "sampled_ll": -0.546619176864624, "all_perturbed_sampled_ll": [-2.7364912033081055], "all_perturbed_original_ll": [-2.9923720359802246], "perturbed_sampled_ll": -2.7364912033081055, "perturbed_original_ll": -2.9923720359802246, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "for a,b,r,c,d,s in[map(float,raw_input().split())for i in range(input())]:\n\td=(a-c)**2+(b-d)**2\n\tif d>(r+s)**2:print 0\n\telif d+min(r,s)>max(r,s):print 1\n\telif r>s:print 2\n\telse:print -2", "sampled": "import math\n\nn = int(input())\nfor _ in range(n):\n    xa, ya, ra, xb, yb, rb = map(float, input().split())\n    \n    # Calculate distance between centers\n    d = math.sqrt((xa - xb)**2 + (ya - yb)**2)\n    \n    # Check if B is in A\n    if d + rb <= ra:\n        print(2)\n    # Check if A is in B\n    elif d + ra <= rb:\n        print(-2)\n    # Check if circles intersect\n    elif d < ra + rb:\n        print(1)\n    # Circles do not overlap\n    else:\n        print(0)\n", "perturbed_sampled": ["<extra_id_4>(0)<extra_id_5>Check if<extra_id_6># check if<extra_id_7>D for _   input().split()) # Calculate distance between  B is in A if  print(2) # Check if  rb: print(-2) # Check if circles intersect elif d   else: print(0)"], "perturbed_original": ["for a,b,r,c,d,s in[map(float,raw_input().split())for  1 elif r>s:print 2 else:print -2"], "original_ll": -1.9853733777999878, "sampled_ll": -1.011813759803772, "all_perturbed_sampled_ll": [-4.375080108642578], "all_perturbed_original_ll": [-3.816474437713623], "perturbed_sampled_ll": -4.375080108642578, "perturbed_original_ll": -3.816474437713623, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "#include <stdio.h>\n#include <math.h>\n\nint main(){\n\tfloat v,t,y;\n\twhile(scanf(\"%f\",&v) != EOF){\n\t\tt = v / 9.8;\n\t\ty = t * t * 4.9;\n\t\tprintf(\"%d\\n\",(int)ceilf(y / 5.0) + 1);\n\t}\n\treturn 0;\n}", "sampled": "#include <stdio.h>\n#include <math.h>\n\nint main() {\n    double v;\n    while (scanf(\"%lf\", &v) != EOF) {\n        double t = v / 9.8;\n        double y = 4.9 * t * t;\n        int floor = (int)ceil((y + 5) / 5);\n        printf(\"%d\\n\", floor);\n    }\n    return 0;\n}\n", "perturbed_sampled": [" while (scanf(\"%lf\", &v) != EOF) { double t =   (int)ceil((y +  } return 0; }"], "perturbed_original": ["#include  EOF){ t = v  * t  + 1); } return 0; }"], "original_ll": -1.608237862586975, "sampled_ll": -1.1466416120529175, "all_perturbed_sampled_ll": [-3.3678736686706543], "all_perturbed_original_ll": [-4.922205924987793], "perturbed_sampled_ll": -3.3678736686706543, "perturbed_original_ll": -4.922205924987793, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import java.util.*;\n\npublic class Main {\n\tScanner sc = new Scanner(System.in);\n\tvoid doIt() {\n\t\twhile(true){\n\t\t\ttry{\n\t\t\t\tdouble v = sc.nextDouble();\n\t\t\t\tdouble t = v / 9.8;\n\t\t\t\tdouble y = 4.9 * t * t;\n\t\t\t\tint ans = (int) y / 5;\n\t\t\t\tdouble cnt = y % 5;\n\t\t\t\tif(cnt > 0){\n\t\t\t\t\tans++;\n\t\t\t\t\tSystem.out.println(ans);\n\t\t\t\t}else{\n\t\t\t\t\tSystem.out.println(ans);\n\t\t\t\t}\n\t\t\t}catch(Exception g){\n\t\t\t\tSystem.exit(0);\n\t\t\t}\n\t\t}\n\t}\n    public static void main(String[] args) {\n    \tnew Main().doIt();\n    }\n}", "sampled": "import java.util.Scanner;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        \n        while (sc.hasNext()) {\n            double v = sc.nextDouble();\n            \n            // From v = 9.8t, we get t = v / 9.8\n            double t = v / 9.8;\n            \n            // Drop distance y = 4.9 * t^2\n            double y = 4.9 * t * t;\n            \n            // Height of floor N is 5*N - 5\n            // We need to find smallest N such that 5*N - 5 >= y\n            // 5*N >= y + 5\n            // N >= (y + 5) / 5\n            \n            int floor = (int) Math.ceil((y + 5) / 5.0);\n            \n            System.out.println(floor);\n        }\n        \n        sc.close();\n    }\n}\n", "perturbed_sampled": ["import java.util.Scanner;  { Scanner sc = new Scanner(System.in); while (sc.hasNext()) { double  v   t = v / 9.8; //  of   that 5*N - 5 >= y // 5*N >= y  (y + 5)  (int) Math.ceil((y +  sc.close(); } }"], "perturbed_original": ["import   void  t = v / 9.8; double y = 4.9 * t * t; int ans  % 5; if(cnt   static void main(String[] args) { new Main().doIt(); } }"], "original_ll": -1.2170612812042236, "sampled_ll": -1.0458544492721558, "all_perturbed_sampled_ll": [-3.554539442062378], "all_perturbed_original_ll": [-3.6853039264678955], "perturbed_sampled_ll": -3.554539442062378, "perturbed_original_ll": -3.6853039264678955, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import sys\nimport math\nv=[]\nfor line in sys.stdin:\n    v.append(float(line))\nfor i in range(len(v)):\n    print math.ceil(v[i]**2/98+1),", "sampled": "import sys\nimport math\n\nfor line in sys.stdin:\n    v = float(line.strip())\n    \n    # From v = 9.8 * t, we get t = v / 9.8\n    t = v / 9.8\n    \n    # From y = 4.9 * t^2\n    y = 4.9 * t * t\n    \n    # Height of floor N is 5*N - 5\n    # We need 5*N - 5 >= y\n    # 5*N >= y + 5\n    # N >= (y + 5) / 5\n    \n    N = math.ceil((y + 5) / 5)\n    \n    print(N)\n", "perturbed_sampled": ["import sys import math  = float(line.strip()) # From  we get t = v / 9.8 t =  y =  t # Height  + 5) / 5 N = math.ceil((y + 5) / 5) print(N)"], "perturbed_original": ["import sys import math v=[]  print math.ceil(v[i]**2/98+1),"], "original_ll": -2.009835720062256, "sampled_ll": -1.18108332157135, "all_perturbed_sampled_ll": [-4.10006856918335], "all_perturbed_original_ll": [-5.7484917640686035], "perturbed_sampled_ll": -4.10006856918335, "perturbed_original_ll": -5.7484917640686035, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "#include <stdio.h>\n\nint main(){\n\tint A[4], B[4];\n\tint a, b;\n\tint hit, blow;\n\n\twhile( scanf(\"%d%d%d%d\",&A[0],&A[1],&A[2],&A[3]) != EOF ){\n\t\tscanf(\"%d%d%d%d\",&B[0],&B[1],&B[2],&B[3]);\n\n\t\thit=blow=0;\n\n\t\tfor( a=0; a<4; a++ ){\n\t\t\tfor( b=0; b<4; b++ ){\n\t\t\t\tif( A[a] == B[b] ){\n\t\t\t\t\t(a==b)? hit++ : blow++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tprintf(\"%d %d\\n\", hit, blow);\n\t}\n\n\treturn 0;\n}\n\t", "sampled": "#include <stdio.h>\n\nint main() {\n    int a[4], b[4];\n    \n    while(scanf(\"%d %d %d %d\", &a[0], &a[1], &a[2], &a[3]) != EOF) {\n        scanf(\"%d %d %d %d\", &b[0], &b[1], &b[2], &b[3]);\n        \n        int hit = 0, blow = 0;\n        \n        // Count hits\n        for(int i = 0; i < 4; i++) {\n            if(a[i] == b[i]) {\n                hit++;\n            }\n        }\n        \n        // Count blows\n        for(int i = 0; i < 4; i++) {\n            for(int j = 0; j < 4; j++) {\n                if(i != j && a[i] == b[j]) {\n                    blow++;\n                }\n            }\n        }\n        \n        printf(\"%d %d\\n\", hit, blow);\n    }\n    \n    return 0;\n}\n", "perturbed_sampled": [" int a[4], b[4]; while(scanf(\"%d %d %d %d\", &a[0], &a[1],   hit  // Count hits for(int i = 0; i < 4;  {   { for(int j = 0; j < 4;  } printf(\"%d  0; }"], "perturbed_original": ["#include <stdio.h> int main(){ int A[4], B[4]; int a, b; int   for(  %d\\n\", hit, blow); } return 0; }"], "original_ll": -0.8885037302970886, "sampled_ll": -0.4144812822341919, "all_perturbed_sampled_ll": [-2.4136202335357666], "all_perturbed_original_ll": [-3.2111637592315674], "perturbed_sampled_ll": -2.4136202335357666, "perturbed_original_ll": -3.2111637592315674, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import java.util.*;\n\npublic class Main {\n\n\tprivate void doit() {\n\t\tScanner sc = new Scanner(System.in);\n\t\twhile(sc.hasNext()){\n\t\t\tint [] a = new int[4];\n\t\t\tint [] b = new int[4];\n\t\t\tfor(int i = 0; i < 4; i++){\n\t\t\t\ta[i] = sc.nextInt();\n\t\t\t}\n\t\t\tfor(int i =0; i < 4; i++){\n\t\t\t\tb[i] = sc.nextInt();\n\t\t\t}\n\t\t\tint hit=0;\n\t\t\tint blow = 0;\n\t\t\tfor(int i =0; i < 4; i++){\n\t\t\t\tfor(int j =i; j < 4; j++){\n\t\t\t\t\tif(a[i] == b[j]){\n\t\t\t\t\t\tif(i == j)\n\t\t\t\t\t\t\thit++;\n\t\t\t\t\t\telse{\n\t\t\t\t\t\t\tblow++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(hit + \" \" + blow);\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tMain obj = new Main();\n\t\tobj.doit();\n\t}\n}", "sampled": "import java.util.Scanner;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        \n        while (sc.hasNext()) {\n            int[] a = new int[4];\n            int[] b = new int[4];\n            \n            for (int i = 0; i < 4; i++) {\n                a[i] = sc.nextInt();\n            }\n            for (int i = 0; i < 4; i++) {\n                b[i] = sc.nextInt();\n            }\n            \n            int hit = 0;\n            int blow = 0;\n            \n            for (int i = 0; i < 4; i++) {\n                if (a[i] == b[i]) {\n                    hit++;\n                } else {\n                    for (int j = 0; j < 4; j++) {\n                        if (i != j && a[i] == b[j]) {\n                            blow++;\n                            break;\n                        }\n                    }\n                }\n            }\n            \n            System.out.println(hit + \" \" + blow);\n        }\n        \n        sc.close();\n    }\n}\n", "perturbed_sampled": ["import java.util.Scanner;   Scanner(System.in); while (sc.hasNext())  int[4]; int[] b = new int[4]; for (int i =  { a[i] = sc.nextInt(); } for (int i =  0; for  if  (int j = 0; j < 4; j++) { if (i !=  } }  + blow); } sc.close(); } }"], "perturbed_original": ["import java.util.*; public = new ();<extra_id_2>void test()<extra_id_3>i++<extra_id_4>for(<extra_id_5>; j<extra_id_6>} sc.close(); }<extra_id_7>} public void<extra_id_8>; blow<extra_id_9>i >= 4<extra_id_10>) { blow =<extra_id_11>(<extra_id_12>{<extra_id_13>) * 0 ;<extra_id_14>{<extra_id_15>= 1<extra_id_16>int i =<extra_id_17>blow ,<extra_id_18>; }<extra_id_19>s<extra_id_20>int k ) {<extra_id_21>] = 0<extra_id_22>return j ; i =<extra_id_23>] < b [ j<extra_id_24> new   for(int i = 0;  i  b[i] = sc.nextInt(); }  0; for(int i =0; i < 4; i++){ for(int j  == j) hit++; else{  System.out.println(hit + \" \" + blow);  main(String[] args) { Main obj  }"], "original_ll": -0.7011843919754028, "sampled_ll": -0.39263781905174255, "all_perturbed_sampled_ll": [-2.520172119140625], "all_perturbed_original_ll": [-2.5130703449249268], "perturbed_sampled_ll": -2.520172119140625, "perturbed_original_ll": -2.5130703449249268, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import sys\nfor i in sys.stdin:\n    arrA,arrB = [],[]\n    s = i.split()\n    for i in s:\n        arrA.append(int(i))\n    s = input().split()\n    for i in s:\n        arrB.append(int(i))\n    h,b = 0,0\n    for i in range(len(arrA)):\n        if arrA[i] == arrB[i]:\n            h += 1\n        else:\n            if arrB.count(arrA[i]) > 0:\n                b += 1\n    print(h,b)", "sampled": "import sys\n\nfor line in sys.stdin:\n    numbers = list(map(int, line.split()))\n    if len(numbers) < 8:\n        continue\n    \n    a = numbers[:4]\n    b = numbers[4:8]\n    \n    hit = 0\n    blow = 0\n    \n    for i in range(4):\n        if a[i] == b[i]:\n            hit += 1\n        elif b[i] in a:\n            blow += 1\n    \n    print(hit, blow)\n", "perturbed_sampled": ["import sys for line  line.split())) if len(numbers) < 8:  = numbers[4:8] hit = 0 blow =  b[i] in  blow)"], "perturbed_original": ["import sys for i in sys.stdin: arrA,arrB = [],[] s = i.split()  arrA[i] == arrB[i]: h += 1 else: if  1 print(h,b)"], "original_ll": -0.9364861249923706, "sampled_ll": -0.9639748930931091, "all_perturbed_sampled_ll": [-4.683847427368164], "all_perturbed_original_ll": [-3.296541452407837], "perturbed_sampled_ll": -4.683847427368164, "perturbed_original_ll": -3.296541452407837, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "#include <stdio.h>\n\nvoid fact(int ,int, int);\nvoid count(void);\n\nint a[10][10],i,j;\n\nint main(){\n  int x,y,size;\n\n  for(i = 0 ; i < 10 ; i++){\n    for(j = 0 ; j < 10 ; j++){\n      a[i][j] = 0;\n    }\n  }\n  while(scanf(\"%d,%d,%d\",&x,&y,&size) != 3){\n    fact(x,y,size);\n  }\n  count();\n  return 0;\n}\nvoid fact(int x, int y, int size){\n  int size1[2] = {1,-1};\n  int size2[2] = {2,-2};\n\n  a[y][x] += 1;\n  if(size == 1){\n    for(i = 0 ; i < 2 ; i++){\n      if(x+size1[i] >= 0 || x+size1[i] <= 10)\n\ta[y][x+size1[i]] += 1;\n      if(y+size1[i] >= 0 || y+size1[i] <= 10)\n\ta[y+size1[i]][x] += 1;\n    }\n  }\n  if(size == 2){\n    for(i = 0 ; i < 2 ; i++){\n      for(j = 0 ; j < 2 ; j++){\n\tif(x+size1[i] >= 0 || x+size1[i] <= 10 || y+size1[i] >= 0 || y+size1[i] <= 10)\n\t  a[y+size1[i]][x+size1[j]] += 1;\n      }\n    }\n    for(i = 0 ; i < 2 ; i++){\n      if(x+size1[i] >= 0 || x+size1[i] <= 10)\n\ta[y][x+size1[i]] += 1;\n      if(y+size1[i] >= 0 || y+size1[i] <= 10)\n\ta[y+size1[i]][x] += 1;\n    }\n  }\n  if(size == 3){\n    for(i = 0 ; i < 2 ; i++){\n      for(j = 0 ; j < 2 ; j++){\n\tif(x+size1[i] >= 0 || x+size1[i] <= 10 || y+size1[i] >= 0 || y+size1[i] <= 10)\n\t  a[y+size1[i]][x+size1[j]] += 1;\n      }\n    }\n    for(i = 0 ; i < 2 ; i++){\n      if(x+size1[i] >= 0 || x+size1[i] <= 10)\n\ta[y][x+size1[i]] += 1;\n      if(y+size1[i] >= 0 || y+size1[i] <= 10)\n\ta[y+size1[i]][x] += 1;\n    }\n    for(i = 0 ; i < 2 ; i++){\n      if(x+size2[i] >= 0 || x+size2[i] <= 10)\n\ta[y][x+size2[i]] += 1;\n      if(y+size2[i] >= 0 || y+size2[i] <= 10)\n\ta[y+size2[i]][x] += 1;\n    }\n  }\n}\nvoid count(void){\n  int sum = 0,x = 0;\n\n  for(i = 0 ; i < 10 ; i++){\n    for(j = 0 ; j < 10 ; j++){\n      if(a[i][j] == 0)\n\tsum++;\n      else if(x < a[i][j])\n\tx++;\n    }\n  }\n  printf(\"%d\\n%d\\n\",sum,x);\n}", "sampled": "#include <stdio.h>\n#include <string.h>\n\nint main() {\n    int grid[10][10];\n    memset(grid, 0, sizeof(grid));\n    \n    int x, y, s;\n    while (scanf(\"%d,%d,%d\", &x, &y, &s) == 3) {\n        // Small (s=1): only center point\n        if (s == 1) {\n            grid[y][x]++;\n        }\n        // Medium (s=2): center + adjacent (up, down, left, right)\n        else if (s == 2) {\n            grid[y][x]++;\n            if (y > 0) grid[y-1][x]++;\n            if (y < 9) grid[y+1][x]++;\n            if (x > 0) grid[y][x-1]++;\n            if (x < 9) grid[y][x+1]++;\n        }\n        // Large (s=3): center + all 8 surrounding cells + distance 2 in 4 directions\n        else if (s == 3) {\n            grid[y][x]++;\n            // 8 surrounding cells\n            if (y > 0) grid[y-1][x]++;\n            if (y < 9) grid[y+1][x]++;\n            if (x > 0) grid[y][x-1]++;\n            if (x < 9) grid[y][x+1]++;\n            if (y > 0 && x > 0) grid[y-1][x-1]++;\n            if (y > 0 && x < 9) grid[y-1][x+1]++;\n            if (y < 9 && x > 0) grid[y+1][x-1]++;\n            if (y < 9 && x < 9) grid[y+1][x+1]++;\n            // distance 2 in 4 directions\n            if (y > 1) grid[y-2][x]++;\n            if (y < 8) grid[y+2][x]++;\n            if (x > 1) grid[y][x-2]++;\n            if (x < 8) grid[y][x+2]++;\n        }\n    }\n    \n    int zero_count = 0;\n    int max_density = 0;\n    \n    for (int i = 0; i < 10; i++) {\n        for (int j = 0; j < 10; j++) {\n            if (grid[i][j] == 0) {\n                zero_count++;\n            }\n            if (grid[i][j] > max_density) {\n                max_density = grid[i][j];\n            }\n        }\n    }\n    \n    printf(\"%d\\n\", zero_count);\n    printf(\"%d\\n\", max_density);\n    \n    return 0;\n}\n", "perturbed_sampled": ["#include <stdio.h> #include  grid[10][10]; memset(grid, 0, sizeof(grid));  (scanf(\"%d,%d,%d\", &x, &y, &s) == 3) { // Small (s=1): only center point if (s == 1) { grid[y][x]++;  left, right) else if (s == 2) { grid[y][x]++; if (y > 0) grid[y-1][x]++; if (y < 9) grid[y+1][x]++; if (x > 0) grid[y][x-1]++;  center + all 8 surrounding cells  directions else if (s   (y    >   grid[y-1][x+1]++; if (y < 9 &&  x < 9)    (x < 8) grid[y][x+2]++; } }  { for (int j  j++)  {  grid[i][j];  }"], "perturbed_original": ["#include <stdio.h> void fact(int ,int, int); void count(void);  x,y,size;  < 10  ;  } while(scanf(\"%d,%d,%d\",&x,&y,&size)  return 0;  y, int size){ int size1[2] = {1,-1}; int size2[2] =  == 1){ for(i = 0 ; i < 2 ; i++){ if(x+size1[i] >= 0 || x+size1[i] <= 10) a[y][x+size1[i]] += 1;   } } if(size ==  ; j < 2 ;  x+size1[i]  0   = 0 ; i < 2 ; i++){  <=  >= 0 || y+size1[i] <=  }  0 ;   < 2 ; j++){ if(x+size1[i] >= 0 ||  <= 10) a[y+size1[i]][x+size1[j]] += 1; } }  } for(i = 0 ; i < 2  <= 10) a[y+size2[i]][x] += 1; } }   j < 10  a[i][j]) x++; } } printf(\"%d\\n%d\\n\",sum,x); }"], "original_ll": -0.43841585516929626, "sampled_ll": -0.4122350215911865, "all_perturbed_sampled_ll": [-2.0801169872283936], "all_perturbed_original_ll": [-2.169847011566162], "perturbed_sampled_ll": -2.0801169872283936, "perturbed_original_ll": -2.169847011566162, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.Arrays;\n\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\tint[] area = new int[10 * 10];\n\n\t\tString str;\n\n\t\ttry {\n\t\t\twhile ((str = br.readLine()) != null) {\n\t\t\t\tString strArray[] = str.split(\",\");\n\t\t\t\tint x = Integer.parseInt(strArray[0]);\n\t\t\t\tint y = Integer.parseInt(strArray[1]);\n\t\t\t\tint size = Integer.parseInt(strArray[2]);\n\n\t\t\t\tint point = y * 10 + x;\n\n\t\t\t\tswitch (size) {\n\t\t\t\tcase 3:\n\t\t\t\t\tif (x < 8)\n\t\t\t\t\t\tarea[point + 2]++;\n\t\t\t\t\tif (x > 1)\n\t\t\t\t\t\tarea[point - 2]++;\n\t\t\t\t\tif (y < 8)\n\t\t\t\t\t\tarea[point + 20]++;\n\t\t\t\t\tif (y > 1)\n\t\t\t\t\t\tarea[point - 20]++;\n\t\t\t\tcase 2:\n\t\t\t\t\t// \u5de6\u4e0a\n\t\t\t\t\tif (x > 0 && y > 0)\n\t\t\t\t\t\tarea[point - 11]++;\n\t\t\t\t\t// \u53f3\u4e0a\n\t\t\t\t\tif (x < 9 && y > 0)\n\t\t\t\t\t\tarea[point - 9]++;\n\t\t\t\t\t// \u5de6\u4e0b\n\t\t\t\t\tif (y < 9 && x > 0)\n\t\t\t\t\t\tarea[point + 9]++;\n\t\t\t\t\t// \u53f3\u4e0b\n\t\t\t\t\tif (y < 9 && x < 9)\n\t\t\t\t\t\tarea[point + 11]++;\n\t\t\t\tcase 1:\n\t\t\t\t\tif (x < 9)\n\t\t\t\t\t\tarea[point + 1]++;\n\t\t\t\t\tif (x > 0)\n\t\t\t\t\t\tarea[point - 1]++;\n\t\t\t\t\tif (y < 9)\n\t\t\t\t\t\tarea[point + 10]++;\n\t\t\t\t\tif (y > 1)\n\t\t\t\t\t\tarea[point - 10]++;\n\t\t\t\t\tarea[point]++;\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (NumberFormatException e) {\n\t\t\t// TODO \u81ea\u52d5\u751f\u6210\u3055\u308c\u305f catch \u30d6\u30ed\u30c3\u30af\n\t\t\te.printStackTrace();\n\t\t} catch (IOException e) {\n\t\t\t// TODO \u81ea\u52d5\u751f\u6210\u3055\u308c\u305f catch \u30d6\u30ed\u30c3\u30af\n\t\t\te.printStackTrace();\n\t\t}\n\n\t\tArrays.sort(area);\n\t\tint blank = 0;\n\t\tfor (int i = 0; i < 100; i++) {\n\t\t\tif (area[i] != 0) {\n\t\t\t\tblank = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\t// System.out.println(Arrays.binarySearch(area, 1));\n\t\tSystem.out.println(blank);\n\t\tSystem.out.println(area[99]);\n\t}\n}", "sampled": "import java.util.Scanner;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int[][] paper = new int[10][10];\n        \n        while (sc.hasNext()) {\n            String line = sc.nextLine();\n            String[] parts = line.split(\",\");\n            int x = Integer.parseInt(parts[0]);\n            int y = Integer.parseInt(parts[1]);\n            int size = Integer.parseInt(parts[2]);\n            \n            dropInk(paper, x, y, size);\n        }\n        \n        int zeroCells = 0;\n        int maxDensity = 0;\n        \n        for (int i = 0; i < 10; i++) {\n            for (int j = 0; j < 10; j++) {\n                if (paper[i][j] == 0) {\n                    zeroCells++;\n                }\n                maxDensity = Math.max(maxDensity, paper[i][j]);\n            }\n        }\n        \n        System.out.println(zeroCells);\n        System.out.println(maxDensity);\n        \n        sc.close();\n    }\n    \n    static void dropInk(int[][] paper, int x, int y, int size) {\n        if (size == 1) {\n            // Small: only center\n            if (isValid(x, y)) {\n                paper[y][x]++;\n            }\n        } else if (size == 2) {\n            // Medium: cross pattern with radius 1\n            int[][] offsets = {\n                {0, 0},\n                {-1, 0}, {1, 0}, {0, -1}, {0, 1}\n            };\n            for (int[] offset : offsets) {\n                int nx = x + offset[0];\n                int ny = y + offset[1];\n                if (isValid(nx, ny)) {\n                    paper[ny][nx]++;\n                }\n            }\n        } else if (size == 3) {\n            // Large: diamond pattern with radius 2\n            int[][] offsets = {\n                {0, 0},\n                {-1, 0}, {1, 0}, {0, -1}, {0, 1},\n                {-2, 0}, {2, 0}, {0, -2}, {0, 2},\n                {-1, -1}, {-1, 1}, {1, -1}, {1, 1}\n            };\n            for (int[] offset : offsets) {\n                int nx = x + offset[0];\n                int ny = y + offset[1];\n                if (isValid(nx, ny)) {\n                    paper[ny][nx]++;\n                }\n            }\n        }\n    }\n    \n    static boolean isValid(int x, int y) {\n        return x >= 0 && x < 10 && y >= 0 && y < 10;\n    }\n}\n", "perturbed_sampled": ["import java.util.Scanner; public class Main { public static void main(String[] args) { Scanner sc = new Scanner(System.in); <extra_id_12>int x ]<extra_id_13>+= 1;<extra_id_14>if<extra_id_15>]<extra_id_16>[ i ] = 0<extra_id_17>++<extra_id_18>2; }<extra_id_19>j <<extra_id_20>break ;<extra_id_21>[ j<extra_id_22>; continue ; }<extra_id_23> parts = line.split(\",\"); int x  Integer.parseInt(parts[1]); int size = Integer.parseInt(parts[2]); dropInk(paper, x, y, size); } int zeroCells = 0; int maxDensity =  0;  for (int j = 0; j  (paper[i][j] ==   static  {  // Small: only center  }  2) { // Medium:   0},  for  int  + offset[1];   (size == 3)  offsets =  {1, 0}, {0, -1},   {1, -1}, {1, 1} }; for  int nx =    } }  int y)  && x < 10  }"], "perturbed_original": ["import  Main {  { BufferedReader br =  =  str; try { while ((str = br.readLine()) != null) { String strArray[]  Integer.parseInt(strArray[0]); int y = Integer.parseInt(strArray[1]); int size = Integer.parseInt(strArray[2]); int point =  3: if (x <  - 2]++; if  20]++; if (y  case 2: // \u5de6\u4e0a if  > 0) area[point - 11]++; // \u53f3\u4e0a if (x    &&   11]++; case  area[point + 1]++; if (x > 0) area[point -  } } catch (NumberFormatException e) { // TODO \u81ea\u52d5\u751f\u6210\u3055\u308c\u305f catch \u30d6\u30ed\u30c3\u30af e.printStackTrace(); }  (int i =   break;  System.out.println(blank); System.out.println(area[99]); } }"], "original_ll": -0.6759960651397705, "sampled_ll": -0.4992695748806, "all_perturbed_sampled_ll": [-2.6612465381622314], "all_perturbed_original_ll": [-2.914480447769165], "perturbed_sampled_ll": -2.6612465381622314, "perturbed_original_ll": -2.914480447769165, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "class Cloth(object):\n    cell = None\n    x = 0\n    y = 0\n    def __init__(self, x, y):\n        self.cell = list([list([0 for i in range(y)]) for i in range(x)])\n        self.x = x\n        self.y = y\n    def check(self, x, y):\n        try:\n            self.cell[x][y] += 0\n            return True\n        except IndexError:\n            return False\n    def point(self, x, y):\n        try:\n            self.cell[x][y] += 1\n        except IndexError:\n            pass\n    def small(self, x, y):\n        if not self.check(x, y):\n            return\n        self.point(x, y + 1)\n        self.point(x - 1, y)\n        self.point(x, y)\n        self.point(x + 1, y)\n        self.point(x, y - 1)\n    def medium(self, x, y):\n        if not self.check(x, y):\n            return\n        self.small(x, y)\n        self.point(x + 1, y + 1)\n        self.point(x - 1, y + 1)\n        self.point(x + 1, y - 1)\n        self.point(x - 1, y - 1)\n    def large(self, x, y):\n        if not self.check(x, y):\n            return\n        self.medium(x, y)\n        self.point(x, y + 2)\n        self.point(x - 2, y)\n        self.point(x + 2, y)\n        self.point(x, y - 2)\ncloth = Cloth(10, 10)\nwhile True:\n    try:\n        (x, y, s) = map(lambda x:int(x)-1, raw_input().split(','))\n        if s == 0:\n            cloth.small(x, y)\n        elif s == 1:\n            cloth.medium(x, y)\n        elif s == 2:\n            cloth.large(x, y)\n    except EOFError:\n        break\nprint reduce(lambda x,y:x+y,map(lambda x:x.count(0),cloth.cell))\nprint max(map(max,cloth.cell))", "sampled": "import sys\n\n# Initialize 10x10 grid\ngrid = [[0 for _ in range(10)] for _ in range(10)]\n\n# Define ink patterns for each size relative to drop point\n# Size 1 (Small): just the center and 4 adjacent cells (cross pattern)\npatterns = {\n    1: [(0, 0), (0, 1), (0, -1), (1, 0), (-1, 0)],\n    2: [(0, 0), (0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (1, -1), (-1, 1), (-1, -1), (0, 2), (0, -2), (2, 0), (-2, 0)],\n    3: [(0, 0), (0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (1, -1), (-1, 1), (-1, -1), \n        (0, 2), (0, -2), (2, 0), (-2, 0), (1, 2), (1, -2), (-1, 2), (-1, -2), (2, 1), (2, -1), (-2, 1), (-2, -1),\n        (0, 3), (0, -3), (3, 0), (-3, 0)]\n}\n\n# Read input and process drops\nfor line in sys.stdin:\n    line = line.strip()\n    if not line:\n        continue\n    parts = line.split(',')\n    x = int(parts[0])\n    y = int(parts[1])\n    size = int(parts[2])\n    \n    # Apply ink pattern\n    for dx, dy in patterns[size]:\n        nx, ny = x + dx, y + dy\n        if 0 <= nx < 10 and 0 <= ny < 10:\n            grid[ny][nx] += 1\n\n# Count cells with density 0 and find maximum density\nzero_count = 0\nmax_density = 0\n\nfor row in grid:\n    for cell in row:\n        if cell == 0:\n            zero_count += 1\n        max_density = max(max_density, cell)\n\nprint(zero_count)\nprint(max_density)\n", "perturbed_sampled": ["import sys # Initialize 10x10 grid grid = [[0 for _ in  # Define ink patterns for each size relative to drop point #  center and  patterns  (1, 0), (-1,  0), (-1, 0), (1, 1), (1,  (0, 2), (0, -2),  [(0, 0), (0, 1), (0,   1), (-1, -1), (0, 2), (0, -2),  2), (1,  (2, 1), (2, -1), (-2, 1),  -3), (3, 0),  input and process drops for line in sys.stdin: line =  for  ny  and 0  +=  density  zero_count  for cell  print(zero_count) print(max_density)"], "perturbed_original": ["class Cloth(object): cell  x  x, y): try: self.cell[x][y] += 0 return True except  x, y): try:  pass def  - 1,  -  if  y) self.point(x + 1, y   x, y): if not self.check(x, y): return  2) self.point(x - 2, y) self.point(x + 2, y) self.point(x, y - 2)  True: try:  x:int(x)-1, raw_input().split(',')) if s == 0: cloth.small(x, y) elif s  s == 2:  print reduce(lambda x,y:x+y,map(lambda x:x.count(0),cloth.cell)) print max(map(max,cloth.cell))"], "original_ll": -0.7247860431671143, "sampled_ll": -0.6722749471664429, "all_perturbed_sampled_ll": [-2.7104616165161133], "all_perturbed_original_ll": [-2.9536783695220947], "perturbed_sampled_ll": -2.7104616165161133, "perturbed_original_ll": -2.9536783695220947, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "#include <stdio.h>\n \nint dayOfWeek(int year, int month, int day)\n{\n    if (month == 1 || month == 2) {\n        year--;\n        month += 12;\n    }\n    return (year + year / 4 - year / 100 + year / 400\n        + (13 * month + 8) / 5 + day) % 7;\n}\n \nint main()\n{\n    int m, d;\n    char *day[7] = {\n        \"Sunday\", \"Monday\", \"Tuesday\", \"Wednesday\", \"Thursday\", \"Friday\", \"Saturday\"\n    };\n     \n    while (1) {\n        scanf(\"%d%d\", &m, &d);\n        if (m == 0 || d == 0) break;\n        puts(day[dayOfWeek(2004, m, d)]);\n    }\n    return 0;\n}\n\n", "sampled": "#include <stdio.h>\n\nint main() {\n    int days_in_month[] = {0, 31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};\n    char *day_names[] = {\"Thursday\", \"Friday\", \"Saturday\", \"Sunday\", \"Monday\", \"Tuesday\", \"Wednesday\"};\n    \n    int m, d;\n    while(1) {\n        scanf(\"%d %d\", &m, &d);\n        if(m == 0 && d == 0) break;\n        \n        int total_days = 0;\n        for(int i = 1; i < m; i++) {\n            total_days += days_in_month[i];\n        }\n        total_days += d - 1;\n        \n        int day_index = total_days % 7;\n        printf(\"%s\\n\", day_names[day_index]);\n    }\n    \n    return 0;\n}\n", "perturbed_sampled": ["#include <stdio.h> int <extra_id_1>15; d-=<extra_id_2>int<extra_id_3>days_in_month[day_index] */ <s> void DW(<extra_id_4>,<extra_id_5>day ++ ) {<extra_id_6>days_in_month<extra_id_7>days_in_month.length);<extra_id_8>+=<extra_id_9>) DW(d); if (d > 0)<extra_id_10>break; #include<extra_id_11>#include \"<extra_id_12>d<extra_id_13>} 31, 30,    d; while(1) { scanf(\"%d %d\",  && d == 0) break; int total_days = 0; for(int i  days_in_month[i];  1; int day_index = total_days % 7;  }"], "perturbed_original": ["#include <stdio.h> int dayOfWeek(int year,  if (month  +=  year / 100 + year / 400 +  / 5 + day) %   \"Tuesday\", \"Wednesday\", \"Thursday\", \"Friday\",  d == 0) break; puts(day[dayOfWeek(2004, m, d)]); } return 0; }"], "original_ll": -0.9109442830085754, "sampled_ll": -0.5046465992927551, "all_perturbed_sampled_ll": [-2.746763229370117], "all_perturbed_original_ll": [-2.6919424533843994], "perturbed_sampled_ll": -2.746763229370117, "perturbed_original_ll": -2.6919424533843994, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import java.util.*;\nimport java.lang.*;\nimport java.math.*;\n\npublic class Main {\n\tScanner sc = new Scanner(System.in);\n\tvoid run(){\n\t\tint[] map={31,29,31,30,31,30,31,31,30,31,30,31};\n\t\tint[] dp = new int [12];\n\t\tString[] str ={\n\t\t\t\t\"Monday\",\n\t\t\t\t\"Tuesday\",\n\t\t\t\t\"Wednesday\",\n\t\t\t\t\"Thursday\",\n\t\t\t\t\"Friday\",\n\t\t\t\t\"Monday\",\n\t\t\t\t\"Sunday\",\n\t\t};\n\t\tdp[0] = 2;\n\t\tfor(int i=1; i <12;i++){\n\t\t\tdp[i] = (dp[i-1] + map[i-1] +2)%7;\n\t\t}\n\t\tfor(;;){\n\t\t\tint m = sc.nextInt();\n\t\t\tint n = sc.nextInt();\n\t\t\tif((m|n)==0){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tSystem.out.println(str[(dp[m-1]+n)%7]);\n\t\t}\n\t}\n\tpublic static void main(String[] args){\n\t\tMain m = new Main();\n\t\tm.run();\n\t}\n}", "sampled": "import java.util.Scanner;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        \n        int[] daysInMonth = {0, 31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};\n        String[] days = {\"Thursday\", \"Friday\", \"Saturday\", \"Sunday\", \"Monday\", \"Tuesday\", \"Wednesday\"};\n        \n        while (true) {\n            int m = sc.nextInt();\n            int d = sc.nextInt();\n            \n            if (m == 0 && d == 0) {\n                break;\n            }\n            \n            int totalDays = 0;\n            for (int i = 1; i < m; i++) {\n                totalDays += daysInMonth[i];\n            }\n            totalDays += d - 1;\n            \n            System.out.println(days[totalDays % 7]);\n        }\n        \n        sc.close();\n    }\n}\n", "perturbed_sampled": ["import java.util.Scanner;  { Scanner sc = new Scanner(System.in); int[] daysInMonth = {0, 31, 29, 31,   days  =  if (m == 0  break; } int totalDays = 0; for  < m;   } sc.close(); } }"], "perturbed_original": ["import java.util.*; import  = new Scanner(System.in); void  = new int [12];  \"Wednesday\", \"Thursday\", \"Friday\", \"Monday\", \"Sunday\", }; dp[0] = 2;   }  int n =  m = new Main(); m.run(); } }"], "original_ll": -1.004957675933838, "sampled_ll": -0.4278634190559387, "all_perturbed_sampled_ll": [-2.646630048751831], "all_perturbed_original_ll": [-2.886204957962036], "perturbed_sampled_ll": -2.646630048751831, "perturbed_original_ll": -2.886204957962036, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "month, day = map(int, raw_input().split())\ndays = [31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]\nyoubi = [\"Sunday\", \"Monday\", \"Tuesday\",\n         \"Wednesday\", \"Thursday\", \"Friday\", \"Saturday\"]\nwhile month != 0:\n    Days = 0\n    for i in range(month - 1):\n        Days += days[i]\n    Days += day\n    print youbi[Days % 7]\n    month, day = map(int, raw_input().split())", "sampled": "days_of_week = [\"Thursday\", \"Friday\", \"Saturday\", \"Sunday\", \"Monday\", \"Tuesday\", \"Wednesday\"]\ndays_in_month = [0, 31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]\n\nwhile True:\n    line = input().split()\n    m, d = int(line[0]), int(line[1])\n    \n    if m == 0 and d == 0:\n        break\n    \n    total_days = 0\n    for i in range(1, m):\n        total_days += days_in_month[i]\n    total_days += d - 1\n    \n    day_index = total_days % 7\n    print(days_of_week[day_index])\n", "perturbed_sampled": ["days_of_week =  \"Tuesday\",  30, 31, 31, 30,  line = input().split() m, d = int(line[0]),   total_days = 0 for i  total_days % 7 print(days_of_week[day_index])"], "perturbed_original": ["month, day = map(int, raw_input().split()) days = [31, 29, 31, 30, youbi=[] i<extra_id_9>month) if<extra_id_10>n != =<extra_id_11>[i]=30, 29, 29, 29,<extra_id_12>30, 30]<extra_id_13>( i ==<extra_id_14>+1))youbico=[]<extra_id_15>= [] days[i] = 31, 30, 31] youbi  month  for i in range(month  Days  map(int, raw_input().split())"], "original_ll": -0.9888721704483032, "sampled_ll": -0.618447482585907, "all_perturbed_sampled_ll": [-3.197503089904785], "all_perturbed_original_ll": [-2.916144609451294], "perturbed_sampled_ll": -3.197503089904785, "perturbed_original_ll": -2.916144609451294, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "#include <stdio.h>\n#include <string.h>\n\nint main()\n{\n  int countArray[101], number, mx_number = 0;\n  memset(countArray, 0, sizeof countArray);\n\n  while(scanf(\"%d\", &number)!=EOF){\n    ++countArray[number];\n  }\n\n  for(number = 100; number > 0; --number)\n    if(countArray[number] > countArray[mx_number])\n      mx_number = number;\n\n  for(number = 1; number <= mx_number; ++number)\n    if(countArray[number] == countArray[mx_number])\n      printf(\"%d\\n\", number);\n\n  return 0;\n}", "sampled": "#include <stdio.h>\n\nint main() {\n    int count[101] = {0};\n    int num;\n    int maxCount = 0;\n    \n    while (scanf(\"%d\", &num) != EOF) {\n        count[num]++;\n        if (count[num] > maxCount) {\n            maxCount = count[num];\n        }\n    }\n    \n    for (int i = 1; i <= 100; i++) {\n        if (count[i] == maxCount) {\n            printf(\"%d\\n\", i);\n        }\n    }\n    \n    return 0;\n}\n", "perturbed_sampled": ["#include  count[101] = {0}; int  while  count[num]++; if (count[num] > maxCount) { maxCount = count[num]; } } for (int  100;  }"], "perturbed_original": ["#include <stdio.h>  int countArray[101], number,  sizeof countArray); while(scanf(\"%d\",  --number) if(countArray[number] > countArray[mx_number]) mx_number = number; for(number = 1;  return 0; }"], "original_ll": -0.9871660470962524, "sampled_ll": -0.4140847623348236, "all_perturbed_sampled_ll": [-2.5563642978668213], "all_perturbed_original_ll": [-3.1384620666503906], "perturbed_sampled_ll": -2.5563642978668213, "perturbed_original_ll": -3.1384620666503906, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.ArrayList;\nimport java.util.Collections;\n\npublic class Main {\n\n\tpublic static void main(String[] args) {\n\t\t// TODO \u81ea\u52d5\u751f\u6210\u3055\u308c\u305f\u30e1\u30bd\u30c3\u30c9\u30fb\u30b9\u30bf\u30d6\n\t\t\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\tString tmp = null;\n\t\tint cup = 0;\n\t\tint mun = 0;\n\t\tint ter = 0;\n\t\tString[] rrr;\n\t\tint st = 0,sr = 0;\n\t\tint mon = 0;\n\t\tArrayList<Integer> al = new ArrayList<Integer>();\n\t\t\n\t\twhile(true){\n\t\t\t\n\t\t\ttry {\n\t\t\t\ttmp = br.readLine();\n\t\t\t} catch (IOException e) {\n\t\t\t\t// TODO \u81ea\u52d5\u751f\u6210\u3055\u308c\u305f catch \u30d6\u30ed\u30c3\u30af\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t\t\n\t\t\tif(tmp == null){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\n\t\t\tif(tmp.equals(\"\")){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\n\t\t\tal.add(Integer.parseInt(tmp));\n\t\t}\n\t\t\n\t\t//System.out.println(al.toString());\n\t\tCollections.sort(al);\n\t\t//System.out.println(al.toString());\n\t\tArrayList<Integer> al2 = new ArrayList<Integer>();\n\t\tArrayList<Integer> al3 = new ArrayList<Integer>();\n\t\tint tmpr = 0;\n\t\t\n\t\tfor(int i=0;i<al.size();i++){\n\t\t\tif(tmpr ==0){\n\t\t\t\tal2.add(al.get(i));\n\t\t\t}\n\t\t\tif(al2.get(tmpr) < al.get(i)){\n\t\t\t\ttmpr++;\n\t\t\t\tal2.add(al.get(i));\n\t\t\t}\n\t\t}\n\t\tint aaa = 0;\n\t\tfor(int i=0;i<al2.size();i++){\n\t\t\ttmpr = 0;\n\t\t\tfor(int j=0;j<al.size();j++){\n\t\t\t\tif(al.get(j) == al2.get(i)){\n\t\t\t\t\ttmpr++;\n\t\t\t\t}\n\t\t\t\tal3.add(tmpr);\n\t\t\t\tif(aaa < tmpr){\n\t\t\t\t\taaa = tmpr;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor(int i=0;i<al3.size();i++){\n\t\t\tif(aaa == al3.get(i)){\n\t\t\t\tSystem.out.println(al2.get(i));\n\t\t\t}\n\t\t}\n\t\t\n\t\t\n\t\t\n\t}\n\n}", "sampled": "import java.util.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        Map<Integer, Integer> count = new HashMap<>();\n        \n        while (sc.hasNextInt()) {\n            int num = sc.nextInt();\n            count.put(num, count.getOrDefault(num, 0) + 1);\n        }\n        \n        int maxCount = 0;\n        for (int c : count.values()) {\n            maxCount = Math.max(maxCount, c);\n        }\n        \n        List<Integer> modes = new ArrayList<>();\n        for (Map.Entry<Integer, Integer> entry : count.entrySet()) {\n            if (entry.getValue() == maxCount) {\n                modes.add(entry.getKey());\n            }\n        }\n        \n        Collections.sort(modes);\n        \n        for (int mode : modes) {\n            System.out.println(mode);\n        }\n        \n        sc.close();\n    }\n}\n", "perturbed_sampled": ["import java.util.*; public class Main { public static  sc = new Scanner(System.in); Map<Integer, Integer> count  {  }  (int c :  == maxCount) { modes.add(entry.getKey()); } }  modes) { System.out.println(mode); } sc.close(); } }"], "perturbed_original": ["import java.io.BufferedReader; import java.io.IOException; import java.io.InputStreamReader; import  // TODO \u81ea\u52d5\u751f\u6210\u3055\u308c\u305f\u30e1\u30bd\u30c3\u30c9\u30fb\u30b9\u30bf\u30d6 BufferedReader br = new  0; int mun =  String[] rrr; int  int mon = 0; ArrayList<Integer> al = new ArrayList<Integer>(); while(true){ try { tmp = br.readLine(); }  TODO \u81ea\u52d5\u751f\u6210\u3055\u308c\u305f  ArrayList<Integer>(); ArrayList<Integer> al3 = new  } int  tmpr = 0; for(int j=0;j<al.size();j++){ if(al.get(j) == al2.get(i)){ tmpr++;  aaa =  System.out.println(al2.get(i)); } } } }"], "original_ll": -0.8464222550392151, "sampled_ll": -0.3624679446220398, "all_perturbed_sampled_ll": [-3.087472677230835], "all_perturbed_original_ll": [-2.5956215858459473], "perturbed_sampled_ll": -3.087472677230835, "perturbed_original_ll": -2.5956215858459473, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "num = [[0,i+1] for i in range(100)]\nwhile True:\n    try:\n        num[int(input())-1][0] += 1\n    except:\n        num.sort(reverse = True)\n        ans = []\n        for i in range(100):\n            if num[i][0] == num[0][0]:\n                ans.append(num[i][1])\n            else:\n                ans.sort()\n                for z in ans:\n                    print(z)\n                break\n        break\n", "sampled": "import sys\nfrom collections import Counter\n\nnumbers = []\nfor line in sys.stdin:\n    numbers.append(int(line.strip()))\n\ncounter = Counter(numbers)\nmax_count = max(counter.values())\nmode_values = sorted([num for num, count in counter.items() if count == max_count])\n\nfor val in mode_values:\n    print(val)\n", "perturbed_sampled": ["import sys from  [] for line in sys.stdin: numbers.append(int(line.strip())) counter =   ==  print(val)"], "perturbed_original": ["num =  while True: try: num[int(input())-1][0] += 1  == num[0][0]: ans.append(num[i][1]) else: ans.sort() for  break"], "original_ll": -1.135990858078003, "sampled_ll": -1.0147686004638672, "all_perturbed_sampled_ll": [-4.665111541748047], "all_perturbed_original_ll": [-3.142979145050049], "perturbed_sampled_ll": -4.665111541748047, "perturbed_original_ll": -3.142979145050049, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "#include <stdio.h>\n#include <string.h>\n\nint main(void){\n\tint i=0,j,c,max=0,ans1=100,ans2=100,count=0;\n\tchar s[1000][33]={0};\n\tchar ch;\n\t\n\twhile(1){\n\t\tscanf(\"%c\",&ch);\n\t\tif(ch=='\\n')break;\n\t\tif(ch==' '){\n\t\t\tcount++;\n\t\t\ti=0;\n\t\t}\n\t\ts[count][i]=ch;\n\t\tif(max<1+i){\n\t\t\tmax=i+1;\n\t\t\tans2=count;\n\t\t}\n\t\tif(ch!=' ')i++;\n\t}\n\tmax=0;\n\tfor(i=0;i<count;i++){\n\t\tfor(j=i+1,c=0;j<count;j++){\n\t\t\tif(strcmp(s[i],s[j])==0){\n\t\t\t\tc++;\n\t\t\t}\n\t\t\tif(max<c){\n\t\t\t\tmax=c;\n\t\t\t\tans1=i;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tprintf(\"%s %s\\n\",s[ans1],s[ans2]);\n\treturn 0;\n}", "sampled": "#include <stdio.h>\n#include <string.h>\n#include <ctype.h>\n\nint main() {\n    char text[1001];\n    char words[100][33];\n    int count[100] = {0};\n    int wordCount = 0;\n    \n    fgets(text, sizeof(text), stdin);\n    \n    // Remove newline if present\n    int len = strlen(text);\n    if (len > 0 && text[len-1] == '\\n') {\n        text[len-1] = '\\0';\n    }\n    \n    // Parse words\n    char *token = strtok(text, \" \");\n    while (token != NULL) {\n        int found = -1;\n        for (int i = 0; i < wordCount; i++) {\n            if (strcmp(words[i], token) == 0) {\n                found = i;\n                break;\n            }\n        }\n        \n        if (found != -1) {\n            count[found]++;\n        } else {\n            strcpy(words[wordCount], token);\n            count[wordCount] = 1;\n            wordCount++;\n        }\n        \n        token = strtok(NULL, \" \");\n    }\n    \n    // Find most frequent word\n    int maxCount = 0;\n    int maxCountIndex = 0;\n    for (int i = 0; i < wordCount; i++) {\n        if (count[i] > maxCount) {\n            maxCount = count[i];\n            maxCountIndex = i;\n        }\n    }\n    \n    // Find longest word\n    int maxLen = 0;\n    int maxLenIndex = 0;\n    for (int i = 0; i < wordCount; i++) {\n        int len = strlen(words[i]);\n        if (len > maxLen) {\n            maxLen = len;\n            maxLenIndex = i;\n        }\n    }\n    \n    printf(\"%s %s\\n\", words[maxCountIndex], words[maxLenIndex]);\n    \n    return 0;\n}\n", "perturbed_sampled": ["  count[100] =  int  = strtok(text, \"  -1; for (int i = 0; i < wordCount; i++) {  { found = i; break; } } if (found != -1) { count[found]++; } else  1; wordCount++; } token = strtok(NULL, \" \");  word int maxCount = 0; int  i = 0; i < wordCount;  count[i]; maxCountIndex = i;  0; for (int i = 0; i <  i; } } printf(\"%s %s\\n\", words[maxCountIndex], words[maxLenIndex]); return 0; }"], "perturbed_original": ["#include <stdio.h> #include <string.h>   max=i+1; ans2=count; } if(ch!=' ')i++;   } } } printf(\"%s %s\\n\",s[ans1],s[ans2]); return 0; }"], "original_ll": -1.0555611848831177, "sampled_ll": -0.43979984521865845, "all_perturbed_sampled_ll": [-2.4006142616271973], "all_perturbed_original_ll": [-2.762206554412842], "perturbed_sampled_ll": -2.4006142616271973, "perturbed_original_ll": -2.762206554412842, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import java.util.HashMap;\nimport java.util.Scanner;\n\nclass Main{\n\tpublic static void main(String[] args){\n\t\tScanner sc = new Scanner(System.in);\n\t\tHashMap<String, Integer> map = new HashMap<String, Integer>();\n\n\t\tString[] st = sc.nextLine().split(\" \");\n\t\t\n\t\tfor(int i = 0; i < st.length; i++)\n\t\t\tif(map.containsKey(st[i]))\n\t\t\t\tmap.put(st[i], map.get(st[i])+1);\n\t\t\telse\n\t\t\t\tmap.put(st[i], 1);\n\t\t\n\t\tString max = st[0];\n\t\tint count = 0;\n\t\tfor(int i = 0; i < st.length-1; i++){\n\t\t\tif(map.get(st[i]) < map.get(st[i+1]))max = st[i+1];\n\t\t    if(st[i].length() < st[i+1].length())count = i+1;\n\t\t}\n\t\t\tSystem.out.println(max + \" \" + st[count]);\n\t\t\t\n\t\t\tsc.close();\n\t}\n}", "sampled": "import java.util.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        String line = sc.nextLine();\n        String[] words = line.split(\" \");\n        \n        Map<String, Integer> frequency = new HashMap<>();\n        for (String word : words) {\n            frequency.put(word, frequency.getOrDefault(word, 0) + 1);\n        }\n        \n        String mostFrequent = \"\";\n        int maxFreq = 0;\n        for (Map.Entry<String, Integer> entry : frequency.entrySet()) {\n            if (entry.getValue() > maxFreq) {\n                maxFreq = entry.getValue();\n                mostFrequent = entry.getKey();\n            }\n        }\n        \n        String longest = \"\";\n        int maxLen = 0;\n        for (String word : words) {\n            if (word.length() > maxLen) {\n                maxLen = word.length();\n                longest = word;\n            }\n        }\n        \n        System.out.println(mostFrequent + \" \" + longest);\n    }\n}\n", "perturbed_sampled": ["import  line = sc.nextLine(); String[] words = line.split(\" \"); Map<String, Integer> frequency = new  0) + 1); } String mostFrequent = \"\"; int maxFreq   (entry.getValue() > maxFreq) { maxFreq = entry.getValue();  String longest =  words)  { maxLen  } } System.out.println(mostFrequent  } }"], "perturbed_original": ["import java.util.HashMap; import java.util.Scanner; class Main{ public static void main(String[]    i = 0; i <   = 0;  < st.length-1; i++){ if(map.get(st[i]) < map.get(st[i+1]))max = st[i+1]; if(st[i].length() < st[i+1].length())count  sc.close(); } }"], "original_ll": -0.8052243590354919, "sampled_ll": -0.35838332772254944, "all_perturbed_sampled_ll": [-2.985621929168701], "all_perturbed_original_ll": [-2.555781841278076], "perturbed_sampled_ll": -2.985621929168701, "perturbed_original_ll": -2.555781841278076, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "def solve():\n    text = input()\n    longest, length = '', 0\n    dic = {}\n    for word in text.split():\n        if word in dic.keys():\n            dic[word] += 1\n        else:\n            dic[word] = 1\n        \n        if length < len(word):\n            longest = word\n            length = len(word)\n    \n    target, cnt = '', 0\n    for k, v in dic.items():\n        if v > cnt:\n            target = k\n            cnt = v\n    print(target, longest)\n\nif __name__ == \"__main__\":\n    solve()\n\n", "sampled": "text = input().split()\nword_count = {}\nfor word in text:\n    word_count[word] = word_count.get(word, 0) + 1\n\nmost_frequent = max(word_count, key=word_count.get)\nlongest = max(text, key=len)\n\nprint(most_frequent, longest)\n", "perturbed_sampled": ["text = input().split() word_count = {} for word in text: word_count[word] =  longest)"], "perturbed_original": ["def  length   = word length = len(word) target, cnt = '', 0 for k, v in dic.items(): if  print(target, longest) if __name__ == \"__main__\": solve()"], "original_ll": -0.9060442447662354, "sampled_ll": -1.0406062602996826, "all_perturbed_sampled_ll": [-3.814577341079712], "all_perturbed_original_ll": [-4.0492987632751465], "perturbed_sampled_ll": -3.814577341079712, "perturbed_original_ll": -4.0492987632751465, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "#include <stdio.h>\n#include <string.h>\n\n\nint val[10];\nint s;\n\nint getWay(int x, int n, int sum)\n{\n\tint ret = 0;\n\tint i;\n\t\n\tif (n == 0){\n\t\tif (sum == s){\n\t\t\treturn (1);\n\t\t}\n\t\treturn (0);\n\t}\n\t\n\tfor (i = x; i < 10; i++){\n\t\tif (val[i] == 0 && sum + i <= s){\n\t\t\tval[i] = 1;\n\t\t\tret += getWay(i, n - 1, i + sum);\n\t\t\tval[i] = 0;\n\t\t}\n\t}\n\t\n\treturn (ret);\n}\n\nint main(void)\n{\n\twhile (1){\n\t\tint n;\n\t\t\n\t\tscanf(\"%d%d\", &n, &s);\n\t\tmemset(val, 0, sizeof(val));\n\t\t\n\t\tif (n == 0 && s == 0){\n\t\t\tbreak;\n\t\t}\n\t\t\n\t\tprintf(\"%d\\n\", getWay(0, n, 0));\n\t}\n\t\n\treturn (0);\n}", "sampled": "#include <stdio.h>\n\nint count_combinations(int pos, int n, int s, int used) {\n    if (n == 0) {\n        return (s == 0) ? 1 : 0;\n    }\n    if (pos > 9 || s < 0) {\n        return 0;\n    }\n    \n    int result = 0;\n    // Don't use current digit\n    result += count_combinations(pos + 1, n, s, used);\n    // Use current digit\n    result += count_combinations(pos + 1, n - 1, s - pos, used);\n    \n    return result;\n}\n\nint main() {\n    int n, s;\n    \n    while (1) {\n        scanf(\"%d %d\", &n, &s);\n        if (n == 0 && s == 0) {\n            break;\n        }\n        \n        int result = count_combinations(0, n, s, 0);\n        printf(\"%d\\n\", result);\n    }\n    \n    return 0;\n}\n", "perturbed_sampled": ["#include <stdio.h> int count_combinations(int pos, =<extra_id_5>s ;<extra_id_6>++<extra_id_7>; i ++<extra_id_8>. c<extra_id_9>s+1); if (s<extra_id_10>}<extra_id_11>s< 0)<extra_id_12>if(s ><extra_id_13>0) { break; }<extra_id_14>return result;<extra_id_15>; } }<extra_id_16>;<extra_id_6>return ( int )  (pos > 9 || s < 0) {  = 0;  result += count_combinations(pos  //  count_combinations(pos + 1,  pos, used); return result; } int main() {  &s); if (n == 0 && s == 0) { break;  }"], "perturbed_original": ["#include <stdio.h> #include <string.h> int val[10]; int s; int getWay(int x, int n, int sum) { int ret  (n ==   x;  (val[i] == 0 && sum + i  ret += getWay(i, n - 1, i +  }    getWay(0,  }"], "original_ll": -0.8791469931602478, "sampled_ll": -0.6037840843200684, "all_perturbed_sampled_ll": [-2.5588526725769043], "all_perturbed_original_ll": [-2.984635353088379], "perturbed_sampled_ll": -2.5588526725769043, "perturbed_original_ll": -2.984635353088379, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "\n\nimport java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.HashMap;\n\npublic class Main {\n    public static void main(String args[]){\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        try{\n            String line;\n            \n            while((line=br.readLine())!=null){\n                if(line.equals(\"\"))break;\n                String[] splited = line.split(\" \");\n                int n = Integer.parseInt(splited[0]);\n                s = Integer.parseInt(splited[1]);\n                if(n==0&&s==0)break;if(n>=10)System.out.println(\"0\");\n                    combis(1,n);\n                    System.out.println(count);\n                count=0;\n            }         \n        }catch(Exception e){e.printStackTrace();}\n        \n    }\n    static int[] com = new int[10];\n    static int count = 0,s=0;\n    static void combis(int st,int r){\n        if(st<=r){\n            for(int i=(st==1)? 0:com[st-1]+1;i<=9-r+st;i++){\n                com[st]=i;\n                combis(st+1,r);\n            }\n        }else{\n            //System.out.println(Arrays.toString(com));\n            int sum=0; for(int i=1;i<=r;i++) sum+=com[i];\n            if(sum==s)count++;\n        }\n        \n        }\n    static int _10Cn(int n){\n            int _n=1,d=1;\n            for(int i=1; i<=n;i++){\n                _n*=11-i; d*=i;\n            }\n            return _n/d;\n        }\n}", "sampled": "import java.util.Scanner;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        \n        while (true) {\n            int n = sc.nextInt();\n            int s = sc.nextInt();\n            \n            if (n == 0 && s == 0) {\n                break;\n            }\n            \n            int count = countCombinations(n, s, 0, 0);\n            System.out.println(count);\n        }\n        \n        sc.close();\n    }\n    \n    private static int countCombinations(int n, int s, int start, int depth) {\n        if (depth == n) {\n            return s == 0 ? 1 : 0;\n        }\n        \n        if (start > 9) {\n            return 0;\n        }\n        \n        int count = 0;\n        for (int i = start; i <= 9; i++) {\n            count += countCombinations(n, s - i, i + 1, depth + 1);\n        }\n        \n        return count;\n    }\n}\n", "perturbed_sampled": ["import java.util.Scanner; public class Main  = sc.nextInt(); int s =  count  System.out.println(count);  int countCombinations(int n, int s, int start, int depth) { if (depth  : 0; }  (int i = start; i <=   + 1, depth + 1); } return count; } }"], "perturbed_original": ["  args[]){ BufferedReader  try{ String line; while((line=br.readLine())!=null){ if(line.equals(\"\"))break; String[] splited =  if(n==0&&s==0)break;if(n>=10)System.out.println(\"0\"); combis(1,n); System.out.println(count); count=0; } }catch(Exception e){e.printStackTrace();} } static int[] com = new int[10]; static  if(st<=r){ for(int i=(st==1)? 0:com[st-1]+1;i<=9-r+st;i++){ com[st]=i; combis(st+1,r);  for(int  int _n=1,d=1; for(int i=1; i<=n;i++){  } }"], "original_ll": -1.3355286121368408, "sampled_ll": -0.42449766397476196, "all_perturbed_sampled_ll": [-2.8900723457336426], "all_perturbed_original_ll": [-2.7223246097564697], "perturbed_sampled_ll": -2.8900723457336426, "perturbed_original_ll": -2.7223246097564697, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import sys\nsys.setrecursionlimit(10000)\n\ndef solve(i,wa,use):\n    global ct,s,n\n    if wa==s and use==n:\n        ct+=1\n        return\n    if use>=n or i==10 or wa>s:\n        return\n    solve(i+1,wa,use)\n    solve(i+1,wa+i,use+1)\n\nwhile 1:\n    n,s=map(int,raw_input().split())\n    if n==0 and s==0:\n        break\n    ct=0\n    wa=0\n    solve(0,0,0)\n    print ct", "sampled": "from itertools import combinations\n\nwhile True:\n    n, s = map(int, input().split())\n    if n == 0 and s == 0:\n        break\n    \n    count = 0\n    for combo in combinations(range(10), n):\n        if sum(combo) == s:\n            count += 1\n    \n    print(count)\n", "perturbed_sampled": ["from itertools import combinations while True:  if   combinations(range(10), n):  += 1 print(count)"], "perturbed_original": ["import  use==n: ct+=1 return  wa>s:  n,s=map(int,raw_input().split()) if n==0 and s==0: break ct=0 wa=0 solve(0,0,0) print ct"], "original_ll": -1.1724587678909302, "sampled_ll": -0.6921679973602295, "all_perturbed_sampled_ll": [-3.3549814224243164], "all_perturbed_original_ll": [-3.503521680831909], "perturbed_sampled_ll": -3.3549814224243164, "perturbed_original_ll": -3.503521680831909, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "/*\nAizuOnline A0031\nWeight\n*/\n#include <stdio.h>\n\n\nmain()\n{\n  int weight;\n  int fundou;\n  int flag;\n  \n  while(EOF !=scanf(\"%d\",&weight))\n    {\n      flag = 0;\n      for(fundou=1;fundou <= 512;fundou <<= 1)\n      { if(weight & fundou)\n        {\n          if(flag)\n            printf(\" \");\n          printf(\"%d\",fundou);\n          flag = 1;\n        }\n      }\n        printf(\"\\n\");\n    }\n\nreturn(0);\n}", "sampled": "#include <stdio.h>\n\nint main() {\n    int weight;\n    int weights[] = {1, 2, 4, 8, 16, 32, 64, 128, 256, 512};\n    \n    while(scanf(\"%d\", &weight) != EOF) {\n        int first = 1;\n        for(int i = 0; i < 10; i++) {\n            if(weight & (1 << i)) {\n                if(!first) {\n                    printf(\" \");\n                }\n                printf(\"%d\", weights[i]);\n                first = 0;\n            }\n        }\n        printf(\"\\n\");\n    }\n    \n    return 0;\n}\n", "perturbed_sampled": [" int weight;  64, 128,   0; i <  if(!first) { printf(\" \"); } printf(\"%d\", weights[i]); first = 0; } } printf(\"\\n\"); } return 0; }"], "perturbed_original": ["/* AizuOnline A0031 Weight */ #include <stdio.h> main() {  flag =  1) { if(weight & fundou)  }"], "original_ll": -1.9631786346435547, "sampled_ll": -0.6626967191696167, "all_perturbed_sampled_ll": [-2.613888740539551], "all_perturbed_original_ll": [-4.853954315185547], "perturbed_sampled_ll": -2.613888740539551, "perturbed_original_ll": -4.853954315185547, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import java.util.*;\n\nclass Main{\n        public static void main(String[] args){\n                Scanner sc = new Scanner(System.in);\n                while(sc.hasNext()){\n                        String b = Integer.toString(sc.nextInt(), 2); \n                        String s = \"\"; \n                        for(int i = 0; i < b.length(); i++){\n                                if(b.charAt(b.length()-1-i) == '1'){\n                                        if(!s.equals(\"\")){\n                                                s += \" \";\n                                        }   \n                                        s += (int)Math.pow(2,i);\n                                }   \n                        }   \n                        System.out.println(s);\n                }   \n                sc.close();\n        }   \n}", "sampled": "import java.util.Scanner;\nimport java.util.ArrayList;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        \n        while (sc.hasNext()) {\n            int weight = sc.nextInt();\n            ArrayList<Integer> weights = new ArrayList<>();\n            \n            int[] powers = {1, 2, 4, 8, 16, 32, 64, 128, 256, 512};\n            \n            for (int i = 0; i < powers.length; i++) {\n                if ((weight & (1 << i)) != 0) {\n                    weights.add(powers[i]);\n                }\n            }\n            \n            for (int i = 0; i < weights.size(); i++) {\n                if (i > 0) System.out.print(\" \");\n                System.out.print(weights.get(i));\n            }\n            System.out.println();\n        }\n        \n        sc.close();\n    }\n}\n", "perturbed_sampled": ["import java.util.Scanner; import java.util.ArrayList; public class Main { public  Scanner sc   ArrayList<Integer>  powers = {1, 2, 4, 8, 16, 32, 64, 128, 256, 512}; for (int i = 0; i < powers.length;  (1  } }"], "perturbed_original": ["import   = new  Integer.toString(sc.nextInt(), 2);  i = 0; i  '1'){ if(!s.equals(\"\")){ s += \"  sc.close(); } }"], "original_ll": -1.0754268169403076, "sampled_ll": -0.5055698752403259, "all_perturbed_sampled_ll": [-1.7273786067962646], "all_perturbed_original_ll": [-4.816171646118164], "perturbed_sampled_ll": -1.7273786067962646, "perturbed_original_ll": -4.816171646118164, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "#encoding=utf-8\nimport itertools as iter\nimport sys\nfor i in sys.stdin:\n    omori = [1, 2, 4, 8, 16, 32, 64, 128, 256, 512]\n    x = int(i)\n    for i in xrange(1,11):\n        for element in iter.combinations(omori,i):\n             if sum(element) == x:\n                 for k in xrange(len(element)):\n                     print element[k],\n                 print \"\"", "sampled": "import sys\n\nfor line in sys.stdin:\n    weight = int(line.strip())\n    weights = []\n    power = 0\n    \n    while weight > 0:\n        if weight & 1:\n            weights.append(2 ** power)\n        weight >>= 1\n        power += 1\n    \n    print(' '.join(map(str, weights)))\n", "perturbed_sampled": ["import  weight =  =  if weight & 1: weights.append(2 ** power) weight >>=  '.join(map(str, weights)))"], "perturbed_original": ["#encoding=utf-8 import   8, 16,  x = int(i) for i in xrange(1,11):  sum(element)  xrange(len(element)): print element[k], print \"\""], "original_ll": -1.3029707670211792, "sampled_ll": -1.1976935863494873, "all_perturbed_sampled_ll": [-4.205206394195557], "all_perturbed_original_ll": [-3.6458547115325928], "perturbed_sampled_ll": -4.205206394195557, "perturbed_original_ll": -3.6458547115325928, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "#include <stdio.h>\n\nint main(void)\n{\n\tint tyou=0, hisi=0;\n\tint a, b, c;\n\t\n\twhile(scanf(\"%d,%d,%d\", &a, &b, &c)!=EOF) {\n\t\tif(c*c==a*a+b*b) tyou++;\n\t\tif(a==b) hisi++;\n\t}\n\t\n\tprintf(\"%d\\n%d\\n\", tyou, hisi);\n\t\n\treturn 0;\n}\n", "sampled": "#include <stdio.h>\n#include <string.h>\n\nint main() {\n    char line[256];\n    int rectangles = 0;\n    int rhombuses = 0;\n    \n    while (fgets(line, sizeof(line), stdin)) {\n        int a, b, c;\n        if (sscanf(line, \"%d,%d,%d\", &a, &b, &c) == 3) {\n            // Check if it's a rectangle: a^2 + b^2 = c^2\n            if (a * a + b * b == c * c) {\n                rectangles++;\n            }\n            // Check if it's a rhombus: a = b\n            else if (a == b) {\n                rhombuses++;\n            }\n        }\n    }\n    \n    printf(\"%d\\n\", rectangles);\n    printf(\"%d\\n\", rhombuses);\n    \n    return 0;\n}\n", "perturbed_sampled": ["#include <stdio.h> #include <string.h> int main() {  0; int rhombuses   &a,  a rectangle: a^2   } //  a = b else  rhombuses++; } } } printf(\"%d\\n\", rectangles); printf(\"%d\\n\", rhombuses); return 0; }"], "perturbed_original": [" a, b, c; while(scanf(\"%d,%d,%d\", &a, &b, &c)!=EOF) {  printf(\"%d\\n%d\\n\", tyou, hisi); return 0; }"], "original_ll": -1.362696886062622, "sampled_ll": -0.6247656941413879, "all_perturbed_sampled_ll": [-2.987856149673462], "all_perturbed_original_ll": [-2.3942344188690186], "perturbed_sampled_ll": -2.987856149673462, "perturbed_original_ll": -2.3942344188690186, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import java.util.Scanner;\n\nclass Main {\n\n\tpublic static void main(String[] args) {\n\n\t\tScanner sc = null;\n\t\ttry {\n\t\t\tsc = new Scanner(System.in);\n\t\t\tint countRectangle = 0;\n\t\t\tint countRhombus = 0;\n\t\t\twhile (sc.hasNextLine()) {\n\t\t\t\tString[] input = sc.nextLine().split(\",\");\n\t\t\t\tint[] x = new int[3];\n\t\t\t\tfor (int i = 0; i < 3; i++)\n\t\t\t\t\tx[i] = Integer.parseInt(input[i]);\n\t\t\t\tif (x[0] * x[0] + x[1] * x[1] == x[2] * x[2])\n\t\t\t\t\tcountRectangle++;\n\t\t\t\telse if (x[0] == x[1])\n\t\t\t\t\tcountRhombus++;\n\t\t\t}\n\t\t\tSystem.out.println(countRectangle);\n\t\t\tSystem.out.println(countRhombus);\n\t\t} finally {\n\t\t\tsc.close();\n\t\t}\n\t}\n}", "sampled": "import java.util.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int rectangles = 0;\n        int rhombuses = 0;\n        \n        while (sc.hasNextLine()) {\n            String line = sc.nextLine().trim();\n            if (line.isEmpty()) break;\n            \n            String[] parts = line.split(\",\");\n            int a = Integer.parseInt(parts[0]);\n            int b = Integer.parseInt(parts[1]);\n            int c = Integer.parseInt(parts[2]);\n            \n            // Check if rectangle: a^2 + b^2 = c^2 (diagonal satisfies Pythagorean theorem)\n            if (a * a + b * b == c * c) {\n                rectangles++;\n            }\n            // Check if rhombus: all sides equal (a == b)\n            else if (a == b) {\n                rhombuses++;\n            }\n        }\n        \n        System.out.println(rectangles);\n        System.out.println(rhombuses);\n        sc.close();\n    }\n}\n", "perturbed_sampled": ["import java.util.*; public class  main(String[] args) { Scanner sc = new Scanner(System.in);  rhombuses = 0; while (sc.hasNextLine())  parts =   c  rectangle: a^2 + b^2 = c^2 (diagonal  * b == c *  Check  (a  ==  }"], "perturbed_original": ["<extra_id_11>int<extra_id_12>{ int<extra_id_13>int<extra_id_14>i =<extra_id_15>] == j<extra_id_16>i <<extra_id_17>) countRectangle++; System.out.print(countRectangle);<extra_id_18>++ *<extra_id_22>++ ; int<extra_id_23>+ public  try { sc = new Scanner(System.in); int  { String[]  (int i =  x[i] =  ==  if (x[0] == x[1]) countRhombus++; } System.out.println(countRectangle); System.out.println(countRhombus); } finally { sc.close(); } } }"], "original_ll": -0.6246577501296997, "sampled_ll": -0.6703314781188965, "all_perturbed_sampled_ll": [-3.4245941638946533], "all_perturbed_original_ll": [-2.6745712757110596], "perturbed_sampled_ll": -3.4245941638946533, "perturbed_original_ll": -2.6745712757110596, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import math\nnum1=0                                          #\u9577\u65b9\u5f62\u306e\u6570                                                 \nnum2=0                                          #\u3072\u3057\u5f62\u306e\u6570\nwhile True:\n    try:\n        a,b,c=list(map(int, input().split(\",\")))\n    except:\n        break\n    \n    if pow(a,2)+pow(b,2)==pow(c,2):\n        num1+=1\n    elif a==b and a+b>c:\n        num2+=1\n\nprint(num1)\nprint(num2)\n\n", "sampled": "import sys\nimport math\n\nrectangle_count = 0\nrhombus_count = 0\n\nfor line in sys.stdin:\n    line = line.strip()\n    if not line:\n        continue\n    \n    parts = line.split(',')\n    a, b, c = int(parts[0]), int(parts[1]), int(parts[2])\n    \n    # Check if it's a rectangle\n    # In a rectangle, the diagonal satisfies: c^2 = a^2 + b^2\n    if a * a + b * b == c * c:\n        rectangle_count += 1\n    \n    # Check if it's a rhombus\n    # In a rhombus, all sides are equal: a == b\n    if a == b:\n        rhombus_count += 1\n\nprint(rectangle_count)\nprint(rhombus_count)\n", "perturbed_sampled": ["import <extra_id_6>a =<extra_id_7>a<extra_id_8>for a<extra_id_9>b += 1<extra_id_10>else: if<extra_id_11>0 for j<extra_id_12>rhombus_count += 1<extra_id_13>+= 1 print(rectangle_count)<extra_id_14>print(rectangle_count)<extra_id_15> 0 rhombus_count  parts = line.split(',') a, b,   c^2 = a^2 +  rectangle_count += 1 # Check if it's a rhombus # In a  a == b if a == b: rhombus_count += 1 print(rectangle_count) print(rhombus_count)"], "perturbed_original": [" #\u3072\u3057\u5f62\u306e\u6570 while  elif a==b and a+b>c: num2+=1 print(num1) print(num2)"], "original_ll": -1.7677839994430542, "sampled_ll": -0.735996425151825, "all_perturbed_sampled_ll": [-2.5676419734954834], "all_perturbed_original_ll": [-3.7689268589019775], "perturbed_sampled_ll": -2.5676419734954834, "perturbed_original_ll": -3.7689268589019775, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "#include<stdio.h>\n\nint main(){\n\n\tint i,j,n,a[10],b,c,nflag;\n\n\tscanf(\"%d\",&n);\n\n\tfor(i=0;i<n;i++){\n\t\tnflag=0;\n\t\tfor(j=0;j<9;j++) scanf(\"%d \",&a[j]);\n\t\tscanf(\"%d\",&a[9]);\n\n\t\tb=a[0];\n\t\tc=0;\n\t\tfor(j=1;j<10;j++){\n\t\t\tif(b<a[j]) b=a[j];\n\t\t\telse if(c<a[j]) c=a[j];\n\t\t\telse{\n\t\t\t\tprintf(\"NO\\n\");\n\t\t\t\tnflag=1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif(nflag) continue;\n\t\tprintf(\"YES\\n\");\n\n\t}\n\n\n\n\treturn 0;\n\n}", "sampled": "#include <stdio.h>\n#include <stdbool.h>\n\nbool canArrange(int balls[10]) {\n    // Try all possible combinations of putting balls in B or C\n    // Use bitmask: 0 = put in B, 1 = put in C\n    for (int mask = 0; mask < (1 << 10); mask++) {\n        int b[10], c[10];\n        int bCount = 0, cCount = 0;\n        bool valid = true;\n        \n        // Distribute balls according to mask\n        for (int i = 0; i < 10; i++) {\n            if ((mask & (1 << i)) == 0) {\n                // Put in B\n                if (bCount > 0 && b[bCount - 1] > balls[i]) {\n                    valid = false;\n                    break;\n                }\n                b[bCount++] = balls[i];\n            } else {\n                // Put in C\n                if (cCount > 0 && c[cCount - 1] > balls[i]) {\n                    valid = false;\n                    break;\n                }\n                c[cCount++] = balls[i];\n            }\n        }\n        \n        if (valid) {\n            return true;\n        }\n    }\n    \n    return false;\n}\n\nint main() {\n    int n;\n    scanf(\"%d\", &n);\n    \n    for (int i = 0; i < n; i++) {\n        int balls[10];\n        for (int j = 0; j < 10; j++) {\n            scanf(\"%d\", &balls[j]);\n        }\n        \n        if (canArrange(balls)) {\n            printf(\"YES\\n\");\n        } else {\n            printf(\"NO\\n\");\n        }\n    }\n    \n    return 0;\n}\n", "perturbed_sampled": ["#include <stdio.h> #include <stdbool.h> bool canArrange(int  possible combinations of putting balls  Use bitmask: 0 = put in  = 0;  0, cCount = 0; bool valid  (int i = 0; i  ((mask & (1 << i))  in B if  - 1] >  break;  else { // Put in C if (cCount > 0   break; } c[cCount++]  } } return false; } int main()  for  j =  if (canArrange(balls)) {  }"], "perturbed_original": ["#include<stdio.h> int  nflag=0; for(j=0;j<9;j++) scanf(\"%d \",&a[j]);  else{ printf(\"NO\\n\"); nflag=1; break; }  return 0; }"], "original_ll": -1.075134515762329, "sampled_ll": -0.5315077900886536, "all_perturbed_sampled_ll": [-3.5375068187713623], "all_perturbed_original_ll": [-2.1919243335723877], "perturbed_sampled_ll": -3.5375068187713623, "perturbed_original_ll": -2.1919243335723877, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "\nimport java.util.Scanner;\n\npublic class Main {\n\n\tprivate static final int N = 12;\n\tint[] a = new int[N];\n\tint small = 0;\n\tint big = 0;\n\t\n\tprivate int s=0;     //\u6570?\u7684\u4e2a\u6570\n\t\n\tpublic static void main(String[] args) {\n\t\tMain m = new Main();\n\t\tm.Sort();\n\t}\n\t\n\t\n\tprivate void Sort(){\t\n\n\t\tScanner sc = new Scanner(System.in);\n\t\ts = sc.nextInt();\n\t\t\n\t\twhile(s!= 0){\t\n\t\t\t\n\t\t\tfor (int i = 1; i <= 10; i++) {\n\t\t\t\ta[i] = sc.nextInt();\n\t\t\t}\n\t\t\t\n\t\t\t/*for (int m = 1; m <= 10; m++) {\n\t\t\t\tSystem.out.print(a[m]+ \" \");\n\t\t\t}*/\n\t\t\t\n\t\t\tif (a[1] > a[2]) {\n\t\t\t\tbig = a[1];\n\t\t\t\tsmall = a[2];\n\t\t\t}else {\n\t\t\t\tbig = a[2];\n\t\t\t\tsmall = a[1];\n\t\t\t}\n\t\t\t//System.out.println(big);\n\t\t\t\n\t\t\tfor (int j = 3; j <= 10; j++) {\n\t\t\t\tif (a[j] > big) {\n\t\t\t\t\tbig = a[j];\n\t\t\t\t}\n\t\t\t\tif (a[j] < big && a[j] > small) {\n\t\t\t\t\tsmall = a[j];\n\t\t\t\t}\n\t\t\t\tif (a[j] < small) {\n\t\t\t\t\tSystem.out.printf(\"%s\\n\",\"NO\");\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (j == 10) {\n\t\t\t\t\tSystem.out.printf(\"%s\\n\",\"YES\");\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\t\t\t//System.out.println(s);\n\t\t\ts--;\n\t\t\t\t\n\t\t}\n\t\tsc.close();\n\t}\n}", "sampled": "import java.util.*;\n\npublic class Main {\n    static int[] balls;\n    \n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int n = sc.nextInt();\n        \n        for (int i = 0; i < n; i++) {\n            balls = new int[10];\n            for (int j = 0; j < 10; j++) {\n                balls[j] = sc.nextInt();\n            }\n            \n            if (canArrange(0, new ArrayList<>(), new ArrayList<>())) {\n                System.out.println(\"YES\");\n            } else {\n                System.out.println(\"NO\");\n            }\n        }\n        sc.close();\n    }\n    \n    static boolean canArrange(int index, List<Integer> b, List<Integer> c) {\n        if (index == 10) {\n            return true;\n        }\n        \n        int current = balls[index];\n        \n        // Try to put in B\n        boolean canPutInB = true;\n        if (!b.isEmpty() && b.get(b.size() - 1) > current) {\n            canPutInB = false;\n        }\n        \n        if (canPutInB) {\n            b.add(current);\n            if (canArrange(index + 1, b, c)) {\n                return true;\n            }\n            b.remove(b.size() - 1);\n        }\n        \n        // Try to put in C\n        boolean canPutInC = true;\n        if (!c.isEmpty() && c.get(c.size() - 1) > current) {\n            canPutInC = false;\n        }\n        \n        if (canPutInC) {\n            c.add(current);\n            if (canArrange(index + 1, b, c)) {\n                return true;\n            }\n            c.remove(c.size() - 1);\n        }\n        \n        return false;\n    }\n}\n", "perturbed_sampled": ["import java.util.*; <extra_id_8>hasNext() ||<extra_id_9>{<extra_id_10>return false;<extra_id_11>; // Try<extra_id_12>JDBMETRY canGetValue = (<extra_id_13>list) { //if(b.isEmpty() && !b.isEmpty( )<extra_id_14>hasNext() || !canGetValue<extra_id_15> int[] balls;   (int j = 0;  balls[j] = sc.nextInt(); } if (canArrange(0, new ArrayList<>(), new ArrayList<>())) { System.out.println(\"YES\"); } else { System.out.println(\"NO\");  boolean canArrange(int index, List<Integer> b,  == 10) { return true; } int current = balls[index]; // Try  canPutInB = true; if (!b.isEmpty() && b.get(b.size() - 1) > current) { canPutInB =  return true;      =   true; }  false; } }"], "perturbed_original": ["import java.util.Scanner; public class  int[] a = new int[N]; int small = 0; int big = 0; private int s=0; //\u6570?\u7684\u4e2a\u6570 public static void main(String[] args) { Main m =  = new Scanner(System.in); s = sc.nextInt(); while(s!= 0){ for (int i = 1;  /*for  if  = a[1]; small  =  =  { if (a[j]  < big && a[j]  break; }  } }"], "original_ll": -0.9852482080459595, "sampled_ll": -0.4311102330684662, "all_perturbed_sampled_ll": [-2.8612372875213623], "all_perturbed_original_ll": [-2.910165309906006], "perturbed_sampled_ll": -2.8612372875213623, "perturbed_original_ll": -2.910165309906006, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "for data in range(input()):\n    dataset=map(int,raw_input().split(\" \"))\n    B,C=0,0\n    B=dataset.pop(0)\n    while len(dataset)!=0:\n        ball = dataset.pop(0)\n        if ball-B<0 or ball-C<0:\n            if ball-B<0 and ball-C<0:\n                print \"NO\"\n                break\n            elif ball-B<0:\n                C=ball\n            else:\n                B=ball\n        else:\n            if ball-B<ball-C:\n                B=ball\n            else:\n                C=ball\n    if(len(dataset)==0):\n        print \"YES\"", "sampled": "def can_sort(sequence):\n    def is_valid(b_stack, c_stack, index):\n        if index == 10:\n            return True\n        \n        ball = sequence[index]\n        \n        # Try putting in B\n        can_put_b = len(b_stack) == 0 or b_stack[-1] < ball\n        if can_put_b:\n            b_stack.append(ball)\n            if is_valid(b_stack, c_stack, index + 1):\n                return True\n            b_stack.pop()\n        \n        # Try putting in C\n        can_put_c = len(c_stack) == 0 or c_stack[-1] < ball\n        if can_put_c:\n            c_stack.append(ball)\n            if is_valid(b_stack, c_stack, index + 1):\n                return True\n            c_stack.pop()\n        \n        return False\n    \n    return is_valid([], [], 0)\n\nn = int(input())\nfor _ in range(n):\n    sequence = list(map(int, input().split()))\n    if can_sort(sequence):\n        print(\"YES\")\n    else:\n        print(\"NO\")\n", "perturbed_sampled": ["def can_sort(sequence): def is_valid(b_stack, c_stack,  sequence[index] # Try putting in B can_put_b = len(b_stack)  ball if can_put_b: b_stack.append(ball)  < ball  return True c_stack.pop()  0)  in range(n): sequence = list(map(int, input().split())) if can_sort(sequence): print(\"YES\") else: print(\"NO\")"], "perturbed_original": ["for data in range(input()):  len(dataset)!=0: ball = dataset.pop(0) if ball-B<0 or  ball-B<0: C=ball   \"YES\""], "original_ll": -1.2449607849121094, "sampled_ll": -0.7508653402328491, "all_perturbed_sampled_ll": [-3.179537773132324], "all_perturbed_original_ll": [-4.153415203094482], "perturbed_sampled_ll": -3.179537773132324, "perturbed_original_ll": -4.153415203094482, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "#include<stdio.h>\nmain(){\n  int i,ans;\n  double l[10],km,k,v[2];\n  while(scanf(\"%lf,%lf,%lf,%lf,%lf,%lf,%lf,%lf,%lf,%lf,%lf,%lf\",&l[0],&l[1],&l[2],&l[3],&l[4],&l[5],&l[6],&l[7],&l[8],&l[9],&v[0],&v[1])!=EOF){\n    km=l[0]+l[1]+l[2]+l[3]+l[4]+l[5]+l[6]+l[7]+l[8]+l[9];\n    k=km*v[0]/(v[0]+v[1]);\n    for(i=0;i>=0;i++){\n      k-=l[i];\n      if(k<=0){\n\tans=i+1;\n\ti=-2;\n      }\n    }\n    printf(\"%d\\n\",ans);\n  }\n  return 0;\n}", "sampled": "#include <stdio.h>\n#include <string.h>\n\nint main() {\n    char line[256];\n    \n    while (fgets(line, sizeof(line), stdin)) {\n        int l[10];\n        int v1, v2;\n        \n        sscanf(line, \"%d,%d,%d,%d,%d,%d,%d,%d,%d,%d,%d,%d\",\n               &l[0], &l[1], &l[2], &l[3], &l[4],\n               &l[5], &l[6], &l[7], &l[8], &l[9],\n               &v1, &v2);\n        \n        // Calculate total distance\n        int total = 0;\n        for (int i = 0; i < 10; i++) {\n            total += l[i];\n        }\n        \n        // Calculate cumulative distances from left\n        int cum[11];\n        cum[0] = 0;\n        for (int i = 0; i < 10; i++) {\n            cum[i + 1] = cum[i] + l[i];\n        }\n        \n        // Find meeting point\n        // Train 1 travels distance d1 = v1 * t\n        // Train 2 travels distance d2 = v2 * t\n        // d1 + d2 = total\n        // v1 * t + v2 * t = total\n        // t = total / (v1 + v2)\n        // d1 = v1 * total / (v1 + v2)\n        \n        double d1 = (double)v1 * total / (v1 + v2);\n        \n        // Find which section this is in\n        for (int i = 0; i < 10; i++) {\n            if (d1 <= cum[i + 1]) {\n                printf(\"%d\\n\", i + 1);\n                break;\n            }\n        }\n    }\n    \n    return 0;\n}\n", "perturbed_sampled": ["#include <stdio.h> #include <string.h> int main() { char line[256];  int  = 0; i  += l[i]; } // Calculate cumulative distances from left int  (int i = 0; i < 10; i++) { cum[i + 1] = cum[i]  1  2  + d2 = total  v2 * t = total  (v1  v1 * total / (v1   in  i < 10; i++) {  1]) { printf(\"%d\\n\", i + 1); break;  }"], "perturbed_original": ["#include<stdio.h> main(){ int  ans=i+1; i=-2; } } printf(\"%d\\n\",ans); } return 0; }"], "original_ll": -0.9417028427124023, "sampled_ll": -0.6957040429115295, "all_perturbed_sampled_ll": [-2.7444114685058594], "all_perturbed_original_ll": [-2.6820623874664307], "perturbed_sampled_ll": -2.7444114685058594, "perturbed_original_ll": -2.6820623874664307, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\n\npublic class Main {\n\tpublic static void main(String[] args) throws IOException {\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\tString line = null;\n\t\tint[] l = new int[10];\n\t\tint[] v = new int[2];\n\n\t\twhile ((line = br.readLine()) != null) {\n\t\t\tString[] data = line.trim().split(\",\");\n\t\t\tint distance = 0;\n\t\t\tfor (int i = 0; i < 10; i++) {\n\t\t\t\tl[i] = Integer.parseInt(data[i]);\n\t\t\t\tdistance += l[i];\n\t\t\t}\n\t\t\tfor (int i = 0; i < 2; i++)\n\t\t\t\tv[i] = Integer.parseInt(data[i + 10]);\n\t\t\tdouble see = distance * ((double) v[0] / (v[1] + v[0]));\n\n\t\t\tfor (int i = 0; i < 10; i++) {\n\t\t\t\tif (see - l[i] > 0) {\n\t\t\t\t\tsee -= l[i];\n\t\t\t\t} else {\n\t\t\t\t\tSystem.out.println(i + 1);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}", "sampled": "import java.util.*;\nimport java.io.*;\n\npublic class Main {\n    public static void main(String[] args) throws IOException {\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        String line;\n        \n        while ((line = br.readLine()) != null) {\n            line = line.trim();\n            if (line.isEmpty()) break;\n            \n            String[] parts = line.split(\",\");\n            int[] lengths = new int[10];\n            for (int i = 0; i < 10; i++) {\n                lengths[i] = Integer.parseInt(parts[i].trim());\n            }\n            int v1 = Integer.parseInt(parts[10].trim());\n            int v2 = Integer.parseInt(parts[11].trim());\n            \n            // Calculate cumulative distances from station 0\n            int[] cumDist = new int[11];\n            cumDist[0] = 0;\n            for (int i = 0; i < 10; i++) {\n                cumDist[i + 1] = cumDist[i] + lengths[i];\n            }\n            int totalDistance = cumDist[10];\n            \n            // They meet when: distance1 + distance2 = totalDistance\n            // time is same for both: t = distance1 / v1 = distance2 / v2\n            // distance1 = v1 * t, distance2 = v2 * t\n            // v1 * t + v2 * t = totalDistance\n            // t = totalDistance / (v1 + v2)\n            // distance1 = v1 * totalDistance / (v1 + v2)\n            \n            double meetDistance = (double) v1 * totalDistance / (v1 + v2);\n            \n            // Find which section this distance falls into\n            int section = 1;\n            for (int i = 1; i <= 10; i++) {\n                if (meetDistance <= cumDist[i]) {\n                    section = i;\n                    break;\n                }\n            }\n            \n            System.out.println(section);\n        }\n    }\n}\n", "perturbed_sampled": ["import java.util.*;  { BufferedReader br =  = line.trim(); if  new int[10];  { lengths[i] = Integer.parseInt(parts[i].trim()); } int v1 = Integer.parseInt(parts[10].trim()); int  0 int[] cumDist = new int[11]; cumDist[0] = 0; for (int i = 0; i < 10;   same for both: t = distance1  v2 //  t // v1 * t + v2 * t = totalDistance //  + v2) // distance1 = v1 *  double   int section   <= cumDist[i]) { section = i; break; } } System.out.println(section); } } }"], "perturbed_original": ["import java.io.BufferedReader; import java.io.IOException; import java.io.InputStreamReader; public class Main { public  IOException { BufferedReader br = new  null; int[] l  ((line = br.readLine()) != null) {  distance = 0;  i < 10; i++)  (int i = 0; i   = distance *  v[0]));   >    } }"], "original_ll": -0.6926061511039734, "sampled_ll": -0.7299249172210693, "all_perturbed_sampled_ll": [-2.8722572326660156], "all_perturbed_original_ll": [-3.081056833267212], "perturbed_sampled_ll": -2.8722572326660156, "perturbed_original_ll": -3.081056833267212, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "while True:\n    try:\n        l1,l2,l3,l4,l5,l6,l7,l8,l9,l10,v1,v2=map(int,input().split(\",\"))\n        kyo=0\n        for i in l1,l2,l3,l4,l5,l6,l7,l8,l9,l10:\n            kyo +=i\n        v=v1+v2\n        x=kyo/v\n        ans=v1*x\n        flag=0\n        for j in l1,l2,l3,l4,l5,l6,l7,l8,l9,l10:\n            if ans>0:\n                ans -=j\n                flag +=1\n            elif ans==0:\n                print(flag)\n                break\n            elif ans<0:\n                print(flag)\n                break\n    except:break\n\n", "sampled": "import sys\n\nfor line in sys.stdin:\n    parts = line.strip().split(',')\n    lengths = list(map(int, parts[:10]))\n    v1, v2 = int(parts[10]), int(parts[11])\n    \n    total_length = sum(lengths)\n    \n    # Time when trains meet\n    t_meet = total_length / (v1 + v2)\n    \n    # Distance traveled by train from section 1 side\n    d1 = v1 * t_meet\n    \n    # Find which section this distance falls into\n    cumulative = 0\n    for i in range(10):\n        cumulative += lengths[i]\n        if d1 <= cumulative:\n            print(i + 1)\n            break\n", "perturbed_sampled": ["import sys for line  lengths = list(map(int, parts[:10])) v1, v2  sum(lengths) #  traveled by train from section 1  t_meet # Find which section this distance falls   break"], "perturbed_original": ["while True: try:  l1,l2,l3,l4,l5,l6,l7,l8,l9,l10: kyo   ans>0: ans -=j flag +=1 elif ans==0:  break except:break"], "original_ll": -1.0209673643112183, "sampled_ll": -1.3985567092895508, "all_perturbed_sampled_ll": [-5.020118713378906], "all_perturbed_original_ll": [-3.245217800140381], "perturbed_sampled_ll": -5.020118713378906, "perturbed_original_ll": -3.245217800140381, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "#include <stdio.h>\n\ndouble gaiseki(double x0,double y0,double x1,double y1,double x2,double y2){\nreturn(x0-x1)*(y0-y1)-(x0-x2)*(y0-y2);\n}\nint main(){\ndouble x0,y0,x1,y1,x2,y2,x3,y3;\nwhile (scanf(\"%lf,%lf,%lf,%lf,%lf,%lf,%lf,%lf\",&x0,&y0,&x1,&y1,&x2,&y2,&x3,&y3)!=EOF){\nif (gaiseki(x0,y0,x1,y1,x3,y3)>=0&&gaiseki(x1,y1,x2,y2,x3,y3)>=0&&gaiseki(x2,y2,x0,y0,x3,y3)>=0){\nprintf(\"YES\\n\");\n}else{\nprintf(\"NO\\n\");\n}\n}\nreturn 0;\n}", "sampled": "#include <stdio.h>\n\ndouble cross(double ax, double ay, double bx, double by, double cx, double cy) {\n    return (bx - ax) * (cy - ay) - (by - ay) * (cx - ax);\n}\n\nint main() {\n    double xa, ya, xb, yb, xc, yc, xd, yd;\n    \n    while (scanf(\"%lf,%lf,%lf,%lf,%lf,%lf,%lf,%lf\", \n                 &xa, &ya, &xb, &yb, &xc, &yc, &xd, &yd) == 8) {\n        \n        double c1 = cross(xa, ya, xb, yb, xc, yc);\n        double c2 = cross(xb, yb, xc, yc, xd, yd);\n        double c3 = cross(xc, yc, xd, yd, xa, ya);\n        double c4 = cross(xd, yd, xa, ya, xb, yb);\n        \n        if ((c1 > 0 && c2 > 0 && c3 > 0 && c4 > 0) ||\n            (c1 < 0 && c2 < 0 && c3 < 0 && c4 < 0)) {\n            printf(\"YES\\n\");\n        } else {\n            printf(\"NO\\n\");\n        }\n    }\n    \n    return 0;\n}\n", "perturbed_sampled": ["#include  by,  return (bx -  * (cx - ax);   (scanf(\"%lf,%lf,%lf,%lf,%lf,%lf,%lf,%lf\", &xa, &ya, &xb,  == 8) { double c1 = cross(xa, ya, xb,  = cross(xb, yb, xc, yc, xd, yd); double c3 = cross(xc, yc, xd,  = cross(xd, yd, xa,    { printf(\"YES\\n\"); } else { printf(\"NO\\n\"); } } return 0; }"], "perturbed_original": ["#include <stdio.h>  } int  if (gaiseki(x0,y0,x1,y1,x3,y3)>=0&&gaiseki(x1,y1,x2,y2,x3,y3)>=0&&gaiseki(x2,y2,x0,y0,x3,y3)>=0){ printf(\"YES\\n\"); }else{ printf(\"NO\\n\"); } } return 0; }"], "original_ll": -0.752171516418457, "sampled_ll": -0.4255961775779724, "all_perturbed_sampled_ll": [-2.264171600341797], "all_perturbed_original_ll": [-1.703613042831421], "perturbed_sampled_ll": -2.264171600341797, "perturbed_original_ll": -1.703613042831421, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import java.util.*;class Main{public static void main(String[]z){double[]b=new double[8];for(Scanner s=new Scanner(System.in);s.hasNext();System.out.println((f(b[0],b[1],b[4],b[5],b[6],b[7])>0&&f(b[4],b[5],b[0],b[1],b[2],b[3])>0&&f(b[2],b[3],b[6],b[7],b[0],b[1])>0&&f(b[6],b[7],b[2],b[3],b[4],b[5])>0)||(f(b[0],b[1],b[4],b[5],b[6],b[7])<0&&f(b[4],b[5],b[0],b[1],b[2],b[3])<0&&f(b[2],b[3],b[6],b[7],b[0],b[1])<0&&f(b[6],b[7],b[2],b[3],b[4],b[5])<0)?\"YES\":\"NO\")){z=s.next().split(\",\");for(int i=0;i<8;++i)b[i]=new Double(z[i]);}}static double f(double a,double b,double c,double d,double e,double f){return ((d-b)*e+(a-c)*f+c*b-a*d);}}", "sampled": "import java.util.Scanner;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        \n        while (sc.hasNext()) {\n            String line = sc.nextLine();\n            String[] parts = line.split(\",\");\n            \n            double xa = Double.parseDouble(parts[0]);\n            double ya = Double.parseDouble(parts[1]);\n            double xb = Double.parseDouble(parts[2]);\n            double yb = Double.parseDouble(parts[3]);\n            double xc = Double.parseDouble(parts[4]);\n            double yc = Double.parseDouble(parts[5]);\n            double xd = Double.parseDouble(parts[6]);\n            double yd = Double.parseDouble(parts[7]);\n            \n            double cross1 = crossProduct(xa, ya, xb, yb, xc, yc);\n            double cross2 = crossProduct(xb, yb, xc, yc, xd, yd);\n            double cross3 = crossProduct(xc, yc, xd, yd, xa, ya);\n            double cross4 = crossProduct(xd, yd, xa, ya, xb, yb);\n            \n            boolean allPositive = cross1 > 0 && cross2 > 0 && cross3 > 0 && cross4 > 0;\n            boolean allNegative = cross1 < 0 && cross2 < 0 && cross3 < 0 && cross4 < 0;\n            \n            if (allPositive || allNegative) {\n                System.out.println(\"YES\");\n            } else {\n                System.out.println(\"NO\");\n            }\n        }\n        \n        sc.close();\n    }\n    \n    private static double crossProduct(double x1, double y1, double x2, double y2, double x3, double y3) {\n        double v1x = x2 - x1;\n        double v1y = y2 - y1;\n        double v2x = x3 - x2;\n        double v2y = y3 - y2;\n        return v1x * v2y - v1y * v2x;\n    }\n}\n", "perturbed_sampled": ["import  args)  String[] parts = line.split(\",\"); double xa = Double.parseDouble(parts[0]);  xc = Double.parseDouble(parts[4]);  xd  Double.parseDouble(parts[7]); double cross1 = crossProduct(xa, ya, xb,  = crossProduct(xb,  double cross3 =  = cross1 > 0  cross3  0; boolean allNegative = cross1 < 0 && cross2  0; if (allPositive || allNegative) { System.out.println(\"YES\"); } else { System.out.println(\"NO\"); } }  crossProduct(double  x1; double v1y =  = x3 - x2; double v2y = y3 - y2; return v1x *  } }"], "perturbed_original": ["import java.util.*;class Main{public  Scanner(System.in);s.hasNext();System.out.println((f(b[0],b[1],b[4],b[5],b[6],b[7])>0&&f(b[4],b[5],b[0],b[1],b[2],b[3])>0&&f(b[2],b[3],b[6],b[7],b[0],b[1])>0&&f(b[6],b[7],b[2],b[3],b[4],b[5])>0)||(f(b[0],b[1],b[4],b[5],b[6],b[7])<0&&f(b[4],b[5],b[0],b[1],b[2],b[3])<0&&f(b[2],b[3],b[6],b[7],b[0],b[1])<0&&f(b[6],b[7],b[2],b[3],b[4],b[5])<0)?\"YES\":\"NO\")){z=s.next().split(\",\");for(int i=0;i<8;++i)b[i]=new Double(z[i]);}}static double f(double a,double  ((d-b)*e+(a-c)*f+c*b-a*d);}}"], "original_ll": -0.7968534231185913, "sampled_ll": -0.2911105155944824, "all_perturbed_sampled_ll": [-2.4687838554382324], "all_perturbed_original_ll": [-1.0365487337112427], "perturbed_sampled_ll": -2.4687838554382324, "perturbed_original_ll": -1.0365487337112427, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "from __future__ import (division, absolute_import, print_function,\n                        unicode_literals)\nfrom sys import stdin\nfrom collections import namedtuple\nPoint = namedtuple('Point', 'x y')\n\ndef make_test(p1, p2):\n    if p1.x == p2.x:\n        gradient = p1.x\n        return lambda p: gradient > p.x\n    gradient = (p1.y - p2.y) / (p1.x - p2.x)\n    y_intercept = p1.y - gradient * p1.x\n    return lambda p: gradient * p.x + y_intercept > p.y\n\nfor line in stdin:\n    it = (float(s) for s in line.split(','))\n    A, B, C, D = (Point(next(it), next(it)) for _ in xrange(4))\n\n    f = make_test(A, C)\n    g = make_test(B, D)\n    if f(B) == f(D) or g(A) == g(C):\n        print('NO')\n    else:\n        print('YES')", "sampled": "import sys\n\ndef cross_product(o, a, b):\n    return (a[0] - o[0]) * (b[1] - o[1]) - (a[1] - o[1]) * (b[0] - o[0])\n\ndef is_convex(points):\n    n = len(points)\n    sign = None\n    \n    for i in range(n):\n        o = points[i]\n        a = points[(i + 1) % n]\n        b = points[(i + 2) % n]\n        \n        cp = cross_product(o, a, b)\n        \n        if cp != 0:\n            if sign is None:\n                sign = cp > 0\n            elif (cp > 0) != sign:\n                return False\n    \n    return True\n\nfor line in sys.stdin:\n    coords = list(map(float, line.strip().split(',')))\n    points = [(coords[i], coords[i+1]) for i in range(0, 8, 2)]\n    \n    if is_convex(points):\n        print(\"YES\")\n    else:\n        print(\"NO\")\n", "perturbed_sampled": [" b): return (a[0] - o[0]) * (b[1] - o[1]) - (a[1] - o[1]) *   1) %  if cp != 0: if sign is  0  sign: return False return True for line in sys.stdin: coords  [(coords[i], coords[i+1]) for  print(\"NO\")"], "perturbed_original": ["from __future__ import    return lambda p: gradient > p.x  /  p1.y - gradient * p1.x  p.y for line in stdin: it = (float(s)  B, C, D = (Point(next(it), next(it)) for _ in   f(B)  g(C): print('NO') else: print('YES')"], "original_ll": -1.1101133823394775, "sampled_ll": -0.638117790222168, "all_perturbed_sampled_ll": [-3.008061170578003], "all_perturbed_original_ll": [-4.125452041625977], "perturbed_sampled_ll": -3.008061170578003, "perturbed_original_ll": -4.125452041625977, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "#include<stdio.h>\n\n#define X 8\n#define Y 8\n#define L 3\n#define M 2\n#define S 1\n\n\nint main(void)\n{\n        char ppr[X][Y];/*\u7d19*/\n        int x = 0, y = 0;\n        int i = 0, j = 0;\n        int size = 0;\n        int count = 0;\n        int max = 0;\n        int farst = 0;\n        int k = 0;\n        int h = 0;\n        char ans[4][2];\n\n        for(i = 0; i < X; i++)\n        {\n                for(j = 0;j < Y; j++)\n                {\n                        ppr[i][j] = '0';\n                }\n        }\n\n        for(i = 0; i < 4; i++)\n        {\n                for(j = 0;j < 2; j++)\n                {\n                        ans[i][j] = '0';\n                }\n        }\n\n        while(scanf(\"%s\", ppr[0]) != EOF)\n        {\n                for(i = 1; i < X; i++)\n                {\n                        scanf(\"%s\", ppr[i]);\n                }\n                for(i = 0; i < X; i++)\n                {\n                        for(j = 0; j < Y; j++)\n                        {\n                                if( ppr[i][j] == '1')\n                                {\n                                        ans[k][0] = j;\n                                        ans[k][1] = i;\n                                        k++;\n                                }\n                        }\n                }\n/*\n                for(i = 0;i < 4; i++)\n                {\n                        printf(\"%d %d\\n\",ans[i][0],ans[i][1]);\n                }\n*/\n                x = ans[0][0];\n                y = ans[0][1];\n                ans[0][0] -= x; ans[0][1] -= y;\n                ans[1][0] -= x; ans[1][1] -= y;\n                ans[2][0] -= x; ans[2][1] -= y;\n                ans[3][0] -= x; ans[3][1] -= y;\n                /*\n                for(i = 0;i < 4; i++)\n                {\n                        printf(\"%d %d\\n\",ans[i][0],ans[i][1]);\n                }*/\n\n                if(ans[0][0] ==  0 && ans[0][1] == 0 &&\n                   ans[1][0] ==  0 && ans[1][1] == 1 &&\n                   ans[2][0] ==  1 && ans[2][1] == 0 &&\n                   ans[3][0] ==  1 && ans[3][1] == 1 )\n                {\n                        printf(\"A\\n\");\n                }\n                else if(ans[0][0] == 0 &&ans[0][1] == 0 &&\n                   ans[1][0] ==  1 && ans[1][1] == 0 &&\n                   ans[2][0] ==  2 && ans[2][1] == 0 &&\n                   ans[3][0] ==  3 && ans[3][1] == 0 )\n                {\n                        printf(\"B\\n\");\n                }\n                else if(ans[0][0] ==  0 && ans[0][1] == 0 &&\n                        ans[1][0] ==  0 && ans[1][1] == 1 &&\n                        ans[2][0] ==  0 && ans[2][1] == 2 &&\n                        ans[3][0] ==  0 && ans[3][1] == 3 )\n                {\n                        printf(\"C\\n\");\n                }\n                else if(ans[0][0] ==  0 && ans[0][1] == 1 &&\n                        ans[1][0] ==  1 && ans[1][1] == 0 &&\n                        ans[2][0] ==  1 && ans[2][1] == 1 &&\n                        ans[3][0] ==  2 && ans[3][1] == 0 )\n                {\n                        printf(\"D\\n\");\n                }\n                else if(ans[0][0] ==  0 && ans[0][1] == 0 &&\n                        ans[1][0] ==  0 && ans[1][1] == 1 &&\n                        ans[2][0] ==  1 && ans[2][1] == 1 &&\n                        ans[3][0] ==  1 && ans[3][1] == 2 )\n                {\n                        printf(\"E\\n\");\n                }\n                else if(ans[0][0] ==  0 && ans[0][1] == 0 &&\n                        ans[1][0] ==  1 && ans[1][1] == 0 &&\n                        ans[2][0] ==  1 && ans[2][1] == 1 &&\n                        ans[3][0] ==  2 && ans[3][1] == 1 )\n                {\n                        printf(\"F\\n\");\n                }\n                else if(ans[0][0] ==  0 && ans[0][1] == 1 &&\n                        ans[1][0] ==  0 && ans[1][1] == 2 &&\n                        ans[2][0] ==  1 && ans[2][1] == 0 &&\n                        ans[3][0] ==  1 && ans[3][1] == 1 )\n                {\n                        printf(\"G\\n\");\n                }\n\n\n        }\n\n        return 0;\n}", "sampled": "#include <stdio.h>\n#include <string.h>\n\nint main() {\n    char grid[8][9];\n    \n    while(scanf(\"%s\", grid[0]) != EOF) {\n        for(int i = 1; i < 8; i++) {\n            scanf(\"%s\", grid[i]);\n        }\n        \n        // Extract the shape pattern\n        int minR = 8, maxR = -1, minC = 8, maxC = -1;\n        for(int i = 0; i < 8; i++) {\n            for(int j = 0; j < 8; j++) {\n                if(grid[i][j] == '1') {\n                    if(i < minR) minR = i;\n                    if(i > maxR) maxR = i;\n                    if(j < minC) minC = j;\n                    if(j > maxC) maxC = j;\n                }\n            }\n        }\n        \n        int height = maxR - minR + 1;\n        int width = maxC - minC + 1;\n        \n        // Extract normalized pattern\n        int pattern[4][4] = {0};\n        for(int i = minR; i <= maxR; i++) {\n            for(int j = minC; j <= maxC; j++) {\n                if(grid[i][j] == '1') {\n                    pattern[i-minR][j-minC] = 1;\n                }\n            }\n        }\n        \n        // Check each shape\n        char result = '?';\n        \n        // Shape A: 2x2 square\n        if(height == 2 && width == 2 && \n           pattern[0][0] && pattern[0][1] && \n           pattern[1][0] && pattern[1][1]) {\n            result = 'A';\n        }\n        // Shape B: 1x4 horizontal\n        else if(height == 1 && width == 4 && \n                pattern[0][0] && pattern[0][1] && \n                pattern[0][2] && pattern[0][3]) {\n            result = 'B';\n        }\n        // Shape C: 4x1 vertical\n        else if(height == 4 && width == 1 && \n                pattern[0][0] && pattern[1][0] && \n                pattern[2][0] && pattern[3][0]) {\n            result = 'C';\n        }\n        // Shape D: 3x1 vertical\n        else if(height == 3 && width == 1 && \n                pattern[0][0] && pattern[1][0] && \n                pattern[2][0]) {\n            result = 'D';\n        }\n        // Shape E: zigzag\n        else if(height == 2 && width == 3 && \n                pattern[0][0] && pattern[0][1] && !pattern[0][2] &&\n                !pattern[1][0] && pattern[1][1] && pattern[1][2]) {\n            result = 'E';\n        }\n        // Shape F: reverse zigzag\n        else if(height == 2 && width == 3 && \n                !pattern[0][0] && pattern[0][1] && pattern[0][2] &&\n                pattern[1][0] && pattern[1][1] && !pattern[1][2]) {\n            result = 'F';\n        }\n        // Shape G: L-shape\n        else if(height == 2 && width == 2 && \n                pattern[0][0] && !pattern[0][1] && \n                pattern[1][0] && pattern[1][1]) {\n            result = 'G';\n        }\n        \n        printf(\"%c\\n\", result);\n    }\n    \n    return 0;\n}\n", "perturbed_sampled": ["#include <stdio.h> #include <string.h> int main() { char grid[8][9]; while(scanf(\"%s\",  i = 1; i  grid[i]);  8, maxR  < 8; i++) { for(int j =  { if(grid[i][j] == '1')  = i; if(i  =  = j; }  maxR  minC + 1; // Extract normalized pattern  <=  = minC; j  == '1') { pattern[i-minR][j-minC]  // Check  2 && width == 2 && pattern[0][0] && pattern[0][1] &&   if(height == 1 && width == 4 && pattern[0][0] && pattern[0][1] && pattern[0][2] && pattern[0][3]) {  Shape C: 4x1 vertical else if(height == 4  pattern[0][0]  pattern[3][0])  //  if(height == 3 && width == 1 && pattern[0][0] &&  = 'D'; } // Shape E: zigzag  !pattern[0][2] && !pattern[1][0] &&  = 'E'; } // Shape F: reverse  &&    {   }"], "perturbed_original": [" Y  M 2  { char ppr[X][Y];/*\u7d19*/ int x = 0,  = 0, j =  int count  0; int farst = 0; int k = 0;  i < X; i++) { for(j = 0;j  for(i = 0; i < 4; i++) { for(j = 0;j < 2; j++)  j <  =  4; i++) { printf(\"%d %d\\n\",ans[i][0],ans[i][1]);   i++) {  0 && ans[0][1] == 0 && ans[1][0] ==   ans[3][0] == 1 && ans[3][1] == 1 ) { printf(\"A\\n\"); } else if(ans[0][0] == 0 &&ans[0][1] == 0 &&  == 0 && ans[2][0] == 2 && ans[2][1] == 0 &&  ==  else  == 0   == 2 && ans[3][0] == 0 && ans[3][1] == 3 ) { printf(\"C\\n\"); } else if(ans[0][0]  1 && ans[1][0] == 1 && ans[1][1] == 0 &&  == 2 && ans[3][1] == 0 ) { printf(\"D\\n\"); }  ans[0][1] == 0  ans[2][0] == 1 &&  == 1 &&  == 0  ans[1][1] ==  && ans[2][1] ==  ) { printf(\"F\\n\"); } else  ==  && ans[2][0] == 1 && ans[2][1]  } } return 0; }"], "original_ll": -0.4194045662879944, "sampled_ll": -0.4454434812068939, "all_perturbed_sampled_ll": [-2.512590169906616], "all_perturbed_original_ll": [-1.6181362867355347], "perturbed_sampled_ll": -2.512590169906616, "perturbed_original_ll": -1.6181362867355347, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import java.util.Scanner;\n\npublic class Main {\n\n\tstatic Scanner sc = new java.util.Scanner(System.in);\n\n\n\tpublic static void main(String[] args) {\n\n\t\tint[][] num = new int[15][15];\n\t\tString str = \"\";\n\n\t\twhile (sc.hasNextLine()) {\n\t\t\t// ?????????\n\t\t\t//syokika(num);\n\t\t\tfor (int i = 0; i < 15; i++) {\n\t\t\t\tfor (int j = 0; j < 15; j++) {\n\t\t\t\t\tnum[i][j] = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t\t// ???????????\u00a8????????????????\u00b4?\n\t\t\tfor (int i = 0; i < 8; i++) {\n\t\t\t\tstr = sc.next();\n\t\t\t\tString[] st = str.split(\"\");\n\t\t\t\tfor (int j = 0; j < 8; j++) {\n\t\t\t\t\tnum[i][j] = Integer.parseInt(st[j]);\n\t\t\t\t}\n\t\t\t}\n\t\t\t// ????????????\n\t\t\tfor (int i = 0; i < 8; i++) {\n\t\t\t\tfor (int j = 0; j < 8; j++) {\n\t\t\t\t\tif (num[i][j] == 1 && num[i][j + 1] == 1 && num[i + 1][j] == 1 && num[i + 1][j + 1] == 1) {\n\t\t\t\t\t\tSystem.out.println(\"A\");\n\t\t\t\t\t} else if (num[i][j] == 1 && num[i + 1][j] == 1 && num[i + 2][j] == 1 && num[i + 3][j] == 1) {\n\t\t\t\t\t\tSystem.out.println(\"B\");\n\t\t\t\t\t} else if (num[i][j] == 1 && num[i][j + 1] == 1 && num[i][j + 2] == 1 && num[i][j + 3] == 1) {\n\t\t\t\t\t\tSystem.out.println(\"C\");\n\t\t\t\t\t} else if (num[i][j + 1] == 1 && num[i + 1][j] == 1 && num[i][j + 1] == 1 && num[i + 2][j] == 1) {\n\t\t\t\t\t\tSystem.out.println(\"D\");\n\t\t\t\t\t} else if (num[i][j] == 1 && num[i][j + 1] == 1 && num[i + 1][j + 1] == 1\n\t\t\t\t\t\t\t&& num[i + 1][j + 2] == 1) {\n\t\t\t\t\t\tSystem.out.println(\"E\");\n\t\t\t\t\t} else if (num[i][j] == 1 && num[i + 1][j] == 1 && num[i + 1][j + 1] == 1\n\t\t\t\t\t\t\t&& num[i + 2][j + 1] == 1) {\n\t\t\t\t\t\tSystem.out.println(\"F\");\n\t\t\t\t\t} else if (num[i][j + 1] == 1 && num[i][j + 2] == 1 && num[i + 1][j] == 1\n\t\t\t\t\t\t\t&& num[i + 1][j + 1] == 1) {\n\t\t\t\t\t\tSystem.out.println(\"G\");\n\t\t\t\t\t}\n\n\t\t\t\t}\n\t\t\t}\n\n\t\t}\n\n\t}\n}", "sampled": "import java.util.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        \n        while (sc.hasNextLine()) {\n            String[][] grid = new String[8][8];\n            List<int[]> points = new ArrayList<>();\n            \n            for (int i = 0; i < 8; i++) {\n                String line = sc.nextLine();\n                for (int j = 0; j < 8; j++) {\n                    grid[i][j] = String.valueOf(line.charAt(j));\n                    if (line.charAt(j) == '1') {\n                        points.add(new int[]{i, j});\n                    }\n                }\n            }\n            \n            if (points.size() == 0) break;\n            \n            // Normalize the shape\n            int minRow = Integer.MAX_VALUE;\n            int minCol = Integer.MAX_VALUE;\n            for (int[] p : points) {\n                minRow = Math.min(minRow, p[0]);\n                minCol = Math.min(minCol, p[1]);\n            }\n            \n            Set<String> normalized = new HashSet<>();\n            for (int[] p : points) {\n                normalized.add((p[0] - minRow) + \",\" + (p[1] - minCol));\n            }\n            \n            String result = identifyShape(normalized);\n            System.out.println(result);\n            \n            if (sc.hasNextLine()) {\n                String blank = sc.nextLine();\n            }\n        }\n        sc.close();\n    }\n    \n    static String identifyShape(Set<String> shape) {\n        // Define all shapes\n        Map<String, Set<String>> shapes = new HashMap<>();\n        \n        // A: 2x2 square\n        Set<String> a = new HashSet<>();\n        a.add(\"0,0\"); a.add(\"0,1\"); a.add(\"1,0\"); a.add(\"1,1\");\n        shapes.put(\"A\", a);\n        \n        // B: vertical line\n        Set<String> b = new HashSet<>();\n        b.add(\"0,0\"); b.add(\"1,0\"); b.add(\"2,0\"); b.add(\"3,0\");\n        shapes.put(\"B\", b);\n        \n        // C: horizontal line\n        Set<String> c = new HashSet<>();\n        c.add(\"0,0\"); c.add(\"0,1\"); c.add(\"0,2\"); c.add(\"0,3\");\n        shapes.put(\"C\", c);\n        \n        // D: L shape\n        Set<String> d = new HashSet<>();\n        d.add(\"0,0\"); d.add(\"1,0\"); d.add(\"2,0\"); d.add(\"2,1\");\n        shapes.put(\"D\", d);\n        \n        // E: Z shape\n        Set<String> e = new HashSet<>();\n        e.add(\"0,0\"); e.add(\"0,1\"); e.add(\"1,1\"); e.add(\"1,2\");\n        shapes.put(\"E\", e);\n        \n        // F: T shape\n        Set<String> f = new HashSet<>();\n        f.add(\"0,0\"); f.add(\"0,1\"); f.add(\"0,2\"); f.add(\"1,1\");\n        shapes.put(\"F\", f);\n        \n        // G: small L\n        Set<String> g = new HashSet<>();\n        g.add(\"0,0\"); g.add(\"1,0\"); g.add(\"1,1\");\n        shapes.put(\"G\", g);\n        \n        // Try all rotations and reflections\n        for (String key : shapes.keySet()) {\n            Set<String> pattern = shapes.get(key);\n            if (matchesWithTransformations(shape, pattern)) {\n                return key;\n            }\n        }\n        \n        return \"?\";\n    }\n    \n    static boolean matchesWithTransformations(Set<String> shape, Set<String> pattern) {\n        Set<String> current = pattern;\n        \n        for (int rotation = 0; rotation < 4; rotation++) {\n            if (matches(shape, current)) return true;\n            Set<String> reflected = reflect(current);\n            if (matches(shape, reflected)) return true;\n            current = rotate90(current);\n        }\n        \n        return false;\n    }\n    \n    static boolean matches(Set<String> shape, Set<String> pattern) {\n        Set<String> normalized = normalize(pattern);\n        return shape.equals(normalized);\n    }\n    \n    static Set<String> normalize(Set<String> pattern) {\n        int minRow = Integer.MAX_VALUE;\n        int minCol = Integer.MAX_VALUE;\n        \n        for (String p : pattern) {\n            String[] parts = p.split(\",\");\n            int r = Integer.parseInt(parts[0]);\n            int c = Integer.parseInt(parts[1]);\n            minRow = Math.min(minRow, r);\n            minCol = Math.min(minCol, c);\n        }\n        \n        Set<String> result = new HashSet<>();\n        for (String p : pattern) {\n            String[] parts = p.split(\",\");\n            int r = Integer.parseInt(parts[0]);\n            int c = Integer.parseInt(parts[1]);\n            result.add((r - minRow) + \",\" + (c - minCol));\n        }\n        \n        return result;\n    }\n    \n    static Set<String> rotate90(Set<String> pattern) {\n        Set<String> result = new HashSet<>();\n        for (String p : pattern) {\n            String[] parts = p.split(\",\");\n            int r = Integer.parseInt(parts[0]);\n            int c = Integer.parseInt(parts[1]);\n            result.add(c + \",\" + (-r));\n        }\n        return normalize(result);\n    }\n    \n    static Set<String> reflect(Set<String> pattern) {\n        Set<String> result = new HashSet<>();\n        for (String p : pattern) {\n            String[] parts = p.split(\",\");\n            int r = Integer.parseInt(parts[0]);\n            int c = Integer.parseInt(parts[1]);\n            result.add(r + \",\" + (-c));\n        }\n        return normalize(result);\n    }\n}\n", "perturbed_sampled": ["import java.util.*; public class Main { public static  sc = new Scanner(System.in); while (sc.hasNextLine()) { String[][]  points = new ArrayList<>(); for (int i = 0; i   j = 0; j < 8; j++) { grid[i][j] = String.valueOf(line.charAt(j)); if (line.charAt(j)  j}); } } } if (points.size() == 0)   { minRow = Math.min(minRow, p[0]); minCol = Math.min(minCol,   :   = sc.nextLine(); } } sc.close();  {  new HashSet<>(); a.add(\"0,0\"); a.add(\"0,1\"); a.add(\"1,0\"); a.add(\"1,1\"); shapes.put(\"A\",   c.add(\"0,1\"); c.add(\"0,2\"); c.add(\"0,3\");  shape Set<String> d  shapes.put(\"F\", f); // G: small L Set<String> g = new HashSet<>(); g.add(\"0,0\"); g.add(\"1,0\"); g.add(\"1,1\"); shapes.put(\"G\",  and reflections for (String key : shapes.keySet()) { Set<String> pattern = shapes.get(key); if (matchesWithTransformations(shape, pattern)) { return  }  pattern) { Set<String> current = pattern; for (int rotation = 0;  true; Set<String>  reflected)) return  return false; } static boolean matches(Set<String>  normalize(Set<String> pattern) {   int r = Integer.parseInt(parts[0]);  : pattern) { String[] parts = p.split(\",\"); int r =  result.add((r - minRow) +   Set<String>  { String[] parts =  int c = Integer.parseInt(parts[1]); result.add(c + \",\" +  static   (String p  =  int c = Integer.parseInt(parts[1]); result.add(r + \",\" + (-c)); } return normalize(result); } }"], "perturbed_original": [" { static Scanner  static  String str = \"\"; while (sc.hasNextLine()) {  i  i++) { for (int j = 0; j < 15; j++) { num[i][j]    for  < 8; j++) { num[i][j] = Integer.parseInt(st[j]); } } //  0;  0;  if   num[i + 1][j] ==  + 1] == 1) { System.out.println(\"A\"); } else if  && num[i + 2][j] ==  == 1) {  == 1 && num[i][j   && num[i][j + 3] == 1) { System.out.println(\"C\");   &&  + 1] ==  + 2] ==  if (num[i][j]  num[i +  &&  == 1) { System.out.println(\"F\"); }  && num[i + 1][j] == 1 && num[i + 1][j + 1] == 1) { System.out.println(\"G\"); } } } } } }"], "original_ll": -0.5062336325645447, "sampled_ll": -0.4144364297389984, "all_perturbed_sampled_ll": [-2.3802225589752197], "all_perturbed_original_ll": [-2.000286340713501], "perturbed_sampled_ll": -2.3802225589752197, "perturbed_original_ll": -2.000286340713501, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import sys;import re\nfor s in sys.stdin.read().split('\\n\\n'):print 'BCD F GAE'[len(re.findall('1.*1',s.replace('\\n',''))[0])%12-3]", "sampled": "import sys\n\ndef normalize_shape(points):\n    if not points:\n        return []\n    min_r = min(p[0] for p in points)\n    min_c = min(p[1] for p in points)\n    normalized = sorted([(r - min_r, c - min_c) for r, c in points])\n    return normalized\n\ndef get_shape_signature(grid):\n    points = []\n    for r in range(8):\n        for c in range(8):\n            if grid[r][c] == '1':\n                points.append((r, c))\n    return normalize_shape(points)\n\n# Define the shapes A-G\nshapes = {\n    'A': [(0, 0), (0, 1), (1, 0), (1, 1)],\n    'B': [(0, 0), (0, 1), (0, 2), (0, 3)],\n    'C': [(0, 0), (0, 1), (0, 2), (0, 3)],\n    'D': [(0, 0), (1, 0), (1, 1), (2, 1)],\n    'E': [(0, 0), (0, 1), (1, 0), (1, 1)],\n    'F': [(0, 1), (1, 0), (1, 1), (2, 0)],\n    'G': [(0, 0), (0, 1), (0, 2), (1, 1)]\n}\n\n# Generate all rotations and reflections for each shape\ndef get_all_orientations(points):\n    orientations = set()\n    pts = points[:]\n    \n    for _ in range(4):  # 4 rotations\n        orientations.add(tuple(normalize_shape(pts)))\n        # Rotate 90 degrees clockwise: (r, c) -> (c, -r)\n        pts = [(c, -r) for r, c in pts]\n    \n    # Mirror horizontally\n    pts = [(r, -c) for r, c in points]\n    for _ in range(4):  # 4 rotations of mirrored\n        orientations.add(tuple(normalize_shape(pts)))\n        pts = [(c, -r) for r, c in pts]\n    \n    return orientations\n\nshape_orientations = {}\nfor name, shape in shapes.items():\n    shape_orientations[name] = get_all_orientations(shape)\n\ndef identify_shape(grid):\n    sig = tuple(get_shape_signature(grid))\n    \n    for name, orientations in shape_orientations.items():\n        if sig in orientations:\n            return name\n    \n    return None\n\n# Read input\nlines = []\nfor line in sys.stdin:\n    lines.append(line.rstrip('\\n'))\n\n# Process datasets\ni = 0\nwhile i < len(lines):\n    grid = []\n    while i < len(lines) and lines[i] != '':\n        grid.append(lines[i])\n        i += 1\n    \n    if len(grid) == 8:\n        result = identify_shape(grid)\n        print(result)\n    \n    i += 1  # Skip empty line\n", "perturbed_sampled": ["range(4):<extra_id_2>] for r, c in<extra_id_3>) = ==<extra_id_4>3, 0, 1<extra_id_5>: ] result . append<extra_id_6>1 ]<extra_id_7>2 ] ] lines [<extra_id_8>i ]<extra_id_9>i ] )<extra_id_10>None # Handle empty lines:<extra_id_11>'': if [<extra_id_12>]<extra_id_13>(lines[i] != 'A':<extra_id_14>[ 1 ,<extra_id_15>=<extra_id_16>i ] = None lines<extra_id_17>[<extra_id_18>+= 1 #<extra_id_19>3 #<extra_id_20> not points:  for p in points) min_c  points) normalized  - min_c) for r, c in points]) return normalized def get_shape_signature(grid): points = []  c)) return  'A':   2),  (0, 1),  (1, 1), (2, 1)], 'E': [(0, 0), (0, 1), (1, 0), (1,   1), (0, 2), (1, 1)] } # Generate  each  set() pts = points[:]   90 degrees clockwise: (r, c) -> (c, -r) pts  c in pts] # Mirror horizontally pts = [(r,  range(4):  orientations.add(tuple(normalize_shape(pts))) pts  orientations  shape in  identify_shape(grid): sig = tuple(get_shape_signature(grid)) for name, orientations in  = [] for   lines[i] != '':  = identify_shape(grid) print(result) i += 1 # Skip empty line"], "perturbed_original": ["import  sys.stdin.read().split('\\n\\n'):print 'BCD F GAE'[len(re.findall('1.*1',s.replace('\\n',''))[0])%12-3]"], "original_ll": -3.175971746444702, "sampled_ll": -0.7605741024017334, "all_perturbed_sampled_ll": [-2.9698076248168945], "all_perturbed_original_ll": [-4.290280818939209], "perturbed_sampled_ll": -2.9698076248168945, "perturbed_original_ll": -4.290280818939209, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "#include<stdio.h>\nint main(void){\n  int tate[8][4],yoko[8][3];\n  int h,i,j,k,x=0,y=0;\n  for(i=0;i<9;i++){\n    if(i%2==0){\n      scanf(\"%1d%1d%1d%1d\",&yoko[i][0],&yoko[i][1],&yoko[i][2],&yoko[i][3]);\n      yoko[i][4]=0;   \n    }else{  \n      scanf(\"%1d%1d%1d%1d%1d\",&tate[i][0],&tate[i][1],&tate[i][2],&tate[i][3],&tate[i][4]);\n      tate[i][5]=0;\n    }\n  }\n\n  //printf(\"----------------------------------------\\n\");\n       for(k=0;k<=9;k++){\n       if(k%2==0){\n\t //printf(\"%d%d%d%d%d\\n\",yoko[k][0],yoko[k][1],yoko[k][2],yoko[k][3],yoko[k][4]);\n       }else{\n\t //printf(\"%d%d%d%d%d%d\\n\",tate[k][0],tate[k][1],tate[k][2],tate[k][3],tate[k][4],tate[k][5]);\n       }\n       }\n  \n\n \n  int sl=1;\n  printf(\"R\");\n  do{\n   \n    switch(sl){\n    case 1:\n      //printf(\"x=%d:y=%d\\n\",x,y);\n      //printf(\"tate74=%d\\n\",tate[7][4]);\n\n      if(tate[y-1][x+1]==1&&y>0){\n\tx++;\n\ty--;\n\tsl=4;\n      }else if(yoko[y][x+1]==1&&x<3){\n\t//printf(\"ok\\n\");\n\tx++;\n\tsl=1;\n\t//printf(\"s=%d\",s);\n      }else if(tate[y+1][x+1]==1&&y<8){\n\tx++;\n\ty++;\n\t\n\tsl=2;\n      }\n      // printf(\"tate74=%d\\n\",tate[7][4]);\n\n      break;\n\n    case 2:\n      //printf(\"x=%d:y=%d\\n\",x,y);\n      //printf(\"%d %d\\n\",x+1,y+2);\n      //printf(\"tate74=%d\\n\",tate[7][4]);\n      if(yoko[y+1][x]==1&&x<3){\n\ty++;sl=1;\n      }else if(tate[y+2][x]==1&&y<8){\n\ty=y+2;sl=2;\n      }else if(yoko[y+1][x-1]==1&&x>0){\n\ty++;\n\tx--;\n\tsl=3;\n      }\n      break;\n\n\n    case 3:\n      //printf(\"x=%d:y=%d\\n\",x,y);\n       if(tate[y+1][x]==1&&y<8){\n\tsl=2;y++;\n      }else if(yoko[y][x-1]==1&&x>0){\n\tx--;sl=3;\n      }else if(tate[y-1][x]==1&&y>0){\n\ty--;sl=4;\n      }\n      break;\n\n\n    case 4:\n      // printf(\"x=%d:y=%d\\n\",x,y);\n      if(yoko[y-1][x-1]==1&&x>0){\n\tx--;y--;sl=3;\n      }else if(tate[y-2][x]==1&&y>0){\n\ty=y-2;sl=4;\n      }else if(yoko[y-1][x]==1&&x<3){\n\ty--;sl=1;\n      }\n      break;\n\n\n    }\n    //printf(\"sl=%d\\n\",sl);\n    if(sl==1)printf(\"R\");\n    if(sl==2)printf(\"D\");\n    if(sl==3)printf(\"L\");\n    if(sl==4)printf(\"U\");\n    //printf(\"tate74=%d\\n\",tate[7][4]);\n    //printf(\"\\n\");\n   \n   \n  }while(x!=0||y!=0);\n  printf(\"\\n\");\n  return 0;\n  \n}", "sampled": "#include <stdio.h>\n#include <string.h>\n\nint main() {\n    char h[5][5]; // horizontal walls\n    char v[4][5]; // vertical walls\n    char input[10];\n    \n    // Read input\n    for (int i = 0; i < 9; i++) {\n        scanf(\"%s\", input);\n        if (i % 2 == 0) {\n            // horizontal walls\n            int row = i / 2;\n            strcpy(h[row], input);\n        } else {\n            // vertical walls\n            int row = i / 2;\n            strcpy(v[row], input);\n        }\n    }\n    \n    // Start at point A (0,0), facing right (east)\n    int x = 0, y = 0;\n    int dir = 0; // 0=East, 1=South, 2=West, 3=North\n    char dirChars[] = {'R', 'D', 'L', 'U'};\n    \n    // Direction vectors: dx[dir], dy[dir]\n    int dx[] = {1, 0, -1, 0};\n    int dy[] = {0, 1, 0, -1};\n    \n    char path[10000];\n    int pathLen = 0;\n    \n    // Right-hand rule: keep wall on right\n    do {\n        // Try to turn right first\n        int rightDir = (dir + 3) % 4; // turn right\n        int rightX = x + dx[rightDir];\n        int rightY = y + dy[rightDir];\n        \n        // Check if we can move right\n        int canMoveRight = 0;\n        if (rightX >= 0 && rightX <= 4 && rightY >= 0 && rightY <= 4) {\n            if (rightDir == 0 && rightX <= 4 && v[y][x] == '0') canMoveRight = 1;\n            else if (rightDir == 1 && rightY <= 4 && h[y][x] == '0') canMoveRight = 1;\n            else if (rightDir == 2 && rightX >= 0 && v[y][rightX] == '0') canMoveRight = 1;\n            else if (rightDir == 3 && rightY >= 0 && h[rightY][x] == '0') canMoveRight = 1;\n        }\n        \n        if (canMoveRight) {\n            dir = rightDir;\n            x = rightX;\n            y = rightY;\n            path[pathLen++] = dirChars[dir];\n        } else {\n            // Try to move forward\n            int fwdX = x + dx[dir];\n            int fwdY = y + dy[dir];\n            \n            int canMoveFwd = 0;\n            if (fwdX >= 0 && fwdX <= 4 && fwdY >= 0 && fwdY <= 4) {\n                if (dir == 0 && fwdX <= 4 && v[y][x] == '0') canMoveFwd = 1;\n                else if (dir == 1 && fwdY <= 4 && h[y][x] == '0') canMoveFwd = 1;\n                else if (dir == 2 && fwdX >= 0 && v[y][fwdX] == '0') canMoveFwd = 1;\n                else if (dir == 3 && fwdY >= 0 && h[fwdY][x] == '0') canMoveFwd = 1;\n            }\n            \n            if (canMoveFwd) {\n                x = fwdX;\n                y = fwdY;\n                path[pathLen++] = dirChars[dir];\n            } else {\n                // Turn left\n                dir = (dir + 1) % 4;\n            }\n        }\n    } while (!(x == 0 && y == 0 && dir == 0));\n    \n    path[pathLen] = '\\0';\n    printf(\"%s\\n\", path);\n    \n    return 0;\n}\n", "perturbed_sampled": ["#include <stdio.h> #include <string.h> int main() { char h[5][5]; // horizontal walls char  input[10];  i =  i / 2; strcpy(h[row], input); } else { // vertical  } }  int x  // 0=East,  'U'}; //  dx[] = {1, 0, -1, 0}; int  pathLen = 0; // Right-hand rule: keep wall on  to  = (dir + 3)  = y + dy[rightDir]; // Check if we  = 0; if  <= 4 && rightY >= 0 && rightY <= 4) { if (rightDir == 0 && rightX <= 4 && v[y][x] == '0')   == '0') canMoveRight = 1;  && rightX >= 0 && v[y][rightX] == '0') canMoveRight =  3 && rightY >=  canMoveRight = 1; } if (canMoveRight) { dir =  dirChars[dir];  to move   canMoveFwd =  && fwdY <=  0 && fwdX <= 4 && v[y][x]  else if (dir  4 &&     fwdX;  = (dir + 1) % 4;  == 0)); path[pathLen] = '\\0'; printf(\"%s\\n\", path); return 0; }"], "perturbed_original": ["#include<stdio.h> int main(void){ int tate[8][4],yoko[8][3]; int h,i,j,k,x=0,y=0; for(i=0;i<9;i++){ if(i%2==0){ scanf(\"%1d%1d%1d%1d\",&yoko[i][0],&yoko[i][1],&yoko[i][2],&yoko[i][3]); yoko[i][4]=0; }else{ scanf(\"%1d%1d%1d%1d%1d\",&tate[i][0],&tate[i][1],&tate[i][2],&tate[i][3],&tate[i][4]);  if(k%2==0){ //printf(\"%d%d%d%d%d\\n\",yoko[k][0],yoko[k][1],yoko[k][2],yoko[k][3],yoko[k][4]); }else{ //printf(\"%d%d%d%d%d%d\\n\",tate[k][0],tate[k][1],tate[k][2],tate[k][3],tate[k][4],tate[k][5]); } } int sl=1; printf(\"R\"); do{  if(tate[y-1][x+1]==1&&y>0){  //printf(\"ok\\n\"); x++; sl=1; //printf(\"s=%d\",s); }else if(tate[y+1][x+1]==1&&y<8){ x++; y++; sl=2;  if(tate[y+2][x]==1&&y<8){  y=y-2;sl=4;  } //printf(\"sl=%d\\n\",sl); if(sl==1)printf(\"R\"); if(sl==2)printf(\"D\");  printf(\"\\n\"); return 0; }"], "original_ll": -0.8594191670417786, "sampled_ll": -0.5614480376243591, "all_perturbed_sampled_ll": [-2.7096445560455322], "all_perturbed_original_ll": [-1.1987309455871582], "perturbed_sampled_ll": -2.7096445560455322, "perturbed_original_ll": -1.1987309455871582, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import java.util.*;\nimport static java.util.Arrays.*;\nimport static java.lang.Math.*;\n\n// AOJ 0037\npublic class Main {\n\n\tstatic Scanner sc = new Scanner(System.in);\n\tstatic final double EPS = 1e-10;\n\tpublic static void main(String[] args) {\n\t\tchar[][] cs = new char[20][1000];\n\t\tfor (int i = 0; i < 20; i++) fill(cs[i], '0');\n\t\t\n\t\tfor (int i = 0; i < 9; i++) {\n\t\t\tString buf = sc.next();\n\t\t\tfor (int j = 0; j < buf.length(); j++) {\n\t\t\t\tif (i % 2 == 0) {\n\t\t\t\t\tcs[i + 1][j * 2 + 2] = buf.charAt(j);\n\t\t\t\t} else {\n\t\t\t\t\tcs[i + 1][j * 2 + 1] = buf.charAt(j);\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t}\n\n\t\tint[] dx = {1, 0, -1, 0}, dy = {0, 1, 0, -1};\n\t\tString[] str = {\"R\", \"D\", \"L\", \"U\"}; \n\t\tint x = 1, y = 1, d = 0;\n\t\twhile (!(x == 1 && y == 1 && d == 2)) {\n\t\t\tif (cs[y + dy[d]][x + dx[d]] == '1') {\n\t\t\t\tx += dx[d] * 2; \n\t\t\t\ty += dy[d] * 2;\n\t\t\t\tSystem.out.print(str[d]);\n\t\t\t} else {\n\t\t\t\t\n\t\t\t\tif (cs[y + dy[(d - 1 + 4) % 4]][x + dx[(d - 1 + 4) % 4]] == '1') {\n\t\t\t\t\td = (d - 1 + 4) % 4;\t\t\t\t\t\n\t\t\t\t} else {\n\t\t\t\t\td = (d + 1) % 4;\n\t\t\t\t}\n\n\t\t\t\t\n\t\t\t}\n\t\t}\n\t\tSystem.out.println();\n\t\t\n\t}\n}", "sampled": "import java.util.*;\n\npublic class Main {\n    static class State {\n        int row, col;\n        int dir; // 0=right, 1=down, 2=left, 3=up\n        \n        State(int row, int col, int dir) {\n            this.row = row;\n            this.col = col;\n            this.dir = dir;\n        }\n    }\n    \n    static int[][] horizontal = new int[5][4]; // 5 horizontal lines, 4 segments each\n    static int[][] vertical = new int[4][5]; // 4 vertical lines, 5 segments each\n    \n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        \n        // Read horizontal walls\n        for (int i = 0; i < 5; i++) {\n            String line = sc.nextLine();\n            for (int j = 0; j < 4; j++) {\n                horizontal[i][j] = line.charAt(j) - '0';\n            }\n        }\n        \n        // Read vertical walls\n        for (int i = 0; i < 4; i++) {\n            String line = sc.nextLine();\n            for (int j = 0; j < 5; j++) {\n                vertical[i][j] = line.charAt(j) - '0';\n            }\n        }\n        \n        // Start at position (0,0), facing right (dir=0)\n        // Right hand is on the wall above (horizontal[0][0] = 1)\n        State state = new State(0, 0, 0);\n        StringBuilder result = new StringBuilder();\n        \n        do {\n            // Try to turn right first (right-hand rule)\n            int rightDir = (state.dir + 3) % 4; // Turn right\n            \n            if (canMove(state.row, state.col, rightDir)) {\n                // Turn right and move\n                state.dir = rightDir;\n                move(state, result);\n            } else if (canMove(state.row, state.col, state.dir)) {\n                // Move straight\n                move(state, result);\n            } else {\n                // Turn left\n                state.dir = (state.dir + 1) % 4;\n            }\n        } while (!(state.row == 0 && state.col == 0 && state.dir == 0));\n        \n        System.out.println(result.toString());\n    }\n    \n    static boolean canMove(int row, int col, int dir) {\n        if (dir == 0) { // Right\n            if (col >= 4) return false;\n            return vertical[col][row] == 0;\n        } else if (dir == 1) { // Down\n            if (row >= 4) return false;\n            return horizontal[row + 1][col] == 0;\n        } else if (dir == 2) { // Left\n            if (col <= 0) return false;\n            return vertical[col - 1][row] == 0;\n        } else { // Up\n            if (row <= 0) return false;\n            return horizontal[row][col] == 0;\n        }\n    }\n    \n    static void move(State state, StringBuilder result) {\n        if (state.dir == 0) { // Right\n            result.append('R');\n            state.col++;\n        } else if (state.dir == 1) { // Down\n            result.append('D');\n            state.row++;\n        } else if (state.dir == 2) { // Left\n            result.append('L');\n            state.col--;\n        } else { // Up\n            result.append('U');\n            state.row--;\n        }\n    }\n}\n", "perturbed_sampled": ["import java.util.*; public class Main { static class State { int row, col; int dir; //  row, int   this.dir    static void main(String[]  new Scanner(System.in); // Read horizontal walls for (int i  i++)   { horizontal[i][j] = line.charAt(j) -  vertical walls for (int i = 0; i  line = sc.nextLine(); for (int j = 0; j < 5;  // Start  State  right first (right-hand rule) int rightDir = (state.dir   right and move state.dir =    Turn left state.dir =  } } while (!(state.row == 0 && state.col == 0  }  col, int dir)  { // Right if (col >= 4)  0;  return false; return horizontal[row + 1][col] ==  vertical[col -  { // Up if  return horizontal[row][col] ==  move(State state, StringBuilder result)  { // Right result.append('R'); state.col++; }   } else if (state.dir == 2)  } else { //  }"], "perturbed_original": ["import java.util.*; import  // AOJ 0037 public class Main { static  static final double EPS = 1e-10; public static void main(String[] args) {  for  < 20; i++) fill(cs[i],   {  (int j = 0; j < buf.length(); j++) { if (i % 2 == 0) { cs[i  2] = buf.charAt(j); } else { cs[i +  {1, 0, -1, 0}, dy =  1, d =  &&  dx[d]] ==  dy[d] * 2;    (d + 1) % 4; } } } System.out.println(); } }"], "original_ll": -0.7912678122520447, "sampled_ll": -0.5232971906661987, "all_perturbed_sampled_ll": [-3.2066383361816406], "all_perturbed_original_ll": [-2.6502442359924316], "perturbed_sampled_ll": -3.2066383361816406, "perturbed_original_ll": -2.6502442359924316, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "path = [[[] for i in range(5)] for i in range(5)]\nfor i in range(9):\n    if i%2 == 0:\n        a = [int(i) for i in list(input())]\n        for j in range(4):\n            if a[j] == 1:\n                path[int(i/2)][j].append(\"R\")\n                path[int(i/2)][j+1].append(\"L\")\n    else:\n        a = [int(i) for i in list(input())]\n        for j in range(5):\n            if a[j] == 1:\n                path[int(i/2)][j].append(\"D\")\n                path[int(i/2)+1][j].append(\"U\")\n\nprev = \"R\"\np = \"R\"\nx = 0\ny = 0\nwhile(1):\n    if prev == \"R\":\n        if \"U\" in path[x][y]:\n            x -= 1\n            prev = \"U\"\n            p += \"U\"\n        elif \"R\" in path[x][y]:\n            y += 1\n            prev = \"R\"\n            p += \"R\"\n        elif \"D\" in path[x][y]:\n            x += 1\n            prev = \"D\"\n            p += \"D\"\n        elif \"L\" in path[x][y]:\n            y -= 1\n            prev = \"L\"\n            p += \"L\"\n    elif prev == \"L\":\n        if \"D\" in path[x][y]:\n            x += 1\n            prev = \"D\"\n            p += \"D\"\n        elif \"L\" in path[x][y]:\n            y -= 1\n            prev = \"L\"\n            p += \"L\"\n        elif \"U\" in path[x][y]:\n            x -= 1\n            prev = \"U\"\n            p += \"U\"\n        elif \"R\" in path[x][y]:\n            y += 1\n            prev = \"R\"\n            p += \"R\"\n    elif prev == \"U\":\n        if \"L\" in path[x][y]:\n            y -= 1\n            prev = \"L\"\n            p += \"L\"\n        elif \"U\" in path[x][y]:\n            x -= 1\n            prev = \"U\"\n            p += \"U\"\n        elif \"R\" in path[x][y]:\n            y += 1\n            prev = \"R\"\n            p += \"R\"\n        elif \"D\" in path[x][y]:\n            x += 1\n            prev = \"D\"\n            p += \"D\"\n    elif prev == \"D\":\n        if \"R\" in path[x][y]:\n            y += 1\n            prev = \"R\"\n            p += \"R\"\n        elif \"D\" in path[x][y]:\n            x += 1\n            prev = \"D\"\n            p += \"D\"\n        elif \"L\" in path[x][y]:\n            y -= 1\n            prev = \"L\"\n            p += \"L\"\n        elif \"U\" in path[x][y]:\n            x -= 1\n            prev = \"U\"\n            p += \"U\"\n    if x == 0 and y == 0:\n        break\nprint(p[1:])\n\n\n    \n\n", "sampled": "def solve():\n    # Read input\n    lines = []\n    for _ in range(9):\n        lines.append(input().strip())\n    \n    # Parse walls\n    # h_walls[i][j] = horizontal wall between row i and i+1, at column j\n    # v_walls[i][j] = vertical wall between column j and j+1, at row i\n    h_walls = []\n    v_walls = []\n    \n    for i in range(9):\n        if i % 2 == 0:  # horizontal walls\n            h_walls.append([int(c) for c in lines[i]])\n        else:  # vertical walls\n            v_walls.append([int(c) for c in lines[i]])\n    \n    # Start at point A (top-left corner, position (0, 0))\n    # Initial direction: facing right (since we start by going right with wall on right)\n    # Directions: 0=Right, 1=Down, 2=Left, 3=Up\n    pos = (0, 0)\n    direction = 0  # facing right\n    path = []\n    \n    # Direction vectors\n    dx = [1, 0, -1, 0]  # Right, Down, Left, Up\n    dy = [0, 1, 0, -1]\n    dir_chars = ['R', 'D', 'L', 'U']\n    \n    def has_wall(r, c, d):\n        \"\"\"Check if there's a wall when moving from (r,c) in direction d\"\"\"\n        if d == 0:  # Right\n            if c >= len(v_walls[0]):\n                return True\n            return v_walls[r][c] == 1\n        elif d == 1:  # Down\n            if r >= len(h_walls) - 1:\n                return True\n            return h_walls[r + 1][c] == 1\n        elif d == 2:  # Left\n            if c == 0:\n                return True\n            return v_walls[r][c - 1] == 1\n        else:  # Up (d == 3)\n            if r == 0:\n                return True\n            return h_walls[r][c] == 1\n    \n    while True:\n        # Try to turn right first (right-hand rule)\n        right_dir = (direction - 1) % 4\n        \n        # Check if we can go right\n        if not has_wall(pos[1], pos[0], right_dir):\n            # Turn right and move\n            direction = right_dir\n            pos = (pos[0] + dx[direction], pos[1] + dy[direction])\n            path.append(dir_chars[direction])\n        # Check if we can go straight\n        elif not has_wall(pos[1], pos[0], direction):\n            # Move straight\n            pos = (pos[0] + dx[direction], pos[1] + dy[direction])\n            path.append(dir_chars[direction])\n        else:\n            # Turn left\n            direction = (direction + 1) % 4\n            continue\n        \n        # Check if we're back at start\n        if pos == (0, 0) and len(path) > 0:\n            break\n    \n    print(''.join(path))\n\nsolve()\n", "perturbed_sampled": ["def   range(9):  h_walls[i][j] = horizontal wall between row  j # v_walls[i][j] = vertical wall between column  i h_walls = [] v_walls =    v_walls.append([int(c) for  at point A (top-left  Initial  start by going right with wall on right) #  pos =  = []  [1, 0, -1, 0]  ['R', 'D', 'L', 'U']   direction d\"\"\"  v_walls[r][c] == 1 elif d ==  >= len(h_walls) -  elif d == 2: # Left    True  True: #    go right if not has_wall(pos[1], pos[0], right_dir): #  = right_dir  #   direction): # Move straight pos =  dy[direction]) path.append(dir_chars[direction]) else: # Turn left direction = (direction + 1) %  we're back at start if pos == (0, 0) and len(path) > 0: break print(''.join(path)) solve()"], "perturbed_original": ["path = [[[] for i in range(5)]   list(input())] for   a = [int(i) for i in  path[int(i/2)][j].append(\"D\") path[int(i/2)+1][j].append(\"U\") prev = \"R\"  0  prev ==    = \"D\" p += \"D\" elif \"L\" in path[x][y]:   \"D\" in path[x][y]: x += 1 prev = \"D\" p += \"D\" elif \"L\" in path[x][y]:  \"L\" p += \"L\"  -= 1 prev =  if \"L\"  prev  elif \"U\" in path[x][y]:  \"U\" p +=  y += 1 prev  = \"D\" p += \"D\" elif prev == \"D\": if \"R\"  prev = \"R\" p += \"R\" elif \"D\" in  = \"D\" p  path[x][y]: y -= 1 prev = \"L\" p  prev = \"U\"  == 0: break print(p[1:])"], "original_ll": -0.37163588404655457, "sampled_ll": -0.8005430698394775, "all_perturbed_sampled_ll": [-3.3714282512664795], "all_perturbed_original_ll": [-2.242917060852051], "perturbed_sampled_ll": -3.3714282512664795, "perturbed_original_ll": -2.242917060852051, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "#include <stdio.h>\n\nint isstraight(int[5]);\n\nint main(void) {\n\tint cards[5];\n\tint i,j,temp;\n\tint yaku;\n\tchar yakuname[7][11]={\"null\",\"one pair\",\"two pair\",\"three card\",\n\t\t\t\t\t\t\"straight\",\"full house\",\"four card\"};\n\twhile(1) {\n\t\tif(scanf(\"%d,%d,%d,%d,%d\",\n\t\t\t&cards[0],&cards[1],&cards[2],&cards[3],&cards[4])==-1)break;\n\t\tfor(i=4;i>0;i--) {\n\t\t\tfor(j=0;j<i;j++) {\n\t\t\t\tif(cards[j]>cards[j+1]) {\n\t\t\t\t\ttemp=cards[j];\n\t\t\t\t\tcards[j]=cards[j+1];\n\t\t\t\t\tcards[j+1]=temp;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tyaku=0;\n\t\tif(cards[1]==cards[2] && cards[2]==cards[3]) {\n\t\t\tif(cards[0]==cards[1] || cards[3]==cards[4])yaku=6;\n\t\t\telse yaku=3;\n\t\t} else if(cards[0]==cards[1] && cards[1]==cards[2]) {\n\t\t\tif(cards[3]==cards[4])yaku=5; else yaku=3;\n\t\t} else if(cards[2]==cards[3] && cards[3]==cards[4]) {\n\t\t\tif(cards[0]==cards[1])yaku=5; else yaku=3;\n\t\t} else if(isstraight(cards))yaku=4;\n\t\telse {\n\t\t\tfor(i=0;i<4;i++) {\n\t\t\t\tif(cards[i]==cards[i+1])yaku++;\n\t\t\t}\n\t\t}\n\t\tprintf(\"%s\\n\",yakuname[yaku]);\n\t}\n\treturn 0;\n}\n\nint isstraight(int cards[5]) {\n\tint i;\n\tfor(i=0;i<4;i++) {\n\t\tif(cards[i]+1!=cards[i+1])break;\n\t}\n\tif(i<4) {\n\t\tif(cards[0]==1 && cards[1]==10 && cards[2]==11 &&\n\t\t\tcards[3]==12 && cards[4]==13)return 1; else return 0;\n\t} else return 1;\n}", "sampled": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nint compare(const void *a, const void *b) {\n    return (*(int*)a - *(int*)b);\n}\n\nint main() {\n    char line[100];\n    \n    while (fgets(line, sizeof(line), stdin)) {\n        int cards[5];\n        sscanf(line, \"%d,%d,%d,%d,%d\", &cards[0], &cards[1], &cards[2], &cards[3], &cards[4]);\n        \n        // Count frequency of each card value\n        int count[14] = {0};\n        for (int i = 0; i < 5; i++) {\n            count[cards[i]]++;\n        }\n        \n        // Check for pairs, three of a kind, four of a kind\n        int pairs = 0, threes = 0, fours = 0;\n        for (int i = 1; i <= 13; i++) {\n            if (count[i] == 2) pairs++;\n            else if (count[i] == 3) threes++;\n            else if (count[i] == 4) fours++;\n        }\n        \n        // Check for straight\n        qsort(cards, 5, sizeof(int), compare);\n        int is_straight = 0;\n        \n        // Normal straight\n        if (cards[1] == cards[0] + 1 && \n            cards[2] == cards[1] + 1 && \n            cards[3] == cards[2] + 1 && \n            cards[4] == cards[3] + 1) {\n            is_straight = 1;\n        }\n        \n        // A-2-3-4-5 straight\n        if (cards[0] == 1 && cards[1] == 2 && cards[2] == 3 && \n            cards[3] == 4 && cards[4] == 5) {\n            is_straight = 1;\n        }\n        \n        // 10-J-Q-K-A straight\n        if (cards[0] == 1 && cards[1] == 10 && cards[2] == 11 && \n            cards[3] == 12 && cards[4] == 13) {\n            is_straight = 1;\n        }\n        \n        // Determine the hand\n        if (fours > 0) {\n            printf(\"four card\\n\");\n        } else if (threes > 0 && pairs > 0) {\n            printf(\"full house\\n\");\n        } else if (is_straight) {\n            printf(\"straight\\n\");\n        } else if (threes > 0) {\n            printf(\"three card\\n\");\n        } else if (pairs == 2) {\n            printf(\"two pair\\n\");\n        } else if (pairs == 1) {\n            printf(\"one pair\\n\");\n        } else {\n            printf(\"null\\n\");\n        }\n    }\n    \n    return 0;\n}\n", "perturbed_sampled": ["#include <stdio.h> #include <stdlib.h> #include  const void *b) { return (*(int*)a -  sizeof(line), stdin)) {  (int i = 0; i < 5; i++) { count[cards[i]]++; } // Check for   = 0, fours = 0;  {  else if (count[i] == 3) threes++;  fours++;  // Normal straight if  + 1 &&   straight if (cards[0]  3 &&  = 1; } // 10-J-Q-K-A straight  cards[2] == 11 && cards[3] == 12 && cards[4] ==    printf(\"four card\\n\"); } else if (threes > 0 && pairs > 0) { printf(\"full house\\n\"); } else  else if (threes  } else  printf(\"two pair\\n\"); } else if  printf(\"null\\n\"); } } return 0; }"], "perturbed_original": ["#include <stdio.h> int isstraight(int[5]); int main(void) {  cards[j]=cards[j+1];   || cards[3]==cards[4])yaku=6; else yaku=3; } else if(cards[0]==cards[1] && cards[1]==cards[2]) { if(cards[3]==cards[4])yaku=5;  && cards[3]==cards[4])  } printf(\"%s\\n\",yakuname[yaku]); } return 0; }  i; for(i=0;i<4;i++) { if(cards[i]+1!=cards[i+1])break; } if(i<4) { if(cards[0]==1 && cards[1]==10  cards[4]==13)return 1; else  1; }"], "original_ll": -0.8021338582038879, "sampled_ll": -0.5267094969749451, "all_perturbed_sampled_ll": [-2.7425358295440674], "all_perturbed_original_ll": [-2.0784058570861816], "perturbed_sampled_ll": -2.7425358295440674, "perturbed_original_ll": -2.0784058570861816, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import java.util.Arrays;\nimport java.util.Scanner;\n\npublic class Main {\n\t\n\tprivate static boolean checkFourCard(int[] group){\n\t\tboolean flag = false;\n\t\tfor(int i=1; i<group.length; ++i){\n\t\t\tif(group[i] == 4){\n\t\t\t\tflag = true;\n\t\t\t}\n\t\t}\n\t\treturn flag;\n\t}\n\t\n\tprivate static boolean checkFullHouse(int[] group){\n\t\tboolean two=false, three=false;\n\t\t\n\t\tfor(int i=1; i<group.length; ++i){\n\t\t\tif(group[i] == 2){\n\t\t\t\ttwo = true;\n\t\t\t}else if(group[i] == 3){\n\t\t\t\tthree = true;\n\t\t\t}\n\t\t}\n\t\tif(two && three){\n\t\t\treturn true;\n\t\t}else{\n\t\t\treturn false;\n\t\t}\n\t}\n\t\n\tprivate static boolean checkStraight(int[] group){\n\t\tboolean flag = false;\n\t\tint count = 0;\n\t\t\n\t\tfor(int i=1; i<group.length; ++i){\n\t\t\tif(group[i] == 1){\n\t\t\t\t//\u307e\u305f\u3044\u3060\u56de\u6570\n\t\t\t\tint over = 0;\n\t\t\t\tfor(int j=i; j<i+5; ++j){\n\t\t\t\t\tover += j/group.length;\n\t\t\t\t\tif(over > 1){\t//2\u307e\u3067\u884c\u3063\u305f\u3089\u3001\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tint num = j%13;\n\t\t\t\t\tif(num == 0){ num = 13; }\n\t\t\t\t\tif(group[num] == 1){\n\t\t\t\t\t\t++count;\n\t\t\t\t\t}else{\n\t\t\t\t\t\tcount = 0;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(count == 5){\n\t\t\t\t\tflag = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn flag;\n\t}\n\tprivate static boolean checkThreeCard(int[] group){\n\t\tboolean flag = false;\n\t\t\n\t\tfor(int i=1; i<group.length; ++i){\n\t\t\t//main \u3067 else if \u3084\u3063\u3066\u3044\u308b\u304b\u3089\u5927\u4e08\u592b\u3060\u3051\u3069\u3001full house \u8aa4\u8a8d\u9632\u6b62\n\t\t\tif(group[i] == 2){\n\t\t\t\treturn false;\n\t\t\t}else if(group[i] == 3){\t\t//four card\u3082false\u3067\u5e30\u308b\u3002\n\t\t\t\tflag = true;\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn flag;\n\t}\n\t\n\tprivate static boolean checkTwoPair(int[] group){\n\t\tboolean flag = false;\n\t\t\n\t\tfor(int i=1; i<group.length; ++i){\n\t\t\tif(flag){\t\t//one pair \u3042\u3063\u305f\u4e0a\u3067\u898b\u3064\u304b\u3063\u305f\u3089\u3001\n\t\t\t\tif(group[i] == 2){\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(group[i] == 2){\n\t\t\t\tflag = true;\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn false;\n\t}\n\t\n\tprivate static boolean checkOnePair(int[] group){\n\t\tboolean flag = false;\n\t\t\n\t\tfor(int i=1; i<group.length; ++i){\n\t\t\tif(flag){\t\t//one pair \u3042\u3063\u305f\u4e0a\u3067\u898b\u3064\u304b\u3063\u305f\u3089\u3001\n\t\t\t\tif(group[i] == 2 || group[i] == 3){\n\t\t\t\t\tflag = false;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(group[i] == 2){\n\t\t\t\tflag = true;\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn flag;\n\t}\n\t\n\t/**\n\t * @param args\n\t */\n\tpublic static void main(String[] args) {\n\t\t// TODO Auto-generated method stub\n\t\tScanner scan = new Scanner(System.in);\n\t\tint hand[] = new int [5];\n\t\t\n\t\twhile(scan.hasNext()){\n\t\t\tString[] str = scan.next().split(\",\");\n\t\t\tfor(int i=0; i<str.length; ++i){\n\t\t\t\thand[i] = Integer.parseInt(str[i]);\n\t\t\t}\n\t\t\t\n\t\t\tint group[] = new int [14];\t//\u6dfb\u5b57\u304c\u30ab\u30fc\u30c9\u30ca\u30f3\u30d0\u3068\u5bfe\u5fdc\u3002\uff10\u306f\u6b20\u756a\n\t\t\tArrays.fill(group, 0);\n\t\t\tfor(int i=0; i<hand.length; ++i){\n\t\t\t\t++group[hand[i]];\n\t\t\t}\n\t\t\t\n\t\t\tif(checkFourCard(group)){\n\t\t\t\tSystem.out.println(\"four card\");\n\t\t\t}else if(checkFullHouse(group)){\n\t\t\t\tSystem.out.println(\"full house\");\n\t\t\t}else if(checkStraight(group)){\n\t\t\t\tSystem.out.println(\"straight\");\n\t\t\t}else if(checkThreeCard(group)){\n\t\t\t\tSystem.out.println(\"three card\");\n\t\t\t}else if(checkTwoPair(group)){\n\t\t\t\tSystem.out.println(\"two pair\");\n\t\t\t}else if(checkOnePair(group)){\n\t\t\t\tSystem.out.println(\"one pair\");\n\t\t\t}else{\n\t\t\t\tSystem.out.println(\"null\");\n\t\t\t}\n\t\t}\n\t}\n}", "sampled": "import java.util.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        \n        while (sc.hasNextLine()) {\n            String line = sc.nextLine().trim();\n            if (line.isEmpty()) break;\n            \n            String[] cards = line.split(\",\");\n            int[] hand = new int[5];\n            for (int i = 0; i < 5; i++) {\n                hand[i] = Integer.parseInt(cards[i]);\n            }\n            \n            System.out.println(evaluateHand(hand));\n        }\n        \n        sc.close();\n    }\n    \n    static String evaluateHand(int[] hand) {\n        int[] count = new int[14];\n        for (int card : hand) {\n            count[card]++;\n        }\n        \n        // Check for four card\n        for (int i = 1; i <= 13; i++) {\n            if (count[i] == 4) {\n                return \"four card\";\n            }\n        }\n        \n        // Check for full house\n        boolean hasThree = false;\n        boolean hasTwo = false;\n        for (int i = 1; i <= 13; i++) {\n            if (count[i] == 3) hasThree = true;\n            if (count[i] == 2) hasTwo = true;\n        }\n        if (hasThree && hasTwo) {\n            return \"full house\";\n        }\n        \n        // Check for straight\n        if (isStraight(hand)) {\n            return \"straight\";\n        }\n        \n        // Check for three card\n        if (hasThree) {\n            return \"three card\";\n        }\n        \n        // Check for two pair\n        int pairCount = 0;\n        for (int i = 1; i <= 13; i++) {\n            if (count[i] == 2) pairCount++;\n        }\n        if (pairCount == 2) {\n            return \"two pair\";\n        }\n        \n        // Check for one pair\n        if (pairCount == 1) {\n            return \"one pair\";\n        }\n        \n        return \"null\";\n    }\n    \n    static boolean isStraight(int[] hand) {\n        int[] sorted = hand.clone();\n        Arrays.sort(sorted);\n        \n        // Check normal straight\n        boolean isConsecutive = true;\n        for (int i = 1; i < 5; i++) {\n            if (sorted[i] != sorted[i-1] + 1) {\n                isConsecutive = false;\n                break;\n            }\n        }\n        if (isConsecutive) return true;\n        \n        // Check A-2-3-4-5\n        if (sorted[0] == 1 && sorted[1] == 2 && sorted[2] == 3 && sorted[3] == 4 && sorted[4] == 5) {\n            return true;\n        }\n        \n        // Check 10-J-Q-K-A\n        if (sorted[0] == 1 && sorted[1] == 10 && sorted[2] == 11 && sorted[3] == 12 && sorted[4] == 13) {\n            return true;\n        }\n        \n        return false;\n    }\n}\n", "perturbed_sampled": ["import java.util.*; public class  main(String[] args) { Scanner sc = new Scanner(System.in); while (sc.hasNextLine()) { String  break; String[]   hand[i] = Integer.parseInt(cards[i]); } System.out.println(evaluateHand(hand));  evaluateHand(int[] hand) { int[] count = new int[14];  Check for four card for (int  (count[i] == 4) { return \"four card\"; } } //  hasThree  false; for (int i = 1; i <= 13; i++)  hasThree = true; if    1; i <= 13; i++) { if (count[i]  return \"two pair\"; } // Check for  pair\"; } return \"null\"; }   i++) { if (sorted[i] != sorted[i-1]  false; break; } } if (isConsecutive) return true;  == 2 && sorted[2] == 3 &&  true; } // Check 10-J-Q-K-A if (sorted[0] == 1 && sorted[1] ==  &&  == 13) { return  }"], "perturbed_original": ["import java.util.Arrays;  { private static boolean  ++i){ if(group[i]   if(group[i] == 2){ two  private static boolean  false; int   //\u307e\u305f\u3044\u3060\u56de\u6570 int over = 0; for(int j=i; j<i+5; ++j){   int num =  == 1){ ++count; }else{  flag = true; break; } } } return flag; }  boolean flag = false; for(int i=1;  if \u3084\u3063\u3066\u3044\u308b\u304b\u3089\u5927\u4e08\u592b\u3060\u3051\u3069\u3001full house \u8aa4\u8a8d\u9632\u6b62  }else  private static boolean  ++i){ if(flag){ //one pair \u3042\u3063\u305f\u4e0a\u3067\u898b\u3064\u304b\u3063\u305f\u3089\u3001 if(group[i] == 2){ return true; }   false; } private static boolean checkOnePair(int[] group){   pair \u3042\u3063\u305f\u4e0a\u3067\u898b\u3064\u304b\u3063\u305f\u3089\u3001 if(group[i] == 2 || group[i] == 3){ flag  == 2){ flag = true; } } return flag; } /** * @param  String[] str  new int [14]; //\u6dfb\u5b57\u304c\u30ab\u30fc\u30c9\u30ca\u30f3\u30d0\u3068\u5bfe\u5fdc\u3002\uff10\u306f\u6b20\u756a Arrays.fill(group, 0); for(int i=0;  System.out.println(\"straight\"); }else if(checkThreeCard(group)){ System.out.println(\"three card\"); }else if(checkTwoPair(group)){ System.out.println(\"two pair\"); }else if(checkOnePair(group)){ System.out.println(\"one pair\"); }else{ System.out.println(\"null\"); } } } }"], "original_ll": -0.8529282808303833, "sampled_ll": -0.41500619053840637, "all_perturbed_sampled_ll": [-2.451428174972534], "all_perturbed_original_ll": [-2.8132483959198], "perturbed_sampled_ll": -2.451428174972534, "perturbed_original_ll": -2.8132483959198, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "# -*- coding: utf-8 -*-\n\nimport sys\nimport os\n\nfor s in sys.stdin:\n    A = list(map(int, s.split(',')))\n    A.sort()\n    #print(A)\n\n    if (A[0] == A[1] == A[2] == A[3]) or (A[1] == A[2] == A[3] == A[4]):\n        print('four card')\n\n    # full house\n    elif (A[0] == A[1] == A[2]) and (A[3] == A[4]):\n        print('full house')\n    elif (A[0] == A[1]) and (A[2] == A[3] == A[4]):\n        print('full house')\n\n    # straight\n    elif A[0] == A[1] - 1 == A[2] - 2 == A[3] - 3 == A[4] - 4:\n        print('straight')\n    elif A[1] == 10 and A[2] == 11 and A[3] == 12 and A[4] == 13 and A[0] == 1:\n        print('straight')\n\n    # three card\n    elif (A[0] == A[1] == A[2]) or (A[1] == A[2] == A[3]) or (A[2] == A[3] == A[4]):\n        print('three card')\n\n    # two pair\n    elif ((A[0] == A[1]) and (A[2] == A[3])) or ((A[0] == A[1]) and (A[3] == A[4])) or ((A[1] == A[2]) and (A[3] == A[4])):\n        print('two pair')\n\n    # one pair\n    elif (A[0] == A[1]) or (A[1] == A[2]) or (A[2] == A[3]) or (A[3] == A[4]):\n        print('one pair')\n\n    else:\n        print('null')", "sampled": "import sys\nfrom collections import Counter\n\ndef get_hand_rank(cards):\n    counts = Counter(cards)\n    count_values = sorted(counts.values(), reverse=True)\n    \n    # Check for four card\n    if count_values[0] == 4:\n        return \"four card\"\n    \n    # Check for full house\n    if count_values[0] == 3 and count_values[1] == 2:\n        return \"full house\"\n    \n    # Check for straight\n    sorted_cards = sorted(cards)\n    is_straight = True\n    for i in range(4):\n        if sorted_cards[i+1] - sorted_cards[i] != 1:\n            is_straight = False\n            break\n    \n    if is_straight:\n        return \"straight\"\n    \n    # Check for A-2-3-4-5 straight\n    if sorted_cards == [1, 2, 3, 4, 5]:\n        return \"straight\"\n    \n    # Check for 10-J-Q-K-A straight\n    if sorted_cards == [1, 10, 11, 12, 13]:\n        return \"straight\"\n    \n    # Check for three card\n    if count_values[0] == 3:\n        return \"three card\"\n    \n    # Check for two pair\n    if count_values[0] == 2 and count_values[1] == 2:\n        return \"two pair\"\n    \n    # Check for one pair\n    if count_values[0] == 2:\n        return \"one pair\"\n    \n    return \"null\"\n\nfor line in sys.stdin:\n    line = line.strip()\n    if not line:\n        break\n    cards = list(map(int, line.split(',')))\n    print(get_hand_rank(cards))\n", "perturbed_sampled": ["import sys  get_hand_rank(cards): counts = Counter(cards)  if count_values[0] ==   count_values[1] == 2: return \"full   range(4): if  [1, 2, 3, 4, 5]: return \"straight\" # Check for 10-J-Q-K-A straight if sorted_cards ==  return \"straight\" # Check  == 3: return \"three   return  pair\" return \"null\" for line in sys.stdin: line = line.strip() if not line: break cards = list(map(int, line.split(','))) print(get_hand_rank(cards))"], "perturbed_original": ["# -*- coding: utf-8 -*- import  list(map(int, s.split(','))) A.sort() #print(A) if  == A[3]) or (A[1] == A[2] == A[3] == A[4]): print('four card') # full  == A[2]) and  elif   3 == A[4] - 4:  and A[2] == 11  A[4] == 13 and A[0] ==  elif (A[0] == A[1] == A[2]) or (A[1] == A[2] == A[3])  (A[0]  A[2]) or (A[2] == A[3]) or (A[3] == A[4]): print('one pair') else: print('null')"], "original_ll": -0.4635232388973236, "sampled_ll": -0.5993234515190125, "all_perturbed_sampled_ll": [-2.825326919555664], "all_perturbed_original_ll": [-1.9597969055175781], "perturbed_sampled_ll": -2.825326919555664, "perturbed_original_ll": -1.9597969055175781, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "#include<stdio.h>\n#include<string.h>\n\n\nint main(){\n  int i,j,k,l,al[]={0,1,5,7,11,17,19,23,25},n,clen;\n  char ci[257],ans[257];\n  fgets(ci,256,stdin);\n  n=atoi(ci);\n  for(i=0;i<n;i++){\n    fgets(ci,256,stdin);\n    clen=strlen(ci);\n    ans[clen]='\\0';\n    for(j=0;j<9;j++){\n      for(k=0;k<26;k++){\n\tfor(l=0;l<clen;l++){\n\t  if(isalpha(ci[l]))\n\t    ans[l]=(al[j]*((int)ci[l]-(int)'a')+k)%26+'a';\n\t  else\n\t    ans[l]=ci[l];\n\t}\n\tif(strstr(ans,\"that\")||strstr(ans,\"this\")){\n\t  printf(\"%s\",ans);\n\t  goto find;\n\t}\n      }\n    }\n  find:;\n  }\n  return 0;\n}", "sampled": "#include <stdio.h>\n#include <string.h>\n#include <ctype.h>\n\nint gcd(int a, int b) {\n    if (b == 0) return a;\n    return gcd(b, a % b);\n}\n\nint mod_inverse(int a, int m) {\n    for (int i = 1; i < m; i++) {\n        if ((a * i) % m == 1) return i;\n    }\n    return -1;\n}\n\nvoid decrypt(char *text, int alpha, int beta, char *result) {\n    int alpha_inv = mod_inverse(alpha, 26);\n    if (alpha_inv == -1) {\n        result[0] = '\\0';\n        return;\n    }\n    \n    int len = strlen(text);\n    for (int i = 0; i < len; i++) {\n        if (isalpha(text[i])) {\n            int c = text[i] - 'a';\n            int decoded = (alpha_inv * (c - beta + 26)) % 26;\n            if (decoded < 0) decoded += 26;\n            result[i] = decoded + 'a';\n        } else {\n            result[i] = text[i];\n        }\n    }\n    result[len] = '\\0';\n}\n\nint contains_word(char *text, char *word) {\n    int text_len = strlen(text);\n    int word_len = strlen(word);\n    \n    for (int i = 0; i <= text_len - word_len; i++) {\n        if (i > 0 && isalpha(text[i-1])) continue;\n        if (i + word_len < text_len && isalpha(text[i + word_len])) continue;\n        \n        int match = 1;\n        for (int j = 0; j < word_len; j++) {\n            if (text[i + j] != word[j]) {\n                match = 0;\n                break;\n            }\n        }\n        if (match) return 1;\n    }\n    return 0;\n}\n\nint main() {\n    int n;\n    scanf(\"%d\\n\", &n);\n    \n    for (int t = 0; t < n; t++) {\n        char text[257];\n        fgets(text, 257, stdin);\n        int len = strlen(text);\n        if (text[len-1] == '\\n') text[len-1] = '\\0';\n        \n        char result[257];\n        int found = 0;\n        \n        for (int alpha = 1; alpha < 26 && !found; alpha++) {\n            if (gcd(alpha, 26) != 1) continue;\n            \n            for (int beta = 0; beta < 26 && !found; beta++) {\n                decrypt(text, alpha, beta, result);\n                \n                if (contains_word(result, \"that\") || contains_word(result, \"this\")) {\n                    printf(\"%s\\n\", result);\n                    found = 1;\n                }\n            }\n        }\n    }\n    \n    return 0;\n}\n", "perturbed_sampled": ["#include <stdio.h> #include <string.h>  int b) {  a; return gcd(b,  mod_inverse(int  i < m; i++)   i; } return -1; } void decrypt(char *text, int alpha, int beta,  (alpha_inv == -1)  } int  'a'; int decoded = (alpha_inv * (c -  result[len] =  char *word) { int text_len  strlen(word); for  <= text_len - word_len; i++) { if (i  <  (text[i + j] != word[j])  0; } int  &n); for (int t = 0; t < n; t++) {  int len = strlen(text); if (text[len-1] == '\\n') text[len-1] = '\\0'; char result[257];  (int alpha = 1; alpha <  if (gcd(alpha, 26)  beta = 0; beta < 26 && !found; beta++) { decrypt(text, alpha, beta,   0; }"], "perturbed_original": ["#include<stdio.h> #include<string.h> int main(){    else  find; } } } find:; } return 0; }"], "original_ll": -1.324188470840454, "sampled_ll": -0.5105780363082886, "all_perturbed_sampled_ll": [-2.949456214904785], "all_perturbed_original_ll": [-3.2828686237335205], "perturbed_sampled_ll": -2.949456214904785, "perturbed_original_ll": -3.2828686237335205, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "\n\nimport java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.util.ArrayList;\n\n\n\n class Main{\n     \n    static  ArrayList<String> al=new ArrayList<String>();\n    static int A=1,B=0;\n    static char chars[]= new char[]{\n         'a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p',\n         'q','r','s','t','u','v','w','x','y','z'\n     };\n    static char getChar(int n){return chars[n];}\n    static int getCode(char c){return (int)c-(int)'a';}\n    static int F(int m){return (A*m+B)%26;}\n    static String replace(String str){\n        StringBuilder sb=new StringBuilder();\n        for(int i=0; i<str.length(); i++){\n           // System.out.println(str.charAt(i)+\" \"+F(getCode(str.charAt(i))));\n            char replaced = getChar(F(getCode(str.charAt(i))));\n            //System.out.println(replaced);\n            sb.append(replaced);\n        }        return new String(sb);\n    }\n    static void detectAB(){\n        A=1;B=0;\n        for(int a=1; a<30000;a+=2){\n            for(int b=0; b<26;b++){\n                A=a;B=b;\n                for(String str:al){\n                    String rep = replace(str);\n                    //System.out.println(rep);\n                    if(rep.equals(\"this\")||rep.equals(\"that\"))return;\n                }\n            }\n        }\n    }\n    \n     public static void main(String args[]){\n         BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        // System.out.println(getCode('a')+\"\"+getCode('b')+\"\"+getCode('z'));\n         //System.out.println(replace(\"abz\"));\n         //String line;\n         try{\n         int n=Integer.parseInt(br.readLine());\n         //int n=1;\n         //for(int i=0; i<n;i++){\n         String line;\n         while((line=br.readLine())!=null){\n             //System.out.println(\"aa\"+n);\n             al.clear();\n             \n             //System.out.println(line);\n             String split[]=line.split(\" \");\n             for(String str:split)if(str.length()==4)al.add(str);\n            detectAB();\n             System.out.print(replace(split[0]));\n            for(int j=1; j<split.length;j++){\n                System.out.print(\" \"+replace(split[j]));\n            }\n             System.out.println();\n         }\n         }catch(Exception e){}\n         \n     }\n     \n }", "sampled": "import java.util.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int n = sc.nextInt();\n        sc.nextLine();\n        \n        for (int i = 0; i < n; i++) {\n            String encrypted = sc.nextLine();\n            String decrypted = decrypt(encrypted);\n            System.out.println(decrypted);\n        }\n    }\n    \n    static String decrypt(String encrypted) {\n        // Try all possible alpha and beta values\n        for (int alpha = 1; alpha < 26; alpha++) {\n            if (gcd(alpha, 26) != 1) continue; // alpha must be coprime with 26\n            \n            for (int beta = 0; beta < 26; beta++) {\n                String decrypted = tryDecrypt(encrypted, alpha, beta);\n                if (decrypted != null && (decrypted.contains(\"that\") || decrypted.contains(\"this\"))) {\n                    return decrypted;\n                }\n            }\n        }\n        return encrypted;\n    }\n    \n    static String tryDecrypt(String encrypted, int alpha, int beta) {\n        // Find modular inverse of alpha\n        int alphaInv = modInverse(alpha, 26);\n        if (alphaInv == -1) return null;\n        \n        StringBuilder sb = new StringBuilder();\n        for (char c : encrypted.toCharArray()) {\n            if (c >= 'a' && c <= 'z') {\n                int y = c - 'a';\n                int x = (alphaInv * (y - beta + 26)) % 26;\n                if (x < 0) x += 26;\n                sb.append((char)('a' + x));\n            } else {\n                sb.append(c);\n            }\n        }\n        return sb.toString();\n    }\n    \n    static int gcd(int a, int b) {\n        if (b == 0) return a;\n        return gcd(b, a % b);\n    }\n    \n    static int modInverse(int a, int m) {\n        for (int x = 1; x < m; x++) {\n            if ((a * x) % m == 1) {\n                return x;\n            }\n        }\n        return -1;\n    }\n}\n", "perturbed_sampled": ["import java.util.*; public class  main(String[] args) { Scanner sc = new Scanner(System.in); int n  i = 0; i < n;  sc.nextLine(); String  } static String decrypt(String encrypted) { // Try all possible alpha  alpha   alpha must be coprime with 26 for (int beta = 0; beta <   (decrypted != null && (decrypted.contains(\"that\") ||  } } return  encrypted, int alpha, int  inverse   -1) return null; StringBuilder     (alphaInv * (y - beta   } else { sb.append(c);  static int  if (b  } static int  == 1)  return -1; } }"], "perturbed_original": ["import java.io.BufferedReader; import java.io.InputStreamReader;  ArrayList<String> al=new ArrayList<String>(); static int A=1,B=0;  'a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p', 'q','r','s','t','u','v','w','x','y','z' }; static char getChar(int n){return chars[n];} static int getCode(char c){return (int)c-(int)'a';} static int F(int m){return (A*m+B)%26;} static String replace(String  System.out.println(str.charAt(i)+\" \"+F(getCode(str.charAt(i))));  String(sb); }   A=a;B=b; for(String  } } public static  line; try{ int n=Integer.parseInt(br.readLine()); //int   String split[]=line.split(\"    } }"], "original_ll": -1.1537333726882935, "sampled_ll": -0.566597580909729, "all_perturbed_sampled_ll": [-3.427311658859253], "all_perturbed_original_ll": [-2.119982957839966], "perturbed_sampled_ll": -3.427311658859253, "perturbed_original_ll": -2.119982957839966, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "for _ in[0]*int(input()):\n e=input()\n for i in range(1,26,2):\n  for j in range(26):\n   a=''.join([c,chr(((ord(c)-97)*i+j)%26+97)][c.islower()]for c in e)\n   if'that'in a or'this'in a:print(a);break\n", "sampled": "def gcd(a, b):\n    while b:\n        a, b = b, a % b\n    return a\n\ndef mod_inverse(a, m):\n    if gcd(a, m) != 1:\n        return None\n    for i in range(1, m):\n        if (a * i) % m == 1:\n            return i\n    return None\n\ndef decrypt_char(c, alpha, beta):\n    if not c.isalpha():\n        return c\n    alpha_inv = mod_inverse(alpha, 26)\n    if alpha_inv is None:\n        return c\n    val = ord(c) - ord('a')\n    decrypted_val = (alpha_inv * (val - beta)) % 26\n    return chr(decrypted_val + ord('a'))\n\ndef decrypt_text(text, alpha, beta):\n    return ''.join(decrypt_char(c, alpha, beta) for c in text)\n\ndef try_decrypt(encrypted):\n    keywords = [\"that\", \"this\"]\n    \n    for alpha in range(1, 26):\n        if gcd(alpha, 26) != 1:\n            continue\n        \n        for beta in range(26):\n            decrypted = decrypt_text(encrypted, alpha, beta)\n            \n            for keyword in keywords:\n                if keyword in decrypted:\n                    return decrypted\n    \n    return encrypted\n\nn = int(input())\nfor _ in range(n):\n    encrypted = input()\n    print(try_decrypt(encrypted))\n", "perturbed_sampled": [" a, b = b, a  mod_inverse(a, m): if gcd(a, m) !=  in range(1,  return i return None def  c.isalpha(): return c  alpha_inv is None: return c  ord('a')) def decrypt_text(text, alpha,  def try_decrypt(encrypted): keywords  in range(1, 26):  range(26): decrypted = decrypt_text(encrypted,  keywords: if keyword in decrypted: return   encrypted = input() print(try_decrypt(encrypted))"], "perturbed_original": [" i in range(1,26,2): for  in e) if'that'in a or'this'in a:print(a);break"], "original_ll": -2.2450149059295654, "sampled_ll": -0.7217479944229126, "all_perturbed_sampled_ll": [-3.4793684482574463], "all_perturbed_original_ll": [-4.099874496459961], "perturbed_sampled_ll": -3.4793684482574463, "perturbed_original_ll": -4.099874496459961, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "d[4],e[9],f,k;char x[];z(){int b,c,a=e[f++];a>9?x[k++]=40,b=z(),x[k++]=a,c=z(),x[k++]=41,a=a-43?a-45?b*c:b-c:b+c:(x[k++]=a+48);return a;}y(o,n,i,j){if(i==7){f=k=0;if(z()==10){x[k]=0;puts(x);return 1;}return 0;}if(o)for(;j--;){e[i]=\"+-*\"[j];if(y(o-1,n+1,i+1,3))return 1;}if(n|i==6)for(j=4;j--;)if(e[i]=d[j]){d[j]=0;if(y(o,n-1,i+1,3))return 1;d[j]=e[i];}return 0;}main(){for(;scanf(\"%d%d%d%d\",d,d+1,d+2,d+3),f=*d;)y(3,0,0,3)||puts(\"0\");}", "sampled": "#include <stdio.h>\n#include <string.h>\n\nint nums[4];\nchar result[1025];\nint found;\n\nvoid generate(int depth, int count, int used, int values[], char* exprs[], int value, char* expr) {\n    if (found) return;\n    \n    if (count == 1) {\n        if (value == 10) {\n            strcpy(result, expr);\n            found = 1;\n        }\n        return;\n    }\n    \n    for (int i = 0; i < count; i++) {\n        for (int j = i + 1; j < count; j++) {\n            int newValues[4];\n            char* newExprs[4];\n            int newCount = 0;\n            \n            for (int k = 0; k < count; k++) {\n                if (k != i && k != j) {\n                    newValues[newCount] = values[k];\n                    newExprs[newCount] = exprs[k];\n                    newCount++;\n                }\n            }\n            \n            char expr1[1025], expr2[1025], expr3[1025];\n            \n            // Addition\n            sprintf(expr1, \"(%s + %s)\", exprs[i], exprs[j]);\n            newValues[newCount] = values[i] + values[j];\n            newExprs[newCount] = expr1;\n            generate(depth + 1, newCount + 1, used, newValues, newExprs, newValues[newCount], expr1);\n            if (found) return;\n            \n            // Subtraction (i - j)\n            sprintf(expr2, \"(%s - %s)\", exprs[i], exprs[j]);\n            newValues[newCount] = values[i] - values[j];\n            newExprs[newCount] = expr2;\n            generate(depth + 1, newCount + 1, used, newValues, newExprs, newValues[newCount], expr2);\n            if (found) return;\n            \n            // Subtraction (j - i)\n            sprintf(expr3, \"(%s - %s)\", exprs[j], exprs[i]);\n            newValues[newCount] = values[j] - values[i];\n            newExprs[newCount] = expr3;\n            generate(depth + 1, newCount + 1, used, newValues, newExprs, newValues[newCount], expr3);\n            if (found) return;\n            \n            // Multiplication\n            sprintf(expr1, \"(%s * %s)\", exprs[i], exprs[j]);\n            newValues[newCount] = values[i] * values[j];\n            newExprs[newCount] = expr1;\n            generate(depth + 1, newCount + 1, used, newValues, newExprs, newValues[newCount], expr1);\n            if (found) return;\n        }\n    }\n}\n\nvoid permute(int pos, int used, int perm[]) {\n    if (found) return;\n    \n    if (pos == 4) {\n        int values[4];\n        char* exprs[4];\n        char exprBuf[4][10];\n        \n        for (int i = 0; i < 4; i++) {\n            values[i] = perm[i];\n            sprintf(exprBuf[i], \"%d\", perm[i]);\n            exprs[i] = exprBuf[i];\n        }\n        \n        generate(0, 4, 0, values, exprs, 0, \"\");\n        return;\n    }\n    \n    for (int i = 0; i < 4; i++) {\n        if (!(used & (1 << i))) {\n            perm[pos] = nums[i];\n            permute(pos + 1, used | (1 << i), perm);\n            if (found) return;\n        }\n    }\n}\n\nint main() {\n    while (1) {\n        scanf(\"%d %d %d %d\", &nums[0], &nums[1], &nums[2], &nums[3]);\n        \n        if (nums[0] == 0 && nums[1] == 0 && nums[2] == 0 && nums[3] == 0) {\n            break;\n        }\n        \n        found = 0;\n        result[0] = '\\0';\n        \n        int perm[4];\n        permute(0, 0, perm);\n        \n        if (found) {\n            printf(\"%s\\n\", result);\n        } else {\n            printf(\"0\\n\");\n        }\n    }\n    \n    return 0;\n}\n", "perturbed_sampled": ["#include  char result[1025]; int  count, int used, int values[], char* exprs[], int value,  return; if  (value == 10) { strcpy(result, expr); found = 1; } return; } for (int i = 0; i < count; i++) { for  1; j  newCount = 0; for (int  (k !=  expr2[1025], expr3[1025]; //  exprs[i], exprs[j]); newValues[newCount]   newValues, newExprs, newValues[newCount], expr1);  \"(%s -   newCount +  + 1, newCount + 1,  if (found) return; // Multiplication   + 1, used, newValues, newExprs,  int perm[]) { if (found) return; if (pos == 4) { int values[4]; char* exprs[4];   = 0; i < 4;  (1 << i), perm); if (found) return; } } } int main()  %d %d %d\",  (nums[0] == 0 && nums[1] == 0 && nums[2] == 0 && nums[3] == 0) {  result[0] = '\\0'; int  (found) { printf(\"%s\\n\", result); } else { printf(\"0\\n\"); } } return 0; }"], "perturbed_original": ["d[4],e[9],f,k;char x[];z(){int b,c,a=e[f++];a>9?x[k++]=40,b=z(),x[k++]=a,c=z(),x[k++]=41,a=a-43?a-45?b*c:b-c:b+c:(x[k++]=a+48);return  0;}main(){for(;scanf(\"%d%d%d%d\",d,d+1,d+2,d+3),f=*d;)y(3,0,0,3)||puts(\"0\");}"], "original_ll": -2.5349209308624268, "sampled_ll": -0.5034188032150269, "all_perturbed_sampled_ll": [-2.438915967941284], "all_perturbed_original_ll": [-3.097567319869995], "perturbed_sampled_ll": -2.438915967941284, "perturbed_original_ll": -3.097567319869995, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import java.util.*;\n\nclass Main{\n  public static ArrayList<int[]> perm(int n){\n    int[] num = new int[n];\n    boolean[] flag = new boolean[n];\n    ArrayList<int[]> arrList = new ArrayList<int[]>();\n    permCalc(0,num,flag,arrList);\n    return arrList;\n  }\n\n  public static void permCalc(int rank, int[] num, boolean[] flag, ArrayList<int[]> arrList){\n    if (rank == num.length) {\n      arrList.add(num.clone());\n    }\n    else {\n      for (int i = 0; i < num.length; i++) {\n        if (!flag[i]) {\n          num[rank] = i;\n          flag[i] = true;\n          permCalc(rank+1,num,flag,arrList);\n          flag[i] = false;\n        }\n      }\n    }\n  }\n\n  public static int ope(int a, int b, int operand){\n    switch (operand) {\n      case 0:\n        return a+b;\n      case 1:\n        return a-b;\n      default:\n        return a*b;\n    }\n  }\n\n  public static String opeToStr(int operand){\n    switch (operand) {\n      case 0:\n        return \"+\";\n      case 1:\n        return \"-\";\n      default:\n        return \"*\";\n    }\n  }\n\n  public static String check(int[] num, int[] op){\n    int a = num[0];\n    int b = num[1];\n    int c = num[2];\n    int d = num[3];\n    if(ope(ope(ope(a,b,op[0]),c,op[1]),d,op[2]) == 10) {\n      return \"((\"+a+\" \"+opeToStr(op[0])+\" \"+b+\") \"+opeToStr(op[1])+\" \"+c+\") \"+opeToStr(op[2])+\" \"+d;\n    }\n    else if(ope(ope(a,b,op[0]),ope(c,d,op[2]),op[1]) == 10) {\n      return \"(\"+a+\" \"+opeToStr(op[0])+\" \"+b+\") \"+opeToStr(op[1])+\" (\"+c+\" \"+opeToStr(op[2])+\" \"+d+\")\";\n    }\n    else if(ope(ope(a,ope(b,c,op[1]),op[0]),d,op[2]) == 10) {\n      return \"(\"+a+\" \"+opeToStr(op[0])+\" (\"+b+\" \"+opeToStr(op[1])+\" \"+c+\")) \"+opeToStr(op[2])+\" \"+d;\n    }\n    else if(ope(a,ope(ope(b,c,op[1]),d,op[2]),op[0]) == 10) {\n      return a+\" \"+opeToStr(op[0])+\" ((\"+b+\" \"+opeToStr(op[1])+\" \"+c+\") \"+opeToStr(op[2])+\" \"+d+\")\";\n    }\n    else if(ope(a,ope(b,ope(c,d,op[2]),op[1]),op[0]) == 10) {\n      return a+\" \"+opeToStr(op[0])+\" (\"+b+\" \"+opeToStr(op[1])+\" (\"+c+\" \"+opeToStr(op[2])+\" \"+d+\"))\";\n    }\n    else {\n      return null;\n    }\n  }\n\n  public static void main(String[] args){\n    Scanner sc = new Scanner(System.in);\n    ArrayList<int[]> arrList = perm(4);\n    int[][] operand = new int[27][];\n    for (int i = 0; i < 3; i++) {\n      for (int j = 0; j < 3; j++) {\n        for (int k = 0; k < 3; k++) {\n          int[] temp = {i,j,k};\n          operand[9*i+3*j+k] = temp;\n        }\n      }\n    }\n    while(true) {\n      int[] num0 = new int[4];\n      for (int i = 0; i < 4; i++) {\n        num0[i] = sc.nextInt();\n      }\n      if (num0[0] == 0 && num0[1] == 0 && num0[2] == 0 && num0[3] == 0) {\n        break;\n      }\n      String chk = null;\n      search:\n      for (int i = 0; i < arrList.size(); i++) {\n        int[] num = {num0[arrList.get(i)[0]],num0[arrList.get(i)[1]],\n                     num0[arrList.get(i)[2]],num0[arrList.get(i)[3]]};\n        for (int j = 0; j < operand.length; j++) {\n          chk = check(num, operand[j]);\n          if (chk != null) {\n            break search;\n          }\n        }\n      }\n      if (chk == null) {\n        System.out.println(0);\n      }\n      else {\n        System.out.println(chk);\n      }\n    }\n  }\n}", "sampled": "import java.util.*;\n\npublic class Main {\n    static class Expr {\n        String str;\n        int val;\n        Expr(String s, int v) {\n            str = s;\n            val = v;\n        }\n    }\n    \n    static String result;\n    static boolean found;\n    \n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        \n        while (true) {\n            int a = sc.nextInt();\n            int b = sc.nextInt();\n            int c = sc.nextInt();\n            int d = sc.nextInt();\n            \n            if (a == 0 && b == 0 && c == 0 && d == 0) break;\n            \n            int[] nums = {a, b, c, d};\n            result = null;\n            found = false;\n            \n            permute(nums, 0);\n            \n            if (result != null) {\n                System.out.println(result);\n            } else {\n                System.out.println(\"0\");\n            }\n        }\n    }\n    \n    static void permute(int[] nums, int start) {\n        if (found) return;\n        \n        if (start == nums.length) {\n            solve(nums);\n            return;\n        }\n        \n        for (int i = start; i < nums.length; i++) {\n            swap(nums, start, i);\n            permute(nums, start + 1);\n            swap(nums, start, i);\n            if (found) return;\n        }\n    }\n    \n    static void swap(int[] nums, int i, int j) {\n        int temp = nums[i];\n        nums[i] = nums[j];\n        nums[j] = temp;\n    }\n    \n    static void solve(int[] nums) {\n        List<Expr> exprs = new ArrayList<>();\n        for (int num : nums) {\n            exprs.add(new Expr(String.valueOf(num), num));\n        }\n        \n        generate(exprs);\n    }\n    \n    static void generate(List<Expr> exprs) {\n        if (found) return;\n        \n        if (exprs.size() == 1) {\n            if (exprs.get(0).val == 10) {\n                result = exprs.get(0).str;\n                found = true;\n            }\n            return;\n        }\n        \n        for (int i = 0; i < exprs.size(); i++) {\n            for (int j = 0; j < exprs.size(); j++) {\n                if (i == j) continue;\n                \n                Expr e1 = exprs.get(i);\n                Expr e2 = exprs.get(j);\n                \n                char[] ops = {'+', '-', '*'};\n                \n                for (char op : ops) {\n                    int newVal = calc(e1.val, e2.val, op);\n                    String newStr = \"(\" + e1.str + \" \" + op + \" \" + e2.str + \")\";\n                    \n                    List<Expr> newExprs = new ArrayList<>();\n                    for (int k = 0; k < exprs.size(); k++) {\n                        if (k != i && k != j) {\n                            newExprs.add(exprs.get(k));\n                        }\n                    }\n                    newExprs.add(new Expr(newStr, newVal));\n                    \n                    generate(newExprs);\n                    if (found) return;\n                }\n            }\n        }\n    }\n    \n    static int calc(int a, int b, char op) {\n        switch (op) {\n            case '+': return a + b;\n            case '-': return a - b;\n            case '*': return a * b;\n        }\n        return 0;\n    }\n}\n", "perturbed_sampled": ["import java.util.*; public class    = v; } } static String result; static boolean found; public  Scanner   sc.nextInt(); int c = sc.nextInt(); int d = sc.nextInt(); if (a == 0  b, c,  = false; permute(nums, 0);  System.out.println(\"0\");  permute(int[] nums, int start) { if (found) return; if  return; } for (int i = start; i < nums.length; i++) { swap(nums, start, i);  i, int j) { int  } static void solve(int[]  new ArrayList<>(); for (int  Expr(String.valueOf(num),   == 1) { if (exprs.get(0).val == 10) { result =  i = 0; i < exprs.size(); i++)  e1 = exprs.get(i); Expr e2  {'+', '-', '*'}; for (char   String newStr = \"(\" + e1.str + \" \" + op + \" \" +  = new ArrayList<>(); for (int  (k != i && k != j) { newExprs.add(exprs.get(k));   '+':  a  } }"], "perturbed_original": ["import java.util.*; class Main{ public static (operand[9*i + j],operand[8*i+3*j+k] = new int[n]; boolean[] flag = new boolean[n]; ArrayList<int[]> <extra_id_8>1; if (flag[0]* i ==<extra_id_9>0; num0[i] ==<extra_id_10>{ return arrList; } public static void permCalc(int rank, int[] num, boolean[]    = 0; i < num.length; i++) { if  flag[i] = true; permCalc(rank+1,num,flag,arrList); flag[i] = false; } } } }  switch (operand) {  return  (operand) { case 0: return \"+\"; case 1:  String check(int[]  =  int c = num[2]; int d =  return \"((\"+a+\" \"+opeToStr(op[0])+\"  10)   else if(ope(ope(a,ope(b,c,op[1]),op[0]),d,op[2]) ==  \"+d;  ((\"+b+\" \"+opeToStr(op[1])+\" \"+c+\") \"+opeToStr(op[2])+\" \"+d+\")\"; }  return  { return  void  new    { for (int j = 0; j < 3; j++) { for (int k = 0; k < 3;  {i,j,k}; operand[9*i+3*j+k]  (int i = 0; i <   0 && num0[1] == 0 && num0[2] == 0 &&  num0[arrList.get(i)[2]],num0[arrList.get(i)[3]]}; for (int j = 0;  if (chk  (chk ==  } }"], "original_ll": -0.5566064715385437, "sampled_ll": -0.39151710271835327, "all_perturbed_sampled_ll": [-2.771575689315796], "all_perturbed_original_ll": [-2.7685041427612305], "perturbed_sampled_ll": -2.771575689315796, "perturbed_original_ll": -2.7685041427612305, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "from itertools import *\ndef f(s):\n if sum(s)==10:return\"((({} + {}) + {}) + {})\".format(*s)\n for a,b,c,d in permutations(s):\n  for x,y,z in permutations('+-**',3):\n   for t in[f\"({a} {x} {b}) {y} ({c} {z} {d})\",f\"(({a} {x} {b}) {y} {c}) {z} {d}\",f\"({a} {x} ({b} {y} {c})) {z} {d}\"]:\n    if eval(t)==10:return'('+t+')'\n else:return 0\nfor e in iter(input,'0 0 0 0'):print(f(list(map(int,e.split()))))\n", "sampled": "from itertools import permutations, product\n\ndef evaluate(expr):\n    try:\n        return eval(expr)\n    except:\n        return None\n\ndef generate_expressions(nums):\n    operators = ['+', '-', '*']\n    \n    # Template patterns for 4 numbers with different parenthesizations\n    patterns = [\n        # No parentheses\n        \"{} {} {} {} {} {} {}\",\n        # One pair of parentheses\n        \"({} {} {}) {} {} {} {}\",\n        \"{} {} ({} {} {}) {} {}\",\n        \"{} {} {} {} ({} {} {})\",\n        # Two pairs of parentheses\n        \"({} {} {}) {} ({} {} {})\",\n        \"(({} {} {}) {} {}) {} {}\",\n        \"{} {} (({} {} {}) {} {})\",\n        \"({} {} ({} {} {})) {} {}\",\n        \"{} {} ({} {} ({} {} {}))\",\n        # Three pairs of parentheses\n        \"(({} {} {}) {} ({} {} {}))\",\n        \"((({} {} {}) {} {}) {} {})\",\n        \"({} {} (({} {} {}) {} {}))\",\n        \"({} {} ({} {} ({} {} {})))\",\n        \"{} {} ((({} {} {}) {} {}))\",\n        \"{} {} (({} {} ({} {} {})))\",\n        \"{} {} ({} {} (({} {} {})))\",\n        # More complex patterns\n        \"((({} {} {}) {} ({} {} {})))\",\n        \"(({} {} ({} {} {})) {} {})\",\n        \"({} {} (({} {} ({} {} {}))))\",\n        \"(({} {} {}) {} (({} {} {})))\",\n        \"((({} {} ({} {} {}))) {} {})\",\n        \"{} {} (((({} {} {})) {} {}))\",\n    ]\n    \n    for perm in permutations(nums):\n        for ops in product(operators, repeat=3):\n            for pattern in patterns:\n                try:\n                    # Interleave numbers and operators\n                    elements = []\n                    num_idx = 0\n                    op_idx = 0\n                    for char in pattern:\n                        if char == '{}':\n                            if num_idx < 4:\n                                elements.append(str(perm[num_idx]))\n                                num_idx += 1\n                            elif op_idx < 3:\n                                elements.append(ops[op_idx])\n                                op_idx += 1\n                    \n                    if num_idx == 4 and op_idx == 3:\n                        expr = pattern.format(perm[0], ops[0], perm[1], ops[1], perm[2], ops[2], perm[3])\n                        result = evaluate(expr)\n                        if result == 10:\n                            return expr\n                except:\n                    continue\n    \n    return None\n\ndef solve():\n    results = []\n    while True:\n        line = input().split()\n        nums = [int(x) for x in line]\n        \n        if nums == [0, 0, 0, 0]:\n            break\n        \n        expr = generate_expressions(nums)\n        if expr:\n            results.append(expr)\n        else:\n            results.append(\"0\")\n    \n    for result in results:\n        print(result)\n\nsolve()\n", "perturbed_sampled": ["from itertools import permutations, product def evaluate(expr):   {} {} {}  of parentheses \"({} {} {}) {} {} {} {}\", \"{} {} ({} {} {})  parentheses \"({} {} {}) {} ({}  {} {}) {} {}\", \"{}  {})\", \"({} {} ({} {} {})) {} {}\", \"{} {} ({} {}  pairs  {} ({} {} {}))\", \"((({} {} {}) {} {})  ({} {} {})))\", \"{} {} ((({} {} {})  {} ({} {} {})))\", \"{} {} ({}  {} {}) {}  ({} {}   (({} {}   in permutations(nums):  try: # Interleave  [] num_idx = 0 op_idx  '{}': if num_idx < 4: elements.append(str(perm[num_idx])) num_idx +=  elements.append(ops[op_idx]) op_idx  4 and op_idx == 3: expr =  ops[2], perm[3]) result = evaluate(expr) if result == 10:  ==  expr: results.append(expr) else: results.append(\"0\")  solve()"], "perturbed_original": [" {})\".format(*s) for  in permutations('+-**',3): for  {d}\",f\"({a} {x} ({b} {y} {c})) {z} {d}\"]: if eval(t)==10:return'('+t+')' else:return 0 for e in iter(input,'0 0 0 0'):print(f(list(map(int,e.split()))))"], "original_ll": -1.8911123275756836, "sampled_ll": -0.8875479698181152, "all_perturbed_sampled_ll": [-2.932694673538208], "all_perturbed_original_ll": [-3.6790616512298584], "perturbed_sampled_ll": -2.932694673538208, "perturbed_original_ll": -3.6790616512298584, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "#include<stdio.h>\n\nint main(void)\n{\n  int i,j;\n  int prime[70000];\n  int n;\n  for(i=0;i<60000;i++){\n    prime[i] = 1;\n  }\n  prime[0]=0;\n  scanf(\"%d\",&n);\n\n  for(i=1;i*i<=60000;i++){\n    if(prime[i]==1){\n      for(j=i+1;(i+1)*j<=60000;j++){\n\tprime[(i+1)*j-1]=0;\n      }\n    }\n  }\n\n  for(i=n-2;0<=i;i--){\n    if(prime[i]==1){\n      printf(\"%d \",i+1); break;\n    }\n  }\n\n  for(i=n;i<60000;i++){\n    if(prime[i]==1){\n      printf(\"%d\",i+1); break;\n    }\n  }\n  putchar('\\n');\n  return 0;\n}", "sampled": "#include <stdio.h>\n#include <stdbool.h>\n#include <math.h>\n\nbool is_prime(int num) {\n    if (num < 2) return false;\n    if (num == 2) return true;\n    if (num % 2 == 0) return false;\n    \n    int sqrt_num = (int)sqrt(num);\n    for (int i = 3; i <= sqrt_num; i += 2) {\n        if (num % i == 0) return false;\n    }\n    return true;\n}\n\nint main() {\n    int n;\n    \n    while (scanf(\"%d\", &n) != EOF) {\n        int smaller = n - 1;\n        int larger = n + 1;\n        \n        while (smaller >= 2 && !is_prime(smaller)) {\n            smaller--;\n        }\n        \n        while (!is_prime(larger)) {\n            larger++;\n        }\n        \n        printf(\"%d %d\\n\", smaller, larger);\n    }\n    \n    return 0;\n}\n", "perturbed_sampled": ["#include <stdio.h> #include <stdbool.h> #include <math.h> bool is_prime(int num) {  sqrt_num = (int)sqrt(num);  i <= sqrt_num; i += 2) { if (num   != EOF) { int  { smaller--; } while (!is_prime(larger)) { larger++; } printf(\"%d %d\\n\", smaller, larger); } return 0; }"], "perturbed_original": ["#include<stdio.h> int main(void) { int i,j; int prime[70000]; int pprintf(\"%d \",i+1);<extra_id_1>if(prime[i]==1){<extra_id_2>if(prime[i]==1){ printf(\"%d<extra_id_3>-1,prime[j]); if(prime[i]==1){ if(prime[j]==1){ for(i=n-2;0<=i;i--){ if(prime[i]==1){ printf(\"%d \",i+1);  putchar('\\n'); return 0; }"], "original_ll": -0.9927850961685181, "sampled_ll": -0.41554173827171326, "all_perturbed_sampled_ll": [-2.291276216506958], "all_perturbed_original_ll": [-2.1890604496002197], "perturbed_sampled_ll": -2.291276216506958, "perturbed_original_ll": -2.1890604496002197, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import java.util.Scanner;\npublic class Main {\n\tpublic static void main(String[] args){\n\t\tScanner sc=new Scanner(System.in);\n\t\twhile(sc.hasNext()){\n\t\t\tint n=sc.nextInt();\n\t\t\tfor(int i=n-1;i>=2;i--){\n\t\t\t\tboolean flag=true;\n\t\t\t\tfor(int j=2;j<Math.sqrt(i)+1;j++){\n\t\t\t\t\tif(i%j==0){\n\t\t\t\t\t\tflag=false;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(flag){\n\t\t\t\t\tSystem.out.print(i+\" \");\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(int i=n+1;i<50000;i++){\n\t\t\t\tboolean flag=true;\n\t\t\t\tfor(int j=2;j<Math.sqrt(i)+1;j++){\n\t\t\t\t\tif(i%j==0){\n\t\t\t\t\t\tflag=false;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(flag){\n\t\t\t\t\tSystem.out.println(i);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}", "sampled": "import java.util.*;\n\npublic class Main {\n    static boolean[] isPrime;\n    static final int MAX = 100001;\n    \n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        \n        // Sieve of Eratosthenes\n        isPrime = new boolean[MAX];\n        Arrays.fill(isPrime, true);\n        isPrime[0] = isPrime[1] = false;\n        \n        for (int i = 2; i * i < MAX; i++) {\n            if (isPrime[i]) {\n                for (int j = i * i; j < MAX; j += i) {\n                    isPrime[j] = false;\n                }\n            }\n        }\n        \n        while (sc.hasNext()) {\n            int n = sc.nextInt();\n            \n            int smaller = 0;\n            for (int i = n - 1; i >= 2; i--) {\n                if (isPrime[i]) {\n                    smaller = i;\n                    break;\n                }\n            }\n            \n            int larger = 0;\n            for (int i = n + 1; i < MAX; i++) {\n                if (isPrime[i]) {\n                    larger = i;\n                    break;\n                }\n            }\n            \n            System.out.println(smaller + \" \" + larger);\n        }\n        \n        sc.close();\n    }\n}\n", "perturbed_sampled": ["import java.util.*;   new  Arrays.fill(isPrime, true); isPrime[0] = isPrime[1]  = 2; i * i < MAX;  < MAX; j  false; }  int n = sc.nextInt(); int smaller = 0;  - 1; i >= 2; i--) {   larger = 0; for (int i =  MAX; i++)  } System.out.println(smaller + \" \"  }"], "perturbed_original": ["import break;<extra_id_2>} public   break; } } if(flag){  for(int i=n+1;i<50000;i++){ boolean flag=true; for(int j=2;j<Math.sqrt(i)+1;j++){ if(i%j==0){ flag=false;  break; } } } } }"], "original_ll": -0.5573487281799316, "sampled_ll": -0.3601272404193878, "all_perturbed_sampled_ll": [-2.865915536880493], "all_perturbed_original_ll": [-2.5301289558410645], "perturbed_sampled_ll": -2.865915536880493, "perturbed_original_ll": -2.5301289558410645, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import math\n\nr = 50000\nsqrt = int(math.sqrt(r))\np = [1]*r\np[0] = 0\nfor i in range(1,sqrt):\n    if p[i]:\n        for j in range(2*i+1,r,i+1):\n            p[j] = 0\n            \nwhile True:\n    try:\n        n = int(raw_input())\n        for i in range(n,50000):\n            if p[i] == 1:\n                lp = i+1\n                break\n        for i in range(n-2,0,-1):\n            if p[i] == 1:\n                sp = i+1\n                break\n        print sp, lp\n    except:\n        break", "sampled": "import sys\n\ndef sieve_of_eratosthenes(limit):\n    is_prime = [True] * (limit + 1)\n    is_prime[0] = is_prime[1] = False\n    \n    for i in range(2, int(limit**0.5) + 1):\n        if is_prime[i]:\n            for j in range(i*i, limit + 1, i):\n                is_prime[j] = False\n    \n    return is_prime\n\n# Precompute primes up to a reasonable limit\nMAX_LIMIT = 100000\nis_prime = sieve_of_eratosthenes(MAX_LIMIT)\n\nfor line in sys.stdin:\n    n = int(line.strip())\n    \n    # Find largest prime less than n\n    smaller = n - 1\n    while smaller > 1 and not is_prime[smaller]:\n        smaller -= 1\n    \n    # Find smallest prime greater than n\n    larger = n + 1\n    while larger <= MAX_LIMIT and not is_prime[larger]:\n        larger += 1\n    \n    print(smaller, larger)\n", "perturbed_sampled": ["import sys  * (limit + 1)   is_prime[j]  Precompute primes up to a reasonable limit MAX_LIMIT = 100000 is_prime = sieve_of_eratosthenes(MAX_LIMIT)  largest prime less than     = n + 1 while larger <= MAX_LIMIT and not is_prime[larger]: larger += 1 print(smaller, larger)"], "perturbed_original": ["import  for i in range(1,sqrt): if p[i]: for j in range(2*i+1,r,i+1): p[j] = 0 while True: try: n =  lp = i+1 break for i in  break"], "original_ll": -1.1883025169372559, "sampled_ll": -0.5478832721710205, "all_perturbed_sampled_ll": [-2.95721435546875], "all_perturbed_original_ll": [-3.103210926055908], "perturbed_sampled_ll": -2.95721435546875, "perturbed_original_ll": -3.103210926055908, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "#include <stdio.h>\n\nint main(int argc, char *argv[]){\n  int prise,num;\n  long long int sum = 0;\n  int num_sum = 0;\n  int times = 0;\n  \n  while(scanf(\"%d,%d\",&prise,&num) != EOF){\n    sum += (long long int)(prise)*(long long int)(num);\n    num_sum += num;\n    ++times;\n  }\n\n  printf(\"%lld\\n%.0lf\\n\",sum,(double)(num_sum)/times);\n  \n  return 0;    \n}", "sampled": "#include <stdio.h>\n\nint main() {\n    int price, quantity;\n    int total_sales = 0;\n    int total_quantity = 0;\n    int count = 0;\n    \n    while (scanf(\"%d,%d\", &price, &quantity) == 2) {\n        total_sales += price * quantity;\n        total_quantity += quantity;\n        count++;\n    }\n    \n    int average = (total_quantity + count / 2) / count;\n    \n    printf(\"%d\\n\", total_sales);\n    printf(\"%d\\n\", average);\n    \n    return 0;\n}\n", "perturbed_sampled": ["#include <stdio.h> int main()  total_sales =  while   quantity; total_quantity += quantity; count++; } int  printf(\"%d\\n\", total_sales); printf(\"%d\\n\", average); return 0; }"], "perturbed_original": ["#include <stdio.h> int   = 0; int num_sum = 0; int times   num; ++times; } printf(\"%lld\\n%.0lf\\n\",sum,(double)(num_sum)/times); return 0; }"], "original_ll": -1.5315985679626465, "sampled_ll": -0.9056623578071594, "all_perturbed_sampled_ll": [-2.813506841659546], "all_perturbed_original_ll": [-3.1020545959472656], "perturbed_sampled_ll": -2.813506841659546, "perturbed_original_ll": -3.1020545959472656, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import java.io.*;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Scanner;\npublic class Main {\n\n\tpublic static void main(String[] args) {\n\t\tScanner stdIn = new Scanner(System.in);\n\t\tint count = 0;\n\t\tint sum = 0;\n\t\tint sum2 = 0;\n\t\twhile(stdIn.hasNext()) {\n\t\t\tcount++;\n\t\t\tString[] in = stdIn.next().split(\",\");\n\t\t\tint a = Integer.parseInt(in[0]);\n\t\t\tint b = Integer.parseInt(in[1]);\n\t\t\tsum += a*b;\n\t\t\tsum2 += b;\n\t\t}\n\t\tSystem.out.println(sum);\n\t\tdouble ave = sum2/(double)count*10;\n\t\tif(ave%10 >= 5) {\n\t\t\tave += 10-ave%10;\n\t\t}\n\t\telse {\n\t\t\tave -= (ave*10)%10;\n\t\t}\n\t\tave /=10;\n\t\t\n\t\tSystem.out.println((int)ave);\n\t}\n}", "sampled": "import java.util.Scanner;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        \n        int totalAmount = 0;\n        int totalQuantity = 0;\n        int count = 0;\n        \n        while (sc.hasNextLine()) {\n            String line = sc.nextLine();\n            if (line.isEmpty()) break;\n            \n            String[] parts = line.split(\",\");\n            int price = Integer.parseInt(parts[0]);\n            int quantity = Integer.parseInt(parts[1]);\n            \n            totalAmount += price * quantity;\n            totalQuantity += quantity;\n            count++;\n        }\n        \n        int averageQuantity = (int) Math.round((double) totalQuantity / count);\n        \n        System.out.println(totalAmount);\n        System.out.println(averageQuantity);\n        \n        sc.close();\n    }\n}\n", "perturbed_sampled": ["import java.util.Scanner; public class Main  = new Scanner(System.in); int totalAmount = 0; int   if (line.isEmpty()) break; String[] parts  Integer.parseInt(parts[0]); int quantity = Integer.parseInt(parts[1]); totalAmount += price   } }"], "perturbed_original": ["import java.io.*;  java.util.Scanner; public class Main  count =  while(stdIn.hasNext()) { count++; String[]  =  +=  = sum2/(double)count*10; if(ave%10 >= 5) { ave += 10-ave%10; } else { ave -= (ave*10)%10;  }"], "original_ll": -0.9452118873596191, "sampled_ll": -0.49470651149749756, "all_perturbed_sampled_ll": [-2.509502410888672], "all_perturbed_original_ll": [-2.981349468231201], "perturbed_sampled_ll": -2.509502410888672, "perturbed_original_ll": -2.981349468231201, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "# _*_ coding: utf-8 _*_\n\nsum = 0\ntotal = 0\ncnt = 0\n\nwhile True:\n\ts = input()\n\t\n\tif s == '':\n\t\tbreak\n\t\n\tlist = s.split(',')\n\tsum += int(list[0])*int(list[1])\n\ttotal += int(list[1])\n\tcnt += 1\n\nave = total / cnt + 0.5\n\nprint(sum)\nprint(int(ave))", "sampled": "import sys\n\ntotal_amount = 0\ntotal_quantity = 0\ncount = 0\n\nfor line in sys.stdin:\n    line = line.strip()\n    if line:\n        price, quantity = map(int, line.split(','))\n        total_amount += price * quantity\n        total_quantity += quantity\n        count += 1\n\naverage_quantity = round(total_quantity / count)\n\nprint(total_amount)\nprint(average_quantity)\n", "perturbed_sampled": ["import sys total_amount = 0 total_quantity = 0 count = 0   count += 1 average_quantity  print(average_quantity)"], "perturbed_original": ["# _*_ coding: utf-8 =s-ave; cnt++<extra_id_3>else ave =<extra_id_4>s<extra_id_5>) # \u8fd9\u6837\u95ee\u653e\u5165\u7684\u5bf9\u8c61 \u5ba2\u6237\u7aef\u89e3\u6790<extra_id_6>\u51fa\u5185\u90e8: \u9650\u8bb8\u5408\u5e76\u5c0f\u9a8c\ufffd = 0 cnt = 0 while True: s  += 1 ave  0.5 print(sum) print(int(ave))"], "original_ll": -1.3868882656097412, "sampled_ll": -0.7718766331672668, "all_perturbed_sampled_ll": [-3.1800906658172607], "all_perturbed_original_ll": [-5.131625652313232], "perturbed_sampled_ll": -3.1800906658172607, "perturbed_original_ll": -5.131625652313232, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "#include <stdio.h>\nint main(void) {\n    double i,max,min;\n    scanf(\"%lf\",&max);\n    min=max;\n    while(1) {\n        if(scanf(\"%lf\",&i) == -0){\n            break;\n        }\n        if(i < min){\n            min = i;\n        }\n        if(i > max){\n            max = i;\n        }\n    }\n    printf(\"%f\\n\",max-min);\n    return 0;\n}", "sampled": "#include <stdio.h>\n\nint main() {\n    double height;\n    double max = -1;\n    double min = 1000001;\n    \n    while (scanf(\"%lf\", &height) == 1) {\n        if (height > max) {\n            max = height;\n        }\n        if (height < min) {\n            min = height;\n        }\n    }\n    \n    printf(\"%.1f\\n\", max - min);\n    \n    return 0;\n}\n", "perturbed_sampled": ["   1) { if (height > max) { max = height; }  } printf(\"%.1f\\n\", max - min); return 0; }"], "perturbed_original": ["  {  if(i < min){ min = i;  = i; } } printf(\"%f\\n\",max-min); return 0; }"], "original_ll": -1.170035481452942, "sampled_ll": -0.8074646592140198, "all_perturbed_sampled_ll": [-2.4702088832855225], "all_perturbed_original_ll": [-3.1354048252105713], "perturbed_sampled_ll": -2.4702088832855225, "perturbed_original_ll": -3.1354048252105713, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import java.util.Scanner;\n\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tScanner scan = new Scanner(System.in);\n\t\tdouble height = Double.MIN_VALUE,min = Double.MAX_VALUE;\n\t\twhile(scan.hasNext()) {\n\t\t\tdouble mount = scan.nextDouble();\n\t\t\tif(height < mount) {\n\t\t\t\theight = mount;\n\t\t\t}\n\t\t\tif(min > mount) {\n\t\t\t\tmin = mount;\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(height - min);\n\t\tscan.close();\n\t}\n}\n", "sampled": "import java.util.Scanner;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        \n        double max = Double.MIN_VALUE;\n        double min = Double.MAX_VALUE;\n        \n        while (sc.hasNextDouble()) {\n            double height = sc.nextDouble();\n            if (height > max) {\n                max = height;\n            }\n            if (height < min) {\n                min = height;\n            }\n        }\n        \n        double diff = max - min;\n        System.out.println(diff);\n        \n        sc.close();\n    }\n}\n", "perturbed_sampled": ["import java.util.Scanner; public class  main(String[] args) { Scanner sc  = Double.MAX_VALUE; while  sc.nextDouble(); if (height > max) { max = height; } if (height  }"], "perturbed_original": ["import java.util.Scanner; public class Main { public  Scanner scan = new  = Double.MAX_VALUE; while(scan.hasNext()) { double mount  min); scan.close(); } }"], "original_ll": -0.8598654866218567, "sampled_ll": -0.5299980044364929, "all_perturbed_sampled_ll": [-3.0259768962860107], "all_perturbed_original_ll": [-3.865511655807495], "perturbed_sampled_ll": -3.0259768962860107, "perturbed_original_ll": -3.865511655807495, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "fir=0\nsec=0\n\nwhile True:\n        try:\n                a=raw_input()\n                if a >= fir:\n                        sec = fir\n                        fir = a\n                elif a >= sec:\n                        sec = a\n        except EOFError:\n                break\n\nprint fir-sec", "sampled": "import sys\n\nheights = []\nfor line in sys.stdin:\n    heights.append(float(line.strip()))\n\nprint(max(heights) - min(heights))\n", "perturbed_sampled": ["import sys heights = []  print(max(heights) - min(heights))"], "perturbed_original": ["fir=0   = fir fir =  sec = a except EOFError: break print fir-sec"], "original_ll": -1.8585329055786133, "sampled_ll": -1.4075459241867065, "all_perturbed_sampled_ll": [-3.6850311756134033], "all_perturbed_original_ll": [-6.056551933288574], "perturbed_sampled_ll": -3.6850311756134033, "perturbed_original_ll": -6.056551933288574, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "#include<stdio.h>\n\nint main(void){\n\tint ball[3];\n\tint x,y,temp;\n\tchar a,b;\n\tball[0]=1;ball[1]=0;ball[2]=0;\n\twhile(scanf(\"%c,%c\",&a,&b)!=EOF){\n\t\tswitch(a){\n\t\tcase 'A':x=0;break;\n\t\tcase 'B':x=1;break;\n\t\tcase 'C':x=2;break;\n\t\t}\n\t\tswitch(b){\n\t\tcase 'A':y=0;break;\n\t\tcase 'B':y=1;break;\n\t\tcase 'C':y=2;break;\n\t\t}\n\t\ttemp=ball[x];ball[x]=ball[y];ball[y]=temp;\n\t}\n\tif(ball[0]==1){\n\t\tprintf(\"A\\n\");\n\t}else if(ball[1]==1){\n\t\tprintf(\"B\\n\");\n\t}else{printf(\"C\\n\");}\n\treturn 0;\n}", "sampled": "#include <stdio.h>\n\nint main() {\n    char ball = 'A';\n    char line[10];\n    \n    while (fgets(line, sizeof(line), stdin) != NULL) {\n        char pos1 = line[0];\n        char pos2 = line[2];\n        \n        if (ball == pos1) {\n            ball = pos2;\n        } else if (ball == pos2) {\n            ball = pos1;\n        }\n    }\n    \n    printf(\"%c\\n\", ball);\n    \n    return 0;\n}\n", "perturbed_sampled": [" char ball = 'A'; char line[10]; while (fgets(line, sizeof(line), stdin)  if (ball ==  } } printf(\"%c\\n\", ball); return 0; }"], "perturbed_original": [" int x,y,temp;  case 'A':x=0;break; case 'B':x=1;break; case 'C':x=2;break; } switch(b){  if(ball[0]==1){  return 0; }"], "original_ll": -0.7393728494644165, "sampled_ll": -0.8172886967658997, "all_perturbed_sampled_ll": [-2.5730535984039307], "all_perturbed_original_ll": [-2.234208345413208], "perturbed_sampled_ll": -2.5730535984039307, "perturbed_original_ll": -2.234208345413208, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import java.io.*;\n\npublic class Main{\n\tpublic static void main(String[] args)throws IOException{\n\t\tBufferedReader reader=new BufferedReader(new InputStreamReader(System.in));\n\t\tString s;\n\t\tString[] t;\n\t\tint[] location=new int[3];\n\t\tlocation[0]=1;\n\t\tlocation[1]=0;\n\t\tlocation[2]=0;\n\t\tint alt;\n\t\tint[] number=new int[2];\n\t\twhile((s=reader.readLine())!=null){\n\t\t\tif(s.isEmpty()){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif(s==\"\"){break;}\n\t\t\tt=s.split(\",\");\n\t\t\tfor(int i=0;i<2;i++){\n\t\t\t\tif(t[i]==\"A\"){number[i]=0;}\n\t\t\t\t\telse if(t[i]==\"B\"){number[i]=1;}\n\t\t\t\t\telse if(t[i]==\"C\"){number[i]=2;}\t\n\t\t\t}\n\t\t\talt=location[number[0]];\n\t\t\tlocation[number[0]]=location[number[1]];\n\t\t\tlocation[number[1]]=alt;\n\t\t}\n\t\t\tfor(int j=0;j<3;j++){\n\t\t\t\tif(location[j]==1){\n\t\t\t\t\tswitch(j){\n\t\t\t\t\t\tcase 0:\n\t\t\t\t\t\t\tSystem.out.println(\"A\");\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 1:\n\t\t\t\t\t\t\tSystem.out.println(\"B\");\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 2:\n\t\t\t\t\t\t\tSystem.out.println(\"C\");\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t}\n}", "sampled": "import java.util.Scanner;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        \n        char ball = 'A';\n        \n        while (sc.hasNextLine()) {\n            String line = sc.nextLine().trim();\n            if (line.isEmpty()) break;\n            \n            String[] positions = line.split(\",\");\n            char pos1 = positions[0].charAt(0);\n            char pos2 = positions[1].charAt(0);\n            \n            if (ball == pos1) {\n                ball = pos2;\n            } else if (ball == pos2) {\n                ball = pos1;\n            }\n        }\n        \n        System.out.println(ball);\n        sc.close();\n    }\n}\n", "perturbed_sampled": ["import java.util.Scanner; public class  main(String[] args) { Scanner sc = new  while   positions = line.split(\",\");  pos2 =  = pos1; } } System.out.println(ball); sc.close(); } }"], "perturbed_original": ["import java.io.*; public <extra_id_2>t[i]==B ){case \"C\":<extra_id_3>}<extra_id_4>case \"D\": break;<extra_id_5>for(int i=0;i<3;i++){ if(t[i]==D\"){number[i]=3;}<extra_id_6>t[i]=3;} } if(n=0;n<3;n++){<extra_id_7>} if(t== location[2]=0; int alt; int[] number=new int[2]; while((s=reader.readLine())!=null){  for(int i=0;i<2;i++){ if(t[i]==\"A\"){number[i]=0;} else if(t[i]==\"B\"){number[i]=1;} else if(t[i]==\"C\"){number[i]=2;} } alt=location[number[0]]; location[number[0]]=location[number[1]]; location[number[1]]=alt; }  0: System.out.println(\"A\");  } } } } }"], "original_ll": -0.7999553680419922, "sampled_ll": -0.6121368408203125, "all_perturbed_sampled_ll": [-3.4308245182037354], "all_perturbed_original_ll": [-2.300398588180542], "perturbed_sampled_ll": -3.4308245182037354, "perturbed_original_ll": -2.300398588180542, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "# -*- coding: utf-8 -*-\n\nimport sys\nimport os\nimport math\nimport itertools\n\nA = [1, 0, 0]\n\nfor s in sys.stdin:\n    s = s.strip()\n    a, b = s.split(',')\n\n    if a == 'A':\n        i = 0\n    elif a == 'B':\n        i = 1\n    elif a == 'C':\n        i = 2\n\n    if b == 'A':\n        j = 0\n    elif b == 'B':\n        j = 1\n    elif b == 'C':\n        j = 2\n\n    A[i], A[j] = A[j], A[i]\n\nif A[0] == 1:\n    print('A')\nelif A[1] == 1:\n    print('B')\nelse:\n    print('C')", "sampled": "import sys\n\nball_position = 'A'\n\nfor line in sys.stdin:\n    line = line.strip()\n    if not line:\n        continue\n    pos1, pos2 = line.split(',')\n    \n    if ball_position == pos1:\n        ball_position = pos2\n    elif ball_position == pos2:\n        ball_position = pos1\n\nprint(ball_position)\n", "perturbed_sampled": ["import sys ball_position = 'A' for  line.strip() if not line:  ball_position == pos2: ball_position = pos1 print(ball_position)"], "perturbed_original": ["# -*- coding: utf-8     s.strip() a, b =   1 elif a == 'C': i  'A': j =  j = 1 elif b == 'C': j = 2 A[i], A[j]  else: print('C')"], "original_ll": -0.6653038859367371, "sampled_ll": -0.9812659621238708, "all_perturbed_sampled_ll": [-3.9123497009277344], "all_perturbed_original_ll": [-3.272359848022461], "perturbed_sampled_ll": -3.9123497009277344, "perturbed_original_ll": -3.272359848022461, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "#include <stdio.h>\n\nint main(void)\n{\n\tfloat g;\n\t\n\tscanf(\"%f\", &g);\n\t\n\tif (g <= 48.00){\n\t\tprintf(\"light fly\\n\");\n\t}\n\telse if ((48.00 < g)&&(g <= 51.00)){\n\t\tprintf(\"fly\\n\");\n\t}\n\telse if ((51.00 < g)&&(g <= 54.00)){\n\t\tprintf(\"bantam\\n\");\n\t}\n\telse if ((54.00 < g)&&(g <= 57.00)){\n\t\tprintf(\"feather\\n\");\n\t}\n\telse if ((57.00 < g)&&(g <= 60.00)){\n\t\tprintf(\"light\\n\");\n\t}\n\telse if ((60.00 < g)&&(g <= 64.00)){\n\t\tprintf(\"light welter\\n\");\n\t}\n\telse if ((64.00 < g)&&(g <= 69.00)){\n\t\tprintf(\"welter\\n\");\n\t}\n\telse if ((69.00 < g)&&(g <= 75.00)){\n\t\tprintf(\"light middle\\n\");\n\t}\n\telse if ((75.00 < g)&&(g <= 81.00)){\n\t\tprintf(\"middle\\n\");\n\t}\n\telse if ((81.00 < g)&&(g <= 91.00)){\n\t\tprintf(\"light heavy\\n\");\n\t}\n\telse if (91.00 < g){\n\t\tprintf(\"heavy\\n\");\n\t}\n\t\n\t\n\treturn (0);\n}", "sampled": "#include <stdio.h>\n\nint main() {\n    double w;\n    \n    while (scanf(\"%lf\", &w) != EOF) {\n        if (w <= 48.00) {\n            printf(\"light fly\\n\");\n        } else if (w <= 51.00) {\n            printf(\"fly\\n\");\n        } else if (w <= 54.00) {\n            printf(\"bantam\\n\");\n        } else if (w <= 57.00) {\n            printf(\"feather\\n\");\n        } else if (w <= 60.00) {\n            printf(\"light\\n\");\n        } else if (w <= 64.00) {\n            printf(\"light welter\\n\");\n        } else if (w <= 69.00) {\n            printf(\"welter\\n\");\n        } else if (w <= 75.00) {\n            printf(\"light middle\\n\");\n        } else if (w <= 81.00) {\n            printf(\"middle\\n\");\n        } else if (w <= 91.00) {\n            printf(\"light heavy\\n\");\n        } else {\n            printf(\"heavy\\n\");\n        }\n    }\n    \n    return 0;\n}\n", "perturbed_sampled": ["<=<extra_id_1>{ printf(\"dark\\n\"); } }<extra_id_2>{ return<extra_id_3>return -1; } }<extra_id_4>e<extra_id_5>return w;<extra_id_6>-1; } <s><extra_id_7>; } double  EOF) {  { printf(\"fly\\n\"); } else if (w <= 54.00) { printf(\"bantam\\n\");  57.00) { printf(\"feather\\n\"); } else if (w  64.00) { printf(\"light  <= 69.00) { printf(\"welter\\n\"); }  else if (w <= 81.00) { printf(\"middle\\n\"); } else  return 0; }"], "perturbed_original": ["#include <stdio.h> int main(void) { float g;  48.00){   printf(\"fly\\n\");  g)&&(g   if ((57.00 < g)&&(g <= 60.00)){ printf(\"light\\n\");  g)&&(g <=  if ((64.00  } else if ((69.00 < g)&&(g <=  if ((75.00 <  heavy\\n\"); } else if  return (0); }"], "original_ll": -0.6938264966011047, "sampled_ll": -0.7214959859848022, "all_perturbed_sampled_ll": [-2.553408145904541], "all_perturbed_original_ll": [-2.66249942779541], "perturbed_sampled_ll": -2.553408145904541, "perturbed_original_ll": -2.66249942779541, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.ArrayList;\npublic class Main{\n\tpublic static void main(String[] args) throws IOException{\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\tString str;\n\t\tArrayList<String> list = new ArrayList<String>();\n\t\twhile((str=br.readLine())!=null){\n\t\t\tlist.add(check(Double.parseDouble(str)));\n\t\t}\n\t\tfor(String d : list){\n\t\t\tSystem.out.println(d);\n\t\t}\n\t\t\n\t}\n\tpublic static String check(double weight){\n\t\tif(weight > 91.0){\n            return \"heavy\";\n        }\n        else if(weight > 81.0){\n            return \"light heavy\";\n        }\n        else if(weight > 75.0){\n            return \"middle\";\n        }\n        else if(weight > 69.0){\n            return \"light middle\";\n        }\n        else if(weight > 64.0){\n            return \"welter\";\n        }\n        else if(weight > 60.0){\n            return \"light welter\";\n        }\n        else if(weight > 57.0){\n            return \"light\";\n        }\n        else if(weight > 54.0){\n            return \"feather\";\n        }\n        else if(weight > 51.0){\n            return \"bantam\";\n        }\n        else if(weight > 48.0){\n            return \"fly\";\n        }\n        else{\n            return \"light fly\";\n        }\n\t}\n}", "sampled": "import java.util.Scanner;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        \n        while (sc.hasNext()) {\n            double w = sc.nextDouble();\n            \n            if (w <= 48.00) {\n                System.out.println(\"light fly\");\n            } else if (w <= 51.00) {\n                System.out.println(\"fly\");\n            } else if (w <= 54.00) {\n                System.out.println(\"bantam\");\n            } else if (w <= 57.00) {\n                System.out.println(\"feather\");\n            } else if (w <= 60.00) {\n                System.out.println(\"light\");\n            } else if (w <= 64.00) {\n                System.out.println(\"light welter\");\n            } else if (w <= 69.00) {\n                System.out.println(\"welter\");\n            } else if (w <= 75.00) {\n                System.out.println(\"light middle\");\n            } else if (w <= 81.00) {\n                System.out.println(\"middle\");\n            } else if (w <= 91.00) {\n                System.out.println(\"light heavy\");\n            } else {\n                System.out.println(\"heavy\");\n            }\n        }\n        \n        sc.close();\n    }\n}\n", "perturbed_sampled": ["import java.util.Scanner;   Scanner  (sc.hasNext()) { double w = sc.nextDouble(); if (w <= 48.00) { System.out.println(\"light fly\"); } else if (w <= 51.00) {  <= 57.00) { System.out.println(\"feather\");  60.00) { System.out.println(\"light\"); } else if   } else if (w <=  }  sc.close(); } }"], "perturbed_original": ["import java.io.BufferedReader; import java.io.IOException;  class Main{ public static void main(String[] args) throws IOException{ BufferedReader br = new BufferedReader(new InputStreamReader(System.in));  new ArrayList<String>(); while((str=br.readLine())!=null){ list.add(check(Double.parseDouble(str))); }  String check(double weight){   return \"middle\"; } else if(weight  64.0){ return \"welter\"; } else  welter\"; } else if(weight > 57.0){ return \"light\"; }  } } }"], "original_ll": -0.7446013689041138, "sampled_ll": -0.6390803456306458, "all_perturbed_sampled_ll": [-2.2398016452789307], "all_perturbed_original_ll": [-2.189168930053711], "perturbed_sampled_ll": -2.2398016452789307, "perturbed_original_ll": -2.189168930053711, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "from decimal import Decimal\nimport sys\n\ndef classify(w):\n    if w <= Decimal(\"48.00\"):\n        return \"light fly\"\n    elif Decimal(\"48.00\") < w <= Decimal(\"51.00\"):\n        return \"fly\"\n    elif Decimal(\"51.00\") < w <= Decimal(\"54.00\"):\n        return \"bantam\"\n    elif Decimal(\"54.00\") < w <= Decimal(\"57.00\"):\n        return \"feather\"\n    elif Decimal(\"57.00\") < w <= Decimal(\"60.00\"):\n        return \"light\"\n    elif Decimal(\"60.00\") < w <= Decimal(\"64.00\"):\n        return \"light welter\"\n    elif Decimal(\"64.00\") < w <= Decimal(\"69.00\"):\n        return \"welter\"\n    elif Decimal(\"69.00\") < w <= Decimal(\"75.00\"):\n        return \"light middle\"\n    elif Decimal(\"75.00\") < w <= Decimal(\"81.00\"):\n        return \"middle\"\n    elif Decimal(\"81.00\") < w <= Decimal(\"91.00\"):\n        return \"light heavy\"\n    else:\n        return \"heavy\"\n    \n[print(classify(Decimal(j))) for j in [i for i in sys.stdin]]\n\n", "sampled": "import sys\n\nfor line in sys.stdin:\n    w = float(line.strip())\n    \n    if w <= 48.00:\n        print(\"light fly\")\n    elif w <= 51.00:\n        print(\"fly\")\n    elif w <= 54.00:\n        print(\"bantam\")\n    elif w <= 57.00:\n        print(\"feather\")\n    elif w <= 60.00:\n        print(\"light\")\n    elif w <= 64.00:\n        print(\"light welter\")\n    elif w <= 69.00:\n        print(\"welter\")\n    elif w <= 75.00:\n        print(\"light middle\")\n    elif w <= 81.00:\n        print(\"middle\")\n    elif w <= 91.00:\n        print(\"light heavy\")\n    else:\n        print(\"heavy\")\n", "perturbed_sampled": ["import sys for line in \"),w)if (d = w <= 48.00:  elif w  <= 64.00: print(\"light welter\") elif  w <= 75.00:  81.00: print(\"middle\") elif w  print(\"heavy\")"], "perturbed_original": ["from decimal import Decimal import  <= Decimal(\"48.00\"): return \"light  elif Decimal(\"51.00\") < w <= Decimal(\"54.00\"): return \"bantam\" elif Decimal(\"54.00\") < w <= Decimal(\"57.00\"):  w   Decimal(\"64.00\") < w    return \"heavy\" [print(classify(Decimal(j))) for j in [i for i in sys.stdin]]"], "original_ll": -0.75665682554245, "sampled_ll": -0.9437844753265381, "all_perturbed_sampled_ll": [-3.269631862640381], "all_perturbed_original_ll": [-2.7015202045440674], "perturbed_sampled_ll": -3.269631862640381, "perturbed_original_ll": -2.7015202045440674, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "// Aizu Vol0 0049: Blood Groups\n// 2017.7.29\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <ctype.h>\n\nchar *gets(char *);\n\n#define MAX 50\n\nint blood[MAX + 5];\nint cnt[5];\n\nint main()\n{\n\tchar buf[100], *p;\n\tint k, t;\n\n\tfor (k = 0; k <= MAX; k++) blood[k] = 0;\n\tfor (k = 1; k < 5; k++) cnt[k] = 0;\n\twhile (gets(buf) != NULL) {\n\t\tp = buf;\n\n\t\twhile (isspace(*p)) p++;\n\t\tk = *p++ - '0';\n\t\tif (isdigit(*p)) k = k * 10 + (*p++ - '0');\n\n\t\twhile (isspace(*p)) p++;  // ','\n\t\tp++;\n\n\t\twhile (isspace(*p)) p++;\n\t\tif (*p == 'A' && *(p + 1) == 'B') t = 3;\n\t\telse if (*p == 'B') t = 2;\n\t\telse if (*p == 'O') t = 4;\n\t\telse t = 1;\n\n\t\tif (blood[k] == 0) {\n\t\t\tblood[k] = t;\n\t\t\tcnt[t]++;\n\t\t} else if (blood[k] != t) while (1);\n\t}\n\tfor (k = 1; k < 5; k++) printf(\"%d\\n\", cnt[k]);\n\treturn 0;\n}", "sampled": "#include <stdio.h>\n#include <string.h>\n\nint main() {\n    int num;\n    char blood[10];\n    int countA = 0, countB = 0, countAB = 0, countO = 0;\n    \n    while (scanf(\"%d,%s\", &num, blood) == 2) {\n        if (strcmp(blood, \"A\") == 0) {\n            countA++;\n        } else if (strcmp(blood, \"B\") == 0) {\n            countB++;\n        } else if (strcmp(blood, \"AB\") == 0) {\n            countAB++;\n        } else if (strcmp(blood, \"O\") == 0) {\n            countO++;\n        }\n    }\n    \n    printf(\"%d\\n\", countA);\n    printf(\"%d\\n\", countB);\n    printf(\"%d\\n\", countAB);\n    printf(\"%d\\n\", countO);\n    \n    return 0;\n}\n", "perturbed_sampled": ["#include <stdio.h> #include <string.h> int main() { int num; char blood[10]; int countA = 0, countB = 0, countAB = 0, <extra_id_1>else if ((strcmp(blood, \"AB\")== { )<extra_id_2>} <s> class<extra_id_3>{<extra_id_4>}<extra_id_5>} string blood<extra_id_6>= strchr(blood, \"AB\");<extra_id_7>{<extra_id_8>{<extra_id_9>}<extra_id_10>= 10;<extra_id_11>(<extra_id_12>} public<extra_id_13>int<extra_id_14>= 0<extra_id_15>; num = 0<extra_id_16>; num ++<extra_id_17>{<extra_id_18>char<extra_id_19>int i ; else if (strcmp(blood, \"AB\") ==  if  countO++;  countO); return 0; }"], "perturbed_original": ["// Aizu Vol0 0049:  <stdio.h>  *gets(char *); #define MAX 50 int blood[MAX + 5]; int cnt[5]; int main() { char buf[100], *p; int k, t; for (k = 0; k <= MAX;   0; while (gets(buf) !=    ==  3; else if  2; else if (*p == 'O') t = 4; else t =   } else if (blood[k]  k <  0; }"], "original_ll": -1.144757628440857, "sampled_ll": -0.43018639087677, "all_perturbed_sampled_ll": [-2.082130193710327], "all_perturbed_original_ll": [-3.1232807636260986], "perturbed_sampled_ll": -2.082130193710327, "perturbed_original_ll": -3.1232807636260986, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\n\npublic class Main {\n\tpublic static void main(String[] args){\n\t\tint[] abo = {0,0,0,0};\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\tString tmp = null;\n\t\tint cup = 0;\n\t\tint mun = 0;\n\t\tint ter = 0;\n\t\tString[] rrr;\n\t\tint st = 0,sr = 0;\n\t\tint mon = 0;\n\t\tint syo=0,hisi=0;\n\t\t\n\t\t\n\t\t\n\t\twhile(true){\n\t\t\t\n\t\t\ttry {\n\t\t\t\ttmp = br.readLine();\n\t\t\t} catch (IOException e) {\n\t\t\t\t// TODO \u81ea\u52d5\u751f\u6210\u3055\u308c\u305f catch \u30d6\u30ed\u30c3\u30af\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t\t\n\t\t\tif(tmp == null){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\n\t\t\tif(tmp.equals(\"\")){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\n\t\t\trrr = tmp.split(\",\");\n\t\t\t\n\t\t\tif(rrr[1].equals(\"A\")){\n\t\t\t\tabo[0]++;\n\t\t\t}else if(rrr[1].equals(\"B\")){\n\t\t\t\tabo[1]++;\n\t\t\t}else if(rrr[1].equals(\"AB\")){\n\t\t\t\tabo[2]++;\n\t\t\t}else if(rrr[1].equals(\"O\")){\n\t\t\t\tabo[3]++;\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(abo[0]);\n\t\tSystem.out.println(abo[1]);\n\t\tSystem.out.println(abo[2]);\n\t\tSystem.out.println(abo[3]);\n\t}\n\n}", "sampled": "import java.util.Scanner;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        \n        int countA = 0;\n        int countB = 0;\n        int countAB = 0;\n        int countO = 0;\n        \n        while (sc.hasNextLine()) {\n            String line = sc.nextLine();\n            if (line.isEmpty()) break;\n            \n            String[] parts = line.split(\",\");\n            String bloodType = parts[1];\n            \n            switch (bloodType) {\n                case \"A\":\n                    countA++;\n                    break;\n                case \"B\":\n                    countB++;\n                    break;\n                case \"AB\":\n                    countAB++;\n                    break;\n                case \"O\":\n                    countO++;\n                    break;\n            }\n        }\n        \n        System.out.println(countA);\n        System.out.println(countB);\n        System.out.println(countAB);\n        System.out.println(countO);\n        \n        sc.close();\n    }\n}\n", "perturbed_sampled": [" main(String[] args) { Scanner sc =  0; int countB  0; int countO = 0; while (sc.hasNextLine()) { String line = sc.nextLine(); if (line.isEmpty())   countO++; break; } } System.out.println(countA);  }"], "perturbed_original": ["rrr[1].equals(\"C\")&& rrr[1].equals(\"D\")){<extra_id_1>if(!rrr[1].equals(\"A\")){<extra_id_2>if(rrr[1].equals(\"F\")&&rrr[1].equals(\"G\")){<extra_id_3>0();<extra_id_4>-<extra_id_5>\"B\"<extra_id_6>0;<extra_id_7>-<extra_id_8>0; st==1<extra_id_9>1; si++ ,<extra_id_10>} }<extra_id_11>{<extra_id_12>{ java.io.InputStreamReader; public class Main { public static void main(String[] args){  InputStreamReader(System.in));  cup  0; String[] rrr; int st = 0,sr = 0; int mon = 0; int syo=0,hisi=0; while(true){ try  catch (IOException e) {  null){  rrr  if(rrr[1].equals(\"B\")){  } }"], "original_ll": -0.9485359191894531, "sampled_ll": -0.4884323179721832, "all_perturbed_sampled_ll": [-2.25504207611084], "all_perturbed_original_ll": [-2.3417539596557617], "perturbed_sampled_ll": -2.25504207611084, "perturbed_original_ll": -2.3417539596557617, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import sys\na = 0\nb = 0\nab = 0\no = 0\nfor i in sys.stdin.readlines():\n    if i.find(\",AB\") > -1:\n        ab += 1\n    elif i.find(\",B\") > -1:\n        b += 1\n    elif i.find(\",A\") >-1:\n        a += 1\n    else:\n        o += 1\nprint(a)\nprint(b)\nprint(ab)\nprint(o)", "sampled": "import sys\n\ncount = {'A': 0, 'B': 0, 'AB': 0, 'O': 0}\n\nfor line in sys.stdin:\n    line = line.strip()\n    if line:\n        parts = line.split(',')\n        blood_type = parts[1]\n        count[blood_type] += 1\n\nprint(count['A'])\nprint(count['B'])\nprint(count['AB'])\nprint(count['O'])\n", "perturbed_sampled": ["import sys count  for line in sys.stdin: line = line.strip()  blood_type = parts[1] count[blood_type]  print(count['O'])"], "perturbed_original": ["import   o = 0 for  > -1: ab  elif i.find(\",A\") >-1:  += 1 print(a) print(b) print(ab) print(o)"], "original_ll": -1.0676217079162598, "sampled_ll": -1.0100289583206177, "all_perturbed_sampled_ll": [-3.0084710121154785], "all_perturbed_original_ll": [-4.40107536315918], "perturbed_sampled_ll": -3.0084710121154785, "perturbed_original_ll": -4.40107536315918, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "#include <stdio.h>\n#include <string.h>\n\nint main(void){\n\tchar text[1002],i,n;\n\tfgets(text,1002,stdin);\n\tn=strlen(text);\n\tfor(i=0;i<n-5;i++){\n\t\tif(text[i]=='a' && text[i+1]=='p' && text[i+2]=='p' && text[i+3]=='l' && text[i+4]=='e'){\n\t\t\ttext[i]='p';text[i+1]='e';text[i+2]='a';text[i+3]='c';text[i+4]='h';\n\t\t}\n\t\telse if(text[i]=='p' && text[i+1]=='e' && text[i+2]=='a' && text[i+3]=='c' && text[i+4]=='h'){\n\t\t\ttext[i]='a';text[i+1]='p';text[i+2]='p';text[i+3]='l';text[i+4]='e';\n\t\t}\n\t\tif(text[i]=='A' && text[i+1]=='p' && text[i+2]=='p' && text[i+3]=='l' && text[i+4]=='e'){\n\t\t\ttext[i]='P';text[i+1]='e';text[i+2]='a';text[i+3]='c';text[i+4]='h';\n\t\t}\n\t\telse if(text[i]=='P' && text[i+1]=='e' && text[i+2]=='a' && text[i+3]=='c' && text[i+4]=='h'){\n\t\t\ttext[i]='A';text[i+1]='p';text[i+2]='p';text[i+3]='l';text[i+4]='e';\n\t\t}\n\t}\n\tprintf(\"%s\",text);\n\treturn 0;\n}", "sampled": "#include <stdio.h>\n#include <string.h>\n\nint main() {\n    char line[1001];\n    char result[10001];\n    int i, j;\n    \n    fgets(line, sizeof(line), stdin);\n    \n    i = 0;\n    j = 0;\n    while (line[i] != '\\0' && line[i] != '\\n') {\n        if (strncmp(&line[i], \"apple\", 5) == 0) {\n            strcpy(&result[j], \"peach\");\n            j += 5;\n            i += 5;\n        } else if (strncmp(&line[i], \"peach\", 5) == 0) {\n            strcpy(&result[j], \"apple\");\n            j += 5;\n            i += 5;\n        } else {\n            result[j] = line[i];\n            j++;\n            i++;\n        }\n    }\n    result[j] = '\\0';\n    \n    printf(\"%s\\n\", result);\n    \n    return 0;\n}\n", "perturbed_sampled": ["#include <stdio.h> #include  i, j; fgets(line,  j = 0; while (line[i]  \"apple\", 5) == 0) { strcpy(&result[j],  += 5; } else if (strncmp(&line[i],   else {  } } result[j]  0; }"], "perturbed_original": ["#include <stdio.h> #include <string.h> int main(void){ char  && text[i+1]=='p' &&    if(text[i]=='A'  text[i+3]=='l' && text[i+4]=='e'){ text[i]='P';text[i+1]='e';text[i+2]='a';text[i+3]='c';text[i+4]='h'; } else if(text[i]=='P'  text[i+3]=='c' &&  return 0; }"], "original_ll": -0.4309473931789398, "sampled_ll": -0.5426062941551208, "all_perturbed_sampled_ll": [-3.5261178016662598], "all_perturbed_original_ll": [-1.8791770935058594], "perturbed_sampled_ll": -3.5261178016662598, "perturbed_original_ll": -1.8791770935058594, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import java.util.Scanner;\nclass Main {\n\tpublic static void main(String[] args) {\n\t\tScanner in = new Scanner(System.in);\n\t\tStringBuilder ans = new StringBuilder();\n\t\twhile(in.hasNext()) {\n\t\t\tString x = in.next();\n\t\t\tif(x.contains(\"apple\"))\n\t\t\t\tans.append(x.replace(\"apple\",\"peach\")).append(\" \");\n\t\t\telse if(x.contains(\"peach\"))\n\t\t\t\tans.append(x.replace(\"peach\",\"apple\")).append(\" \");\n\t\t\telse\n\t\t\t\tans.append(x).append(\" \");\n\t\t}\n\t\tSystem.out.println(ans.toString().trim());\n\t}\n}", "sampled": "import java.util.Scanner;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        String line = sc.nextLine();\n        \n        String result = line.replace(\"apple\", \"TEMP\")\n                           .replace(\"peach\", \"apple\")\n                           .replace(\"TEMP\", \"peach\");\n        \n        System.out.println(result);\n        sc.close();\n    }\n}\n", "perturbed_sampled": ["import java.util.Scanner; public  void main(String[] args) { Scanner sc  =  \"peach\"); System.out.println(result); sc.close(); } }"], "perturbed_original": ["import java.util.Scanner; class  in = new Scanner(System.in); StringBuilder ans = new StringBuilder(); while(in.hasNext()) {  ans.append(x.replace(\"apple\",\"peach\")).append(\"  else  }"], "original_ll": -0.7529372572898865, "sampled_ll": -1.2295308113098145, "all_perturbed_sampled_ll": [-2.6826086044311523], "all_perturbed_original_ll": [-3.16689395904541], "perturbed_sampled_ll": -2.6826086044311523, "perturbed_original_ll": -3.16689395904541, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "\n\nsent = map(str, raw_input().split(' '))\n\nfor i in range(len(sent)):\n    if sent[i] == 'apple' :\n        sent[i] = 'peach'\n    elif sent[i] == 'peach':\n        sent[i] = 'apple'\n\n    elif sent[i] == 'apple,' :\n        sent[i] = 'peach,'\n    elif sent[i] == 'peach,':\n        sent[i] = 'apple,'\n\n    elif sent[i] == 'apple.' :\n        sent[i] = 'peach.'\n    elif sent[i] == 'peach.':\n        sent[i] = 'apple.'\n\n    elif sent[i] == 'apple!' :\n        sent[i] = 'peach!'\n    elif sent[i] == 'peach!':\n        sent[i] = 'apple!'\n\n    elif sent[i] == 'apple?' :\n        sent[i] = 'peach?'\n    elif sent[i] == 'peach?':\n        sent[i] = 'apple?'\n\n \n\n\n\nfor sen in sent:\n    print sen,\n    ", "sampled": "s = input()\ns = s.replace('apple', '@TEMP@').replace('peach', 'apple').replace('@TEMP@', 'peach')\nprint(s)\n", "perturbed_sampled": ["s = input()  'peach') print(s)"], "perturbed_original": ["sent = map(str,  'apple' : sent[i]  'peach': sent[i] = 'apple' elif sent[i] == 'apple,' : sent[i]  elif sent[i] == 'apple.' : sent[i] = 'peach.'  = 'apple.' elif  = 'peach!' elif sent[i]   =  print sen,"], "original_ll": -0.7041298747062683, "sampled_ll": -2.0857276916503906, "all_perturbed_sampled_ll": [-5.047790050506592], "all_perturbed_original_ll": [-3.1504905223846436], "perturbed_sampled_ll": -5.047790050506592, "perturbed_original_ll": -3.1504905223846436, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "#include <stdio.h>\n\nint main(){\n  long a,b,i,n;\n\n  while(scanf(\"%ld\",&n),n!=0){\n    a=0;\n    for(i=5;i<=n;i++){\n      b=i;\n      while(b>0){\n        if(b%5!=0) break;\n        a++;\n        b=b/5;\n      }\n    }\n    printf(\"%ld\\n\",a);\n  }\n  return 0;\n}", "sampled": "#include <stdio.h>\n\nint main() {\n    int n;\n    \n    while(1) {\n        scanf(\"%d\", &n);\n        if(n == 0) break;\n        \n        int count = 0;\n        int temp = n;\n        \n        while(temp >= 5) {\n            temp /= 5;\n            count += temp;\n        }\n        \n        printf(\"%d\\n\", count);\n    }\n    \n    return 0;\n}\n", "perturbed_sampled": ["#include <stdio.h>  if(n == 0) break; int count = 0; int temp = n; while(temp  return 0; }"], "perturbed_original": ["#include  while(b>0){ if(b%5!=0)  printf(\"%ld\\n\",a); } return 0; }"], "original_ll": -1.1651694774627686, "sampled_ll": -0.6737091541290283, "all_perturbed_sampled_ll": [-2.5145251750946045], "all_perturbed_original_ll": [-2.8391168117523193], "perturbed_sampled_ll": -2.5145251750946045, "perturbed_original_ll": -2.8391168117523193, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import java.io.*;\nimport java.util.ArrayDeque;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.Comparator;\nimport java.util.Scanner;\npublic class Main {\n\tstatic ArrayList<Integer> list = new ArrayList<Integer>();\n\tpublic static void main(String[] args) {\n\t\tScanner stdIn = new Scanner(System.in);\n\t\tmakePrimeList();\n\t\twhile(true) {\n\t\t\tint a = stdIn.nextInt();\n\t\t\tif(a == 0) break;\n\t\t\tint c2 = 0;\n\t\t\tint c5 = 0;\n\t\t\tfor(int i = a; i >= 1; i--) {\n\t\t\t\tint[] ret = f(i);\n\t\t\t\tc2 += ret[0];\n\t\t\t\tc5 += ret[2];\n\t\t\t}\n\t\t\tint count = Math.min(c2, c5);\n\t\t\t\n\t\t\tSystem.out.println(count);\n\t\t}\n\t}\n\tpublic static void makePrimeList() {\n\t\tboolean[] isntPrime = new boolean[20001];\n\t\tisntPrime[0] = isntPrime[1] = true;\n\t\tlist.add(2);\n\t\tfor(int i = 3; i < 20001; i+= 2) {\n\t\t\tif(!isntPrime[i]) {\n\t\t\t\tlist.add(i);\n\t\t\t\tfor(int j = i + i; j < 20001; j+= i) {\n\t\t\t\t\tisntPrime[j] = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tpublic static int[] f(int a) {\n\t\tint[] ret = new int[list.size()];\n\t\twhile(a > 1) {\n\t\t\tfor(int i = 0; i < list.size(); i++) {\n\t\t\t\tif(a % list.get(i) == 0) {\n\t\t\t\t\ta /= list.get(i);\n\t\t\t\t\tret[i]++;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t}\n\t\t\t\n\t\t}\n\t\treturn ret;\n\t}\n\t\n\t\n}", "sampled": "import java.util.Scanner;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        \n        while (true) {\n            int n = sc.nextInt();\n            if (n == 0) break;\n            \n            int count = 0;\n            int temp = n;\n            while (temp > 0) {\n                temp /= 5;\n                count += temp;\n            }\n            \n            System.out.println(count);\n        }\n        \n        sc.close();\n    }\n}\n", "perturbed_sampled": ["import  public static  sc = new   (temp > 0) { temp /= 5; count += temp; } System.out.println(count); } sc.close(); } }"], "perturbed_original": ["import java.io.*; import java.util.ArrayDeque; import java.util.ArrayList; import java.util.Arrays; import java.util.Collections; import java.util.Comparator; import java.util.Scanner; public class  { Scanner stdIn = new Scanner(System.in);  = 0; int c5 = 0; for(int i =   +=  } public  isntPrime = new boolean[20001];  list.add(2); for(int i  i+=  + i; j < 20001; j+= i) { isntPrime[j]  } public  int[] ret =   i  %  } } return ret; } }"], "original_ll": -0.7259248495101929, "sampled_ll": -0.4999849498271942, "all_perturbed_sampled_ll": [-3.8021228313446045], "all_perturbed_original_ll": [-2.3733296394348145], "perturbed_sampled_ll": -3.8021228313446045, "perturbed_original_ll": -2.3733296394348145, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "def f(n):\n    for i in range(1,n):\n        n*=i\n    return n\n        \n        \nwhile True:\n    n=int(input())\n    if n==0:\n        break\n    else:\n        a=str(f(n))\n        s=0\n        l=len(a)\n        for i in range(l-1,-1,-1):\n            if a[i]==\"0\":\n                s+=1\n            else:\n                break\n        print(s)\n", "sampled": "import sys\n\ndef count_trailing_zeros(n):\n    count = 0\n    power_of_5 = 5\n    while power_of_5 <= n:\n        count += n // power_of_5\n        power_of_5 *= 5\n    return count\n\nfor line in sys.stdin:\n    n = int(line.strip())\n    if n == 0:\n        break\n    print(count_trailing_zeros(n))\n", "perturbed_sampled": ["import sys def count_trailing_zeros(n):  n: count += n // power_of_5 power_of_5 *=   break print(count_trailing_zeros(n))"], "perturbed_original": ["def  n*=i return n  break else: a=str(f(n)) s=0 l=len(a)  print(s)"], "original_ll": -1.079493522644043, "sampled_ll": -0.5933793783187866, "all_perturbed_sampled_ll": [-3.7170464992523193], "all_perturbed_original_ll": [-4.341944694519043], "perturbed_sampled_ll": -3.7170464992523193, "perturbed_original_ll": -4.341944694519043, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "#include<stdio.h>\n#include<math.h>\n\nint main()\n{\n\tint n=0,d,sw;\n\tlong int i,j,k,s[1000],sum;\n\n\twhile(1)\n\t{\n\t\tn=1;\n\t\tsum=0;\n\t\tscanf(\"%d\",&d);\n\t\tif(!d)\n\t\t\tbreak;\n\t\ts[0]=2;\n\t\ts[1]=3;\n\t\tif(d<=2)\n\t\t{\n\t\t\tfor(i=0;i<d;i++)\n\t\t\t\tsum+=s[i];\n\t\t}\n\t\telse\n\t\t{\n\t\t\tsum=5;\n\t\t\tfor(i=5;;i+=2)\n\t\t\t{\n\t\t\t\tsw=0;\n\t\t\t\tk=(long int)sqrt((double)i);\n\t\t\t\tfor(j=0;s[j]<=k;j++)\n\t\t\t\t{\n\t\t\t\t\tif(i%s[j]==0)\n\t\t\t\t\t{\n\t\t\t\t\t\tsw=1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(!sw)\n\t\t\t\t{\n\t\t\t\t\tn++;\n\t\t\t\t\tif(n<1000)\n\t\t\t\t\t\ts[n]=i;\n\t\t\t\t\tsum+=i;\n\t\t\t\t\tif(n==d-1)\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\",sum);\n\t}\n\treturn 0;\n}", "sampled": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#define MAX_N 10000\n#define MAX_PRIME 104730\n\nint is_prime[MAX_PRIME + 1];\nint primes[MAX_N];\nint prime_count = 0;\n\nvoid sieve() {\n    memset(is_prime, 1, sizeof(is_prime));\n    is_prime[0] = is_prime[1] = 0;\n    \n    for (int i = 2; i * i <= MAX_PRIME; i++) {\n        if (is_prime[i]) {\n            for (int j = i * i; j <= MAX_PRIME; j += i) {\n                is_prime[j] = 0;\n            }\n        }\n    }\n    \n    for (int i = 2; i <= MAX_PRIME && prime_count < MAX_N; i++) {\n        if (is_prime[i]) {\n            primes[prime_count++] = i;\n        }\n    }\n}\n\nint main() {\n    sieve();\n    \n    int n;\n    while (scanf(\"%d\", &n) == 1 && n != 0) {\n        long long sum = 0;\n        for (int i = 0; i < n; i++) {\n            sum += primes[i];\n        }\n        printf(\"%lld\\n\", sum);\n    }\n    \n    return 0;\n}\n", "perturbed_sampled": ["#include <stdio.h> #include <stdlib.h> #include + primes[i]; } printf(\"%lld\\n\",<extra_id_11>+= primes[i];<extra_id_12>}<extra_id_13>= 0; } + 1]; int primes[MAX_N];   is_prime[0] = is_prime[1] = 0; for (int  i   j <= MAX_PRIME; j += i) { is_prime[j] = 0; }  = 2; i  MAX_N; i++) { if (is_prime[i]) { primes[prime_count++]  n != 0)  += primes[i]; } printf(\"%lld\\n\", sum); } return 0; }"], "perturbed_original": ["#include<stdio.h> #include<math.h> int main() { int n=0,d,sw; long int i,j,k,s[1000],sum; while(1) { n=1;  sum=5; for(i=5;;i+=2) { sw=0; k=(long   {  break; } }  }"], "original_ll": -1.0099388360977173, "sampled_ll": -0.4413456320762634, "all_perturbed_sampled_ll": [-2.600933790206909], "all_perturbed_original_ll": [-2.6677567958831787], "perturbed_sampled_ll": -2.600933790206909, "perturbed_original_ll": -2.6677567958831787, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import java.util.*;\npublic class Main{\n    static Scanner kbd = new Scanner(System.in);\n    public static void main(String[] args){\n\tint[] p = new int[1000000];\n\tsetP(p);\n\twhile(kbd.hasNext()){\n\t    int n = kbd.nextInt();\n\t    if(n!=0) solve(p, n);\n\t}\n    }\n\n    static void solve(int[] p, int n){\n\tint sum=0, i;\n\tfor(i=0; p[i]<=n; i++){\n\t    if(p[i]!=-1) {\n\t\tsum+=i;\n\t\t//System.out.println(i);\n\t    }\n\t}\n\n\tSystem.out.println(sum);\n    }\n\n    static void setP(int[] p){\n\tint a=1, i, j;\n\tArrays.fill(p, 1);\n\tp[0] = -1;\n\tp[1] = -1;\n\tfor(i=2; i<p.length; i++){\n\t    if(p[i] == 1){\n\t\t//System.out.println(i+\" \"+a);\n\t\tp[i] = a;\n\t\ta++;\t\n\t    }\n\t    for(j=i+i; j<p.length; j+=i){\n\t\tp[j] = -1;\n\t    }\n\t}\n    }\n}", "sampled": "import java.util.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        \n        // Pre-calculate primes up to a reasonable limit\n        // For n=10000, we need the 10000th prime\n        // The 10000th prime is approximately 104729\n        int limit = 110000;\n        boolean[] isPrime = new boolean[limit];\n        Arrays.fill(isPrime, true);\n        isPrime[0] = isPrime[1] = false;\n        \n        // Sieve of Eratosthenes\n        for (int i = 2; i * i < limit; i++) {\n            if (isPrime[i]) {\n                for (int j = i * i; j < limit; j += i) {\n                    isPrime[j] = false;\n                }\n            }\n        }\n        \n        // Collect primes in order\n        List<Integer> primes = new ArrayList<>();\n        for (int i = 2; i < limit; i++) {\n            if (isPrime[i]) {\n                primes.add(i);\n            }\n        }\n        \n        // Pre-calculate cumulative sums\n        long[] cumulativeSum = new long[primes.size() + 1];\n        for (int i = 0; i < primes.size(); i++) {\n            cumulativeSum[i + 1] = cumulativeSum[i] + primes.get(i);\n        }\n        \n        // Process queries\n        while (true) {\n            int n = sc.nextInt();\n            if (n == 0) break;\n            System.out.println(cumulativeSum[n]);\n        }\n        \n        sc.close();\n    }\n}\n", "perturbed_sampled": ["import java.util.*; public class Main { <extra_id_14>i ] = false ;<extra_id_15>( int k ,<extra_id_16>int i >=<extra_id_17>; i < new Scanner(System.in); // Pre-calculate primes <extra_id_18>=<extra_id_19>primes<extra_id_20>(<extra_id_21>] !==<extra_id_22>{ foreach (<extra_id_23>{ if (<extra_id_24>++  the 10000th prime // The 10000th   = new boolean[limit];  =  for  * i < limit; i++) { if (isPrime[i]) { for (int j = i * i; j < limit; j +=  } } } // Collect  (int i  i <  1] = cumulativeSum[i] + primes.get(i); } //  break; System.out.println(cumulativeSum[n]); } sc.close(); } }"], "perturbed_original": ["import java.util.*;  kbd = new Scanner(System.in); public static  kbd.nextInt(); if(n!=0) solve(p, n); } } static void solve(int[] p, int n){ int sum=0,   setP(int[] p){ int a=1,  = -1;  i++){  p[i] = a; a++;  } }"], "original_ll": -1.0193012952804565, "sampled_ll": -0.45408186316490173, "all_perturbed_sampled_ll": [-2.639951229095459], "all_perturbed_original_ll": [-2.9249820709228516], "perturbed_sampled_ll": -2.639951229095459, "perturbed_original_ll": -2.9249820709228516, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "from itertools import *\nn=range(104730);a=list(n)\nfor i in range(2,321):a[i*2::i]=[0]*len(a[i*2::i])\np=list(compress(n,a))\nfor e in iter(input,'0'):print(sum(p[:int(e)+1])-1)\n", "sampled": "def sieve_of_eratosthenes(limit):\n    is_prime = [True] * (limit + 1)\n    is_prime[0] = is_prime[1] = False\n    \n    for i in range(2, int(limit**0.5) + 1):\n        if is_prime[i]:\n            for j in range(i*i, limit + 1, i):\n                is_prime[j] = False\n    \n    primes = [i for i in range(2, limit + 1) if is_prime[i]]\n    return primes\n\n# Pre-compute primes up to a sufficient limit\n# For n=10000, we need the 10000th prime\n# The 10000th prime is 104729\nprimes = sieve_of_eratosthenes(105000)\n\n# Pre-compute cumulative sums\ncumsum = [0]\nfor prime in primes:\n    cumsum.append(cumsum[-1] + prime)\n\nwhile True:\n    n = int(input())\n    if n == 0:\n        break\n    print(cumsum[n])\n", "perturbed_sampled": ["def sieve_of_eratosthenes(limit): is_prime  1) is_prime[0]  i in range(2, int(limit**0.5) + 1): if  in range(2,  return primes   n=10000,  is 104729 primes = sieve_of_eratosthenes(105000) # Pre-compute cumulative sums cumsum = [0] for prime  while  n == 0: break print(cumsum[n])"], "perturbed_original": ["from itertools import * n=range(104730);a=list(n) for i ));print()i in iter(input,'0'):print(sum(p[:int(e)+1])-1)"], "original_ll": -2.5868303775787354, "sampled_ll": -0.6957857012748718, "all_perturbed_sampled_ll": [-2.4354004859924316], "all_perturbed_original_ll": [-4.295653820037842], "perturbed_sampled_ll": -2.4354004859924316, "perturbed_original_ll": -4.295653820037842, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "#include <stdio.h>\n\nint main(void) {\n\tint a,b,n;\n\tint sum;\n\tint i,j;\n\twhile(1) {\n\t\tif(scanf(\"%d %d %d\",&a,&b,&n)==-1)break;\n\t\ta-=a/b*b;\n\t\tsum=0;\n\t\tfor(i=1;i<=n;i++) {\n\t\t\ta*=10;\n\t\t\tfor(j=9;j>=0;j--) {\n\t\t\t\tif(b*j<=a)break;\n\t\t\t}\n\t\t\ta-=b*j;\n\t\t\tsum+=j;\n\t\t}\n\t\tprintf(\"%d\\n\",sum);\n\t}\n\treturn 0;\n}", "sampled": "#include <stdio.h>\n\nint main() {\n    int a, b, n;\n    \n    while (scanf(\"%d %d %d\", &a, &b, &n) == 3) {\n        int sum = 0;\n        int remainder = a % b;\n        \n        for (int i = 0; i < n; i++) {\n            remainder *= 10;\n            int digit = remainder / b;\n            sum += digit;\n            remainder = remainder % b;\n        }\n        \n        printf(\"%d\\n\", sum);\n    }\n    \n    return 0;\n}\n", "perturbed_sampled": [" int a,  %d\", &a, &b,  sum = 0; int remainder  { remainder *= 10; int digit = remainder / b;  remainder %  return 0; }"], "perturbed_original": ["#include <stdio.h> int main(void) { int a,b,n; int sum; int i,j; while(1) {   0; }"], "original_ll": -1.2095630168914795, "sampled_ll": -0.6085061430931091, "all_perturbed_sampled_ll": [-3.399932861328125], "all_perturbed_original_ll": [-2.638169288635254], "perturbed_sampled_ll": -3.399932861328125, "perturbed_original_ll": -2.638169288635254, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import java.util.Scanner;\n\npublic class Main{\n\tMain(){\n\t\tScanner sc = new Scanner(System.in);\n\t\t\n\t\twhile(sc.hasNext()){\n\t\t\tdouble a = sc.nextDouble();\n\t\t\tdouble b = sc.nextDouble();\n\t\t\tint n = sc.nextInt();\n\t\t\tint s = 0;\n\t\t\tString str = Double.toString((a/b)) + \"0000000000\";\n\t\t\tfor(int i = 0; i < n; i++){\n\t\t\t\ts += Integer.parseInt(str.substring(i+2, i+3));\n\t\t\t}\n\t\t\tSystem.out.println(Integer.toString(s));\n\t\t}\n\t}\n\t\n\tpublic static void main(String[] args){\n\t\tnew Main();\n\t}\n}", "sampled": "import java.util.Scanner;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        \n        while (sc.hasNext()) {\n            int a = sc.nextInt();\n            int b = sc.nextInt();\n            int n = sc.nextInt();\n            \n            int sum = 0;\n            int remainder = a % b;\n            \n            for (int i = 0; i < n; i++) {\n                remainder *= 10;\n                int digit = remainder / b;\n                sum += digit;\n                remainder = remainder % b;\n            }\n            \n            System.out.println(sum);\n        }\n        \n        sc.close();\n    }\n}\n", "perturbed_sampled": ["import java.util.Scanner;  static void  = sc.nextInt(); int b  0; int remainder  (int i  i++) { remainder *= 10; int digit = remainder / b; sum  } sc.close(); } }"], "perturbed_original": [" Main(){ Scanner  double a = sc.nextDouble(); double b = sc.nextDouble(); int   i = 0; i  Integer.parseInt(str.substring(i+2, i+3)); }  void  }"], "original_ll": -0.9731116890907288, "sampled_ll": -0.566260576248169, "all_perturbed_sampled_ll": [-3.5250906944274902], "all_perturbed_original_ll": [-3.253986358642578], "perturbed_sampled_ll": -3.5250906944274902, "perturbed_original_ll": -3.253986358642578, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "t=10**9\nwhile 1:\n    try:\n        a,b,n=map(int,raw_input().split())\n        if b==0:\n            print 0\n            continue\n        f=a*t/b\n        f=str(f%t)\n        ans=0\n        for i in range(n):\n            ans+=int(f[i])\n        print ans\n    except:\n        break", "sampled": "import sys\n\nfor line in sys.stdin:\n    a, b, n = map(int, line.split())\n    s = 0\n    remainder = a % b\n    \n    for i in range(n):\n        remainder *= 10\n        digit = remainder // b\n        s += digit\n        remainder = remainder % b\n    \n    print(s)\n", "perturbed_sampled": [" = map(int, line.split()) s = 0 remainder = a % b  remainder // b s +=  b print(s)"], "perturbed_original": ["t=10**9 while 1: try: a,b,n=map(int,raw_input().split()) if b==0:   break"], "original_ll": -1.3663463592529297, "sampled_ll": -1.1175869703292847, "all_perturbed_sampled_ll": [-3.7574803829193115], "all_perturbed_original_ll": [-2.3698532581329346], "perturbed_sampled_ll": -3.7574803829193115, "perturbed_original_ll": -2.3698532581329346, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "#include<stdio.h>\nint main(void){\n  int k;\n  double a[11];\n  double sum;\n  while(scanf(\"%lf\",&a[1])!=EOF){\n    sum = a[1];\n    printf(\"test\");\n    for(k=2;k=10;k++){\n      if(k%2==0){\n        a[k] = a[k-1] * 2;\n      }else{\n        a[k] = a[k-1] / 3;\n      }\n      sum += a[k];\n    }\n    printf(\"%lf\\n\",sum);\n  }\n  return 0;\n}", "sampled": "#include <stdio.h>\n\nint main() {\n    double a;\n    while (scanf(\"%lf\", &a) != EOF) {\n        double sum = 0.0;\n        double current = a;\n        \n        for (int i = 1; i <= 10; i++) {\n            sum += current;\n            if (i % 2 == 0) {\n                current = current / 3.0;\n            } else {\n                current = current * 2.0;\n            }\n        }\n        \n        printf(\"%.8lf\\n\", sum);\n    }\n    \n    return 0;\n}\n", "perturbed_sampled": [" double a; while (scanf(\"%lf\", &a) != EOF) { double sum = 0.0; double current = a;  i <= 10;  if   2.0; }  0; }"], "perturbed_original": ["#include<stdio.h> int main(void){ int k;     += a[k]; } printf(\"%lf\\n\",sum); } return 0; }"], "original_ll": -1.18648099899292, "sampled_ll": -0.6376007199287415, "all_perturbed_sampled_ll": [-2.5621700286865234], "all_perturbed_original_ll": [-3.2038822174072266], "perturbed_sampled_ll": -2.5621700286865234, "perturbed_original_ll": -3.2038822174072266, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import java.util.*;\n\npublic class Main{\n    private static double calculation(double value){\n\tdouble sum = value;\n\tdouble[] values = new double[10];\n\tvalues[0] = value;\n\t\n\tfor(int i = 1; i < 10; ++i){\n\t    if(i%2 == 1){\n\t\tvalues[i] = values[i-1]*2.0;\n\t    } else {\n\t\tvalues[i] = values[i-1]/3.0;\n\t    }\n\t    sum += values[i];\n\t}\n\t\n\n\treturn sum;\n    }\n    \n    public static void main(String[] args){\n\tScanner sc = new Scanner(System.in);\n\t\n\twhile(sc.hasNext()){\n\t    double value = sc.nextDouble();\n\t    System.out.printf(\"%f\\n\", calculation(value));\n\t}\n    }\n}", "sampled": "import java.util.Scanner;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        \n        while (sc.hasNext()) {\n            double a = sc.nextDouble();\n            double sum = 0;\n            double current = a;\n            \n            for (int i = 1; i <= 10; i++) {\n                sum += current;\n                if (i % 2 == 0) {\n                    current = current / 3.0;\n                } else {\n                    current = current * 2.0;\n                }\n            }\n            \n            System.out.printf(\"%.8f%n\", sum);\n        }\n        \n        sc.close();\n    }\n}\n", "perturbed_sampled": ["import  public static void main(String[] args) { Scanner sc =  double   % 2 ==  / 3.0; } else { current  } System.out.printf(\"%.8f%n\", sum); } sc.close(); } }"], "perturbed_original": ["import java.util.*; public class Main{ private  values =  for(int i = 1; i < 10; ++i){ if(i%2 == 1){ values[i]   +=  public  sc.nextDouble(); System.out.printf(\"%f\\n\", calculation(value)); } } }"], "original_ll": -0.9494082927703857, "sampled_ll": -0.616515040397644, "all_perturbed_sampled_ll": [-3.3005058765411377], "all_perturbed_original_ll": [-2.764484167098999], "perturbed_sampled_ll": -3.3005058765411377, "perturbed_original_ll": -2.764484167098999, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "while 1:\n    try:n=float(input())\n    except:break\n    s=n\n    for i in range(9):\n        n=n/3 if i%2 else n*2\n        s+=n\n    print(s)", "sampled": "import sys\n\nfor line in sys.stdin:\n    a = float(line.strip())\n    \n    terms = [a]\n    for i in range(1, 10):\n        if i % 2 == 1:  # odd index (2nd, 4th, 6th... terms)\n            terms.append(terms[-1] * 2)\n        else:  # even index (3rd, 5th, 7th... terms)\n            terms.append(terms[-1] / 3)\n    \n    s = sum(terms)\n    print(f\"{s:.8f}\")\n", "perturbed_sampled": ["import sys  = float(line.strip()) terms = [a]  index (2nd, 4th, 6th... terms)  even index (3rd, 5th, 7th... terms) terms.append(terms[-1]  print(f\"{s:.8f}\")"], "perturbed_original": ["while 1: try:n=float(input())  range(9): n=n/3  print(s)"], "original_ll": -1.83852219581604, "sampled_ll": -0.9661317467689514, "all_perturbed_sampled_ll": [-3.2097115516662598], "all_perturbed_original_ll": [-3.9948432445526123], "perturbed_sampled_ll": -3.2097115516662598, "perturbed_original_ll": -3.9948432445526123, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "#include <stdio.h>\nint prime[50001];\nvoid set(void){\n    int i,o;\n    for(i=4;i<=5000;i+=2)\n        prime[i]=1;\n    for(i=3;i*i<=5000;i+=2){\n        if(prime[i]==0)\n            for(o=i*2;o<=5000;o+=i)\n                prime[o]=1;\n    }\n}\nint main(void){\n    int num,count,sum,i,o;\n    set();\n    for(;count=0,scanf(\"%d\",&num),num;){\n        for(i=2;i<=num;i++)\n            if(!prime[i]){\n                if(i>num)\n                     break;\n                for(o=2;o<=num;o++)\n                    if(!prime[o]){\n                        sum=i+o;\n                        if(sum == num){\n                            count++;\n                            break;\n                        }\n                        if(sum > num)\n                            break;\n                    }\n            }\n        printf(\"%d\\n\",count%2?(count/2+1):(count/2));\n    }\n    return 0;\n}", "sampled": "#include <stdio.h>\n#include <string.h>\n\n#define MAX 50001\n\nint is_prime[MAX];\n\nvoid sieve() {\n    memset(is_prime, 1, sizeof(is_prime));\n    is_prime[0] = is_prime[1] = 0;\n    \n    for (int i = 2; i * i < MAX; i++) {\n        if (is_prime[i]) {\n            for (int j = i * i; j < MAX; j += i) {\n                is_prime[j] = 0;\n            }\n        }\n    }\n}\n\nint main() {\n    sieve();\n    \n    int n;\n    while (scanf(\"%d\", &n) == 1 && n != 0) {\n        int count = 0;\n        for (int i = 2; i <= n / 2; i++) {\n            if (is_prime[i] && is_prime[n - i]) {\n                count++;\n            }\n        }\n        printf(\"%d\\n\", count);\n    }\n    \n    return 0;\n}\n", "perturbed_sampled": ["#include <stdio.h> ; } n++<extra_id_9>return i*(i+1); }<extra_id_10>; sieve(); sieve();<extra_id_11>* i* 0;   i++) { if (is_prime[i])  i * i; j < MAX; j +=  int main() { sieve(); int n; while (scanf(\"%d\",   = 0; for (int i =  (is_prime[i] && is_prime[n - i]) { count++;  return 0; }"], "perturbed_original": ["#include <stdio.h> int <extra_id_1>public int<extra_id_2>(<extra_id_3>{<extra_id_4>i+i=1;i<=5000;i+=i;i++; } for(o=i*2;o<=5000;o+=i) prime[o]=1;  if(!prime[i]){  if(sum == num){ count++; break; } if(sum > num) break;  0; }"], "original_ll": -1.1158311367034912, "sampled_ll": -0.36023810505867004, "all_perturbed_sampled_ll": [-3.3428685665130615], "all_perturbed_original_ll": [-3.0770368576049805], "perturbed_sampled_ll": -3.3428685665130615, "perturbed_original_ll": -3.0770368576049805, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import java.util.Arrays;\nimport java.util.Scanner;\n\npublic class Main {\n\tpublic static boolean[] p=new boolean[50000];\n\tpublic static int counter(int n){\n\t\tint c=0,i,j;\n\t\tfor(i=2;i<=n/2;i++){\n\t\t\tif(p[i])\n\t\t\tfor(j=2;i+j<=n;j++){\n\t\t\t\tif(p[j]){\n\t\t\t\t\tif(i+j==n){\n\t\t\t\t\t\tc++;\n//\t\t\t\t\t\tSystem.out.println(i+\" \"+j);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}//\n\t\treturn c;\n\t}\n\tpublic static void main(String[] args) {\n\t\tScanner sc=new Scanner(System.in);\n\t\tint n,i,j;\n\t\tArrays.fill(p, true);\n\t\tfor(i=2;i<50000;i++){\n\t\t\tif(p[i])\n\t\t\tfor(j=2;i*j<50000;j++){\n\t\t\t\tp[i*j]=false;\n\t\t\t}\n\t\t}\n\t\twhile(true){\n\t\t\tn=sc.nextInt();\n\t\t\tif(n==0) break;\n\t\t\tSystem.out.println(counter(n));\n\t\t}\n\t}\n}", "sampled": "import java.util.*;\n\npublic class Main {\n    static boolean[] isPrime;\n    static int MAX = 50001;\n    \n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        \n        // Sieve of Eratosthenes\n        isPrime = new boolean[MAX];\n        Arrays.fill(isPrime, true);\n        isPrime[0] = isPrime[1] = false;\n        \n        for (int i = 2; i * i < MAX; i++) {\n            if (isPrime[i]) {\n                for (int j = i * i; j < MAX; j += i) {\n                    isPrime[j] = false;\n                }\n            }\n        }\n        \n        while (true) {\n            int n = sc.nextInt();\n            if (n == 0) break;\n            \n            int count = 0;\n            for (int i = 2; i <= n / 2; i++) {\n                if (isPrime[i] && isPrime[n - i]) {\n                    count++;\n                }\n            }\n            \n            System.out.println(count);\n        }\n        \n        sc.close();\n    }\n}\n", "perturbed_sampled": ["import java.util.*; public <extra_id_1>(int i =<extra_id_2><<extra_id_3>==<extra_id_4>if<extra_id_5>!= i)<extra_id_6>=<extra_id_7>] =<extra_id_8>= ( ( int )<extra_id_9>)<extra_id_10>count == 0; if<extra_id_11>=<extra_id_12>)<extra_id_13>null ; p =<extra_id_14>{ if<extra_id_15>}<extra_id_16>=<extra_id_17>) { sc . close<extra_id_18>) ; }<extra_id_19>} j<extra_id_20>* \" = \"<extra_id_21>;<extra_id_22>( 0 == i )<extra_id_23>p ) ;<extra_id_24>if<extra_id_25>i void  =  = isPrime[1] =  2; i * i < MAX; i++) { if (isPrime[i]) { for (int j = i * i; j < MAX;   while  sc.nextInt();  int count  = 2;  i++) { if (isPrime[i]  } sc.close(); } }"], "perturbed_original": ["import  Main { public  static int counter(int n){ int c=0,i,j; for(i=2;i<=n/2;i++){ if(p[i]) for(j=2;i+j<=n;j++){  }// return c; } public  n,i,j;  p[i*j]=false; }  System.out.println(counter(n)); } } }"], "original_ll": -0.9992666244506836, "sampled_ll": -0.3539169132709503, "all_perturbed_sampled_ll": [-2.3004016876220703], "all_perturbed_original_ll": [-3.1014628410339355], "perturbed_sampled_ll": -2.3004016876220703, "perturbed_original_ll": -3.1014628410339355, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "N=50000+1\np=[True]*N\np[0],p[1]=False,False\nfor i in xrange(2,int(N**0.5)+1):\n    if p[i]==True:\n        for j in xrange(i**2,N,i):\n            p[j]=False\nwhile True:\n    n=input()\n    if n==0:break\n    c=0\n    for i in xrange(n/2+1):\n        if p[i] and p[n-i]:c+=1\n    print c", "sampled": "def sieve_of_eratosthenes(limit):\n    is_prime = [True] * (limit + 1)\n    is_prime[0] = is_prime[1] = False\n    \n    for i in range(2, int(limit**0.5) + 1):\n        if is_prime[i]:\n            for j in range(i*i, limit + 1, i):\n                is_prime[j] = False\n    \n    return is_prime\n\nlimit = 50000\nis_prime = sieve_of_eratosthenes(limit)\n\nwhile True:\n    n = int(input())\n    if n == 0:\n        break\n    \n    count = 0\n    for i in range(2, n // 2 + 1):\n        if is_prime[i] and is_prime[n - i]:\n            count += 1\n    \n    print(count)\n", "perturbed_sampled": ["def sieve_of_eratosthenes(limit): is_prime  1) is_prime[0] = is_prime[1] = False for  n = int(input()) if n ==  for i in range(2, n  is_prime[i] and is_prime[n - i]: count += 1 print(count)"], "perturbed_original": ["   c=0 for i in xrange(n/2+1): if p[i] and p[n-i]:c+=1 print c"], "original_ll": -0.9976736307144165, "sampled_ll": -0.38441094756126404, "all_perturbed_sampled_ll": [-2.400874614715576], "all_perturbed_original_ll": [-2.5236127376556396], "perturbed_sampled_ll": -2.400874614715576, "perturbed_original_ll": -2.5236127376556396, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "N,main(){while(~scanf(\"%d\",&N))printf(\"%d\\n\",N*(N+1)/2+1);}", "sampled": "#include <stdio.h>\n\nint main() {\n    int n;\n    while (scanf(\"%d\", &n) != EOF) {\n        long long result = 1 + (long long)n * (n + 1) / 2;\n        printf(\"%lld\\n\", result);\n    }\n    return 0;\n}\n", "perturbed_sampled": ["#include <stdio.h> int main()  long long result = 1 +  result); } return 0; }"], "perturbed_original": ["N,main(){while(~scanf(\"%d\",&N))printf(\"%d\\n\",N*(N+1)/2+1);}"], "original_ll": -2.3594918251037598, "sampled_ll": -0.7457207441329956, "all_perturbed_sampled_ll": [-3.041828155517578], "all_perturbed_original_ll": [-2.3594918251037598], "perturbed_sampled_ll": -3.041828155517578, "perturbed_original_ll": -2.3594918251037598, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import java.util.*;\n\nclass Main {\n    public static void main(String[] args) {\n\tScanner s = new Scanner(System.in);\n\tint[] d = new int[10001];\n\td[0]=1;\n\td[1]=2;\n\tfor(int i=2 ; i<10001 ; i++)\n\t    d[i] = d[i-1]+i;\n\twhile(s.hasNext())\n\t    System.out.println(d[s.nextInt()]);\n    }\n}", "sampled": "import java.util.Scanner;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        \n        while (sc.hasNext()) {\n            int n = sc.nextInt();\n            long result = (long) n * (n + 1) / 2 + 1;\n            System.out.println(result);\n        }\n        \n        sc.close();\n    }\n}\n", "perturbed_sampled": ["import java.util.Scanner; public class Main { public   while (sc.hasNext()) { int n = sc.nextInt(); long result  sc.close(); } }"], "perturbed_original": ["import java.util.*; class Main { public   i=2 ;  d[i-1]+i; while(s.hasNext()) System.out.println(d[s.nextInt()]); } }"], "original_ll": -0.9584491848945618, "sampled_ll": -0.6549385190010071, "all_perturbed_sampled_ll": [-2.9371087551116943], "all_perturbed_original_ll": [-3.2836296558380127], "perturbed_sampled_ll": -2.9371087551116943, "perturbed_original_ll": -3.2836296558380127, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "while True:\n    try:\n        a = int(input())\n        print(((a * a) + a + 2) / 2)\n    except EOFError:\n        break", "sampled": "import sys\n\nfor line in sys.stdin:\n    n = int(line.strip())\n    result = 1 + n * (n + 1) // 2\n    print(result)\n", "perturbed_sampled": ["import  n = int(line.strip()) result =  + 1) // 2 print(result)"], "perturbed_original": ["while  print(((a * a) + a +  break"], "original_ll": -1.3567216396331787, "sampled_ll": -1.0850199460983276, "all_perturbed_sampled_ll": [-4.747538089752197], "all_perturbed_original_ll": [-5.88793420791626], "perturbed_sampled_ll": -4.747538089752197, "perturbed_original_ll": -5.88793420791626, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "i;main(){float A,a,B,b,C,c,D,d;for(;~scanf(\"%f\",&d+i*2);)if(++i==8)puts((A-B)*(C-D)+(a-b)*(c-d)?\"NO\":\"YES\",i=0);}", "sampled": "#include <stdio.h>\n#include <math.h>\n\nint main() {\n    double xA, yA, xB, yB, xC, yC, xD, yD;\n    \n    while (scanf(\"%lf %lf %lf %lf %lf %lf %lf %lf\", \n                 &xA, &yA, &xB, &yB, &xC, &yC, &xD, &yD) == 8) {\n        double dx1 = xB - xA;\n        double dy1 = yB - yA;\n        double dx2 = xD - xC;\n        double dy2 = yD - yC;\n        \n        double dot = dx1 * dx2 + dy1 * dy2;\n        \n        if (fabs(dot) < 1e-9) {\n            printf(\"YES\\n\");\n        } else {\n            printf(\"NO\\n\");\n        }\n    }\n    \n    return 0;\n}\n", "perturbed_sampled": ["#include <stdio.h> #include <math.h> int main()   while (scanf(\"%lf %lf  %lf\", &xA, &yA, &xB, &yB, &xC,  {  yB  xD  yD - yC; double dot  dy1 * dy2; if  } else  0; }"], "perturbed_original": ["i;main(){float A,a,B,b,C,c,D,d;for(;~scanf(\"%f\",&d+i*2);)if(++i==8)puts((A-B)*(C-D)+(a-b)*(c-d)?\"NO\":\"YES\",i=0);}"], "original_ll": -3.3201801776885986, "sampled_ll": -0.4434913396835327, "all_perturbed_sampled_ll": [-2.7255494594573975], "all_perturbed_original_ll": [-3.3201801776885986], "perturbed_sampled_ll": -2.7255494594573975, "perturbed_original_ll": -3.3201801776885986, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import java.util.Scanner;\nclass Main{\n    public static void main(String[] args) {\n        Scanner sc=new Scanner(System.in);\n        while(sc.hasNext()){\n            double[][]point=new double[4][2];\n            for(int i=0;i<4;i++){\n                point[i][0]=sc.nextDouble();\n                point[i][1]=sc.nextDouble();\n            }\n            double x1=point[1][0]-point[0][0],y1=point[1][1]-point[0][1],x2=point[3][0]-point[2][0],y2=point[3][1]-point[2][1];\n            System.out.println((x1*x2+y1*y2)==0?\"YES\":\"NO\");\n            \n        }\n    }\n}", "sampled": "import java.util.Scanner;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        \n        while (sc.hasNext()) {\n            double xA = sc.nextDouble();\n            double yA = sc.nextDouble();\n            double xB = sc.nextDouble();\n            double yB = sc.nextDouble();\n            double xC = sc.nextDouble();\n            double yC = sc.nextDouble();\n            double xD = sc.nextDouble();\n            double yD = sc.nextDouble();\n            \n            double dx1 = xB - xA;\n            double dy1 = yB - yA;\n            double dx2 = xD - xC;\n            double dy2 = yD - yC;\n            \n            double dotProduct = dx1 * dx2 + dy1 * dy2;\n            \n            if (Math.abs(dotProduct) < 1e-9) {\n                System.out.println(\"YES\");\n            } else {\n                System.out.println(\"NO\");\n            }\n        }\n        \n        sc.close();\n    }\n}\n", "perturbed_sampled": ["import java.util.Scanner; public class  main(String[] args) { Scanner sc = new Scanner(System.in); while (sc.hasNext()) { double xA =  double xB =  double yC  sc.nextDouble(); double  double dy1  dotProduct = dx1 *  { System.out.println(\"NO\"); } } sc.close(); } }"], "perturbed_original": ["import java.util.Scanner;  sc=new Scanner(System.in); while(sc.hasNext()){ double[][]point=new double[4][2]; for(int i=0;i<4;i++){ point[i][0]=sc.nextDouble(); point[i][1]=sc.nextDouble(); }  }"], "original_ll": -0.653437614440918, "sampled_ll": -0.3822898268699646, "all_perturbed_sampled_ll": [-2.708983898162842], "all_perturbed_original_ll": [-1.410947561264038], "perturbed_sampled_ll": -2.708983898162842, "perturbed_original_ll": -1.410947561264038, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "while True:\n    try:\n        xA,yA,xB,yB,xC,yC,xD,yD = map(float,raw_input().split())\n        if (100000*(yB-yA))*(100000*(yD-yC)) + (100000*(xB-xA))*(100000*(xD-xC)) < 1.e-10:\n            print \"YES\"\n        else:\n            print \"NO\"\n    except:\n        break", "sampled": "import sys\n\nfor line in sys.stdin:\n    coords = list(map(float, line.split()))\n    xa, ya, xb, yb, xc, yc, xd, yd = coords\n    \n    # Vector AB\n    vab_x = xb - xa\n    vab_y = yb - ya\n    \n    # Vector CD\n    vcd_x = xd - xc\n    vcd_y = yd - yc\n    \n    # Dot product\n    dot = vab_x * vcd_x + vab_y * vcd_y\n    \n    # Check if perpendicular (dot product is 0)\n    if abs(dot) < 1e-9:\n        print(\"YES\")\n    else:\n        print(\"NO\")\n", "perturbed_sampled": ["import sys for line in sys.stdin: coords  = xb - xa vab_y =  - xc vcd_y = yd -  (dot product is 0) if abs(dot) < 1e-9: print(\"YES\") else: print(\"NO\")"], "perturbed_original": ["while True:  (100000*(yB-yA))*(100000*(yD-yC)) +  else: print \"NO\" except: break"], "original_ll": -1.1582998037338257, "sampled_ll": -0.777967631816864, "all_perturbed_sampled_ll": [-3.5376052856445312], "all_perturbed_original_ll": [-3.3466711044311523], "perturbed_sampled_ll": -3.5376052856445312, "perturbed_original_ll": -3.3466711044311523, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "#include<stdio.h>\n#include<math.h>\n#include <stdlib.h>\n#include<string.h>\n#include<limits.h>\n\nint main(){\n\tdouble x[4],y[4];\n\tint i;\n\t\n\twhile(scanf(\"%lf%lf%lf%lf%lf%lf%lf%lf\",&x[0],&y[0],&x[1],&y[1],&x[2],&y[2],&x[3],&y[3])!=EOF){\n\t\n\t\tif(x[0]<=x[2] && x[1]>=x[2]){\n\t\t\tif((y[0]<=y[2] && y[1]>=y[2]) || (y[0]<=y[3] && y[1]>=y[3]))printf(\"YES\\n\");\n\t\t\telse printf(\"NO\\n\");\n\t\t}\n\t\telse if(x[0]<=x[3] && x[1]>=x[3]){\n\t\t\tif((y[0]<=y[2] && y[1]>=y[2]) || (y[0]<=y[3] && y[1]>=y[3]))printf(\"YES\\n\");\n\t\t\telse printf(\"NO\\n\");\n\t\t}\n\t\telse printf(\"NO\\n\");\n\t}\nreturn 0;\n}", "sampled": "#include <stdio.h>\n\nint main() {\n    double xa1, ya1, xa2, ya2, xb1, yb1, xb2, yb2;\n    \n    while (scanf(\"%lf %lf %lf %lf %lf %lf %lf %lf\", \n                  &xa1, &ya1, &xa2, &ya2, &xb1, &yb1, &xb2, &yb2) == 8) {\n        \n        if (xa2 >= xb1 && xb2 >= xa1 && ya2 >= yb1 && yb2 >= ya1) {\n            printf(\"YES\\n\");\n        } else {\n            printf(\"NO\\n\");\n        }\n    }\n    \n    return 0;\n}\n", "perturbed_sampled": ["#include <stdio.h> int  xa2,  %lf\", &xa1, &ya1, &xa2, &ya2, &xb1, &yb1, &xb2,  (xa2 >= xb1 &&  >= yb1 && yb2 >=  return 0; }"], "perturbed_original": ["#include<stdio.h> #include<math.h> #include <stdlib.h>  if(x[0]<=x[2] &&  printf(\"NO\\n\"); } else if(x[0]<=x[3] && x[1]>=x[3]){  } else printf(\"NO\\n\"); } return 0; }"], "original_ll": -0.5937101244926453, "sampled_ll": -0.5137386918067932, "all_perturbed_sampled_ll": [-2.705929756164551], "all_perturbed_original_ll": [-2.1479756832122803], "perturbed_sampled_ll": -2.705929756164551, "perturbed_original_ll": -2.1479756832122803, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import java.util.Scanner;\npublic class Main {\n\tstatic double x1[]=new double[2];\n\tstatic double y1[]=new double[2];\n\tstatic double x2[]=new double[2];\n\tstatic double y2[]=new double[2];\n\tpublic static boolean check(double x,double y) {\n\t\tif(x1[0]<=x && x<=x1[1] && y1[0]<=y && y<=y1[1]){\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n\tpublic static boolean check2(double x,double y) {\n\t\tif(x2[0]<=x && x<=x2[1] && y2[0]<=y && y<=y2[1]){\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n\tpublic static void main(String[] args) {\n\t\tScanner sc=new Scanner(System.in);\n\t\tdouble tmp;\n\t\tint i,j;\n\t\twhile(sc.hasNext()){\n\t\t\tfor(i=0;i<2;i++){\n\t\t\t\tx1[i]=sc.nextDouble();\n\t\t\t\ty1[i]=sc.nextDouble();\n\t\t\t}\n\t\t\tfor(i=0;i<2;i++){\n\t\t\t\tx2[i]=sc.nextDouble();\n\t\t\t\ty2[i]=sc.nextDouble();\n\t\t\t}\n\t\t\tif(x1[1]<x1[0]){\n\t\t\t\ttmp=x1[1];\n\t\t\t\tx1[0]=x1[1];\n\t\t\t\tx1[1]=tmp;\n\t\t\t}\n\t\t\tif(y1[1]<y1[0]){\n\t\t\t\ttmp=y1[1];\n\t\t\t\ty1[0]=y1[1];\n\t\t\t\ty1[1]=tmp;\n\t\t\t}\n\t\t\tif(x2[1]<x2[0]){\n\t\t\t\ttmp=x2[1];\n\t\t\t\tx2[0]=x2[1];\n\t\t\t\tx2[1]=tmp;\n\t\t\t}\n\t\t\tif(y2[1]<y2[0]){\n\t\t\t\ttmp=y2[1];\n\t\t\t\ty2[0]=y2[1];\n\t\t\t\ty2[1]=tmp;\n\t\t\t}\n\t\t\tboolean f=false;\n\t\t\tfor(i=0;i<2;i++){\n\t\t\t\tfor(j=0;j<2;j++){\n\t\t\t\t\t//System.out.println(f+\" \"+x2[i]+\" \"+y2[j]);\n\t\t\t\t\tif(f) break;\n\t\t\t\t\tf=check(x2[i],y2[j]);\n\t\t\t\t}\n\t\t\t}//\n\t\t\tfor(i=0;i<2;i++){\n\t\t\t\tfor(j=0;j<2;j++){\n\t\t\t\t\t//System.out.println(f);\n\t\t\t\t\tif(f) break;\n\t\t\t\t\tf=check2(x1[i],y1[j]);\n\t\t\t\t}\n\t\t\t}//\n\t\t\tif(f){\n\t\t\t\tSystem.out.println(\"YES\");\n\t\t\t}\n\t\t\telse{\n\t\t\t\tSystem.out.println(\"NO\");\n\t\t\t}\n\t\t}\n\t}\n}", "sampled": "import java.util.Scanner;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        \n        while (sc.hasNext()) {\n            double xa1 = sc.nextDouble();\n            double ya1 = sc.nextDouble();\n            double xa2 = sc.nextDouble();\n            double ya2 = sc.nextDouble();\n            double xb1 = sc.nextDouble();\n            double yb1 = sc.nextDouble();\n            double xb2 = sc.nextDouble();\n            double yb2 = sc.nextDouble();\n            \n            boolean xOverlap = !(xa2 < xb1 || xb2 < xa1);\n            boolean yOverlap = !(ya2 < yb1 || yb2 < ya1);\n            \n            if (xOverlap && yOverlap) {\n                System.out.println(\"YES\");\n            } else {\n                System.out.println(\"NO\");\n            }\n        }\n        \n        sc.close();\n    }\n}\n", "perturbed_sampled": ["import java.util.Scanner;  static  sc = new Scanner(System.in); while  sc.nextDouble(); double ya2 = sc.nextDouble(); double xb1  sc.nextDouble();  yb2 =  < xa1); boolean yOverlap = !(ya2 < yb1 || yb2 < ya1);  } }"], "perturbed_original": ["import java.util.Scanner;  double x1[]=new double[2]; static double y1[]=new double[2]; static double x2[]=new  public static boolean check(double  return false; } public static  if(x2[0]<=x && x<=x2[1] && y2[0]<=y && y<=y2[1]){ return  public static void main(String[]  }  }  } boolean f=false; for(i=0;i<2;i++){ for(j=0;j<2;j++){ //System.out.println(f+\" \"+x2[i]+\" \"+y2[j]); if(f)  for(j=0;j<2;j++){ //System.out.println(f); if(f) break;  } } }"], "original_ll": -0.38706761598587036, "sampled_ll": -0.45130082964897156, "all_perturbed_sampled_ll": [-3.0986266136169434], "all_perturbed_original_ll": [-1.7746937274932861], "perturbed_sampled_ll": -3.0986266136169434, "perturbed_original_ll": -1.7746937274932861, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import sys\n\n\nfor line in sys.stdin.readline():\n    xa1, ya1, xa2, ya2, xb1, yb1, xb2, yb2 = map(float, line.rstrip('\\n').split(' '))\n    if ((xb1<=xa1 and xa1<=xb2) or (xa1<=xb1 and xb1<=xa2)) and ((yb1<=ya2 and ya2<=yb2) or (ya1<=yb2 and yb2<=ya2)):\n        print 'YES'\n    else:\n        print 'NO'", "sampled": "import sys\n\nfor line in sys.stdin:\n    coords = []\n    coords.append(list(map(float, line.split())))\n    for _ in range(7):\n        coords.append(list(map(float, input().split())))\n    \n    xa1, ya1 = coords[0][0], coords[1][0]\n    xa2, ya2 = coords[2][0], coords[3][0]\n    xb1, yb1 = coords[4][0], coords[5][0]\n    xb2, yb2 = coords[6][0], coords[7][0]\n    \n    if xa2 >= xb1 and xb2 >= xa1 and ya2 >= yb1 and yb2 >= ya1:\n        print(\"YES\")\n    else:\n        print(\"NO\")\n", "perturbed_sampled": ["import sys for line in   = coords[0][0], coords[1][0] xa2, ya2 = coords[2][0],  >= xa1 and ya2 >= yb1 and yb2 >= ya1: print(\"YES\") else: print(\"NO\")"], "perturbed_original": [" yb2 = map(float, line.rstrip('\\n').split(' ')) if ((xb1<=xa1  xb1<=xa2)) and ((yb1<=ya2 and ya2<=yb2)  'YES' else: print 'NO'"], "original_ll": -0.9972597360610962, "sampled_ll": -0.6717944741249084, "all_perturbed_sampled_ll": [-2.742851734161377], "all_perturbed_original_ll": [-3.1207568645477295], "perturbed_sampled_ll": -2.742851734161377, "perturbed_original_ll": -3.1207568645477295, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "#include <stdio.h>\n\nint main()\n{\n        int c1, c2, c3, i, cnt = 0;\n        int card[11];\n\n        for ( int i = 1 ; i < 11 ; i++ ) {\n                card[i] = 1;\n        }\n\n        while ( scanf( \"%d %d %d\", &c1, &c2, &c3 ) == 3 ) {\n                cnt = 0;\n                for ( i = 1 ; i < 11 ; i++ ) {\n                        if ( c1 != i && c2 != i && c3 != i ) {\n                                if ( c1 + c2 + i <= 20 ) {\n                                        cnt++;\n                                }\n                        }\n                }\n                if ( cnt >= 4 ) {\n                        printf( \"YES\\n\" );\n                } else {\n                        printf( \"NO\\n\" );\n                }\n        }\n        return 0;\n}\n\n", "sampled": "#include <stdio.h>\n\nint main() {\n    int c1, c2, c3;\n    \n    while (scanf(\"%d %d %d\", &c1, &c2, &c3) == 3) {\n        int current_sum = c1 + c2;\n        int max_allowed = 20 - current_sum;\n        \n        int count_valid = 0;\n        int count_total = 0;\n        \n        for (int i = 1; i <= 10; i++) {\n            if (i != c1 && i != c2 && i != c3) {\n                count_total++;\n                if (i <= max_allowed) {\n                    count_valid++;\n                }\n            }\n        }\n        \n        if (count_valid * 2 >= count_total) {\n            printf(\"YES\\n\");\n        } else {\n            printf(\"NO\\n\");\n        }\n    }\n    \n    return 0;\n}\n", "perturbed_sampled": ["#include   %d %d\",     = 0; for (int i = 1; i <= 10;  c2 && i != c3) { count_total++; if (i <= max_allowed) { count_valid++; } } }  } return 0; }"], "perturbed_original": ["#include <stdio.h> int main() { int c1, c2, c3, i, <extra_id_1>c3<extra_id_2>{ printf( \"YES\\n\" ) { card[i] = 1; } while ( scanf( \"%d %d %d\", &c1, &c2, &c3 <extra_id_3>{ printf( \"NO\\n\" cnt = 0; for ( i }<extra_id_4>printf( \"YES\\n\" }<extra_id_5><c1||<c2||<c3|<c3}>%d%d\\n\", &c2, &c3,<extra_id_6>c3<extra_id_7>( \"I/O\\n\",<extra_id_8>==<extra_id_9>c3 == \"A \" if ( c1 != i && c2 != i  {  } else { printf( \"NO\\n\"  }"], "original_ll": -0.900566577911377, "sampled_ll": -0.7280890345573425, "all_perturbed_sampled_ll": [-3.193511962890625], "all_perturbed_original_ll": [-2.240370512008667], "perturbed_sampled_ll": -3.193511962890625, "perturbed_original_ll": -2.240370512008667, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import java.util.*;\n\npublic class Main {\n\t\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\t\n\t\twhile(sc.hasNext()){\n\t\t\tint a = sc.nextInt();\n\t\t\tint b = sc.nextInt();\n\t\t\tint c = sc.nextInt();\n\t\t\tint count = 0;\n\t\t\tfor(int i=1;i<=10;i++){\n\t\t\t\tif(i!=a && i!=b && i!=c && a+b+i>20) count++;\n\t\t\t}\n\t\t\tif(count<=3) System.out.println(\"YES\");\n\t\t\telse System.out.println(\"NO\");\t\n\t\t}\n\t}\t\n}", "sampled": "import java.util.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        \n        while (sc.hasNext()) {\n            int c1 = sc.nextInt();\n            int c2 = sc.nextInt();\n            int c3 = sc.nextInt();\n            \n            int currentSum = c1 + c2;\n            \n            // Count how many cards from remaining 7 cards would make sum <= 20\n            int count = 0;\n            for (int i = 1; i <= 10; i++) {\n                if (i != c1 && i != c2 && i != c3) {\n                    if (currentSum + i <= 20) {\n                        count++;\n                    }\n                }\n            }\n            \n            // Total remaining cards is 7 (10 - 3 known cards)\n            // Probability is count/7\n            // 50% or more means count/7 >= 0.5, which is count >= 3.5, so count >= 4\n            if (count * 2 >= 7) {\n                System.out.println(\"YES\");\n            } else {\n                System.out.println(\"NO\");\n            }\n        }\n        \n        sc.close();\n    }\n}\n", "perturbed_sampled": ["  args) { Scanner   sc.nextInt(); int  = sc.nextInt(); int  cards from remaining 7 cards would make sum <= 20 int count   != c3) { if (currentSum + i <= 20) { count++; }  cards is 7 (10 - 3 known cards) // Probability   3.5,  (count * 2   sc.close(); } }"], "perturbed_original": ["import  public  = sc.nextInt(); int count = 0; for(int i=1;i<=10;i++){  && a+b+i>20) count++; } if(count<=3) System.out.println(\"YES\"); else System.out.println(\"NO\"); } } }"], "original_ll": -0.8495214581489563, "sampled_ll": -1.0624080896377563, "all_perturbed_sampled_ll": [-3.9965670108795166], "all_perturbed_original_ll": [-2.4407765865325928], "perturbed_sampled_ll": -3.9965670108795166, "perturbed_original_ll": -2.4407765865325928, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import sys\nfor x in sys.stdin:\n e=list(map(int,x.split()))\n print(['YES','NO'][len(set(range(1,21-sum(e[:2])))-set(e))/7<.5])\n", "sampled": "import sys\n\nfor line in sys.stdin:\n    c1, c2, c3 = map(int, line.strip().split())\n    \n    current_sum = c1 + c2\n    used_cards = {c1, c2, c3}\n    \n    available_cards = []\n    for i in range(1, 11):\n        if i not in used_cards:\n            available_cards.append(i)\n    \n    valid_count = 0\n    for card in available_cards:\n        if current_sum + card <= 20:\n            valid_count += 1\n    \n    total_count = len(available_cards)\n    \n    if valid_count / total_count >= 0.5:\n        print(\"YES\")\n    else:\n        print(\"NO\")\n", "perturbed_sampled": ["import sys for line in sys.stdin: c1, c2, c3 = map(int, line.strip().split()) current_sum  = {c1, c2,  i in range(1, 11):  available_cards.append(i) valid_count  len(available_cards)  0.5: print(\"YES\") else: print(\"NO\")"], "perturbed_original": ["import  e=list(map(int,x.split())) print(['YES','NO'][len(set(range(1,21-sum(e[:2])))-set(e))/7<.5])"], "original_ll": -3.4410805702209473, "sampled_ll": -0.8978514671325684, "all_perturbed_sampled_ll": [-2.652256727218628], "all_perturbed_original_ll": [-4.312676429748535], "perturbed_sampled_ll": -2.652256727218628, "perturbed_original_ll": -4.312676429748535, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "#include <stdio.h>\n\nint main(void)\n{\n\tint i,j,k;\n\tint team[100],score[100];\n\tint rank[100];\n\tint count,number,tmp1,tmp2,info;\n\t\n\tcount=0;\n\t//\u5165\u529b\n\tfor(i=0;i<100;i++)\n\t{\n\t\tscanf(\"%d,%d\",&team[i],&score[i]);\n\t\tif(team[i]+score[i]==0)\n\t\t\tbreak;\n\t\tcount++;\n\t}\n\t\n\t//\u4e26\u3073\u66ff\u3048\n\tfor(i=0;i<count;i++)\n\t{\n\t\tfor(j=count-1;j>i;j--)\n\t\t{\n\t\t\tif(score[i]<=score[j])\n\t\t\t{\n\t\t\t\ttmp1=score[i];\n\t\t\t\tscore[i]=score[j];\n\t\t\t\tscore[j]=tmp1;\n\t\t\t\t\n\t\t\t\ttmp1=team[i];\n\t\t\t\tteam[i]=team[j];\n\t\t\t\tteam[j]=tmp1;\n\t\t\t}\n\t\t}\n\t}\n\t//\u9806\u4f4d\u4ed8\u3051\n\tnumber=1;\n\trank[0]=number;\n\ttmp2=score[0];\n\tfor(i=1;i<count;i++)\n\t{\n\t\t//printf(\"%d %d\\n\",score[i],tmp2);\n\t\tif(score[i]!=tmp2)\n\t\t{\n\t\t\tnumber++;\n\t\t\ttmp2=score[i];\n\t\t}\n\t\trank[i]=number;\n\t}\n\t\n\t\n\t//\u554f\u3044\u5408\u308f\u305b\n\twhile(scanf(\"%d\",&info)!=EOF)\n\t{\n\t\tfor(i=0;i<count;i++)\n\t\t{\n\t\t\tif(info==team[i])\n\t\t\t\tprintf(\"%d\\n\",rank[i]);\n\t\t\t//printf(\"%d,%d\\n\",team[i],score[i]);\n\t\t}\n\t}\n\treturn 0;\n}", "sampled": "#include <stdio.h>\n#include <stdlib.h>\n\ntypedef struct {\n    int id;\n    int score;\n} Team;\n\nint compare(const void *a, const void *b) {\n    Team *ta = (Team *)a;\n    Team *tb = (Team *)b;\n    return tb->score - ta->score;\n}\n\nint main() {\n    Team teams[100];\n    int count = 0;\n    int id, score;\n    \n    while (1) {\n        scanf(\"%d,%d\", &id, &score);\n        if (id == 0 && score == 0) break;\n        teams[count].id = id;\n        teams[count].score = score;\n        count++;\n    }\n    \n    qsort(teams, count, sizeof(Team), compare);\n    \n    int query;\n    while (scanf(\"%d\", &query) != EOF) {\n        int target_score = -1;\n        for (int i = 0; i < count; i++) {\n            if (teams[i].id == query) {\n                target_score = teams[i].score;\n                break;\n            }\n        }\n        \n        int rank = 1;\n        int prev_score = -1;\n        int current_rank = 0;\n        \n        for (int i = 0; i < count; i++) {\n            if (teams[i].score != prev_score) {\n                current_rank++;\n                prev_score = teams[i].score;\n            }\n            if (teams[i].score == target_score) {\n                rank = current_rank;\n                break;\n            }\n        }\n        \n        printf(\"%d\\n\", rank);\n    }\n    \n    return 0;\n}\n", "perturbed_sampled": ["#include <stdio.h> #include <stdlib.h> typedef struct   *a,  *ta = (Team *)a;  return tb->score - ta->score;   int   == 0 && score == 0) break; teams[count].id =   int query; while (scanf(\"%d\", &query) !=  = 0; i  (teams[i].id == query) { target_score =  rank =  0;  if (teams[i].score != prev_score) {  if  } printf(\"%d\\n\", rank); } return 0; }"], "perturbed_original": ["#include <stdio.h> int main(void) { int i,j,k; int team[100],score[100]; int   {   { //printf(\"%d %d\\n\",score[i],tmp2);   for(i=0;i<count;i++) { if(info==team[i]) printf(\"%d\\n\",rank[i]); //printf(\"%d,%d\\n\",team[i],score[i]); } } return 0; }"], "original_ll": -0.8656981587409973, "sampled_ll": -0.531158983707428, "all_perturbed_sampled_ll": [-2.933250904083252], "all_perturbed_original_ll": [-2.2177727222442627], "perturbed_sampled_ll": -2.933250904083252, "perturbed_original_ll": -2.2177727222442627, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import java.util.Scanner;\nclass Main{\n\tpublic static void main(String args[]){\n\t\tScanner sc = new Scanner(System.in);\n\t\tString point[]= new String[100];\n\t\tint rank[]= new int[30];\n\t\tint n = 0;\n\t\tint count=0;\n\t\twhile(sc.hasNext()){\n\t\t\tString get = sc.next();\n\t\t\tif(get.equals(\"0,0\"))break;\n\t\t\tString str[] = get.split(\",\");\n\t\t\tpoint[n = Integer.parseInt(str[0])]=str[1];\n\t\t\trank[n= Integer.parseInt(str[1])-1]++;\n\t\t}\n\t\twhile(sc.hasNext()){\n\t\t\tcount=1;\n\t\t\tn = sc.nextInt();\n\t\t\tfor(int i = 29 ;i > Integer.parseInt(point[n]);i--){\n\t\t\t\tif(rank[i]>0)count++;\n\t\t\t}\n\t\t\tSystem.out.println(count);\n\t\t}\n\t}\t\n}", "sampled": "import java.util.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        \n        Map<Integer, Integer> teamScores = new HashMap<>();\n        \n        while (true) {\n            String line = sc.nextLine();\n            String[] parts = line.split(\",\");\n            int teamId = Integer.parseInt(parts[0]);\n            int score = Integer.parseInt(parts[1]);\n            \n            if (teamId == 0 && score == 0) {\n                break;\n            }\n            \n            teamScores.put(teamId, score);\n        }\n        \n        List<Integer> sortedScores = new ArrayList<>(teamScores.values());\n        Collections.sort(sortedScores, Collections.reverseOrder());\n        \n        Map<Integer, Integer> scoreToRank = new HashMap<>();\n        int rank = 1;\n        for (int score : sortedScores) {\n            if (!scoreToRank.containsKey(score)) {\n                scoreToRank.put(score, rank);\n                rank++;\n            }\n        }\n        \n        while (sc.hasNextLine()) {\n            String line = sc.nextLine();\n            if (line.isEmpty()) break;\n            int queryTeam = Integer.parseInt(line.trim());\n            int score = teamScores.get(queryTeam);\n            int teamRank = scoreToRank.get(score);\n            System.out.println(teamRank);\n        }\n        \n        sc.close();\n    }\n}\n", "perturbed_sampled": [" { public static void  Integer> teamScores = new HashMap<>();  = sc.nextLine(); String[]  = Integer.parseInt(parts[0]); int score = Integer.parseInt(parts[1]); if (teamId == 0  break; } teamScores.put(teamId,  new ArrayList<>(teamScores.values());   score :  scoreToRank.put(score, rank); rank++; } } while (sc.hasNextLine()) { String   System.out.println(teamRank); } sc.close(); } }"], "perturbed_original": ["import java.util.Scanner; class .<extra_id_5>} } } new String[100]; int rank[]= new int[30]; int n = 0; int count=0;  rank[n= Integer.parseInt(str[1])-1]++; } while(sc.hasNext()){ count=1; n = sc.nextInt(); for(int  Integer.parseInt(point[n]);i--){  }"], "original_ll": -1.347314715385437, "sampled_ll": -0.5559727549552917, "all_perturbed_sampled_ll": [-2.8635032176971436], "all_perturbed_original_ll": [-3.460766077041626], "perturbed_sampled_ll": -2.8635032176971436, "perturbed_original_ll": -3.460766077041626, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "nums={}\nwhile True:\n    p,s=map(int,input().split(','))\n    if(p==0 and s==0):break\n    if not s in nums:\n        nums[s]=[]\n    nums[s].append(p)\n\nwhile True:\n    try:\n        q=int(input())\n        ans=len(nums)\n        for ns in nums.items():\n            if q in ns[1]:\n                print(ans)\n                break\n            ans-=1\n    except:\n        break", "sampled": "# Read team data\nteams = {}\nwhile True:\n    line = input().strip()\n    parts = line.split(',')\n    team_id = int(parts[0])\n    score = int(parts[1])\n    if team_id == 0 and score == 0:\n        break\n    teams[team_id] = score\n\n# Get unique scores and sort them in descending order\nunique_scores = sorted(set(teams.values()), reverse=True)\n\n# Create a mapping from score to rank\nscore_to_rank = {}\nfor i, score in enumerate(unique_scores):\n    score_to_rank[score] = i + 1\n\n# Process queries\nimport sys\nfor line in sys.stdin:\n    query = int(line.strip())\n    score = teams[query]\n    rank = score_to_rank[score]\n    print(rank)\n", "perturbed_sampled": ["# Read team data  line  team_id =  team_id ==  break teams[team_id]  scores and  from score to rank score_to_rank = {} for  =  queries  sys.stdin: query  rank = score_to_rank[score] print(rank)"], "perturbed_original": ["nums={} while True:  not s in  ns in  print(ans) break ans-=1 except: break"], "original_ll": -1.3176860809326172, "sampled_ll": -0.9851930141448975, "all_perturbed_sampled_ll": [-4.423159599304199], "all_perturbed_original_ll": [-5.3149871826171875], "perturbed_sampled_ll": -4.423159599304199, "perturbed_original_ll": -5.3149871826171875, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "#include <stdio.h>\n#include <string.h>\n#define N 100\n\nvoid hanten(char str[],int n){\n  char t;\n  int i,j;\n    for (j=0;j<n/2;j++){\n      t=str[j];\n      str[j]=str[n-j-1];\n      str[n-j-1]=t;\n    }\n}\n\nint main()\n{\n  int i,j,cnt=0;\n  char str1[N],str2[N];\n  while (scanf(\"%s\",str1)!=EOF){\n    strcpy(str2,str1);\n    hanten(str1,strlen(str1));\n    if (strcmp(str1,str2)==0)\n      cnt++;\n  }\n  printf(\"%d\\n\",cnt);\n\n  return 0;\n}", "sampled": "#include <stdio.h>\n#include <string.h>\n\nint isPalindrome(char *str) {\n    int len = strlen(str);\n    if (str[len-1] == '\\n') {\n        str[len-1] = '\\0';\n        len--;\n    }\n    \n    for (int i = 0; i < len / 2; i++) {\n        if (str[i] != str[len - 1 - i]) {\n            return 0;\n        }\n    }\n    return 1;\n}\n\nint main() {\n    char line[101];\n    int count = 0;\n    \n    while (fgets(line, sizeof(line), stdin) != NULL) {\n        if (isPalindrome(line)) {\n            count++;\n        }\n    }\n    \n    printf(\"%d\\n\", count);\n    \n    return 0;\n}\n", "perturbed_sampled": ["#include <stdio.h> #include <string.h> int isPalindrome(char *str) { int len =  < len  (str[i] != str[len -  1; }  int count = 0;   count++; } } printf(\"%d\\n\", count); return 0; }"], "perturbed_original": ["#include <stdio.h> #include <string.h>  str[],int n){ char t; int i,j; for  }  cnt++; } printf(\"%d\\n\",cnt); return 0; }"], "original_ll": -1.0074193477630615, "sampled_ll": -0.5331399440765381, "all_perturbed_sampled_ll": [-2.4865617752075195], "all_perturbed_original_ll": [-2.9113833904266357], "perturbed_sampled_ll": -2.4865617752075195, "perturbed_original_ll": -2.9113833904266357, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import java.util.*;\n\npublic class Main {\n    private static final Scanner scn = new Scanner(System.in);\n    \n    public static void main(String[] args) {\n        int cnt = 0;\n        while(scn.hasNext()) {\n            String str = scn.next();\n            String rev = new String(new StringBuilder(str).reverse());\n            if(str.equals(rev)) {\n                cnt++;\n            }\n        }\n        System.out.println(cnt);\n    }\n}", "sampled": "import java.util.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int count = 0;\n        \n        while (sc.hasNextLine()) {\n            String line = sc.nextLine();\n            if (isPalindrome(line)) {\n                count++;\n            }\n        }\n        \n        System.out.println(count);\n        sc.close();\n    }\n    \n    static boolean isPalindrome(String s) {\n        int left = 0;\n        int right = s.length() - 1;\n        \n        while (left < right) {\n            if (s.charAt(left) != s.charAt(right)) {\n                return false;\n            }\n            left++;\n            right--;\n        }\n        \n        return true;\n    }\n}\n", "perturbed_sampled": ["import java.util.*; public class Main { public static  while (sc.hasNextLine()) { String line = sc.nextLine();  0; int right = s.length() -  {  return false; } left++;  }"], "perturbed_original": ["import java.util.*; public class Main { private static final Scanner scn = new  args)  =   }"], "original_ll": -0.8267020583152771, "sampled_ll": -0.3024909496307373, "all_perturbed_sampled_ll": [-2.88559889793396], "all_perturbed_original_ll": [-4.032907962799072], "perturbed_sampled_ll": -2.88559889793396, "perturbed_original_ll": -4.032907962799072, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "# -*- coding: utf-8 -*-\n\nimport sys\n\ndef is_pal(s):\n    l = len(s)-1\n    for i in range(l/2):\n        if s[i] != s[l-1-i]:\n            return False\n    return True\n\ncount = 0\nfor line in sys.stdin:\n    if is_pal(line):\n        count += 1\nprint count", "sampled": "import sys\n\ncount = 0\nfor line in sys.stdin:\n    s = line.strip()\n    if s == s[::-1]:\n        count += 1\n\nprint(count)\n", "perturbed_sampled": ["import sys count = 0 for line in sys.stdin:  1 print(count)"], "perturbed_original": ["# -*- coding: utf-8 -*- import sys def is_pal(s): l ) return for line  += 1 print count"], "original_ll": -0.8122162222862244, "sampled_ll": -0.9955853223800659, "all_perturbed_sampled_ll": [-2.8059911727905273], "all_perturbed_original_ll": [-4.465446949005127], "perturbed_sampled_ll": -2.8059911727905273, "perturbed_original_ll": -4.465446949005127, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "#include <stdio.h>\n#include <ctype.h>\n\nint main()\n{\n        char str[81], tmp[6];\n        int num = 0, i, sum = 0;\n\n        while ( scanf( \"%s\", str ) == 1 ) {\n                i = 0;\n                while ( str[i] ) {\n                        if ( isdigit( str[i] ) ) {\n                                num = 0;\n                                while ( isdigit( str[i] ) ) {\n                                        num = 10 * num + ( str[i] - '0' );\n                                        i++;\n                                }\n                                sum = sum + num;\n                        } else {\n                                i++;\n                        }\n                }\n        }\n\n        printf( \"%d\\n\", sum );\n\n        return 0;\n}\n\n", "sampled": "#include <stdio.h>\n#include <ctype.h>\n\nint main() {\n    int sum = 0;\n    int num = 0;\n    int in_number = 0;\n    char c;\n    \n    while ((c = getchar()) != EOF) {\n        if (isdigit(c)) {\n            num = num * 10 + (c - '0');\n            in_number = 1;\n        } else {\n            if (in_number) {\n                sum += num;\n                num = 0;\n                in_number = 0;\n            }\n        }\n    }\n    \n    if (in_number) {\n        sum += num;\n    }\n    \n    printf(\"%d\\n\", sum);\n    \n    return 0;\n}\n", "perturbed_sampled": ["#include  {   =  { if (isdigit(c))  10 + (c - '0'); in_number = 1;  { sum += num; num = 0; in_number =  return 0; }"], "perturbed_original": ["#include <stdio.h>  char str[81], tmp[6]; int num =  while ( scanf( \"%s\", str  i = 0; while  ) {  * num + (  { i++; } } } printf( \"%d\\n\", sum ); return 0; }"], "original_ll": -0.9237989783287048, "sampled_ll": -0.4305321276187897, "all_perturbed_sampled_ll": [-3.022646903991699], "all_perturbed_original_ll": [-3.1086480617523193], "perturbed_sampled_ll": -3.022646903991699, "perturbed_original_ll": -3.1086480617523193, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import java.util.Scanner;\n\npublic class Main{\n\tpublic static void main(String[] args){\n\t\tScanner sc = new Scanner(System.in);\n\t\t\n\t\tint n = 0,sum = 0;\n\t\t\n\t\twhile(sc.hasNext()){\n\t\t\tchar[] ch = sc.next().toCharArray();\n\t\tfor(int i = 0; i < ch.length; i++){\n\t\t\tif('0' <= ch[i] && ch[i] <= '9'){\n\t\t\t\tn = n * 10;\n\t\t\t\tn += ch[i] - '0';\n\t\t\t}else{\n\t\t\t\tsum += n;\n\t\t\t\tn = 0;\n\t\t\t}\n\t\t}\n\t\tsum += n;\n\t\t}\n\t\tSystem.out.println(sum);\n\t\t\n\t\tsc.close();\n\t}\n}", "sampled": "import java.util.*;\nimport java.util.regex.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int sum = 0;\n        Pattern pattern = Pattern.compile(\"\\\\d+\");\n        \n        while (sc.hasNextLine()) {\n            String line = sc.nextLine();\n            Matcher matcher = pattern.matcher(line);\n            \n            while (matcher.find()) {\n                sum += Integer.parseInt(matcher.group());\n            }\n        }\n        \n        System.out.println(sum);\n        sc.close();\n    }\n}\n", "perturbed_sampled": [" class   pattern = Pattern.compile(\"\\\\d+\"); while (sc.hasNextLine()) { String  = pattern.matcher(line); while (matcher.find()) { sum += Integer.parseInt(matcher.group());  }"], "perturbed_original": [" public  int n = 0,sum = 0; while(sc.hasNext()){ char[] ch =  i  ch[i] &&  n * 10; n +=  0; } } sum +=  }"], "original_ll": -0.7045949697494507, "sampled_ll": -0.5067358016967773, "all_perturbed_sampled_ll": [-2.809391975402832], "all_perturbed_original_ll": [-3.408869743347168], "perturbed_sampled_ll": -2.809391975402832, "perturbed_original_ll": -3.408869743347168, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import re\nans = 0\nwhile True:\n    try:\n        line = input()\n    except:\n        print(ans)\n        break\n    ans += sum(map(int, re.findall(\"[0-9]+\", line)))", "sampled": "import sys\nimport re\n\ntotal = 0\nfor line in sys.stdin:\n    numbers = re.findall(r'\\d+', line)\n    for num in numbers:\n        total += int(num)\n\nprint(total)\n", "perturbed_sampled": ["import sys import re   line) for  int(num) print(total)"], "perturbed_original": [" while True: try: line = input()  sum(map(int, re.findall(\"[0-9]+\", line)))"], "original_ll": -1.2053115367889404, "sampled_ll": -0.8612873554229736, "all_perturbed_sampled_ll": [-6.641984462738037], "all_perturbed_original_ll": [-2.714601516723633], "perturbed_sampled_ll": -6.641984462738037, "perturbed_original_ll": -2.714601516723633, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "#include<stdio.h>\n#include<math.h>\n#include <stdlib.h>\n#include<string.h>\n#include<limits.h>\n#include<time.h>\n\nvoid sosu(int n){\n\tint i,j,num[n];\n\t\n\tfor(i=2;i<=n;i++)num[i]=i;\n\tfor(i=2;i<=sqrt(n);i++){\n\t\tfor(j=2;j*i<=n;j++)num[j*i]=0;\n\t}\n}\n\nint main(){\n\tint number[10000]={0};\n\tint ac[10000]={0};\n\tint i,j,k,count;\n\t\n\tfor(i=0;scanf(\"%d,%d\",&number[i],&ac[i])!=EOF;i++);\n\tfor(j=i;scanf(\"%d,%d\",&number[j],&ac[j])!=EOF;j++);\n\tcount=j;\n\t\n\tfor(i=0;i<count;i++){\n\t\tfor(j=0;j<count;j++){\n\t\t\tif(number[i]<number[j]){\n\t\t\t\tk=number[i];\n\t\t\t\tnumber[i]=number[j];\n\t\t\t\tnumber[j]=k;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tfor(i=0,k=0;i<count;i++){\n\t\tfor(j=i;j<count;j++){\n\t\t\tif(number[i]==number[j] && i!=j)k++;\n\t\t}\n\t\ti+=k;\n\t\tif(k>=1)printf(\"%d %d\\n\",number[i],k+1);\n\t\tk=0;\n\t}\n\t\nreturn 0;\n\n}", "sampled": "#include <stdio.h>\n#include <string.h>\n\nint main() {\n    int this_month[1001] = {0};\n    int last_month[1001] = {0};\n    int customer, day;\n    char line[100];\n    int reading_this_month = 1;\n    \n    while (fgets(line, sizeof(line), stdin)) {\n        if (line[0] == '\\n' || strlen(line) <= 1) {\n            reading_this_month = 0;\n            continue;\n        }\n        \n        if (sscanf(line, \"%d,%d\", &customer, &day) == 2) {\n            if (reading_this_month) {\n                this_month[customer]++;\n            } else {\n                last_month[customer]++;\n            }\n        }\n    }\n    \n    for (int i = 1; i <= 1000; i++) {\n        if (this_month[i] > 0 && last_month[i] > 0) {\n            printf(\"%d %d\\n\", i, this_month[i] + last_month[i]);\n        }\n    }\n    \n    return 0;\n}\n", "perturbed_sampled": ["#include <stdio.h> #include <string.h> int main()  1; while (fgets(line, sizeof(line), stdin))  || strlen(line) <=  \"%d,%d\",  if (reading_this_month) { this_month[customer]++; } else {  i <= 1000; i++) {  last_month[i] > 0) { printf(\"%d %d\\n\", i,  return 0; }"], "perturbed_original": ["#include<stdio.h> #include<math.h> #include <stdlib.h> #include<string.h> #include<limits.h> #include<time.h>   int ac[10000]={0}; int  number[j]=k; }   %d\\n\",number[i],k+1); k=0; } return 0; }"], "original_ll": -1.059664011001587, "sampled_ll": -0.7164496183395386, "all_perturbed_sampled_ll": [-2.9331448078155518], "all_perturbed_original_ll": [-2.4488368034362793], "perturbed_sampled_ll": -2.9331448078155518, "perturbed_original_ll": -2.4488368034362793, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import java.util.*;\nimport java.util.Map.Entry;\n\n//\u6587\u5b57\u64cd\u4f5c\nclass Main {\n\tScanner sc = new Scanner(System.in);\n\n\tpublic void run() {\n\t\tHashtable<Integer,Integer> data1=new Hashtable<Integer, Integer>();\n\t\tHashtable<Integer,Integer> data2=new Hashtable<Integer, Integer>();\n\n\t\twhile(sc.hasNext()){\n\t\t\tString[] str=sc.nextLine().split(\",\");\n\t\t\tif(\"\".equals(str[0]))break;\n\t\t\tint[] vals=new int[]{Integer.parseInt(str[0]),Integer.parseInt(str[1])};\n\t\t\tif(data1.containsKey(vals[0])){\n\t\t\t\tdata1.put(vals[0],data1.get(vals[0])+1);\n\t\t\t}else{\n\t\t\t\tdata1.put(vals[0],1);\n\t\t\t}\n\t\t}\n\t\twhile(sc.hasNext()){\n\t\t\tString[] str=sc.nextLine().split(\",\");\n\t\t\tif(\"\".equals(str[0]))break;\n\t\t\tint[] vals=new int[]{Integer.parseInt(str[0]),Integer.parseInt(str[1])};\n\t\t\tif(data2.containsKey(vals[0])){\n\t\t\t\tdata2.put(vals[0],data2.get(vals[0])+1);\n\t\t\t}else{\n\t\t\t\tdata2.put(vals[0],1);\n\t\t\t}\n\t\t}\n\t\tArrayList<Entry<Integer,Integer>> data1list=new ArrayList<Entry<Integer,Integer>>(data1.entrySet());\n\t\tCollections.sort(data1list,new Comparator<Entry<Integer,Integer>>() {\n\t\t\t@Override\n\t\t\tpublic int compare(Entry<Integer, Integer> o1,\n\t\t\t\t\tEntry<Integer, Integer> o2) {\n\t\t\t\treturn o1.getKey()-o2.getKey();\n\t\t\t}\n\t\t});\n\t\tfor(Entry<Integer,Integer> entry:data1list){\n\t\t\tif(data2.containsKey(entry.getKey())){\n\t\t\t\tln(entry.getKey()+\" \"+ (entry.getValue()+data2.get(entry.getKey())));\n\t\t\t}\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n\n\tpublic static void pr(Object o) {\n\t\tSystem.out.print(o);\n\t}\n\n\tpublic static void ln(Object o) {\n\t\tSystem.out.println(o);\n\t}\n\n\tpublic static void ln() {\n\t\tSystem.out.println();\n\t}\n}", "sampled": "import java.util.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        \n        Map<Integer, Integer> thisMonth = new HashMap<>();\n        Map<Integer, Integer> lastMonth = new HashMap<>();\n        \n        // Read this month's data\n        while (sc.hasNextLine()) {\n            String line = sc.nextLine();\n            if (line.trim().isEmpty()) {\n                break;\n            }\n            String[] parts = line.split(\",\");\n            int customer = Integer.parseInt(parts[0]);\n            thisMonth.put(customer, thisMonth.getOrDefault(customer, 0) + 1);\n        }\n        \n        // Read last month's data\n        while (sc.hasNextLine()) {\n            String line = sc.nextLine();\n            if (line.trim().isEmpty()) {\n                break;\n            }\n            String[] parts = line.split(\",\");\n            int customer = Integer.parseInt(parts[0]);\n            lastMonth.put(customer, lastMonth.getOrDefault(customer, 0) + 1);\n        }\n        \n        // Find customers in both months\n        Set<Integer> commonCustomers = new HashSet<>(thisMonth.keySet());\n        commonCustomers.retainAll(lastMonth.keySet());\n        \n        // Sort and output\n        List<Integer> sortedCustomers = new ArrayList<>(commonCustomers);\n        Collections.sort(sortedCustomers);\n        \n        for (int customer : sortedCustomers) {\n            int total = thisMonth.get(customer) + lastMonth.get(customer);\n            System.out.println(customer + \" \" + total);\n        }\n        \n        sc.close();\n    }\n}\n", "perturbed_sampled": ["import java.util.*; public  void   thisMonth  lastMonth = new HashMap<>(); // Read this month's  int customer  + 1); } // Read   }  customer  + 1); } // Find customers in both months Set<Integer>   sortedCustomers = new ArrayList<>(commonCustomers);  sortedCustomers) { int total = thisMonth.get(customer) + lastMonth.get(customer); System.out.println(customer  } sc.close(); } }"], "perturbed_original": ["import java.util.*; import java.util.Map.Entry; //\u6587\u5b57\u64cd\u4f5c class Main { Scanner sc = new Scanner(System.in);  data1=new Hashtable<Integer, <extra_id_3>long key;<extra_id_4>= \"<extra_id_5>//\u5b58\u5728\u7ae0\u8ba1\u7b97<extra_id_6>entry){<extra_id_7>return (data2.get(o1.getKey()).get(o2.getKey()).get() -<extra_id_8>{ return int.parseInt(val)); } }<extra_id_9>return<extra_id_10>private static Hashtable<Integer, data1=new Hashtable<Integer,<extra_id_11>return data  String[] str=sc.nextLine().split(\",\"); if(\"\".equals(str[0]))break;  }else{ data2.put(vals[0],1);  { return o1.getKey()-o2.getKey(); }  \"+ (entry.getValue()+data2.get(entry.getKey()))); } } } public static void main(String[]  o) { System.out.print(o); }   void ln() { System.out.println(); } }"], "original_ll": -0.6889062523841858, "sampled_ll": -0.44719964265823364, "all_perturbed_sampled_ll": [-3.356323480606079], "all_perturbed_original_ll": [-2.950883626937866], "perturbed_sampled_ll": -3.356323480606079, "perturbed_original_ll": -2.950883626937866, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import sys\nb=0\na=[{},{}]\nfor e in sys.stdin:\n if'\\n'==e:b=1\n else:c=int(e.split(',')[0]);a[b].setdefault(c,0);a[b][c]+=1\nfor k in sorted({*a[0]}&{*a[1]}):print(k,a[0][k]+a[1][k])\n", "sampled": "import sys\n\n# Read all input\nlines = []\nfor line in sys.stdin:\n    lines.append(line.strip())\n\n# Find the empty line that separates this month and last month\nseparator_idx = -1\nfor i, line in enumerate(lines):\n    if line == '':\n        separator_idx = i\n        break\n\n# Parse this month's data\nthis_month = lines[:separator_idx]\nlast_month = lines[separator_idx + 1:]\n\n# Count transactions for each customer\nthis_month_customers = {}\nlast_month_customers = {}\n\nfor line in this_month:\n    if line:\n        parts = line.split(',')\n        customer_id = int(parts[0])\n        this_month_customers[customer_id] = this_month_customers.get(customer_id, 0) + 1\n\nfor line in last_month:\n    if line:\n        parts = line.split(',')\n        customer_id = int(parts[0])\n        last_month_customers[customer_id] = last_month_customers.get(customer_id, 0) + 1\n\n# Find customers who appear in both months\ncommon_customers = set(this_month_customers.keys()) & set(last_month_customers.keys())\n\n# Calculate total transactions and sort by customer ID\nresults = []\nfor customer_id in common_customers:\n    total_transactions = this_month_customers[customer_id] + last_month_customers[customer_id]\n    results.append((customer_id, total_transactions))\n\nresults.sort()\n\n# Output\nfor customer_id, total in results:\n    print(customer_id, total)\n", "perturbed_sampled": [" input lines =  lines.append(line.strip()) # Find the empty  and last   # Count transactions for each customer this_month_customers = {} last_month_customers = {} for line in this_month: if line:  line: parts = line.split(',') customer_id  0) + 1 # Find customers who appear in both months  # Calculate total transactions  = this_month_customers[customer_id] + last_month_customers[customer_id]  for customer_id, total in results: print(customer_id, total)"], "perturbed_original": ["import sys b=0 a=[{},{}] for  for k in sorted({*a[0]}&{*a[1]}):print(k,a[0][k]+a[1][k])"], "original_ll": -2.024172067642212, "sampled_ll": -0.742479145526886, "all_perturbed_sampled_ll": [-3.0331475734710693], "all_perturbed_original_ll": [-2.8127708435058594], "perturbed_sampled_ll": -3.0331475734710693, "perturbed_original_ll": -2.8127708435058594, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "#include <stdio.h>\n\nchar map[16][16] = {0};\n\nvoid delete_island(int x, int y)\n{\n\tif (map[x][y] == 0) return;\n\tmap[x][y] = 0;\n\tdelete_island(x - 1, y);\n\tdelete_island(x + 1, y);\n\tdelete_island(x, y - 1);\n\tdelete_island(x, y + 1);\n}\n\nint main(void)\n{\n\twhile (scanf(\"%s\", &map[0][1]) != EOF){\n\t\tint i, j;\n\t\tint count = 0;\n\t\t\n\t\tfor (i = 1; i < 12; i++) scanf(\"%s\", &map[i][1]);\n\t\tfor (i = 0; i < 12; i++){\n\t\t\tfor (j = 0; j < 12; j++) map[i][j + 1] -= '0';\n\t\t}\n\t\t\n\t\tfor (i = 0; i < 12; i++){\n\t\t\tfor (j = 0; j < 12; j++){\n\t\t\t\tif (map[i][j + 1] == 1){\n\t\t\t\t\tcount++;\n\t\t\t\t\tdelete_island(i, j + 1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\", count);\n\t\tscanf(\"%*c\");\n\t}\n\t\n\treturn 0;\n}", "sampled": "#include <stdio.h>\n#include <string.h>\n\nint grid[12][12];\nint visited[12][12];\n\nvoid dfs(int i, int j) {\n    if (i < 0 || i >= 12 || j < 0 || j >= 12) return;\n    if (grid[i][j] == 0 || visited[i][j]) return;\n    \n    visited[i][j] = 1;\n    \n    dfs(i-1, j);\n    dfs(i+1, j);\n    dfs(i, j-1);\n    dfs(i, j+1);\n}\n\nint main() {\n    char line[100];\n    \n    while (1) {\n        int hasInput = 0;\n        \n        for (int i = 0; i < 12; i++) {\n            if (fgets(line, sizeof(line), stdin) == NULL) {\n                return 0;\n            }\n            \n            if (strlen(line) > 1 && line[0] != '\\n') {\n                hasInput = 1;\n                for (int j = 0; j < 12; j++) {\n                    grid[i][j] = line[j] - '0';\n                }\n            } else if (strlen(line) <= 1 || line[0] == '\\n') {\n                if (!hasInput) {\n                    i--;\n                    continue;\n                } else {\n                    return 0;\n                }\n            }\n        }\n        \n        if (!hasInput) break;\n        \n        memset(visited, 0, sizeof(visited));\n        \n        int islands = 0;\n        for (int i = 0; i < 12; i++) {\n            for (int j = 0; j < 12; j++) {\n                if (grid[i][j] == 1 && !visited[i][j]) {\n                    dfs(i, j);\n                    islands++;\n                }\n            }\n        }\n        \n        printf(\"%d\\n\", islands);\n        \n        while (fgets(line, sizeof(line), stdin) != NULL) {\n            if (line[0] != '\\n' && strlen(line) > 1) {\n                fseek(stdin, -(long)strlen(line), SEEK_CUR);\n                break;\n            }\n            if (feof(stdin)) return 0;\n        }\n        \n        if (feof(stdin)) break;\n    }\n    \n    return 0;\n}\n", "perturbed_sampled": ["#include <stdio.h> #include <string.h> int   (i  0 || j >= 12) return; if (grid[i][j] ==   = 0; for  < 12; i++)  == NULL) {  = 1; for (int j = 0;  grid[i][j] = line[j]  if (strlen(line)  '\\n') { if (!hasInput) {  return 0; } } }  (int j = 0; j < 12; j++) {  !visited[i][j]) {  (fgets(line, sizeof(line), stdin) != NULL) { if (line[0] !=  { fseek(stdin, -(long)strlen(line), SEEK_CUR); break; }  if (feof(stdin)) break; } return 0; }"], "perturbed_original": ["=<extra_id_6>3; i++){<extra_id_7>] ; } if<extra_id_8>==<extra_id_9>) || (map[i][j] ==<extra_id_10>1){<extra_id_11>{ return<extra_id_12>else if<extra_id_13>) {<extra_id_14>( (<extra_id_15>(map[i][j] == 1){<extra_id_16>(0<extra_id_17>* 0); } }<extra_id_18>( (map[x][y] == 0) return; map[x][y] = 0;  +  1); delete_island(x, y + 1); } int  != EOF){ int i,  for  12; i++) scanf(\"%s\", &map[i][1]); for (i =   0; i < 12; i++){   + 1] == 1){ count++; delete_island(i, j + 1); }  } return 0; }"], "original_ll": -0.6796762347221375, "sampled_ll": -0.502373218536377, "all_perturbed_sampled_ll": [-2.526163101196289], "all_perturbed_original_ll": [-2.342099666595459], "perturbed_sampled_ll": -2.526163101196289, "perturbed_original_ll": -2.342099666595459, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import java.util.Scanner;\n\npublic class Main {\n\n\tpublic static void main(String[] args) {\n\t\t// TODO \u81ea\u52d5\u751f\u6210\u3055\u308c\u305f\u30e1\u30bd\u30c3\u30c9\u30fb\u30b9\u30bf\u30d6\n\t\tnew Main().run();\n\t}\n\t\n\tint filed[][]=new int[12][12];\n\tvoid run(){\n\t\tScanner sc=new Scanner(System.in);\n\t\twhile(sc.hasNext()){\n\t\t\tint count=0;\n\t\t\t\n\t\t\tfor(int i=0;i<12;i++){\n\t\t\t\tchar ch[]=sc.next().toCharArray();\n\t\t\t\tfor(int j=0;j<12;j++){\n\t\t\t\t\tfiled[i][j]=ch[j]-'0';\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tfor(int i=0;i<12;i++){\n\t\t\t\tfor(int j=0;j<12;j++){\n\t\t\t\t\tif(filed[i][j]==1){\n\t\t\t\t\t\tcount++;\n\t\t\t\t\t\tdfs(j,i,12,12);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(count);\n\t\t}\n\t}\n\t\n    int mx[]={-1,0,1,0};\n    int my[]={0,-1,0,1};\n\tvoid dfs(int x,int y,int w,int h){\n        int i,nx,ny;\n        for(i=0;i<4;i++){\n            nx=x+mx[i];\n            ny=y+my[i];\n            if(0<=nx && nx<w && 0<=ny && ny<h && filed[ny][nx]!=0){\n                filed[ny][nx]=0;\n                dfs(nx,ny,w,h);\n            }\n        }\n    }\n\n}", "sampled": "import java.util.*;\n\npublic class Main {\n    static int[][] grid;\n    static boolean[][] visited;\n    static int[] dx = {-1, 1, 0, 0};\n    static int[] dy = {0, 0, -1, 1};\n    \n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        \n        while (sc.hasNextLine()) {\n            grid = new int[12][12];\n            visited = new boolean[12][12];\n            \n            // Read 12 lines for the grid\n            boolean validInput = true;\n            for (int i = 0; i < 12; i++) {\n                if (!sc.hasNextLine()) {\n                    validInput = false;\n                    break;\n                }\n                String line = sc.nextLine().trim();\n                if (line.isEmpty()) {\n                    validInput = false;\n                    break;\n                }\n                for (int j = 0; j < 12 && j < line.length(); j++) {\n                    grid[i][j] = line.charAt(j) - '0';\n                }\n            }\n            \n            if (!validInput) {\n                break;\n            }\n            \n            // Count islands\n            int islands = 0;\n            for (int i = 0; i < 12; i++) {\n                for (int j = 0; j < 12; j++) {\n                    if (grid[i][j] == 1 && !visited[i][j]) {\n                        dfs(i, j);\n                        islands++;\n                    }\n                }\n            }\n            \n            System.out.println(islands);\n            \n            // Skip empty line between datasets\n            if (sc.hasNextLine()) {\n                String line = sc.nextLine();\n                // If the line is not empty, we need to check if it's the start of next dataset\n                if (!line.trim().isEmpty()) {\n                    // This is the first line of next dataset\n                    grid = new int[12][12];\n                    visited = new boolean[12][12];\n                    \n                    // Process this first line\n                    for (int j = 0; j < 12 && j < line.length(); j++) {\n                        grid[0][j] = line.charAt(j) - '0';\n                    }\n                    \n                    // Read remaining 11 lines\n                    for (int i = 1; i < 12; i++) {\n                        if (!sc.hasNextLine()) break;\n                        line = sc.nextLine().trim();\n                        if (line.isEmpty()) break;\n                        for (int j = 0; j < 12 && j < line.length(); j++) {\n                            grid[i][j] = line.charAt(j) - '0';\n                        }\n                    }\n                    \n                    // Count islands\n                    islands = 0;\n                    for (int i = 0; i < 12; i++) {\n                        for (int j = 0; j < 12; j++) {\n                            if (grid[i][j] == 1 && !visited[i][j]) {\n                                dfs(i, j);\n                                islands++;\n                            }\n                        }\n                    }\n                    \n                    System.out.println(islands);\n                    \n                    // Skip empty line\n                    if (sc.hasNextLine()) {\n                        sc.nextLine();\n                    }\n                }\n            }\n        }\n        \n        sc.close();\n    }\n    \n    static void dfs(int x, int y) {\n        visited[x][y] = true;\n        \n        for (int i = 0; i < 4; i++) {\n            int nx = x + dx[i];\n            int ny = y + dy[i];\n            \n            if (nx >= 0 && nx < 12 && ny >= 0 && ny < 12 && \n                grid[nx][ny] == 1 && !visited[nx][ny]) {\n                dfs(nx, ny);\n            }\n        }\n    }\n}\n", "perturbed_sampled": ["  0, 0}; static int[] dy = {0, 0, -1, 1}; public  Scanner sc =  grid = new int[12][12];  Read 12 lines for the grid boolean validInput =  break; } String  break; } for (int j  && j   }  islands = 0; for (int i = 0; i  (int j = 0; j < 12; j++)  } System.out.println(islands);  is not empty,  it's the start of next dataset if (!line.trim().isEmpty()) { // This is the first line  new boolean[12][12]; // Process this first  0;  (int i = 1;  break; for (int j = 0; j <  j++) { grid[i][j] = line.charAt(j)  Count islands islands = 0; for (int i = 0; i < 12; i++) { for (int j =  1 && !visited[i][j]) {  }  if (sc.hasNextLine()) { sc.nextLine(); } } }  { visited[x][y] =  0;  +  + dy[i]; if (nx  1 && !visited[nx][ny]) {  }"], "perturbed_original": ["import java.util.Scanner; public class Main { public static void main(String[] args) { //  int  } } for(int i=0;i<12;i++){ for(int  my[]={0,-1,0,1};  h){  if(0<=nx && nx<w  filed[ny][nx]!=0){ filed[ny][nx]=0; dfs(nx,ny,w,h); } } } }"], "original_ll": -0.8550409078598022, "sampled_ll": -0.4221113920211792, "all_perturbed_sampled_ll": [-2.4120640754699707], "all_perturbed_original_ll": [-2.5552663803100586], "perturbed_sampled_ll": -2.4120640754699707, "perturbed_original_ll": -2.5552663803100586, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "class Depth_First_Search_stack:\n    def __init__(self, map):\n        self.map = map\n        self.num_island = 0\n        self.stack = []\n        self.start_point = None\n\n    def get_start_point(self):\n        get_start = False\n        for i in range(12):\n            for j in range(12):\n                if self.map[i][j] == '1':\n                    self.start_point = [i, j]\n                    get_start = True\n        return get_start\n\n    def check(self, new_r, new_c):\n        return 0<=new_r<12 and 0<=new_c<12 and self.map[new_r][new_c] == '1'\n\n    def search(self, r, c):\n        while self.stack:\n            r, c = self.stack.pop()\n            self.map[r][c] = '0'\n            for (i, j) in [[1, 0], [0, 1], [-1, 0], [0, -1]]:\n                if self.check(r+i, c+j):\n                    self.stack.append([r+i, c+j])\n\n    def run(self):\n        while self.get_start_point():\n            r, c = self.start_point\n            self.stack.append([r, c])\n            self.search(r, c)\n            self.num_island += 1\n\nif __name__ == '__main__':\n    while 1:\n        map = []\n        for i in range(12):\n            row = [x for x in input()]\n            map.append(row)\n\n        if len(map[0]) != 12:\n            break\n\n        DFS = Depth_First_Search_stack(map)\n        DFS.run()\n        print(DFS.num_island)\n\n        empty = input()", "sampled": "import sys\nfrom collections import deque\n\ndef count_islands(grid):\n    rows = 12\n    cols = 12\n    visited = [[False] * cols for _ in range(rows)]\n    count = 0\n    \n    def bfs(start_r, start_c):\n        queue = deque([(start_r, start_c)])\n        visited[start_r][start_c] = True\n        \n        while queue:\n            r, c = queue.popleft()\n            # Check 4 directions: up, down, left, right\n            for dr, dc in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n                nr, nc = r + dr, c + dc\n                if 0 <= nr < rows and 0 <= nc < cols and not visited[nr][nc] and grid[nr][nc] == 1:\n                    visited[nr][nc] = True\n                    queue.append((nr, nc))\n    \n    for i in range(rows):\n        for j in range(cols):\n            if grid[i][j] == 1 and not visited[i][j]:\n                bfs(i, j)\n                count += 1\n    \n    return count\n\ndef main():\n    lines = []\n    for line in sys.stdin:\n        lines.append(line.rstrip('\\n'))\n    \n    datasets = []\n    current_dataset = []\n    \n    for line in lines:\n        if line == '':\n            if current_dataset:\n                datasets.append(current_dataset)\n                current_dataset = []\n        else:\n            current_dataset.append(line)\n    \n    if current_dataset:\n        datasets.append(current_dataset)\n    \n    for dataset in datasets:\n        grid = []\n        for line in dataset:\n            row = [int(c) for c in line]\n            grid.append(row)\n        \n        result = count_islands(grid)\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "perturbed_sampled": ["import sys from collections import deque  for _ in range(rows)] count = 0 def bfs(start_r, start_c): queue = deque([(start_r, start_c)]) visited[start_r][start_c]   4 directions:  nc =   <=   range(cols): if grid[i][j] == 1 and  += 1 return count def  line in sys.stdin: lines.append(line.rstrip('\\n')) datasets = [] current_dataset = [] for  datasets.append(current_dataset) current_dataset = [] else:  dataset  for line in dataset: row = [int(c) for  =  \"__main__\": main()"], "perturbed_original": ["class Depth_First_Search_stack: def __init__(self, map): self.map =     self.map[i][j] == '1': self.start_point =  return get_start def  and 0<=new_c<12 and self.map[new_r][new_c] == '1' def  self.map[r][c] =  [[1, 0], [0, 1], [-1, 0], [0,   self.num_island += 1 if __name__ == '__main__': while 1:  [x for  len(map[0]) != 12:  print(DFS.num_island) empty = input()"], "original_ll": -0.721847653388977, "sampled_ll": -0.3918014466762543, "all_perturbed_sampled_ll": [-2.9755711555480957], "all_perturbed_original_ll": [-2.9622182846069336], "perturbed_sampled_ll": -2.9755711555480957, "perturbed_original_ll": -2.9622182846069336, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "#include <stdio.h>\n#include <stdlib.h>\n\ntypedef struct {\n\tdouble x,y;\n} xy_t;\n\nint qsort_comp(const void* x,const void* y) {\n\tconst xy_t* a=(const xy_t*)x;\n\tconst xy_t* b=(const xy_t*)y;\n\tif((a->x)>(b->x))return 1;\n\tif((a->x)<(b->x))return -1;\n\tif((a->y)>(b->y))return 1;\n\tif((a->y)<(b->y))return -1;\n\treturn 0;\n}\n\nint zahyou_num;\nxy_t zahyou[100];\n\nint th_up_n;\nint th_down_n;\nxy_t th_up[100];\nxy_t th_down[100];\n\nint main(void) {\n\tint i;\n\twhile(1) {\n\t\tscanf(\"%d\",&zahyou_num);\n\t\tif(zahyou_num==0)break;\n\t\tfor(i=0;i<zahyou_num;i++) {\n\t\t\tscanf(\"%lf,%lf\",&zahyou[i].x,&zahyou[i].y);\n\t\t}\n\t\tqsort(zahyou,zahyou_num,sizeof(xy_t),qsort_comp);\n\t\t//sita no totu-ho\n\t\tth_down_n=1;\n\t\tth_down[0].x=zahyou[0].x;\n\t\tth_down[0].y=zahyou[0].y;\n\t\tfor(i=1;i<zahyou_num;i++) {\n\t\t\t//if(zahyou[i].y<th_down[th_down_n-1].y) {\n\t\t\t\twhile(th_down_n>1) {\n\t\t\t\t\tdouble k1,k2;\n\t\t\t\t\tif(zahyou[i].x==th_down[th_down_n-1].x) {\n\t\t\t\t\t\t//INF\n\t\t\t\t\t\tif(zahyou[i].y<th_down[th_down_n-1].y) {\n\t\t\t\t\t\t\tk1=-1e+200;\n\t\t\t\t\t\t} else if(zahyou[i].y>th_down[th_down_n-1].y) {\n\t\t\t\t\t\t\tk1=1e+200;\n\t\t\t\t\t\t} else k1=0;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tk1=(zahyou[i].y-th_down[th_down_n-1].y)/\n\t\t\t\t\t\t   (zahyou[i].x-th_down[th_down_n-1].x);\n\t\t\t\t\t}\n\t\t\t\t\tif(th_down[th_down_n-1].x==th_down[th_down_n-2].x) {\n\t\t\t\t\t\t//INF\n\t\t\t\t\t\tif(th_down[th_down_n-1].y<th_down[th_down_n-2].y) {\n\t\t\t\t\t\t\tk2=-1e+200;\n\t\t\t\t\t\t} else if(th_down[th_down_n-1].y>th_down[th_down_n-2].y) {\n\t\t\t\t\t\t\tk2=1e+200;\n\t\t\t\t\t\t} else k2=0;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tk2=(th_down[th_down_n-1].y-th_down[th_down_n-2].y)/\n\t\t\t\t\t\t   (th_down[th_down_n-1].x-th_down[th_down_n-2].x);\n\t\t\t\t\t}\n\t\t\t\t\tif(k1>=k2)break;\n\t\t\t\t\tth_down_n--;\n\t\t\t\t}\n\t\t\t//}\n\t\t\tth_down[th_down_n].x=zahyou[i].x;\n\t\t\tth_down[th_down_n].y=zahyou[i].y;\n\t\t\tth_down_n++;\n\t\t}\n\t\t//ue no totu-ho\n\t\tth_up_n=1;\n\t\tth_up[0].x=zahyou[zahyou_num-1].x;\n\t\tth_up[0].y=zahyou[zahyou_num-1].y;\n\t\tfor(i=zahyou_num-2;i>=0;i--) {\n\t\t\t//if(zahyou[i].y>th_up[th_up_n-1].y) {\n\t\t\t\twhile(th_up_n>1) {\n\t\t\t\t\tdouble k1,k2;\n\t\t\t\t\tif(zahyou[i].x==th_up[th_up_n-1].x) {\n\t\t\t\t\t\t//INF\n\t\t\t\t\t\tif(zahyou[i].y<th_up[th_up_n-1].y) {\n\t\t\t\t\t\t\tk1=1e+200;\n\t\t\t\t\t\t} else if(zahyou[i].y>th_up[th_up_n-1].y) {\n\t\t\t\t\t\t\tk1=-1e+200;\n\t\t\t\t\t\t} else k1=0;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tk1=(zahyou[i].y-th_up[th_up_n-1].y)/\n\t\t\t\t\t\t   (zahyou[i].x-th_up[th_up_n-1].x);\n\t\t\t\t\t}\n\t\t\t\t\tif(th_up[th_up_n-1].x==th_up[th_up_n-2].x) {\n\t\t\t\t\t\t//INF\n\t\t\t\t\t\tif(th_up[th_up_n-1].y<th_up[th_up_n-2].y) {\n\t\t\t\t\t\t\tk2=1e+200;\n\t\t\t\t\t\t} else if(th_up[th_up_n-1].y>th_up[th_up_n-2].y) {\n\t\t\t\t\t\t\tk2=-1e+200;\n\t\t\t\t\t\t} else k2=0;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tk2=(th_up[th_up_n-1].y-th_up[th_up_n-2].y)/\n\t\t\t\t\t\t   (th_up[th_up_n-1].x-th_up[th_up_n-2].x);\n\t\t\t\t\t}\n\t\t\t\t\tif(k1>=k2)break;\n\t\t\t\t\tth_up_n--;\n\t\t\t\t}\n\t\t\t//}\n\t\t\tth_up[th_up_n].x=zahyou[i].x;\n\t\t\tth_up[th_up_n].y=zahyou[i].y;\n\t\t\tth_up_n++;\n\t\t}\n\t\tprintf(\"%d\\n\",zahyou_num-(th_down_n+th_up_n-2));\n\t}\n\treturn 0;\n}", "sampled": "#include <stdio.h>\n#include <math.h>\n\ntypedef struct {\n    double x, y;\n} Point;\n\ndouble cross(Point O, Point A, Point B) {\n    return (A.x - O.x) * (B.y - O.y) - (A.y - O.y) * (B.x - O.x);\n}\n\nint convexHull(Point points[], int n, int hull[]) {\n    int k = 0;\n    \n    // Find bottommost point (or leftmost in case of tie)\n    int minIdx = 0;\n    for (int i = 1; i < n; i++) {\n        if (points[i].y < points[minIdx].y || \n            (points[i].y == points[minIdx].y && points[i].x < points[minIdx].x)) {\n            minIdx = i;\n        }\n    }\n    \n    // Start from bottommost point\n    int current = minIdx;\n    do {\n        hull[k++] = current;\n        int next = 0;\n        for (int i = 0; i < n; i++) {\n            if (i == current) continue;\n            \n            if (next == current) {\n                next = i;\n            } else {\n                double cp = cross(points[current], points[next], points[i]);\n                if (cp < 0 || (cp == 0 && \n                    (pow(points[i].x - points[current].x, 2) + pow(points[i].y - points[current].y, 2)) >\n                    (pow(points[next].x - points[current].x, 2) + pow(points[next].y - points[current].y, 2)))) {\n                    next = i;\n                }\n            }\n        }\n        current = next;\n    } while (current != minIdx);\n    \n    return k;\n}\n\nint main() {\n    int n;\n    while (scanf(\"%d\", &n) == 1 && n != 0) {\n        Point points[100];\n        for (int i = 0; i < n; i++) {\n            scanf(\"%lf,%lf\", &points[i].x, &points[i].y);\n        }\n        \n        if (n == 3) {\n            printf(\"0\\n\");\n            continue;\n        }\n        \n        int hull[100];\n        int hullSize = convexHull(points, n, hull);\n        \n        printf(\"%d\\n\", n - hullSize);\n    }\n    \n    return 0;\n}\n", "perturbed_sampled": ["#include <stdio.h> #include  x, y;   return (A.x - O.x) * (B.y - O.y) - (A.y  = 0; // Find bottommost point (or leftmost in case of tie) int minIdx = 0;  { if (points[i].y  points[minIdx].x))  } // Start from  minIdx; do { hull[k++] =  for (int i  i++) {  if (next == current) { next =  cp = cross(points[current],  0 || (cp == 0 && (pow(points[i].x - points[current].x, 2) + pow(points[i].y  { next  while (current   for (int i =   if (n == 3)  convexHull(points, n, hull); printf(\"%d\\n\",  0; }"], "perturbed_original": ["#include <stdio.h>  double x,y; } xy_t; int qsort_comp(const void* x,const  if((a->x)<(b->x))return -1; if((a->y)>(b->y))return 1; if((a->y)<(b->y))return -1; return 0; } int zahyou_num; xy_t zahyou[100]; int th_up_n; int th_down_n; xy_t  { int i; while(1) { scanf(\"%d\",&zahyou_num); if(zahyou_num==0)break; for(i=0;i<zahyou_num;i++) { scanf(\"%lf,%lf\",&zahyou[i].x,&zahyou[i].y); } qsort(zahyou,zahyou_num,sizeof(xy_t),qsort_comp); //sita no totu-ho th_down_n=1;  {  k1=-1e+200; } else if(zahyou[i].y>th_down[th_down_n-1].y) { k1=1e+200; }  th_down[th_down_n].y=zahyou[i].y; th_down_n++;  th_up[0].x=zahyou[zahyou_num-1].x; th_up[0].y=zahyou[zahyou_num-1].y; for(i=zahyou_num-2;i>=0;i--)  //INF if(zahyou[i].y<th_up[th_up_n-1].y) { k1=1e+200;  } else  (zahyou[i].x-th_up[th_up_n-1].x); } if(th_up[th_up_n-1].x==th_up[th_up_n-2].x)   } else k2=0;  } if(k1>=k2)break; th_up_n--; }  }"], "original_ll": -0.4097282290458679, "sampled_ll": -0.5593058466911316, "all_perturbed_sampled_ll": [-2.912869453430176], "all_perturbed_original_ll": [-1.5021438598632812], "perturbed_sampled_ll": -2.912869453430176, "perturbed_original_ll": -1.5021438598632812, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import java.util.Scanner;\n\npublic class Main {\n\t\n\tScanner sc;\n\t\n\tclass Point{\n\t\tpublic double x,y;\n\t\t\n\t\tpublic String toString(){\n\t\t\treturn \"(\"+x+\",\"+y+\")\";\n\t\t}\n\t\t\n\t\tpublic Point(double x,double y){\n\t\t\tthis.x=x;\n\t\t\tthis.y=y;\n\t\t}\n\t}\n\t\n\tdouble getTheta(Point p,Point p0){\n\t\tdouble theta=Math.acos((p.x-p0.x)/Math.hypot(p.x-p0.x,p.y-p0.y));\n\t\tif(p.y<p0.y)theta=Math.PI*2-theta;\n\t\treturn theta;\n\t}\n\t\n\tint solve(Point[] points){\n\t\tPoint start=points[0];\n\t\tfor(Point v:points){\n\t\t\tif(v.y<start.y)start=v;\n\t\t}\n\t\tPoint p0=start;\n\t\tint n=0;\n\t\tdouble prev=0;\n\t\tdo{\n\t\t\tdouble min=Math.PI*3;\n\t\t\tPoint next=p0;\n\t\t\tfor(Point p: points){\n\t\t\t\tdouble theta=getTheta(p,p0);\n\t\t\t\tif(theta>=prev&&theta<min){\n\t\t\t\t\tmin=theta;\n\t\t\t\t\tnext=p;\n\t\t\t\t}\n\t\t\t}\n\t\t\tp0=next;\n\t\t\tprev=min;\n\t\t\t++n;\n\t\t}while(p0!=start);\n\t\treturn points.length-n;\n\t}\n\t\n\tdouble nd(){\n\t\treturn sc.nextDouble();\n\t}\n\t\n\tint ni(){\n\t\treturn sc.nextInt();\n\t}\n\t\n\tvoid io(){\n\t\tsc=new Scanner(System.in).useDelimiter(\",|\\r\\n|\\n\");\n\t\t\n\t\tint n;\n\t\tPoint[] points;\n\t\twhile((n=ni())!=0){\n\t\t\tpoints=new Point[n];\n\t\t\tfor(int i=0;i<n;++i){\n\t\t\t\tpoints[i]=new Point(nd(),nd());\n\t\t\t}\n\t\t\tSystem.out.println(solve(points));\n\t\t}\n\t\tsc.close();\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\t// TODO Auto-generated method stub\n\t\tnew Main().io();\n\t}\n}", "sampled": "import java.util.*;\nimport java.io.*;\n\npublic class Main {\n    static class Point {\n        double x, y;\n        Point(double x, double y) {\n            this.x = x;\n            this.y = y;\n        }\n    }\n    \n    public static void main(String[] args) throws IOException {\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        String line;\n        \n        while ((line = br.readLine()) != null) {\n            int n = Integer.parseInt(line.trim());\n            if (n == 0) break;\n            \n            Point[] points = new Point[n];\n            for (int i = 0; i < n; i++) {\n                String[] parts = br.readLine().trim().split(\",\");\n                double x = Double.parseDouble(parts[0]);\n                double y = Double.parseDouble(parts[1]);\n                points[i] = new Point(x, y);\n            }\n            \n            List<Integer> hull = convexHull(points);\n            System.out.println(n - hull.size());\n        }\n    }\n    \n    static List<Integer> convexHull(Point[] points) {\n        int n = points.length;\n        if (n < 3) {\n            List<Integer> result = new ArrayList<>();\n            for (int i = 0; i < n; i++) result.add(i);\n            return result;\n        }\n        \n        // Find the bottommost point (or leftmost in case of tie)\n        int start = 0;\n        for (int i = 1; i < n; i++) {\n            if (points[i].y < points[start].y || \n                (points[i].y == points[start].y && points[i].x < points[start].x)) {\n                start = i;\n            }\n        }\n        \n        List<Integer> hull = new ArrayList<>();\n        int current = start;\n        \n        do {\n            hull.add(current);\n            int next = (current + 1) % n;\n            \n            for (int i = 0; i < n; i++) {\n                if (i == current) continue;\n                double cross = crossProduct(points[current], points[next], points[i]);\n                if (cross > 0) {\n                    next = i;\n                } else if (cross == 0) {\n                    // Collinear points - choose the farthest one\n                    if (distance(points[current], points[i]) > distance(points[current], points[next])) {\n                        next = i;\n                    }\n                }\n            }\n            \n            current = next;\n        } while (current != start);\n        \n        return hull;\n    }\n    \n    static double crossProduct(Point o, Point a, Point b) {\n        return (a.x - o.x) * (b.y - o.y) - (a.y - o.y) * (b.x - o.x);\n    }\n    \n    static double distance(Point a, Point b) {\n        double dx = a.x - b.x;\n        double dy = a.y - b.y;\n        return dx * dx + dy * dy;\n    }\n}\n", "perturbed_sampled": ["import java.util.*; import java.io.*;  class Point { double  y) {  y;  { BufferedReader br = new BufferedReader(new InputStreamReader(System.in)); String line; while ((line = br.readLine()) != null) { int n = Integer.parseInt(line.trim());  Point[] points = new Point[n]; for (int i = 0; i < n; i++) { String[] parts =  points[i] = new Point(x,  convexHull(points); System.out.println(n - hull.size()); } } static List<Integer> convexHull(Point[] points) {  result; }  (or leftmost in case of  i++) { if (points[i].y < points[start].y ||  =  current = start; do { hull.add(current); int next = (current  (int i =  = crossProduct(points[current], points[next],  }  { // Collinear  next  while  } static double crossProduct(Point o, Point a, Point b) { return (a.x - o.x) * (b.y -     dy; } }"], "perturbed_original": ["import  Scanner sc; class Point{ public double  x,double y){ this.x=x; this.y=y; } }  theta=Math.acos((p.x-p0.x)/Math.hypot(p.x-p0.x,p.y-p0.y)); if(p.y<p0.y)theta=Math.PI*2-theta; return  Point start=points[0];  prev=0; do{ double min=Math.PI*3; Point next=p0; for(Point p: points){ double theta=getTheta(p,p0);  p0=next; prev=min; ++n; }while(p0!=start); return points.length-n;  Point[] points;  points[i]=new Point(nd(),nd()); } System.out.println(solve(points)); } sc.close(); }   }"], "original_ll": -0.9743269681930542, "sampled_ll": -0.4412460923194885, "all_perturbed_sampled_ll": [-2.4912757873535156], "all_perturbed_original_ll": [-2.695741891860962], "perturbed_sampled_ll": -2.4912757873535156, "perturbed_original_ll": -2.695741891860962, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "def f(x,y,x1,y1,x2,y2):\n    if x1 <= x2:\n        return (x2-x1)*y-(y2-y1)*x+x1*y2-x2*y1\n    else:\n        return -((x2-x1)*y-(y2-y1)*x+x1*y2-x2*y1)\n\ndef DC(a):\n    if len(a) > 3:\n        # Divide\n        la = a[:len(a)/2]\n        ra = a[len(a)/2:]\n        # Conquer\n        la,ra = DC(la),DC(ra)\n        while f(ra[1][0],ra[1][1],la[-1][0],la[-1][1],ra[0][0],ra[0][1]) > 0 and len(ra) > 1:\n            ra.pop(0)\n        while f(la[-2][0],la[-2][1],ra[0][0],ra[0][1],la[-1][0],la[-1][1]) > 0 and len(la) > 1:\n            la.pop(-1)\n        return la+ra\n    else:\n        return a\n\nwhile True:\n    n = int(raw_input())\n    if n == 0:\n        break\n    p = []\n    for i in range(n):\n        p.append(map(float, raw_input().split(\",\")))\n    p = sorted(p, key = lambda x: x[0])\n    print n - len(DC(p))", "sampled": "def cross(o, a, b):\n    return (a[0] - o[0]) * (b[1] - o[1]) - (a[1] - o[1]) * (b[0] - o[0])\n\ndef convex_hull(points):\n    points = sorted(points)\n    if len(points) <= 1:\n        return points\n    \n    lower = []\n    for p in points:\n        while len(lower) >= 2 and cross(lower[-2], lower[-1], p) <= 0:\n            lower.pop()\n        lower.append(p)\n    \n    upper = []\n    for p in reversed(points):\n        while len(upper) >= 2 and cross(upper[-2], upper[-1], p) <= 0:\n            upper.pop()\n        upper.append(p)\n    \n    return lower[:-1] + upper[:-1]\n\nwhile True:\n    n = int(input())\n    if n == 0:\n        break\n    \n    points = []\n    for _ in range(n):\n        line = input().strip()\n        x, y = map(float, line.split(','))\n        points.append((x, y))\n    \n    hull = convex_hull(points)\n    hull_set = set(hull)\n    \n    count = 0\n    for p in points:\n        if p not in hull_set:\n            count += 1\n    \n    print(count)\n", "perturbed_sampled": [" (a[0] - o[0]) *  -  sorted(points) if len(points) <=  p) <= 0: lower.pop() lower.append(p)  in reversed(points): while len(upper) >= 2 and  + upper[:-1] while True:  == 0: break points  range(n):  y)) hull  count =  if p not in hull_set: count += 1 print(count)"], "perturbed_original": ["def f(x,y,x1,y1,x2,y2): if x1 <= x2: return   # Divide la = a[:len(a)/2]  la,ra = DC(la),DC(ra) while f(ra[1][0],ra[1][1],la[-1][0],la[-1][1],ra[0][0],ra[0][1]) > 0 and len(ra) >   la.pop(-1) return la+ra    = sorted(p, key = lambda  len(DC(p))"], "original_ll": -0.9147688746452332, "sampled_ll": -0.5048861503601074, "all_perturbed_sampled_ll": [-3.841045618057251], "all_perturbed_original_ll": [-3.1204724311828613], "perturbed_sampled_ll": -3.841045618057251, "perturbed_original_ll": -3.1204724311828613, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "#include <stdio.h>\n#include <string.h>\n\nint i, j;\nint flag;\nint n;\nint m;\nint atari;\nint d;\nchar amida[11][31];\nint temp[10], keep[10];\n\nint check_amida(void){\n\tint k, l;\n\tfor (k = 0; k < d; k++){\n\t\tfor (l = 0; l < n - 1; l++){\n\t\t\tif (amida[k][l] == '1'){\n\t\t\t\ttemp[l] += temp[l + 1];\n\t\t\t\ttemp[l + 1] = temp[l] - temp[l + 1];\n\t\t\t\ttemp[l] -= temp[l + 1];\n\t\t\t}\n\t\t}\n\t}\n\tif (temp[atari - 1] == m){\n\t\treturn (1);\n\t}\n\telse {\n\t\treturn (0);\n\t}\n}\n\nint ins_amida(int a, int b){\n\tint res;\n\tamida[a][b] = '1';\n\tres = check_amida();\n\tamida[a][b] = '0';\n\t\n\treturn (res);\n}\n\nint main(void)\n{\n\twhile (1){\n\t\tscanf(\"%d\", &n);\n\t\t\n\t\tif (!n){\n\t\t\tbreak;\n\t\t}\n\t\t\n\t\tfor (i = 0; i < n; i++){\n\t\t\ttemp[i] = i + 1;\n\t\t\tkeep[i] = i + 1;\n\t\t}\n\t\t\n\t\tscanf(\"%d\", &m);\n\t\tscanf(\"%d\", &atari);\n\t\tscanf(\"%d\", &d);\n\t\t\n\t\tfor (i = 0; i < d; i++){\n\t\t\tscanf(\"%s\", amida[i]);\n\t\t\tgetchar();\n\t\t}\n\t\t\n\t\tflag = 0;\n\t\t\n\t\tif (check_amida() == 1){\n\t\t\tprintf(\"0\\n\");\n\t\t\tflag = 1;\n\t\t}\n\t\tif (flag == 0){\n\t\t\tfor (i = 0; i < d; i++){\n\t\t\t\tfor (j = 0; j < n - 1; j++){\n\t\t\t\t\tmemcpy(temp, keep, sizeof(keep));\n\t\t\t\t\tif (amida[i][j] == '1'){\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tif (j > 0){\n\t\t\t\t\t\tif (amida[i][j - 1] == '1'){\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (j != n - 2){\n\t\t\t\t\t\tif (amida[i][j + 1] == '1'){\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (ins_amida(i, j) == 1){\n\t\t\t\t\t\tprintf(\"%d %d\\n\", i + 1, j + 1);\n\t\t\t\t\t\tflag = 1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (flag == 1){\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (flag == 0){\n\t\t\tprintf(\"1\\n\");\n\t\t}\n\t}\n\treturn (0);\n}", "sampled": "#include <stdio.h>\n#include <string.h>\n\nint n, m, target, d;\nint amida[31][10];\n\nint trace(int start, int skipRow, int skipCol) {\n    int pos = start;\n    for (int row = 1; row <= d; row++) {\n        if (row == skipRow && skipCol == pos && amida[row][pos] == 0) {\n            pos++;\n        } else if (row == skipRow && skipCol == pos - 1 && amida[row][pos - 1] == 0) {\n            pos--;\n        } else if (pos > 1 && amida[row][pos - 1] == 1) {\n            pos--;\n        } else if (pos < n && amida[row][pos] == 1) {\n            pos++;\n        }\n    }\n    return pos;\n}\n\nint canAdd(int row, int col) {\n    if (amida[row][col] == 1) return 0;\n    if (col > 1 && amida[row][col - 1] == 1) return 0;\n    if (col < n - 1 && amida[row][col + 1] == 1) return 0;\n    return 1;\n}\n\nint main() {\n    while (1) {\n        scanf(\"%d\", &n);\n        if (n == 0) break;\n        \n        scanf(\"%d\", &m);\n        scanf(\"%d\", &target);\n        scanf(\"%d\", &d);\n        \n        for (int i = 1; i <= d; i++) {\n            char line[11];\n            scanf(\"%s\", line);\n            for (int j = 0; j < n - 1; j++) {\n                amida[i][j + 1] = line[j] - '0';\n            }\n        }\n        \n        int result = trace(m, -1, -1);\n        if (result == target) {\n            printf(\"0\\n\");\n            continue;\n        }\n        \n        int found = 0;\n        for (int row = 1; row <= d && !found; row++) {\n            for (int col = 1; col < n && !found; col++) {\n                if (canAdd(row, col)) {\n                    int res = trace(m, row, col);\n                    if (res == target) {\n                        printf(\"%d %d\\n\", row, col);\n                        found = 1;\n                    }\n                }\n            }\n        }\n        \n        if (!found) {\n            printf(\"1\\n\");\n        }\n    }\n    \n    return 0;\n}\n", "perturbed_sampled": ["#include <extra_id_12>+=(n | 1) !=<extra_id_13>0<extra_id_14>{ printf(\"1\\n\"); return<extra_id_15>j; } case<extra_id_16>1; break ; case<extra_id_17>3; if (col<extra_id_18>row == skipRow &&<extra_id_19>(int row  for (int row = 1; row <= d; row++) { if (row == skipRow && skipCol == pos && amida[row][pos] == 0) { pos++;  amida[row][pos -  > 1 && amida[row][pos - 1]  }  row, int  1) return 0; if (col > 1 && amida[row][col - 1] == 1) return 0; if (col < n - 1 && amida[row][col + 1] ==  while (1) { scanf(\"%d\", &n); if (n ==  (int i =   0; j < n - 1;   trace(m,  target) { printf(\"0\\n\");  0; for (int row = 1; row <=  for (int  { if (canAdd(row, col)) { int   } return 0; }"], "perturbed_original": ["#include <stdio.h> #include <string.h> int i, j; int flag; int n; switch (a<extra_id_5>patab ) { case 0<extra_id_6>i =<extra_id_7>0<extra_id_8>case 1<extra_id_9>(a); }<extra_id_10>return 0;<extra_id_11>for (i<extra_id_12>!= 6){<extra_id_13>} if (flag<extra_id_14>} if (flag){<extra_id_15>2<extra_id_16>if<extra_id_17>!=<extra_id_18>2<extra_id_19>continue; if (flag) { flag<extra_id_20>{ return (0); }<extra_id_21>}<extra_id_22>= d; char amida[11][31]; int temp[10], keep[10];  for (k = 0; k < d; k++){ for (l = 0; l < n -   1];  temp[l]  } } if (temp[atari  (1); } else { return (0);  = check_amida(); amida[a][b] = '0';  scanf(\"%d\", &m); scanf(\"%d\", &atari); scanf(\"%d\", &d); for (i =   = 0; if  = 1;  for (i = 0;   n -  if  if  continue; }  - 2){ if (amida[i][j + 1] == '1'){ continue; } }   j +  } } if (flag   (0); }"], "original_ll": -0.7526494264602661, "sampled_ll": -0.6088991165161133, "all_perturbed_sampled_ll": [-2.4773664474487305], "all_perturbed_original_ll": [-2.4069900512695312], "perturbed_sampled_ll": -2.4773664474487305, "perturbed_original_ll": -2.4069900512695312, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\n\npublic class Main{\n\tpublic static void main(String[] args)throws IOException{\n\t\tInputStreamReader isr = new InputStreamReader(System.in);\n\t\tBufferedReader reader = new BufferedReader(isr);\n\t\tString string;\n\t\t\n\t\twhile(!(string = reader.readLine()).equals(\"0\")){\n\t\t\tint n = Integer.valueOf(string);\n\t\t\tint m = Integer.valueOf(reader.readLine()) - 1;\n\t\t\tint a = Integer.valueOf(reader.readLine()) - 1;\n\t\t\tint d = Integer.valueOf(reader.readLine());\n\t\t\t\n\t\t\tint node[][] = new int[n - 1][d];\n\t\t\tfor(int i = 0; i < d; i++){\n\t\t\t\tstring = reader.readLine();\n\t\t\t\tfor(int j = 0; j < n - 1; j++){\n\t\t\t\t\tnode[j][i] = string.charAt(j) - '0';\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tif(doing(node, n, m, d) == a){\n\t\t\t\tSystem.out.println(0);\n\t\t\t\tcontinue;\n\t\t\t}else{\n\t\t\t\tboolean judge = false;\n\t\t\t\tx : for(int i = 0; i < d; i++){\n\t\t\t\t\tfor(int j = 0; j < n - 1; j++){\n\t\t\t\t\t\tif(j + 1 < n && j - 1 >= 0)\n\t\t\t\t\t\tif(node[j][i] == 0){\n\t\t\t\t\t\t\tnode[j][i] = 1;\n\t\t\t\t\t\t\tif(doing(node, n, m, d) == a){\n\t\t\t\t\t\t\t\tSystem.out.println((i + 1) + \" \" + (j + 1));\n\t\t\t\t\t\t\t\tjudge = true;\n\t\t\t\t\t\t\t\tbreak x;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tnode[j][i] = 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(!judge) System.out.println(1);\n\t\t\t}\n\t\t}\n\t\treader.close();\n\t}\n\t\n\tpublic static int doing(int node[][], int n, int s, int d){\n\t\tfor(int i = 0; i < d; i++){\n\t\t\tif(s > 0 && node[s - 1][i] == 1) s--;\n\t\t\telse if(s < n - 1 && node[s][i] == 1) s++;\n\t\t}\n\t\treturn s;\n\t}\n}", "sampled": "import java.util.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        \n        while (true) {\n            int n = sc.nextInt();\n            if (n == 0) break;\n            \n            int m = sc.nextInt();\n            int target = sc.nextInt();\n            int d = sc.nextInt();\n            \n            int[][] ladder = new int[d][n - 1];\n            for (int i = 0; i < d; i++) {\n                String line = sc.next();\n                for (int j = 0; j < n - 1; j++) {\n                    ladder[i][j] = line.charAt(j) - '0';\n                }\n            }\n            \n            // Check if we can reach without adding\n            int result = traverse(ladder, m - 1, d, n);\n            if (result == target - 1) {\n                System.out.println(0);\n                continue;\n            }\n            \n            // Try adding one horizontal line\n            boolean found = false;\n            for (int row = 0; row < d; row++) {\n                for (int col = 0; col < n - 1; col++) {\n                    if (canAddLine(ladder, row, col, n)) {\n                        ladder[row][col] = 1;\n                        int newResult = traverse(ladder, m - 1, d, n);\n                        if (newResult == target - 1) {\n                            System.out.println((row + 1) + \" \" + (col + 1));\n                            found = true;\n                            ladder[row][col] = 0;\n                            break;\n                        }\n                        ladder[row][col] = 0;\n                    }\n                }\n                if (found) break;\n            }\n            \n            if (!found) {\n                System.out.println(1);\n            }\n        }\n        \n        sc.close();\n    }\n    \n    static int traverse(int[][] ladder, int start, int d, int n) {\n        int pos = start;\n        for (int row = 0; row < d; row++) {\n            // Check left\n            if (pos > 0 && ladder[row][pos - 1] == 1) {\n                pos--;\n            }\n            // Check right\n            else if (pos < n - 1 && ladder[row][pos] == 1) {\n                pos++;\n            }\n        }\n        return pos;\n    }\n    \n    static boolean canAddLine(int[][] ladder, int row, int col, int n) {\n        if (ladder[row][col] == 1) {\n            return false;\n        }\n        \n        // Check if adjacent positions have lines\n        if (col > 0 && ladder[row][col - 1] == 1) {\n            return false;\n        }\n        if (col < n - 2 && ladder[row][col + 1] == 1) {\n            return false;\n        }\n        \n        return true;\n    }\n}\n", "perturbed_sampled": [" sc =  sc.nextInt(); int d = sc.nextInt(); int[][] ladder = new  i = 0; i < d; i++) { String  j = 0;  line.charAt(j) -  without adding int  1, d, n);  1) { System.out.println(0); continue; } // Try adding  row  row++) { for (int col =   ladder[row][col] = 1; int newResult  d, n); if  +  1)); found = true; ladder[row][col] = 0; break; } ladder[row][col] = 0; } } if (found)  ladder,  n)  for (int  d; row++) { // Check left if (pos >  else if (pos  ladder[row][pos] == 1) {  } static boolean canAddLine(int[][]  int n) {  have lines if (col > 0 &&  {   1) { return false; } return true; } }"], "perturbed_original": ["import java.io.BufferedReader; import java.io.IOException;  args)throws  InputStreamReader(System.in); BufferedReader reader  m = Integer.valueOf(reader.readLine()) - 1; int a =  =   reader.readLine(); for(int j =  1;  '0'; } } if(doing(node, n, m, d) ==   i < d; i++){   n &&  if(node[j][i] == 0){ node[j][i] = 1; if(doing(node, n, m, d) == a){ System.out.println((i   } } } if(!judge) System.out.println(1); }  int doing(int node[][], int n, int s, int d){  < d; i++){   - 1 && node[s][i] == 1) s++; } return s; } }"], "original_ll": -0.7589021921157837, "sampled_ll": -0.5889236927032471, "all_perturbed_sampled_ll": [-3.1232707500457764], "all_perturbed_original_ll": [-2.782928228378296], "perturbed_sampled_ll": -3.1232707500457764, "perturbed_original_ll": -2.782928228378296, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import sys\nimport itertools\n\n\ndef one_step(lo,lis):\n    nu = [ e for e in lis ]\n    for j in xrange(len(nu)):\n        if lo[0][j] == 1:\n            nu[j],nu[j+1] = nu[j+1],nu[j]\n    return lo[1:],nu\n\n\ndef solve(lo,lis):\n    if len(lo) == 0:\n        return lis\n    nu = [ e for e in lis]\n    lo2,nu2 = one_step(lo,nu)\n    return solve(lo2,nu2)\n\nn = input()\nm = input()\nstar = input()\nd = input()\nlis = range(n+1)\nlots = []\nfor i in xrange(d):\n    lots.append([0]+[ 1 if e == '1' else 0 for e in list(raw_input()) ] +[0])\n\nif solve(lots,lis)[star] == m: print 0;exit()\nfor i in xrange(d):\n    for j in xrange(1,n):\n        if lots[0][j-1] == 0 and lots[0][j] == 0 and lots[0][j+1] == 0:\n            lots[0][j] = 1\n            if solve(lots,lis)[star] == m: print i+1,j;exit()\n            lots[0][j] = 0\n    lots,lis = one_step(lots,lis)\nprint 1", "sampled": "def follow_amida(n, start, lines):\n    pos = start\n    for line in lines:\n        if pos > 1 and line[pos-2] == 1:\n            pos -= 1\n        elif pos < n and line[pos-1] == 1:\n            pos += 1\n    return pos\n\ndef can_add_line(lines, level, bridge_pos):\n    # Check if we can add a horizontal line at level between bridge_pos and bridge_pos+1\n    line = lines[level]\n    \n    # Check if there's already a line there\n    if line[bridge_pos] == 1:\n        return False\n    \n    # Check left neighbor\n    if bridge_pos > 0 and line[bridge_pos-1] == 1:\n        return False\n    \n    # Check right neighbor\n    if bridge_pos < len(line) - 1 and line[bridge_pos+1] == 1:\n        return False\n    \n    return True\n\ndef solve():\n    while True:\n        n = int(input())\n        if n == 0:\n            break\n        \n        m = int(input())\n        target = int(input())\n        d = int(input())\n        \n        lines = []\n        for _ in range(d):\n            line_str = input().strip()\n            line = [int(c) for c in line_str]\n            lines.append(line)\n        \n        # Check if already reaches target without adding any line\n        result = follow_amida(n, m, lines)\n        if result == target:\n            print(0)\n            continue\n        \n        # Try adding one line at each possible position\n        found = False\n        for level in range(d):\n            for bridge_pos in range(n-1):\n                if can_add_line(lines, level, bridge_pos):\n                    # Make a copy and add the line\n                    new_lines = [line[:] for line in lines]\n                    new_lines[level][bridge_pos] = 1\n                    \n                    # Check if this reaches target\n                    result = follow_amida(n, m, new_lines)\n                    if result == target:\n                        print(level + 1, bridge_pos + 1)\n                        found = True\n                        break\n            if found:\n                break\n        \n        if not found:\n            print(1)\n\nsolve()\n", "perturbed_sampled": ["def follow_amida(n, start, lines): pos = start for line  1 and   pos += 1 return pos def can_add_line(lines, level, bridge_pos): # Check if we can  level between bridge_pos and   == 1: return False # Check  1: return False # Check right   1:  solve(): while  n == 0: break  _ in range(d):  [int(c) for  Check if already reaches target  print(0) continue # Try   if can_add_line(lines, level, bridge_pos): # Make a copy and   Check if   1,  True break if found: break if not found: print(1) solve()"], "perturbed_original": ["import sys import itertools def one_step(lo,lis): nu = [ e for e  in xrange(len(nu)): if lo[0][j] ==  lo[1:],nu def solve(lo,lis): if len(lo)  =  = input()  xrange(d): lots.append([0]+[ 1 if e ==      == 0 and lots[0][j+1] == 0: lots[0][j] = 1 if solve(lots,lis)[star] == m: print  = one_step(lots,lis) print 1"], "original_ll": -1.3814579248428345, "sampled_ll": -0.9201996326446533, "all_perturbed_sampled_ll": [-3.6109859943389893], "all_perturbed_original_ll": [-3.665945291519165], "perturbed_sampled_ll": -3.6109859943389893, "perturbed_original_ll": -3.665945291519165, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "#include <stdio.h>\n\nint num[10]={1,2,3,4,5,6,7,8,9,0}, dp[11][331];\n#define exch(A,B) {int t; t=A, A=B, B=t;}\n\n/* k\u0095\u00b6\u008e\u009a\u0096\u00da\u0082\u00f0\u008c\u0088\u0082\u00df\u0082\u00e9, s\u0082\u00c9\u0082\u00cd\u0082\u00bb\u0082\u00cc\u008e\u009e\u0093_\u0082\u00c5\u0082\u00cc\u0098a\u0082\u00f0\u0083\u0081\u0083\u0082 */\nvoid solve(int k, int s){\n     int i, j, ts;\n\n     for(i=k; i<10; i++){\n\t  exch(num[i],num[k]);\n\n\t  /* n=k\u0082\u00c5\u0082\u00ccs\u0082\u00f0\u008bL\u0098^ */\n\t  ts=s;\n\t  ts+=num[k]*(k+1);\n\t  dp[k+1][ts]++;\n\n\t  if(k<9) solve(k+1,ts);\n\n\t  exch(num[i],num[k]);\n     }\n}\n\nint main(int argc, char *argv[]){\n     int n, s;\n\n     solve(0,0);\n     \n     while(~scanf(\"%d %d\",&n,&s))\n\t  printf(\"%d\\n\",(n<=10 && s<=330)?dp[n][s]:0);\n\n     return 0;\n}", "sampled": "#include <stdio.h>\n\nint n, s;\nint count;\nint used[10];\nint seq[11];\n\nvoid solve(int pos, int sum) {\n    if (pos > n) {\n        if (sum == s) {\n            count++;\n        }\n        return;\n    }\n    \n    for (int i = 0; i <= 9; i++) {\n        if (!used[i]) {\n            used[i] = 1;\n            seq[pos] = i;\n            solve(pos + 1, sum + pos * i);\n            used[i] = 0;\n        }\n    }\n}\n\nint main() {\n    while (scanf(\"%d %d\", &n, &s) == 2) {\n        count = 0;\n        for (int i = 0; i <= 9; i++) {\n            used[i] = 0;\n        }\n        solve(1, 0);\n        printf(\"%d\\n\", count);\n    }\n    return 0;\n}\n", "perturbed_sampled": ["  (pos > n) { if (sum  <= 9; i++) {   + 1, sum + pos *  } } int main() { while  2) { count =  0; i <= 9;  } solve(1, 0);  }"], "perturbed_original": ["#include  s\u0082\u00c9\u0082\u00cd\u0082\u00bb\u0082\u00cc\u008e\u009e\u0093_\u0082\u00c5\u0082\u00cc\u0098a\u0082\u00f0\u0083\u0081\u0083\u0082 */ void solve(int k,   /* n=k\u0082\u00c5\u0082\u00ccs\u0082\u00f0\u008bL\u0098^ */ ts=s; ts+=num[k]*(k+1); dp[k+1][ts]++; if(k<9) solve(k+1,ts); exch(num[i],num[k]); } } int main(int   && s<=330)?dp[n][s]:0); return 0; }"], "original_ll": -1.9702337980270386, "sampled_ll": -0.5576450824737549, "all_perturbed_sampled_ll": [-3.7234232425689697], "all_perturbed_original_ll": [-3.65008544921875], "perturbed_sampled_ll": -3.7234232425689697, "perturbed_original_ll": -3.65008544921875, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\n\n/**\n * Combination of Number Sequences\n */\npublic class Main {\n\n\tstatic int count;\n\n\tpublic static void main(String[] args) throws IOException {\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\tString line = \"\";\n\n\t\twhile ((line = br.readLine()) != null && !line.isEmpty()) {\n\n\t\t\tint n = Integer.parseInt(line.substring(0, line.indexOf(' ')));\n\t\t\tint s = Integer.parseInt(line.substring(line.indexOf(' ') + 1));\n\n\t\t\tcount = 0;\n\t\t\tsolve(0, n, 1, s);\n\t\t\tSystem.out.println(count);\n\n\t\t}\n\n\t}\n\n\tstatic void solve(int p, int n, int a, int s) {\n\n\t\tif (p > 9 || n <= 0 || p * a > s) {\n\t\t\treturn;\n\t\t}\n\n\t\tif (n == 1 && p * a == s) {\n\t\t\t++count;\n\t\t} else {\n\t\t\tsolve(p + 1, n - 1, a + 1, s - p * a);\n\t\t\tsolve(p + 1, n, a, s);\n\t\t}\n\t}\n}", "sampled": "import java.util.*;\n\npublic class Main {\n    static int n, s;\n    static int count;\n    \n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        \n        while (sc.hasNext()) {\n            n = sc.nextInt();\n            s = sc.nextInt();\n            \n            count = 0;\n            boolean[] used = new boolean[10];\n            solve(1, 0, used);\n            \n            System.out.println(count);\n        }\n        \n        sc.close();\n    }\n    \n    static void solve(int pos, int sum, boolean[] used) {\n        if (pos > n) {\n            if (sum == s) {\n                count++;\n            }\n            return;\n        }\n        \n        for (int i = 0; i <= 9; i++) {\n            if (!used[i]) {\n                used[i] = true;\n                solve(pos + 1, sum + pos * i, used);\n                used[i] = false;\n            }\n        }\n    }\n}\n", "perturbed_sampled": ["import java.util.*; public class Main { static int n, s;  void main(String[] args) { Scanner  sc.nextInt();   System.out.println(count); } sc.close(); } static void solve(int pos, int   (sum == s) {  i  true; solve(pos + 1,  } } } }"], "perturbed_original": ["import java.io.BufferedReader; import java.io.IOException; import  class Main   {  '))); int s = Integer.parseInt(line.substring(line.indexOf(' ') + 1)); count = 0;  solve(int p, int n, int a, int  a > s) { return; } if (n ==  == s) { ++count; } else  1,  solve(p + 1, n, a, s); } } }"], "original_ll": -0.7944003343582153, "sampled_ll": -0.5080924034118652, "all_perturbed_sampled_ll": [-2.9633750915527344], "all_perturbed_original_ll": [-2.706650972366333], "perturbed_sampled_ll": -2.9633750915527344, "perturbed_original_ll": -2.706650972366333, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "\nimport sys\nimport itertools\n\n\ntable = [[], [], [], [], [], [], [], [], [], [], []]\n\ndef solv(n, s):\n    if s > 330:\n        return 0\n    dp = table[n]\n    if dp:\n        return dp[s]\n    else:\n        for i in xrange(331):\n            dp.append(0)\n        for p in itertools.permutations(xrange(10), n):\n            s0 = foo(p, n)\n            dp[s0] += 1\n        return dp[s]\n\n\ndef foo(perm, n):\n    return sum(map(lambda x, y: x * y, xrange(1, n+1), perm))\n\n\nfor line in sys.stdin:\n    n, s = map(int, line.split(' '))\n    print solv(n, s)", "sampled": "import sys\nfrom itertools import permutations\n\ndef count_combinations(n, s):\n    count = 0\n    # Generate all permutations of n numbers from 0-9\n    for perm in permutations(range(10), n):\n        # Calculate the weighted sum\n        weighted_sum = sum((i + 1) * perm[i] for i in range(n))\n        if weighted_sum == s:\n            count += 1\n    return count\n\nfor line in sys.stdin:\n    n, s = map(int, line.strip().split())\n    print(count_combinations(n, s))\n", "perturbed_sampled": ["import sys from itertools import permutations  0 # Generate  from 0-9 for perm in permutations(range(10), n): # Calculate the weighted sum weighted_sum = sum((i +  print(count_combinations(n, s))"], "perturbed_original": ["import sys import itertools table = [[], [], [], [], [], [], [],  >    itertools.permutations(xrange(10), n): s0  1 return  * y, xrange(1, n+1),  line.split(' ')) print solv(n, s)"], "original_ll": -1.341007947921753, "sampled_ll": -0.871116578578949, "all_perturbed_sampled_ll": [-3.6761646270751953], "all_perturbed_original_ll": [-4.325314521789551], "perturbed_sampled_ll": -3.6761646270751953, "perturbed_original_ll": -4.325314521789551, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "#include <stdio.h>\n\nvoid bomb(int field[8][8],int x,int y);\n\nint main(){\n\tint i,j,k,n;\n\tint field[8][8];\n\tchar line[9];\n\tint x,y;\n\t\n\tscanf(\"%d\",&n);\n\tfor(i=1;i<=n;i++){\t\t\n\t\tfor(j=0;j<8;j++){\n\t\t\tscanf(\"%s\",line);\n\t\t\tfor(k=0;k<8;k++){\n\t\t\t\tfield[j][k] = line[k] - '0';\n\t\t\t}\n\t\t}\n\t\tscanf(\"%d\",&x);\n\t\tscanf(\"%d\",&y);\n\t\tx--; y--;\n\t\t\n\t\tbomb(field,y,x);\n\t\t\n\t\tprintf(\"Data %d:\\n\",i);\n\t\tfor(j=0;j<8;j++){\n\t\t\tfor(k=0;k<8;k++){\n\t\t\t\tprintf(\"%d\",field[j][k]);\n\t\t\t}\n\t\t\tprintf(\"\\n\");\n\t\t}\n\t}\n\t\n\treturn 0;\n}\n\nvoid bomb(int field[8][8],int x,int y){\n\tint i;\n\tfield[x][y] = 0;\n\tfor(i=1;i<=3&&x-i>=0;i++){\n\t\tif(field[x-i][y] == 1){\n\t\t\tfield[x-i][y] = 0;\n\t\t\tbomb(field,x-i,y);\n\t\t}\n\t}\n\tfor(i=1;i<=3&&x+i<8;i++){\n\t\tif(field[x+i][y] == 1){\n\t\t\tfield[x+i][y] = 0;\n\t\t\tbomb(field,x+i,y);\n\t\t}\n\t}\n\tfor(i=1;i<=3&&y-i>=0;i++){\n\t\tif(field[x][y-i] == 1){\n\t\t\tfield[x][y-i] = 0;\n\t\t\tbomb(field,x,y-i);\n\t\t}\n\t}\n\tfor(i=1;i<=3&&y+i<8;i++){\n\t\tif(field[x][y+i] == 1){\n\t\t\tfield[x][y+i] = 0;\n\t\t\tbomb(field,x,y+i);\n\t\t}\n\t}\n}", "sampled": "#include <stdio.h>\n#include <string.h>\n\nint grid[8][8];\nint exploded[8][8];\n\nvoid explode(int x, int y) {\n    if (x < 0 || x >= 8 || y < 0 || y >= 8) return;\n    if (exploded[y][x]) return;\n    if (grid[y][x] == 0) return;\n    \n    exploded[y][x] = 1;\n    \n    // Explode bombs in range (3 squares in each direction)\n    for (int i = 1; i <= 3; i++) {\n        if (x - i >= 0) explode(x - i, y);\n        if (x + i < 8) explode(x + i, y);\n        if (y - i >= 0) explode(x, y - i);\n        if (y + i < 8) explode(x, y + i);\n    }\n}\n\nint main() {\n    int n;\n    scanf(\"%d\", &n);\n    \n    for (int dataset = 1; dataset <= n; dataset++) {\n        // Read the grid\n        for (int i = 0; i < 8; i++) {\n            char line[10];\n            scanf(\"%s\", line);\n            for (int j = 0; j < 8; j++) {\n                grid[i][j] = line[j] - '0';\n            }\n        }\n        \n        int x, y;\n        scanf(\"%d %d\", &x, &y);\n        x--; y--; // Convert to 0-indexed\n        \n        // Initialize exploded array\n        memset(exploded, 0, sizeof(exploded));\n        \n        // Start the chain reaction\n        explode(x, y);\n        \n        // Output\n        printf(\"Data %d:\\n\", dataset);\n        for (int i = 0; i < 8; i++) {\n            for (int j = 0; j < 8; j++) {\n                if (exploded[i][j]) {\n                    printf(\"0\");\n                } else {\n                    printf(\"%d\", grid[i][j]);\n                }\n            }\n            printf(\"\\n\");\n        }\n    }\n    \n    return 0;\n}\n", "perturbed_sampled": [" grid[8][8]; int exploded[8][8]; void explode(int x, int   return;  == 0) return;   i <=  -  i, y); if (x + i   >= 0) explode(x, y -  int main() { int  dataset = 1;   (int i = 0; i < 8; i++) { char line[10]; scanf(\"%s\", line);  j < 8; j++) { grid[i][j]  } int x, y;   printf(\"Data %d:\\n\", dataset); for (int i  i++) { for (int j = 0; j  (exploded[i][j]) { printf(\"0\"); } else  printf(\"\\n\"); } } return 0; }"], "perturbed_original": ["#include <stdio.h> void  } scanf(\"%d\",&x); scanf(\"%d\",&y); x--; y--; bomb(field,y,x); printf(\"Data  0; }  bomb(field,x-i,y); } } for(i=1;i<=3&&x+i<8;i++){ if(field[x+i][y] == 1){ field[x+i][y] = 0; bomb(field,x+i,y); } } for(i=1;i<=3&&y-i>=0;i++){ if(field[x][y-i] == 1){ field[x][y-i]  for(i=1;i<=3&&y+i<8;i++){ if(field[x][y+i] == 1){ field[x][y+i] = 0; bomb(field,x,y+i); } } }"], "original_ll": -0.5113551616668701, "sampled_ll": -0.545032799243927, "all_perturbed_sampled_ll": [-2.497833728790283], "all_perturbed_original_ll": [-1.6339725255966187], "perturbed_sampled_ll": -2.497833728790283, "perturbed_original_ll": -1.6339725255966187, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import java.util.LinkedList;\nimport java.util.Scanner;\n\npublic class Main {\n\tprivate Scanner sc;\n\n\tint[][] map;\n\tpublic static void main(String[] args) {\n\t\tnew Main();\n\t}\n\t\n\tpublic Main() {\n\t\tsc = new Scanner(System.in);\n\t\t\n\t\tint sets = Integer.parseInt(sc.nextLine());\n\t\t\n\t\tfor (int index = 0; index < sets; index++) {\n\t\t\tsc.nextLine();\n\t\t\t\n\t\t\tmap = new int[8][8];\n\t\t\tfor (int i = 0; i < map.length; i++) {\n\t\t\t\tString line = sc.nextLine();\n\t\t\t\tfor (int j = 0; j < map.length; j++) {\n\t\t\t\t\tmap[j][i] = line.charAt(j) - '0';\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tLinkedList<Integer[]> boms = new LinkedList<Integer[]>();\n\t\t\tInteger[] xy = new Integer[2];\n\t\t\txy[0] = Integer.parseInt(sc.nextLine()) - 1;\n\t\t\txy[1] = Integer.parseInt(sc.nextLine()) - 1;\n\t\t\tmap[xy[0]][xy[1]] = 0;\n\t\t\tboms.add(xy);\n\t\t\t\n\t\t\twhile (boms.isEmpty() == false) {\n\t\t\t\txy = boms.pop();\n\t\t\t\t\n\t\t\t\tint tx = xy[0];\n\t\t\t\tint ty = xy[1];\n\t\t\t\t\n\t\t\t\t\n\t\t\t\tfor (int i = -3; i < 4; i++) {\n\t\t\t\t\tif ((tx + i) < 0) continue;\n\t\t\t\t\tif ((tx + i) > 7) break;\n\t\t\t\t\t\n\t\t\t\t\tif (map[tx + i][ty] == 1) {\n\t\t\t\t\t\tmap[tx + i][ty] = 0;\n\t\t\t\t\t\txy[0] = tx + i;\n\t\t\t\t\t\txy[1] = ty;\n\t\t\t\t\t\tboms.add(xy);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tfor (int i = -3; i < 4; i++) {\n\t\t\t\t\tif ((ty + i) < 0) continue;\n\t\t\t\t\tif ((ty + i) > 7) break;\t\n\t\t\t\t\t\n\t\t\t\t\tif (map[tx][ty + i] == 1) {\n\t\t\t\t\t\tmap[tx][ty + i] = 0;\n\t\t\t\t\t\txy[0] = tx;\n\t\t\t\t\t\txy[1] = ty + i;\n\t\t\t\t\t\tboms.add(xy);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tSystem.out.println(\"Data \" + (index + 1) + \":\");\n\t\t\tfor (int i = 0; i < map.length; i++) {\n\t\t\t\tfor (int j = 0; j < map.length; j++) {\n\t\t\t\t\tSystem.out.print(map[j][i]);\n\t\t\t\t}\n\t\t\t\tSystem.out.println();\n\t\t\t}\n\t\t}\n\t}\n}", "sampled": "import java.util.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int n = sc.nextInt();\n        sc.nextLine();\n        \n        for (int dataSet = 1; dataSet <= n; dataSet++) {\n            sc.nextLine(); // empty line\n            \n            int[][] grid = new int[8][8];\n            for (int y = 0; y < 8; y++) {\n                String line = sc.nextLine();\n                for (int x = 0; x < 8; x++) {\n                    grid[y][x] = line.charAt(x) - '0';\n                }\n            }\n            \n            int startX = sc.nextInt() - 1;\n            int startY = sc.nextInt() - 1;\n            sc.nextLine();\n            \n            // BFS to explode bombs\n            Queue<int[]> queue = new LinkedList<>();\n            boolean[][] exploded = new boolean[8][8];\n            \n            queue.offer(new int[]{startX, startY});\n            exploded[startY][startX] = true;\n            \n            while (!queue.isEmpty()) {\n                int[] pos = queue.poll();\n                int x = pos[0];\n                int y = pos[1];\n                \n                // Check up to 3 cells in each direction\n                for (int dy = -3; dy <= 3; dy++) {\n                    int ny = y + dy;\n                    if (ny >= 0 && ny < 8 && grid[ny][x] == 1 && !exploded[ny][x]) {\n                        exploded[ny][x] = true;\n                        queue.offer(new int[]{x, ny});\n                    }\n                }\n                \n                for (int dx = -3; dx <= 3; dx++) {\n                    int nx = x + dx;\n                    if (nx >= 0 && nx < 8 && grid[y][nx] == 1 && !exploded[y][nx]) {\n                        exploded[y][nx] = true;\n                        queue.offer(new int[]{nx, y});\n                    }\n                }\n            }\n            \n            // Update grid\n            for (int y = 0; y < 8; y++) {\n                for (int x = 0; x < 8; x++) {\n                    if (exploded[y][x]) {\n                        grid[y][x] = 0;\n                    }\n                }\n            }\n            \n            // Output\n            System.out.println(\"Data \" + dataSet + \":\");\n            for (int y = 0; y < 8; y++) {\n                for (int x = 0; x < 8; x++) {\n                    System.out.print(grid[y][x]);\n                }\n                System.out.println();\n            }\n        }\n        \n        sc.close();\n    }\n}\n", "perturbed_sampled": ["import java.util.*; public class Main { public static void main(String[] args) { Scanner sc = new Scanner(System.in); int    // empty line  0; y < 8;  = 0;     = sc.nextInt() - 1;  bombs Queue<int[]> queue  = new boolean[8][8]; queue.offer(new int[]{startX,  (!queue.isEmpty()) { int[] pos =  //  (int dy  dy++) { int ny = y + dy; if (ny >=  && grid[ny][x] ==   }  dx++) { int nx = x  1 && !exploded[y][nx]) { exploded[y][nx] = true; queue.offer(new int[]{nx,  Update grid for (int   = 0; }  \" + dataSet +  0; y < 8; y++) {  } } sc.close(); } }"], "perturbed_original": ["import <extra_id_5>8<extra_id_6>[0]); } } } }<extra_id_7>t.charAt( j) - '0';<extra_id_8>+<extra_id_9>0;<extra_id_10>;<extra_id_11>}<extra_id_12>int t = 0 ;<extra_id_13>) + //<extra_id_14>+<extra_id_15>//<extra_id_16>-<extra_id_17>1 )<extra_id_18>] = 0;<extra_id_19>= 10; T .<extra_id_20>+<extra_id_21>)<extra_id_22>; } /*<extra_id_23>break;<extra_id_24>Boms boms.add( =  = 0; index  for (int i = 0; i < map.length; i++) { String line =  line.charAt(j) - '0'; }    0; boms.add(xy); while  = boms.pop(); int tx = xy[0];  (int i = -3; i < 4;   7) break; if (map[tx + i][ty] ==  = 0; xy[0] = tx + i;  } for (int  4;  i)  + i) > 7) break; if (map[tx][ty + i] == 1) { map[tx][ty + i] = 0; xy[0] = tx; xy[1] = ty   + 1) +  0; i <  < map.length; j++) { System.out.print(map[j][i]);  }"], "original_ll": -0.5534349679946899, "sampled_ll": -0.4734344184398651, "all_perturbed_sampled_ll": [-2.81652569770813], "all_perturbed_original_ll": [-2.2746975421905518], "perturbed_sampled_ll": -2.81652569770813, "perturbed_original_ll": -2.2746975421905518, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "def bomb(x,y):\n    s=M[y]\n    if s[x]==\"0\":return\n    M[y]=s[:x]+\"0\"+s[x+1:]\n    R=[-3,-2,-1,1,2,3]\n    for e in R:\n        bomb(x+e,y)\n        bomb(x,y+e)\n    return\n\nA=range(3,11)\nM=[\"00000000000000\" for i in range(14)]\nz=\"000\"\nn=input()\nfor i in range(n):\n    s=raw_input()\n    for j in A:\n        M[j]=z+raw_input()+z\n    x=input()+2\n    y=input()+2\n    bomb(x,y)\n    print \"Data %d:\" %(i+1)\n    for j in A:\n        print M[j][3:-3]", "sampled": "from collections import deque\n\ndef solve():\n    n = int(input())\n    \n    for dataset_num in range(1, n + 1):\n        # Read empty line\n        input()\n        \n        # Read 8x8 grid\n        grid = []\n        for i in range(8):\n            line = input().strip()\n            grid.append([int(c) for c in line])\n        \n        # Read starting position\n        x = int(input())\n        y = int(input())\n        \n        # Convert to 0-indexed\n        x -= 1\n        y -= 1\n        \n        # BFS to simulate chain explosions\n        exploded = [[False] * 8 for _ in range(8)]\n        queue = deque()\n        \n        # Start explosion at (x, y)\n        if grid[y][x] == 1:\n            queue.append((x, y))\n            exploded[y][x] = True\n        \n        while queue:\n            cx, cy = queue.popleft()\n            \n            # Explosion affects 3 squares in each direction (up, down, left, right)\n            directions = []\n            # Up\n            for dy in range(1, 4):\n                if cy - dy >= 0:\n                    directions.append((cx, cy - dy))\n            # Down\n            for dy in range(1, 4):\n                if cy + dy < 8:\n                    directions.append((cx, cy + dy))\n            # Left\n            for dx in range(1, 4):\n                if cx - dx >= 0:\n                    directions.append((cx - dx, cy))\n            # Right\n            for dx in range(1, 4):\n                if cx + dx < 8:\n                    directions.append((cx + dx, cy))\n            \n            for nx, ny in directions:\n                if grid[ny][nx] == 1 and not exploded[ny][nx]:\n                    exploded[ny][nx] = True\n                    queue.append((nx, ny))\n        \n        # Remove exploded bombs from grid\n        for i in range(8):\n            for j in range(8):\n                if exploded[i][j]:\n                    grid[i][j] = 0\n        \n        # Output result\n        print(f\"Data {dataset_num}:\")\n        for row in grid:\n            print(''.join(map(str, row)))\n\nsolve()\n", "perturbed_sampled": ["from collections import  # Read empty line input() # Read 8x8 grid grid = [] for i in range(8):  c   1 y -= 1 # BFS to simulate chain explosions   =  ==  = [] # Up for dy in range(1, 4): if  directions.append((cx,  -  dx, cy)) # Right for dx in range(1,  < 8:  nx, ny in directions: if grid[ny][nx] ==  = True queue.append((nx, ny)) # Remove exploded bombs from  for j in range(8): if exploded[i][j]: grid[i][j] =  {dataset_num}:\") for row in grid: print(''.join(map(str, row))) solve()"], "perturbed_original": ["def  R=[-3,-2,-1,1,2,3] for e  A=range(3,11) M=[\"00000000000000\" for  bomb(x,y) print \"Data %d:\" %(i+1) for j in A: print M[j][3:-3]"], "original_ll": -1.5403037071228027, "sampled_ll": -0.7144481539726257, "all_perturbed_sampled_ll": [-3.433109760284424], "all_perturbed_original_ll": [-3.088860511779785], "perturbed_sampled_ll": -3.433109760284424, "perturbed_original_ll": -3.088860511779785, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "#include <stdio.h>\n#define INF 1000000\n\nint cost[100][100];\nint mincost[100];\nchar used[100];\nint V;\n\nint min(int a, int b){\n\tif (a > b){\n\t\treturn (b);\n\t}\n\treturn (a);\n}\n\nint prim(void)\n{\n\tint i;\n\tint res;\n\tint u, v;\n\t\n\tfor (i = 0; i < V; i++){\n\t\tmincost[i] = INF;\n\t\tused[i] = 0;\n\t}\n\t\n\tmincost[0] = 0;\n\tres = 0;\n\t\n\twhile (1){\n\t\tv = -1;\n\t\tfor (u = 0; u < V; u++){\n\t\t\tif (!used[u] && (v == -1 || mincost[u] < mincost[v])){\n\t\t\t\tv = u;\n\t\t\t}\n\t\t}\n\t\t\n\t\tif (v == -1){\n\t\t\tbreak;\n\t\t}\n\t\tused[v] = 1;\n\t\tres += mincost[v];\n\t\t\n\t\tfor (u = 0; u < V; u++){\n\t\t\tmincost[u] = min(mincost[u], cost[v][u]);\n\t\t}\n\t}\n\treturn (res);\n}\n\nint main(void)\n{\n\tint num, from, to, dist;\n\tint i,j;\n\t\n\twhile (1){\n\t\tscanf(\"%d\", &V);\n\t\tif (V == 0){\n\t\t\tbreak;\n\t\t}\n\t\tscanf(\"%d\", &num);\n\t\t\n\t\tfor (i = 0; i < num; i++){\n\t\t\tfor (j = 0; j < num; j++){\n\t\t\t\tcost[i][j] = INF;\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor (i = 0; i < num; i++){\n\t\t\tscanf(\"%d,%d,%d\", &from, &to, &dist);\n\t\t\tcost[from][to] = cost[to][from] = (dist / 100) - 1;\n\t\t}\n\t\t\n\t\tprintf(\"%d\\n\", prim());\n\t}\n\treturn (0);\n}", "sampled": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#define MAX_N 100\n#define MAX_M 5000\n\ntypedef struct {\n    int u, v, w;\n} Edge;\n\nint parent[MAX_N];\nEdge edges[MAX_M];\n\nint find(int x) {\n    if (parent[x] != x) {\n        parent[x] = find(parent[x]);\n    }\n    return parent[x];\n}\n\nvoid unite(int x, int y) {\n    int px = find(x);\n    int py = find(y);\n    if (px != py) {\n        parent[px] = py;\n    }\n}\n\nint compare(const void *a, const void *b) {\n    Edge *ea = (Edge *)a;\n    Edge *eb = (Edge *)b;\n    return ea->w - eb->w;\n}\n\nint main() {\n    int n, m;\n    \n    while (scanf(\"%d\", &n) == 1 && n != 0) {\n        scanf(\"%d\", &m);\n        \n        for (int i = 0; i < m; i++) {\n            int a, b, d;\n            scanf(\"%d,%d,%d\", &a, &b, &d);\n            edges[i].u = a;\n            edges[i].v = b;\n            edges[i].w = d;\n        }\n        \n        qsort(edges, m, sizeof(Edge), compare);\n        \n        for (int i = 0; i < n; i++) {\n            parent[i] = i;\n        }\n        \n        int total_lanterns = 0;\n        int edges_used = 0;\n        \n        for (int i = 0; i < m && edges_used < n - 1; i++) {\n            int u = edges[i].u;\n            int v = edges[i].v;\n            int w = edges[i].w;\n            \n            if (find(u) != find(v)) {\n                unite(u, v);\n                edges_used++;\n                total_lanterns += (w / 100 - 1);\n            }\n        }\n        \n        printf(\"%d\\n\", total_lanterns);\n    }\n    \n    return 0;\n}\n", "perturbed_sampled": [" #define MAX_M 5000 typedef struct { int u,  return parent[x]; }   if (px != py) { parent[px] = py; } } int compare(const void  Edge *ea = (Edge *)a; Edge *eb = (Edge  } int main()  (scanf(\"%d\", &n)  for (int i = 0; i < m; i++) { int a, b, d;   for (int i = 0; i  i < m && edges_used  { int  != find(v)) { unite(u, v);  100 - 1); } } printf(\"%d\\n\", total_lanterns); } return 0; }"], "perturbed_original": ["#include <stdio.h> #define INF   { int i; int  (i = 0;  = INF; used[i] = 0; } mincost[0]  while  (u = 0; u < V;   } } if (v == -1){ break; } used[v] = 1;  = 0;  = min(mincost[u], cost[v][u]); } } return  (1){ scanf(\"%d\", &V); if (V == 0){ break; } scanf(\"%d\", &num); for (i = 0; i  num; j++){ cost[i][j]  &from, &to, &dist); cost[from][to]   }"], "original_ll": -0.593109130859375, "sampled_ll": -0.42744705080986023, "all_perturbed_sampled_ll": [-2.857794761657715], "all_perturbed_original_ll": [-2.438276767730713], "perturbed_sampled_ll": -2.857794761657715, "perturbed_original_ll": -2.438276767730713, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.Arrays;\n\npublic class Main{\n\tpublic static void main(String[] args)throws IOException{\n\t\tInputStreamReader isr = new InputStreamReader(System.in);\n\t\tBufferedReader reader = new BufferedReader(isr);\n\t\tStringBuilder sb = new StringBuilder();\n\t\tint n = 0, m = 0, a = 0, b = 0, c = 0;\n\t\t\n\t\twhile(!(sb.append(reader.readLine())).equals(\"0\")){\n\t\t\tn = Integer.valueOf(sb.toString());\n\t\t\tm = Integer.valueOf(reader.readLine());\n\t\t\t\n\t\t\tint map[][] = new int[n][n];\n\t\t\tboolean visit[] = new boolean[n];\n\t\t\tfor(int i = 0;i < n; i++) Arrays.fill(map[i], 1 << 29);\n\t\t\tfor(int i = 0; i < m; i++){\n\t\t\t\tsb.setLength(0);\n\t\t\t\tsb.append(reader.readLine());\n\t\t\t\ta = Integer.valueOf(sb.toString().split(\",\")[0]);\n\t\t\t\tb = Integer.valueOf(sb.toString().split(\",\")[1]);\n\t\t\t\tc = (Integer.valueOf(sb.toString().split(\",\")[2]) - 100) / 100;\n\t\t\t\tmap[a][b] = map[b][a] = c;\n\t\t\t}\n\t\t\tc = 0;\n\t\t\tvisit[0] = true;\n\t\t\tfor(int x = 0; x < n - 1; x++){\n\t\t\t\tm = 1 << 29;\n\t\t\t\tfor(int i = 0; i < n; i++){\n\t\t\t\t\tif(map[0][i] < m && !visit[i]){\n\t\t\t\t\t\tm = map[0][i];\n\t\t\t\t\t\tb = i;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tvisit[b] = true;\n\t\t\t\tc += map[0][b];\n\t\t\t\tfor(int i = 0; i < n; i++){\n\t\t\t\t\tmap[0][i] = Math.min(map[0][i], map[b][i]);\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(c);\n\t\t\tsb.setLength(0);\n\t\t}\n\t\treader.close();\n\t}\n}", "sampled": "import java.util.*;\n\npublic class Main {\n    static class Edge {\n        int to, dist;\n        Edge(int to, int dist) {\n            this.to = to;\n            this.dist = dist;\n        }\n    }\n    \n    static class UnionFind {\n        int[] parent, rank;\n        \n        UnionFind(int n) {\n            parent = new int[n];\n            rank = new int[n];\n            for (int i = 0; i < n; i++) {\n                parent[i] = i;\n            }\n        }\n        \n        int find(int x) {\n            if (parent[x] != x) {\n                parent[x] = find(parent[x]);\n            }\n            return parent[x];\n        }\n        \n        void union(int x, int y) {\n            int px = find(x);\n            int py = find(y);\n            if (px == py) return;\n            \n            if (rank[px] < rank[py]) {\n                parent[px] = py;\n            } else if (rank[px] > rank[py]) {\n                parent[py] = px;\n            } else {\n                parent[py] = px;\n                rank[px]++;\n            }\n        }\n        \n        boolean connected(int x, int y) {\n            return find(x) == find(y);\n        }\n    }\n    \n    static class MSTEdge implements Comparable<MSTEdge> {\n        int u, v, dist;\n        MSTEdge(int u, int v, int dist) {\n            this.u = u;\n            this.v = v;\n            this.dist = dist;\n        }\n        \n        public int compareTo(MSTEdge other) {\n            return this.dist - other.dist;\n        }\n    }\n    \n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        \n        while (true) {\n            int n = sc.nextInt();\n            if (n == 0) break;\n            \n            int m = sc.nextInt();\n            sc.nextLine();\n            \n            List<MSTEdge> edges = new ArrayList<>();\n            \n            for (int i = 0; i < m; i++) {\n                String line = sc.nextLine();\n                String[] parts = line.split(\",\");\n                int a = Integer.parseInt(parts[0]);\n                int b = Integer.parseInt(parts[1]);\n                int d = Integer.parseInt(parts[2]);\n                edges.add(new MSTEdge(a, b, d));\n            }\n            \n            // Kruskal's algorithm to find MST\n            Collections.sort(edges);\n            UnionFind uf = new UnionFind(n);\n            \n            int totalLanterns = 0;\n            \n            for (MSTEdge edge : edges) {\n                if (!uf.connected(edge.u, edge.v)) {\n                    uf.union(edge.u, edge.v);\n                    // Calculate lanterns needed for this edge\n                    // Distance is in meters, lanterns are every 100m\n                    // First lantern at 100m from one end, last at 100m from other end\n                    // For distance d, we need (d/100 - 1) lanterns\n                    int lanterns = edge.dist / 100 - 1;\n                    totalLanterns += lanterns;\n                }\n            }\n            \n            System.out.println(totalLanterns);\n        }\n        \n        sc.close();\n    }\n}\n", "perturbed_sampled": ["import java.util.*; public class Main  this.to = to; this.dist =   (int i =  } } int find(int x) { if  int px =  rank[py]) { parent[px] = py; } else if (rank[px] > rank[py])  px; rank[px]++; } }   int u, v, dist; MSTEdge(int u, int  = u;  compareTo(MSTEdge other)   sc = new  n = sc.nextInt(); if (n == 0)  sc.nextLine(); List<MSTEdge> edges = new ArrayList<>(); for  int  = Integer.parseInt(parts[1]); int d = Integer.parseInt(parts[2]); edges.add(new MSTEdge(a, b, d)); } // Kruskal's algorithm  uf  = 0; for (MSTEdge  (!uf.connected(edge.u,  Calculate lanterns needed for this edge // Distance is in meters, lanterns are  at 100m from  from other end // For distance d, we need (d/100 - 1)   +=  sc.close(); } }"], "perturbed_original": ["import java.io.BufferedReader; import java.io.IOException; import java.io.InputStreamReader; import java.util.Arrays; public   0, m = 0, a = 0, b =  = Integer.valueOf(reader.readLine()); int map[][] =  new  <  29); for(int i = 0; i  (Integer.valueOf(sb.toString().split(\",\")[2]) -  map[b][a] = c; } c = 0; visit[0] = true; for(int  0; i < n; i++){ if(map[0][i] < m && !visit[i]){   for(int  Math.min(map[0][i], map[b][i]); } } System.out.println(c); sb.setLength(0); } reader.close(); } }"], "original_ll": -0.7757416367530823, "sampled_ll": -0.4814315438270569, "all_perturbed_sampled_ll": [-3.0280110836029053], "all_perturbed_original_ll": [-2.207645893096924], "perturbed_sampled_ll": -3.0280110836029053, "perturbed_original_ll": -2.207645893096924, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "while 1:\n  n=int(input())\n  if not n:break\n  X={0}\n  Y=set(range(n))-X\n  s=0\n  l=[tuple(map(int,input().split(\",\"))) for _ in range(int(input()))]\n\n  while Y:\n    cd=[i for i in l if (i[0] in X and i[1] in Y) or (i[0] in Y and i[1] in X)]\n    cd=sorted(cd,key=lambda x:x[2])[0]\n    if cd[0] in X and cd[1] in Y:\n      X.add(cd[1])\n      Y=Y-X\n    elif cd[0] in Y and cd[1] in X:\n      X.add(cd[0])\n      Y=Y-X\n    s+=int(cd[2]/100-1)\n  print(s)\n", "sampled": "import sys\nfrom collections import defaultdict\n\ndef find(parent, x):\n    if parent[x] != x:\n        parent[x] = find(parent, parent[x])\n    return parent[x]\n\ndef union(parent, rank, x, y):\n    px, py = find(parent, x), find(parent, y)\n    if px == py:\n        return False\n    if rank[px] < rank[py]:\n        px, py = py, px\n    parent[py] = px\n    if rank[px] == rank[py]:\n        rank[px] += 1\n    return True\n\ndef kruskal_mst(n, edges):\n    parent = list(range(n))\n    rank = [0] * n\n    edges.sort(key=lambda x: x[2])\n    mst_edges = []\n    \n    for a, b, d in edges:\n        if union(parent, rank, a, b):\n            mst_edges.append((a, b, d))\n            if len(mst_edges) == n - 1:\n                break\n    \n    return mst_edges\n\nwhile True:\n    n = int(input())\n    if n == 0:\n        break\n    \n    m = int(input())\n    edges = []\n    \n    for _ in range(m):\n        line = input().strip()\n        a, b, d = map(int, line.split(','))\n        edges.append((a, b, d))\n    \n    # Find MST\n    mst_edges = kruskal_mst(n, edges)\n    \n    # Calculate total lanterns needed\n    total_lanterns = 0\n    for a, b, d in mst_edges:\n        # Distance between two sites is d meters\n        # Lanterns are placed every 100m\n        # First lantern is 100m from site a, last is 100m from site b\n        # So number of lanterns = d/100 - 1\n        lanterns = d // 100 - 1\n        total_lanterns += lanterns\n    \n    print(total_lanterns)\n", "perturbed_sampled": ["import sys  !=  rank, x,  x), find(parent, y) if px  py = py, px parent[py] = px if rank[px] == rank[py]: rank[px] += 1  parent = list(range(n)) rank =  x[2]) mst_edges = [] for a, b, d in edges: if union(parent, rank, a, b):  == n  int(input()) if n == 0: break m  for   d)) #  lanterns needed  b,  between two sites is d meters  a,  of lanterns = d/100  total_lanterns += lanterns print(total_lanterns)"], "perturbed_original": ["while 1:  Y: cd=[i  i[1]  Y and i[1] in X)] cd=sorted(cd,key=lambda  and cd[1] in Y: X.add(cd[1]) Y=Y-X elif cd[0] in Y and  s+=int(cd[2]/100-1) print(s)"], "original_ll": -1.2589569091796875, "sampled_ll": -0.6471632719039917, "all_perturbed_sampled_ll": [-3.3246350288391113], "all_perturbed_original_ll": [-3.805802822113037], "perturbed_sampled_ll": -3.3246350288391113, "perturbed_original_ll": -3.805802822113037, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "#include <stdio.h>\n\nvoid timePrint(int time);\n\nint main(void){\n  int t, h, s;\n  int time;\n\n  scanf(\"%d%d%d\", &t, &h, &s);\n  while(!(t == -1 && h == -1 && s == -1)){\n    time = t*3600 + h*60 + s;\n    timePrint(7200-time);\n    timePrint(7200-time/3);\n    scanf(\"%d%d%d\", &t, &h, &s);\n  }\n  return 0;\n}\n\nvoid timePrint(int time){\n  printf(\"%02d:\", time/3600);\n  time %= 3600;\n  printf(\"%02d:\", time/60);\n  time %= 60;\n  printf(\"%02d\\n\", time);\n  return;\n}", "sampled": "#include <stdio.h>\n\nint main() {\n    int T, H, S;\n    \n    while(1) {\n        scanf(\"%d %d %d\", &T, &H, &S);\n        \n        if(T == -1 && H == -1 && S == -1) {\n            break;\n        }\n        \n        // Convert current time to seconds\n        int current_seconds = T * 3600 + H * 60 + S;\n        \n        // Total tape is 120 minutes = 7200 seconds\n        int total_seconds = 120 * 60;\n        \n        // Remaining seconds\n        int remaining_seconds = total_seconds - current_seconds;\n        \n        // Standard mode: remaining time as is\n        int std_hours = remaining_seconds / 3600;\n        int std_minutes = (remaining_seconds % 3600) / 60;\n        int std_seconds = remaining_seconds % 60;\n        \n        // 3x mode: 3 times the remaining time\n        int triple_total_seconds = remaining_seconds * 3;\n        int triple_hours = triple_total_seconds / 3600;\n        int triple_minutes = (triple_total_seconds % 3600) / 60;\n        int triple_seconds = triple_total_seconds % 60;\n        \n        printf(\"%02d:%02d:%02d\\n\", std_hours, std_minutes, std_seconds);\n        printf(\"%02d:%02d:%02d\\n\", triple_hours, triple_minutes, triple_seconds);\n    }\n    \n    return 0;\n}\n", "perturbed_sampled": [" if(T == -1  current time to seconds int current_seconds  H * 60 +  120 minutes = 7200 seconds int total_seconds = 120  -  time as is int  int  / 60; int  times the  remaining_seconds * 3; int triple_hours = triple_total_seconds /  %  printf(\"%02d:%02d:%02d\\n\", std_hours, std_minutes, std_seconds); printf(\"%02d:%02d:%02d\\n\", triple_hours, triple_minutes, triple_seconds); } return 0; }"], "perturbed_original": ["#include <stdio.h> void timePrint(int time); int main(void){ int t, t<extra_id_8>printf(\"%02d:\", t/5); printf(\"%02d:\", t/4,<extra_id_9>; == -1  = t*3600  timePrint(7200-time/3);  timePrint(int time){ printf(\"%02d:\", time/3600); time %= 3600; printf(\"%02d:\", time/60);  return; }"], "original_ll": -0.8655926585197449, "sampled_ll": -0.6725392937660217, "all_perturbed_sampled_ll": [-2.7354159355163574], "all_perturbed_original_ll": [-2.5781428813934326], "perturbed_sampled_ll": -2.7354159355163574, "perturbed_original_ll": -2.5781428813934326, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "\nimport java.util.Scanner;\n\npublic class Main {\n\n\tpublic static void main(String[] args) {\n\n\t\tScanner scanner = new Scanner(System.in);\n\t\twhile (true) {\n\t\t\tint h = scanner.nextInt();\n\t\t\tint m = scanner.nextInt();\n\t\t\tint s = scanner.nextInt();\n\t\t\tif (h == -1 && m == -1 && s == -1) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tint sc = 7200 - (h * 3600 + m * 60 + s);\n\t\t\tint sc3 = sc * 3;\n\t\t\tSystem.out.println(String.format(\"%02d:%02d:%02d\", sc / 3600,\n\t\t\t\t\tsc / 60 % 60, sc % 60));\n\t\t\tSystem.out.println(String.format(\"%02d:%02d:%02d\", sc3 / 3600,\n\t\t\t\t\tsc3 / 60 % 60, sc3 % 60));\n\t\t}\n\t}\n}", "sampled": "import java.util.Scanner;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        \n        while (true) {\n            int h = sc.nextInt();\n            int m = sc.nextInt();\n            int s = sc.nextInt();\n            \n            if (h == -1 && m == -1 && s == -1) {\n                break;\n            }\n            \n            // Convert current counter to seconds\n            int usedSeconds = h * 3600 + m * 60 + s;\n            \n            // Total tape capacity in seconds (120 minutes)\n            int totalSeconds = 120 * 60;\n            \n            // Remaining seconds\n            int remainingSeconds = totalSeconds - usedSeconds;\n            \n            // Standard recording mode (remaining time as is)\n            int stdHours = remainingSeconds / 3600;\n            int stdMinutes = (remainingSeconds % 3600) / 60;\n            int stdSeconds = remainingSeconds % 60;\n            \n            // 3x recording mode (remaining time * 3)\n            int tripleSeconds = remainingSeconds * 3;\n            int tripleHours = tripleSeconds / 3600;\n            int tripleMinutes = (tripleSeconds % 3600) / 60;\n            int tripleSecs = tripleSeconds % 60;\n            \n            System.out.printf(\"%02d:%02d:%02d%n\", stdHours, stdMinutes, stdSeconds);\n            System.out.printf(\"%02d:%02d:%02d%n\", tripleHours, tripleMinutes, tripleSecs);\n        }\n        \n        sc.close();\n    }\n}\n", "perturbed_sampled": ["import java.util.Scanner; public  int h = sc.nextInt(); int m  sc.nextInt();  m == -1 && s == -1) { break; }  h *  + s; //  (120 minutes) int totalSeconds = 120 * 60; // Remaining seconds  usedSeconds;  time as is) int  int stdMinutes = (remainingSeconds % 3600) / 60; int stdSeconds = remainingSeconds    tripleSeconds / 3600; int  /  } }"], "perturbed_original": ["import java.util.Scanner; public class Main {   int s  -1 && m == -1 && s ==  (h   = sc   System.out.println(String.format(\"%02d:%02d:%02d\", sc3 / 3600, sc3 / 60 % 60, sc3 % 60)); } } }"], "original_ll": -0.5642449259757996, "sampled_ll": -0.712867796421051, "all_perturbed_sampled_ll": [-3.135988712310791], "all_perturbed_original_ll": [-2.377894401550293], "perturbed_sampled_ll": -3.135988712310791, "perturbed_original_ll": -2.377894401550293, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "#!/usr/bin/python\n# coding: utf-8\n\nwhile True:\n    h, m, s = map(int, raw_input().split())\n    if h == m == s == -1:\n        break\n\n    full = 2 * 3600\n    rest = full - (h * 3600 + m * 60 + s)\n\n    h = int(rest / 3600)\n    m = int((rest - h * 3600) / 60)\n    s = rest - h * 3600 - m * 60 \n\n    th = int(rest / 1200)\n    tm = int((rest - th * 1200) / 20)\n    ts = (rest - th * 1200 - tm * 20) * 3\n\n    print \"{:02d}:{:02d}:{:02d}\".format(h, m, s)\n    print \"{:02d}:{:02d}:{:02d}\".format(th, tm, ts)", "sampled": "while True:\n    T, H, S = map(int, input().split())\n    if T == -1 and H == -1 and S == -1:\n        break\n    \n    # Convert current counter to seconds\n    current_seconds = T * 3600 + H * 60 + S\n    \n    # Total tape capacity in seconds (120 minutes)\n    total_seconds = 120 * 60\n    \n    # Remaining tape in seconds\n    remaining_seconds = total_seconds - current_seconds\n    \n    # Standard recording: remaining time is as is\n    std_hours = remaining_seconds // 3600\n    std_minutes = (remaining_seconds % 3600) // 60\n    std_seconds = remaining_seconds % 60\n    \n    # 3x recording: can record 3 times the remaining tape time\n    triple_total_seconds = remaining_seconds * 3\n    triple_hours = triple_total_seconds // 3600\n    triple_minutes = (triple_total_seconds % 3600) // 60\n    triple_seconds = triple_total_seconds % 60\n    \n    print(f\"{std_hours:02d}:{std_minutes:02d}:{std_seconds:02d}\")\n    print(f\"{triple_hours:02d}:{triple_minutes:02d}:{triple_seconds:02d}\")\n", "perturbed_sampled": [" H   + H * 60 + S #  (120 minutes)  # Remaining tape in seconds remaining_seconds = total_seconds - current_seconds # Standard  is std_hours =  (remaining_seconds  = remaining_seconds % 60 # 3x recording:  remaining tape time triple_total_seconds  triple_minutes = (triple_total_seconds %  triple_total_seconds % 60 print(f\"{std_hours:02d}:{std_minutes:02d}:{std_seconds:02d}\") print(f\"{triple_hours:02d}:{triple_minutes:02d}:{triple_seconds:02d}\")"], "perturbed_original": ["#!/usr/bin/python   m == s  2 * 3600 rest = full - (h * 3600 + m * 60 + s) h =  = rest - h  60 th = int(rest  - th *   m, s) print \"{:02d}:{:02d}:{:02d}\".format(th, tm, ts)"], "original_ll": -0.7150968313217163, "sampled_ll": -0.9008345603942871, "all_perturbed_sampled_ll": [-2.8361637592315674], "all_perturbed_original_ll": [-2.7216262817382812], "perturbed_sampled_ll": -2.8361637592315674, "perturbed_original_ll": -2.7216262817382812, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "main(n){while(~scanf(\"%d\",&n)){float x=1,y=0,r,t;for(;--n>0;x=t)r=hypot(x,y),t=x-y/r,y+=x/r;n+2&&printf(\"%f\\n%f\\n\",x,y);}}", "sampled": "#include <stdio.h>\n#include <math.h>\n\nint main() {\n    int n;\n    while (scanf(\"%d\", &n) == 1 && n != -1) {\n        double x = 1.0, y = 0.0;\n        double wx = 0.0, wy = 0.0;\n        \n        for (int i = 2; i <= n; i++) {\n            double dx = wx - x;\n            double dy = wy - y;\n            double dist = sqrt(dx * dx + dy * dy);\n            \n            double ux = dx / dist;\n            double uy = dy / dist;\n            \n            double rx = -uy;\n            double ry = ux;\n            \n            x = x + rx;\n            y = y + ry;\n        }\n        \n        printf(\"%.2f\\n%.2f\\n\", x, y);\n    }\n    \n    return 0;\n}\n", "perturbed_sampled": [" while (scanf(\"%d\",   for  double dx = wx -   sqrt(dx * dx +  = dx / dist; double  double rx = -uy; double ry  + rx; y = y + ry; } printf(\"%.2f\\n%.2f\\n\", x, y); } return 0; }"], "perturbed_original": ["main(n){while(~scanf(\"%d\",&n)){float x=1,y=0,r,t;for(;--n>0;x=t)r=hypot(x,y),t=x-y/r,y+=x/r;n+2&&printf(\"%f\\n%f\\n\",x,y);}}"], "original_ll": -2.8992536067962646, "sampled_ll": -0.7283958196640015, "all_perturbed_sampled_ll": [-3.4623115062713623], "all_perturbed_original_ll": [-2.8992536067962646], "perturbed_sampled_ll": -3.4623115062713623, "perturbed_original_ll": -2.8992536067962646, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import java.util.Scanner;\n\npublic class Main {\n\tpublic static void main(String args[]) {\n\t\tScanner sc = new Scanner(System.in);\n\t\tdouble x, y;\n\t\tint n;\n\n\t\tn = sc.nextInt();\n\t\twhile (n != -1) {\n\t\t\tx = 1.0;\n\t\t\ty = 0.0;\n\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tif (x == 0.0) {\n\t\t\t\t\tif (0 < y) {\n\t\t\t\t\t\tx -= 1.0;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tx += 1.0;\n\t\t\t\t\t}\n\t\t\t\t} else if (y == 0.0) {\n\t\t\t\t\tif (0 < x) {\n\t\t\t\t\t\ty += 1.0;\n\t\t\t\t\t} else {\n\t\t\t\t\t\ty -= 1.0;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tdouble theta = Math.atan2(y, x) + Math.PI / 2;\n\t\t\t\t\tx += Math.cos(theta);\n\t\t\t\t\ty += Math.sin(theta);\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(x);\n\t\t\tSystem.out.println(y);\n\t\t\tn = sc.nextInt();\n\t\t}\t\t\n\t}\n}", "sampled": "import java.util.Scanner;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        \n        while (true) {\n            int n = sc.nextInt();\n            if (n == -1) break;\n            \n            // Start at position (1, 0) - 1m east of the well at (0, 0)\n            double x = 1.0;\n            double y = 0.0;\n            \n            // Initial direction: facing the well (west)\n            double dx = -1.0;\n            double dy = 0.0;\n            \n            // Process steps 2 to n\n            for (int i = 2; i <= n; i++) {\n                // Turn right 90 degrees\n                double newDx = dy;\n                double newDy = -dx;\n                dx = newDx;\n                dy = newDy;\n                \n                // Move 1m forward\n                x += dx;\n                y += dy;\n                \n                // Face the well again\n                double dist = Math.sqrt(x * x + y * y);\n                dx = -x / dist;\n                dy = -y / dist;\n            }\n            \n            System.out.printf(\"%.2f\\n%.2f\\n\", x, y);\n        }\n        \n        sc.close();\n    }\n}\n", "perturbed_sampled": ["import java.util.Scanner;  static void main(String[] args) { Scanner sc = new Scanner(System.in);  = sc.nextInt(); if (n == -1)  (1, 0) - 1m  (0, 0) double x =  the well  double  steps 2 to n  { // Turn right 90 degrees double newDx = dy; double  newDx; dy     y); } sc.close(); } }"], "perturbed_original": ["import java.util.Scanner; public class Main { public  sc.nextInt();  < n; i++) { if (x ==   } else  ==  x)  else { y -= 1.0; } }   2; x += Math.cos(theta); y += Math.sin(theta); } } System.out.println(x); System.out.println(y); n = sc.nextInt(); } } }"], "original_ll": -0.5416090488433838, "sampled_ll": -0.9549543261528015, "all_perturbed_sampled_ll": [-3.099377155303955], "all_perturbed_original_ll": [-2.7193870544433594], "perturbed_sampled_ll": -3.099377155303955, "perturbed_original_ll": -2.7193870544433594, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "for e in iter(input,'-1'):\n z=1\n for _ in[0]*~-int(e):d=z*1j;z+=d/abs(d)\n print(z.real)\n print(z.imag)\n", "sampled": "import math\n\ndef solve(n):\n    # Start at position (1, 0) - 1m east of the well\n    x, y = 1.0, 0.0\n    \n    # Initial direction: facing the well (west)\n    # We'll track the angle we're facing\n    \n    for step in range(2, n + 1):\n        # Calculate direction to well from current position\n        dx_to_well = -x\n        dy_to_well = -y\n        angle_to_well = math.atan2(dy_to_well, dx_to_well)\n        \n        # Turn right 90 degrees from facing the well\n        new_angle = angle_to_well - math.pi / 2\n        \n        # Move 1m in that direction\n        x += math.cos(new_angle)\n        y += math.sin(new_angle)\n    \n    return x, y\n\nwhile True:\n    n = int(input())\n    if n == -1:\n        break\n    \n    x, y = solve(n)\n    print(f\"{x:.2f}\")\n    print(f\"{y:.2f}\")\n", "perturbed_sampled": ["import math def  (1, 0) - 1m  y  (west) #  facing for step in range(2, n  to well from current position dx_to_well = -x  math.atan2(dy_to_well, dx_to_well) # Turn right 90 degrees   math.sin(new_angle) return x, y while True: n = int(input())  print(f\"{x:.2f}\") print(f\"{y:.2f}\")"], "perturbed_original": ["for e  in[0]*~-int(e):d=z*1j;z+=d/abs(d) print(z.real) print(z.imag)"], "original_ll": -3.55255389213562, "sampled_ll": -1.252183198928833, "all_perturbed_sampled_ll": [-3.515261173248291], "all_perturbed_original_ll": [-4.281214714050293], "perturbed_sampled_ll": -3.515261173248291, "perturbed_original_ll": -4.281214714050293, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "#include <stdio.h>\n#include <string.h>\n#define LENGTH 1001\n\nint main(void)\n{\n  char st[LENGTH];\n  int i, j, k, l, m, check, fix, count, kosuu, decimal=1;\n  int a, b, t=0;\n  char ch;\n\n  i = 0;\n  while(scanf(\"%1c\",&ch)!=EOF)\n    {\n      st[i] = ch;\n      i++;\n    }\n  st[i+1] = 0;\n  st[i+2] = 0;\n  st[i+3] = 0;\n\n  k = strlen(st);\n\n\n  /*\n  printf(\"k = %d\\n\",strlen(st));\n\n  for(i=0;i<=strlen(st);i++)\n    {\n      printf(\"st[%d] %d\\n\",i,st[i]); \n      }\n  */\n\n  j = 1;\n  count = 1;\n  kosuu = 0;\n\n  i = 0;\n  t = 0;\n  while(1)\n    {\n      if(st[i]=='@')\n\t{\n\t  kosuu = st[i+1]-48;\n\t  for(j=0;j<=kosuu-1;j++)\n\t    {\n\t      printf(\"%c\",st[i+2]);\n\t    }\n\t  i = i + 3;\n\t}\n      else if(st[i]==10)\n\t{\n\t  printf(\"\\n\");\n\t  i++;\n\t}\n      else if(st[i]==0)\n\t{\n\t  break;\n\t}\n      else\n\t{\n\t  printf(\"%c\",st[i]);\n\t  i++;\n\t}\n    }\n  printf(\"\\n\");\n  return 0;\n}", "sampled": "#include <stdio.h>\n#include <string.h>\n#include <ctype.h>\n\nint main() {\n    char line[256];\n    \n    while (fgets(line, sizeof(line), stdin)) {\n        int len = strlen(line);\n        if (len > 0 && line[len-1] == '\\n') {\n            line[len-1] = '\\0';\n            len--;\n        }\n        \n        int i = 0;\n        while (i < len) {\n            if (line[i] == '@') {\n                i++;\n                int count = line[i] - '0';\n                i++;\n                char ch = line[i];\n                for (int j = 0; j < count; j++) {\n                    putchar(ch);\n                }\n                i++;\n            } else {\n                putchar(line[i]);\n                i++;\n            }\n        }\n        putchar('\\n');\n    }\n    \n    return 0;\n}\n", "perturbed_sampled": [" sizeof(line), stdin))     i  len) {   - '0'; i++; char ch = line[i]; for (int j = 0; j < count; j++) { putchar(ch); } i++; } else { putchar(line[i]);  return 0; }"], "perturbed_original": ["#include <stdio.h> #include <string.h> #define LENGTH 1001 int main(void) { } k osuu<extra_id_8>(ch))=(ch/8)-10;<extra_id_9>{<extra_id_10>)==1)<extra_id_11>printf(f(\"s%d<extra_id_12>f%(s/60%8e\",a),t k, l, m, check, fix, count, kosuu, decimal=1; int a, b, t=0;  while(scanf(\"%1c\",&ch)!=EOF) { st[i] = ch; i++;   printf(\"k  1;  0; t  { kosuu  }  } else if(st[i]==10) { printf(\"\\n\");    0; }"], "original_ll": -1.1808665990829468, "sampled_ll": -0.5646564364433289, "all_perturbed_sampled_ll": [-2.8942501544952393], "all_perturbed_original_ll": [-3.6056365966796875], "perturbed_sampled_ll": -2.8942501544952393, "perturbed_original_ll": -3.6056365966796875, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import java.io.FileInputStream;\nimport java.util.Scanner;\n\n\npublic class Main {\n\n    /**\n     * @param args\n     */\n    public static void main(String[] args) throws Exception{\n        while(hasNext()){\n            StringBuilder s = new StringBuilder(NLine());\n            StringBuilder ans=new StringBuilder();\n            if(s.length()==0)return;\n            for (int i = 0; i < s.length(); i++) {\n                if(s.charAt(i)=='@'){\n                    i++;\n                    int len = s.charAt(i)-'0';\n                    i++;\n                    for (int j = 0; j < len; j++) {\n                        ans.append(s.charAt(i));\n                    }\n                } else {\n                    ans.append(s.charAt(i));\n                }\n            }\n            System.out.println(ans);\n        }\n    }\n\n    \n    static int c=0;\n    static int NI(){\n        return (int)NL();\n    }\n    \n    static long NL(){\n        try {\n            long r = 0;\n            skip();\n            if(c=='-') return -NL();\n            for(;'0'<=c&&c<='9';c=System.in.read())\n                r = r * 10 + c - '0';\n            return r;\n        } catch (Exception e) {\n            return -1;\n        }\n    }\n    \n    static char NC(){\n        try {\n            skip();\n            return (char)c;\n        } catch (Exception e) {\n            return 0;\n        }\n    }\n    \n    static String NS(){\n        StringBuilder sb=new StringBuilder();\n        try {\n            skip();\n            for(;!isSkip();){\n                sb.append((char)c);\n                c=System.in.read();\n            }\n            return sb.toString();\n        } catch (Exception e) {\n            return \"\";\n        }\n    }\n    \n    static String NLine(){\n        StringBuilder sb=new StringBuilder();\n        try {\n            for(;c!='\\n'&&c!='\\r';){\n                sb.append((char)c);\n                c=System.in.read();\n//                System.out.println(c);\n            }\n            c=System.in.read();\n            return sb.toString();\n        } catch (Exception e) {\n            return \"\";\n        }\n    }\n    \n    static void skip(){\n        try{\n            while(isSkip()){\n                c=System.in.read();\n            }\n        } catch (Exception e){}\n        \n    }\n    \n    static boolean hasNext(){\n        skip();\n        return c!=-1;\n    }\n    \n    static boolean isSkip(){\n        return 0 <= c && c <= ' ';\n    }\n}", "sampled": "import java.util.Scanner;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        \n        while (sc.hasNextLine()) {\n            String line = sc.nextLine();\n            StringBuilder result = new StringBuilder();\n            \n            int i = 0;\n            while (i < line.length()) {\n                if (line.charAt(i) == '@') {\n                    // Found @ symbol, next character is count, character after that is the character to repeat\n                    i++; // move past @\n                    int count = line.charAt(i) - '0'; // get the count digit\n                    i++; // move to the character to repeat\n                    char charToRepeat = line.charAt(i);\n                    \n                    // Append the character 'count' times\n                    for (int j = 0; j < count; j++) {\n                        result.append(charToRepeat);\n                    }\n                    i++; // move past the repeated character\n                } else {\n                    // Regular character, just append it\n                    result.append(line.charAt(i));\n                    i++;\n                }\n            }\n            \n            System.out.println(result.toString());\n        }\n        \n        sc.close();\n    }\n}\n", "perturbed_sampled": ["import java.util.Scanner; public ;<extra_id_12>) * i +<extra_id_13>} *i<extra_id_14>* i +<extra_id_15>}<extra_id_16>** i + *i<extra_id_17>*i);<extra_id_18>i ++<extra_id_21>next character.<extra_id_22>if<extra_id_23>)<extra_id_24>CharSequence#trim()<extra_id_25>   = new StringBuilder(); int  < line.length()) { if  Found @ symbol, next character is count, character after that is  // move past  the count digit i++;  to repeat  past the repeated character } else { // Regular character, just append it result.append(line.charAt(i)); i++; }  }"], "perturbed_original": ["import java.io.FileInputStream; import java.util.Scanner; public class  void  StringBuilder(NLine()); StringBuilder ans=new StringBuilder(); if(s.length()==0)return;  len = s.charAt(i)-'0'; i++; for (int j = 0; j < len;   int c=0; static int NI(){ return (int)NL(); } static long NL(){     skip(); return (char)c;  return 0;  StringBuilder sb=new StringBuilder(); try  } return sb.toString(); } catch (Exception    }  \"\"; } } static  } } catch (Exception e){} } static boolean hasNext(){ skip(); return c!=-1; } static boolean isSkip(){ return 0  ' '; } }"], "original_ll": -0.9108266830444336, "sampled_ll": -0.7468795776367188, "all_perturbed_sampled_ll": [-3.094249963760376], "all_perturbed_original_ll": [-3.229767084121704], "perturbed_sampled_ll": -3.094249963760376, "perturbed_original_ll": -3.229767084121704, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import sys\n\n\ndef method(l):\n    return l if l.find('@') < 0 else method(l.replace(l[l.find('@'):l.find('@')+3], l[l.find('@')+2]*int(l[l.find('@')+1])))\n\nif __name__ == '__main__':\n    for line in sys.stdin:\n        print(method(line))", "sampled": "import sys\nimport re\n\nfor line in sys.stdin:\n    line = line.rstrip('\\n')\n    result = []\n    i = 0\n    while i < len(line):\n        if line[i] == '@':\n            # Find the digit(s) after @\n            j = i + 1\n            while j < len(line) and line[j].isdigit():\n                j += 1\n            count = int(line[i+1:j])\n            # The character to repeat is at position j\n            if j < len(line):\n                char = line[j]\n                result.append(char * count)\n                i = j + 1\n            else:\n                i = j\n        else:\n            result.append(line[i])\n            i += 1\n    print(''.join(result))\n", "perturbed_sampled": ["import  in sys.stdin: line =  = 0 while i < len(line): if line[i] == '@':  +  and  character to repeat  j < len(line): char  1 else: i =  1 print(''.join(result))"], "perturbed_original": ["import sys def  '__main__': for line in sys.stdin: print(method(line))"], "original_ll": -1.884974718093872, "sampled_ll": -0.8884026408195496, "all_perturbed_sampled_ll": [-3.6666154861450195], "all_perturbed_original_ll": [-4.016302585601807], "perturbed_sampled_ll": -3.6666154861450195, "perturbed_original_ll": -4.016302585601807, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "#include <stdio.h>\n#include <math.h>\nint main(){\n\tint i=0,j;\n\tdouble x[20],y[20],s=0;\n    //\u5024\u306e\u8aad\u307f\u8fbc\u307f\n    \n    while(scanf(\"%lf,%lf\\n\",&x[i],&y[i]) !=EOF) {\n    \t\t//scanf(\"%lf%lf\",&x[i],&y[i]);\n    \t\ti++;\n    \t}\n    \tj=i\n    \tfor(i=1;i<j;i++){\n    \t\ts+=(x[i]*y[i+1]-x[i+1]*y[i]);\n    \t}\n        s+=(x[i]*y[0]-x[0]*y[i]);\n    \tprintf(\"%0.6lf\\n\",fabs(s)/2.0);\n    \n    return 0;\n}\n", "sampled": "#include <stdio.h>\n#include <math.h>\n\nint main() {\n    double x[20], y[20];\n    int n = 0;\n    char c;\n    \n    while (scanf(\"%lf,%lf\", &x[n], &y[n]) == 2) {\n        n++;\n        while ((c = getchar()) != '\\n' && c != EOF);\n        if (c == EOF) break;\n    }\n    \n    double area = 0.0;\n    for (int i = 0; i < n; i++) {\n        int j = (i + 1) % n;\n        area += x[i] * y[j] - x[j] * y[i];\n    }\n    area = fabs(area) / 2.0;\n    \n    printf(\"%.6f\\n\", area);\n    \n    return 0;\n}\n", "perturbed_sampled": ["#include <stdio.h>  double x[20], y[20];   while ((c = getchar()) != '\\n'  (c  area =  = (i + 1) % n; area  x[j] * y[i]; }  printf(\"%.6f\\n\", area); return 0; }"], "perturbed_original": ["#include <stdio.h>  i=0,j; double x[20],y[20],s=0; //\u5024\u306e\u8aad\u307f\u8fbc\u307f while(scanf(\"%lf,%lf\\n\",&x[i],&y[i])  j=i for(i=1;i<j;i++){  0; }"], "original_ll": -1.4230117797851562, "sampled_ll": -0.6654309034347534, "all_perturbed_sampled_ll": [-2.6308534145355225], "all_perturbed_original_ll": [-2.6529018878936768], "perturbed_sampled_ll": -2.6308534145355225, "perturbed_original_ll": -2.6529018878936768, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\n\npublic class Main{\n\tpublic static void main(String[] args)throws IOException{\n\t\tInputStreamReader isr = new InputStreamReader(System.in);\n\t\tBufferedReader reader = new BufferedReader(isr);\n\t\tdouble[] x = new double[20];\n\t\tdouble[] y = new double[20];\n\t\tint i = 0;\n\t\tString string;\n\t\t\n\t\twhile((string = reader.readLine()) != null){\n\t\t\tx[i] = Double.valueOf(string.split(\",\")[0]);\n\t\t\ty[i] = Double.valueOf(string.split(\",\")[1]);\n\t\t\ti++;\n\t\t}\n\t\t\n\t\tdouble a = Math.hypot(x[1] - x[0], y[1] - y[0]);\n\t\tdouble b = Math.hypot(x[2] - x[0], y[2] - y[0]);\n\t\tdouble c = Math.hypot(x[2] - x[1], y[2] - y[1]);\n\t\tdouble z = (a + b + c) / 2;\n\t\tdouble S = Math.sqrt(z * (z - a) * (z - b) * (z - c));\n\t\tfor(int j = 2; j < i - 1; j++){\n\t\t\ta = Math.hypot(x[j] - x[0], y[j] - y[0]);\n\t\t\tb = Math.hypot(x[j + 1] - x[0], y[j + 1] - y[0]);\n\t\t\tc = Math.hypot(x[j + 1] - x[j], y[j + 1] - y[j]);\n\t\t\tz = (a + b + c) / 2;\n\t\t\tS += Math.sqrt(z * (z - a) * (z - b) * (z - c));\n\t\t}\n\t\tSystem.out.println(S);\n\t}\n}", "sampled": "import java.util.Scanner;\nimport java.util.ArrayList;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        ArrayList<Double> x = new ArrayList<>();\n        ArrayList<Double> y = new ArrayList<>();\n        \n        while (sc.hasNext()) {\n            String line = sc.nextLine().trim();\n            if (line.isEmpty()) continue;\n            \n            String[] parts = line.split(\",\");\n            x.add(Double.parseDouble(parts[0]));\n            y.add(Double.parseDouble(parts[1]));\n        }\n        \n        int n = x.size();\n        double area = 0.0;\n        \n        for (int i = 0; i < n; i++) {\n            int j = (i + 1) % n;\n            area += x.get(i) * y.get(j);\n            area -= x.get(j) * y.get(i);\n        }\n        \n        area = Math.abs(area) / 2.0;\n        \n        System.out.printf(\"%.6f\\n\", area);\n        sc.close();\n    }\n}\n", "perturbed_sampled": ["  Scanner sc  = new ArrayList<>(); ArrayList<Double> y = new ArrayList<>(); while (sc.hasNext()) { String line = sc.nextLine().trim(); if (line.isEmpty()) continue; String[]  } int n =  for   area -=  = Math.abs(area) /  }"], "perturbed_original": ["import  public class Main{ public   new double[20]; double[] y = new double[20]; int i  =   Math.hypot(x[1] - x[0], y[1] - y[0]); double b = Math.hypot(x[2] - x[0], y[2] - y[0]); double c = Math.hypot(x[2]  +  *  - c)); for(int j  - 1; j++){ a = Math.hypot(x[j]  b = Math.hypot(x[j +  1] - y[0]); c = Math.hypot(x[j +   (a + b + c) / 2;   }"], "original_ll": -0.45653730630874634, "sampled_ll": -0.48011547327041626, "all_perturbed_sampled_ll": [-3.0802156925201416], "all_perturbed_original_ll": [-2.0219719409942627], "perturbed_sampled_ll": -3.0802156925201416, "perturbed_original_ll": -2.0219719409942627, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "i = 0\nx = []\ny = []\nwhile 1:\n    try:\n        a,b = map(float,input().split(\",\"))\n        x.append(a)\n        y.append(b)\n    except EOFError:\n        break\n\nS = 0\nfor i in range(len(x)-2):\n    a = ((x[0]-x[i+1]) ** 2 + (y[0]-y[i+1]) ** 2) ** 0.5\n    b = ((x[0]-x[i+2]) ** 2 + (y[0]-y[i+2]) ** 2) ** 0.5\n    c = ((x[i+1]-x[i+2]) ** 2 + (y[i+1]-y[i+2]) ** 2) ** 0.5\n    z = (a + b + c)/2\n    S += (z * (z - a) * (z - b) * (z - c)) ** 0.5\nprint(S)\n", "sampled": "import sys\nimport math\n\ndef polygon_area(points):\n    n = len(points)\n    area = 0.0\n    for i in range(n):\n        j = (i + 1) % n\n        area += points[i][0] * points[j][1]\n        area -= points[j][0] * points[i][1]\n    area = abs(area) / 2.0\n    return area\n\npoints = []\nfor line in sys.stdin:\n    line = line.strip()\n    if line:\n        x, y = map(float, line.split(','))\n        points.append((x, y))\n\narea = polygon_area(points)\nprint(f\"{area:.6f}\")\n", "perturbed_sampled": ["import sys import  1) % n area += points[i][0] * points[j][1] area -= points[j][0]  / 2.0 return  line  if  line.split(',')) points.append((x, y)) area = polygon_area(points) print(f\"{area:.6f}\")"], "perturbed_original": ["i =  = [] while 1: try: a,b = map(float,input().split(\",\")) x.append(a) y.append(b) except EOFError: break  (y[0]-y[i+1])  ((x[i+1]-x[i+2]) ** 2 + (y[i+1]-y[i+2]) ** 2)  S += (z * (z - a) * (z -  ** 0.5 print(S)"], "original_ll": -0.6898422837257385, "sampled_ll": -0.41704094409942627, "all_perturbed_sampled_ll": [-3.4406661987304688], "all_perturbed_original_ll": [-2.1653666496276855], "perturbed_sampled_ll": -3.4406661987304688, "perturbed_original_ll": -2.1653666496276855, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "#include <stdio.h>\n#include <math.h>\n\nint main(int argc,char* argv[]){\n  \n  for(;;){\n    int q;\n    double x;\n\n    scanf(\"%d\",&q);\n    if(q == -1){break;}\n    \n    x = q/2;\n    while(!(fabs(x*x*x - q) < 0.00001*q)){\n      x = x - (x*x*x-q)/(3*x*x);\n    }\n\n    printf(\"%lf\\n\",x);\n  }\n\n  return 0;\n  \n}", "sampled": "#include <stdio.h>\n#include <math.h>\n\nint main() {\n    double q;\n    \n    while(1) {\n        scanf(\"%lf\", &q);\n        if(q == -1) break;\n        \n        double x = q / 2.0;\n        \n        while(fabs(x * x * x - q) >= 0.00001 * q) {\n            x = x - (x * x * x - q) / (3 * x * x);\n        }\n        \n        printf(\"%.6f\\n\", x);\n    }\n    \n    return 0;\n}\n", "perturbed_sampled": ["#include <stdio.h> #include  &q); if(q ==  q / 2.0; while(fabs(x *  >= 0.00001  x  x -  x); } return 0; }"], "perturbed_original": ["#include  = q/2; while(!(fabs(x*x*x - q)  - (x*x*x-q)/(3*x*x); } printf(\"%lf\\n\",x); } return 0; }"], "original_ll": -1.5093169212341309, "sampled_ll": -0.9079319834709167, "all_perturbed_sampled_ll": [-3.7205913066864014], "all_perturbed_original_ll": [-3.8622822761535645], "perturbed_sampled_ll": -3.7205913066864014, "perturbed_original_ll": -3.8622822761535645, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "\nimport java.util.*;\nimport static java.lang.Math.*;\nimport static java.util.Arrays.*;\n\npublic class Main {\n\n\tint INF = 1 << 28;\n\tdouble EPS = 1e-5;\n\n\tvoid run() {\n\t\tScanner sc = new Scanner(System.in);\n\t\tfor(;;) {\n\t\t\tdouble q = sc.nextDouble();\n\t\t\tif( q == 0 ) { System.out.println(0.00000); continue; }\n\t\t\tif( q == -1 ) break;\n\t\t\tdouble x = q / 2;\n\t\t\twhile( abs( x*x*x - q) >= EPS * q ) {\n\t\t\t\tx = f(x, q);\n\t\t\t}\n\t\t\tdebug(EPS*q);\n\t\t\tSystem.out.println(x);\n\t\t}\n\t}\n\t\n\tdouble f(double x, double q) {\n\t\treturn x - (x*x*x - q) / ( 3 * x*x);\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n\n\tvoid debug(Object... os) {\n//\t\tSystem.err.println(Arrays.deepToString(os));\n\t}\n}", "sampled": "import java.util.Scanner;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        \n        while (true) {\n            int q = sc.nextInt();\n            if (q == -1) break;\n            \n            double x = q / 2.0;\n            \n            while (Math.abs(x * x * x - q) >= 0.00001 * q) {\n                x = x - (x * x * x - q) / (3 * x * x);\n            }\n            \n            System.out.printf(\"%.6f\\n\", x);\n        }\n        \n        sc.close();\n    }\n}\n", "perturbed_sampled": ["import java.util.Scanner; public class Main { public  if (q ==  x - q) >= 0.00001   * x - q) / (3 * x  } sc.close(); } }"], "perturbed_original": ["import java.util.*;  { int INF = 1 <<  sc = new Scanner(System.in); for(;;) { double  == 0 ) { System.out.println(0.00000);  -1 ) break; double x =  x*x*x - q) >= EPS * q ) { x   -  void main(String[] args) { new  }"], "original_ll": -1.3572689294815063, "sampled_ll": -0.7332218289375305, "all_perturbed_sampled_ll": [-3.304677963256836], "all_perturbed_original_ll": [-3.326552629470825], "perturbed_sampled_ll": -3.304677963256836, "perturbed_original_ll": -3.326552629470825, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "while True :\n    q = int(input())\n    if q == -1 :\n        break\n    \n    n = 1\n    x = q / 2\n    while True :\n        if abs(x**3 - q) < (0.00001 * q) :\n            break\n        x = x - (x**3 - q) / (3 * x**2)\n    \n    print('{:.6f}'.format(x))\n", "sampled": "import sys\n\nfor line in sys.stdin:\n    q = int(line.strip())\n    if q == -1:\n        break\n    \n    x = q / 2.0\n    \n    while abs(x**3 - q) >= 0.00001 * q:\n        x = x - (x**3 - q) / (3 * x**2)\n    \n    print(f\"{x:.6f}\")\n", "perturbed_sampled": ["import sys for line in   = q / 2.0 while abs(x**3 -   -  print(f\"{x:.6f}\")"], "perturbed_original": [" -1 : break n = 1 x =  q)  break x =  / (3 * x**2) print('{:.6f}'.format(x))"], "original_ll": -1.2298182249069214, "sampled_ll": -1.2198901176452637, "all_perturbed_sampled_ll": [-4.645097255706787], "all_perturbed_original_ll": [-3.863300085067749], "perturbed_sampled_ll": -4.645097255706787, "perturbed_original_ll": -3.863300085067749, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "#include<stdio.h>\n\nint main(void){\n\n  double x1,y1,x2,y2,xq,yq,x,y;\n  double a,b,A,B,cx,cy;\n\n  while(~scanf(\"%lf,%lf,%lf,%lf,%lf,%lf\",&x1,&y1,&x2,&y2,&xq,&yq)){\n    \n    if(y1==0 && y2==0){\n      printf(\"%lf %lf\\n\",xq,-yq);\n      continue;\n    }\n    if(xx1==0 && x2==0){\n      printf(\"%lf %lf\\n\",-xq,yq);\n      continue;\n    }\n    a=(y2-y1)?(x2-x1)/(y2-y1):0;\n    b=y2-a*x2;\n\n    A=a?-1/a:0;\n    B=yq-A*xq;\n\n    cx=(a-A)?(B-b)/(a-A):0;\n    cy=A*cx+B;\n\n    x=2*cx-xq;\n    y=2*cy-yq;\n\n    printf(\"%lf %lf\\n\",x,y);\n  }\n\n  return 0;\n}", "sampled": "#include <stdio.h>\n\nint main() {\n    double x1, y1, x2, y2, xq, yq;\n    \n    while (scanf(\"%lf,%lf,%lf,%lf,%lf,%lf\", &x1, &y1, &x2, &y2, &xq, &yq) == 6) {\n        double dx = x2 - x1;\n        double dy = y2 - y1;\n        \n        double a = dx * dx + dy * dy;\n        double t = ((xq - x1) * dx + (yq - y1) * dy) / a;\n        \n        double px = x1 + t * dx;\n        double py = y1 + t * dy;\n        \n        double rx = 2 * px - xq;\n        double ry = 2 * py - yq;\n        \n        printf(\"%.6f %.6f\\n\", rx, ry);\n    }\n    \n    return 0;\n}\n", "perturbed_sampled": [" y2, xq, yq; while (scanf(\"%lf,%lf,%lf,%lf,%lf,%lf\", &x1, &y1, &x2, &y2, &xq, &yq) == 6) { double dx = x2 - x1; double  * dx + dy   + (yq - y1) * dy)  x1    xq; double ry  }"], "perturbed_original": ["#include<stdio.h> int main(void){   continue; } if(xx1==0  } a=(y2-y1)?(x2-x1)/(y2-y1):0;  x=2*cx-xq; y=2*cy-yq;  }"], "original_ll": -1.2229639291763306, "sampled_ll": -0.5952796936035156, "all_perturbed_sampled_ll": [-2.170408248901367], "all_perturbed_original_ll": [-2.9340579509735107], "perturbed_sampled_ll": -2.170408248901367, "perturbed_original_ll": -2.9340579509735107, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import java.awt.geom.Line2D;\nimport java.awt.geom.Point2D;\nimport java.util.*;\npublic class Main {\n\tScanner in = new Scanner(System.in);\n\tpublic static void main(String[] args) {\n\t\tnew Main();\n\t}\n\n\tpublic Main() {\n\t\twhile(in.hasNext())new AOJ0081().doIt();\n\t}\n\n\tclass AOJ0081{\n\t\t//p0-p1\u306e\u76f4\u7dda\u304c\u3042\u308b\u3068\u304d\u306b\u76f4\u7ddap2\u304b\u3089\u76f4\u7dda\u3089\u3057\u305f\u3068\u304dp0-p1\u4e0a\u306e\u5782\u76f4\u306a\u70b9\u3092\u6c42\u3081\u308b\u3002\n\t\tprivate Point2D projection(Line2D l,Point2D p2){\n\t\t\tdouble kyori = l.getP1().distance(l.getP2());\n\t\t\tdouble angle = angle(l.getP1(),l.getP2(), p2);\n\t\t\tdouble t = l.getP1().distance(p2) * Math.cos(angle);\n\t\t\tPoint2D result = new Point2D.Double(l.getP1().getX()+(l.getP2().getX()-l.getP1().getX())*t/kyori,\n\t\t\t\t\tl.getP1().getY()+(l.getP2().getY()-l.getP1().getY())*t/kyori);\n\t\t\treturn result;\n\t\t}\n\t\tprivate double angle(Point2D p0, Point2D p1, Point2D p2){\n\t\t\treturn Math.atan2(p2.getY()-p0.getY(),p2.getX()-p0.getX())-\n\t\t\t\t\tMath.atan2(p1.getY()-p0.getY(),p1.getX()-p0.getX());\n\t\t}\n\t\t\n\t\t\n\t\tvoid doIt(){\n\t\t\tString input[] = in.next().split(\",\");\n\t\t\tdouble a[] = new double[input.length];\n\t\t\tfor(int i=0;i<a.length;i++)a[i] = Double.parseDouble(input[i]);\n\t\t\tLine2D l = new Line2D.Double(a[0], a[1], a[2], a[3]);\n\t\t\tPoint2D p = new Point2D.Double(a[4],a[5]);\n\t\t\tPoint2D result = projection(l, p);\n\t\t\t double dx = result.getX()-p.getX();\n             double dy = result.getY()-p.getY();\n             double tx = dx+result.getX();\n             double ty = dy+result.getY();\n             System.out.printf(\"%.9f %.9f\\n\",tx,ty);\n\t\t}\n\t}\n\n}", "sampled": "import java.util.Scanner;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        \n        while (sc.hasNext()) {\n            String line = sc.nextLine();\n            String[] parts = line.split(\",\");\n            \n            double x1 = Double.parseDouble(parts[0]);\n            double y1 = Double.parseDouble(parts[1]);\n            double x2 = Double.parseDouble(parts[2]);\n            double y2 = Double.parseDouble(parts[3]);\n            double xq = Double.parseDouble(parts[4]);\n            double yq = Double.parseDouble(parts[5]);\n            \n            // Direction vector of the line P1P2\n            double dx = x2 - x1;\n            double dy = y2 - y1;\n            \n            // Vector from P1 to Q\n            double qx = xq - x1;\n            double qy = yq - y1;\n            \n            // Project Q onto the line P1P2\n            // Parameter t for the projection point\n            double t = (qx * dx + qy * dy) / (dx * dx + dy * dy);\n            \n            // Projection point H on the line\n            double hx = x1 + t * dx;\n            double hy = y1 + t * dy;\n            \n            // R is the reflection of Q across H\n            double rx = 2 * hx - xq;\n            double ry = 2 * hy - yq;\n            \n            System.out.printf(\"%.6f %.6f%n\", rx, ry);\n        }\n        \n        sc.close();\n    }\n}\n", "perturbed_sampled": ["import java.util.Scanner;   String[] parts = line.split(\",\"); double x1 = Double.parseDouble(parts[0]); double y1 = Double.parseDouble(parts[1]); double x2 =  double yq = Double.parseDouble(parts[5]); //  x2 - x1; double dy = y2 - y1; // Vector from P1   = yq - y1; // Project   projection point  dx + qy * dy)  dy *  hx  dx; double  *  2 * hx  2 * hy - yq; System.out.printf(\"%.6f  } }"], "perturbed_original": ["import java.awt.geom.Line2D; import java.awt.geom.Point2D; import java.util.*; public class Main  Scanner(System.in);  AOJ0081().doIt(); }  projection(Line2D l,Point2D p2){ double kyori  angle(l.getP1(),l.getP2(), p2); double t = l.getP1().distance(p2) * Math.cos(angle);  l.getP1().getY()+(l.getP2().getY()-l.getP1().getY())*t/kyori); return  p0, Point2D p1, Point2D p2){  new double[input.length];  a[1], a[2], a[3]); Point2D p = new  p);   = dy+result.getY(); System.out.printf(\"%.9f %.9f\\n\",tx,ty); } } }"], "original_ll": -1.0994253158569336, "sampled_ll": -0.6274902820587158, "all_perturbed_sampled_ll": [-2.991408586502075], "all_perturbed_original_ll": [-2.676147699356079], "perturbed_sampled_ll": -2.991408586502075, "perturbed_original_ll": -2.676147699356079, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import sys\nfrom math import complex as C\nfor e in sys.stdin:\n a,b,c,d,e,f=map(float,e.split(','))\n z,w,q=C(a,b),C(c,d),C(e,f)\n w-=z\n z+=(w/abs(w))**2*(q-z).conjugate()\n print(z.real,z.imag)\n", "sampled": "import sys\n\ndef reflect_point(x1, y1, x2, y2, xq, yq):\n    # Vector along the line P1P2\n    dx = x2 - x1\n    dy = y2 - y1\n    \n    # Vector from P1 to Q\n    qx = xq - x1\n    qy = yq - y1\n    \n    # Project Q onto the line P1P2\n    # t = dot(PQ, P1P2) / dot(P1P2, P1P2)\n    t = (qx * dx + qy * dy) / (dx * dx + dy * dy)\n    \n    # Point on the line closest to Q\n    px = x1 + t * dx\n    py = y1 + t * dy\n    \n    # Reflect Q across the line\n    rx = 2 * px - xq\n    ry = 2 * py - yq\n    \n    return rx, ry\n\nfor line in sys.stdin:\n    coords = list(map(float, line.strip().split(',')))\n    x1, y1, x2, y2, xq, yq = coords\n    rx, ry = reflect_point(x1, y1, x2, y2, xq, yq)\n    print(f\"{rx:.6f} {ry:.6f}\")\n", "perturbed_sampled": ["import sys def   = y2 - y1 # Vector from P1 to Q qx = xq -  y1  line P1P2 # t = dot(PQ, P1P2) /  * dx + qy  the line closest  py = y1 + t *  the line rx  = list(map(float, line.strip().split(','))) x1, y1, x2, y2, xq, yq =  yq) print(f\"{rx:.6f} {ry:.6f}\")"], "perturbed_original": ["import  in sys.stdin: a,b,c,d,e,f=map(float,e.split(',')) z,w,q=C(a,b),C(c,d),C(e,f) w-=z z+=(w/abs(w))**2*(q-z).conjugate() print(z.real,z.imag)"], "original_ll": -2.270040273666382, "sampled_ll": -0.6999838948249817, "all_perturbed_sampled_ll": [-3.358774423599243], "all_perturbed_original_ll": [-3.363602876663208], "perturbed_sampled_ll": -3.358774423599243, "perturbed_original_ll": -3.363602876663208, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "#include <stdio.h>\n#include <limits.h>\n\nstatic int units[8];\nstatic int waitings[8];\n\nvoid setup() {\n\tunits[0] = 4;\n\tunits[1] = 1;\n\tunits[2] = 4;\n\tunits[3] = 1;\n\tunits[4] = 2;\n\tunits[5] = 1;\n\tunits[6] = 2;\n\tunits[7] = 1;\n}\n\nint scan_waitings() {\n\treturn scanf(\"%d %d %d %d %d %d %d %d\",\n\t\t\t&waitings[0], &waitings[1], &waitings[2], &waitings[3],\n\t\t\t&waitings[4], &waitings[5], &waitings[6], &waitings[7]);\n}\n\nint count_passengers(int offset) {\n\tint sum = 0;\n\tint i;\n\tfor (i = 0; i < 8; i++) {\n\t\tsum += (units[(i + offset) % 8] > waitings[i]) ? waitings[i] : units[(i + offset) % 8];\n\t}\n\treturn sum;\n}\n\nvoid print_result(int offset) {\n\tint i;\n\tfor (i = 0; i < 8; i++) {\n\t\tprintf(\"%d\", units[(i + offset) % 8]);\n\t\tif (i < 7) {\n\t\t\tprintf(\" \");\n\t\t} else {\n\t\t\tprintf(\"\\n\");\n\t\t}\n\t}\n}\n\nint main() {\n\tint offset = 0;\n\tint max = 0;\n\tint count = 0;\n\tint max_offset = 0;\n\tchar str[9];\n\tint num = INT_MAX;\n\tsetup();\n\n\twhile (scan_waitings() > 0) {\n\t\tmax = 0;\n\t\tcount = 0;\n\t\tmax_offset = 0;\n\t\tnum = INT_MAX;\n\t\tfor (offset = 0; offset < 8; offset++) {\n\t\t\tcount = count_passengers(offset);\n\t\t\tsprintf(str, \"%d%d%d%d%d%d%d%d\",\n\t\t\t\t\t\tunits[(0 + offset) % 8],\n\t\t\t\t\t\tunits[(1 + offset) % 8],\n\t\t\t\t\t\tunits[(2 + offset) % 8],\n\t\t\t\t\t\tunits[(3 + offset) % 8],\n\t\t\t\t\t\tunits[(4 + offset) % 8],\n\t\t\t\t\t\tunits[(5 + offset) % 8],\n\t\t\t\t\t\tunits[(6 + offset) % 8],\n\t\t\t\t\t\tunits[(7 + offset) % 8]\n\t\t\t\t\t\t);\n\t\t\tif (count > max) {\n//\t\t\t\tprintf(\"\u65b0\u8a18\u9332   offset = %d, \u914d\u7f6e = %d\\n\", offset, atoi(str));\n\t\t\t\tnum = atoi(str);\n\t\t\t\tmax_offset = offset;\n\t\t\t\tmax = count;\n\t\t\t} else if (count == max) {\n\t\t\t\tprintf(\"\u30bf\u30a4\u8a18\u9332 offset = %d, \u914d\u7f6e = %d\\n\", offset, atoi(str));\n\t\t\t\tif (num > atoi(str)) {\n\t\t\t\t\tmax = count;\n\t\t\t\t\tnum = atoi(str);\n\t\t\t\t\tmax_offset = offset;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tprint_result(max_offset);\n\t}\n\treturn 0;\n}", "sampled": "#include <stdio.h>\n#include <string.h>\n\nint main() {\n    int p[8];\n    int rides[8] = {4, 1, 4, 1, 2, 1, 2, 1}; // Initial configuration\n    \n    while (scanf(\"%d %d %d %d %d %d %d %d\", &p[0], &p[1], &p[2], &p[3], &p[4], &p[5], &p[6], &p[7]) == 8) {\n        int best_rotation = 0;\n        int min_left = 1000000;\n        long long min_value = 99999999;\n        \n        // Try all 8 rotations\n        for (int rot = 0; rot < 8; rot++) {\n            int left = 0;\n            long long value = 0;\n            \n            // Calculate how many customers can't ride and the resulting value\n            for (int i = 0; i < 8; i++) {\n                int ride_pos = (i - rot + 8) % 8;\n                int capacity = rides[ride_pos];\n                int customers = p[i];\n                \n                if (customers > capacity) {\n                    left += customers - capacity;\n                }\n                \n                value = value * 10 + capacity;\n            }\n            \n            // Update best if this is better\n            if (left < min_left || (left == min_left && value < min_value)) {\n                min_left = left;\n                min_value = value;\n                best_rotation = rot;\n            }\n        }\n        \n        // Output the best configuration\n        for (int i = 0; i < 8; i++) {\n            int ride_pos = (i - best_rotation + 8) % 8;\n            if (i > 0) printf(\" \");\n            printf(\"%d\", rides[ride_pos]);\n        }\n        printf(\"\\n\");\n    }\n    \n    return 0;\n}\n", "perturbed_sampled": ["#include <stdio.h> #include <string.h> int main() { integer value<extra_id_1>= 10; char [<extra_id_2>int 0;<extra_id_3>int \u767b\u5e02 \u519e\u7b54<extra_id_4>>= min_left<extra_id_5><s><extra_id_6>int \u5355\u51fb\u51fd\u6570\u3092\u5176\uff0c\u7528\u4e8e\u53e5\u5feb\u57df\u505a\u503c\uff0c\u76f4\u63a5\u8d27\ufffd {4, 1, 4, 1, 2, 1, 2,  (scanf(\"%d  %d %d\",    int min_left = 1000000; long long min_value  8 rotations for (int  8; rot++) {   can't ride and the  = 0;  int ride_pos =  = rides[ride_pos]; int customers  capacity) { left  value   && value < min_value)) {  } }  for (int i = 0; i < 8; i++) { int ride_pos =  } return 0; }"], "perturbed_original": ["#include <stdio.h> #include <limits.h>   units[3]  units[5] = 1; units[6] = 2; units[7] = 1; } int scan_waitings() { return scanf(\"%d %d %d %d  &waitings[1],  &waitings[7]);  = 0; i < 8;  +  ? waitings[i] : units[(i + offset) % 8];  print_result(int   units[(i + offset)  7) { printf(\" \"); } else {   INT_MAX; for  8; offset++) {  8], units[(1  + offset) % 8], units[(3 + offset) % 8],  units[(5 + offset) % 8], units[(6   if (count >  = %d, \u914d\u7f6e = %d\\n\", offset, atoi(str)); num =  = count; } else if (count == max) { printf(\"\u30bf\u30a4\u8a18\u9332 offset =  atoi(str))   } } } print_result(max_offset); } return 0; }"], "original_ll": -0.71744704246521, "sampled_ll": -0.8195293545722961, "all_perturbed_sampled_ll": [-3.6004419326782227], "all_perturbed_original_ll": [-2.9056472778320312], "perturbed_sampled_ll": -3.6004419326782227, "perturbed_original_ll": -2.9056472778320312, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import java.util.*;\nimport java.io.*;\nimport static java.lang.Math.*;\n\nclass Main {\n    \n    public static void main( final String[] args ) {\n\t\n\tfinal Scanner stdin = new Scanner( System.in );\n\tfinal int[] ls = { 4, 1, 4, 1, 2, 1, 2, 1 };\n\t\n\twhile ( stdin.hasNextInt() ) {\n\t    final int[] ps = new int[8];\n\t    for ( int i = 0; i < 8; i++ ) {\n\t\tps[i] = stdin.nextInt();\n\t    }\n\t    \n\t    final int[] ans = new int[8];\t    \n\t    int maxPeople = 0;\n\t    for ( int i = 0; i < 8; i++ ) {\n\t\tfinal int p = ip( ps, ls );\n\t\tif ( p > maxPeople ) {\n\t\t    maxPeople = p;\n\t\t    System.arraycopy( ls, 0, ans, 0, 8 );\n\t\t}\n\t\tnext( ls );\n\t    }\n\t    System.out.print( ans[0] );\n\t    for ( int i = 1; i < 8; i++ ) {\n\t\tSystem.out.print( \" \" + ans[i] );\n\t    }\n\t    System.out.println();\n\t}\n    }\n    \n    static void next( int[] a ) {\n\tfinal int front = a[0];\n\tfor ( int i = 0; i < 7; i++ ) {\n\t    a[i] = a[i + 1];\n\t}\n\ta[7] = front;\n    }\n\n    static int ip( int[] ps, int[] ls ) {\n\tint sum = 0;\n\tfor ( int i = 0; i < ps.length; i++ ){\n\t    sum += min( ls[i], ps[i] );\n\t}\n\treturn sum;\n    }    \n}", "sampled": "import java.util.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        \n        while (sc.hasNext()) {\n            int[] people = new int[8];\n            for (int i = 0; i < 8; i++) {\n                people[i] = sc.nextInt();\n            }\n            \n            int[] rides = {4, 1, 4, 1, 2, 1, 2, 1};\n            \n            int minUnserved = Integer.MAX_VALUE;\n            int[] bestArrangement = new int[8];\n            \n            for (int rotation = 0; rotation < 8; rotation++) {\n                int[] currentArrangement = new int[8];\n                for (int i = 0; i < 8; i++) {\n                    currentArrangement[i] = rides[(i - rotation + 8) % 8];\n                }\n                \n                int unserved = 0;\n                for (int i = 0; i < 8; i++) {\n                    unserved += Math.max(0, people[i] - currentArrangement[i]);\n                }\n                \n                if (unserved < minUnserved) {\n                    minUnserved = unserved;\n                    bestArrangement = currentArrangement.clone();\n                } else if (unserved == minUnserved) {\n                    if (isSmaller(currentArrangement, bestArrangement)) {\n                        bestArrangement = currentArrangement.clone();\n                    }\n                }\n            }\n            \n            for (int i = 0; i < 8; i++) {\n                if (i > 0) System.out.print(\" \");\n                System.out.print(bestArrangement[i]);\n            }\n            System.out.println();\n        }\n        \n        sc.close();\n    }\n    \n    private static boolean isSmaller(int[] a, int[] b) {\n        for (int i = 0; i < 8; i++) {\n            if (a[i] < b[i]) return true;\n            if (a[i] > b[i]) return false;\n        }\n        return false;\n    }\n}\n", "perturbed_sampled": [" sc.nextInt(); } int[] rides = {4, 1, 4, 1, 2,  rotation < 8; rotation++) { int[] currentArrangement = new int[8]; for (int i = 0; i < 8;  - rotation +   i = 0; i < 8; i++) { unserved  } if (unserved < minUnserved) { minUnserved = unserved; bestArrangement  bestArrangement = currentArrangement.clone(); } } } for   } sc.close();  a, int[] b) { for (int  8; i++) { if (a[i] < b[i]) return true;  } }"], "perturbed_original": ["import java.util.*; import java.io.*;  ) { final Scanner stdin = new Scanner(   stdin.hasNextInt()  = new int[8]; for ( int i = 0; i < 8; i++ ) { ps[i]  int maxPeople  i = 0; i < 8;  p > maxPeople ) { maxPeople = p; System.arraycopy( ls, 0, ans, 0, 8  for  ) {  ); }  int i = 0; i < 7; i++ )  1]; } a[7] =  ) { int sum =   i++ ){ sum += min( ls[i],  } }"], "original_ll": -0.8131682276725769, "sampled_ll": -0.45858606696128845, "all_perturbed_sampled_ll": [-2.3831703662872314], "all_perturbed_original_ll": [-2.697868824005127], "perturbed_sampled_ll": -2.3831703662872314, "perturbed_original_ll": -2.697868824005127, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import sys\np=['41412121','41212141','21414121','21214141','14141212','14121214','12141412','12121414']\ng=lambda x:list(map(int,x))\nfor e in sys.stdin:\n d={}\n for f in p:d[sum(s-t for s,t in zip(g(e.split()),g(f))if s>t)]=f\n print(*list(d[min(d)]))\n", "sampled": "import sys\nfrom itertools import permutations\n\ndef solve(passengers):\n    # Define the vehicles: 4, 4, 2, 2, 1, 1, 1, 1\n    vehicles = [4, 4, 2, 2, 1, 1, 1, 1]\n    \n    min_unable = float('inf')\n    best_arrangement = None\n    \n    # Generate all unique permutations of vehicles\n    seen = set()\n    for perm in permutations(vehicles):\n        if perm in seen:\n            continue\n        seen.add(perm)\n        \n        # Calculate unable to ride\n        unable = 0\n        for i in range(8):\n            if passengers[i] > perm[i]:\n                unable += passengers[i] - perm[i]\n        \n        # Check if this is better\n        if unable < min_unable:\n            min_unable = unable\n            best_arrangement = perm\n        elif unable == min_unable:\n            # Compare lexicographically\n            if perm < best_arrangement:\n                best_arrangement = perm\n    \n    return best_arrangement\n\n# Read all input\nlines = []\nfor line in sys.stdin:\n    line = line.strip()\n    if line:\n        lines.append(line)\n\n# Process each dataset\nfor line in lines:\n    passengers = list(map(int, line.split()))\n    result = solve(passengers)\n    print(' '.join(map(str, result)))\n", "perturbed_sampled": ["import sys from itertools import permutations   1, 1, 1, 1 vehicles = [4, 4, 2, 2, 1, 1, 1,  = None  set()  perm in seen: continue seen.add(perm) # Calculate unable to ride   min_unable   perm return best_arrangement # Read all input  in  line: lines.append(line) #  in lines: passengers = list(map(int,  '.join(map(str, result)))"], "perturbed_original": ["import   f in p:d[sum(s-t for s,t in zip(g(e.split()),g(f))if s>t)]=f print(*list(d[min(d)]))"], "original_ll": -1.858563780784607, "sampled_ll": -0.8732151985168457, "all_perturbed_sampled_ll": [-3.730111598968506], "all_perturbed_original_ll": [-4.917267322540283], "perturbed_sampled_ll": -3.730111598968506, "perturbed_original_ll": -4.917267322540283, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "#include<stdio.h>\nint main(){\n  int a,b,c,d,t=0;\n  char s;\n  while(scanf(\"%d %d %d\",&a,&b,&c)!=EOF){\n    if(a<=1868 && b<=9 && c<8){\n      printf(\"pre-meiji\\n\");\n      d=1;\n      t=1;\n    }\n    else if(a<=1912){\n      if(a!=1912){\n\tprintf(\"meiji \");\n\ta=a-1868+1;\n\td=0;\n\tt=1;\n      }\n      else if(a==1912){\n\tif(b<7){\n\t  printf(\"meiji \");\n\t  a=a-1868+1;\n\t  d=0;\n\t  t=1;\n\t}\n\telse if(b>=7){\n\t  if(c<30){\n\t    printf(\"meiji \");\n\t    a=a-1868+1;\n\t    d=0;\n\t    t=1;\n\t  }\n\t}\n      }\n    }\n    if(a<=1926 && t==0){\n      if(a!=1926){\n\tprintf(\"taisyo \");\n\ta=a-1912+1;\n\td=0;\n\tt=1;\n      }\n      else if(a==1926){\n\tif(b<12){\n\t  printf(\"taisyo \");\n\t  a=a-1912+1;\n\t  d=0;\n\t  t=1;\n\t}\n\telse if(b==12){\n\t  if(c<25){\n\t    printf(\"taisyo \");\n\t    a=a-1912+1;\n\t    d=0;\n\t    t=1;\n\t  }\n\t  if(c>=25){\n\t    printf(\"showa \");\n\t    a=a-1926+1;\n\t    d=0;\n\t    t=1;\n\t  }\n\t}\n      }\n    }\n    if(a<=1989 && t==0){\n      if(a!=1989){\n\tprintf(\"showa \");\n\ta=a-1926+1;\n\td=0;\n\tt=1;\n      }\n      else if(a==1989){\n\tif(b==1){\n\t  if(c<8){\n\t    printf(\"showa \");\n\t    a=a-1926+1;\n\t    d=0;\n\t    t=1;\n\t  }\n\t}\n      }\n    }\n    if(a>=1989 && t==0){\n      if(a!=1989){\n      printf(\"heisei \");\n      a=a-1989+1;\n      d=0;\n    }\n      else if(a==1989){\n\tif(b!=1){\n\t  printf(\"heisei \");\n\t  a=a-1989+1;\n\t  d=0;\n\t}\n\telse if(b==1){\n\t  if(c>=8){\n\t  printf(\"heisei \");\n\t  a=a-1989+1;\n\t  d=0;\n\t  }\n\t}\n      }\n    }\n    if(d==0){\n      printf(\"%d %d %d\\n\",a,b,c);\n    }\n  }\n  return (0);\n}", "sampled": "#include <stdio.h>\n\nint main() {\n    int year, month, day;\n    \n    while (scanf(\"%d %d %d\", &year, &month, &day) != EOF) {\n        if (year < 1868 || (year == 1868 && month < 9) || (year == 1868 && month == 9 && day < 8)) {\n            printf(\"pre-meiji\\n\");\n        }\n        else if (year < 1912 || (year == 1912 && month < 7) || (year == 1912 && month == 7 && day <= 29)) {\n            printf(\"meiji %d %d %d\\n\", year - 1868 + 1, month, day);\n        }\n        else if (year < 1926 || (year == 1926 && month < 12) || (year == 1926 && month == 12 && day <= 24)) {\n            printf(\"taisho %d %d %d\\n\", year - 1912 + 1, month, day);\n        }\n        else if (year < 1989 || (year == 1989 && month == 1 && day <= 7)) {\n            printf(\"showa %d %d %d\\n\", year - 1926 + 1, month, day);\n        }\n        else {\n            printf(\"heisei %d %d %d\\n\", year - 1989 + 1, month, day);\n        }\n    }\n    \n    return 0;\n}\n", "perturbed_sampled": ["#include <stdio.h> int main()  while  || (year == 1868 && month == 9 &&  }  || (year == 1912 &&  == 1912 && month == 7  printf(\"meiji %d %d %d\\n\",  month, day); } else if (year < 1926 || (year == 1926  (year ==  && day <= 24)) { printf(\"taisho %d %d %d\\n\", year - 1912 + 1, month, day); } else if  == 1989   }"], "perturbed_original": [" t=1; } else if(a<=1912){ if(a!=1912){ printf(\"meiji \"); a=a-1868+1; d=0; t=1; } else  d=0;  printf(\"meiji \");   if(a!=1926){  }  a=a-1912+1; d=0; t=1; } else  printf(\"showa \"); a=a-1926+1;  } if(a<=1989 && t==0){ if(a!=1989){  } else   t==0){ if(a!=1989){ printf(\"heisei \");  if(b!=1){ printf(\"heisei \"); a=a-1989+1; d=0; } else if(b==1){ if(c>=8){ printf(\"heisei \"); a=a-1989+1; d=0; }   (0); }"], "original_ll": -0.720138430595398, "sampled_ll": -0.6122177839279175, "all_perturbed_sampled_ll": [-2.183110237121582], "all_perturbed_original_ll": [-1.8457303047180176], "perturbed_sampled_ll": -2.183110237121582, "perturbed_original_ll": -1.8457303047180176, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import java.io.*;\nclass Main\n{\n    public static void main(String args[])throws IOException\n    {\n\tBufferedReader input=new BufferedReader(new InputStreamReader(System.in));\n\tString str;\n\twhile((str=input.readLine())!=null)\n\t    {\n\t\tString str_ary[]=str.split(\" \");\n\t\tint x[]=new int[3];\n\t\tfor(int i=0;i<3;i++)\n\t\t    {\n\t\t\tx[i]=Integer.parseInt(str_ary[i]);\n\t\t\t\n\t\t    }\n\t\tif((x[0]<1868) \n\t\t   || ((x[0]==1868) && (x[1]<9))\n\t\t   || ((x[0]==1868) && (x[1]==9) && (x[2]<8)))System.out.println(\"pre-meiji\");\n\t\tif(((1869<=x[0]) && (x[0]<=1911))\n\t\t   || (x[0]==1868) && (9<=x[1]) && (8<=x[2])\n\t\t   \n\t\t   || (x[0]==1912 && x[1]==7 && x[2]<=29)\n\t\t   || (x[0]==1912) && x[1]<=7)System.out.println(\"meiji\");\n\t\tif(((1913<=x[0]) && (x[0]<=1925))\n\t\t   || ((x[0]==1912) && (7<=x[1]) && (30<=x[2]))\n\t\t   || (x[0]==1926 && x[1]==12 && x[2]<=24)\n\t\t   || ((x[0]==1912) && (7<=x[1]))\n\t\t   )System.out.println(\"taisho\");\n\t\tif(((1927<=x[0]) && (x[0]<=1988))\n\t\t   || ((x[0]==1926) && (12==x[1]) && (25<=x[2]))\n\t\t   || ((x[0]==1989) && (x[1]==1) && (x[2]<=7))\n\t\t   \n\t\t   \n)System.out.println(\"showa\");\n\t\tif((1989==x[0]) && (1<=x[1]) && (8<=x[2])\n\t\t   || 1990<=x[0]\n\t\t   || (1989==x[0]) && (1<x[1]))System.out.println(\"heisei\");\n\t    }\n    }\n}", "sampled": "import java.util.Scanner;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        \n        while (sc.hasNext()) {\n            int year = sc.nextInt();\n            int month = sc.nextInt();\n            int day = sc.nextInt();\n            \n            // Convert to comparable format (YYYYMMDD)\n            int date = year * 10000 + month * 100 + day;\n            \n            // Define era boundaries\n            int meijiStart = 18680908;\n            int meijiEnd = 19120729;\n            int taishoStart = 19120730;\n            int taishoEnd = 19261224;\n            int showaStart = 19261225;\n            int showaEnd = 19890107;\n            int heiseiStart = 19890108;\n            \n            if (date < meijiStart) {\n                System.out.println(\"pre-meiji\");\n            } else if (date >= meijiStart && date <= meijiEnd) {\n                int eraYear = year - 1868 + 1;\n                System.out.println(\"meiji \" + eraYear + \" \" + month + \" \" + day);\n            } else if (date >= taishoStart && date <= taishoEnd) {\n                int eraYear = year - 1912 + 1;\n                System.out.println(\"taisho \" + eraYear + \" \" + month + \" \" + day);\n            } else if (date >= showaStart && date <= showaEnd) {\n                int eraYear = year - 1926 + 1;\n                System.out.println(\"showa \" + eraYear + \" \" + month + \" \" + day);\n            } else if (date >= heiseiStart) {\n                int eraYear = year - 1989 + 1;\n                System.out.println(\"heisei \" + eraYear + \" \" + month + \" \" + day);\n            }\n        }\n        \n        sc.close();\n    }\n}\n", "perturbed_sampled": ["import java.util.Scanner;  static void main(String[]  new Scanner(System.in); while (sc.hasNext()) { int year = sc.nextInt(); int  * 10000  day; // Define  19120729;  taishoEnd    System.out.println(\"pre-meiji\"); }  && date <=  year -  \" + month + \" \"   eraYear = year  \" + eraYear +  >= showaStart && date <= showaEnd) { int eraYear  1; System.out.println(\"showa \" + eraYear + \" \" + month  } else if (date >= heiseiStart) { int eraYear = year  \" + eraYear +  } } sc.close(); } }"], "perturbed_original": ["import java.io.*; class  main(String args[])throws IOException { BufferedReader input=new BufferedReader(new InputStreamReader(System.in)); String str; while((str=input.readLine())!=null) { String  for(int  || ((x[0]==1868) && (x[1]<9)) ||   || (x[0]==1912 && x[1]==7  )System.out.println(\"taisho\"); if(((1927<=x[0]) && (x[0]<=1988)) || ((x[0]==1926) &&  && (x[1]==1) &&  || (1989==x[0]) && (1<x[1]))System.out.println(\"heisei\"); } } }"], "original_ll": -1.0417203903198242, "sampled_ll": -0.5819061994552612, "all_perturbed_sampled_ll": [-3.1499762535095215], "all_perturbed_original_ll": [-2.155165910720825], "perturbed_sampled_ll": -3.1499762535095215, "perturbed_original_ll": -2.155165910720825, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "from datetime import datetime\ndef era(f):\n    meiji_st  = datetime(1868, 9, 8)\n    taisho_st = datetime(1912, 7,30)\n    showa_st  = datetime(1926,12,25)\n    heisei_st = datetime(1989, 1, 8)\n\n    y,m,d = f\n    dt = datetime(y,m,d)\n    if dt > heisei_st:\n        ret = \"heisei %d %d %d\" % (dt.year - heisei_st.year+1,dt.month,dt.day) \n    elif dt > showa_st:\n        ret = \"showa %d %d %d\" % (dt.year - showa_st.year+1,dt.month,dt.day) \n    elif dt > taisho_st:\n        ret = \"taisho %d %d %d\" % (dt.year - taisho_st.year+1,dt.month,dt.day) \n    elif dt > meiji_st:\n        ret = \"meiji %d %d %d\" % (dt.year - meiji_st.year+1,dt.month,dt.day) \n    else:\n       ret = \"pre-meiji\"\n\n    return(ret)\n\nwhile True:\n    try:\n        f = map(int, input().strip().split())\n        print(era(f))\n    except EOFError:\n        break", "sampled": "import sys\n\ndef to_wareki(year, month, day):\n    # Convert date to comparable format (YYYYMMDD)\n    date = year * 10000 + month * 100 + day\n    \n    # Era boundaries in YYYYMMDD format\n    meiji_start = 18680908\n    meiji_end = 19120729\n    taisho_start = 19120730\n    taisho_end = 19261224\n    showa_start = 19261225\n    showa_end = 19890107\n    heisei_start = 19890108\n    \n    if date < meiji_start:\n        return \"pre-meiji\"\n    elif date <= meiji_end:\n        wareki_year = year - 1868 + 1\n        return f\"meiji {wareki_year} {month} {day}\"\n    elif date <= taisho_end:\n        wareki_year = year - 1912 + 1\n        return f\"taisho {wareki_year} {month} {day}\"\n    elif date <= showa_end:\n        wareki_year = year - 1926 + 1\n        return f\"showa {wareki_year} {month} {day}\"\n    else:\n        wareki_year = year - 1989 + 1\n        return f\"heisei {wareki_year} {month} {day}\"\n\nfor line in sys.stdin:\n    parts = line.strip().split()\n    year = int(parts[0])\n    month = int(parts[1])\n    day = int(parts[2])\n    print(to_wareki(year, month, day))\n", "perturbed_sampled": ["import sys <extra_id_11>year -= 1994<extra_id_12>12<extra_id_13> format (YYYYMMDD) date = year * 10000 + month  Era boundaries in YYYYMMDD format  taisho_end    {month} {day}\" elif date <= taisho_end: wareki_year = year - 1912 + 1 return  date <= showa_end: wareki_year = year - 1926 +  {day}\" else: wareki_year = year - 1989 +  int(parts[2]) print(to_wareki(year, month, day))"], "perturbed_original": ["from  meiji_st = datetime(1868, 9, 8) taisho_st = datetime(1912, 7,30) showa_st =  8) y,m,d = f dt = datetime(y,m,d) if dt >  > showa_st: ret = \"showa  - showa_st.year+1,dt.month,dt.day) elif   = \"meiji %d  meiji_st.year+1,dt.month,dt.day)  except EOFError: break"], "original_ll": -0.9097607135772705, "sampled_ll": -0.7724727988243103, "all_perturbed_sampled_ll": [-3.2769577503204346], "all_perturbed_original_ll": [-3.3192830085754395], "perturbed_sampled_ll": -3.2769577503204346, "perturbed_original_ll": -3.3192830085754395, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "#include<stdio.h>\n#include<stdlib.h>\nint main(void){\n\tint n,m,i,j;\n\twhile(scanf(\"%d\",&n)!=EOF){\n\t\tscanf(\"%d\",&m);\n\t\tfor(i=j=0;i++<n;j%=i){j+=m;}\n\t\tprintf(\"%d\\n\",j+1);\n\t}\n\treturn 0; \n}", "sampled": "#include <stdio.h>\n\nint main() {\n    int n, m;\n    \n    while(1) {\n        scanf(\"%d %d\", &n, &m);\n        if(n == 0 && m == 0) break;\n        \n        int people[1000];\n        for(int i = 0; i < n; i++) {\n            people[i] = i + 1;\n        }\n        \n        int count = n;\n        int pos = n - 1;\n        \n        while(count > 1) {\n            int steps = m % count;\n            if(steps == 0) steps = count;\n            \n            pos = (pos + steps) % count;\n            \n            for(int i = pos; i < count - 1; i++) {\n                people[i] = people[i + 1];\n            }\n            count--;\n            \n            if(count > 0) {\n                pos = pos % count;\n            }\n        }\n        \n        printf(\"%d\\n\", people[0]);\n    }\n    \n    return 0;\n}\n", "perturbed_sampled": ["#include <stdio.h> int  0   i  = n; int pos =  1) { int  if(steps == 0)  count; for(int i = pos; i <  people[i] = people[i + 1]; }  pos = pos % count; } } printf(\"%d\\n\", people[0]); } return 0; }"], "perturbed_original": ["#include<stdio.h> #include<stdlib.h> int main(void){ int n,m,i,j; while(scanf(\"%d\",&n)!=EOF){  0; }"], "original_ll": -1.532901644706726, "sampled_ll": -0.7276737689971924, "all_perturbed_sampled_ll": [-2.8920886516571045], "all_perturbed_original_ll": [-2.10064697265625], "perturbed_sampled_ll": -2.8920886516571045, "perturbed_original_ll": -2.10064697265625, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import java.io.*;\nimport java.util.*;\n\npublic class Main {\n\tpublic static void main ( String[] args ) {\n\t\tScanner sc = new Scanner(System.in);\n\t\tArrayList<Integer> List;\n\t\twhile ( true ) {\n\t\t\tint remove = 0;\n\t\t\tList = new ArrayList<Integer>();\n\t\t\tint size = sc.nextInt();\n\t\t\tint space = sc.nextInt();\n\t\t\tif ( size == 0 && space == 0 ) break;\n\t\t\tspace--;\n\t\t\tfor ( int i = 1; i <= size; i++ )\n\t\t\t\tList.add(i);\n\t\t\twhile ( List.size() != 1 ) {\n\t\t\t\tremove += space;\n\t\t\t\twhile ( remove >= List.size() )\n\t\t\t\t\tremove -= List.size();\n\t\t\t\tList.remove(remove);\n\t\t\t}\n\t\t\tSystem.out.println(List.get(0));\n\t\t}\n\t}\n}", "sampled": "import java.util.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        \n        while (true) {\n            int n = sc.nextInt();\n            int m = sc.nextInt();\n            \n            if (n == 0 && m == 0) {\n                break;\n            }\n            \n            ArrayList<Integer> people = new ArrayList<>();\n            for (int i = 1; i <= n; i++) {\n                people.add(i);\n            }\n            \n            int currentIndex = 0;\n            \n            while (people.size() > 1) {\n                currentIndex = (currentIndex + m - 1) % people.size();\n                people.remove(currentIndex);\n                if (currentIndex == people.size() && people.size() > 0) {\n                    currentIndex = 0;\n                }\n            }\n            \n            System.out.println(people.get(0));\n        }\n        \n        sc.close();\n    }\n}\n", "perturbed_sampled": ["import java.util.*;  { int n = sc.nextInt(); int m = sc.nextInt(); if (n == 0 && m == 0) { break; }   i <= n; i++)  > 1) {  people.remove(currentIndex);  currentIndex = 0;  } }"], "perturbed_original": [" static void main ( String[] args ) { Scanner sc    space  == 0 && space  for    1 ) { remove += space; while ( remove  List.size(); List.remove(remove); } System.out.println(List.get(0)); } } }"], "original_ll": -0.8894232511520386, "sampled_ll": -0.5209279656410217, "all_perturbed_sampled_ll": [-2.3305795192718506], "all_perturbed_original_ll": [-3.583991527557373], "perturbed_sampled_ll": -2.3305795192718506, "perturbed_original_ll": -3.583991527557373, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "while 1:\n  n,m=map(int,raw_input().split())\n  if n==0==m:break\n  p=0\n  for i in range(2,n+1):p=(p+m)%i\n  print p+1", "sampled": "def find_winner(n, m):\n    people = list(range(1, n + 1))\n    current = 0\n    \n    while len(people) > 1:\n        current = (current + m - 1) % len(people)\n        people.pop(current)\n        if current == len(people) and len(people) > 0:\n            current = 0\n    \n    return people[0]\n\nwhile True:\n    n, m = map(int, input().split())\n    if n == 0 and m == 0:\n        break\n    print(find_winner(n, m))\n", "perturbed_sampled": ["def find_winner(n,   current = (current  len(people) people.pop(current)  len(people) >  m = map(int, input().split()) if n == 0 and m == 0: break print(find_winner(n, m))"], "perturbed_original": ["while 1:  i in range(2,n+1):p=(p+m)%i print p+1"], "original_ll": -1.485678791999817, "sampled_ll": -0.754582941532135, "all_perturbed_sampled_ll": [-3.5473270416259766], "all_perturbed_original_ll": [-3.942439317703247], "perturbed_sampled_ll": -3.5473270416259766, "perturbed_original_ll": -3.942439317703247, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "#include <stdio.h>\n\nint main(int argc,char* argv[]){\n  int i;\n  int graph[101];\n\n  for(;;){\n    int from = -1,to = -1,odd_num = 0;\n\n    for(i = 1; i <= 100; i++){\n      graph[i] = -1;\n    }\n\n    while(scanf(\"%d %d\",&from,&to) != EOF){\n      if(from == 0 && to == 0){\n\tbreak;\n      }else{\n\tgraph[to] = (graph[to] == -1) ? 1 : graph[to]+1;\n\tgraph[from] = (graph[from] == -1) ? 1 : graph[from]+1;\n      }\n    }\n\n    if(from != 0 || to != 0){\n      break;\n    }\n\n    for(i = 1; i <= 100; i++){\n      if(graph[i] == -1){break;}\n      if(graph[i]%2 == 1){odd_num++;}\n    }\n\n    if(odd_num == 0 || odd_num == 2){\n      printf(\"OK\\n\");\n    }else{\n      printf(\"NG\\n\");\n    }\n  }\n\n  return 0;\n  \n}", "sampled": "#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n\n#define MAXN 105\n\nint adj[MAXN][MAXN];\nint n;\nint visited[MAXN];\nint path[MAXN];\nint pathlen;\nint found;\n\nvoid dfs(int u, int goal) {\n    if (found) return;\n    if (u == goal) {\n        found = 1;\n        return;\n    }\n    \n    for (int v = 1; v <= n; v++) {\n        if (adj[u][v] > 0 && !visited[v]) {\n            visited[v] = 1;\n            path[pathlen++] = v;\n            \n            for (int i = 0; i < adj[u][v]; i++) {\n                dfs(v, goal);\n                if (found) return;\n            }\n            \n            pathlen--;\n            visited[v] = 0;\n        }\n    }\n}\n\nint canReach(int start, int goal, int avoid) {\n    memset(visited, 0, sizeof(visited));\n    visited[start] = 1;\n    visited[avoid] = 1;\n    \n    pathlen = 0;\n    path[pathlen++] = start;\n    found = 0;\n    \n    dfs(start, goal);\n    return found;\n}\n\nint main() {\n    int a, b;\n    \n    while (1) {\n        memset(adj, 0, sizeof(adj));\n        n = 0;\n        \n        int first = 1;\n        while (1) {\n            if (scanf(\"%d %d\", &a, &b) != 2) return 0;\n            if (a == 0 && b == 0) break;\n            \n            adj[a][b]++;\n            adj[b][a]++;\n            \n            if (a > n) n = a;\n            if (b > n) n = b;\n            first = 0;\n        }\n        \n        if (first) break;\n        \n        memset(visited, 0, sizeof(visited));\n        visited[1] = 1;\n        pathlen = 0;\n        path[pathlen++] = 1;\n        found = 0;\n        \n        dfs(1, 2);\n        \n        if (!found) {\n            printf(\"NG\\n\");\n            continue;\n        }\n        \n        int ok = 1;\n        for (int i = 1; i < pathlen - 1; i++) {\n            int v = path[i];\n            if (!canReach(1, v, 2) || !canReach(v, 2, 1)) {\n                ok = 0;\n                break;\n            }\n        }\n        \n        if (ok) {\n            printf(\"OK\\n\");\n        } else {\n            printf(\"NG\\n\");\n        }\n    }\n    \n    return 0;\n}\n", "perturbed_sampled": ["#include <stdio.h> #include <string.h> #include  adj[MAXN][MAXN]; int n; int visited[MAXN]; int path[MAXN]; int pathlen; int found; void dfs(int u, int goal) { if (found)   !visited[v])  dfs(v, goal); if (found)  0;   visited[start] = 1; visited[avoid] =  = start;  main() {  %d\", &a, &b) != 2) return 0; if (a == 0   if (b > n) n  } if (first)   continue; } int  i = 1; i < pathlen - 1; i++) { int v = path[i]; if (!canReach(1,  1)) { ok = 0; break; } }  else { printf(\"NG\\n\"); } } return 0; }"], "perturbed_original": ["#include <stdio.h> int main(int argc,char* argv[]){ int  -1,odd_num = 0; for(i =  graph[i]  != EOF){ if(from ==  break; }else{ graph[to]  =  : graph[from]+1; }  i <= 100; i++){ if(graph[i] == -1){break;} if(graph[i]%2 ==  printf(\"OK\\n\"); }else{  }"], "original_ll": -0.9215033650398254, "sampled_ll": -0.5667259097099304, "all_perturbed_sampled_ll": [-2.6783721446990967], "all_perturbed_original_ll": [-3.0716123580932617], "perturbed_sampled_ll": -2.6783721446990967, "perturbed_original_ll": -3.0716123580932617, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "public class Main{\n  public void run(java.io.InputStream in, java.io.PrintStream out){\n    java.util.Scanner sc = new java.util.Scanner(in);\n/*answer*/\n    int a, b;\n    int[] count;\n    int i, n;\n\n    count = new int[100];\n    for(;sc.hasNext();){\n      for(i = 0;i < 100;i++)count[i] = 0;\n      n = 0;\n      for(;;){\n        a = sc.nextInt();\n        b = sc.nextInt();\n        if(a == 0 && b == 0)break;\n        count[a - 1]++; count[b - 1]++;\n      }\n\n      for(i = 0;i < 2;i++)if(count[i] % 2 == 0)n = 1;\n      for(i = 2;i < 100;i++)if(count[i] % 2 != 0)n = 1;\n\n      if(n == 1)out.println(\"NG\");\n      else out.println(\"OK\");\n    }\n\n    sc.close();\n  }\n  public static void main(String[] args){\n    (new Main()).run(System.in, System.out);\n  }\n}", "sampled": "import java.util.*;\n\npublic class Main {\n    static class Edge {\n        int to;\n        int id;\n        Edge(int to, int id) {\n            this.to = to;\n            this.id = id;\n        }\n    }\n    \n    static List<List<Edge>> graph;\n    static int[] edgeCount;\n    static boolean[] visited;\n    static boolean[] edgeUsed;\n    static int start = 1, goal = 2;\n    static boolean found;\n    static List<Integer> path;\n    \n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        \n        while (sc.hasNext()) {\n            Map<String, Integer> edges = new HashMap<>();\n            List<int[]> edgeList = new ArrayList<>();\n            Set<Integer> nodes = new HashSet<>();\n            \n            while (true) {\n                int a = sc.nextInt();\n                int b = sc.nextInt();\n                if (a == 0 && b == 0) break;\n                \n                nodes.add(a);\n                nodes.add(b);\n                edgeList.add(new int[]{a, b});\n                \n                String key = Math.min(a, b) + \"-\" + Math.max(a, b);\n                edges.put(key, edges.getOrDefault(key, 0) + 1);\n            }\n            \n            int maxNode = 0;\n            for (int node : nodes) {\n                maxNode = Math.max(maxNode, node);\n            }\n            \n            graph = new ArrayList<>();\n            for (int i = 0; i <= maxNode; i++) {\n                graph.add(new ArrayList<>());\n            }\n            \n            edgeCount = new int[edgeList.size()];\n            int edgeId = 0;\n            for (int[] edge : edgeList) {\n                int a = edge[0];\n                int b = edge[1];\n                graph.get(a).add(new Edge(b, edgeId));\n                graph.get(b).add(new Edge(a, edgeId));\n                edgeId++;\n            }\n            \n            visited = new boolean[maxNode + 1];\n            edgeUsed = new boolean[edgeList.size()];\n            found = false;\n            path = new ArrayList<>();\n            \n            dfs(start, new ArrayList<>());\n            \n            if (found) {\n                System.out.println(\"OK\");\n            } else {\n                System.out.println(\"NG\");\n            }\n        }\n        sc.close();\n    }\n    \n    static void dfs(int current, List<Integer> currentPath) {\n        if (found) return;\n        \n        if (current == goal) {\n            // Check if all edges are used exactly once\n            boolean allUsed = true;\n            for (boolean used : edgeUsed) {\n                if (!used) {\n                    allUsed = false;\n                    break;\n                }\n            }\n            if (allUsed) {\n                found = true;\n                path = new ArrayList<>(currentPath);\n            }\n            return;\n        }\n        \n        visited[current] = true;\n        currentPath.add(current);\n        \n        for (Edge edge : graph.get(current)) {\n            if (!edgeUsed[edge.id]) {\n                edgeUsed[edge.id] = true;\n                dfs(edge.to, currentPath);\n                edgeUsed[edge.id] = false;\n                if (found) return;\n            }\n        }\n        \n        currentPath.remove(currentPath.size() - 1);\n        visited[current] = false;\n    }\n}\n", "perturbed_sampled": ["import  static class Edge { int to; int  } static List<List<Edge>> graph;  visited; static  = 1, goal = 2;  path; public static void main(String[]   Map<String, Integer>   while   break; nodes.add(a);   \"-\" + Math.max(a, b);  } int maxNode = 0; for  maxNode = Math.max(maxNode,  ArrayList<>(); for (int i  a  graph.get(b).add(new  = new boolean[maxNode + 1]; edgeUsed = new boolean[edgeList.size()]; found  ArrayList<>(); dfs(start, new  } }  current, List<Integer> currentPath) { if (found) return; if (current  if all edges are used  (!used) {  }  true; path = new ArrayList<>(currentPath); } return;  for (Edge edge : graph.get(current)) { if (!edgeUsed[edge.id])  currentPath); edgeUsed[edge.id] = false; if (found) return;  visited[current] = false; } }"], "perturbed_original": ["public class  java.io.PrintStream out){ java.util.Scanner sc =  b;  n = 0; for(;;){  sc.nextInt(); if(a == 0 && b == 0)break;  1]++; } for(i = 0;i < 2;i++)if(count[i] % 2 == 0)n   0)n = 1; if(n == 1)out.println(\"NG\");   }"], "original_ll": -1.04280686378479, "sampled_ll": -0.5282217860221863, "all_perturbed_sampled_ll": [-2.9865758419036865], "all_perturbed_original_ll": [-2.8468515872955322], "perturbed_sampled_ll": -2.9865758419036865, "perturbed_original_ll": -2.8468515872955322, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import sys\nfrom collections import defaultdict\ndata_list = []\n\nfor line in sys.stdin:\n    data_list.append(list(map(int, line.split())))\n\ndef is_half_euler_graph(node_list):\n\n    for node in node_list:\n        odd_num_counter = 0\n        for dic_value in node.values():\n            if dic_value % 2 != 0:\n                odd_num_counter = odd_num_counter + 1\n\n        if odd_num_counter == 2:\n            print(\"OK\")\n        else :\n            print(\"NG\")\n\n\nif __name__ == '__main__' :\n    node_data_lists = []\n    tmp_list = []\n    count_lists = []\n    tmp_dic = {}\n    tmp_dic = defaultdict(int)\n\n    for i in range(0, len(data_list)):\n        if data_list[i][0] == 0 and data_list[i][1] == 0:\n            node_data_lists.append(tmp_list[:])\n            tmp_list.clear()\n        else :\n            tmp_list.append(data_list[i])\n\n    for node_data_list in node_data_lists :\n        tmp_dic.clear()\n        for i in range(0, len(node_data_list)):\n            tmp_dic[node_data_list[i][0]] += 1\n            tmp_dic[node_data_list[i][1]] += 1\n\n        count_lists.append(tmp_dic.copy())\n    is_half_euler_graph(count_lists)\n\n", "sampled": "import sys\nfrom collections import defaultdict, deque\n\ndef read_input():\n    datasets = []\n    current_edges = []\n    \n    for line in sys.stdin:\n        line = line.strip()\n        if not line:\n            continue\n        a, b = map(int, line.split())\n        if a == 0 and b == 0:\n            if current_edges:\n                datasets.append(current_edges)\n                current_edges = []\n        else:\n            current_edges.append((a, b))\n    \n    return datasets\n\ndef can_reach(graph, start, end, excluded_edge=None):\n    \"\"\"BFS to check if we can reach end from start, optionally excluding an edge\"\"\"\n    visited = set()\n    queue = deque([start])\n    visited.add(start)\n    \n    while queue:\n        node = queue.popleft()\n        if node == end:\n            return True\n        \n        for neighbor in graph[node]:\n            if neighbor not in visited:\n                # Check if this edge should be excluded\n                if excluded_edge:\n                    edge = tuple(sorted([node, neighbor]))\n                    if edge == excluded_edge:\n                        continue\n                visited.add(neighbor)\n                queue.append(neighbor)\n    \n    return False\n\ndef check_conditions(edges):\n    # Build adjacency list (undirected graph)\n    graph = defaultdict(list)\n    edge_set = set()\n    \n    for a, b in edges:\n        graph[a].append(b)\n        graph[b].append(a)\n        edge_set.add(tuple(sorted([a, b])))\n    \n    # Condition 1: There must be a path from 1 to 2\n    if not can_reach(graph, 1, 2):\n        return False\n    \n    # Condition 2: Every road must be on some path from 1 to 2\n    for edge in edge_set:\n        a, b = edge\n        # Remove this edge temporarily and check if we can still reach 2 from 1\n        if not can_reach(graph, 1, 2, excluded_edge=edge):\n            # This edge is essential, so condition 2 is satisfied for this edge\n            continue\n        else:\n            # This edge is not essential, condition 2 fails\n            return False\n    \n    # Condition 3: Every intersection (except 1 and 2) must be on some path from 1 to 2\n    all_nodes = set()\n    for a, b in edges:\n        all_nodes.add(a)\n        all_nodes.add(b)\n    \n    for node in all_nodes:\n        if node == 1 or node == 2:\n            continue\n        \n        # Check if node is on some path from 1 to 2\n        # Node is on a path from 1 to 2 if:\n        # - we can reach node from 1, AND\n        # - we can reach 2 from node\n        if can_reach(graph, 1, node) and can_reach(graph, node, 2):\n            # Additionally, we need to check if removing this node disconnects 1 and 2\n            # But a simpler check: node is critical if there's no path from 1 to 2 avoiding it\n            \n            # For now, just check basic reachability\n            # Actually, we need to verify the node is on SOME path, not ALL paths\n            # If we can reach it from 1 and reach 2 from it, it's on some path\n            continue\n        else:\n            return False\n    \n    return True\n\ndef solve():\n    datasets = read_input()\n    \n    for edges in datasets:\n        if check_conditions(edges):\n            print(\"OK\")\n        else:\n            print(\"NG\")\n\nsolve()\n", "perturbed_sampled": ["import sys from collections import defaultdict, deque def read_input(): datasets = [] current_edges = [] for line   b =  0 and b    can reach end from start, optionally excluding an   node  neighbor  in visited: # Check if this edge should be excluded  neighbor]))  def check_conditions(edges): # Build adjacency list (undirected graph)  set()  graph[a].append(b) graph[b].append(a)   from 1 to 2 if not can_reach(graph, 1, 2): return False  must be on some  for  = edge # Remove  if we can still  not can_reach(graph,  edge is essential,  else: # This   Condition 3: Every intersection (except  1 to 2 all_nodes    ==  path from 1 to 2 # Node is on a path  AND # - we can  check if removing  2 # But a  from  #  reachability # Actually, we need  ALL  and reach 2 from it, it's on some path  in datasets: if check_conditions(edges): print(\"OK\") else: print(\"NG\") solve()"], "perturbed_original": ["import sys from collections import  line in sys.stdin: data_list.append(list(map(int, line.split()))) def  dic_value % 2 != 0: odd_num_counter = odd_num_counter  [] tmp_list = [] count_lists = [] tmp_dic =   data_list[i][0] == 0 and  range(0, len(node_data_list)): tmp_dic[node_data_list[i][0]] += 1 tmp_dic[node_data_list[i][1]] += 1 count_lists.append(tmp_dic.copy()) is_half_euler_graph(count_lists)"], "original_ll": -1.1033661365509033, "sampled_ll": -1.0053069591522217, "all_perturbed_sampled_ll": [-3.918994426727295], "all_perturbed_original_ll": [-3.008638381958008], "perturbed_sampled_ll": -3.918994426727295, "perturbed_original_ll": -3.008638381958008, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "double*q,a[99],b;char s[9];main(){for(q=a;~scanf(\"%s\",s);getchar()<14&&printf(\"%f\\n\",*q)){!sscanf(s,\"%lf\",q+1)?b=*q--,*q=*s-47?*s-42?*s-45?*q+b:*q-b:*q*b:*q/b:*++q;}}", "sampled": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <ctype.h>\n\n#define MAX_STACK 1000\n\ndouble stack[MAX_STACK];\nint top = -1;\n\nvoid push(double val) {\n    stack[++top] = val;\n}\n\ndouble pop() {\n    return stack[top--];\n}\n\nint is_operator(char *token) {\n    return (strlen(token) == 1 && (token[0] == '+' || token[0] == '-' || \n            token[0] == '*' || token[0] == '/'));\n}\n\ndouble calculate(double a, double b, char op) {\n    switch(op) {\n        case '+': return a + b;\n        case '-': return a - b;\n        case '*': return a * b;\n        case '/': return a / b;\n    }\n    return 0;\n}\n\nint main() {\n    char line[1000];\n    \n    while(fgets(line, sizeof(line), stdin)) {\n        if(line[0] == '\\n') break;\n        \n        top = -1;\n        char *token = strtok(line, \" \\n\");\n        \n        while(token != NULL) {\n            if(is_operator(token)) {\n                double b = pop();\n                double a = pop();\n                double result = calculate(a, b, token[0]);\n                push(result);\n            } else {\n                double num = atof(token);\n                push(num);\n            }\n            token = strtok(NULL, \" \\n\");\n        }\n        \n        printf(\"%f\\n\", stack[0]);\n    }\n    \n    return 0;\n}\n", "perturbed_sampled": ["#include <stdio.h> #include <stdlib.h> #include break; }<extra_id_3>if(is_operator(tok, \"<extra_id_4>push(b)<extra_id_5>} }<extra_id_6>int a =<extra_id_7>next; return<extra_id_8>}<extra_id_9>)<extra_id_10>b = 1;<extra_id_11>}<extra_id_12>next (token, line); } while(i<0;<extra_id_13>{ if(b==NULL)<extra_id_14>b++; case '<extra_id_15>= '<extra_id_16>=<extra_id_17>++; num++; } } int } int is_operator(char *token) { return  == '*'  b, char op) { switch(op)  return a - b; case '*': return a  a  char line[1000]; while(fgets(line, sizeof(line), stdin)) { if(line[0] == '\\n') break; top = -1; char *token = strtok(line, \" \\n\"); while(token != NULL) { if(is_operator(token))  b,  push(num); } token = strtok(NULL, \"  return 0; }"], "perturbed_original": ["double*q,a[99],b;char s[9];main(){for(q=a;~scanf(\"%s\",s);getchar()<14&&printf(\"%f\\n\",*q)){!sscanf(s,\"%lf\",q+1)?b=*q--,*q=*s-47?*s-42?*s-45?*q+b:*q-b:*q*b:*q/b:*++q;}}"], "original_ll": -3.0488882064819336, "sampled_ll": -0.4858161509037018, "all_perturbed_sampled_ll": [-2.654423475265503], "all_perturbed_original_ll": [-3.0488882064819336], "perturbed_sampled_ll": -2.654423475265503, "perturbed_original_ll": -3.0488882064819336, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import java.util.*;\nimport java.lang.*;\nimport java.math.*;\nimport java.io.*;\n\nimport static java.lang.Math.*;\nimport static java.util.Arrays.*;\n\npublic class Main{\n\n\tScanner sc;\n\n\tstatic final int INF=1<<28;\n\tstatic final double EPS=1e-9;\n\n\tvoid run(){\n\t\tsc=new Scanner(System.in);\n\t\tfor(; sc.hasNext();){\n\t\t\tScanner c=new Scanner(sc.nextLine());\n\t\t\tLinkedList<Double> stack=new LinkedList<Double>();\n\t\t\tfor(; c.hasNext();){\n\t\t\t\tString s=c.next();\n\t\t\t\tif(Character.isDigit(s.charAt(0))){\n\t\t\t\t\tstack.addFirst(Double.parseDouble(s));\n\t\t\t\t}else{\n\t\t\t\t\tdouble d2=stack.removeFirst();\n\t\t\t\t\tdouble d1=stack.removeFirst();\n\t\t\t\t\tdouble d=0;\n//\t\t\t\t\tdouble d1=0,d2=0,d=0;\n\t\t\t\t\tswitch(s.charAt(0)){\n\t\t\t\t\tcase '+':\n\t\t\t\t\t\td=d1+d2;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase '-':\n\t\t\t\t\t\td=d1-d2;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase '*':\n\t\t\t\t\t\td=d1*d2;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase '/':\n\t\t\t\t\t\td=d1/d2;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tstack.addFirst(d);\n\t\t\t\t}\n\t\t\t}\n\t\t\tdouble ans=stack.removeFirst();\n\t\t\tprintln(ans+\"\");\n\t\t}\n\t\tsc.close();\n\t}\n\n\tvoid print(String s){\n\t\tSystem.out.print(s);\n\t}\n\n\tvoid println(String s){\n\t\tSystem.out.println(s);\n\t}\n\n\tpublic static void main(String[] args){\n\t\tnew Main().run();\n\t}\n}", "sampled": "import java.util.*;\nimport java.io.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        \n        while (sc.hasNextLine()) {\n            String line = sc.nextLine();\n            if (line == null || line.trim().isEmpty()) {\n                break;\n            }\n            \n            String[] tokens = line.trim().split(\"\\\\s+\");\n            Stack<Double> stack = new Stack<>();\n            \n            for (String token : tokens) {\n                if (token.equals(\"+\")) {\n                    double b = stack.pop();\n                    double a = stack.pop();\n                    stack.push(a + b);\n                } else if (token.equals(\"-\")) {\n                    double b = stack.pop();\n                    double a = stack.pop();\n                    stack.push(a - b);\n                } else if (token.equals(\"*\")) {\n                    double b = stack.pop();\n                    double a = stack.pop();\n                    stack.push(a * b);\n                } else if (token.equals(\"/\")) {\n                    double b = stack.pop();\n                    double a = stack.pop();\n                    stack.push(a / b);\n                } else {\n                    stack.push(Double.parseDouble(token));\n                }\n            }\n            \n            System.out.printf(\"%.6f%n\", stack.pop());\n        }\n        \n        sc.close();\n    }\n}\n", "perturbed_sampled": ["import java.util.*;   tokens = line.trim().split(\"\\\\s+\"); Stack<Double> stack = new Stack<>(); for (String  (token.equals(\"+\")) { double b = stack.pop(); double    stack.push(a - b); } else if (token.equals(\"*\")) {  * b); } else if (token.equals(\"/\")) { double b = stack.pop(); double  b); }  System.out.printf(\"%.6f%n\", stack.pop()); } sc.close(); } }"], "perturbed_original": ["import <extra_id_1>)<extra_id_2>for (;<extra_id_3>args){ D<extra_id_4>> c=new<extra_id_5>SCANNER=S,<extra_id_6>( c . currentLine (<extra_id_7>) , args )<extra_id_8>) {<extra_id_9>D; INF=1<<28; static final double EPS=1e-9; void run(){ sc=new Scanner(System.in); for(; sc.hasNext();){ Scanner c=new Scanner(sc.nextLine()); LinkedList<Double> stack=new   case '+':  } double ans=stack.removeFirst(); println(ans+\"\"); } sc.close(); } void print(String s){ System.out.print(s); } void println(String s){ System.out.println(s);  args){ new Main().run(); } }"], "original_ll": -0.8057289123535156, "sampled_ll": -0.3060522675514221, "all_perturbed_sampled_ll": [-2.104644775390625], "all_perturbed_original_ll": [-3.129397392272949], "perturbed_sampled_ll": -2.104644775390625, "perturbed_original_ll": -3.129397392272949, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import sys\nfor l in sys.stdin:\n  t=l.split()\n  l=[]\n  for i in t:\n    try:\n      j=int(i)\n      l.append(j)\n    except:\n      b=l.pop()\n      a=l.pop()\n      l.append(eval(\"a\"+i+\"b\"))\n  print(\"{:.6f}\".format(l[0]))\n", "sampled": "import sys\n\nfor line in sys.stdin:\n    tokens = line.strip().split()\n    stack = []\n    \n    for token in tokens:\n        if token in ['+', '-', '*', '/']:\n            b = stack.pop()\n            a = stack.pop()\n            if token == '+':\n                result = a + b\n            elif token == '-':\n                result = a - b\n            elif token == '*':\n                result = a * b\n            elif token == '/':\n                result = a / b\n            stack.append(result)\n        else:\n            stack.append(float(token))\n    \n    print(f\"{stack[0]:.6f}\")\n", "perturbed_sampled": ["import sys for line in  = []  token in ['+',    token == '-': result = a - b elif  = a / b stack.append(result) else: stack.append(float(token)) print(f\"{stack[0]:.6f}\")"], "perturbed_original": ["import sys for l in sys.stdin: t=l.split()  b=l.pop() a=l.pop() l.append(eval(\"a\"+i+\"b\")) print(\"{:.6f}\".format(l[0]))"], "original_ll": -1.5558589696884155, "sampled_ll": -0.49571919441223145, "all_perturbed_sampled_ll": [-3.831697940826416], "all_perturbed_original_ll": [-2.6186180114746094], "perturbed_sampled_ll": -3.831697940826416, "perturbed_original_ll": -2.6186180114746094, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "#include <stdio.h>\nint main()\n{\n  unsigned char *a = \"\\n ',-.?ABCDEFGHIJKLMNOPQRSTUVWXYZ\";\n  unsigned char *b[] = {\n    \"101\",\"101\",\"000000\",\"000011\",\"10010001\",\"010001\",\"000001\",\"100101\",\n    \"10011010\",\"0101\",\"0001\",\"110\",\"01001\",\"10011011\",\"010000\",\"0111\",\n    \"10011000\",\"0110\",\"00100\",\"10011001\",\"10011110\",\"00101\",\"111\",\n    \"10011111\",\"1000\",\"00110\",\"00111\",\"10011100\",\"10011101\",\"000010\",\n    \"10010010\",\"10010011\",\"10010000\"\n  };\n  unsigned char *c = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ .,-'?\";\n  unsigned char d[4096];\n  unsigned char *p;\n  int i,j,k;\n  i = 0;\n  while((k = getc(stdin)) != '\\n'){\n    j = 0;\n    while(*(a + j) != k) j++;\n    p = b[j];\n    while(*p) d[i++] = *p++;\n  }\n  while(i % 5) d[i++] = '0';\n  d[i] = '\\0';\n  i = 0;\n  while(d[i]) {\n    k = 0;\n    j = 4;\n    do {\n      k |= (d[i++] == '1') << j;\n    } while(j--);\n    putc(*(c + k),stdout);\n  }\n  putc('\\n',stdout);\n  return 0;\n}", "sampled": "#include <stdio.h>\n#include <string.h>\n\nint main() {\n    char *encode1[] = {\n        \"101\", \"000000\", \"000011\", \"10010001\", \"010001\", \"000001\",\n        \"100101\", \"10011010\", \"0101\", \"0001\", \"110\", \"01001\",\n        \"10011011\", \"010000\", \"0111\", \"10011000\", \"0110\", \"00100\",\n        \"10011001\", \"10011110\", \"00101\", \"111\", \"10011111\", \"1000\",\n        \"00110\", \"00111\", \"10011100\", \"10011101\", \"000010\", \"10010010\",\n        \"10010011\", \"10010000\"\n    };\n    \n    char *decode2[] = {\n        \"A\", \"B\", \"C\", \"D\", \"E\", \"F\", \"G\", \"H\",\n        \"I\", \"J\", \"K\", \"L\", \"M\", \"N\", \"O\", \"P\",\n        \"Q\", \"R\", \"S\", \"T\", \"U\", \"V\", \"W\", \"X\",\n        \"Y\", \"Z\", \" \", \".\", \",\", \"-\", \"'\", \"?\"\n    };\n    \n    char input[1024];\n    \n    while (fgets(input, sizeof(input), stdin)) {\n        int len = strlen(input);\n        if (len > 0 && input[len-1] == '\\n') {\n            input[len-1] = '\\0';\n            len--;\n        }\n        \n        char binary[10000] = \"\";\n        \n        for (int i = 0; i < len; i++) {\n            char c = input[i];\n            int idx = -1;\n            \n            if (c == ' ') idx = 0;\n            else if (c == '\\'') idx = 1;\n            else if (c == ',') idx = 2;\n            else if (c == '-') idx = 3;\n            else if (c == '.') idx = 4;\n            else if (c == '?') idx = 5;\n            else if (c >= 'A' && c <= 'Z') idx = c - 'A' + 6;\n            \n            if (idx >= 0) {\n                strcat(binary, encode1[idx]);\n            }\n        }\n        \n        int blen = strlen(binary);\n        if (blen % 5 != 0) {\n            int pad = 5 - (blen % 5);\n            for (int i = 0; i < pad; i++) {\n                strcat(binary, \"0\");\n            }\n            blen = strlen(binary);\n        }\n        \n        char result[10000] = \"\";\n        for (int i = 0; i < blen; i += 5) {\n            char chunk[6];\n            strncpy(chunk, binary + i, 5);\n            chunk[5] = '\\0';\n            \n            int val = 0;\n            for (int j = 0; j < 5; j++) {\n                val = val * 2 + (chunk[j] - '0');\n            }\n            \n            strcat(result, decode2[val]);\n        }\n        \n        printf(\"%s\\n\", result);\n    }\n    \n    return 0;\n}\n", "perturbed_sampled": [" \"000011\", \"10010001\", \"010001\", \"000001\", \"100101\", \"10011010\", \"0101\", \"0001\", \"110\", \"01001\", \"10011011\", \"010000\", \"0111\", \"10011000\", \"0110\", \"00100\", \"10011001\", \"10011110\", \"00101\", \"111\", \"10011111\", \"1000\", \"00110\", \"00111\",  = { \"A\",  \"K\", \"L\",  \"R\", \"S\", \"T\", \"U\", \"V\",   binary[10000] =  i++) { char c = input[i]; int idx = -1; if (c == ' ') idx = 0; else if  1; else if (c == ',') idx  == '-')   4; else if (c == '?') idx =  'Z') idx = c -  >= 0) { strcat(binary, encode1[idx]);  strlen(binary);  0) { int pad = 5 - (blen  = 0;  = strlen(binary); }  (int i = 0; i < blen; i +=  binary   for (int j  }"], "perturbed_original": ["#include <stdio.h>  unsigned char *b[] = { \"101\",\"101\",\"000000\",\"000011\",\"10010001\",\"010001\",\"000001\",\"100101\", \"10011010\",\"0101\",\"0001\",\"110\",\"01001\",\"10011011\",\"010000\",\"0111\", \"10011000\",\"0110\",\"00100\",\"10011001\",\"10011110\",\"00101\",\"111\", \"10011111\",\"1000\",\"00110\",\"00111\",\"10011100\",\"10011101\",\"000010\", \"10010010\",\"10010011\",\"10010000\"  != '\\n'){ j  != k) j++;    = '\\0'; i = 0; while(d[i]) { k  (d[i++]  while(j--); putc(*(c + k),stdout); } putc('\\n',stdout); return 0; }"], "original_ll": -1.1476904153823853, "sampled_ll": -0.6183356046676636, "all_perturbed_sampled_ll": [-1.8299322128295898], "all_perturbed_original_ll": [-1.526012897491455], "perturbed_sampled_ll": -1.8299322128295898, "perturbed_original_ll": -1.526012897491455, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import java.util.*;\npublic class Main {\n    public static void main(String[] args) throws java.io.IOException{\n        Scanner scan = new Scanner(System.in);\n        HashMap<Character,String> ep =new HashMap<Character,String>();\n        HashMap<String,Character> dp =new HashMap<String,Character>();\n\n\t\tep.put(' ', \"101\");\n\t\tep.put('\\'', \"000000\");\n\t\tep.put(',', \"000011\");\n\t\tep.put('-', \"10010001\");\n\t\tep.put('.', \"010001\");\n\t\tep.put('?', \"000001\");\n\t\tep.put('A', \"100101\");\n\t\tep.put('B', \"10011010\");\n\t\tep.put('C', \"0101\");\n\t\tep.put('D', \"0001\");\n\t\tep.put('E', \"110\");\n\t\tep.put('F', \"01001\");\n\t\tep.put('G', \"10011011\");\n\t\tep.put('H', \"010000\");\n\t\tep.put('I', \"0111\");\n\t\tep.put('J', \"10011000\");\n\t\tep.put('K', \"0110\");\n\t\tep.put('L', \"00100\");\n\t\tep.put('M', \"10011001\");\n\t\tep.put('N', \"10011110\");\n\t\tep.put('O', \"00101\");\n\t\tep.put('P', \"111\");\n\t\tep.put('Q', \"10011111\");\n\t\tep.put('R', \"1000\");\n\t\tep.put('S', \"00110\");\n\t\tep.put('T', \"00111\");\n\t\tep.put('U', \"10011100\");\n\t\tep.put('V', \"10011101\");\n\t\tep.put('W', \"000010\");\n\t\tep.put('X', \"10010010\");\n\t\tep.put('Y', \"10010011\");\n\t\tep.put('Z', \"10010000\");\n        \n\t\tdp.put(\"00000\", 'A');\n\t\tdp.put(\"00001\", 'B');\n\t\tdp.put(\"00010\", 'C');\n\t\tdp.put(\"00011\", 'D');\n\t\tdp.put(\"00100\", 'E');\n\t\tdp.put(\"00101\", 'F');\n\t\tdp.put(\"00110\", 'G');\n\t\tdp.put(\"00111\", 'H');\n\t\tdp.put(\"01000\", 'I');\n\t\tdp.put(\"01001\", 'J');\n\t\tdp.put(\"01010\", 'K');\n\t\tdp.put(\"01011\", 'L');\n\t\tdp.put(\"01100\", 'M');\n\t\tdp.put(\"01101\", 'N');\n\t\tdp.put(\"01110\", 'O');\n\t\tdp.put(\"01111\", 'P');\n\t\tdp.put(\"10000\", 'Q');\n\t\tdp.put(\"10001\", 'R');\n\t\tdp.put(\"10010\", 'S');\n\t\tdp.put(\"10011\", 'T');\n\t\tdp.put(\"10100\", 'U');\n\t\tdp.put(\"10101\", 'V');\n\t\tdp.put(\"10110\", 'W');\n\t\tdp.put(\"10111\", 'X');\n\t\tdp.put(\"11000\", 'Y');\n\t\tdp.put(\"11001\", 'Z');\n\t\tdp.put(\"11010\", ' ');\n\t\tdp.put(\"11011\", '.');\n\t\tdp.put(\"11100\", ',');\n\t\tdp.put(\"11101\", '-');\n\t\tdp.put(\"11110\", '\\'');\n\t\tdp.put(\"11111\", '?');\n        \n        while(scan.hasNext()){\n        \tchar [] line= scan.nextLine().toCharArray();\n        \tString tmp=\"\";\n        \tfor(int i=0;i<line.length;i++)\n        \t\ttmp+=ep.get(line[i]);\n        \tString [] splitedCode =new String[tmp.length()/5+1];\n        \tfor(int i=0;i<splitedCode.length;i++){\t\n        \t\tif(i==(splitedCode.length-1))\n        \t\t\tsplitedCode[i]=tmp.substring(5*i,tmp.length());\n        \t\telse splitedCode[i]=tmp.substring(5*i,5*i+5);\n        \t}\n        \t\tif(tmp.length()%5!=0)\n        \tfor(int i=0;i<(5-tmp.length()%5);i++)\n        \t\tsplitedCode[splitedCode.length-1]+=\"0\";\n        \t\n        \tStringBuilder sb = new StringBuilder();\n        \tfor(int i=0;i<splitedCode.length;i++)\n        \t\tsb.append(dp.get(splitedCode[i]));\n        \tSystem.out.println(sb);\n        }\n    }\n}", "sampled": "import java.util.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        \n        Map<Character, String> encode1 = new HashMap<>();\n        encode1.put(' ', \"101\");\n        encode1.put('\\'', \"000000\");\n        encode1.put(',', \"000011\");\n        encode1.put('-', \"10010001\");\n        encode1.put('.', \"010001\");\n        encode1.put('?', \"000001\");\n        encode1.put('A', \"100101\");\n        encode1.put('B', \"10011010\");\n        encode1.put('C', \"0101\");\n        encode1.put('D', \"0001\");\n        encode1.put('E', \"110\");\n        encode1.put('F', \"01001\");\n        encode1.put('G', \"10011011\");\n        encode1.put('H', \"010000\");\n        encode1.put('I', \"0111\");\n        encode1.put('J', \"10011000\");\n        encode1.put('K', \"0110\");\n        encode1.put('L', \"00100\");\n        encode1.put('M', \"10011001\");\n        encode1.put('N', \"10011110\");\n        encode1.put('O', \"00101\");\n        encode1.put('P', \"111\");\n        encode1.put('Q', \"10011111\");\n        encode1.put('R', \"1000\");\n        encode1.put('S', \"00110\");\n        encode1.put('T', \"00111\");\n        encode1.put('U', \"10011100\");\n        encode1.put('V', \"10011101\");\n        encode1.put('W', \"000010\");\n        encode1.put('X', \"10010010\");\n        encode1.put('Y', \"10010011\");\n        encode1.put('Z', \"10010000\");\n        \n        Map<String, Character> encode2 = new HashMap<>();\n        encode2.put(\"00000\", 'A');\n        encode2.put(\"00001\", 'B');\n        encode2.put(\"00010\", 'C');\n        encode2.put(\"00011\", 'D');\n        encode2.put(\"00100\", 'E');\n        encode2.put(\"00101\", 'F');\n        encode2.put(\"00110\", 'G');\n        encode2.put(\"00111\", 'H');\n        encode2.put(\"01000\", 'I');\n        encode2.put(\"01001\", 'J');\n        encode2.put(\"01010\", 'K');\n        encode2.put(\"01011\", 'L');\n        encode2.put(\"01100\", 'M');\n        encode2.put(\"01101\", 'N');\n        encode2.put(\"01110\", 'O');\n        encode2.put(\"01111\", 'P');\n        encode2.put(\"10000\", 'Q');\n        encode2.put(\"10001\", 'R');\n        encode2.put(\"10010\", 'S');\n        encode2.put(\"10011\", 'T');\n        encode2.put(\"10100\", 'U');\n        encode2.put(\"10101\", 'V');\n        encode2.put(\"10110\", 'W');\n        encode2.put(\"10111\", 'X');\n        encode2.put(\"11000\", 'Y');\n        encode2.put(\"11001\", 'Z');\n        encode2.put(\"11010\", ' ');\n        encode2.put(\"11011\", '.');\n        encode2.put(\"11100\", ',');\n        encode2.put(\"11101\", '-');\n        encode2.put(\"11110\", '\\'');\n        encode2.put(\"11111\", '?');\n        \n        while (sc.hasNextLine()) {\n            String line = sc.nextLine();\n            \n            StringBuilder binary = new StringBuilder();\n            for (char c : line.toCharArray()) {\n                binary.append(encode1.get(c));\n            }\n            \n            while (binary.length() % 5 != 0) {\n                binary.append('0');\n            }\n            \n            StringBuilder result = new StringBuilder();\n            for (int i = 0; i < binary.length(); i += 5) {\n                String chunk = binary.substring(i, i + 5);\n                result.append(encode2.get(chunk));\n            }\n            \n            System.out.println(result.toString());\n        }\n        \n        sc.close();\n    }\n}\n", "perturbed_sampled": [" Map<Character, String> encode1 = new HashMap<>(); encode1.put(' ',  encode1.put('B', \"10011010\");  \"10011011\"); encode1.put('H', \"010000\"); encode1.put('I', \"0111\"); encode1.put('J', \"10011000\"); encode1.put('K', \"0110\"); encode1.put('L', \"00100\"); encode1.put('M',  encode1.put('R', \"1000\"); encode1.put('S', \"00110\"); encode1.put('T', \"00111\"); encode1.put('U', \"10011100\"); encode1.put('V', \"10011101\"); encode1.put('W', \"000010\"); encode1.put('X', \"10010010\"); encode1.put('Y', \"10010011\"); encode1.put('Z', \"10010000\"); Map<String,  encode2.put(\"00000\", 'A'); encode2.put(\"00001\", 'B'); encode2.put(\"00010\", 'C'); encode2.put(\"00011\", 'D'); encode2.put(\"00100\",   'J');  'O');  'R'); encode2.put(\"10010\",   'Z');   (sc.hasNextLine()) { String  =  binary.append('0'); } StringBuilder result = new StringBuilder(); for (int i = 0; i < binary.length();   5); result.append(encode2.get(chunk)); } System.out.println(result.toString()); } sc.close(); } }"], "perturbed_original": ["import  args) throws   \"010000\"); ep.put('I', \"0111\"); ep.put('J', \"10011000\"); ep.put('K', \"0110\");  \"10011110\"); ep.put('O', \"00101\"); ep.put('P', \"111\"); ep.put('Q', \"10011111\");  \"00111\"); ep.put('U', \"10011100\"); ep.put('V', \"10011101\"); ep.put('W', \"000010\"); ep.put('X', \"10010010\");  'A'); dp.put(\"00001\", 'B');  'E'); dp.put(\"00101\", 'F'); dp.put(\"00110\", 'G'); dp.put(\"00111\", 'H'); dp.put(\"01000\", 'I'); dp.put(\"01001\", 'J'); dp.put(\"01010\", 'K'); dp.put(\"01011\", 'L'); dp.put(\"01100\",  dp.put(\"01111\", 'P'); dp.put(\"10000\", 'Q');  'V'); dp.put(\"10110\",  '); dp.put(\"11011\", '.'); dp.put(\"11100\", ',');  '?'); while(scan.hasNext()){ char [] line= scan.nextLine().toCharArray(); String  []   StringBuilder(); for(int i=0;i<splitedCode.length;i++) sb.append(dp.get(splitedCode[i])); System.out.println(sb); } } }"], "original_ll": -0.5282508730888367, "sampled_ll": -0.3539580702781677, "all_perturbed_sampled_ll": [-1.218854546546936], "all_perturbed_original_ll": [-1.3569740056991577], "perturbed_sampled_ll": -1.218854546546936, "perturbed_original_ll": -1.3569740056991577, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import sys\nd={' ':'101',\"'\":'000000',',':'000011','-':'10010001','.':'010001','?':'000001','A':'100101','B':'10011010','C':'0101','D':'0001','E':'110',\n'F':'01001','G':'10011011','H':'010000','I':'0111','J':'10011000','K':'0110','L':'00100','M':'10011001','N':'10011110','O':'00101','P':'111',\n'Q':'10011111','R':'1000','S':'00110','T':'00111','U':'10011100','V':'10011101','W':'000010','X':'10010010','Y':'10010011','Z':'10010000'}\nfor e in sys.stdin:\n a=''.join(d[c]for c in e[:-1])\n a+='0'*(-len(a)%5)\n print(''.join(\"ABCDEFGHIJKLMNOPQRSTUVWXYZ .,-'?\"[int(a[i*5:i*5+5],2)]for i in range(len(a)//5)))\n", "sampled": "import sys\n\n# First encoding table (character to binary code)\nencode1 = {\n    ' ': '101',\n    \"'\": '000000',\n    ',': '000011',\n    '-': '10010001',\n    '.': '010001',\n    '?': '000001',\n    'A': '100101',\n    'B': '10011010',\n    'C': '0101',\n    'D': '0001',\n    'E': '110',\n    'F': '01001',\n    'G': '10011011',\n    'H': '010000',\n    'I': '0111',\n    'J': '10011000',\n    'K': '0110',\n    'L': '00100',\n    'M': '10011001',\n    'N': '10011110',\n    'O': '00101',\n    'P': '111',\n    'Q': '10011111',\n    'R': '1000',\n    'S': '00110',\n    'T': '00111',\n    'U': '10011100',\n    'V': '10011101',\n    'W': '000010',\n    'X': '10010010',\n    'Y': '10010011',\n    'Z': '10010000'\n}\n\n# Second encoding table (5-bit binary to character)\nencode2 = {\n    '00000': 'A',\n    '00001': 'B',\n    '00010': 'C',\n    '00011': 'D',\n    '00100': 'E',\n    '00101': 'F',\n    '00110': 'G',\n    '00111': 'H',\n    '01000': 'I',\n    '01001': 'J',\n    '01010': 'K',\n    '01011': 'L',\n    '01100': 'M',\n    '01101': 'N',\n    '01110': 'O',\n    '01111': 'P',\n    '10000': 'Q',\n    '10001': 'R',\n    '10010': 'S',\n    '10011': 'T',\n    '10100': 'U',\n    '10101': 'V',\n    '10110': 'W',\n    '10111': 'X',\n    '11000': 'Y',\n    '11001': 'Z',\n    '11010': ' ',\n    '11011': '.',\n    '11100': ',',\n    '11101': '-',\n    '11110': \"'\",\n    '11111': '?'\n}\n\nfor line in sys.stdin:\n    line = line.rstrip('\\n')\n    \n    # Step 1: Convert each character to its binary code\n    binary_string = ''.join(encode1[c] for c in line)\n    \n    # Step 2: Pad with zeros to make length multiple of 5\n    remainder = len(binary_string) % 5\n    if remainder != 0:\n        binary_string += '0' * (5 - remainder)\n    \n    # Step 3: Split into chunks of 5 and convert using second table\n    result = ''\n    for i in range(0, len(binary_string), 5):\n        chunk = binary_string[i:i+5]\n        result += encode2[chunk]\n    \n    print(result)\n", "perturbed_sampled": ["  ': '101', \"'\": '000000', ',': '000011',  '10011010',  '110', 'F': '01001', 'G':  'J': '10011000',  '10011001', 'N': '10011110', 'O': '00101', 'P': '111', 'Q': '10011111',  '10011101', 'W': '000010', 'X':  } # Second encoding table (5-bit  { '00000': 'A', '00001': 'B', '00010': 'C', '00011':  '01000': 'I', '01001': 'J', '01010': 'K', '01011': 'L', '01100': 'M',    'Y', '11001': 'Z',  '11100': ',', '11101': '-',  line  its binary code binary_string  Pad with  len(binary_string)  # Step 3: Split  convert using  for i in range(0, len(binary_string), 5): chunk = binary_string[i:i+5] result += encode2[chunk] print(result)"], "perturbed_original": ["import sys d={'  in sys.stdin: a=''.join(d[c]for c in  in range(len(a)//5)))"], "original_ll": -1.205153465270996, "sampled_ll": -0.49995502829551697, "all_perturbed_sampled_ll": [-1.7900654077529907], "all_perturbed_original_ll": [-4.920464038848877], "perturbed_sampled_ll": -1.7900654077529907, "perturbed_original_ll": -4.920464038848877, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "/* ????????????????????????????????????????????? */\n#include <stdio.h>\n\n/* ?????\u00b0???????????? */\ntypedef\tvoid\t\t\tVD;\ntypedef\tsigned char\t\tI1;\ntypedef unsigned char \tU1;\ntypedef\tsigned short\tI2;\ntypedef unsigned short \tU2;\ntypedef\tsigned long\t\tI4;\ntypedef unsigned long \tU4;\n\n/* ?????\u00b0?????? */\n#define MAXOFNUM_ROW \t99\t\t\t\t\t/* ?????\u00b0????????\u00a7??? */\n#define MAXOFSUM_COLUMN\t(MAXOFNUM_ROW+1)/2\t/* ?????\u00b0????????\u00a7??? */\n\n/* ??\u00b0?????????????????\u00b0 */\nU1 mu1InputNum[MAXOFNUM_ROW][MAXOFSUM_COLUMN];\t/* ??\\??????????????\u00b0??????????\u00b4????????????? */\n\n/* \n??\u00a2??\u00b0??????u1ReadData\n???????????\\???????????????????????????????????\u00b0???????????? \n?????\u00b0???\n?????????\n????????????U1 ??\\?????????????????\u00b0\n*/\nU1 u1ReadData();\n\n/*\n??\u00a2??\u00b0??????u2SearchMax\n???????????\u00a8????????????????????\u00a7?????\u00a7???????????????\n?????\u00b0???\n????\u00ac\u00ac1?????\u00b0????????\u00b0\n????????????U2 ?????\u00a7???\n*/\nU2 u2SearchMax(U1 u1NumOfRow);\n\n/*\n??\u00a2??\u00b0??????\n?????????2????????\u00b0??????????????\u00a7????????\u00b0????????????\n?????\u00b0???\n????\u00ac\u00ac1?????\u00b0?????\u00b0???1\n????\u00ac\u00ac2?????\u00b0?????\u00b0???2\n????????????U2 ??\u00a7??????????????\u00b0???\n*/\nU2 u2JudjeBigNum(U2 u2Num1,U2 u2Num2);\n\nVD main(void)\n{\n\tU1 u1NumOfRow;\t\t\t\t\t\t/* ?????????????????\u00b0 */\n\tU2 u2MaxOfSum;\t\t\t\t\t\t/* ???????????\u00a7??? */\n\t\n\tu1NumOfRow = u1ReadData();\t\t\t\t/* ??????1 ??\\??????????????????????????? */\n\tu2MaxOfSum = u2SearchMax(u1NumOfRow);\t/* ??????2 ?????\u00a7????????\u00a2??? */\n\tprintf(\"%d\\n\",u2MaxOfSum);\t\t\t\t/* ??????3 ?????\u00a7????????\u00a8????????? */\n}\n\nU1 u1ReadData()\n{\n\tU1 u1NumOfRow;\t\t/* ?????????????????\u00b0 */\n\tU1 u1NumOfColumn;\t/* ?????????????????\u00b0 */\n\tU1 u1TmpChar;\t\t/* ','????????????'\\n'???????\u00b4????????????\u00b0 */\n\tI1 i1ReturnScanf;\t/* scanf??\u00a2??\u00b0???????????????????\u00b4????????????\u00b0 */\n\t\n\tU1 u1OnlyNumCnt;\n\t\n\tu1NumOfRow = 0;\n\tu1NumOfColumn = 0;\n\tu1OnlyNumCnt = 0;\n\t\n\twhile(u1OnlyNumCnt != 2){\n\t\tscanf(\"%d%c\",&mu1InputNum[u1NumOfRow][u1NumOfColumn],&u1TmpChar);\n\t\tif(u1TmpChar == ','){\n\t\t\tu1NumOfColumn++;\n\t\t\tu1TmpChar = 0;\n\t\t}\n\t\telse{\n\t\t\tif(u1NumOfColumn == 0){\n\t\t\t\tu1OnlyNumCnt++;\n\t\t\t}\n\t\t\tu1NumOfRow++;\n\t\t\tu1NumOfColumn = 0;\n\t\t}\n\t}\n\treturn u1NumOfRow;\n}\n\n\nU2 u2SearchMax(U1 u1NumOfRow)\n{\n\tU2 mu2work[MAXOFNUM_ROW][MAXOFSUM_COLUMN];\t/* ?\u00a8???????????????????????\u00b4????????????? */\n\tU1 u1RowCnt;\t\t/* ?????\u00b0???????????? */\n\tU1 u1ColumnCnt;\t\t/* ?????\u00b0???????????? */\n\tU1 u1HalfNumOfRow;\t/* ?????\u00b0????????? */\n\tU2 u2Num1;\t\t\t/* ?\u00a8?????????????????\u00b4???????????????\u00b0??????????\u00b4????????????\u00b0 */\n\tU2 u2Num2;\t\t\t/* ?\u00a8?????????????????\u00b4???????????????\u00b0??????????\u00b4????????????\u00b0 */\n\t\n\tu1HalfNumOfRow = u1NumOfRow/2+1;\n\t\n\t/* ??\\?????????????????????mu2work?????????????????? */\n\tfor(u1RowCnt = 0; u1RowCnt < u1NumOfRow; u1RowCnt++){\n\t\tfor(u1ColumnCnt = 0; u1ColumnCnt <= u1RowCnt; u1ColumnCnt++){\n\t\t\tif(u1RowCnt >= u1HalfNumOfRow){\n\t\t\t\tif(u1ColumnCnt >= u1HalfNumOfRow*2-(u1RowCnt+1)){\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tmu2work[u1RowCnt][u1ColumnCnt] = mu1InputNum[u1RowCnt][u1ColumnCnt];\n\t\t}\n\t}\n\t\n\tfor(u1RowCnt = 1; u1RowCnt < u1NumOfRow; u1RowCnt++){\n\t\tfor(u1ColumnCnt = 0; u1ColumnCnt <= u1RowCnt; u1ColumnCnt++){\n\t\t\t/* ????????\u00a2?????\u00a8???????\u00b4???\u00b0????\u00a8????????????\u00b4??? */\n\t\t\tif(u1RowCnt < u1HalfNumOfRow){\t\t\t\t\n\t\t\t\tif(u1ColumnCnt == 0){\n\t\t\t\t\tmu2work[u1RowCnt][u1ColumnCnt] = mu1InputNum[u1RowCnt][u1ColumnCnt]+mu2work[u1RowCnt-1][0];\n\t\t\t\t}\n\t\t\t\telse if(u1ColumnCnt == u1RowCnt){\n\t\t\t\t\tmu2work[u1RowCnt][u1ColumnCnt] = mu1InputNum[u1RowCnt][u1ColumnCnt]+mu2work[u1RowCnt-1][u1RowCnt-1];\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tu2Num1 = mu2work[u1RowCnt-1][u1ColumnCnt-1];\n\t\t\t\t\tu2Num2 = mu2work[u1RowCnt-1][u1ColumnCnt];\n\t\t\t\t\tmu2work[u1RowCnt][u1ColumnCnt] = mu1InputNum[u1RowCnt][u1ColumnCnt]+u2JudjeBigNum(u2Num1,u2Num2);\n\t\t\t\t}\n\t\t\t}\n\t\t\t/* ????????\u00a2?????\u00a8???????\u00b4???\u00b0????\u00a8????????????\u00b4??? */\n\t\t\telse{\n\t\t\t\tif(u1ColumnCnt >= u1HalfNumOfRow*2-(u1RowCnt+1)){\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tu2Num1 = mu2work[u1RowCnt-1][u1ColumnCnt];\n\t\t\t\tu2Num2 = mu2work[u1RowCnt-1][u1ColumnCnt+1];\n\t\t\t\tmu2work[u1RowCnt][u1ColumnCnt] = mu1InputNum[u1RowCnt][u1ColumnCnt]+u2JudjeBigNum(u2Num1,u2Num2);\n\t\t\t}\n\t\t}\n\t}\n\treturn mu2work[u1NumOfRow-1][0];\n}\n\nU2 u2JudjeBigNum(U2 u2Num1,U2 u2Num2)\n{\n\tU2 u2Rtn;\t/* ????????????????\u00b4????????????\u00b0 */\n\t\n\tif(u2Num1 >= u2Num2){\n\t\tu2Rtn = u2Num1;\n\t}else{\n\t\tu2Rtn = u2Num2;\n\t}\t\n\treturn u2Rtn;\n}", "sampled": "#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n\nint main() {\n    int diamond[200][100];\n    int dp[200][100];\n    int rows = 0;\n    char line[1000];\n    \n    // Read input\n    while (fgets(line, sizeof(line), stdin)) {\n        int len = strlen(line);\n        if (len > 0 && line[len-1] == '\\n') {\n            line[len-1] = '\\0';\n        }\n        \n        int col = 0;\n        char *token = strtok(line, \",\");\n        while (token != NULL) {\n            diamond[rows][col] = atoi(token);\n            col++;\n            token = strtok(NULL, \",\");\n        }\n        rows++;\n    }\n    \n    // Find the middle row (widest part)\n    int maxRow = 0;\n    for (int i = 0; i < rows; i++) {\n        if (i > maxRow) {\n            maxRow = i;\n        }\n    }\n    \n    // Initialize dp\n    for (int i = 0; i < rows; i++) {\n        for (int j = 0; j < 100; j++) {\n            dp[i][j] = -1;\n        }\n    }\n    \n    // Start with first element\n    dp[0][0] = diamond[0][0];\n    \n    // Determine middle row\n    int mid = rows / 2;\n    \n    // Process upper half (expanding)\n    for (int i = 0; i < mid; i++) {\n        for (int j = 0; j <= i; j++) {\n            if (dp[i][j] != -1) {\n                // Move to left-down diagonal\n                if (dp[i+1][j] < dp[i][j] + diamond[i+1][j]) {\n                    dp[i+1][j] = dp[i][j] + diamond[i+1][j];\n                }\n                // Move to right-down diagonal\n                if (dp[i+1][j+1] < dp[i][j] + diamond[i+1][j+1]) {\n                    dp[i+1][j+1] = dp[i][j] + diamond[i+1][j+1];\n                }\n            }\n        }\n    }\n    \n    // Process lower half (contracting)\n    for (int i = mid; i < rows - 1; i++) {\n        int width = rows - i - 1;\n        for (int j = 0; j <= width; j++) {\n            if (dp[i][j] != -1) {\n                // Move to left-down diagonal\n                if (j > 0) {\n                    if (dp[i+1][j-1] < dp[i][j] + diamond[i+1][j-1]) {\n                        dp[i+1][j-1] = dp[i][j] + diamond[i+1][j-1];\n                    }\n                }\n                // Move to right-down diagonal\n                if (j < width) {\n                    if (dp[i+1][j] < dp[i][j] + diamond[i+1][j]) {\n                        dp[i+1][j] = dp[i][j] + diamond[i+1][j];\n                    }\n                }\n            }\n        }\n    }\n    \n    printf(\"%d\\n\", dp[rows-1][0]);\n    \n    return 0;\n}\n", "perturbed_sampled": ["#include <stdio.h> #include <string.h> #include <stdlib.h> int main() } j input while (fgets(line, <extra_id_12>p[j] =<extra_id_13>j-1] :<extra_id_14>* (dp[i].len -<extra_id_15>*/ } if<extra_id_16>dp [i][j=i; = strlen(line); if (len > 0  int col  strtok(line, \",\"); while (token != NULL) {  = strtok(NULL, \",\"); } rows++; } //  0; for   (i >  } } // Initialize dp   0; j  = -1; } } //  =  int  // Process upper half (expanding) for (int  mid;  =  { if (dp[i][j] != -1)  dp[i][j]  dp[i][j] + diamond[i+1][j]; }  }  lower half (contracting) for (int i = mid; i   - i  = 0; j  (dp[i][j] !=  left-down diagonal if  diamond[i+1][j-1]) { dp[i+1][j-1] = dp[i][j] + diamond[i+1][j-1];  right-down diagonal if  (dp[i+1][j] < dp[i][j] +   return 0; }"], "perturbed_original": ["/* ????????????????????????????????????????????? */ #include <stdio.h> /*  typedef signed char I1;  unsigned long U4; /* ?????\u00b0??????   ??\u00b0?????????????????\u00b0 */ U1 mu1InputNum[MAXOFNUM_ROW][MAXOFSUM_COLUMN]; /*  ?????\u00b0??? ????????? ????????????U1 ??\\?????????????????\u00b0 */ U1  ????\u00ac\u00ac1?????\u00b0????????\u00b0 ????????????U2 ?????\u00a7???  ??\u00a2??\u00b0?????? ?????????2????????\u00b0??????????????\u00a7????????\u00b0???????????? ?????\u00b0??? ????\u00ac\u00ac1?????\u00b0?????\u00b0???1  u2JudjeBigNum(U2 u2Num1,U2 u2Num2); VD main(void) {  */ u1NumOfRow = u1ReadData(); /* ??????1 ??\\??????????????????????????? */ u2MaxOfSum = u2SearchMax(u1NumOfRow);  /* ??????3 ?????\u00a7????????\u00a8????????? */ } U1 u1ReadData()  */ U1 u1NumOfColumn;   } U2 u2SearchMax(U1 u1NumOfRow) {   U1 u1ColumnCnt; /*  ?????\u00b0????????? */ U2 u2Num1; /* ?\u00a8?????????????????\u00b4???????????????\u00b0??????????\u00b4????????????\u00b0 */  ??\\?????????????????????mu2work?????????????????? */ for(u1RowCnt  u1ColumnCnt <= u1RowCnt;  >= u1HalfNumOfRow*2-(u1RowCnt+1)){  u1NumOfRow;   */ if(u1RowCnt <  = mu1InputNum[u1RowCnt][u1ColumnCnt]+mu2work[u1RowCnt-1][0]; } else if(u1ColumnCnt  } else{ u2Num1 = mu2work[u1RowCnt-1][u1ColumnCnt-1]; u2Num2 = mu2work[u1RowCnt-1][u1ColumnCnt]; mu2work[u1RowCnt][u1ColumnCnt] = mu1InputNum[u1RowCnt][u1ColumnCnt]+u2JudjeBigNum(u2Num1,u2Num2); } } /*  mu2work[u1RowCnt-1][u1ColumnCnt+1]; mu2work[u1RowCnt][u1ColumnCnt] = mu1InputNum[u1RowCnt][u1ColumnCnt]+u2JudjeBigNum(u2Num1,u2Num2); } } } return mu2work[u1NumOfRow-1][0]; } U2 u2JudjeBigNum(U2 u2Num1,U2 u2Num2) { U2 u2Rtn;  }else{ u2Rtn = u2Num2; } return u2Rtn; }"], "original_ll": -1.0170522928237915, "sampled_ll": -0.4945202171802521, "all_perturbed_sampled_ll": [-2.867608070373535], "all_perturbed_original_ll": [-2.056579113006592], "perturbed_sampled_ll": -2.867608070373535, "perturbed_original_ll": -2.056579113006592, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "\nimport java.util.*;\nimport static java.lang.Math.*;\nimport static java.util.Arrays.*;\n\npublic class Main {\n\n\tint INF = 1 << 28;\n\tint[] now, next;\n\tint[] dp1, dp2;\n\tvoid run() {\n\t\tScanner sc = new Scanner(System.in);\n\t\tString[] str = sc.next().split(\",\");\n\t\tnow = new int[str.length+4];\n\t\tnow[2] = Integer.parseInt(str[0]);\n\t\tdp1 = new int[51];\n\t\tdp2 = new int[51];\n\t\tdp1[1] = now[2]; \n\t\tfor(;sc.hasNext();) {\n\t//\t\tdebug(dp1);\n\t\t\tstr = sc.next().split(\",\");\n\t\t\tdp2 = dp1.clone();\n\t//\t\tif(str[0].equals(\"0\")) break;\n\t\t\tnext = new int[str.length+4];\n\t\t\tfor(int i=0;i<str.length;i++) next[i+2] = Integer.parseInt(str[i]);\n\t//\t\tdebug(next);\n\t\t\tfor(int i=2;i<=str.length+1;i++) {\n\t\t\t\tif(now.length < next.length) dp1[i-1] = max( dp2[i-2] + next[i], dp2[i-1] + next[i]);\n\t\t\t\telse dp1[i-1] = max( dp2[i-1] + next[i], dp2[i] + next[i]);\n\t\t\t}\n\t\t\tnow = next.clone();\n\t\t}\n\t\tSystem.out.println(dp1[1]);\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n\n\tvoid debug(Object... os) {\n\t\tSystem.err.println(Arrays.deepToString(os));\n\t}\n}", "sampled": "import java.util.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        List<List<Integer>> diamond = new ArrayList<>();\n        \n        while (sc.hasNextLine()) {\n            String line = sc.nextLine().trim();\n            if (line.isEmpty()) break;\n            \n            List<Integer> row = new ArrayList<>();\n            if (line.contains(\",\")) {\n                String[] parts = line.split(\",\");\n                for (String part : parts) {\n                    row.add(Integer.parseInt(part));\n                }\n            } else {\n                row.add(Integer.parseInt(line));\n            }\n            diamond.add(row);\n        }\n        \n        int n = diamond.size();\n        int mid = n / 2;\n        \n        List<List<Integer>> dp = new ArrayList<>();\n        for (int i = 0; i < n; i++) {\n            List<Integer> row = new ArrayList<>();\n            for (int j = 0; j < diamond.get(i).size(); j++) {\n                row.add(Integer.MIN_VALUE);\n            }\n            dp.add(row);\n        }\n        \n        dp.get(0).set(0, diamond.get(0).get(0));\n        \n        for (int i = 0; i < n - 1; i++) {\n            int currSize = diamond.get(i).size();\n            int nextSize = diamond.get(i + 1).size();\n            \n            if (nextSize > currSize) {\n                for (int j = 0; j < currSize; j++) {\n                    if (dp.get(i).get(j) != Integer.MIN_VALUE) {\n                        dp.get(i + 1).set(j, Math.max(dp.get(i + 1).get(j), \n                            dp.get(i).get(j) + diamond.get(i + 1).get(j)));\n                        dp.get(i + 1).set(j + 1, Math.max(dp.get(i + 1).get(j + 1), \n                            dp.get(i).get(j) + diamond.get(i + 1).get(j + 1)));\n                    }\n                }\n            } else {\n                for (int j = 0; j < currSize; j++) {\n                    if (dp.get(i).get(j) != Integer.MIN_VALUE) {\n                        if (j > 0) {\n                            dp.get(i + 1).set(j - 1, Math.max(dp.get(i + 1).get(j - 1), \n                                dp.get(i).get(j) + diamond.get(i + 1).get(j - 1)));\n                        }\n                        if (j < nextSize) {\n                            dp.get(i + 1).set(j, Math.max(dp.get(i + 1).get(j), \n                                dp.get(i).get(j) + diamond.get(i + 1).get(j)));\n                        }\n                    }\n                }\n            }\n        }\n        \n        System.out.println(dp.get(n - 1).get(0));\n    }\n}\n", "perturbed_sampled": ["import java.util.*; public  Scanner(System.in); List<List<Integer>> diamond  sc.nextLine().trim(); if (line.isEmpty()) break;  (String part :   }  2; List<List<Integer>> dp = new ArrayList<>(); for (int i =  { List<Integer>  (int j = 0; j  n -  = diamond.get(i).size();   { for (int j = 0; j <  1).get(j),   Math.max(dp.get(i   1))); } } } else { for (int j = 0; j < currSize; j++) { if (dp.get(i).get(j) != Integer.MIN_VALUE) { if (j > 0) { dp.get(i + 1).set(j - 1, Math.max(dp.get(i + 1).get(j  nextSize)  +   } System.out.println(dp.get(n - 1).get(0)); } }"], "perturbed_original": ["import java.util.*; import static java.lang.Math.*; import     Integer.parseInt(str[0]); dp1 = new int[51]; dp2 = new int[51]; dp1[1] = now[2]; for(;sc.hasNext();)  // if(str[0].equals(\"0\")) break; next = new int[str.length+4]; for(int i=0;i<str.length;i++) next[i+2] = Integer.parseInt(str[i]); //  max( dp2[i-2] + next[i],  }  } public static void main(String[] args) { new Main().run(); }  } }"], "original_ll": -1.1418027877807617, "sampled_ll": -0.33317098021507263, "all_perturbed_sampled_ll": [-2.256333112716675], "all_perturbed_original_ll": [-2.1406521797180176], "perturbed_sampled_ll": -2.256333112716675, "perturbed_original_ll": -2.1406521797180176, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "def path(mx,w,h):\n\tif h < c/2:\n\t\tif w > 0:\n\t\t\tmx[h][w] = max(mx[h-1][w],mx[h-1][w-1]) + inp[h][w]\n\t\telse:\n\t\t\tmx[h][w] = mx[h-1][w] + inp[h][w]\n\telse:\n\t\tif w < len(inp[h])-1:\n\t\t\tmx[h][w] = max(mx[h-1][w],mx[h-1][w+1]) + inp[h][w]\n\t\telse:\n\t\t\tmx[h][w] = mx[h-1][w] + inp[h][w]\n\treturn mx\n\t\nc = 0\ninp = []\nwhile True:\n\ttry:\n\t\tinp.append(map(int, raw_input().split(\",\")))\n\t\tc += 1\n\texcept:\n\t\tmx = [[0 for i in range((c+1)/2)] for i in range(c)]\n\t\tmx[0][0] = inp[0][0]\n\t\tfor h in range(1,c):\n\t\t\tfor w in range(len(inp[h])):\n\t\t\t\tmx = path(mx,w,h)\n\t\tprint mx[c-1][0]\n\t\tbreak", "sampled": "import sys\n\nlines = []\nfor line in sys.stdin:\n    line = line.strip()\n    if line:\n        lines.append(line)\n\n# Parse the diamond\ndiamond = []\nfor line in lines:\n    if ',' in line:\n        diamond.append(list(map(int, line.split(','))))\n    else:\n        diamond.append([int(line)])\n\nn = len(diamond)\nmid = n // 2\n\n# Dynamic programming\ndp = [[float('-inf')] * len(row) for row in diamond]\ndp[0][0] = diamond[0][0]\n\n# Process upper half (expanding)\nfor i in range(1, mid + 1):\n    for j in range(len(diamond[i])):\n        # Can come from position j-1 or j in previous row\n        if j > 0:\n            dp[i][j] = max(dp[i][j], dp[i-1][j-1] + diamond[i][j])\n        if j < len(diamond[i-1]):\n            dp[i][j] = max(dp[i][j], dp[i-1][j] + diamond[i][j])\n\n# Process lower half (contracting)\nfor i in range(mid + 1, n):\n    for j in range(len(diamond[i])):\n        # Can come from position j or j+1 in previous row\n        if j < len(diamond[i-1]):\n            dp[i][j] = max(dp[i][j], dp[i-1][j] + diamond[i][j])\n        if j + 1 < len(diamond[i-1]):\n            dp[i][j] = max(dp[i][j], dp[i-1][j+1] + diamond[i][j])\n\nprint(dp[n-1][0])\n", "perturbed_sampled": [" for line in sys.stdin: line  # Parse  for line in lines: if ',' in line: diamond.append(list(map(int,  len(diamond) mid  Dynamic    in range(len(diamond[i])): # Can     = max(dp[i][j], dp[i-1][j] +  (contracting) for i in range(mid + 1, n): for j in range(len(diamond[i])): # Can come from position  j + 1 < len(diamond[i-1]): dp[i][j] = max(dp[i][j], dp[i-1][j+1] + diamond[i][j]) print(dp[n-1][0])"], "perturbed_original": ["  mx[h][w] = max(mx[h-1][w],mx[h-1][w-1]) + inp[h][w] else: mx[h][w] = mx[h-1][w] +  len(inp[h])-1: mx[h][w] = max(mx[h-1][w],mx[h-1][w+1]) + inp[h][w] else: mx[h][w] = mx[h-1][w] + inp[h][w]   try: inp.append(map(int, raw_input().split(\",\"))) c +=   path(mx,w,h) print mx[c-1][0] break"], "original_ll": -0.9190635085105896, "sampled_ll": -0.6800452470779419, "all_perturbed_sampled_ll": [-2.622393846511841], "all_perturbed_original_ll": [-1.788670301437378], "perturbed_sampled_ll": -2.622393846511841, "perturbed_original_ll": -1.788670301437378, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "// AOJ0090 Overlaps of Seals\n\n#include <stdio.h>\n#include <string.h>\n\n#define MAX_N\t(200)\n\n\nint main(void)\n{\n    int n;\n\tdouble circle[MAX_N][2];\n    double d;\n    int flag[MAX_N][MAX_N];\n    int overlap[MAX_N][MAX_N];\n    int max_overlap;\n\tint i, j, k;\n\tint num[MAX_N], max[MAX_N], min[MAX_N];\n    int cont_flag;\n\t\n\twhile (1){\n\t\tscanf(\"%d\", &n);\n\t\tif (n == 0){\n\t\t\tbreak;\n\t\t}\n\t\t\n\t\t// \u0093\u00fc\u0097\u00cd\n\t\tfor (i = 0; i < n; i++){\n\t\t\tscanf(\"%lf,%lf\", &circle[i][0], &circle[i][1]);\n\t\t}\n\t\t\n\t\t// \u008fd\u0082\u00c8\u0082\u00e8\u0083e\u0081[\u0083u\u0083\u008b\u008d\u00ec\u0090\u00ac\n\t\tmemset(flag, 0, sizeof(flag));\n\t\tfor (i = 0; i < n; i++){\n\t\t\tfor (j = i; j < n; j++){\n\t\t\t\tif (i == j){\n\t\t\t\t\tflag[i][j] = 1;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\td = (circle[i][0] - circle[j][0]) * (circle[i][0] - circle[j][0]) +\n\t\t\t\t\t    (circle[i][1] - circle[j][1]) * (circle[i][1] - circle[j][1]);\n\t\t\t\t\tif (d <= 4.0){\n\t\t\t\t\t\tflag[i][j] = flag[j][i] = 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n        \n                    // \u0092[\u0082\u00c1\u0082\u00b1\u0082\u00cc\u008d\u00ed\u008f\u009c\n        max_overlap = 1;\n        do {\n\t\t\tfor (i = 0; i < n; i++){\n                num[i] = 0;\n\t\t\t\tfor (j = 0; j < n; j++){\n\t\t\t\t\tnum[i] += flag[i][j];\n\t\t\t\t}\n   \t\t\t}\n\n            cont_flag = 0;\n\t\t\tfor (i = 0; i < n; i++){\n                if (num[i] == 2){\n                    max_overlap = 2;\n                }\n\t\t\t\tif (num[i] == 1 || num[i] == 2){\n\t\t\t\t\tfor (j = 0; j < n; j++){\n\t\t\t\t\t\tflag[i][j] = flag[j][i] = 0; \n\t\t\t\t\t}\n                    cont_flag = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t} while (cont_flag == 1);\n\n        \n\t\tmemset(overlap, 0, sizeof(overlap));\n        for (i = 0; i < n; i++){\n            if (num[i] > 0){\n                for (j = 0; j < n; j++){\n                    if (flag[i][j] == 1){\n                        for (k = j + 1; k < n; k++){\n                            if (flag[i][k] == 1){\n                                if (flag[j][k] == 1){\n                                    overlap[i][j]++;\n                                    overlap[i][k]++;\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        \n        for (i = 0; i < n; i++){\n            max[i] = 0;\n            min[i] = 1000;\n        }\n        for (i = 0; i < n; i++){\n            for (j = 0; j < n; j++){\n                if (max[i] < overlap[i][j]){\n                    max[i] = overlap[i][j];\n                }\n                if (overlap[i][j] > 0 && min[i] > overlap[i][j]){\n                    min[i] = overlap[i][j];\n                }\n            }\n//            printf(\"<%d %d-%d>\", i, min[i], max[i]);\n        }\n\n        for (i = 0; i < n; i++){\n            for (j = 0; j < n; j++){\n//                printf(\"[%d]\",overlap[i][j]);\n                if (overlap[i][j] < overlap[i][i] || max[i] == min[i]){\n                    if (max_overlap < overlap[i][j]){\n                        max_overlap = overlap[i][j];\n                    }\n                }\n            }\n//            printf(\"\\n\");\n        }\n        \n        printf(\"%d\\n\", max_overlap + 1);\n\t}\n\t\n\treturn (0);\n}", "sampled": "#include <stdio.h>\n#include <math.h>\n\n#define MAX_N 100\n#define EPS 1e-9\n\ntypedef struct {\n    double x, y;\n} Point;\n\nint main() {\n    int n;\n    Point stickers[MAX_N];\n    \n    while (scanf(\"%d\", &n) == 1 && n != 0) {\n        for (int i = 0; i < n; i++) {\n            scanf(\"%lf,%lf\", &stickers[i].x, &stickers[i].y);\n        }\n        \n        int maxOverlap = 1;\n        \n        // Check all pairs of stickers\n        for (int i = 0; i < n; i++) {\n            for (int j = i + 1; j < n; j++) {\n                double dx = stickers[i].x - stickers[j].x;\n                double dy = stickers[i].y - stickers[j].y;\n                double dist = sqrt(dx * dx + dy * dy);\n                \n                // If circles overlap or touch\n                if (dist <= 2.0 + EPS) {\n                    // Find intersection points\n                    if (dist < EPS) continue; // Same center (shouldn't happen)\n                    \n                    // Calculate intersection points\n                    double a = dist / 2.0;\n                    double h = sqrt(1.0 - a * a);\n                    \n                    double mx = (stickers[i].x + stickers[j].x) / 2.0;\n                    double my = (stickers[i].y + stickers[j].y) / 2.0;\n                    \n                    double px1 = mx + h * (stickers[j].y - stickers[i].y) / dist;\n                    double py1 = my - h * (stickers[j].x - stickers[i].x) / dist;\n                    \n                    double px2 = mx - h * (stickers[j].y - stickers[i].y) / dist;\n                    double py2 = my + h * (stickers[j].x - stickers[i].x) / dist;\n                    \n                    // Check point 1\n                    int count1 = 0;\n                    for (int k = 0; k < n; k++) {\n                        double d = sqrt((px1 - stickers[k].x) * (px1 - stickers[k].x) + \n                                      (py1 - stickers[k].y) * (py1 - stickers[k].y));\n                        if (d <= 1.0 + EPS) count1++;\n                    }\n                    if (count1 > maxOverlap) maxOverlap = count1;\n                    \n                    // Check point 2\n                    int count2 = 0;\n                    for (int k = 0; k < n; k++) {\n                        double d = sqrt((px2 - stickers[k].x) * (px2 - stickers[k].x) + \n                                      (py2 - stickers[k].y) * (py2 - stickers[k].y));\n                        if (d <= 1.0 + EPS) count2++;\n                    }\n                    if (count2 > maxOverlap) maxOverlap = count2;\n                }\n            }\n            \n            // Check center of each sticker\n            int count = 0;\n            for (int k = 0; k < n; k++) {\n                double d = sqrt((stickers[i].x - stickers[k].x) * (stickers[i].x - stickers[k].x) + \n                              (stickers[i].y - stickers[k].y) * (stickers[i].y - stickers[k].y));\n                if (d <= 1.0 + EPS) count++;\n            }\n            if (count > maxOverlap) maxOverlap = count;\n        }\n        \n        printf(\"%d\\n\", maxOverlap);\n    }\n    \n    return 0;\n}\n", "perturbed_sampled": ["#include <stdio.h> #include <math.h> #define  typedef struct {  int main() { int n; Point stickers[MAX_N]; while (scanf(\"%d\",   i = 0; i <  &stickers[i].y);  // Check all pairs  = 0;  for (int j = i + 1;  double dist =  * dy); //  +  points if (dist < EPS) continue; // Same  intersection points double a = dist / 2.0; double h = sqrt(1.0 - a  (stickers[i].x + stickers[j].x) /  + h * (stickers[j].y - stickers[i].y) / dist;  stickers[i].x) / dist; double   my    stickers[k].x) * (px1  stickers[k].y) * (py1 - stickers[k].y)); if (d <= 1.0 + EPS)  //  = 0; for (int k = 0; k <  * (px2 - stickers[k].x) + (py2 - stickers[k].y) * (py2 - stickers[k].y)); if (d <=  maxOverlap = count2; }   d = sqrt((stickers[i].x - stickers[k].x) *   stickers[k].y));   } return 0; }"], "perturbed_original": ["// AOJ0090 Overlaps of Seals #include <stdio.h>  int  circle[MAX_N][2]; double d; int flag[MAX_N][MAX_N];   max[MAX_N],  //   &circle[i][0], &circle[i][1]); } //   n; i++){ for (j = i; j <  } else  circle[j][0]) *   circle[j][1]); if (d <= 4.0){ flag[i][j]     n; j++){ num[i] += flag[i][j]; }  (i =  max_overlap = 2; } if  == 2){ for (j = 0;   } } while (cont_flag == 1); memset(overlap, 0, sizeof(overlap)); for (i =  if (num[i] > 0){ for (j = 0; j < n;  for (k =   n; i++){ max[i] = 0; min[i] = 1000; } for (i  i++){ for  n; j++){ if  overlap[i][j]; } if (overlap[i][j] > 0 && min[i] > overlap[i][j]){   = 0; i < n; i++){ for (j = 0; j < n; j++){ // printf(\"[%d]\",overlap[i][j]); if (overlap[i][j] < overlap[i][i]  } return (0); }"], "original_ll": -0.9168722033500671, "sampled_ll": -0.4457537531852722, "all_perturbed_sampled_ll": [-2.479916572570801], "all_perturbed_original_ll": [-2.4403603076934814], "perturbed_sampled_ll": -2.479916572570801, "perturbed_original_ll": -2.4403603076934814, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import java.util.Scanner;\n\npublic class Main \n{\n\tpublic static void main(String[] args)\n\t{\n\t\tScanner scanner = new Scanner(System.in);\n\t\t\n\t\tfor(; ;)\n\t\t{\n\t\t\tint n = scanner.nextInt();\n\t\t\tif(n == 0)\n\t\t\t{\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\n\t\t\tint max_len = 0;\n\t\t\tfloat[] x = new float[n];\n\t\t\tfloat[] y = new float[n];\n\t\t\tfor(int i=0; i<n; i++)\n\t\t\t{\n\t\t\t\tString[] input = scanner.next().split(\",\");\n\t\t\t\t\n\t\t\t\tx[i] = Float.parseFloat(input[0]);\n\t\t\t\ty[i] = Float.parseFloat(input[1]);\n\t\t\t}\n\t\t\t\n\t\t\tfor(float px=0; px<=10; px+=0.001)\n\t\t\t{\n\t\t\t\tfor(float py=0; py<=10; py+=0.001)\n\t\t\t\t{\n\t\t\t\t\tint len = 0;\n\t\t\t\t\tfor(int i=0; i<n; i++)\n\t\t\t\t\t{\n\t\t\t\t\t\tif((px-x[i])*(px-x[i])+(py-y[i])*(py-y[i]) <= 1)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tlen ++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(max_len < len)\n\t\t\t\t\t{\n\t\t\t\t\t\tmax_len = len;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tSystem.out.println(max_len);\n\t\t}\n\t}\n}", "sampled": "import java.util.*;\nimport java.io.*;\n\npublic class Main {\n    static class Point {\n        double x, y;\n        Point(double x, double y) {\n            this.x = x;\n            this.y = y;\n        }\n        double dist(Point p) {\n            return Math.sqrt((x - p.x) * (x - p.x) + (y - p.y) * (y - p.y));\n        }\n    }\n    \n    public static void main(String[] args) throws IOException {\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        String line;\n        \n        while ((line = br.readLine()) != null) {\n            int n = Integer.parseInt(line.trim());\n            if (n == 0) break;\n            \n            Point[] stickers = new Point[n];\n            for (int i = 0; i < n; i++) {\n                String[] parts = br.readLine().trim().split(\",\");\n                double x = Double.parseDouble(parts[0]);\n                double y = Double.parseDouble(parts[1]);\n                stickers[i] = new Point(x, y);\n            }\n            \n            int maxOverlap = 1;\n            \n            // Check all pairs of stickers and find intersection points\n            for (int i = 0; i < n; i++) {\n                for (int j = i + 1; j < n; j++) {\n                    double d = stickers[i].dist(stickers[j]);\n                    if (d <= 2.0) {\n                        // Find intersection points\n                        List<Point> testPoints = getIntersectionPoints(stickers[i], stickers[j]);\n                        for (Point p : testPoints) {\n                            int count = 0;\n                            for (int k = 0; k < n; k++) {\n                                if (stickers[k].dist(p) <= 1.0 + 1e-9) {\n                                    count++;\n                                }\n                            }\n                            maxOverlap = Math.max(maxOverlap, count);\n                        }\n                    }\n                }\n                // Also check the center of each sticker\n                int count = 0;\n                for (int k = 0; k < n; k++) {\n                    if (stickers[k].dist(stickers[i]) <= 1.0 + 1e-9) {\n                        count++;\n                    }\n                }\n                maxOverlap = Math.max(maxOverlap, count);\n            }\n            \n            System.out.println(maxOverlap);\n        }\n    }\n    \n    static List<Point> getIntersectionPoints(Point c1, Point c2) {\n        List<Point> points = new ArrayList<>();\n        double d = c1.dist(c2);\n        \n        if (d > 2.0 + 1e-9) return points;\n        \n        double r = 1.0;\n        double a = (r * r - r * r + d * d) / (2 * d);\n        double h = Math.sqrt(Math.max(0, r * r - a * a));\n        \n        double cx = c1.x + a * (c2.x - c1.x) / d;\n        double cy = c1.y + a * (c2.y - c1.y) / d;\n        \n        double px1 = cx + h * (c2.y - c1.y) / d;\n        double py1 = cy - h * (c2.x - c1.x) / d;\n        \n        double px2 = cx - h * (c2.y - c1.y) / d;\n        double py2 = cy + h * (c2.x - c1.x) / d;\n        \n        points.add(new Point(px1, py1));\n        if (h > 1e-9) {\n            points.add(new Point(px2, py2));\n        }\n        \n        return points;\n    }\n}\n", "perturbed_sampled": ["import java.util.*; import java.io.*; public class Main  x, double y) { this.x =  double dist(Point p) {  (x   IOException  BufferedReader(new InputStreamReader(System.in)); String line; while ((line = br.readLine()) != null)  break; Point[] stickers  i = 0; i < n; i++) {  y = Double.parseDouble(parts[1]); stickers[i] = new Point(x, y);  of stickers and find  n; i++) {  + 1;   (d <=   count =  0; k < n;  = Math.max(maxOverlap, count); }   int count = 0;  k < n; k++) { if (stickers[k].dist(stickers[i])  System.out.println(maxOverlap); } } static List<Point>  ArrayList<>(); double  > 2.0 + 1e-9) return  double  -  * d) / (2  Math.sqrt(Math.max(0, r * r - a  c1.x +   (c2.y -  = cy - h * (c2.x   / d; double py2 =  - c1.x) / d; points.add(new Point(px1, py1)); if (h > 1e-9) { points.add(new Point(px2, py2)); } return points; } }"], "perturbed_original": ["import java.util.Scanner; public class Main  args) { Scanner scanner  {  } int  = new    for(float py=0; py<=10; py+=0.001) { int len = 0;  if((px-x[i])*(px-x[i])+(py-y[i])*(py-y[i]) <= 1) { len ++; } }  = len;  } }"], "original_ll": -0.5826813578605652, "sampled_ll": -0.48404642939567566, "all_perturbed_sampled_ll": [-2.813181161880493], "all_perturbed_original_ll": [-2.5027146339416504], "perturbed_sampled_ll": -2.813181161880493, "perturbed_original_ll": -2.5027146339416504, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import math\n\ndef overlap(p1, p2, d):\n    return (p1[0] - p2[0])**2 + (p1[1] - p2[1])**2 <= d\n\ndef intersection(o1,o2):\n    a  = 2*(o2[0] - o1[0])\n    b  = 2*(o2[1] - o1[1])\n    c  = (o1[0] - o2[0])*(o1[0] + o2[0]) + (o1[1] - o2[1])*(o1[1] + o2[1])\n    a2 = a**2 + b**2\n    b2 = a*c + a*b*o1[1] - b**2*o1[0]\n    c2 = b**2*(o1[0]**2 + o1[1]**2 - 1) + c**2 + 2*b*c*o1[1]\n    x1 = (-b2 + math.sqrt(b2**2 - a2*c2))/a2\n    x2 = (-b2 - math.sqrt(b2**2 - a2*c2))/a2\n    if abs(b) < 10e-6:\n        y1 = (o1[1] + o2[1])/2\n        y2 = (o1[1] + o2[1])/2\n    else:\n        y1 = -(a*x1 + c)/b\n        y2 = -(a*x2 + c)/b\n    if abs(b2**2 - a2*c2) < 10e-6:\n        return [x1, y1], [None, None]\n    else:\n        return [x1, y1], [x2, y2]\n\nwhile True:\n    n = int(input())\n    if n == 0:\n        break\n    p = []\n    for i in range(n):\n        p.append(list(map(float, input().split(\",\"))))\n    ans = 0\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            if not overlap(p[i], p[j], 4):\n                continue\n            elif overlap(p[i], p[j], 10e-6):\n                continue\n            p1, p2 = intersection(p[i], p[j])\n            cnt1 = 0\n            cnt2 = 0\n            for k in range(n):\n                if overlap(p1, p[k], 1):\n                    cnt1 += 1\n                if p2[0] != None and overlap(p2, p[k], 1):\n                    cnt2 += 1\n            ans = max([ans, cnt1, cnt2])\n    print(ans)\n\n", "sampled": "import sys\nfrom math import sqrt\n\ndef distance(p1, p2):\n    return sqrt((p1[0] - p2[0])**2 + (p1[1] - p2[1])**2)\n\ndef circles_overlap(c1, c2):\n    return distance(c1, c2) <= 2.0\n\ndef max_overlap(circles):\n    if not circles:\n        return 0\n    \n    n = len(circles)\n    if n == 1:\n        return 1\n    \n    max_count = 1\n    \n    # Check overlaps at each circle center\n    for i in range(n):\n        count = 0\n        for j in range(n):\n            if circles_overlap(circles[i], circles[j]):\n                count += 1\n        max_count = max(max_count, count)\n    \n    # Check intersection points of pairs of circles\n    for i in range(n):\n        for j in range(i + 1, n):\n            if circles_overlap(circles[i], circles[j]):\n                # Find intersection points\n                x1, y1 = circles[i]\n                x2, y2 = circles[j]\n                \n                d = distance(circles[i], circles[j])\n                \n                if d == 0:\n                    continue\n                \n                if d <= 2.0:\n                    # Calculate intersection points\n                    a = d / 2.0\n                    h = sqrt(1.0 - a * a) if a <= 1.0 else 0\n                    \n                    mx = (x1 + x2) / 2.0\n                    my = (y1 + y2) / 2.0\n                    \n                    dx = (x2 - x1) / d\n                    dy = (y2 - y1) / d\n                    \n                    # Two intersection points\n                    points = []\n                    if h > 0:\n                        points.append((mx + h * dy, my - h * dx))\n                        points.append((mx - h * dy, my + h * dx))\n                    else:\n                        points.append((mx, my))\n                    \n                    for point in points:\n                        count = 0\n                        for k in range(n):\n                            if distance(point, circles[k]) <= 1.0 + 1e-9:\n                                count += 1\n                        max_count = max(max_count, count)\n    \n    return max_count\n\nwhile True:\n    n = int(input())\n    if n == 0:\n        break\n    \n    circles = []\n    for _ in range(n):\n        line = input().strip()\n        x, y = map(float, line.split(','))\n        circles.append((x, y))\n    \n    print(max_overlap(circles))\n", "perturbed_sampled": ["import  def distance(p1, p2): return sqrt((p1[0] - p2[0])**2 + (p1[1] - p2[1])**2) def circles_overlap(c1,  not circles: return 0 n = len(circles) if  max_count = 1 # Check overlaps at each circle center  circles[j]): count +=  #  in range(n): for j in range(i + 1, n): if circles_overlap(circles[i], circles[j]): # Find intersection points x1, y1 =  d = distance(circles[i], circles[j])   =  sqrt(1.0 -  <= 1.0  + x2) / 2.0 my = (y1 +   =    dy, my + h * dx))  0 for k in range(n): if   = max(max_count, count) return  int(input()) if  print(max_overlap(circles))"], "perturbed_original": ["import math  (p1[0] - p2[0])**2 + (p1[1] - p2[1])**2  b =  o2[1])*(o1[1] + o2[1]) a2 =   o1[1]**2 - 1)  (-b2 - math.sqrt(b2**2 - a2*c2))/a2 if abs(b) < 10e-6: y1 = (o1[1] + o2[1])/2 y2 =  = -(a*x1 + c)/b y2 = -(a*x2  a2*c2) < 10e-6: return  return [x1, y1], [x2, y2]  if n == 0: break  in range(n): p.append(list(map(float, input().split(\",\")))) ans = 0 for i in  in range(i  if overlap(p1, p[k], 1): cnt1 +=  = max([ans, cnt1, cnt2]) print(ans)"], "original_ll": -0.7319892048835754, "sampled_ll": -0.6724913120269775, "all_perturbed_sampled_ll": [-2.6693308353424072], "all_perturbed_original_ll": [-2.2377915382385254], "perturbed_sampled_ll": -2.6693308353424072, "perturbed_original_ll": -2.2377915382385254, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "z[4000],*a=z,*b=z+2000,m,i,j,t,u;main(n){for(;scanf(\"%d\",&n)*n++;m=!printf(\"%d\\n\",m))for(i=n;i--;j=a,a=b,b=j)for(j=n;j--;t>m?m=t:0)t=b[j]=n+~i&&getchar()>45?1+fmin(u=a[j],fmin(t,u)):0;}", "sampled": "#include <stdio.h>\n#include <string.h>\n\nint main() {\n    int n;\n    char grid[1001][1001];\n    int dp[1001][1001];\n    \n    while(scanf(\"%d\", &n) == 1 && n != 0) {\n        // Read the grid\n        for(int i = 0; i < n; i++) {\n            scanf(\"%s\", grid[i]);\n        }\n        \n        // Initialize dp array\n        for(int i = 0; i < n; i++) {\n            for(int j = 0; j < n; j++) {\n                dp[i][j] = 0;\n            }\n        }\n        \n        // Build dp array\n        int maxSize = 0;\n        for(int i = 0; i < n; i++) {\n            for(int j = 0; j < n; j++) {\n                if(grid[i][j] == '.') {\n                    if(i == 0 || j == 0) {\n                        dp[i][j] = 1;\n                    } else {\n                        int min = dp[i-1][j];\n                        if(dp[i][j-1] < min) min = dp[i][j-1];\n                        if(dp[i-1][j-1] < min) min = dp[i-1][j-1];\n                        dp[i][j] = min + 1;\n                    }\n                    if(dp[i][j] > maxSize) {\n                        maxSize = dp[i][j];\n                    }\n                }\n            }\n        }\n        \n        printf(\"%d\\n\", maxSize);\n    }\n    \n    return 0;\n}\n", "perturbed_sampled": ["#include <stdio.h> #include <string.h> int main() {  1  // Read the grid for(int i  i++) { scanf(\"%s\", grid[i]); } // Initialize dp array for(int i  =   = 0; j < n; j++)  j == 0) { dp[i][j] = 1; }  < min) min  + 1; }  = dp[i][j]; } } } } printf(\"%d\\n\", maxSize); } return 0; }"], "perturbed_original": ["z[4000],*a=z,*b=z+2000,m,i,j,t,u;main(n){for(;scanf(\"%d\",&n)*n++;m=!printf(\"%d\\n\",m))for(i=n;i--;j=a,a=b,b=j)for(j=n;j--;t>m?m=t:0)t=b[j]=n+~i&&getchar()>45?1+fmin(u=a[j],fmin(t,u)):0;}"], "original_ll": -3.5804412364959717, "sampled_ll": -0.3973008394241333, "all_perturbed_sampled_ll": [-2.554049491882324], "all_perturbed_original_ll": [-3.5804412364959717], "perturbed_sampled_ll": -2.554049491882324, "perturbed_original_ll": -3.5804412364959717, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import java.io.*;\n\nclass Main {\n\tprivate static String check = \".\";\n\n\tpublic static void main(String args[]) {\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\tString buf;\n\n\t\ttry {\n\t\t\twhile (!(buf = br.readLine()).equals(\"0\")) {\n\t\t\t\tint n = Integer.parseInt(buf);\n\t\t\t\tint mat[][] = new int[n][n];\n\t\t\t\tString str[] = new String[n];\n\t\t\t\tfor (int i=0;i<n;i++) {\n\t\t\t\t\tstr[i] = br.readLine();\n\t\t\t\t\tfor (int j=0;j<n;j++) {\n\t\t\t\t\t\tif (str[i].charAt(j)=='.') mat[i][j] = 0;\n\t\t\t\t\t\telse if (str[i].charAt(j)=='*') mat[i][j] = 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tint max = 0;\n\t\t\t\tfor (int i=0;i<n;i++) {\n\t\t\t\t\tif (str[i].indexOf(check)>=0) {\n\t\t\t\t\t\tfor (int j=0;j<n;j++) {\n\t\t\t\t\t\t\tint d = Square(mat,i,j,n);\n\t\t\t\t\t\t\tif (max<d) {\n\t\t\t\t\t\t\t\tmax = d;\n\t\t\t\t\t\t\t\tcheck = \".\";\n\t\t\t\t\t\t\t\tfor (int k=0;k<max;k++) check = check+\".\";\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tSystem.out.println(max);\n\t\t\t}\n\t\t} catch (Exception e) {\n\t\t\te.printStackTrace();\n\t\t}\n\t}\n\n\tpublic static int Square(int[][] m,int x,int y,int n) {\n\t\tint c = 0;\n\t\tboolean end = false;\n\t\twhile (x+c<n&&y+c<n) {\n\t\t\tfor (int i=y;i<=y+c;i++) {\n\t\t\t\tif (m[i][x+c]==1) {\n\t\t\t\t\treturn c;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (int i=x+c;i>=x;i--) {\n\t\t\t\tif (m[y+c][i]==1) {\n\t\t\t\t\treturn c;\n\t\t\t\t}\n\t\t\t}\n\t\t\tc++;\n\t\t}\n\t\treturn c;\n\t}\n}", "sampled": "import java.util.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        \n        while (true) {\n            int n = sc.nextInt();\n            if (n == 0) break;\n            sc.nextLine();\n            \n            char[][] grid = new char[n][n];\n            for (int i = 0; i < n; i++) {\n                String line = sc.nextLine();\n                for (int j = 0; j < n; j++) {\n                    grid[i][j] = line.charAt(j);\n                }\n            }\n            \n            int[][] dp = new int[n][n];\n            int maxSize = 0;\n            \n            for (int i = 0; i < n; i++) {\n                for (int j = 0; j < n; j++) {\n                    if (grid[i][j] == '.') {\n                        if (i == 0 || j == 0) {\n                            dp[i][j] = 1;\n                        } else {\n                            dp[i][j] = Math.min(Math.min(dp[i-1][j], dp[i][j-1]), dp[i-1][j-1]) + 1;\n                        }\n                        maxSize = Math.max(maxSize, dp[i][j]);\n                    } else {\n                        dp[i][j] = 0;\n                    }\n                }\n            }\n            \n            System.out.println(maxSize);\n        }\n        \n        sc.close();\n    }\n}\n", "perturbed_sampled": ["import jParagraphStr<extra_id_10>{ String = new Scanner(System.in); while (true) { int n = sc.nextInt(); if (n == 0) break; sc.nextLine(); char[][] grid = new jParagraphStr; }<extra_id_11>jParagraphStr.charAt(jParagraphSem.nextInt())<extra_id_12>String.format(\"\\t%s.%s.length%d.<extra_id_13>% 10 ; if<extra_id_14>jParagraph i++) { String  j  line.charAt(j); } } int[][] dp =    n; j++)  0 ||  = 1;  Math.min(Math.min(dp[i-1][j], dp[i][j-1]),  = Math.max(maxSize, dp[i][j]); } else { dp[i][j]  System.out.println(maxSize); } sc.close(); } }"], "perturbed_original": ["import java.io.*; class Main { private static  { BufferedReader  { int n = Integer.parseInt(buf); int mat[][] = new int[n][n]; String  (int i=0;i<n;i++) {  mat[i][j] = 0; else if (str[i].charAt(j)=='*') mat[i][j]  max = 0; for (int i=0;i<n;i++) { if (str[i].indexOf(check)>=0) { for  { max = d; check = \".\"; for (int k=0;k<max;k++) check = check+\".\"; } }  int c =   i=y;i<=y+c;i++) { if   }"], "original_ll": -0.7796229124069214, "sampled_ll": -0.29041630029678345, "all_perturbed_sampled_ll": [-3.3107330799102783], "all_perturbed_original_ll": [-2.5011651515960693], "perturbed_sampled_ll": -3.3107330799102783, "perturbed_original_ll": -2.5011651515960693, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "while(1):\n    n = int(input())\n    if n == 0:\n        break\n    a = [0 for i in range(n)]\n    b = [[0 for i in range(n)] for j in range(n)]\n    c_ = [[2000 for i in range(n)] for j in range(n)]\n    c = [[0 for i in range(n)] for j in range(n)]\n    for i in range(n):\n        a[i] = [0 if i == \".\" else 1 for i in list(input())]\n        count = 0\n        for j in range(n)[::-1]:\n            if a[i][j] == 0:\n                count += 1\n                b[i][j] = count\n            else:\n                count = 0\n                b[i][j] = count\n                \n    for col in range(n):\n        for i in range(n):\n            for j in range(i,n):\n                if b[j][col] < c_[i][col]:\n                    c_[i][col] = b[j][col]\n                l = j-i+1\n                if c_[i][col] < l:\n                    break\n                c[i][col] = l\n    \n    print(max([max(i) for i in c]))\n\n", "sampled": "import sys\n\ndef max_square(n, grid):\n    if n == 0:\n        return 0\n    \n    # Create DP table\n    dp = [[0] * n for _ in range(n)]\n    max_side = 0\n    \n    # Initialize first row and column\n    for i in range(n):\n        if grid[i][0] == '.':\n            dp[i][0] = 1\n            max_side = 1\n    \n    for j in range(n):\n        if grid[0][j] == '.':\n            dp[0][j] = 1\n            max_side = 1\n    \n    # Fill DP table\n    for i in range(1, n):\n        for j in range(1, n):\n            if grid[i][j] == '.':\n                dp[i][j] = min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1]) + 1\n                max_side = max(max_side, dp[i][j])\n    \n    return max_side\n\nwhile True:\n    n = int(input())\n    if n == 0:\n        break\n    \n    grid = []\n    for _ in range(n):\n        grid.append(input().strip())\n    \n    result = max_square(n, grid)\n    print(result)\n", "perturbed_sampled": ["import sys def max_square(n, grid): if n ==  [[0] * n for _ in range(n)] max_side = 0 # Initialize  range(n): if grid[0][j]  max_side =   for j in range(1, n): if grid[i][j]   = max(max_side,   in range(n): grid.append(input().strip()) result = max_square(n, grid) print(result)"], "perturbed_original": ["while(1):  == 0: break a = [0 for i in range(n)] b  range(n)]  = [[2000 for i in range(n)]  = [[0 for i  range(n)] for i  in list(input())] count = 0 for  == 0:  for i in  if b[j][col]   < l: break c[i][col] =  c]))"], "original_ll": -0.9098446369171143, "sampled_ll": -0.3981064260005951, "all_perturbed_sampled_ll": [-2.5991437435150146], "all_perturbed_original_ll": [-2.8941643238067627], "perturbed_sampled_ll": -2.5991437435150146, "perturbed_original_ll": -2.8941643238067627, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "#include<stdio.h>\nint main(void){\n\tint before,after;\n\tint i;\n\tint flag = 0;\n\twhile(scanf(\"%d %d\",&before,&after)){\n\t\tif(before == 0 && after == 0){\n\t\t\tbreak;\n\t\t}\n\t\tfor(i = before;i <= after;i++){\n\t\t\tif(i % 4 == 0){\n\t\t\t\tif(i % 100 != 0){\n\t\t\t\t\tflag = 1;\n\t\t\t\t\tprintf(\"%d\\n\",i);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(i % 4 == 0){\n\t\t\t\tif(i % 400 == 0){\n\t\t\t\t\tflag = 1;\n\t\t\t\t\tprintf(\"%d\\n\",i);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(flag == 0){\n\t\t\tprintf(\"NA\\n\");\n\t\t}\n\t\tprintf(\"\\n\\n\");\n\t\tflag = 0;\n\t}\n\treturn 0;\n}", "sampled": "#include <stdio.h>\n\nint isLeapYear(int year) {\n    if (year % 400 == 0) return 1;\n    if (year % 100 == 0) return 0;\n    if (year % 4 == 0) return 1;\n    return 0;\n}\n\nint main() {\n    int a, b;\n    int first = 1;\n    \n    while (1) {\n        scanf(\"%d %d\", &a, &b);\n        if (a == 0 && b == 0) break;\n        \n        if (!first) {\n            printf(\"\\n\");\n        }\n        first = 0;\n        \n        int found = 0;\n        for (int year = a; year <= b; year++) {\n            if (isLeapYear(year)) {\n                printf(\"%d\\n\", year);\n                found = 1;\n            }\n        }\n        \n        if (!found) {\n            printf(\"NA\\n\");\n        }\n    }\n    \n    return 0;\n}\n", "perturbed_sampled": [" { if (year % 400 ==  return 1; return 0; } int main() { int a, b; int first = 1; while (1) {  b ==  (isLeapYear(year)) {  } } if (!found) { printf(\"NA\\n\"); } } return 0; }"], "perturbed_original": ["#include<stdio.h>  i; int flag  ==  break; } for(i = before;i  } if(i % 4 == 0){  flag = 1; printf(\"%d\\n\",i); } }  0; } return 0; }"], "original_ll": -0.7553380727767944, "sampled_ll": -0.4964819550514221, "all_perturbed_sampled_ll": [-2.420262336730957], "all_perturbed_original_ll": [-3.119466781616211], "perturbed_sampled_ll": -2.420262336730957, "perturbed_original_ll": -3.119466781616211, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import java.io.IOException;\nimport java.io.BufferedReader;\nimport java.io.InputStreamReader;\n\nclass Main {\n    public static void main(String[] args) throws IOException {\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\n        String line;\n\n        while (!(line = br.readLine()).equals(\"0 0\")) {\n            String[] input = line.split(\" \");\n            int a = Integer.parseInt(input[0]);\n            int b = Integer.parseInt(input[1]);\n            StringBuilder sb = new StringBuilder();\n\n            boolean isNA = true;\n\n            for (int now = a; now <= b; now++) {\n                if (now % 4 == 0) {\n                    if(now % 100 == 0){\n                        if(now % 400 == 0){\n                            sb.append(now).append(\"\\n\");\n                            if (isNA)   isNA = false;\n                        }\n                    }else{\n                        sb.append(now).append(\"\\n\");\n                        if (isNA)   isNA = false;\n                    }\n                }\n            }\n\n            if (isNA) {\n                sb.append(\"NA\").append(\"\\n\");\n            }\n\n            System.out.println(sb);\n        }\n\n    }\n}\n", "sampled": "import java.util.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        boolean first = true;\n        \n        while (true) {\n            int a = sc.nextInt();\n            int b = sc.nextInt();\n            \n            if (a == 0 && b == 0) {\n                break;\n            }\n            \n            if (!first) {\n                System.out.println();\n            }\n            first = false;\n            \n            boolean found = false;\n            for (int year = a; year <= b; year++) {\n                if (isLeapYear(year)) {\n                    System.out.println(year);\n                    found = true;\n                }\n            }\n            \n            if (!found) {\n                System.out.println(\"NA\");\n            }\n        }\n        \n        sc.close();\n    }\n    \n    private static boolean isLeapYear(int year) {\n        if (year % 400 == 0) {\n            return true;\n        }\n        if (year % 100 == 0) {\n            return false;\n        }\n        if (year % 4 == 0) {\n            return true;\n        }\n        return false;\n    }\n}\n", "perturbed_sampled": ["import java.util.*; public class Main  (true) { int a =  if (a == 0 && b == 0) { break; }  year  (isLeapYear(year)) { System.out.println(year); found = true;  }  { if  { return true; } if (year % 100 == 0) { return  return  }"], "perturbed_original": ["import java.io.IOException;  Main  BufferedReader br = new BufferedReader(new InputStreamReader(System.in)); String line; while (!(line =  = line.split(\"  int  = new StringBuilder(); boolean isNA  = a; now  (now % 4 == 0)  0){ if(now % 400 ==  sb.append(now).append(\"\\n\");  System.out.println(sb); } } }"], "original_ll": -0.7082327604293823, "sampled_ll": -0.393057644367218, "all_perturbed_sampled_ll": [-2.4682207107543945], "all_perturbed_original_ll": [-3.270421028137207], "perturbed_sampled_ll": -2.4682207107543945, "perturbed_original_ll": -3.270421028137207, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "while True:\n    a,b=map(int,raw_input().split(\" \"))\n    if a==0 and b==0:\n        break\n    uruu=[]\n    for i in [year for year in range(b+1) if year >=a]:\n        if i%4==0 and i%100!=0 or i%400==0:\n            uruu.append(str(i))\n    if len(uruu)!=0:\n        print '\\n'.join(uruu)\n    else:\n        print \"NA\"\n    print ''", "sampled": "def is_leap_year(year):\n    if year % 400 == 0:\n        return True\n    if year % 100 == 0:\n        return False\n    if year % 4 == 0:\n        return True\n    return False\n\nfirst_dataset = True\n\nwhile True:\n    a, b = map(int, input().split())\n    if a == 0 and b == 0:\n        break\n    \n    if not first_dataset:\n        print()\n    first_dataset = False\n    \n    leap_years = []\n    for year in range(a, b + 1):\n        if is_leap_year(year):\n            leap_years.append(year)\n    \n    if leap_years:\n        for year in leap_years:\n            print(year)\n    else:\n        print(\"NA\")\n", "perturbed_sampled": ["def is_leap_year(year): if year % 400  year % 100 == 0: return False  False first_dataset =  b ==  print()  range(a, b + 1): if is_leap_year(year): leap_years.append(year) if  print(year) else: print(\"NA\")"], "perturbed_original": ["while True: a,b=map(int,raw_input().split(\" \")) if a==0    or i%400==0: uruu.append(str(i)) if  \"NA\" print ''"], "original_ll": -1.3292608261108398, "sampled_ll": -0.612671434879303, "all_perturbed_sampled_ll": [-2.715663194656372], "all_perturbed_original_ll": [-3.7686948776245117], "perturbed_sampled_ll": -2.715663194656372, "perturbed_original_ll": -3.7686948776245117, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "int main(){double a,b;scanf(\"%lf%lf\",&a,&b);printf(\"%.8f\\n\",a*b*0.3025);return 0;}", "sampled": "#include <stdio.h>\n\nint main() {\n    int a, b;\n    scanf(\"%d %d\", &a, &b);\n    \n    double area_m2 = a * b;\n    double area_tsubo = area_m2 / 3.305785;\n    \n    printf(\"%.6f\\n\", area_tsubo);\n    \n    return 0;\n}\n", "perturbed_sampled": [" %d\", &a, &b);  b; double area_tsubo  area_tsubo); return 0; }"], "perturbed_original": ["int main(){double a,b;scanf(\"%lf%lf\",&a,&b);printf(\"%.8f\\n\",a*b*0.3025);return 0;}"], "original_ll": -1.6116118431091309, "sampled_ll": -1.4855016469955444, "all_perturbed_sampled_ll": [-4.188254356384277], "all_perturbed_original_ll": [-1.6116118431091309], "perturbed_sampled_ll": -4.188254356384277, "perturbed_original_ll": -1.6116118431091309, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import java.util.Scanner;\n\npublic class Main \n{\n\tpublic static void main(String[] args)\n\t{\n\t\tString[] input = new Scanner(System.in).nextLine().split(\" \");\n\t\t\n\t\tfloat a = Float.parseFloat(input[0]);\n\t\tfloat b = Float.parseFloat(input[1]);\n\t\t\n\t\tSystem.out.printf(\"%1$.6f\\n\", a*b/3.305785);\n\t}\n}", "sampled": "import java.util.Scanner;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int a = sc.nextInt();\n        int b = sc.nextInt();\n        \n        double area = a * b;\n        double tsubo = area / 3.305785;\n        \n        System.out.println(tsubo);\n        \n        sc.close();\n    }\n}\n", "perturbed_sampled": ["import java.util.Scanner; public class { main(String[] args) {  int a = sc.nextInt(); int b = sc.nextInt(); double  } }"], "perturbed_original": ["  args)  Scanner(System.in).nextLine().split(\" \"); float  = Float.parseFloat(input[1]); System.out.printf(\"%1$.6f\\n\", a*b/3.305785); } }"], "original_ll": -1.3691593408584595, "sampled_ll": -1.1617302894592285, "all_perturbed_sampled_ll": [-2.1600356101989746], "all_perturbed_original_ll": [-3.24699330329895], "perturbed_sampled_ll": -2.1600356101989746, "perturbed_original_ll": -3.24699330329895, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "a, b = map(int, input().split())\nprint(a * b / 3.305785)", "sampled": "a, b = map(int, input().split())\narea_m2 = a * b\ntsubo = area_m2 / 3.305785\nprint(tsubo)\n", "perturbed_sampled": ["a, b  = area_m2 / 3.305785 print(tsubo)"], "perturbed_original": ["a, b = map(int,  3.305785)"], "original_ll": -2.2521822452545166, "sampled_ll": -2.233154296875, "all_perturbed_sampled_ll": [-5.223236083984375], "all_perturbed_original_ll": [-3.3559463024139404], "perturbed_sampled_ll": -5.223236083984375, "perturbed_original_ll": -3.3559463024139404, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "#include <stdio.h>\n#include <stdlib.h>\n\nint\nmain (\n  int   argc,\n  char *argv[ ]\n  )\n{\n  int wo, ws, n;\n  int i;\n\n  scanf ( \"%d%d%d\", &n, &wo, &ws );\n  for ( i = 1; i < n; ++i )\n  {\n    int o, s;\n\n    scanf ( \"%d%d\", &o, &s );\n    if ( s > ws\n      || ( s == ws && o < wo ) )\n    {\n      wo = o;\n      ws = s;\n    }\n  }\n\n  printf ( \"%d %d\\n\", wo, ws );\n\n  return ( EXIT_SUCCESS );\n}", "sampled": "#include <stdio.h>\n\nint main() {\n    int n;\n    scanf(\"%d\", &n);\n    \n    int max_count = -1;\n    int winner_id = 100000;\n    \n    for (int i = 0; i < n; i++) {\n        int a, v;\n        scanf(\"%d %d\", &a, &v);\n        \n        if (v > max_count || (v == max_count && a < winner_id)) {\n            max_count = v;\n            winner_id = a;\n        }\n    }\n    \n    printf(\"%d %d\\n\", winner_id, max_count);\n    \n    return 0;\n}\n", "perturbed_sampled": ["#include <stdio.h> int main() { int n;  -1; int   > max_count || (v == max_count && a < winner_id)) { max_count =   return 0; }"], "perturbed_original": ["#include <extra_id_1>return (<extra_id_2>; }<extra_id_3>} ( int argc, char *argv[ ] ) { int wo, ws, n; int  i < n; ++i )  ( \"%d%d\", &o, &s ); if (   %d\\n\", wo, ws ); return ( EXIT_SUCCESS ); }"], "original_ll": -1.079861044883728, "sampled_ll": -0.6797218322753906, "all_perturbed_sampled_ll": [-3.6859593391418457], "all_perturbed_original_ll": [-3.732327461242676], "perturbed_sampled_ll": -3.6859593391418457, "perturbed_original_ll": -3.732327461242676, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import java.util.Scanner;\n\nclass Main{\n\tpublic static void main(String[] args){\n\t\tScanner sc = new Scanner(System.in);\n\t\t\n\t\tint n = sc.nextInt(),x = 0,y,max = 0;\n\t\t\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tx = Math.max(x, (y = sc.nextInt()));\n\t\t\tif(y == x)max = i + 1;\n\t\t}\n\t\tSystem.out.println(max + \" \" + x);\n\t\t\n\t\tsc.close();\n\t\t}\n}", "sampled": "import java.util.Scanner;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        \n        int n = sc.nextInt();\n        int winnerNumber = 0;\n        int maxCount = -1;\n        \n        for (int i = 0; i < n; i++) {\n            int participantNumber = sc.nextInt();\n            int count = sc.nextInt();\n            \n            if (count > maxCount || (count == maxCount && participantNumber < winnerNumber)) {\n                maxCount = count;\n                winnerNumber = participantNumber;\n            }\n        }\n        \n        System.out.println(winnerNumber + \" \" + maxCount);\n        \n        sc.close();\n    }\n}\n", "perturbed_sampled": [" { public  Scanner(System.in); int n = sc.nextInt();  (int i = 0; i < n; i++)  int count   && participantNumber <  winnerNumber = participantNumber; } } System.out.println(winnerNumber +  } }"], "perturbed_original": ["import  sc = new Scanner(System.in); int n = sc.nextInt(),x  < n; i++){ x  if(y  1; } System.out.println(max + \"  }"], "original_ll": -1.1425676345825195, "sampled_ll": -0.5862747430801392, "all_perturbed_sampled_ll": [-3.3102777004241943], "all_perturbed_original_ll": [-4.464376449584961], "perturbed_sampled_ll": -3.3102777004241943, "perturbed_original_ll": -4.464376449584961, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "n=input()\nx=[0]*(n+1)\nfor i in range(n):\n  a,v=map(int, raw_input().split())\n  x[a]=v\nm=max(x)\nprint x.index(m), m", "sampled": "n = int(input())\nmax_count = -1\nwinner_id = float('inf')\n\nfor _ in range(n):\n    a, v = map(int, input().split())\n    if v > max_count or (v == max_count and a < winner_id):\n        max_count = v\n        winner_id = a\n\nprint(winner_id, max_count)\n", "perturbed_sampled": [" -1 winner_id   input().split()) if v > max_count or  v winner_id = a print(winner_id, max_count)"], "perturbed_original": ["n=input() x=[0]*(n+1) for i  m=max(x) print x.index(m), m"], "original_ll": -1.955080509185791, "sampled_ll": -1.0759934186935425, "all_perturbed_sampled_ll": [-5.224678993225098], "all_perturbed_original_ll": [-4.1640424728393555], "perturbed_sampled_ll": -5.224678993225098, "perturbed_original_ll": -4.1640424728393555, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "#include <stdio.h>\n\nint main(void)\n{\n\tint n;\n\tint i, j, k, l;\n\tint c;\n\t\n\twhile (scanf(\"%d\", &n) != EOF){\n\t\tc = 0;\n\t\tfor (i = 0; i <= 1000; i++){\n\t\t\tfor (j = 0; j <= 1000; j++){\n\t\t\t\tfor (k = 0; k <= 1000; k++){\n\t\t\t\t\tfor (l = 0; l <= 1000; l++){\n\t\t\t\t\t\tif (i + j + k + l == n){\n\t\t\t\t\t\t\tc++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\", c);\n\t}\n\t\n\treturn (0);\n}", "sampled": "#include <stdio.h>\n\nint main() {\n    int n;\n    while (scanf(\"%d\", &n) != EOF) {\n        long long count = 0;\n        for (int a = 0; a <= 1000 && a <= n; a++) {\n            for (int b = 0; b <= 1000 && a + b <= n; b++) {\n                for (int c = 0; c <= 1000 && a + b + c <= n; c++) {\n                    int d = n - a - b - c;\n                    if (d >= 0 && d <= 1000) {\n                        count++;\n                    }\n                }\n            }\n        }\n        printf(\"%lld\\n\", count);\n    }\n    return 0;\n}\n", "perturbed_sampled": ["#include  n;  { long long count = 0; for (int a = 0; a <= 1000 && a <= n; a++)   { int d  (d >= 0 && d <= 1000) { count++; } }  return 0; }"], "perturbed_original": ["#include <stdio.h> int  i, j, k, l; int c; while  = 0;  <= 1000; i++){ for (j = 0; j  1000; k++){  (i + j + k   (0); }"], "original_ll": -0.5304685235023499, "sampled_ll": -0.46994563937187195, "all_perturbed_sampled_ll": [-2.2728374004364014], "all_perturbed_original_ll": [-2.6036946773529053], "perturbed_sampled_ll": -2.2728374004364014, "perturbed_original_ll": -2.6036946773529053, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\n\nimport static java.lang.Integer.parseInt;\n\n/**\n * Sum of 4 Integers II\n */\npublic class Main {\n\n\tpublic static void main(String[] args) throws IOException {\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\tString line;\n\n\t\tint[][] dp = new int[5][4001];\n\n\t\tfor (int i = 1; i <= 4; i++) {\n\t\t\tfor (int j = 0; j <= 1000; j++) {\n\t\t\t\tdp[i][i * j] = 1;\n\t\t\t}\n\t\t}\n\t\tfor (int i = 1; i <= 4; i++) {\n\t\t\tdp[i][0] = 1;\n\t\t}\n\n\t\tfor (int i = 2; i <= 4; i++) {\n\t\t\tfor (int j = 1; j <= 1000; j++) {\n\t\t\t\tdp[i][j] = dp[i - 1][j] + dp[i][j - 1];\n\t\t\t}\n\t\t}\n\n\t\twhile ((line = br.readLine()) != null && !line.isEmpty()) {\n\t\t\tSystem.out.println(dp[4][parseInt(line)]);\n\t\t} // end while\n\t} // end main\n}", "sampled": "import java.util.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        \n        // Precompute all possible sums for two numbers (a+b and c+d)\n        Map<Integer, Integer> sumCount = new HashMap<>();\n        for (int i = 0; i <= 1000; i++) {\n            for (int j = 0; j <= 1000; j++) {\n                int sum = i + j;\n                sumCount.put(sum, sumCount.getOrDefault(sum, 0) + 1);\n            }\n        }\n        \n        while (sc.hasNextInt()) {\n            int n = sc.nextInt();\n            long count = 0;\n            \n            // For each possible sum of a+b, check if n-(a+b) exists as c+d\n            for (Map.Entry<Integer, Integer> entry : sumCount.entrySet()) {\n                int sum1 = entry.getKey();\n                int count1 = entry.getValue();\n                int sum2 = n - sum1;\n                \n                if (sumCount.containsKey(sum2)) {\n                    count += (long) count1 * sumCount.get(sum2);\n                }\n            }\n            \n            System.out.println(count);\n        }\n        \n        sc.close();\n    }\n}\n", "perturbed_sampled": ["import java.util.*; public class Main { public static  sc = new Scanner(System.in); // Precompute all possible sums  c+d) Map<Integer, Integer> sumCount =  1000; i++) { for (int j = 0; j <= 1000; j++)  + j;  } } while  0; //  a+b,  int sum2 = n  * sumCount.get(sum2); }  }"], "perturbed_original": ["import java.io.BufferedReader; import java.io.IOException; import java.io.InputStreamReader; import  of 4  Main  args) throws IOException { BufferedReader  String line; int[][]  i <= 4; i++) {  j <= 1000;  =  dp[i][0] = 1;  2; i <= 4; i++) {  j <= 1000;   1]; } } while ((line  // end main }"], "original_ll": -0.7241489887237549, "sampled_ll": -0.6326650381088257, "all_perturbed_sampled_ll": [-2.7440578937530518], "all_perturbed_original_ll": [-2.7484889030456543], "perturbed_sampled_ll": -2.7440578937530518, "perturbed_original_ll": -2.7484889030456543, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "while 1:\n    try:\n        n = input(); p = min(2000, n);\n        print (p+1)*(p+2)*(3*n-2*p+3)/6\n    except EOFError:\n        break", "sampled": "import sys\nfrom collections import defaultdict\n\ndef count_combinations(n):\n    # Count all possible sums of two numbers (a+b)\n    sum_count = defaultdict(int)\n    \n    # Calculate all possible sums a+b where 0 <= a, b <= 1000\n    for a in range(min(n+1, 1001)):\n        for b in range(min(n+1, 1001)):\n            if a + b <= n:\n                sum_count[a + b] += 1\n    \n    # For each sum of c+d, find how many a+b sums match to make n\n    result = 0\n    for c in range(min(n+1, 1001)):\n        for d in range(min(n+1, 1001)):\n            if c + d <= n:\n                needed = n - (c + d)\n                if needed in sum_count:\n                    result += sum_count[needed]\n    \n    return result\n\nfor line in sys.stdin:\n    n = int(line.strip())\n    print(count_combinations(n))\n", "perturbed_sampled": ["import sys from collections   = defaultdict(int)   b  a  #  find how many a+b sums match   1001)): for d in range(min(n+1, 1001)): if c + d <= n: needed =  if needed in sum_count: result +=  in sys.stdin: n = int(line.strip()) print(count_combinations(n))"], "perturbed_original": [" input();  (p+1)*(p+2)*(3*n-2*p+3)/6 except EOFError: break"], "original_ll": -2.1952428817749023, "sampled_ll": -0.9395961165428162, "all_perturbed_sampled_ll": [-3.7299649715423584], "all_perturbed_original_ll": [-3.859680414199829], "perturbed_sampled_ll": -3.7299649715423584, "perturbed_original_ll": -3.859680414199829, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "// AOJ 0098: Maximum Sum Sequence II \n// 2017.8.15 bal4u@uu\n// 2017.11.1 retry\n\n#include <stdio.h>\n\nint a[102][102];\nint s[102][102];\n\nchar buf[1000], *p;\nint getint()\n{\n\tint n = 0;\n\twhile (*p >= '0') n = (n<<3) + (n<<1) + (*p++ & 0xf);\n\treturn n;\n}\n\nint main()\n{\n\tint n, r, c, k, ans;\n\n\tfgets(p=buf, 10, stdin), n = getint();\n\tfor (r = 0; r < n; r++) {\n\t\tfgets(p=buf, sizeof(buf), stdin);\n\t\tfor (c = 0; c < n; c++, p++) {\n\t\t\tif (*p == '-') p++, a[r][c] = -getint();\n\t\t\telse                a[r][c] =  getint();\n\t\t}\n\t}\n\n\tfor (r = 0; r < n; r++)\n\t\tfor (c = 0; c < n; c++)\n\t\t\ts[r][c+1] += s[r][c] + a[r][c];\n\n\tans = s[0][1];\n\tfor (c = 0; c < n; c++) for (k = c+1; k <= n; k++) {\n\t\tint t = 0;\n\t\tfor (r = 0; r < n; r++) {\n\t\t\tif (t < 0) t  = s[r][k] - s[r][c];\n\t\t\telse       t += s[r][k] - s[r][c];\n\t\t\tif (t > ans) ans = t;\n\t\t}\n\t}\n\tprintf(\"%d\\n\", ans);\n\treturn 0;\n}", "sampled": "#include <stdio.h>\n\nint main() {\n    int n;\n    scanf(\"%d\", &n);\n    \n    int a[100][100];\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < n; j++) {\n            scanf(\"%d\", &a[i][j]);\n        }\n    }\n    \n    int max_sum = a[0][0];\n    \n    for (int top = 0; top < n; top++) {\n        int col_sum[100] = {0};\n        \n        for (int bottom = top; bottom < n; bottom++) {\n            for (int j = 0; j < n; j++) {\n                col_sum[j] += a[bottom][j];\n            }\n            \n            int current_sum = 0;\n            for (int j = 0; j < n; j++) {\n                current_sum += col_sum[j];\n                if (current_sum > max_sum) {\n                    max_sum = current_sum;\n                }\n                if (current_sum < 0) {\n                    current_sum = 0;\n                }\n            }\n        }\n    }\n    \n    printf(\"%d\\n\", max_sum);\n    \n    return 0;\n}\n", "perturbed_sampled": [" int n;   < n; i++) { for (int j = 0; j <  <  = {0}; for (int bottom  bottom++) { for (int j = 0; j < n; j++)  0;  current_sum += col_sum[j]; if (current_sum >  0) { current_sum =  printf(\"%d\\n\", max_sum); return 0; }"], "perturbed_original": ["// AOJ  // 2017.8.15 bal4u@uu // 2017.11.1 retry #include  =  n = (n<<3) + (n<<1) + (*p++ & 0xf); return   ans; fgets(p=buf, 10, stdin), n =   { if  for  = 0; c < n; c++) s[r][c+1] += s[r][c] + a[r][c]; ans =  for   = 0; r < n;  0)  else t +=  > ans) ans = t; } } printf(\"%d\\n\", ans); return 0; }"], "original_ll": -1.1966402530670166, "sampled_ll": -0.3611051142215729, "all_perturbed_sampled_ll": [-2.6843039989471436], "all_perturbed_original_ll": [-2.9965426921844482], "perturbed_sampled_ll": -2.6843039989471436, "perturbed_original_ll": -2.9965426921844482, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "public class\nMain\n{\n  public void\n  run (\n    final java.util.Scanner sc,\n    final java.io.PrintStream out\n    )\n  {\n    int[ ][ ] a;\n    int N;\n    int i, j, k, l;\n    int res;\n\n    N = sc.nextInt ( );\n    a = new int[ N ][ N + 1 ];\n    for ( i = 0; i < N; ++i )\n    for ( j = 1; j <= N ; ++j )\n      a[ i ][ j ] = sc.nextInt ( );\n\n    for ( i = 0; i < N; ++i )\n    for ( j = 1; j <= N; ++j )\n      a[ i ][ j ] += a[ i ][ j - 1 ];\n\n    res = a[ 0 ][ 1 ];\n    for ( i = 0; i < N; ++i )\n    for ( j = i + 1; j <= N; ++j )\n    {\n      for ( k = 0; k < N; ++k )\n      {\n        int t = 0;\n\n        for ( l = k; l < N; ++l )\n        {\n          t += a[ l ][ j ] - a[ l ][ i ];\n          res = Math.max ( res, t );\n        }\n      }\n    }\n\n    out.println ( res );\n  }\n\n  public static void\n  main (\n    String[ ] args\n    )\n  {\n    ( new Main ( ) ).run ( new java.util.Scanner ( System.in ), System.out );\n  }\n}", "sampled": "import java.util.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int n = sc.nextInt();\n        int[][] a = new int[n][n];\n        \n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < n; j++) {\n                a[i][j] = sc.nextInt();\n            }\n        }\n        \n        long maxSum = Long.MIN_VALUE;\n        \n        for (int top = 0; top < n; top++) {\n            int[] colSum = new int[n];\n            \n            for (int bottom = top; bottom < n; bottom++) {\n                for (int col = 0; col < n; col++) {\n                    colSum[col] += a[bottom][col];\n                }\n                \n                long currentSum = 0;\n                long maxEndingHere = Long.MIN_VALUE;\n                \n                for (int col = 0; col < n; col++) {\n                    currentSum += colSum[col];\n                    maxEndingHere = Math.max(maxEndingHere, currentSum);\n                    if (currentSum < 0) {\n                        currentSum = 0;\n                    }\n                }\n                \n                maxSum = Math.max(maxSum, maxEndingHere);\n            }\n        }\n        \n        System.out.println(maxSum);\n        sc.close();\n    }\n}\n", "perturbed_sampled": ["import  public  Scanner(System.in); int n = sc.nextInt(); int[][] a = new int[n][n]; for (int i = 0; i < n; i++) {   a[i][j] =  = Long.MIN_VALUE; for (int top =  bottom = top;  0; col < n; col++)  long currentSum  = 0; col  Math.max(maxEndingHere, currentSum); if  = 0;  sc.close(); } }"], "perturbed_original": [" void run ( final java.util.Scanner sc, final java.io.PrintStream out ) { int[ ][ ]  j, k,  sc.nextInt ( );  ]; for  < N; ++i )  j <=  i ][ j ] =   ( j = 1; j <=  ][ j ]  - 1 ];  1 ]; for  for ( j = i + 1; j   k <    t +=  Math.max ( res, t ); }  ( new  new java.util.Scanner ( System.in ), System.out ); } }"], "original_ll": -0.8061448931694031, "sampled_ll": -0.34165096282958984, "all_perturbed_sampled_ll": [-2.7763636112213135], "all_perturbed_original_ll": [-3.6196274757385254], "perturbed_sampled_ll": -2.7763636112213135, "perturbed_original_ll": -3.6196274757385254, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "# -*- coding: utf-8 -*-\n\"\"\"\nhttp://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=0098\n\n\"\"\"\nimport sys\nfrom sys import stdin\ninput = stdin.readline\n\n\ndef calc_points(n, array):\n    # \u53f3\u4e0b\u304b\u3089(x, y)\u307e\u3067\u306e\u9577\u65b9\u5f62\u306b\u542b\u307e\u308c\u308b\u5024\u306e\u548c\n    dp = [[0] * (n + 1) for _ in range(n + 1)]\n    for y in range(n - 1, -1, -1):\n        for x in range(n - 1, -1, -1):\n            dp[y][x] = dp[y+1][x] + dp[y][x+1] - dp[y+1][x+1] + array[y][x]\n    return dp\n\n\ndef solve(n, array):\n    ans = []\n    dp = calc_points(n, array)\n\n    for sy in range(n + 1):\n        for sx in range(n + 1):\n            for ey in range(sy, n + 1):\n                for ex in range(sx, n + 1):\n                    s1 = dp[sy][sx] #  \u53f3\u4e0b\u304b\u3089\u59cb\u70b9\u307e\u3067\n                    s2 = dp[sy][ex] #  \u91cd\u306a\u308a\u90e8\u5206\n                    s3 = dp[ey][sx] #  \u91cd\u306a\u308a\u90e8\u5206\n                    s4 = dp[ey][ex] #  \u91cd\u306a\u308a\u306e\u91cd\u306a\u308a\u90e8\u5206\n                    s = s1 - s2 -s3 + s4 #  (sx, sy) - (ex, ey) \u9577\u65b9\u5f62\u306e\u7f8e\u5473\u3057\u3055\u30dd\u30a4\u30f3\u30c8\n                    # area = abs(sy - ey) * abs(sx - ex) #  \u9577\u65b9\u5f62\u306e\u9762\u7a4d\n                    ans.append(s)\n    return max(ans)\n\n\ndef main(args):\n    array = []\n    # n = 3\n    # array.append([1, -2, 3])\n    # array.append([-4, 5, 6])\n    # array.append([7, 8, -9])\n\n    n = int(input())\n    for _ in range(n):\n        array.append([int(x) for x in input().split()])\n    ans = solve(n, array)\n    print(ans)\n\n\n\nif __name__ == '__main__':\n    main(sys.argv[1:])\n\n", "sampled": "def max_subarray_sum(arr):\n    if not arr:\n        return 0\n    max_sum = float('-inf')\n    current_sum = 0\n    for num in arr:\n        current_sum = max(num, current_sum + num)\n        max_sum = max(max_sum, current_sum)\n    return max_sum\n\nn = int(input())\nmatrix = []\nfor _ in range(n):\n    row = list(map(int, input().split()))\n    matrix.append(row)\n\nmax_sum = float('-inf')\n\nfor top in range(n):\n    temp = [0] * n\n    for bottom in range(top, n):\n        for col in range(n):\n            temp[col] += matrix[bottom][col]\n        current_max = max_subarray_sum(temp)\n        max_sum = max(max_sum, current_max)\n\nprint(max_sum)\n", "perturbed_sampled": ["def max_subarray_sum(arr): if not arr: return 0 max_sum = float('-inf') current_sum = 0 for num in )<extra_id_8>temp<extra_id_9>= [0]current_max =<extra_id_10>[<extra_id_11>list(map(max(int,<extra_id_12>temp<extra_id_13>current_max)<extra_id_14>current_max) print(current_max) elif current_max < current_sum:<extra_id_15>i = 0 if current_max<extra_id_16>)<extra_id_17>max_sum + num) max_sum =  [] for  list(map(int,  temp = [0]  range(top, n):  current_max) print(max_sum)"], "perturbed_original": ["#  http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=0098 \"\"\" import  input = stdin.readline def calc_points(n, array): # \u53f3\u4e0b\u304b\u3089(x,  (n + 1) for _ in  in range(n - 1, -1, -1): for x in range(n - 1, -1, -1): dp[y][x]   def solve(n, array):  calc_points(n, array) for sy in range(n + 1): for sx in   s2   s   - ey)  \u9577\u65b9\u5f62\u306e\u9762\u7a4d ans.append(s) return max(ans) def main(args): array =   array.append([-4,   ans = solve(n, array) print(ans) if __name__ == '__main__': main(sys.argv[1:])"], "original_ll": -1.0119495391845703, "sampled_ll": -0.589491069316864, "all_perturbed_sampled_ll": [-2.6670191287994385], "all_perturbed_original_ll": [-2.7712080478668213], "perturbed_sampled_ll": -2.6670191287994385, "perturbed_original_ll": -2.7712080478668213, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "#include <stdio.h>\n#include <assert.h>\nint main(void){\n\tint i,x,n,q,a,v,aaa=0,vvv=0,vv[9000],f[1000001],next[1000001],prev[1000001];\n\tscanf(\"%d %d\",&n,&q);\n\tfor(i=0;i<=n;i++){f[i]=0;prev[i]=0;next[i]=0;}\n\tfor(i=0;i<9000;i++)vv[i]=0;\n\tfor(;q>0;q--){\n\t\tscanf(\"%d %d\",&a,&v);\n\n\t\tx=f[a];\n\n\t\tif(x>0){\n\t\t\tif(vv[x]==a){\n\t\t\t\tif(next[a]>0){vv[x]=next[a];}\n\t\t\t\telse vv[x]=0;\n\t\t\t}\n\t\t\tnext[prev[a]]=next[a];\n\t\t\tprev[next[a]]=prev[a];\n\t\t\tprev[0]=0;next[0]=0;\n\t\t}\n\n\t\tf[a]+=v;x+=v;\n\t\t\n\t\tif(x>0){\n\t\t\tif(a<vv[x] || vv[x]==0){\n\t\t\t\tprev[a]=0;\n\t\t\t\tnext[a]=vv[x];\n\t\t\t\tprev[vv[x]]=a;\n\t\t\t\tprev[0]=0;\n\t\t\t\tvv[x]=a;\n\t\t\t}\n\t\t\telse{\n\t\t\t\ti=vv[x];\n\t\t\t\twhile(a>next[i] && next[i]>0){i=next[i];assert(i>0 && i<=n);}\n\t\t\t\tprev[a]=i;\n\t\t\t\tnext[a]=next[i];\n\t\t\t\tprev[next[i]]=a;\n\t\t\t\tnext[i]=a;\n\t\t\t\tprev[0]=0;\n\t\t\t}\n\t\t}else{prev[a]=0;next[a]=0;}\n\t\t\n\t\tif(v>0){if(x>vvv || (x==vvv && a<aaa)){vvv=x;aaa=a;}}\n\t\telse if(a==aaa){\n\t\t\ti=vvv;\n\t\t\t//for(i=vvv; vv[i]<1 && i>0 ;i--){assert(i>0 && i<9000);}\n\t\t\tvvv=i;\n\t\t\t//aaa=vv[i];\n\t\t}\n\t\tprintf(\"%d %d\\n\",aaa,vvv);\n\t}\n\treturn 0;\n}", "sampled": "#include <stdio.h>\n#include <stdlib.h>\n\nint main() {\n    int n, q;\n    scanf(\"%d %d\", &n, &q);\n    \n    long long *counts = (long long *)calloc(n + 1, sizeof(long long));\n    \n    int max_id = 1;\n    long long max_count = 0;\n    \n    for (int i = 0; i < q; i++) {\n        int a, v;\n        scanf(\"%d %d\", &a, &v);\n        \n        counts[a] += v;\n        \n        max_id = 1;\n        max_count = counts[1];\n        for (int j = 2; j <= n; j++) {\n            if (counts[j] > max_count) {\n                max_count = counts[j];\n                max_id = j;\n            }\n        }\n        \n        printf(\"%d %lld\\n\", max_id, max_count);\n    }\n    \n    free(counts);\n    return 0;\n}\n", "perturbed_sampled": ["#include <stdio.h> #include <stdlib.h> int main() {  &n, &q); long  *)calloc(n + 1, sizeof(long long));  long max_count = 0; for  < q; i++) { int a, v; scanf(\"%d %d\", &a, &v); counts[a] +=  max_count); } free(counts); return 0; }"], "perturbed_original": [" main(void){ int i,x,n,q,a,v,aaa=0,vvv=0,vv[9000],f[1000001],next[1000001],prev[1000001]; scanf(\"%d %d\",&n,&q); for(i=0;i<=n;i++){f[i]=0;prev[i]=0;next[i]=0;} for(i=0;i<9000;i++)vv[i]=0; for(;q>0;q--){ scanf(\"%d %d\",&a,&v);  prev[0]=0;next[0]=0;  vv[x]==0){  }  && i<=n);} prev[a]=i; next[a]=next[i]; prev[next[i]]=a; next[i]=a; prev[0]=0;  &&  &&  %d\\n\",aaa,vvv); } return 0; }"], "original_ll": -1.3238756656646729, "sampled_ll": -0.5651220679283142, "all_perturbed_sampled_ll": [-2.3474669456481934], "all_perturbed_original_ll": [-1.8536955118179321], "perturbed_sampled_ll": -2.3474669456481934, "perturbed_original_ll": -1.8536955118179321, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "public class\nMain\n{\n  public void\n  run (\n    final java.util.Scanner sc,\n    final java.io.PrintStream out\n    )\n  {\n    Pair[ ] heap;\n    int[ ]  paeh;\n    int n, q;\n    int i;\n    \n    n = sc.nextInt ( );\n    q = sc.nextInt ( );\n\n    heap = new Pair[ n ];\n    paeh = new int[ n + 1 ];\n    for ( i = 1; i <= n; ++i )\n    {\n      paeh[ i ] = i - 1;\n      heap[ paeh[ i ] ] = new Pair ( i, 0 );\n    }\n\n    for ( ; q > 0; --q )\n    {\n      int a, v, b;\n\n      a = sc.nextInt ( );\n      v = sc.nextInt ( );\n      b = heap[ heap.length - 1 ].index;\n\n      swap ( heap, paeh[ a ], paeh[ b ] );\n      swap ( paeh, a, heap[ paeh[ a ] ].index );\n      for ( ; ; )\n      {\n        if ( paeh[ b ] * 2 + 2 < heap.length - 1\n          && heap[ paeh[ b ] * 2 + 2 ].compareTo ( heap[ paeh[ b ] * 2 + 1 ] ) < 0\n          && heap[ paeh[ b ] * 2 + 2 ].compareTo ( heap[ paeh[ b ] ] ) < 0 )\n        {\n          swap ( heap, paeh[ b ], paeh[ b ] * 2 + 2 );\n          swap ( paeh, b, heap[ paeh[ b ] ].index );\n        }\n        else if ( paeh[ b ] * 2 + 1 < heap.length - 1\n               && heap[ paeh[ b ] * 2 + 1 ].compareTo ( heap[ paeh[ b ] ] ) < 0 )\n        {\n          swap ( heap, paeh[ b ], paeh[ b ] * 2 + 1 );\n          swap ( paeh, b, heap[ paeh[ b ] ].index );\n        }\n        else break ;\n      }\n      heap[ paeh[ a ] ].value += v;\n      for ( ; ; )\n      {\n        if ( paeh[ a ] > 0\n          && heap[ paeh[ a ] ].compareTo ( heap[ ( paeh[ a ] - 1 ) / 2 ] ) < 0 )\n        {\n          swap ( heap, paeh[ a ], ( paeh[ a ] - 1 ) / 2 );\n          swap ( paeh, a, heap[ paeh[ a ] ].index );\n        }\n        else break ;\n      }\n      System.out.println ( heap[ 0 ].index + \" \" + heap[ 0 ].value );\n    }\n  }\n\n  private static void\n  swap (\n    int[ ] a,\n    int i,\n    int j\n    )\n  {\n    final int t = a[ i ];\n    a[ i ] = a[ j ];\n    a[ j ] = t;\n  }\n\n  private static <T> void\n  swap (\n    T[ ] a,\n    int i,\n    int j\n    )\n  {\n    final T t = a[ i ];\n    a[ i ] = a[ j ];\n    a[ j ] = t;\n  }\n\n  public static void\n  main (\n    final String[ ] args\n    )\n  {\n    ( new Main ( ) ).run ( new java.util.Scanner ( System.in ), System.out );\n  }\n\n  private class\n  Pair\n  implements Comparable<Pair>\n  {\n    public final int index;\n    public       int value;\n\n    public\n    Pair (\n      final int index,\n      final int value\n      )\n    {\n      this.index = index;\n      this.value = value;\n    }\n\n    public int\n    compareTo (\n      final Pair obj\n      )\n    {\n      if ( this.value == obj.value )\n        return ( this.index - obj.index );\n      return ( obj.value - this.value );\n    }\n  }\n}", "sampled": "import java.util.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int n = sc.nextInt();\n        int q = sc.nextInt();\n        \n        Map<Integer, Integer> counts = new HashMap<>();\n        \n        for (int i = 0; i < q; i++) {\n            int a = sc.nextInt();\n            int v = sc.nextInt();\n            \n            counts.put(a, counts.getOrDefault(a, 0) + v);\n            \n            int maxCount = Integer.MIN_VALUE;\n            int maxParticipant = Integer.MAX_VALUE;\n            \n            for (int participant = 1; participant <= n; participant++) {\n                int count = counts.getOrDefault(participant, 0);\n                if (count > maxCount || (count == maxCount && participant < maxParticipant)) {\n                    maxCount = count;\n                    maxParticipant = participant;\n                }\n            }\n            \n            System.out.println(maxParticipant + \" \" + maxCount);\n        }\n        \n        sc.close();\n    }\n}\n", "perturbed_sampled": ["import java.util.*; public class Main { public static  sc = new Scanner(System.in); int n = sc.nextInt(); int  counts = new   {  v = sc.nextInt();  int   = 1;  maxCount || (count == maxCount  System.out.println(maxParticipant + \" \"  }"], "perturbed_original": ["public class Main { public   { Pair[ ] heap; int[  n    ( i, 0 ); } for (  sc.nextInt  heap[ heap.length  heap, paeh[ a ], paeh[ b ] ); swap ( paeh, a, heap[ paeh[ a ] ].index );   ] * 2 + 2 < heap.length - 1   (  2  0 && heap[ paeh[  paeh[ b ] ] ) <  heap, paeh[ b ], paeh[ b ] * 2 +  ] ].index ); } else  < heap.length  b ] * 2 + 1 ].compareTo ( heap[  < 0   1 );  paeh[  else break  ] ].value += v; for ( ; ; ) { if ( paeh[ a ] > 0 && heap[ paeh[ a ] ].compareTo ( heap[ ( paeh[ a ]  ) { swap  - 1  ( paeh, a, heap[ paeh[  else break ; }  heap[ 0 ].value ); } }  int[ ] a,   i   } private static <T> void swap ( T[  j ) {  = t; } public static   (  private class Pair implements Comparable<Pair> { public final int index;   Pair obj ) { if ( this.value == obj.value ) return ( this.index -  } }"], "original_ll": -0.6501765251159668, "sampled_ll": -0.521535336971283, "all_perturbed_sampled_ll": [-3.350114107131958], "all_perturbed_original_ll": [-3.050274133682251], "perturbed_sampled_ll": -3.350114107131958, "perturbed_original_ll": -3.050274133682251, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "# -*- coding: utf-8 -*-\n\"\"\"\nhttp://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=0099\n\"\"\"\nimport sys\nimport bisect\n\n\n\ndef main(args):\n    #data = [(1, 4), (2, 5), (1, 3), (3, 6), (2, 7)]\n    #data = [(1, 4), (2, 5), (2, -3),(3, 4), (1, -1)]\n    fisher, event = [int(x) for x in input().split(' ')]\n    fishes = [0 for _ in range(fisher + 1)]\n\n    winner = 9999999999\n    max_fish = -1\n    for _ in range(event):\n        id, fish = [int(x) for x in input().strip().split(' ')]\n        fishes[id] += fish\n        if fish > 0:\n            if fishes[id] > max_fish:\n                max_fish = fishes[id]\n                winner = id\n            elif fishes[id] == max_fish:\n                winner = min(winner, id)\n            else:\n                pass\n        else:\n            max_fish = max(fishes)\n            winner = fishes.index(max_fish)\n        print('{} {}'.format(winner, max_fish))\n\n\nif __name__ == '__main__':\n    main(sys.argv[1:])", "sampled": "n, q = map(int, input().split())\ncounts = [0] * (n + 1)\n\nfor _ in range(q):\n    a, v = map(int, input().split())\n    counts[a] += v\n    \n    max_count = max(counts[1:n+1])\n    for i in range(1, n + 1):\n        if counts[i] == max_count:\n            print(i, max_count)\n            break\n", "perturbed_sampled": ["n, q   for _ in range(q):  = max(counts[1:n+1]) for i  if counts[i] == max_count: print(i, max_count) break"], "perturbed_original": ["# -*- coding: utf-8 -*- \"\"\" http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=0099 \"\"\" import sys import bisect def main(args): #data = [(1,  #data =  -3),(3, 4),   for  winner = 9999999999 max_fish = -1 for _ in range(event): id,  in  max_fish  = max(fishes) winner = fishes.index(max_fish)  == '__main__': main(sys.argv[1:])"], "original_ll": -1.0935108661651611, "sampled_ll": -0.7770909070968628, "all_perturbed_sampled_ll": [-3.346590042114258], "all_perturbed_original_ll": [-2.998584508895874], "perturbed_sampled_ll": -3.346590042114258, "perturbed_original_ll": -2.998584508895874, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "#include<stdio.h>\n\nint main(void){\n\tint n;\n\tint staff,price,sold;\n\twhile(1){\n\t\tint i,j = 0;\n\t\tint sccess[4000];\n\t\tscanf(\"%d\", &n);\n\t\tif(n == 0)\n\t\t\treturn 0;\n\t\t\n\t\tfor(i = 0;i < n;i++){\n\t\t\tscanf(\"%d %d %d\", &staff, &price, &sold);\n\t\t\tif(price * sold >= 1000000){\n\t\t\t\tsccess[j] = staff;\n\t\t\t\tj++;\n\t\t\t}\n\t\t}\n\t\tif(j == 0){\n\t\t\tprintf(\"NA\\n\");\n\t\t}\n\t\tfor(i = 0; j > i; i++){\n\t\t\tprintf(\"%d\\n\", sccess[i]);\n\t\t}\n\t}\n}", "sampled": "#include <stdio.h>\n#include <string.h>\n\nint main() {\n    int n;\n    while(scanf(\"%d\", &n) && n != 0) {\n        int ids[4000];\n        long long sales[4000];\n        int count = 0;\n        \n        for(int i = 0; i < n; i++) {\n            int id, p, q;\n            scanf(\"%d %d %d\", &id, &p, &q);\n            \n            int found = -1;\n            for(int j = 0; j < count; j++) {\n                if(ids[j] == id) {\n                    found = j;\n                    break;\n                }\n            }\n            \n            if(found == -1) {\n                ids[count] = id;\n                sales[count] = (long long)p * q;\n                count++;\n            } else {\n                sales[found] += (long long)p * q;\n            }\n        }\n        \n        int found_any = 0;\n        for(int i = 0; i < count; i++) {\n            if(sales[i] >= 1000000) {\n                printf(\"%d\\n\", ids[i]);\n                found_any = 1;\n            }\n        }\n        \n        if(!found_any) {\n            printf(\"NA\\n\");\n        }\n    }\n    \n    return 0;\n}\n", "perturbed_sampled": ["#include <stdio.h> #include  n; while(scanf(\"%d\", &n) && n != 0) { int ids[4000]; long long sales[4000]; int count  0; i  id, p, q; scanf(\"%d %d %d\", &id, &p, &q); int  = j; break;  { ids[count] =  *  sales[found]   0; i < count;  } return 0; }"], "perturbed_original": ["#include<stdio.h>  =  0; for(i = 0;i < n;i++){  &sold); if(price * sold >= 1000000){ sccess[j] = staff; j++; } } if(j == 0){  }"], "original_ll": -1.182053565979004, "sampled_ll": -0.5563002824783325, "all_perturbed_sampled_ll": [-2.591273546218872], "all_perturbed_original_ll": [-3.1548805236816406], "perturbed_sampled_ll": -2.591273546218872, "perturbed_original_ll": -3.1548805236816406, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.List;\nimport java.util.Scanner;\n\n//Sale Result\npublic class Main{\n\n\tstatic class P implements Comparable<P>{\n\t\tpublic int o;\n\t\tpublic long s;\n\t\tpublic int compareTo(P o) {\n\t\t\treturn this.o-o.o;\n\t\t}\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\twhile(true){\n\t\t\tint n = sc.nextInt();\n\t\t\tif(n==0)break;\n\t\t\tList<Integer> l = new ArrayList<Integer>();\n\t\t\tP[] s = new P[4001];\n\t\t\tint id = 0;\n\t\t\twhile(n--!=0){\n\t\t\t\tint d = sc.nextInt();\n\t\t\t\tif(s[d]==null){\n\t\t\t\t\ts[d] = new P();\n\t\t\t\t\ts[d].o = id++;\n\t\t\t\t}\n\t\t\t\tlong p = sc.nextLong();\n\t\t\t\tlong k = sc.nextLong();\n\t\t\t\ts[d].s+=p*k;\n\t\t\t}\n\t\t\tfor(int i=1;i<4001;i++)if(s[i]!=null&&1000000<=s[i].s)l.add(i);\n\t\t\tCollections.sort(l);\n\t\t\tif(l.isEmpty())System.out.println(\"NA\");\n\t\t\telse for(int i:l)System.out.println(i);\n\t\t}\n\t}\n}", "sampled": "import java.util.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        \n        while (true) {\n            int n = sc.nextInt();\n            if (n == 0) break;\n            \n            LinkedHashMap<Integer, Long> sales = new LinkedHashMap<>();\n            \n            for (int i = 0; i < n; i++) {\n                int id = sc.nextInt();\n                long price = sc.nextLong();\n                long quantity = sc.nextLong();\n                long amount = price * quantity;\n                \n                sales.put(id, sales.getOrDefault(id, 0L) + amount);\n            }\n            \n            boolean found = false;\n            for (Map.Entry<Integer, Long> entry : sales.entrySet()) {\n                if (entry.getValue() >= 1000000) {\n                    System.out.println(entry.getKey());\n                    found = true;\n                }\n            }\n            \n            if (!found) {\n                System.out.println(\"NA\");\n            }\n        }\n        \n        sc.close();\n    }\n}\n", "perturbed_sampled": [" { public static   = sc.nextInt(); if (n == 0)  new  i++) { int id =  long quantity  price * quantity; sales.put(id, sales.getOrDefault(id, 0L) + amount); }   { if (entry.getValue() >= 1000000)  sc.close(); } }"], "perturbed_original": ["import java.util.ArrayList;  java.util.Scanner; //Sale Result public  o;   Scanner(System.in); while(true){ int n = sc.nextInt(); if(n==0)break; List<Integer> l  = new P[4001]; int id = 0; while(n--!=0){ int d = sc.nextInt();  s[d].o = id++; } long   i=1;i<4001;i++)if(s[i]!=null&&1000000<=s[i].s)l.add(i);  } } }"], "original_ll": -1.0943036079406738, "sampled_ll": -0.5078475475311279, "all_perturbed_sampled_ll": [-3.2485744953155518], "all_perturbed_original_ll": [-2.7678439617156982], "perturbed_sampled_ll": -3.2485744953155518, "perturbed_original_ll": -2.7678439617156982, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "# -*- coding: utf-8 -*-\n\nimport sys\nimport os\nimport math\nfrom collections import defaultdict\n\nfor s in sys.stdin:\n    n = int(s)\n    if n == 0:\n        break\n\n    d = defaultdict(int)\n    keys = []\n    for i in range(n):\n        e, p, q = map(int, input().split())\n        d[e] += p * q\n        if e not in keys:\n            keys.append(e)\n\n    # remove dup\n    is_exist = False\n\n    for key in keys:\n        v = d[key]\n        if v >= 1000000:\n            print(key)\n            is_exist = True\n\n    if not is_exist:\n        print('NA')", "sampled": "while True:\n    n = int(input())\n    if n == 0:\n        break\n    \n    sales = {}\n    order = []\n    \n    for _ in range(n):\n        line = input().split()\n        employee_id = line[0]\n        p = int(line[1])\n        q = int(line[2])\n        \n        if employee_id not in sales:\n            sales[employee_id] = 0\n            order.append(employee_id)\n        \n        sales[employee_id] += p * q\n    \n    result = []\n    for employee_id in order:\n        if sales[employee_id] >= 1000000:\n            result.append(employee_id)\n    \n    if result:\n        for emp_id in result:\n            print(emp_id)\n    else:\n        print(\"NA\")\n", "perturbed_sampled": ["while True: n = int(input()) if n == 0: break sales =  =   if employee_id not in  q   for emp_id in result: print(emp_id) else: print(\"NA\")"], "perturbed_original": ["# -*- coding: utf-8 -*- import sys import os import  n == 0: break d = defaultdict(int) keys = []  # remove dup is_exist =  is_exist = True if not is_exist: print('NA')"], "original_ll": -1.0894546508789062, "sampled_ll": -0.8159208297729492, "all_perturbed_sampled_ll": [-3.3673202991485596], "all_perturbed_original_ll": [-3.5248658657073975], "perturbed_sampled_ll": -3.3673202991485596, "perturbed_original_ll": -3.5248658657073975, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "#include <stdio.h>\n#include <string.h>\n\nint main(void) {\n\tint n;\n\tchar in[1024], *ptr;\n\n\tscanf(\"%d \", &n);\n\n\twhile (n--) {\n\t\tfgets(in, 1023, stdin);\n\t\tptr = strstr(in, \"Hoshino\");\n\t\twhile (ptr != NULL) {\n\t\t\tptr[6] = 'a';\n\t\t\tptr = strstr(ptr, \"Hoshino\");\n\t\t}\n\t\tprintf(\"%s\", in);\n\t}\n\treturn 0;\n}", "sampled": "#include <stdio.h>\n#include <string.h>\n\nint main() {\n    int n;\n    char line[1001];\n    char result[1001];\n    \n    scanf(\"%d\\n\", &n);\n    \n    for (int i = 0; i < n; i++) {\n        fgets(line, sizeof(line), stdin);\n        \n        int len = strlen(line);\n        if (line[len-1] == '\\n') {\n            line[len-1] = '\\0';\n            len--;\n        }\n        \n        int j = 0;\n        int k = 0;\n        \n        while (j < len) {\n            if (j + 6 < len && strncmp(&line[j], \"Hoshino\", 7) == 0) {\n                strcpy(&result[k], \"Hoshina\");\n                k += 7;\n                j += 7;\n            } else if (j + 6 == len && strncmp(&line[j], \"Hoshino\", 7) == 0) {\n                strcpy(&result[k], \"Hoshina\");\n                k += 7;\n                j += 7;\n            } else {\n                result[k] = line[j];\n                k++;\n                j++;\n            }\n        }\n        \n        result[k] = '\\0';\n        printf(\"%s\\n\", result);\n    }\n    \n    return 0;\n}\n", "perturbed_sampled": ["#include <stdio.h> #include <string.h> int main() { int n;  = 0; i  sizeof(line), stdin); int len = strlen(line); if (line[len-1] == '\\n')  } int j = 0; int k = 0; while   \"Hoshina\"); k += 7;   7; j +=  } } result[k] =  0; }"], "perturbed_original": ["#include <stdio.h> #include <string.h> int main(void) {  'a'; ptr = strstr(ptr, \"Hoshino\"); } printf(\"%s\", in); } return 0; }"], "original_ll": -1.1224881410598755, "sampled_ll": -0.6112725138664246, "all_perturbed_sampled_ll": [-2.8637070655822754], "all_perturbed_original_ll": [-2.9302139282226562], "perturbed_sampled_ll": -2.8637070655822754, "perturbed_original_ll": -2.9302139282226562, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import java.util.Scanner;\n\npublic class Main {\n\tpublic static void main(String args[]){\n\t\tScanner sc = new Scanner(System.in);\n\t\tint n = Integer.parseInt(sc.nextLine());\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tString str = sc.nextLine();\n\t\t\tstr = str.replaceAll(\"Hoshino\", \"Hoshina\");\n\t\t\tSystem.out.println(str);\n\t\t}\n\t}\n}\n", "sampled": "import java.util.Scanner;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int n = Integer.parseInt(sc.nextLine());\n        \n        for (int i = 0; i < n; i++) {\n            String line = sc.nextLine();\n            String result = line.replace(\"Hoshino\", \"Hoshina\");\n            System.out.println(result);\n        }\n        \n        sc.close();\n    }\n}\n", "perturbed_sampled": ["import java.util.Scanner; public ()<extra_id_1><s> class n; i++) { String line = sc.nextLine(); String result = line.replace(\"Hoshino\", \"Hoshina\"); System.out.println(result); } sc.close(); } }"], "perturbed_original": ["import java.util.Scanner; public  void   n; i++) { String str = sc.nextLine(); str = str.replaceAll(\"Hoshino\", \"Hoshina\"); System.out.println(str); } } }"], "original_ll": -1.033908724784851, "sampled_ll": -0.8473575711250305, "all_perturbed_sampled_ll": [-3.638949394226074], "all_perturbed_original_ll": [-2.8987069129943848], "perturbed_sampled_ll": -3.638949394226074, "perturbed_original_ll": -2.8987069129943848, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import sys\n\ndef main():\n  n = int(sys.stdin.readline())\n  for _ in range(n):\n    line = sys.stdin.readline()\n    print(line.strip().replace(\"Hoshino\", \"Hoshina\"))\n\nif __name__ == \"__main__\":\n  main()", "sampled": "n = int(input())\nfor _ in range(n):\n    line = input()\n    print(line.replace(\"Hoshino\", \"Hoshina\"))\n", "perturbed_sampled": ["n = int(input()) for  input() print(line.replace(\"Hoshino\", \"Hoshina\"))"], "perturbed_original": ["import sys def main(): n = int(sys.stdin.readline()) for  sys.stdin.readline() print(line.strip().replace(\"Hoshino\",  main()"], "original_ll": -1.347481369972229, "sampled_ll": -2.0737977027893066, "all_perturbed_sampled_ll": [-4.554288387298584], "all_perturbed_original_ll": [-3.8395497798919678], "perturbed_sampled_ll": -4.554288387298584, "perturbed_original_ll": -3.8395497798919678, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "#include<stdio.h>\n\nint main(){\n  int a[11][11]={};\n  int i,j,n,s,t;\n\n  for(;;){\n    scanf(\"%d\",&n);\n    if(!n)\n      break;\n    t=0;\n\n    for(i=0;i<n;i++){\n      s=0;\n      for(j=0;j<n;j++){\n\tscanf(\"%d\",&a[i][j]);\n\ts+=a[i][j];\n      }\n      a[i][n]=s;\n      t+=s;\n    }\n    a[n][n]=t;\n    for(j=0;j<n;j++){\n      s=0;\n      for(i=0;i<n;i++){\n\ts+=a[i][j];\n      }\n      a[n][j]=s;\n    }\n    for(i=0;i<=n;i++){\n      for(j=0;j<=n;j++){\n\tprintf(\"%5d\",a[i][j]);\n      }\n      puts(\"\");\n    }\n  }\n  return 0;\n}", "sampled": "#include <stdio.h>\n\nint main() {\n    int n;\n    \n    while(1) {\n        scanf(\"%d\", &n);\n        if(n == 0) break;\n        \n        int table[n][n];\n        int rowSum[n];\n        int colSum[n];\n        int totalSum = 0;\n        \n        // Read input\n        for(int i = 0; i < n; i++) {\n            for(int j = 0; j < n; j++) {\n                scanf(\"%d\", &table[i][j]);\n            }\n        }\n        \n        // Calculate row sums\n        for(int i = 0; i < n; i++) {\n            rowSum[i] = 0;\n            for(int j = 0; j < n; j++) {\n                rowSum[i] += table[i][j];\n            }\n        }\n        \n        // Calculate column sums\n        for(int j = 0; j < n; j++) {\n            colSum[j] = 0;\n            for(int i = 0; i < n; i++) {\n                colSum[j] += table[i][j];\n            }\n        }\n        \n        // Calculate total sum\n        for(int i = 0; i < n; i++) {\n            totalSum += rowSum[i];\n        }\n        \n        // Print table with row sums\n        for(int i = 0; i < n; i++) {\n            for(int j = 0; j < n; j++) {\n                printf(\"%5d\", table[i][j]);\n            }\n            printf(\"%5d\\n\", rowSum[i]);\n        }\n        \n        // Print column sums and total sum\n        for(int j = 0; j < n; j++) {\n            printf(\"%5d\", colSum[j]);\n        }\n        printf(\"%5d\\n\", totalSum);\n    }\n    \n    return 0;\n}\n", "perturbed_sampled": ["#include <stdio.h>   == 0)  int colSum[n]; int  input   j = 0;  //  n;  = 0; j < n; j++) {  = 0; i < n; i++) { colSum[j] +=  total sum for(int i = 0; i < n;  } // Print table with row sums for(int i =  { for(int j    column sums and total sum for(int j  j++)  totalSum); } return 0; }"], "perturbed_original": ["#include<stdio.h> int main(){ int a[11][11]={}; int i,j,n,s,t; for(;;){ scanf(\"%d\",&n); if(!n) break;   for(i=0;i<=n;i++){ for(j=0;j<=n;j++){  return 0; }"], "original_ll": -0.7371178865432739, "sampled_ll": -0.31287622451782227, "all_perturbed_sampled_ll": [-3.168408155441284], "all_perturbed_original_ll": [-1.8140220642089844], "perturbed_sampled_ll": -3.168408155441284, "perturbed_original_ll": -1.8140220642089844, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import java.util.*;\n\nclass Main{\n    public static void main(String args[]){\n        Scanner in = new Scanner(System.in);\n        while(true){\n            int n = in.nextInt();\n            if(n == 0) return ;\n            int mat[][] = new int[n+1][n+1];\n            for(int i=0; i<n; i++){\n                int sumr = 0;\n                for(int j=0; j<n; j++){\n                    mat[i][j] = in.nextInt();\n                    sumr += mat[i][j];\n                }\n                mat[i][n] = sumr;\n            }\n            for(int j=0; j<=n; j++){\n                int sumc = 0;\n                for(int i=0; i<n; i++){\n                    sumc += mat[i][j];\n                }\n                mat[n][j] = sumc;\n            }\n            for(int i=0; i<=n; i++){\n                for(int j=0; j<=n; j++){\n                    System.out.printf(\"%5d\",mat[i][j]);\n                }\n                System.out.println();\n            }\n        }\n    }\n}", "sampled": "import java.util.Scanner;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        \n        while (true) {\n            int n = sc.nextInt();\n            if (n == 0) break;\n            \n            int[][] table = new int[n][n];\n            \n            for (int i = 0; i < n; i++) {\n                for (int j = 0; j < n; j++) {\n                    table[i][j] = sc.nextInt();\n                }\n            }\n            \n            int[] rowSums = new int[n];\n            int[] colSums = new int[n];\n            \n            for (int i = 0; i < n; i++) {\n                int rowSum = 0;\n                for (int j = 0; j < n; j++) {\n                    rowSum += table[i][j];\n                }\n                rowSums[i] = rowSum;\n            }\n            \n            for (int j = 0; j < n; j++) {\n                int colSum = 0;\n                for (int i = 0; i < n; i++) {\n                    colSum += table[i][j];\n                }\n                colSums[j] = colSum;\n            }\n            \n            int totalSum = 0;\n            for (int i = 0; i < n; i++) {\n                totalSum += rowSums[i];\n            }\n            \n            for (int i = 0; i < n; i++) {\n                for (int j = 0; j < n; j++) {\n                    System.out.printf(\"%5d\", table[i][j]);\n                }\n                System.out.printf(\"%5d\\n\", rowSums[i]);\n            }\n            \n            for (int j = 0; j < n; j++) {\n                System.out.printf(\"%5d\", colSums[j]);\n            }\n            System.out.printf(\"%5d\\n\", totalSum);\n        }\n        \n        sc.close();\n    }\n}\n", "perturbed_sampled": ["import java.util.Scanner; public class Main { public  Scanner  (true) {  int[][] table = new int[n][n]; for (int i = 0; i <  j =  { table[i][j] = sc.nextInt();  (int i = 0; i < n; i++) { int rowSum  n; j++)  rowSums[i] = rowSum; } for (int j =   for  < n; i++) { colSum  i = 0; i < n; i++)  0;  0; j < n; j++) {  } sc.close(); } }"], "perturbed_original": ["import java.util.*; class Main{ public  in = new Scanner(System.in);  if(n  for(int i=0; i<n; i++){   in.nextInt(); sumr += mat[i][j]; }  sumc  i++){ sumc += mat[i][j];  for(int i=0; i<=n;  } } }"], "original_ll": -0.5017719864845276, "sampled_ll": -0.2444511502981186, "all_perturbed_sampled_ll": [-2.3482046127319336], "all_perturbed_original_ll": [-2.552609443664551], "perturbed_sampled_ll": -2.3482046127319336, "perturbed_original_ll": -2.552609443664551, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import functools\n\nn = input()\nwhile(n):\n    list = []\n    bottom_record = [0]*(n+1)\n\n    for i in range(0, n):\n        l = map(int, raw_input().split())\n        l.append(functools.reduce(lambda x, y: x + y, l))\n        bottom_record = [x + y for(x,y) in zip(bottom_record, l)]\n        print(' '.join(map(str, l))) \n    print(' '.join(map(str, bottom_record)))\n    n = input()", "sampled": "while True:\n    n = int(input())\n    if n == 0:\n        break\n    \n    table = []\n    for i in range(n):\n        row = list(map(int, input().split()))\n        table.append(row)\n    \n    # Calculate row sums\n    row_sums = []\n    for row in table:\n        row_sums.append(sum(row))\n    \n    # Calculate column sums\n    col_sums = []\n    for j in range(n):\n        col_sum = sum(table[i][j] for i in range(n))\n        col_sums.append(col_sum)\n    \n    # Calculate total sum\n    total_sum = sum(row_sums)\n    \n    # Print the table with sums\n    for i in range(n):\n        for j in range(n):\n            print(f\"{table[i][j]:5d}\", end=\"\")\n        print(f\"{row_sums[i]:5d}\")\n    \n    # Print column sums row\n    for col_sum in col_sums:\n        print(f\"{col_sum:5d}\", end=\"\")\n    print(f\"{total_sum:5d}\")\n", "perturbed_sampled": ["while True:  == 0: break table = [] for i in range(n): row = list(map(int,   j in range(n): col_sum = sum(table[i][j] for i in range(n)) col_sums.append(col_sum) #  table with sums  column  col_sums: print(f\"{col_sum:5d}\", end=\"\") print(f\"{total_sum:5d}\")"], "perturbed_original": ["import functools  [0]*(n+1)  l.append(functools.reduce(lambda x, y:  = [x + y for(x,y) in zip(bottom_record, l)] print(' '.join(map(str,  = input()"], "original_ll": -1.6041557788848877, "sampled_ll": -0.6042158603668213, "all_perturbed_sampled_ll": [-2.7213854789733887], "all_perturbed_original_ll": [-3.9383180141448975], "perturbed_sampled_ll": -2.7213854789733887, "perturbed_original_ll": -3.9383180141448975, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "#include <stdio.h>\n#include <string.h>\n\nint main(void)\n{\n\tint n;\n\tchar event[8];\n\tint out = 0;\n\tint base[3] = {0};\n\tint i;\n\tint score;\n\t\n\tscanf(\"%d\", &n);\n\t\t\t \n\twhile (n != 0){\n\t\tscore = 0;\n\t\tbase[0] = 0;\n\t\tbase[1] = 0;\n\t\tbase[2] = 0;\n\t\tout = 0;\n\t\twhile (out < 3){\n\t\t\tscanf(\"%s\", event);\n\t\t\tif (strcmp(event, \"HIT\") == 0){\n\t\t\t\tbase[0]++;\n\t\t\t\tfor (i = 0; i < 3; i++){\n\t\t\t\t\tif (base[i] > 1){\n\t\t\t\t\t\tif (i < 2){\n\t\t\t\t\t\t\tbase[i + 1]++;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tscore++;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbase[i]--;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (strcmp(event, \"HOMERUN\") == 0){\n\t\t\t\tfor (i = 0; i < 3; i++){\n\t\t\t\t\tif (base[i] == 1){\n\t\t\t\t\t\tscore++;\n\t\t\t\t\t\tbase[i] = 0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tscore++;\n\t\t\t}\n\t\t\telse if (strcmp(event, \"OUT\") == 0){\n\t\t\t\tout++;\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\", score);\n\t\tn--;\n\t}\n\t\n\treturn 0;\n}", "sampled": "#include <stdio.h>\n#include <string.h>\n\nint main() {\n    int n;\n    scanf(\"%d\", &n);\n    \n    while (n--) {\n        int base[4] = {0}; // base[1], base[2], base[3] for first, second, third\n        int score = 0;\n        int outs = 0;\n        char event[10];\n        \n        while (outs < 3 && scanf(\"%s\", event) == 1) {\n            if (strcmp(event, \"HIT\") == 0) {\n                if (base[3]) {\n                    score++;\n                    base[3] = 0;\n                }\n                if (base[2]) {\n                    base[3] = 1;\n                    base[2] = 0;\n                }\n                if (base[1]) {\n                    base[2] = 1;\n                    base[1] = 0;\n                }\n                base[1] = 1;\n            } else if (strcmp(event, \"HOMERUN\") == 0) {\n                score++; // batter scores\n                if (base[1]) {\n                    score++;\n                    base[1] = 0;\n                }\n                if (base[2]) {\n                    score++;\n                    base[2] = 0;\n                }\n                if (base[3]) {\n                    score++;\n                    base[3] = 0;\n                }\n            } else if (strcmp(event, \"OUT\") == 0) {\n                outs++;\n            }\n        }\n        \n        printf(\"%d\\n\", score);\n    }\n    \n    return 0;\n}\n", "perturbed_sampled": ["#include <stdio.h> #include <string.h> int main() { int n;  for first,  0; char event[10]; while  if  base[3] = 0; } if (base[2]) { base[3] = 1; base[2] = 0; } if (base[1]) { base[2] = 1; base[1]  score++; base[2] = 0; }  = 0; } } else if (strcmp(event,  } }  }"], "perturbed_original": ["#include <stdio.h> #include <string.h> int main(void) { int n; score++; base[i]<extra_id_5>score++; foreach (i<extra_id_6>#include <stdio.h> out++;<extra_id_7>, \"SOFT\" ) {<extra_id_8>;<extra_id_9>- = up<extra_id_10>{ 0;<extra_id_11>(<extra_id_12>= base [ out<extra_id_13>}<extra_id_14>(<extra_id_15>int<extra_id_16>int up {0}; int  score  = 0; out = 0;  event); if (strcmp(event,  (base[i] > 1){ if   } base[i]--; } } } else if (strcmp(event, \"HOMERUN\") == 0){ for (i =  score++; base[i]  } } printf(\"%d\\n\", score); n--; } return 0; }"], "original_ll": -0.845903754234314, "sampled_ll": -0.7388814091682434, "all_perturbed_sampled_ll": [-2.0936319828033447], "all_perturbed_original_ll": [-2.81915283203125], "perturbed_sampled_ll": -2.0936319828033447, "perturbed_original_ll": -2.81915283203125, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.Arrays;\nimport java.util.List;\n\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\tint field = 0;\n\t\tlong scoreCount = 0;\n\t\tint outCount = 0;\n\t\tint finishedGame = 0;\n\t\ttry {\n\t\t\tint gameNumber = br.read();\n\t\t\twhile (finishedGame < gameNumber) {\n\t\t\t\tswitch (br.readLine()) {\n\t\t\t\tcase \"HIT\":\n\t\t\t\t\tif(field==3) {\n\t\t\t\t\t\tscoreCount++;\n\t\t\t\t\t}\n\t\t\t\t\tfield++;\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"OUT\":\n\t\t\t\t\toutCount++;\n\t\t\t\t\tif (outCount == 3) {\n\t\t\t\t\t\tSystem.out.println(scoreCount);\n\t\t\t\t\t\tscoreCount = 0;\n\t\t\t\t\t\toutCount = 0;\n\t\t\t\t\t\tfield = 0;\n\t\t\t\t\t\tfinishedGame++;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"HOMERUN\":\n\t\t\t\t\tscoreCount += 1 + field;\n\t\t\t\t\tfield = 0;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tbr.close();\n\t\t} catch (IOException e) {\n\t\t\te.printStackTrace();\n\t\t}\n\t}\n}", "sampled": "import java.util.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int n = sc.nextInt();\n        sc.nextLine();\n        \n        for (int i = 0; i < n; i++) {\n            int score = 0;\n            int outs = 0;\n            boolean[] bases = new boolean[3]; // 0: first, 1: second, 2: third\n            \n            while (outs < 3) {\n                String event = sc.nextLine().trim();\n                \n                if (event.equals(\"HIT\")) {\n                    if (bases[2]) {\n                        score++;\n                        bases[2] = false;\n                    }\n                    if (bases[1]) {\n                        bases[2] = true;\n                        bases[1] = false;\n                    }\n                    if (bases[0]) {\n                        bases[1] = true;\n                    }\n                    bases[0] = true;\n                } else if (event.equals(\"HOMERUN\")) {\n                    score++; // for the batter\n                    for (int j = 0; j < 3; j++) {\n                        if (bases[j]) {\n                            score++;\n                            bases[j] = false;\n                        }\n                    }\n                } else if (event.equals(\"OUT\")) {\n                    outs++;\n                }\n            }\n            \n            System.out.println(score);\n        }\n        \n        sc.close();\n    }\n}\n", "perturbed_sampled": ["import java.util.*; public class Main { public static void main(String[] args)  Scanner(System.in); int n = sc.nextInt(); sc.nextLine(); for (int i =  0; int  < 3)  if (event.equals(\"HIT\")) { if (bases[2]) { score++; bases[2] =  bases[2]  } if  } else if  the batter  j < 3; j++)  bases[j] =  sc.close(); } }"], "perturbed_original": ["import java.io.BufferedReader; import java.io.IOException; import { try { i<extra_id_5>> 2<extra_id_6>i =<extra_id_7>} //<extra_id_8>. in = i;<extra_id_9>++ ;<extra_id_10>this<extra_id_11>; } }<extra_id_12>e<extra_id_13>. io<extra_id_14>} //if(scoreCount>0<extra_id_15>if(scoreCount ><extra_id_16>j<extra_id_17>; }<extra_id_18>{<extra_id_19>j =<extra_id_20>j = 0<extra_id_21>; } if ( args)  BufferedReader(new InputStreamReader(System.in)); int field = 0; long  =  =  { switch   System.out.println(scoreCount); scoreCount = 0;   + field; field = 0; break; } } br.close(); } catch (IOException e) { e.printStackTrace(); } } }"], "original_ll": -1.0079694986343384, "sampled_ll": -0.781657874584198, "all_perturbed_sampled_ll": [-2.8955233097076416], "all_perturbed_original_ll": [-2.5658469200134277], "perturbed_sampled_ll": -2.8955233097076416, "perturbed_original_ll": -2.5658469200134277, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "def hit(bases):\n    got_point = False\n    if bases[2]:\n        got_point = True\n    bases[0], bases[1], bases[2] = 1, bases[0], bases[1]\n    if got_point:\n        return 1\n    else:\n        return 0\n\ndef homerun(bases):\n    num_runner = bases.count(1)\n    bases[0], bases[1], bases[2] = 0, 0, 0\n    return num_runner + 1\n\nfor i in range(int(raw_input())):\n    bases = [0, 0, 0]\n    out_count = 0\n    points = 0\n    while out_count != 3:\n        event = raw_input()\n        if event == \"HIT\":\n            points += hit(bases)\n        elif event == \"HOMERUN\":\n            points += homerun(bases)\n        else:\n            out_count += 1\n    print points", "sampled": "n = int(input())\nfor _ in range(n):\n    score = 0\n    bases = [False, False, False]  # 1st, 2nd, 3rd base\n    outs = 0\n    \n    while outs < 3:\n        event = input().strip()\n        \n        if event == \"HIT\":\n            # Score runners from 3rd base\n            if bases[2]:\n                score += 1\n            # Advance runners\n            bases[2] = bases[1]\n            bases[1] = bases[0]\n            bases[0] = True\n            \n        elif event == \"HOMERUN\":\n            # Count runners on base\n            runners_on_base = sum(bases)\n            # Score all runners plus batter\n            score += runners_on_base + 1\n            # Clear all bases\n            bases = [False, False, False]\n            \n        elif event == \"OUT\":\n            outs += 1\n    \n    print(score)\n", "perturbed_sampled": [" 0 bases = [False, False,  base outs = 0 while  \"HIT\": #    bases[1] bases[1]  elif  runners on base runners_on_base = sum(bases) #  score += runners_on_base +  bases =  == \"OUT\": outs += 1 print(score)"], "perturbed_original": ["def  bases[0], bases[1],  else: return 0 def homerun(bases):  bases[2]  i in range(int(raw_input())): bases =  event == \"HIT\": points += hit(bases) elif event == \"HOMERUN\": points += homerun(bases) else: out_count += 1 print points"], "original_ll": -1.0798087120056152, "sampled_ll": -1.3496166467666626, "all_perturbed_sampled_ll": [-4.557204723358154], "all_perturbed_original_ll": [-3.209721326828003], "perturbed_sampled_ll": -4.557204723358154, "perturbed_original_ll": -3.209721326828003, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "C[51],c;\n#define min(a,b) ((a)<(b)?(a):(b))\nmain(i){\n\tC[1]=380;\n\tfor(i=2;i<=50;i++){\n\t\tc=9999;\n\t\tif(i>=2)c=min(c,C[i-2]+380);\n\t\tif(i>=3)c=min(c,C[i-3]+550);\n\t\tif(i>=5)c=min(c,C[i-5]+850);\n\t\tif(i>=10)c=min(c,C[i-10]+1520);\n\t\tif(i>=12)c=min(c,C[i-12]+1870);\n\t\tif(i>=15)c=min(c,C[i-15]+2244);\n\t\tC[i]=c;\n\t}\n\tfor(;~scanf(\"%d\",&i);)\n\t\ti&&printf(\"%d\\n\",C[(i+99)/100]);\n}", "sampled": "#include <stdio.h>\n\nint main() {\n    int a;\n    \n    while(scanf(\"%d\", &a) == 1 && a != 0) {\n        int minCost = -1;\n        \n        // Shop A: 200g bags, 380 yen, per 5 bags 20% discount\n        if(a % 200 == 0) {\n            int bags = a / 200;\n            int discountedBags = (bags / 5) * 5;\n            int normalBags = bags % 5;\n            int cost = (int)(discountedBags * 380 * 0.8) + normalBags * 380;\n            if(minCost == -1 || cost < minCost) {\n                minCost = cost;\n            }\n        }\n        \n        // Shop B: 300g bags, 550 yen, per 4 bags 15% discount\n        if(a % 300 == 0) {\n            int bags = a / 300;\n            int discountedBags = (bags / 4) * 4;\n            int normalBags = bags % 4;\n            int cost = (int)(discountedBags * 550 * 0.85) + normalBags * 550;\n            if(minCost == -1 || cost < minCost) {\n                minCost = cost;\n            }\n        }\n        \n        // Shop C: 500g bags, 850 yen, per 3 bags 12% discount\n        if(a % 500 == 0) {\n            int bags = a / 500;\n            int discountedBags = (bags / 3) * 3;\n            int normalBags = bags % 3;\n            int cost = (int)(discountedBags * 850 * 0.88) + normalBags * 850;\n            if(minCost == -1 || cost < minCost) {\n                minCost = cost;\n            }\n        }\n        \n        printf(\"%d\\n\", minCost);\n    }\n    \n    return 0;\n}\n", "perturbed_sampled": [" int a; while(scanf(\"%d\", &a) ==  {  Shop A: 200g bags,  200 == 0) { int bags = a /  int normalBags = bags % 5; int cost = (int)(discountedBags *   }  if(a % 300 ==  a / 300; int discountedBags = (bags  (int)(discountedBags *  * 550;  < minCost)  500g   500 == 0) { int bags =  = (bags  3; int cost = (int)(discountedBags  < minCost) { minCost = cost; } } printf(\"%d\\n\", minCost); } return 0; }"], "perturbed_original": ["C[51],c; #define min(a,b) ((a)<(b)?(a):(b)) main(i){ C[1]=380; for(i=2;i<=50;i++){   i&&printf(\"%d\\n\",C[(i+99)/100]); }"], "original_ll": -1.330197811126709, "sampled_ll": -0.5530591011047363, "all_perturbed_sampled_ll": [-2.5696089267730713], "all_perturbed_original_ll": [-2.6979222297668457], "perturbed_sampled_ll": -2.5696089267730713, "perturbed_original_ll": -2.6979222297668457, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import java.util.*;\n\nclass Main{\n\tpublic static void main(String[] args){\n\t\tScanner sc = new Scanner(System.in);\n\t\tint n = sc.nextInt();\n\t\twhile(true){ \n\t\t\tif(n == 0)break;\n\t\t\tSystem.out.println(min(n));\n\t\t\tn = sc.nextInt();\n\t\t}   \n\t}   \n\tstatic int min(int n){\n\t\tint min = Integer.MAX_VALUE;\n\t\tfor(int c = n/500 ; c >= 0 ; c--){\n\t\t\tfor(int b = (n-c*500)/300 ; b >= 0 ; b--){\n\t\t\t\tif((n-c*500-b*300)%200 == 0){ \n\t\t\t\t\tint a = (n-c*500-b*300)/200;\n\t\t\t\t\tint cost = cost(a, b, c); \n\t\t\t\t\tif(cost < min){\n\t\t\t\t\t\tmin = cost;\n\t\t\t\t\t}   \n\t\t\t\t}   \n\t\t\t}   \n\t\t}   \n\t\treturn min;\n\t}   \n\tstatic int cost(int a, int b, int c){\n\t\treturn (a%5)*380+(a/5)*5*380*8/10+(b%4)*550+(b/4)*4*550*85/100+(c%3)*850+(c/3)*3*850*88/100;\n\t}   \n}", "sampled": "import java.util.Scanner;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        \n        while (true) {\n            int a = sc.nextInt();\n            if (a == 0) break;\n            \n            int minCost = Integer.MAX_VALUE;\n            \n            // Shop A: 200g per bag, 380 yen, 5 bags discount 20%\n            if (a % 200 == 0) {\n                int bags = a / 200;\n                int discountedBags = (bags / 5) * 5;\n                int normalBags = bags % 5;\n                int cost = (int)(discountedBags * 380 * 0.8) + normalBags * 380;\n                minCost = Math.min(minCost, cost);\n            }\n            \n            // Shop B: 300g per bag, 550 yen, 4 bags discount 15%\n            if (a % 300 == 0) {\n                int bags = a / 300;\n                int discountedBags = (bags / 4) * 4;\n                int normalBags = bags % 4;\n                int cost = (int)(discountedBags * 550 * 0.85) + normalBags * 550;\n                minCost = Math.min(minCost, cost);\n            }\n            \n            // Shop C: 500g per bag, 850 yen, 3 bags discount 12%\n            if (a % 500 == 0) {\n                int bags = a / 500;\n                int discountedBags = (bags / 3) * 3;\n                int normalBags = bags % 3;\n                int cost = (int)(discountedBags * 850 * 0.88) + normalBags * 850;\n                minCost = Math.min(minCost, cost);\n            }\n            \n            System.out.println(minCost);\n        }\n        \n        sc.close();\n    }\n}\n", "perturbed_sampled": ["import java.util.Scanner;  { Scanner   = Integer.MAX_VALUE; // Shop A:  == 0) { int bags = a / 200; int discountedBags = (bags / 5)   Math.min(minCost, cost);  per bag, 550 yen, 4 bags discount 15% if (a % 300    * 4; int normalBags = bags %  +  Math.min(minCost, cost); }  bag, 850  bags = a / 500; int discountedBags = (bags / 3) * 3; int  int  * 0.88) + normalBags * 850;  System.out.println(minCost); } sc.close(); } }"], "perturbed_original": ["import java.util.*; class Main{ public static void  == 0)break; System.out.println(min(n));  static  = Integer.MAX_VALUE; for(int   b >= 0 ; b--){ if((n-c*500-b*300)%200 ==  b, c); if(cost < min){  a, int b, int c){ return (a%5)*380+(a/5)*5*380*8/10+(b%4)*550+(b/4)*4*550*85/100+(c%3)*850+(c/3)*3*850*88/100; } }"], "original_ll": -0.9665937423706055, "sampled_ll": -0.5388697981834412, "all_perturbed_sampled_ll": [-3.0521767139434814], "all_perturbed_original_ll": [-2.5365188121795654], "perturbed_sampled_ll": -3.0521767139434814, "perturbed_original_ll": -2.5365188121795654, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "a=[(2,380),(3,550),(5,850),(10,1520),(12,1870),(15,2244)]\ndp=[1<<20]*51\nfor i,j in a:\n    dp[i]=j\n    for k in range(51-i):\n        if dp[k]!=1<<20 and dp[k+i]>dp[k]+j:\n            dp[k+i]=dp[k]+j\nwhile 1:\n    n=int(input())\n    if n==0:break\n    print(dp[n//100])", "sampled": "def calculate_cost(amount, bag_size, unit_price, discount_unit, discount_rate):\n    if amount % bag_size != 0:\n        return float('inf')\n    \n    num_bags = amount // bag_size\n    discounted_bags = (num_bags // discount_unit) * discount_unit\n    regular_bags = num_bags % discount_unit\n    \n    discounted_cost = discounted_bags * unit_price * (1 - discount_rate)\n    regular_cost = regular_bags * unit_price\n    \n    return int(discounted_cost + regular_cost)\n\nwhile True:\n    a = int(input())\n    if a == 0:\n        break\n    \n    # Shop A: 200g, 380 yen, per 5 bags, 20% off\n    cost_a = calculate_cost(a, 200, 380, 5, 0.20)\n    \n    # Shop B: 300g, 550 yen, per 4 bags, 15% off\n    cost_b = calculate_cost(a, 300, 550, 4, 0.15)\n    \n    # Shop C: 500g, 850 yen, per 3 bags, 12% off\n    cost_c = calculate_cost(a, 500, 850, 3, 0.12)\n    \n    print(min(cost_a, cost_b, cost_c))\n", "perturbed_sampled": ["def calculate_cost(amount, bag_size, unit_price,  float('inf')  =  discounted_bags *  regular_cost = regular_bags * unit_price return int(discounted_cost + regular_cost) while True: a = int(input()) if a == 0: break  20% off  5, 0.20) # Shop B: 300g, 550 yen, per 4 bags, 15%  calculate_cost(a, 500,  cost_c))"], "perturbed_original": [" in range(51-i): if  1: n=int(input()) if n==0:break print(dp[n//100])"], "original_ll": -1.6114875078201294, "sampled_ll": -0.9219945073127747, "all_perturbed_sampled_ll": [-3.398372173309326], "all_perturbed_original_ll": [-3.899320363998413], "perturbed_sampled_ll": -3.398372173309326, "perturbed_original_ll": -3.899320363998413, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "#include<stdio.h>\n\nint main(){\n  int i,n,t[3];\n  int data,kari,hakari;\n\n  while(1){\n    scanf(\"%d%d%d\",&t[0],&t[1],&t[2]);\n    if(t[0] == 0 || t[1] == 0 || t[2] == 0)\n      break;\n    scanf(\"%d\",&n);\n    if(t[0] >= t[2]){\n      t[0] = t[2];\n       t[2] = -1;\n      }\n    if(t[1] >= t[2]&&t[2] != -1)\n      t[1] = t[2];\n    hakari = t[0] * t[0] + t[1] *t[1];\n    for(i = 0; i < n; i++){\n      scanf(\"%d\",&data);\n      data = data * 2;\n      data = data * data;\n      if(hakari < data)\n\tprintf(\"OK\\n\");\n      else \n\tprintf(\"NA\\n\");\n    }\n  }\n  return 0;\n}", "sampled": "#include <stdio.h>\n#include <math.h>\n\nint main() {\n    int A, B, C;\n    \n    while(1) {\n        scanf(\"%d %d %d\", &A, &B, &C);\n        \n        if(A == 0 && B == 0 && C == 0) break;\n        \n        int n;\n        scanf(\"%d\", &n);\n        \n        // Calculate the minimum diagonal of any face\n        // The cheese can pass through a circular hole if the diagonal of the smallest rectangular face\n        // can fit through the circle\n        double diag1 = sqrt(A * A + B * B);\n        double diag2 = sqrt(B * B + C * C);\n        double diag3 = sqrt(A * A + C * C);\n        \n        double min_diag = diag1;\n        if(diag2 < min_diag) min_diag = diag2;\n        if(diag3 < min_diag) min_diag = diag3;\n        \n        for(int i = 0; i < n; i++) {\n            int R;\n            scanf(\"%d\", &R);\n            \n            // The cheese can pass if the diameter of the hole is greater than the minimum diagonal\n            if(2 * R > min_diag) {\n                printf(\"OK\\n\");\n            } else {\n                printf(\"NA\\n\");\n            }\n        }\n    }\n    \n    return 0;\n}\n", "perturbed_sampled": [" main() { int A, B,  %d\", &A,  && B == 0 &&  Calculate the  // The cheese can pass  smallest rectangular face //  double diag1  B  sqrt(B   *  double min_diag = diag1; if(diag2 < min_diag) min_diag = diag2;  i++) { int R; scanf(\"%d\", &R);   hole  >  { printf(\"NA\\n\"); } } } return 0; }"], "perturbed_original": [" int data,kari,hakari; while(1){  t[2]  >= t[2]){ t[0] = t[2]; t[2] = -1;  -1) t[1] = t[2]; hakari = t[0]  data  = data * data; if(hakari < data)  return 0; }"], "original_ll": -1.136303186416626, "sampled_ll": -0.9435007572174072, "all_perturbed_sampled_ll": [-3.859697103500366], "all_perturbed_original_ll": [-2.749218463897705], "perturbed_sampled_ll": -3.859697103500366, "perturbed_original_ll": -2.749218463897705, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import java.util.Scanner;\nimport java.util.Arrays;\n\nclass Main\n{\n\tpublic static void main(String args[])\n\t{\n\t\tScanner sc = new Scanner(System.in);\n\t\t\n\t\twhile (true)\n\t\t{\n\t\t\tint a[] = new int[3];\n\t\t\tfor (int i = 0; i < 3; i++)\n\t\t\t\ta[i] = sc.nextInt();\n\t\t\tif (a[0] == 0 && a[1] == 0 && a[2] == 0) break;\n\t\t\t\n\t\t\t//Arrays.sort(a);\n\t\t\tint minR = a[0] * a[0] + a[2] + a[2];\n\t\t\t\n\t\t\tint n = sc.nextInt();\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t{\n\t\t\t\tint r = sc.nextInt() * 2;\n\t\t\t\tif (minR < r * r) System.out.println(\"OK\");\n\t\t\t\telse System.out.println(\"NA\");\n\t\t\t}\n\t\t}\n\t}\n}", "sampled": "import java.util.Scanner;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        \n        while (true) {\n            int A = sc.nextInt();\n            int B = sc.nextInt();\n            int C = sc.nextInt();\n            \n            if (A == 0 && B == 0 && C == 0) {\n                break;\n            }\n            \n            // Find the minimum diagonal among all three faces\n            // The cheese can pass through if oriented diagonally through a face\n            double diag1 = Math.sqrt(A * A + B * B);\n            double diag2 = Math.sqrt(B * B + C * C);\n            double diag3 = Math.sqrt(A * A + C * C);\n            \n            double minDiag = Math.min(diag1, Math.min(diag2, diag3));\n            \n            int n = sc.nextInt();\n            \n            for (int i = 0; i < n; i++) {\n                int R = sc.nextInt();\n                \n                if (2 * R > minDiag) {\n                    System.out.println(\"OK\");\n                } else {\n                    System.out.println(\"NA\");\n                }\n            }\n        }\n        \n        sc.close();\n    }\n}\n", "perturbed_sampled": [" main(String[]  new Scanner(System.in); while (true) { int   0 && B == 0 && C == 0) { break;  diagonal among  if oriented diagonally through a face  A +  +  double minDiag = Math.min(diag1,   0; i < n;  sc.nextInt(); if (2 * R > minDiag) { System.out.println(\"OK\"); } else  sc.close(); } }"], "perturbed_original": [" Main  args[]) { Scanner  (true) { int a[]  <  if (a[0]  0   * a[0] + a[2]  sc.nextInt(); for  < n; i++) { int r = sc.nextInt() * 2; if   } }"], "original_ll": -0.8852454423904419, "sampled_ll": -0.8747538328170776, "all_perturbed_sampled_ll": [-3.557344436645508], "all_perturbed_original_ll": [-3.8282527923583984], "perturbed_sampled_ll": -3.557344436645508, "perturbed_original_ll": -3.8282527923583984, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "while 1:\n a,b,_=sorted(map(int,input().split()))\n if a==0:break\n for _ in[0]*int(input()):print(\"OK\"if(int(input())*2)**2>a*a+b*b else\"NA\")\n", "sampled": "import math\n\nwhile True:\n    line = input().split()\n    A, B, C = int(line[0]), int(line[1]), int(line[2])\n    \n    if A == 0 and B == 0 and C == 0:\n        break\n    \n    # The smallest diagonal that can fit through a circle of radius R\n    # is when we orient the cheese optimally through the hole.\n    # The cheese can pass through if the smallest cross-sectional diagonal\n    # fits in the circle of radius R.\n    \n    # For a parallelepiped with dimensions A, B, C, the smallest\n    # cross-sectional diagonal occurs when we look at the rectangular\n    # faces. The diagonals of the three faces are:\n    # sqrt(A^2 + B^2), sqrt(B^2 + C^2), sqrt(A^2 + C^2)\n    \n    # The smallest of these is what we need to fit through the hole\n    # (divided by 2 for radius)\n    \n    sides = [A, B, C]\n    sides.sort()\n    \n    # The minimum diagonal is between the two smallest sides\n    min_diagonal = math.sqrt(sides[0]**2 + sides[1]**2)\n    min_radius_needed = min_diagonal / 2\n    \n    n = int(input())\n    \n    for _ in range(n):\n        R = int(input())\n        if R > min_radius_needed:\n            print(\"OK\")\n        else:\n            print(\"NA\")\n", "perturbed_sampled": ["import math while True: line = input().split() A,  int(line[2])  B    optimally  the circle of radius R. # For a parallelepiped with dimensions A,  we look at the  of the three  B^2),  C^2) # The  we need to fit through the hole # (divided by 2 for radius) sides =  + sides[1]**2)  n = int(input()) for  int(input()) if R > min_radius_needed: print(\"OK\") else: print(\"NA\")"], "perturbed_original": ["while  _ in[0]*int(input()):print(\"OK\"if(int(input())*2)**2>a*a+b*b else\"NA\")"], "original_ll": -2.9978604316711426, "sampled_ll": -1.3626108169555664, "all_perturbed_sampled_ll": [-3.813082695007324], "all_perturbed_original_ll": [-3.869720458984375], "perturbed_sampled_ll": -3.813082695007324, "perturbed_original_ll": -3.869720458984375, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "#include <stdio.h>\n\nint expr(char **s);\n\nint number(char **s) {\n  int val = 0;\n  while ('0' <= **s && **s <= '9') {\n    val = val * 10 + **s - '0';\n    (*s)++;\n  }\n  return val;\n}\n\nint factor(char **s) {\n  if (**s == '(') {\n    (*s)++;\n    int val = expr(s);\n    (*s)++;\n    return val;\n  }\n  return number(s);\n}\n\nint term(char **s) {\n  int val = factor(s);\n  while (1) {\n    if (**s == '*') {\n      (*s)++;\n      val *= factor(s);\n    } else if (**s == '/') {\n      (*s)++;\n      val /= factor(s);\n    } else {\n      break;\n    }\n  }\n  return val;\n}\n\nint expr(char **s) {\n  int val = term(s);\n  while (1) {\n    if (**s == '+') {\n      (*s)++;\n      val += term(s);\n    } else if (**s == '-') {\n      (*s)++;\n      val -= term(s);\n    } else {\n      break;\n    }\n  }\n  return val;\n}\n\nint main() {\n  int n;\n  scanf(\"%d\", &n);\n  char s[101];\n  while (n--) {\n    scanf(\"%s\", s);\n    char *p = s;\n    printf(\"%d\\n\", expr(&p));\n  }\n}", "sampled": "#include <stdio.h>\n#include <string.h>\n#include <ctype.h>\n\nchar expr[105];\nint pos;\n\nlong long parse_expr();\nlong long parse_term();\nlong long parse_factor();\n\nlong long parse_number() {\n    long long num = 0;\n    int sign = 1;\n    \n    if (expr[pos] == '-') {\n        sign = -1;\n        pos++;\n    } else if (expr[pos] == '+') {\n        pos++;\n    }\n    \n    while (isdigit(expr[pos])) {\n        num = num * 10 + (expr[pos] - '0');\n        pos++;\n    }\n    \n    return sign * num;\n}\n\nlong long parse_factor() {\n    if (expr[pos] == '(') {\n        pos++; // skip '('\n        long long result = parse_expr();\n        pos++; // skip ')'\n        return result;\n    } else {\n        return parse_number();\n    }\n}\n\nlong long parse_term() {\n    long long result = parse_factor();\n    \n    while (expr[pos] == '*' || expr[pos] == '/') {\n        char op = expr[pos];\n        pos++;\n        long long right = parse_factor();\n        if (op == '*') {\n            result = result * right;\n        } else {\n            result = result / right;\n        }\n    }\n    \n    return result;\n}\n\nlong long parse_expr() {\n    long long result = parse_term();\n    \n    while (expr[pos] == '+' || expr[pos] == '-') {\n        char op = expr[pos];\n        pos++;\n        long long right = parse_term();\n        if (op == '+') {\n            result = result + right;\n        } else {\n            result = result - right;\n        }\n    }\n    \n    return result;\n}\n\nint main() {\n    int n;\n    scanf(\"%d\", &n);\n    getchar();\n    \n    while (n--) {\n        fgets(expr, 105, stdin);\n        pos = 0;\n        long long result = parse_expr();\n        printf(\"%lld\\n\", result);\n    }\n    \n    return 0;\n}\n", "perturbed_sampled": ["#include <stdio.h>  parse_term();  num =  { sign = -1; pos++; } else if  num =  return  long parse_factor()  { pos++; // skip  parse_expr(); pos++; //   } long long parse_term() { long long  ==  { char op = expr[pos];  '*') { result = result  right; } } return result; }  long  op = expr[pos]; pos++; long  (op ==  + right; } else { result  int main() { int n; scanf(\"%d\", &n); getchar();  stdin); pos = 0; long long result =  0; }"], "perturbed_original": ["#include <stdio.h>  = 0; while   if (**s == '(') { (*s)++; int val = expr(s);  number(s); } int term(char **s) { int val = factor(s);  ==   == '/') { (*s)++; val /= factor(s); } else { break; } } return  if (**s == '+') { (*s)++; val += term(s); } else if (**s == '-') {  else { break; }  }"], "original_ll": -0.4484841823577881, "sampled_ll": -0.33498165011405945, "all_perturbed_sampled_ll": [-3.3245489597320557], "all_perturbed_original_ll": [-2.5279595851898193], "perturbed_sampled_ll": -3.3245489597320557, "perturbed_original_ll": -2.5279595851898193, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import java.util.Scanner;\n\npublic class Main {\n\tstatic String str;\n\tstatic int pos;\n\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint n = sc.nextInt();\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tstr = sc.next();\n\t\t\tpos = 0;\n\t\t\tSystem.out.println(expression());\n\t\t}\n\t\tsc.close();\n\t}\n\n\tstatic int expression() {\n\t\tint ret = term();\n\t\twhile (str.charAt(pos) != '=') {\n\t\t\tif (str.charAt(pos) == '+') {\n\t\t\t\tpos++;\n\t\t\t\tret += term();\n\t\t\t} else if (str.charAt(pos) == '-') {\n\t\t\t\tpos++;\n\t\t\t\tret -= term();\n\t\t\t} else {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\treturn ret;\n\t}\n\n\tstatic int term() {\n\t\tint ret = factor();\n\t\twhile (str.charAt(pos) != '=') {\n\t\t\tif (str.charAt(pos) == '*') {\n\t\t\t\tpos++;\n\t\t\t\tret *= factor();\n\t\t\t} else if (str.charAt(pos) == '/') {\n\t\t\t\tpos++;\n\t\t\t\tret /= factor();\n\t\t\t} else {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\treturn ret;\n\t}\n\n\tstatic int factor() {\n\t\tif (str.charAt(pos) == '(') {\n\t\t\tpos++;\n\t\t\tint temp = expression();\n\t\t\tpos++;\n\t\t\treturn temp;\n\t\t} else {\n\t\t\treturn number();\n\t\t}\n\t}\n\n\tstatic int number() {\n\t\tint ret = 0;\n\t\twhile (Character.isDigit(str.charAt(pos))) {\n\t\t\tret *= 10;\n\t\t\tret += str.charAt(pos) - '0';\n\t\t\tpos++;\n\t\t}\n\t\treturn ret;\n\t}\n\n}", "sampled": "import java.util.*;\n\npublic class Main {\n    static String expr;\n    static int pos;\n    \n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int n = sc.nextInt();\n        sc.nextLine();\n        \n        for (int i = 0; i < n; i++) {\n            expr = sc.nextLine().trim();\n            pos = 0;\n            System.out.println(parseExpression());\n        }\n        sc.close();\n    }\n    \n    static long parseExpression() {\n        long result = parseTerm();\n        \n        while (pos < expr.length() && (expr.charAt(pos) == '+' || expr.charAt(pos) == '-')) {\n            char op = expr.charAt(pos);\n            pos++;\n            long term = parseTerm();\n            if (op == '+') {\n                result += term;\n            } else {\n                result -= term;\n            }\n        }\n        \n        return result;\n    }\n    \n    static long parseTerm() {\n        long result = parseFactor();\n        \n        while (pos < expr.length() && (expr.charAt(pos) == '*' || expr.charAt(pos) == '/')) {\n            char op = expr.charAt(pos);\n            pos++;\n            long factor = parseFactor();\n            if (op == '*') {\n                result *= factor;\n            } else {\n                result /= factor;\n            }\n        }\n        \n        return result;\n    }\n    \n    static long parseFactor() {\n        if (expr.charAt(pos) == '(') {\n            pos++;\n            long result = parseExpression();\n            pos++;\n            return result;\n        }\n        \n        boolean negative = false;\n        if (expr.charAt(pos) == '-') {\n            negative = true;\n            pos++;\n        } else if (expr.charAt(pos) == '+') {\n            pos++;\n        }\n        \n        long num = 0;\n        while (pos < expr.length() && Character.isDigit(expr.charAt(pos))) {\n            num = num * 10 + (expr.charAt(pos) - '0');\n            pos++;\n        }\n        \n        return negative ? -num : num;\n    }\n}\n", "perturbed_sampled": ["import  int pos; public static void main(String[] args) { Scanner sc  =   i++) {  0; System.out.println(parseExpression()); } sc.close(); } static long parseExpression() { long  < expr.length() && (expr.charAt(pos)  '-')) { char  (op  term; } else {   =   pos++; long factor =  { result *= factor; } else { result /= factor; } }  parseFactor() { if  if (expr.charAt(pos)  if (expr.charAt(pos) == '+') { pos++; } long  * 10 + (expr.charAt(pos) - '0');  -num : num; } }"], "perturbed_original": ["import java.util.Scanner;  String str; static int pos; public static void  n = sc.nextInt(); for (int i = 0; i < n; i++) {  } static int expression() { int ret = term();   pos++; ret += term(); } else   '*') {  '/')  } }   temp = expression(); pos++; return temp;  } } static int number() { int ret = 0; while (Character.isDigit(str.charAt(pos))) { ret *= 10; ret  }"], "original_ll": -0.4352850317955017, "sampled_ll": -0.3394372761249542, "all_perturbed_sampled_ll": [-3.0186760425567627], "all_perturbed_original_ll": [-2.5488924980163574], "perturbed_sampled_ll": -3.0186760425567627, "perturbed_original_ll": -2.5488924980163574, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "def String2List(s):\n    L = []\n    flag = True\n    l = len(s)\n    for i in range(l):\n        if s[i].isdigit() and flag:\n            t = \"\"\n            j = 0\n            while s[i+j].isdigit():\n                t += s[i+j]\n                if i+j == l-1:\n                    break\n                j += 1\n            L.append(t)\n            flag = False\n\n        elif not s[i].isdigit():\n            L.append(s[i])\n            flag = True\n\n    return L\n\n\ndef RPN_list(L):\n    S, L2 = [], []\n    table = {\"*\": 1, \"/\": 1, \"+\": 0, \"-\": 0, \"(\": -1, \")\": -1}\n    rpn = \"\"\n    for i in L:\n        if i.isdigit():\n            L2.append(i)\n        elif i == \"(\":\n            S.append(i)\n        elif i == \")\":\n            while S[-1] != \"(\":\n                L2.append(S.pop())\n            S.pop()\n        else:\n            if len(S) != 0 and (table[S[-1]] >= table[i]):\n                L2.append(S.pop())            \n            S.append(i)\n\n    while len(S) != 0:\n        L2.append(S.pop())\n\n    return L2\n\n\ndef RPN_cul(L):\n    St = []\n\n    for i in L:\n        if i == '+':\n            St.append(int(St.pop()) + int(St.pop()))\n        elif i == '-':\n            St.append(-int(St.pop()) + int(St.pop()))\n        elif i == '*':\n            St.append(int(St.pop()) * int(St.pop()))\n        elif i == '/':\n            a = int(St.pop())\n            b = float(St.pop())\n            r = b/a\n            if b < 0 and b % a != 0:\n                r += 1\n            St.append(r)\n        else:\n            St.append(i)\n\n    return St[0]\n\n\nN = int(raw_input())\n\nfor i in range(N):\n    s = raw_input()\n    L = String2List(s[:-1])\n    L = RPN_list(L)\n    print int(RPN_cul(L))", "sampled": "def evaluate(expr):\n    expr = expr.strip().rstrip('=')\n    \n    def parse_number(s, i):\n        j = i\n        if j < len(s) and s[j] in '+-':\n            j += 1\n        while j < len(s) and s[j].isdigit():\n            j += 1\n        return int(s[i:j]), j\n    \n    def parse_factor(s, i):\n        if s[i] == '(':\n            val, j = parse_expr(s, i + 1)\n            return val, j + 1\n        else:\n            return parse_number(s, i)\n    \n    def parse_term(s, i):\n        left, i = parse_factor(s, i)\n        while i < len(s) and s[i] in '*/':\n            op = s[i]\n            right, i = parse_factor(s, i + 1)\n            if op == '*':\n                left = left * right\n            else:\n                left = int(left / right)\n        return left, i\n    \n    def parse_expr(s, i):\n        left, i = parse_term(s, i)\n        while i < len(s) and s[i] in '+-' and (i == 0 or s[i-1] not in '(+*-/'):\n            op = s[i]\n            right, i = parse_term(s, i + 1)\n            if op == '+':\n                left = left + right\n            else:\n                left = left - right\n        return left, i\n    \n    result, _ = parse_expr(expr, 0)\n    return result\n\nn = int(input())\nfor _ in range(n):\n    expr = input()\n    print(evaluate(expr))\n", "perturbed_sampled": ["def evaluate(expr): expr = expr.strip().rstrip('=') def =<extra_id_12>0: op<extra_id_13>+= op n =<extra_id_14>+_5) parse_factor(expr,<extra_id_15>isinstance(expr,<extra_id_16>) int=expr<extra_id_17>val<extra_id_18>+= 1) if<extra_id_19>) result +=<extra_id_20>(<extra_id_21>+ ( op and  +=  parse_factor(s, i): if s[i] == '(': val, j = parse_expr(s, i + 1)   '*': left = left * right else: left =  i) while i < len(s) and s[i]  0  op =  i + 1)  else: left = left - right return left, i result, _  n = int(input()) for _ in range(n): expr = input() print(evaluate(expr))"], "perturbed_original": ["def  =   s[i+j] if i+j ==  elif  RPN_list(L): S, L2  \"+\": 0, \"-\": 0,  = \"\" for i in L: if i.isdigit(): L2.append(i) elif i ==  \"(\":  != 0 and (table[S[-1]]  len(S) !=  for i  '+': St.append(int(St.pop()) + int(St.pop())) elif i == '-': St.append(-int(St.pop()) + int(St.pop()))   < 0 and  else: St.append(i) return St[0] N = int(raw_input()) for i in range(N): s = raw_input() L = String2List(s[:-1]) L = RPN_list(L) print int(RPN_cul(L))"], "original_ll": -0.824628472328186, "sampled_ll": -0.6011657118797302, "all_perturbed_sampled_ll": [-2.86358642578125], "all_perturbed_original_ll": [-2.8486318588256836], "perturbed_sampled_ll": -2.86358642578125, "perturbed_original_ll": -2.8486318588256836, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "#include <stdio.h>\n#include <string.h>\n#include <math.h>\n\n#define DIGIT (pow(10, (strlen(num) - 1 -j)))\n\nint solved(char num[100], int i){\n  int s = 0, j;\n  for(j = 0;j < strlen(num);j++){\n    if(num[j] == 'X')\n      s += i * DIGIT;\n    else \n      s += (num[j] - '0') * DIGIT;\n  }\n  return s;\n}\n\nint main(){\n  int a, b, c, i, j;\n  char calc[100], *f, *s, *ans;\n  while(scanf(\"%s\", calc) != EOF){\n    f = strtok(calc, \"+\");\n    s = strtok(NULL, \"=\");\n    ans = strtok(NULL, \",\");\n    \n    for(i = 0;i < 10;i++)\n      if(solved(f, i) + solved(s, i) == solved(ans, i)){\n\tprintf(\"%d\\n\", i);\n\tbreak;\n      }\n    if(i > 9)\n      puts(\"NA\");\n  }\n  return 0;\n}", "sampled": "#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n\nint hasLeadingZero(char *str) {\n    if (strlen(str) > 1 && str[0] == '0') {\n        return 1;\n    }\n    return 0;\n}\n\nint checkEquation(char *left1, char *left2, char *right) {\n    if (hasLeadingZero(left1) || hasLeadingZero(left2) || hasLeadingZero(right)) {\n        return 0;\n    }\n    \n    long long num1 = atoll(left1);\n    long long num2 = atoll(left2);\n    long long sum = atoll(right);\n    \n    return (num1 + num2 == sum);\n}\n\nvoid replaceX(char *str, char digit, char *result) {\n    int i;\n    for (i = 0; str[i]; i++) {\n        if (str[i] == 'X') {\n            result[i] = digit;\n        } else {\n            result[i] = str[i];\n        }\n    }\n    result[i] = '\\0';\n}\n\nint main() {\n    char input[256];\n    \n    while (fgets(input, sizeof(input), stdin)) {\n        input[strcspn(input, \"\\n\")] = 0;\n        \n        char *plus = strchr(input, '+');\n        char *equal = strchr(input, '=');\n        \n        if (!plus || !equal) continue;\n        \n        char left1[128], left2[128], right[128];\n        \n        int len1 = plus - input;\n        int len2 = equal - plus - 1;\n        int len3 = strlen(equal + 1);\n        \n        strncpy(left1, input, len1);\n        left1[len1] = '\\0';\n        \n        strncpy(left2, plus + 1, len2);\n        left2[len2] = '\\0';\n        \n        strcpy(right, equal + 1);\n        \n        int found = -1;\n        int count = 0;\n        \n        for (int digit = 0; digit <= 9; digit++) {\n            char temp1[128], temp2[128], temp3[128];\n            char digitChar = '0' + digit;\n            \n            replaceX(left1, digitChar, temp1);\n            replaceX(left2, digitChar, temp2);\n            replaceX(right, digitChar, temp3);\n            \n            if (checkEquation(temp1, temp2, temp3)) {\n                found = digit;\n                count++;\n            }\n        }\n        \n        if (count == 1) {\n            printf(\"%d\\n\", found);\n        } else {\n            printf(\"NA\\n\");\n        }\n    }\n    \n    return 0;\n}\n", "perturbed_sampled": ["#include <stdio.h> #include  >  { return 1; } return 0; } int checkEquation(char *left1, char *left2, char *right) { if (hasLeadingZero(left1) || hasLeadingZero(left2)  } long long num1 = atoll(left1); long long num2 = atoll(left2); long long sum  num2  *str, char  result[i] = '\\0'; } int main() { char  0; char *plus = strchr(input, '+');  continue; char left1[128], left2[128],  - input; int len2 = equal - plus -  strncpy(left2, plus +  strcpy(right, equal  0; for (int digit  digit++)   temp2, temp3)) { found  { printf(\"%d\\n\", found);  } return 0; }"], "perturbed_original": ["#include <stdio.h> #include <string.h> s int solved(char num[100], int <extra_id_2>f<extra_id_3>(<extra_id_4>s =<extra_id_5>f = f<extra_id_6>s) ==<extra_id_7>= ! (<extra_id_8>)<extra_id_9>= 0; break ;<extra_id_10>} if (i<extra_id_11>== 0; } }<extra_id_12><<extra_id_13>{ return n(f); }<extra_id_14>strtok(NULL,<extra_id_15>== 0; } if(i==0)<extra_id_16>{ return k<extra_id_17>.<extra_id_18>} if(i=i%21, i<extra_id_19>s<extra_id_20>, \" j; for(j = 0;j < strlen(num);j++){ if(num[j] ==  DIGIT; else  s; } int  *f,  EOF){ f  strtok(NULL, \"=\");  = 0;i <  i) ==  } if(i  0; }"], "original_ll": -1.224336862564087, "sampled_ll": -0.578223466873169, "all_perturbed_sampled_ll": [-2.6473257541656494], "all_perturbed_original_ll": [-2.8125734329223633], "perturbed_sampled_ll": -2.6473257541656494, "perturbed_original_ll": -2.8125734329223633, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import java.util.*;\n\npublic class Main{\n    Scanner in = new Scanner(System.in);\n\n    void solve(){\n        String s;\n        while(in.hasNextLine()){\n            s = in.nextLine();\n            calc(s);\n        }\n    }\n    void calc(String str){\n        String a = str.substring(0, str.indexOf('+'));\n        String b = str.substring(str.indexOf('+') + 1, str.indexOf('='));\n        String c = str.substring(str.indexOf('=') + 1);\n        for(int i = 0; i < 10; i++){\n            String left = sum(a, b, i);\n            String right = c.replace(\"X\", String.valueOf(i));\n            if(left.equals(right)){\n                System.out.println(i);\n                return;\n            }\n        }\n        System.out.println(\"NA\");\n    }\n\n    String sum(String a, String b, int rep){\n        StringBuilder ans  = new StringBuilder();\n        a = new StringBuilder(a.replace(\"X\", String.valueOf(rep))).reverse().toString();\n        b = new StringBuilder(b.replace(\"X\", String.valueOf(rep))).reverse().toString();\n\n        int t = 0;\n        for(int i = 0; i < Math.max(a.length(), b.length()); i++){\n            int x = i < a.length() ? a.charAt(i) - '0' : 0;\n            int y = i < b.length() ? b.charAt(i) - '0' : 0;\n            ans.append(String.valueOf((x + y + t) % 10));\n            t = (x + y + t) / 10;\n        }\n\n        if(t != 0){\n            ans.append(String.valueOf(t));\n        }\n\n        return ans.reverse().toString();\n    }\n    \n    public static void main(String[] args){\n        new Main().solve();    \n    }\n}", "sampled": "import java.util.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        \n        while (sc.hasNextLine()) {\n            String line = sc.nextLine().trim();\n            if (line.isEmpty()) break;\n            \n            String result = solve(line);\n            System.out.println(result);\n        }\n        sc.close();\n    }\n    \n    static String solve(String equation) {\n        String[] parts = equation.split(\"=\");\n        String leftSide = parts[0];\n        String rightSide = parts[1];\n        \n        String[] addends = leftSide.split(\"\\\\+\");\n        String num1Pattern = addends[0];\n        String num2Pattern = addends[1];\n        String sumPattern = rightSide;\n        \n        int validDigit = -1;\n        int validCount = 0;\n        \n        for (int x = 0; x <= 9; x++) {\n            String num1Str = num1Pattern.replace('X', (char)('0' + x));\n            String num2Str = num2Pattern.replace('X', (char)('0' + x));\n            String sumStr = sumPattern.replace('X', (char)('0' + x));\n            \n            // Check for leading zeros\n            if (num1Str.length() > 1 && num1Str.charAt(0) == '0') continue;\n            if (num2Str.length() > 1 && num2Str.charAt(0) == '0') continue;\n            if (sumStr.length() > 1 && sumStr.charAt(0) == '0') continue;\n            \n            try {\n                long num1 = Long.parseLong(num1Str);\n                long num2 = Long.parseLong(num2Str);\n                long sum = Long.parseLong(sumStr);\n                \n                if (num1 + num2 == sum) {\n                    validDigit = x;\n                    validCount++;\n                }\n            } catch (NumberFormatException e) {\n                // Skip invalid numbers\n            }\n        }\n        \n        if (validCount == 1) {\n            return String.valueOf(validDigit);\n        } else {\n            return \"NA\";\n        }\n    }\n}\n", "perturbed_sampled": ["import java.util.*; public class Main {   String  break;  String solve(String equation)  String rightSide = parts[1]; String[] addends = leftSide.split(\"\\\\+\");  num2Pattern = addends[1]; String sumPattern = rightSide; int validDigit = -1; int  x = 0; x <= 9; x++)  (char)('0' + x)); String num2Str   (num1Str.length() > 1 && num1Str.charAt(0) ==  '0') continue; if (sumStr.length() >  num1 = Long.parseLong(num1Str); long  + num2 ==  validCount++; } } catch  invalid numbers } }  } }"], "perturbed_original": [" Scanner in =  in.nextLine(); calc(s); }  a  =  c  i   System.out.println(\"NA\"); } String sum(String a, String b, int rep){ StringBuilder ans = new StringBuilder(); a = new StringBuilder(a.replace(\"X\", String.valueOf(rep))).reverse().toString(); b = new  0; i < Math.max(a.length(),  i  y = i < b.length() ? b.charAt(i)  + y + t) % 10)); t =  != 0){  public static  } }"], "original_ll": -0.6696752309799194, "sampled_ll": -0.5826807618141174, "all_perturbed_sampled_ll": [-3.1629486083984375], "all_perturbed_original_ll": [-3.4493467807769775], "perturbed_sampled_ll": -3.1629486083984375, "perturbed_original_ll": -3.4493467807769775, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "while True:\n    try:\n        string = raw_input()\n    except EOFError:\n        break\n    for i in range(10):\n        translated = string.replace(\"X\",str(i))\n        left,right = translated.split(\"=\")\n        first,second = left.split(\"+\")\n        if i == 0 and any((first[0]==\"0\",second[0]==\"0\",right[0]==\"0\")):\n            continue\n        elif int(first) + int(second) == int(right):\n            print i\n            break\n    else:\n        print \"NA\"", "sampled": "import sys\n\ndef solve(equation):\n    parts = equation.split('=')\n    left_parts = parts[0].split('+')\n    num1 = left_parts[0]\n    num2 = left_parts[1]\n    result = parts[1]\n    \n    for digit in range(10):\n        digit_str = str(digit)\n        \n        # Replace X with the digit\n        n1 = num1.replace('X', digit_str)\n        n2 = num2.replace('X', digit_str)\n        res = result.replace('X', digit_str)\n        \n        # Check for leading zeros (except for single digit numbers)\n        if len(n1) > 1 and n1[0] == '0':\n            continue\n        if len(n2) > 1 and n2[0] == '0':\n            continue\n        if len(res) > 1 and res[0] == '0':\n            continue\n        \n        # Check if the equation holds\n        try:\n            if int(n1) + int(n2) == int(res):\n                return digit_str\n        except:\n            continue\n    \n    return \"NA\"\n\nfor line in sys.stdin:\n    line = line.strip()\n    if line:\n        print(solve(line))\n", "perturbed_sampled": ["import sys def solve(equation): parts =   digit in range(10): digit_str = str(digit) # Replace X with the digit n1 =  digit_str) #  for  == '0':  and n2[0] == '0': continue if len(res)  int(n2) == int(res): return digit_str except: continue return  line: print(solve(line))"], "perturbed_original": ["while  = string.replace(\"X\",str(i)) left,right = translated.split(\"=\") first,second = left.split(\"+\") if i ==  int(right): print i break else: print \"NA\""], "original_ll": -1.5506529808044434, "sampled_ll": -0.8043312430381775, "all_perturbed_sampled_ll": [-3.567927122116089], "all_perturbed_original_ll": [-4.142269611358643], "perturbed_sampled_ll": -3.567927122116089, "perturbed_original_ll": -4.142269611358643, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n\nint i,stk,x[3];\nchar tex[1000000],code[1000000];\nchar encode[64][6]={\n\"11010\",\n\"\",\n\"\",\n\"\",\n\"\",\n\"\",\n\"\",\n\"11110\",\n\"\",\n\"\",\n\"\",\n\"\",\n\"11100\",\n\"11101\",\n\"11011\",\n\"\",\n\"\",\n\"\",\n\"\",\n\"\",\n\"\",\n\"\",\n\"\",\n\"\",\n\"\",\n\"\",\n\"\",\n\"\",\n\"\",\n\"\",\n\"\",\n\"11111\",\n\"\",\n\"00000\",\n\"00001\",\n\"00010\",\n\"00011\",\n\"00100\",\n\"00101\",\n\"00110\",\n\"00111\",\n\"01000\",\n\"01001\",\n\"01010\",\n\"01011\",\n\"01100\",\n\"01101\",\n\"01110\",\n\"01111\",\n\"10000\",\n\"10001\",\n\"10010\",\n\"10011\",\n\"10100\",\n\"10101\",\n\"10110\",\n\"10111\",\n\"11000\",\n\"11001\",\n\"\",\n\"\",\n\"\",\n\"\",\n\"\"}\n,decode[100000000];\n\nint main(){\n\tdecode[212]=' ';\n\tdecode[111111]='\\'';\n\tdecode[111122]=',';\n\tdecode[21121112]='-';\n\tdecode[121112]='.';\n\tdecode[111112]='?';\n\tdecode[211212]='A';\n\tdecode[21122121]='B';\n\tdecode[1212]='C';\n\tdecode[1112]='D';\n\tdecode[221]='E';\n\tdecode[12112]='F';\n\tdecode[21122122]='G';\n\tdecode[121111]='H';\n\tdecode[1222]='I';\n\tdecode[21122111]='J';\n\tdecode[1221]='K';\n\tdecode[11211]='L';\n\tdecode[21122112]='M';\n\tdecode[21122221]='N';\n\tdecode[11212]='O';\n\tdecode[222]='P';\n\tdecode[21122222]='Q';\n\tdecode[2111]='R';\n\tdecode[11221]='S';\n\tdecode[11222]='T';\n\tdecode[21122211]='U';\n\tdecode[21122212]='V';\n\tdecode[111121]='W';\n\tdecode[21121121]='X';\n\tdecode[21121122]='Y';\n\tdecode[21121111]='Z';\n\n\twhile(fgets(tex,900000,stdin)!=NULL){\n\t\tstrcpy(code,\"\");\n\t\tfor(i=0;i<strlen(tex);i++){\n\t\t\tstrcat(code,encode[tex[i]-' ']);\n\t\t}\n\t\tstk=0;\n\t\tfor(i=0;i<strlen(code);i++){\n\t\t\tstk=stk*10+code[i]-'0'+1;\n\t\t\tif(decode[stk]>0){\n\t\t\t\tprintf(\"%c\",decode[stk]);\n\t\t\t\tstk=0;\n\t\t\t}\n\t\t}\n\t\tprintf(\"%\\n\");\n\t}\n\treturn 0;\n}", "sampled": "#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n\nchar* char_to_code[] = {\n    \"00000\", \"10000\", \"01000\", \"00100\", \"00010\", \"11000\", \"10100\", \"01100\",\n    \"00110\", \"10010\", \"01010\", \"11100\", \"10110\", \"01110\", \"11010\", \"11110\",\n    \"00001\", \"10001\", \"01001\", \"00101\", \"10101\", \"01101\", \"11001\", \"10011\",\n    \"01011\", \"11101\", \"10111\", \"01111\", \"11011\", \"11111\", \"00011\", \"00111\"\n};\n\nchar chars[] = \" ABCDEFGHIJKLMNOPQRSTUVWXYZ'-.,?\";\n\nchar* code_to_char[] = {\n    \"0\", \"100\", \"10\", \"1\", \"1010\", \"10100\", \"101000\", \"101\",\n    \"110\", \"1100\", \"11\", \"10101\", \"101010\", \"10110\", \"101011\", \"101100\",\n    \"1011\", \"10111\", \"1000\", \"1001\", \"100100\", \"100101\", \"10010\", \"100110\",\n    \"100111\", \"10011\", \"101000\", \"101001\", \"101010\", \"101011\", \"11\", \"111\"\n};\n\nint main() {\n    char input[256];\n    \n    while (fgets(input, sizeof(input), stdin)) {\n        int len = strlen(input);\n        if (len > 0 && input[len-1] == '\\n') {\n            input[len-1] = '\\0';\n            len--;\n        }\n        \n        char binary[10000] = \"\";\n        \n        for (int i = 0; i < len; i++) {\n            char c = input[i];\n            int found = 0;\n            for (int j = 0; j < 32; j++) {\n                if (chars[j] == c) {\n                    strcat(binary, char_to_code[j]);\n                    found = 1;\n                    break;\n                }\n            }\n        }\n        \n        char result[1000] = \"\";\n        int pos = 0;\n        int binlen = strlen(binary);\n        \n        while (pos < binlen) {\n            int found = 0;\n            for (int trylen = 1; trylen <= binlen - pos && trylen <= 10; trylen++) {\n                char temp[20];\n                strncpy(temp, binary + pos, trylen);\n                temp[trylen] = '\\0';\n                \n                for (int j = 0; j < 32; j++) {\n                    if (strcmp(code_to_char[j], temp) == 0) {\n                        int resultlen = strlen(result);\n                        result[resultlen] = chars[j];\n                        result[resultlen + 1] = '\\0';\n                        pos += trylen;\n                        found = 1;\n                        break;\n                    }\n                }\n                if (found) break;\n            }\n            \n            if (!found) {\n                pos++;\n            }\n        }\n        \n        printf(\"%s\\n\", result);\n    }\n    \n    return 0;\n}\n", "perturbed_sampled": ["#include  \"00000\", \"10000\", \"01000\", \"00100\", \"00010\", \"11000\",  \"10011\", \"01011\", \"11101\",  = \" ABCDEFGHIJKLMNOPQRSTUVWXYZ'-.,?\"; char*  \"11\", \"10101\", \"101010\", \"10110\", \"101011\", \"101100\", \"1011\", \"10111\",  \"111\" }; int main() {  = strlen(input); if (len > 0 && input[len-1] == '\\n')  \"\"; for (int i = 0;  int  j = 0; j   break; }  \"\"; int pos = 0;  int  trylen = 1;  trylen++) { char  0; j < 32; j++) { if (strcmp(code_to_char[j], temp) == 0) { int resultlen = strlen(result); result[resultlen] =  '\\0'; pos += trylen;  } if (!found) { pos++; } } printf(\"%s\\n\", result); } return 0; }"], "perturbed_original": ["#include <stdio.h> #include <string.h> #include <stdlib.h>  encode[64][6]={ \"11010\", \"\", \"\", \"\", \"\", \"\",  \"\", \"\",   \"00010\", \"00011\", \"00100\", \"00101\", \"00110\", \"00111\", \"01000\", \"01001\", \"01010\", \"01011\", \"01100\", \"01101\", \"01110\", \"01111\", \"10000\", \"10001\", \"10010\",  \"\", \"\",  '; decode[111111]='\\''; decode[111122]=','; decode[21121112]='-'; decode[121112]='.'; decode[111112]='?';  decode[2111]='R'; decode[11221]='S'; decode[11222]='T';  decode[21121111]='Z'; while(fgets(tex,900000,stdin)!=NULL){ strcpy(code,\"\");    0; }"], "original_ll": -0.7804712653160095, "sampled_ll": -0.5894367098808289, "all_perturbed_sampled_ll": [-1.9118725061416626], "all_perturbed_original_ll": [-1.3792736530303955], "perturbed_sampled_ll": -1.9118725061416626, "perturbed_original_ll": -1.3792736530303955, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.HashMap;\n\npublic class Main {\n\n\tstatic final HashMap<Character, String> c1 = new HashMap<Character, String>(32) {\n\t\t{\n\t\t\tput('A', \"00000\");\n\t\t\tput('B', \"00001\");\n\t\t\tput('C', \"00010\");\n\t\t\tput('D', \"00011\");\n\t\t\tput('E', \"00100\");\n\t\t\tput('F', \"00101\");\n\t\t\tput('G', \"00110\");\n\t\t\tput('H', \"00111\");\n\t\t\tput('I', \"01000\");\n\t\t\tput('J', \"01001\");\n\t\t\tput('K', \"01010\");\n\t\t\tput('L', \"01011\");\n\t\t\tput('M', \"01100\");\n\t\t\tput('N', \"01101\");\n\t\t\tput('O', \"01110\");\n\t\t\tput('P', \"01111\");\n\t\t\tput('Q', \"10000\");\n\t\t\tput('R', \"10001\");\n\t\t\tput('S', \"10010\");\n\t\t\tput('T', \"10011\");\n\t\t\tput('U', \"10100\");\n\t\t\tput('V', \"10101\");\n\t\t\tput('W', \"10110\");\n\t\t\tput('X', \"10111\");\n\t\t\tput('Y', \"11000\");\n\t\t\tput('Z', \"11001\");\n\t\t\tput(' ', \"11010\");\n\t\t\tput('.', \"11011\");\n\t\t\tput(',', \"11100\");\n\t\t\tput('-', \"11101\");\n\t\t\tput('\\'', \"11110\");\n\t\t\tput('?', \"11111\");\n\t\t}\n\t};\n\n\tstatic final HashMap<String, Character> c2 = new HashMap<String, Character>(32) {\n\t\t{\n\t\t\tput(\"101\", ' ');\n\t\t\tput(\"000000\", '\\'');\n\t\t\tput(\"000011\", ',');\n\t\t\tput(\"10010001\", '-');\n\t\t\tput(\"010001\", '.');\n\t\t\tput(\"000001\", '?');\n\t\t\tput(\"100101\", 'A');\n\t\t\tput(\"10011010\", 'B');\n\t\t\tput(\"0101\", 'C');\n\t\t\tput(\"0001\", 'D');\n\t\t\tput(\"110\", 'E');\n\t\t\tput(\"01001\", 'F');\n\t\t\tput(\"10011011\", 'G');\n\t\t\tput(\"010000\", 'H');\n\t\t\tput(\"0111\", 'I');\n\t\t\tput(\"10011000\", 'J');\n\t\t\tput(\"0110\", 'K');\n\t\t\tput(\"00100\", 'L');\n\t\t\tput(\"10011001\", 'M');\n\t\t\tput(\"10011110\", 'N');\n\t\t\tput(\"00101\", 'O');\n\t\t\tput(\"111\", 'P');\n\t\t\tput(\"10011111\", 'Q');\n\t\t\tput(\"1000\", 'R');\n\t\t\tput(\"00110\", 'S');\n\t\t\tput(\"00111\", 'T');\n\t\t\tput(\"10011100\", 'U');\n\t\t\tput(\"10011101\", 'V');\n\t\t\tput(\"000010\", 'W');\n\t\t\tput(\"10010010\", 'X');\n\t\t\tput(\"10010011\", 'Y');\n\t\t\tput(\"10010000\", 'Z');\n\t\t}\n\t};\n\n\tpublic static void main(String[] args) throws IOException {\n\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\tString line = \"\";\n\n\t\twhile ((line = br.readLine()) != null) {\n\t\t\tif (line.isEmpty()) {\n\t\t\t\tSystem.out.println(\"\");\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tStringBuilder sb1, sb2;\n\t\t\tsb1 = new StringBuilder();\n\t\t\tsb2 = new StringBuilder();\n\t\t\t//\n\t\t\tfor (char c : line.toCharArray()) {\n\t\t\t\tsb1.append(c1.get(c));\n\t\t\t}\n\t\t\t//\n\t\t\tString line2 = sb1.toString();\n\t\t\tfor (int i = 0; ; ) {\n\t\t\t\tchar c = 0;\n\t\t\t\tfor (int j = 3; j < 9 && i + j < line2.length(); j++) {\n\t\t\t\t\tif (c2.containsKey(line2.substring(i, i + j))) {\n\t\t\t\t\t\tc = c2.get(line2.substring(i, i + j));\n\t\t\t\t\t\tsb2.append(c);\n\t\t\t\t\t\ti += j;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (c == 0) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(sb2.toString());\n\t\t}\n\t}\n}", "sampled": "import java.util.*;\n\npublic class Main {\n    static Map<Character, String> charToCode = new HashMap<>();\n    static Map<String, Character> codeToChar = new HashMap<>();\n    \n    static {\n        // First table (char to code)\n        charToCode.put('A', \"00000\");\n        charToCode.put('B', \"0001\");\n        charToCode.put('C', \"0010\");\n        charToCode.put('D', \"0011\");\n        charToCode.put('E', \"110\");\n        charToCode.put('F', \"1000\");\n        charToCode.put('G', \"1001\");\n        charToCode.put('H', \"1010\");\n        charToCode.put('I', \"1011\");\n        charToCode.put('J', \"0100\");\n        charToCode.put('K', \"0101\");\n        charToCode.put('L', \"0110\");\n        charToCode.put('M', \"0111\");\n        charToCode.put('N', \"10000\");\n        charToCode.put('O', \"10001\");\n        charToCode.put('P', \"111\");\n        charToCode.put('Q', \"10010\");\n        charToCode.put('R', \"10011\");\n        charToCode.put('S', \"10100\");\n        charToCode.put('T', \"10101\");\n        charToCode.put('U', \"10110\");\n        charToCode.put('V', \"10111\");\n        charToCode.put('W', \"11000\");\n        charToCode.put('X', \"11001\");\n        charToCode.put('Y', \"11010\");\n        charToCode.put('Z', \"11011\");\n        charToCode.put(' ', \"11100\");\n        charToCode.put('.', \"11101\");\n        charToCode.put(',', \"11110\");\n        charToCode.put('-', \"11111\");\n        charToCode.put('\\'', \"01010\");\n        charToCode.put('?', \"01011\");\n        \n        // Second table (code to char)\n        codeToChar.put(\"00\", 'A');\n        codeToChar.put(\"0100\", 'B');\n        codeToChar.put(\"0101\", 'C');\n        codeToChar.put(\"0110\", 'D');\n        codeToChar.put(\"110\", 'E');\n        codeToChar.put(\"01110\", 'F');\n        codeToChar.put(\"01111\", 'G');\n        codeToChar.put(\"1000\", 'H');\n        codeToChar.put(\"1001\", 'I');\n        codeToChar.put(\"10100\", 'J');\n        codeToChar.put(\"10101\", 'K');\n        codeToChar.put(\"10110\", 'L');\n        codeToChar.put(\"10111\", 'M');\n        codeToChar.put(\"1011\", 'N');\n        codeToChar.put(\"01010\", 'O');\n        codeToChar.put(\"111\", 'P');\n        codeToChar.put(\"01011\", 'Q');\n        codeToChar.put(\"1100\", 'R');\n        codeToChar.put(\"1101\", 'S');\n        codeToChar.put(\"00111\", 'T');\n        codeToChar.put(\"1110\", 'U');\n        codeToChar.put(\"11110\", 'V');\n        codeToChar.put(\"11111\", 'W');\n        codeToChar.put(\"10010\", 'X');\n        codeToChar.put(\"10011\", 'Y');\n        codeToChar.put(\"01000\", 'Z');\n        codeToChar.put(\"01001\", ' ');\n        codeToChar.put(\"10000\", '.');\n        codeToChar.put(\"10001\", ',');\n        codeToChar.put(\"0010\", '-');\n        codeToChar.put(\"0011\", '\\'');\n    }\n    \n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        while (sc.hasNextLine()) {\n            String line = sc.nextLine();\n            if (line.isEmpty()) break;\n            \n            // Step 1: Convert each character to code\n            StringBuilder binary = new StringBuilder();\n            for (char c : line.toCharArray()) {\n                if (charToCode.containsKey(c)) {\n                    binary.append(charToCode.get(c));\n                }\n            }\n            \n            // Step 2: Decode using second table\n            StringBuilder result = new StringBuilder();\n            int i = 0;\n            while (i < binary.length()) {\n                boolean found = false;\n                for (int len = 1; len <= 5 && i + len <= binary.length(); len++) {\n                    String sub = binary.substring(i, i + len);\n                    if (codeToChar.containsKey(sub)) {\n                        result.append(codeToChar.get(sub));\n                        i += len;\n                        found = true;\n                        break;\n                    }\n                }\n                if (!found) {\n                    i++;\n                }\n            }\n            \n            System.out.println(result.toString());\n        }\n        sc.close();\n    }\n}\n", "perturbed_sampled": ["   First table (char to  charToCode.put('K', \"0101\");  \"111\"); charToCode.put('Q', \"10010\"); charToCode.put('R', \"10011\"); charToCode.put('S', \"10100\");  \"11011\"); charToCode.put(' ',  charToCode.put('-', \"11111\"); charToCode.put('\\'', \"01010\"); charToCode.put('?', \"01011\"); // Second table  codeToChar.put(\"01110\", 'F'); codeToChar.put(\"01111\", 'G'); codeToChar.put(\"1000\", 'H'); codeToChar.put(\"1001\", 'I'); codeToChar.put(\"10100\", 'J'); codeToChar.put(\"10101\", 'K'); codeToChar.put(\"10110\", 'L'); codeToChar.put(\"10111\", 'M'); codeToChar.put(\"1011\", 'N');  'Q'); codeToChar.put(\"1100\", 'R');  'U'); codeToChar.put(\"11110\", 'V'); codeToChar.put(\"11111\", 'W'); codeToChar.put(\"10010\", 'X'); codeToChar.put(\"10011\",  '); codeToChar.put(\"10000\",  codeToChar.put(\"0011\", '\\''); } public static void main(String[] args) { Scanner sc  { String line = sc.nextLine(); if (line.isEmpty()) break; //   new  line.toCharArray()) { if (charToCode.containsKey(c)) { binary.append(charToCode.get(c)); } } // Step  StringBuilder  i = 0; while (i < binary.length()) { boolean   { String sub = binary.substring(i, i  }"], "perturbed_original": ["import java.io.BufferedReader; import java.io.IOException; import  Main {  = new HashMap<Character, String>(32) {  put('G', \"00110\"); put('H',  put('M', \"01100\");  \"10001\");   put('Z', \"11001\");  put(',', \"11100\"); put('-', \"11101\");  HashMap<String, Character>(32) { {  put(\"000011\", ',');  '?'); put(\"100101\", 'A');  'F'); put(\"10011011\", 'G');  'J'); put(\"0110\", 'K'); put(\"00100\", 'L');  'Q');   put(\"000010\", 'W'); put(\"10010010\", 'X'); put(\"10010011\", 'Y'); put(\"10010000\", 'Z'); }  args) throws  new BufferedReader(new InputStreamReader(System.in)); String line = \"\"; while ((line = br.readLine()) != null) {  sb2 = new StringBuilder(); // for  sb1.append(c1.get(c));  sb1.toString();  c = 0;  j < 9 &&  j++) {  {  j; break; } } if (c == 0) { break; } } System.out.println(sb2.toString()); } } }"], "original_ll": -0.4868784248828888, "sampled_ll": -0.37182682752609253, "all_perturbed_sampled_ll": [-1.4045482873916626], "all_perturbed_original_ll": [-1.9445726871490479], "perturbed_sampled_ll": -1.4045482873916626, "perturbed_original_ll": -1.9445726871490479, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "to_bin = dict(zip([chr(i) for i in range(ord(\"A\"), ord(\"Z\") + 1)] + [\" \", \".\", \",\", \"-\", \"'\", \"?\"],\n                  [bin(i)[2:7].zfill(5) for i in range(2 ** 5)]))\nto_chr = {\"101\":\" \", \"000000\":\"'\", \"000011\":\",\", \"10010001\":\"-\", \"010001\":\".\", \"000001\":\"?\", \"100101\":\"A\", \"10011010\":\"B\",\n          \"0101\":\"C\", \"0001\":\"D\", \"110\":\"E\", \"01001\":\"F\", \"10011011\":\"G\", \"010000\":\"H\", \"0111\":\"I\", \"10011000\":\"J\",\n          \"0110\":\"K\", \"00100\":\"L\", \"10011001\":\"M\", \"10011110\":\"N\", \"00101\":\"O\", \"111\":\"P\", \"10011111\":\"Q\", \"1000\":\"R\",\n          \"00110\":\"S\", \"00111\":\"T\", \"10011100\":\"U\", \"10011101\":\"V\", \"000010\":\"W\", \"10010010\":\"X\", \"10010011\":\"Y\", \"10010000\":\"Z\"}\n\nwhile True:\n  try:\n    s = input()\n  except EOFError:\n    break\n  bs = \"\".join([to_bin[c] for c in s])\n  ans = \"\"\n  while True:\n    length = 9\n    for i in range(length):\n      if bs[:i] in to_chr:\n        ans = ans + to_chr[bs[:i]]\n        bs = bs[i:]\n        break\n    else:\n      break\n  print(ans)\n", "sampled": "import sys\n\n# First conversion table (character to code)\nchar_to_code = {\n    'A': '00000', 'B': '10000', 'C': '01000', 'D': '00100', 'E': '00010',\n    'F': '10100', 'G': '01100', 'H': '00110', 'I': '10010', 'J': '01010',\n    'K': '00001', 'L': '10001', 'M': '01001', 'N': '00101', 'O': '10101',\n    'P': '01101', 'Q': '00011', 'R': '10011', 'S': '01011', 'T': '11000',\n    'U': '10110', 'V': '01110', 'W': '00111', 'X': '10111', 'Y': '01111',\n    'Z': '11001', \"'\": '11010', ',': '11011', '-': '11100', '.': '11101',\n    '?': '11110', ' ': '11111'\n}\n\n# Second conversion table (code to character)\ncode_to_char = {\n    '00': 'A', '0100': 'B', '0000': 'C', '100': 'D', '110': 'E',\n    '1000': 'F', '0110': 'G', '1110': 'H', '10': 'I', '0010': 'J',\n    '0001': 'K', '1100': 'L', '0101': 'M', '01': 'N', '0011': 'O',\n    '111': 'P', '1010': 'Q', '1001': 'R', '1101': 'S', '11': 'T',\n    '1011': 'U', '0111': 'V', '011': 'W', '1111': 'X', '0001': 'Y',\n    '10100': 'Z', '10101': \"'\", '10110': ',', '10111': '-', '11000': '.',\n    '11001': '?', '0000': ' '\n}\n\n# Fix the duplicate keys issue - need to check which mapping is correct\ncode_to_char = {\n    '00': 'A', '0100': 'B', '0000': 'C', '100': 'D', '110': 'E',\n    '1000': 'F', '0110': 'G', '1110': 'H', '10': 'I', '0010': 'J',\n    '0001': 'K', '1100': 'L', '0101': 'M', '01': 'N', '0011': 'O',\n    '111': 'P', '1010': 'Q', '1001': 'R', '1101': 'S', '11': 'T',\n    '1011': 'U', '0111': 'V', '011': 'W', '1111': 'X', '10100': 'Z',\n    '10101': \"'\", '10110': ',', '10111': '-', '11000': '.', '11001': '?'\n}\n\ndef decode(binary_str):\n    result = []\n    i = 0\n    while i < len(binary_str):\n        found = False\n        # Try lengths from 2 to 5\n        for length in range(2, 6):\n            if i + length <= len(binary_str):\n                substr = binary_str[i:i+length]\n                if substr in code_to_char:\n                    result.append(code_to_char[substr])\n                    i += length\n                    found = True\n                    break\n        if not found:\n            i += 1\n    return ''.join(result)\n\nfor line in sys.stdin:\n    line = line.strip()\n    if not line:\n        continue\n    \n    # Step 1: Convert characters to binary using first table\n    binary = ''\n    for char in line:\n        if char in char_to_code:\n            binary += char_to_code[char]\n    \n    # Step 2: Convert binary to characters using second table\n    result = decode(binary)\n    print(result)\n", "perturbed_sampled": ["import sys # First conversion table (character to code)  'B': '10000', 'C': '01000', 'D': '00100', 'E': '00010', 'F': '10100',  '00001',  '00101', 'O': '10101', 'P': '01101', 'Q': '00011', 'R':  'W': '00111', 'X':  '-': '11100', '.': '11101', '?': '11110',  Second  code_to_char = { '00': 'A', '0100': 'B', '0000': 'C',   '1010': 'Q', '1001': 'R', '1101': 'S', '11': 'T', '1011': 'U', '0111': 'V',  'Y', '10100': 'Z', '10101': \"'\", '10110':  ' } # Fix the duplicate  correct code_to_char = { '00': 'A', '0100': 'B', '0000':  '1000': 'F', '0110': 'G', '1110': 'H', '10': 'I', '0010': 'J', '0001':  '01': 'N', '0011': 'O', '111': 'P', '1010': 'Q', '1001': 'R',  'W', '1111': 'X', '10100': 'Z', '10101':   while i < len(binary_str): found = False # Try lengths from   not found: i +=  continue #  characters using  print(result)"], "perturbed_original": ["to_bin = dict(zip([chr(i) for i in range(ord(\"A\"),  \"'\", \"?\"],  ** 5)])) to_chr = {\"101\":\" \", \"000000\":\"'\", \"000011\":\",\",  \"0101\":\"C\", \"0001\":\"D\", \"110\":\"E\", \"01001\":\"F\",  \"00100\":\"L\",  \"1000\":\"R\", \"00110\":\"S\",  except EOFError: break bs  while True:  ans + to_chr[bs[:i]] bs = bs[i:] break else: break print(ans)"], "original_ll": -1.0182512998580933, "sampled_ll": -0.4748696982860565, "all_perturbed_sampled_ll": [-1.6334820985794067], "all_perturbed_original_ll": [-2.552976131439209], "perturbed_sampled_ll": -1.6334820985794067, "perturbed_original_ll": -2.552976131439209, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "#include <stdio.h>\n\nint main(){\n  long long int time[10001] = {}, wtime[10001] = {}, min, sum;\n  int j, k, n;\n  while(scanf(\"%d\", &n) && n){\n    for(j = 0;j < n;j++)\n      scanf(\"%lld\", &time[j]);\n\n    for(j = 0;j < n - 1;j++){\n      min = j;\n      for(k = j + 1;k < n;k++)\n\tmin = time[min] < time[k] ? min : k;\n      if(min != j){\n\ttime[min] += time[j];\n\ttime[j] = time[min] - time[j];\n\ttime[min] -= time[j];\n      }\n    }\n    sum = 0;\n    for(j = 1;j < n;j++){\n      wtime[j] = wtime[j - 1] + time[j - 1];\n      sum += wtime[j];\n    }\n    \n    printf(\"%lld\\n\", sum);\n  }\n  return 0;\n}", "sampled": "#include <stdio.h>\n#include <stdlib.h>\n\nint compare(const void *a, const void *b) {\n    return (*(int*)a - *(int*)b);\n}\n\nint main() {\n    int n;\n    \n    while(scanf(\"%d\", &n) == 1 && n != 0) {\n        int times[10000];\n        \n        for(int i = 0; i < n; i++) {\n            scanf(\"%d\", &times[i]);\n        }\n        \n        qsort(times, n, sizeof(int), compare);\n        \n        long long total_wait = 0;\n        long long cumulative = 0;\n        \n        for(int i = 0; i < n; i++) {\n            total_wait += cumulative;\n            cumulative += times[i];\n        }\n        \n        printf(\"%lld\\n\", total_wait);\n    }\n    \n    return 0;\n}\n", "perturbed_sampled": [" compare(const void *a,  int main() { int n; while(scanf(\"%d\", &n) == 1 &&  times[10000]; for(int i = 0; i  total_wait = 0; long long  += cumulative; cumulative += times[i]; }  }"], "perturbed_original": ["#include <stdio.h> int main(){ long long int time[10001] = {},   scanf(\"%lld\", &time[j]); for(j = 0;j < n - 1;j++){ min =  1;k < n;k++) min = time[min] <  time[min] - time[j];  sum = 0; for(j =   } return 0; }"], "original_ll": -0.8927487134933472, "sampled_ll": -0.6408005356788635, "all_perturbed_sampled_ll": [-3.0765228271484375], "all_perturbed_original_ll": [-2.529263496398926], "perturbed_sampled_ll": -3.0765228271484375, "perturbed_original_ll": -2.529263496398926, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "\nimport java.util.*;\npublic class Main {\n\t\n\tprivate void doit(){\n\t\tScanner sc = new Scanner(System.in);\n\t\twhile(true){\n\t\t\tint n = sc.nextInt();\n\t\t\tif(n == 0) break;\n\t\t\tint [] data = new int[n];\n\t\t\tfor(int i = 0; i < n; i++){\n\t\t\t\tdata[i] = sc.nextInt();\n\t\t\t\n\t\t\t}\n\t\t\tArrays.sort(data);\n\t\t\tint [] data2 = new int[n];\n\t\t\tint sum = 0;\n\t\t\tdata2[0] = 0;\n\t\t\tfor(int i = 1; i < n; i++){\n\t\t\t\tdata2[i] = data2[i-1] + data[i-1];\n\t\t\t}\n\t\t\t\n\t\t\tfor(int i = 0; i < n; i++){\n\t\t\t\tsum += data2[i];\n\t\t\t}\n\t\t\tSystem.out.println(sum);\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tMain obj = new Main();\n\t\tobj.doit();\n\t}\n}", "sampled": "import java.util.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        \n        while (true) {\n            int n = sc.nextInt();\n            if (n == 0) break;\n            \n            int[] times = new int[n];\n            for (int i = 0; i < n; i++) {\n                times[i] = sc.nextInt();\n            }\n            \n            Arrays.sort(times);\n            \n            int totalWaitTime = 0;\n            int currentTime = 0;\n            \n            for (int i = 0; i < n; i++) {\n                totalWaitTime += currentTime;\n                currentTime += times[i];\n            }\n            \n            System.out.println(totalWaitTime);\n        }\n        \n        sc.close();\n    }\n}\n", "perturbed_sampled": ["import java.util.*; public class  main(String[] args) { Scanner sc = new   times =  = 0; i <  i < n; i++) { totalWaitTime += currentTime; currentTime +=  } }"], "perturbed_original": [" Scanner sc = new Scanner(System.in); while(true){ int n = sc.nextInt(); if(n == 0)   0; i  for(int i =  data2[i] = data2[i-1] +  0; i < n;  System.out.println(sum); } } public static void  = new Main(); obj.doit(); } }"], "original_ll": -0.6788057088851929, "sampled_ll": -0.4193897247314453, "all_perturbed_sampled_ll": [-3.5002808570861816], "all_perturbed_original_ll": [-2.645927667617798], "perturbed_sampled_ll": -3.5002808570861816, "perturbed_original_ll": -2.645927667617798, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "n = int(input())\nt = []\ns = 0\nsum = 0\n\nif n == 0:\n    print(n)\n\nelse:\n    for i in range(n):\n        s = int(input())\n        if s == 0:\n            break\n        else:\n            t.append(i)\n            t[i] = s\n            t.sort()\n\n    for m in range(n):\n        sum = sum + t[m]*(n-m-1)\n\n    print(sum)\n\n", "sampled": "while True:\n    n = int(input())\n    if n == 0:\n        break\n    \n    times = []\n    for _ in range(n):\n        times.append(int(input()))\n    \n    times.sort()\n    \n    total_wait = 0\n    cumulative_time = 0\n    \n    for t in times:\n        total_wait += cumulative_time\n        cumulative_time += t\n    \n    print(total_wait)\n", "perturbed_sampled": ["while   in range(n): times.append(int(input())) times.sort() total_wait = 0 cumulative_time = 0 for  print(total_wait)"], "perturbed_original": [" [] s = 0   == 0: break else: t.append(i)  m in range(n): sum = sum + t[m]*(n-m-1) print(sum)"], "original_ll": -1.2036937475204468, "sampled_ll": -0.9045174717903137, "all_perturbed_sampled_ll": [-3.419611930847168], "all_perturbed_original_ll": [-3.595531463623047], "perturbed_sampled_ll": -3.419611930847168, "perturbed_original_ll": -3.595531463623047, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "char S[99];\nint G(x,y){return y?G(y,x%y):x;}\nmain(g,X,Y,x,y,z,t,T,f){for(;~scanf(\"%d%d\",&x,&y);){\nfor(g=0,X=x,Y=y;g<90;g++)S[g]=X*10/Y+'0',X=X*10%y;\nsprintf(S,\"%.97f\",x/(double)y);\ng=G(x,y);x/=g;y/=g;\nfor(z=0;y%2==0;y/=2)z++;\nfor(f=0;y%5==0;y/=5)f++;\nif(y==1)t=0;else{x=1;t=0;do{x=x*10%y;t++;}while(x!=1);}\nif(z>f)f=z;\nS[f+t+2]=0;puts(S+2);\nif(t){\n\tfor(;f>0;f--)putchar(' ');\n\tfor(;t>0;t--)putchar('^');\n\tputs(\"\");\n}\n}exit(0);}", "sampled": "#include <stdio.h>\n#include <string.h>\n\nint main() {\n    int p, q;\n    \n    while (scanf(\"%d %d\", &p, &q) == 2) {\n        char digits[85];\n        int remainders[1000005];\n        int positions[1000005];\n        \n        memset(remainders, -1, sizeof(remainders));\n        memset(positions, -1, sizeof(positions));\n        \n        int remainder = p % q;\n        int pos = 0;\n        int cycle_start = -1;\n        \n        while (remainder != 0) {\n            if (remainders[remainder] != -1) {\n                cycle_start = remainders[remainder];\n                break;\n            }\n            \n            remainders[remainder] = pos;\n            positions[pos] = remainder;\n            \n            remainder *= 10;\n            digits[pos] = (remainder / q) + '0';\n            remainder = remainder % q;\n            pos++;\n        }\n        \n        digits[pos] = '\\0';\n        \n        if (cycle_start == -1) {\n            // Non-repeating\n            printf(\"%s\\n\", digits);\n        } else {\n            // Repeating\n            printf(\"%s\\n\", digits);\n            for (int i = 0; i < cycle_start; i++) {\n                printf(\" \");\n            }\n            for (int i = cycle_start; i < pos; i++) {\n                printf(\"^\");\n            }\n            printf(\"\\n\");\n        }\n    }\n    \n    return 0;\n}\n", "perturbed_sampled": ["#include <stdio.h> #include <string.h> int  while (scanf(\"%d  remainders[1000005]; int positions[1000005]; memset(remainders, -1, sizeof(remainders)); memset(positions, -1, sizeof(positions)); int  while (remainder  != -1) { cycle_start  = pos; positions[pos]  q) + '0'; remainder = remainder % q; pos++; }  Non-repeating  // Repeating printf(\"%s\\n\", digits);  i  \"); } for (int  return 0; }"], "perturbed_original": ["char S[99]; int G(x,y){return y?G(y,x%y):x;}  if(t){ for(;f>0;f--)putchar(' '); for(;t>0;t--)putchar('^'); puts(\"\"); } }exit(0);}"], "original_ll": -2.3000357151031494, "sampled_ll": -0.7412351965904236, "all_perturbed_sampled_ll": [-2.692610740661621], "all_perturbed_original_ll": [-3.05037522315979], "perturbed_sampled_ll": -2.692610740661621, "perturbed_original_ll": -3.05037522315979, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import java.util.Arrays;\nimport java.util.Scanner;\n\n\npublic class Main {\n\t\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\t\n\t\twhile(true){\n\t\t\tfinal int p = sc.nextInt();\n\t\t\tfinal int q = sc.nextInt();\n\t\t\t\n\t\t\tif(p == 0 && q == 0){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\n\t\t\tint[] mods = new int[q];\n\t\t\tArrays.fill(mods, -1);\n\t\t\t\n\t\t\tint cur = p * 10;\n\t\t\tint rep_start = -1;\n\t\t\tint rep_end = 0;\n\t\t\twhile(true){\n\t\t\t\tfinal int m = cur % q;\n\t\t\t\tSystem.out.print(cur / q);\n\t\t\t\t\n\t\t\t\t\n\t\t\t\tif(m == 0){\n\t\t\t\t\trep_start = rep_end;\n\t\t\t\t\tbreak;\n\t\t\t\t}else if(mods[m] >= 0){\n\t\t\t\t\trep_start = mods[m];\n\t\t\t\t\tbreak;\n\t\t\t\t}else{\n\t\t\t\t\tmods[m] = rep_end;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\trep_end++;\n\t\t\t\tcur = m * 10;\n\t\t\t}\n\t\t\tSystem.out.println();\n\t\t\tif(rep_start != rep_end){\n\t\t\t\tfor(int i = 0; i <= rep_end;i++){\n\t\t\t\t\tif(i <= rep_start){\n\t\t\t\t\t\tSystem.out.print(\" \");\n\t\t\t\t\t}else{\n\t\t\t\t\t\tSystem.out.print(\"^\");\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tSystem.out.println();\n\t\t\t}\n\t\t}\n\n\t}\n\n}", "sampled": "import java.util.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        \n        while (sc.hasNext()) {\n            int p = sc.nextInt();\n            int q = sc.nextInt();\n            \n            StringBuilder decimal = new StringBuilder();\n            Map<Integer, Integer> remainderPos = new HashMap<>();\n            \n            int remainder = p % q;\n            int position = 0;\n            \n            while (remainder != 0 && !remainderPos.containsKey(remainder)) {\n                remainderPos.put(remainder, position);\n                remainder *= 10;\n                int digit = remainder / q;\n                decimal.append(digit);\n                remainder = remainder % q;\n                position++;\n            }\n            \n            if (remainder == 0) {\n                // Terminates\n                System.out.println(decimal.toString());\n            } else {\n                // Repeating\n                int cycleStart = remainderPos.get(remainder);\n                System.out.println(decimal.toString());\n                \n                StringBuilder marker = new StringBuilder();\n                for (int i = 0; i < cycleStart; i++) {\n                    marker.append(' ');\n                }\n                for (int i = cycleStart; i < decimal.length(); i++) {\n                    marker.append('^');\n                }\n                System.out.println(marker.toString());\n            }\n        }\n        \n        sc.close();\n    }\n}\n", "perturbed_sampled": [" main(String[] args)  Scanner(System.in); while (sc.hasNext()) { int p = sc.nextInt(); int  = new StringBuilder(); Map<Integer, Integer>  0; while (remainder   int digit = remainder / q; decimal.append(digit); remainder  0)  i = 0; i < cycleStart; i++) { marker.append(' '); } for (int i = cycleStart; i <  } }"], "perturbed_original": ["import java.util.Arrays;  sc =  p = sc.nextInt(); final int q = sc.nextInt(); if(p == 0 && q   -1); int  int  = 0;  / q); if(m ==  }else if(mods[m] >= 0){ rep_start =  } System.out.println(); if(rep_start != rep_end){ for(int i  \"); }else{ System.out.print(\"^\");  } }"], "original_ll": -0.9555273652076721, "sampled_ll": -0.7955405712127686, "all_perturbed_sampled_ll": [-3.163391351699829], "all_perturbed_original_ll": [-3.490344285964966], "perturbed_sampled_ll": -3.163391351699829, "perturbed_original_ll": -3.490344285964966, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "from decimal import *\nimport re\ndef solve2(m, n):\n    maxlen = 85\n    #PREC=200\n    PREC=300\n    getcontext().prec = PREC\n    x = Decimal(m) / Decimal(n)\n    s = x.to_eng_string()\n    if len(s) < PREC:\n        return(s[2:],'')\n    rep = 1\n    while True:\n        r = r'(.{%d})\\1{%d,}' % (rep, int(PREC/rep)-1)\n                                         #ex. '(.{6})\\\\1{12,}'\n        a=re.search(r, s)\n        if a:\n            break\n        rep += 1\n        if rep > maxlen:\n            raise ValueError('This cannot happen.')\n\n    u = s[2:a.start()+len(a.group(1))]\n    v = (' '*PREC + '^'*len(a.group(1)))[-len(u):]\n    return(u,v)\n\nwhile True:\n    try:\n        m,n = map(int, input().strip().split())\n        s,t = solve2(m, n)\n        print(s)\n        if t!='':\n            print(t)\n    except EOFError:\n        break", "sampled": "import sys\n\ndef solve(p, q):\n    # Calculate decimal representation of p/q\n    decimal_digits = []\n    remainders = {}\n    remainder = p % q\n    position = 0\n    \n    while remainder != 0 and remainder not in remainders:\n        remainders[remainder] = position\n        remainder *= 10\n        digit = remainder // q\n        decimal_digits.append(str(digit))\n        remainder = remainder % q\n        position += 1\n    \n    if remainder == 0:\n        # Terminating decimal\n        print(''.join(decimal_digits))\n    else:\n        # Repeating decimal\n        cycle_start = remainders[remainder]\n        print(''.join(decimal_digits))\n        \n        # Second line with spaces and carets\n        line2 = []\n        for i in range(len(decimal_digits)):\n            if i < cycle_start:\n                line2.append(' ')\n            else:\n                line2.append('^')\n        print(''.join(line2))\n\nfor line in sys.stdin:\n    p, q = map(int, line.strip().split())\n    solve(p, q)\n", "perturbed_sampled": ["import sys def solve(p,  of p/q decimal_digits = [] remainders  in remainders: remainders[remainder] = position remainder *= 10 digit =  remainder == 0:  = remainders[remainder] print(''.join(decimal_digits)) # Second line with spaces and carets line2 = []  i <   line.strip().split()) solve(p, q)"], "perturbed_original": ["from decimal import *  PREC=300 getcontext().prec = PREC x = Decimal(m) / Decimal(n) s  PREC:  % (rep, int(PREC/rep)-1) #ex.  u = s[2:a.start()+len(a.group(1))] v = ('  map(int, input().strip().split()) s,t = solve2(m,  except EOFError: break"], "original_ll": -1.9899669885635376, "sampled_ll": -1.096883773803711, "all_perturbed_sampled_ll": [-4.339999675750732], "all_perturbed_original_ll": [-4.451655864715576], "perturbed_sampled_ll": -4.339999675750732, "perturbed_original_ll": -4.451655864715576, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "int G(x,y){return y?G(y,x%y):x;}\nint L(x,y){return x>y?(x/G(x,y)*y):(y/G(y,x)*x);}\nn[3],a[3],m[3];main(i,x){\n\tfor(;scanf(\"%d%d%d%d%d%d\",a,m,a+1,m+1,a+2,m+2),*m;){\n\t\tfor(i=3;i--;)for(x=n[i]=1;(x=a[i]*x%m[i])>1;n[i]++);\n\t\tprintf(\"%d\\n\",L(n[0],L(n[1],n[2])));\n\t}\n}", "sampled": "#include <stdio.h>\n\nlong long gcd(long long a, long long b) {\n    while (b != 0) {\n        long long temp = b;\n        b = a % b;\n        a = temp;\n    }\n    return a;\n}\n\nlong long lcm(long long a, long long b) {\n    return a / gcd(a, b) * b;\n}\n\nlong long find_period(long long a, long long m) {\n    long long x = 1;\n    long long period = 0;\n    \n    do {\n        x = (x * a) % m;\n        period++;\n    } while (x != 1);\n    \n    return period;\n}\n\nint main() {\n    long long a1, m1, a2, m2, a3, m3;\n    \n    while (1) {\n        scanf(\"%lld %lld %lld %lld %lld %lld\", &a1, &m1, &a2, &m2, &a3, &m3);\n        \n        if (a1 == 0 && m1 == 0 && a2 == 0 && m2 == 0 && a3 == 0 && m3 == 0) {\n            break;\n        }\n        \n        long long period1 = find_period(a1, m1);\n        long long period2 = find_period(a2, m2);\n        long long period3 = find_period(a3, m3);\n        \n        long long result = lcm(period1, lcm(period2, period3));\n        \n        printf(\"%lld\\n\", result);\n    }\n    \n    return 0;\n}\n", "perturbed_sampled": ["#include  temp = b; b = a % b;   b) { return a / gcd(a, b) * b; } long long find_period(long long a, long   { x =  period++; } while    a3, m3; while  %lld %lld %lld\", &a1, &m1, &a2,  == 0 && a2 == 0 && m2 == 0  long long period2 = find_period(a2, m2); long long  long result =  } return 0; }"], "perturbed_original": ["int  n[3],a[3],m[3];main(i,x){ for(;scanf(\"%d%d%d%d%d%d\",a,m,a+1,m+1,a+2,m+2),*m;){ for(i=3;i--;)for(x=n[i]=1;(x=a[i]*x%m[i])>1;n[i]++); printf(\"%d\\n\",L(n[0],L(n[1],n[2]))); } }"], "original_ll": -2.0244574546813965, "sampled_ll": -0.3609764277935028, "all_perturbed_sampled_ll": [-3.115743398666382], "all_perturbed_original_ll": [-2.309584856033325], "perturbed_sampled_ll": -3.115743398666382, "perturbed_original_ll": -2.309584856033325, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "\nimport java.io.*;\nimport java.util.*;\n\n\n// \u0082\u00e6\u0082\u00ad\u008a\u00d4\u0088\u00e1\u0082\u00a4\u0082\u00c6\u0082\u00b1\u0082\u00eb\u0081B\n// \u0096\u00e2\u0091\u00e8\u0095\u00b6\u0082\u00c9\u008f\u0091\u0082\u00a2\u0082\u00c4\u0082\u00c8\u0082\u00ad\u0082\u00c4\u0082\u00e0\u0096\u00e2\u0091\u00e8\u0083Z\u0083b\u0083g\u0082\u00cd\u0095\u00a1\u0090\u0094\u0082\u00c5\u0090\u00e6\u0093\u00aa\u0082\u00aa0\u0082\u00c5\u008fI\u0097\u00b9\u0082\u00c5\u0082\u00a0\u0082\u00e9\u0081B\n// \u0096\u00e2\u0091\u00e8\u0083Z\u0083b\u0083g\u0082\u00cc\u008cJ\u0082\u00e8\u0095\u00d4\u0082\u00b5\u008e\u009e\u0082\u00c9\u008f\u0089\u008a\u00fa\u0089\u00bb\u0098R\u0082\u00ea\n\n// 2011/10/18\n\n//\u0081@0114 \u0094\u0088\npublic class Main {\n\n\t\n\tlong gcm(long a, long b) {\n\t\t\n\t\twhile(b != 0) {\n\t\t\tlong t = a % b;\n\t\t\ta = b;\n\t\t\tb = t;\n\t\t}\n\t\treturn a;\n\t}\n\t\n\tlong lcm(long a, long b) {\n\t\treturn a * b / gcm(a, b);\n\t}\n\t\n\t// \u0083\u0081\u0083C\u0083\u0093 return false\u0082\u00c5\u0082\u00a8\u0082\u00b5\u0082\u00dc\u0082\u00a2\n\tboolean main() throws IOException {\n\n\t\tint[] ri = readIntArray();\n\t\tint a1 = ri[0];\n\t\tint m1 = ri[1];\n\t\tint a2 = ri[2];\n\t\tint m2 = ri[3];\n\t\tint a3 = ri[4];\n\t\tint m3 = ri[5];\n\t\tif (a1 == 0 && m1 == 0 && a2 == 0 && m2 == 0 && a3 == 0 && m3 == 0) \n\t\t\treturn false; // \u0082\u00a8\u0082\u00b5\u0082\u00dc\u0082\u00a2\n\n\t\tint i;\n\t\tint x = 1;\n\t\tfor(i = 1;; i++) {\n\t\t\tx = (a1 * x) % m1;\n\t\t\tif (x == 1)\n\t\t\t\tbreak;\n\t\t}\n\t\tlong v1 = i;\n\t\tx = 1;\n\t\tfor(i = 1;; i++) {\n\t\t\tx = (a2 * x) % m2;\n\t\t\tif (x == 1)\n\t\t\t\tbreak;\n\t\t}\n\t\tlong v2 = i;\n\t\tx = 1;\n\t\tfor(i = 1;; i++) {\n\t\t\tx = (a3 * x) % m3;\n\t\t\tif (x == 1)\n\t\t\t\tbreak;\n\t\t}\n\t\tlong v3 = i;\n\t\tlong r = lcm(lcm(v1, v2), v3);\n\t\t\n\t\t\n\t\t// \u0089\u00f0\u0082\u00cc\u0095\\\u008e\u00a6\n\t\tSystem.out.printf(\"%d\\n\", r);\n\t\t\n\t\treturn true; // \u0090\u00b3\u008f\u00ed\u008fI\u0097\u00b9 \u008e\u009f\u0082\u00d6\n\t}\n\t\n\n//\tprivate final static boolean DEBUG = true;  // debug\n\tprivate final static boolean DEBUG = false; // release\n\n\tpublic static void main(String[] args) throws IOException {\n\n\t\tif (DEBUG) {\n\t\t\tlog = System.out;\n\t\t\t\n\t\t\tString inputStr = \"1 459550\\n\";\n\n\t\t\treader = new BufferedReader(new StringReader(inputStr)); \n\n\t\t}\n\t\telse {\n\t\t\tlog = new PrintStream(new OutputStream() { public void write(int b) {} } ); // \u008f\u0091\u0082\u00ab\u008e\u00cc\u0082\u00c4\n\t\t\treader = new BufferedReader(new InputStreamReader(System.in)); // \u0083R\u0083\u0093\u0083\\\u0081[\u0083\u008b\u0082\u00a9\u0082\u00e7\n\t\t}\n\t\t\n\t\t//int N = readIntArray()[0];\n\n\t\tfor(int i = 0; /*i < N*/; i++) {\n\t\t\tboolean b = new Main().main();\n\t\t\tif (!b)\n\t\t\t\tbreak;\n\t\t}\t\t\n\t\t\n\t\treader.close();\n\t}\n\n\t\n\tstatic PrintStream log;\n\tstatic BufferedReader reader;\n\t\n\n\t// \u0095W\u008f\u0080\u0093\u00fc\u0097\u00cd\u0082\u00e6\u0082\u00e81\u008ds\u0095\u00aa\u0082\u00cc\u0083X\u0083y\u0081[\u0083X\u008b\u00e6\u0090\u00d8\u0082\u00e8\u0082\u00cc\u0090\u00ae\u0090\u0094\u0092l\u0082\u00f0\u0093\u00c7\u0082\u00de\n\t// EOF\u0082\u00cc\u008f\u00ea\u008d\u0087\u0082\u00cdnull\u0082\u00f0\u0095\u00d4\u0082\u00b7\n\tprivate static int[] readIntArray() throws IOException {\n\t\t\n\t\tString s = reader.readLine();\n\t\tif (s == null)\n\t\t\treturn null;\n\t\tString[] sp = s.split(\" \");\n\t\tint[] a = new int[sp.length];\n\t\tfor(int i = 0; i < sp.length; i++) {\n\t\t\ta[i] = Integer.parseInt(sp[i]);\n\t\t}\n\t\treturn a;\n\t}\n\t\t\n}", "sampled": "import java.util.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        \n        while (true) {\n            long a1 = sc.nextLong();\n            long m1 = sc.nextLong();\n            long a2 = sc.nextLong();\n            long m2 = sc.nextLong();\n            long a3 = sc.nextLong();\n            long m3 = sc.nextLong();\n            \n            if (a1 == 0 && m1 == 0 && a2 == 0 && m2 == 0 && a3 == 0 && m3 == 0) {\n                break;\n            }\n            \n            long period1 = findPeriod(a1, m1);\n            long period2 = findPeriod(a2, m2);\n            long period3 = findPeriod(a3, m3);\n            \n            long result = lcm(lcm(period1, period2), period3);\n            \n            System.out.println(result);\n        }\n        \n        sc.close();\n    }\n    \n    private static long findPeriod(long a, long m) {\n        long x = 1;\n        long period = 0;\n        \n        do {\n            x = (a * x) % m;\n            period++;\n        } while (x != 1);\n        \n        return period;\n    }\n    \n    private static long gcd(long a, long b) {\n        while (b != 0) {\n            long temp = b;\n            b = a % b;\n            a = temp;\n        }\n        return a;\n    }\n    \n    private static long lcm(long a, long b) {\n        return a / gcd(a, b) * b;\n    }\n}\n", "perturbed_sampled": ["  = new Scanner(System.in); while   long a3 = sc.nextLong(); long m3 = sc.nextLong(); if (a1 == 0 &&  == 0 && m2 == 0 && a3 == 0  break; } long period1 = findPeriod(a1, m1); long  period3 = findPeriod(a3, m3); long result    0; do {  while  } private static long  while  = a %  static long lcm(long a, long  gcd(a, b) * b; } }"], "perturbed_original": ["import java.io.*; import java.util.*; // \u0082\u00e6\u0082\u00ad\u008a\u00d4\u0088\u00e1\u0082\u00a4\u0082\u00c6\u0082\u00b1\u0082\u00eb\u0081B // \u0096\u00e2\u0091\u00e8\u0095\u00b6\u0082\u00c9\u008f\u0091\u0082\u00a2\u0082\u00c4\u0082\u00c8\u0082\u00ad\u0082\u00c4\u0082\u00e0\u0096\u00e2\u0091\u00e8\u0083Z\u0083b\u0083g\u0082\u00cd\u0095\u00a1\u0090\u0094\u0082\u00c5\u0090\u00e6\u0093\u00aa\u0082\u00aa0\u0082\u00c5\u008fI\u0097\u00b9\u0082\u00c5\u0082  a, long b) { while(b  a =  return a; } long lcm(long a, long   { int[] ri = readIntArray();  a2 = ri[2]; int m2 = ri[3]; int a3 = ri[4]; int m3 = ri[5]; if (a1 == 0 &&  == 0 && m2 == 0  i; int x = 1; for(i = 1;; i++) { x  m1; if (x == 1) break;  x =  { x = (a2 *  x = 1; for(i  == 1) break; } long v3 =  System.out.printf(\"%d\\n\",  private final  {     write(int b) {} }  =  { boolean b = new Main().main(); if  static PrintStream log; static BufferedReader reader; // \u0095W\u008f\u0080\u0093\u00fc\u0097\u00cd\u0082\u00e6\u0082\u00e81\u008ds\u0095\u00aa\u0082\u00cc\u0083X\u0083y\u0081[\u0083X\u008b\u00e6\u0090\u00d8\u0082\u00e8\u0082\u00cc\u0090\u00ae\u0090\u0094\u0092l\u0082\u00f0\u0093\u00c7\u0082\u00de // EOF\u0082\u00cc\u008f\u00ea\u008d\u0087\u0082\u00cdnull\u0082\u00f0\u0095\u00d4\u0082\u00b7 private static int[] readIntArray() throws IOException { String s = reader.readLine();    i++) { a[i] = Integer.parseInt(sp[i]); } return a; } }"], "original_ll": -1.6700654029846191, "sampled_ll": -0.3586435317993164, "all_perturbed_sampled_ll": [-2.7806015014648438], "all_perturbed_original_ll": [-2.8496792316436768], "perturbed_sampled_ll": -2.7806015014648438, "perturbed_original_ll": -2.8496792316436768, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "# AOJ 0114: Electro-Fly\n# Python3 2018.6.18 bal4u\n\nfrom math import gcd\n\nwhile True:\n\ta1, m1, a2, m2, a3, m3 = list(map(int, input().split()))\n\tif a1 == 0: break\n\tn = 0\n\tb1, b2, b3 = 1, 1, 1\n\ta, b, c = 0, 0, 0\n\twhile True:\n\t\tif a == 0: b1 = (b1 * a1) % m1\n\t\tif b == 0: b2 = (b2 * a2) % m2\n\t\tif c == 0: b3 = (b3 * a3) % m3\n\t\tn += 1\n\t\tif a == 0 and b1 == 1: a = n\n\t\tif b == 0 and b2 == 1: b = n\n\t\tif c == 0 and b3 == 1: c = n\n\t\tif a != 0 and b != 0 and c != 0: break\n\t\n\tans = a // gcd(a,b) * b\n\tans = ans // gcd(ans, c) * c\n\tprint(ans)\n\n", "sampled": "import math\nfrom functools import reduce\n\ndef gcd(a, b):\n    while b:\n        a, b = b, a % b\n    return a\n\ndef lcm(a, b):\n    return a * b // gcd(a, b)\n\ndef order_mod(a, m):\n    \"\"\"Find the multiplicative order of a modulo m\"\"\"\n    if gcd(a, m) != 1:\n        return -1\n    \n    order = 1\n    current = a % m\n    while current != 1:\n        current = (current * a) % m\n        order += 1\n    return order\n\nwhile True:\n    line = list(map(int, input().split()))\n    if line == [0, 0, 0, 0, 0, 0]:\n        break\n    \n    a1, m1, a2, m2, a3, m3 = line\n    \n    # Find the order of each coordinate\n    order1 = order_mod(a1, m1)\n    order2 = order_mod(a2, m2)\n    order3 = order_mod(a3, m3)\n    \n    # The minimum number of moves is the LCM of the three orders\n    result = lcm(lcm(order1, order2), order3)\n    print(result)\n", "perturbed_sampled": ["import  def gcd(a, b): while b: a, b = b, a % b   gcd(a,  a  order = 1 current = a % m while current != 1: current =  order += 1 return order while True: line = list(map(int,  0]: break a1, m1,   = order_mod(a3, m3) #  = lcm(lcm(order1, order2), order3) print(result)"], "perturbed_original": ["  import  =   if a == 0:  % m1 if b == 0:  %  b3 = (b3  == 0 and b1 == 1: a =  and b2 == 1: b = n if c == 0 and b3 ==  a != 0 and b  0: break ans = a  c) * c print(ans)"], "original_ll": -1.0804803371429443, "sampled_ll": -0.7357021570205688, "all_perturbed_sampled_ll": [-3.217597246170044], "all_perturbed_original_ll": [-3.3313002586364746], "perturbed_sampled_ll": -3.217597246170044, "perturbed_original_ll": -3.3313002586364746, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n\nint i,j,k,h,w,min,ans,mat[700][700],max[700][700];\nchar c;\n\nint main(){\n\twhile(scanf(\"%d %d\",&h,&w)*h*w){\n\t\tfor(i=0;i<h;i++){\n\t\t\tk=0;\n\t\t\tscanf(\"\\n\");\n\t\t\tfor(j=0;j<w;j++){\n\t\t\t\tscanf(\"%c\",&c);\n\t\t\t\tif(c=='.')k++; else k=0;\n\t\t\t\tmat[i][j]=k;\n\t\t\t}\n\t\t}\n\n\t\tans=0;\n\t\tfor(j=w-1;j>=0;j--){\n\t\t\tfor(k=h-1;k>=0;k--){\n\t\t\t\tmin=mat[k][j];\n\t\t\t\tfor(i=1;i+k<h;i++){\n\t\t\t\t\tif(min>mat[i+k][j])min=mat[i+k][j];\n\t\t\t\t\tif(min==0)break;\n\t\t\t\t\tif(min*(i+1)>ans)ans=min*(i+1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\",ans);\n\t}\n\treturn 0;\n}", "sampled": "#include <stdio.h>\n#include <string.h>\n\nint main() {\n    int H, W;\n    char grid[505][505];\n    int height[505][505];\n    \n    while (scanf(\"%d %d\", &H, &W) == 2 && (H || W)) {\n        for (int i = 0; i < H; i++) {\n            scanf(\"%s\", grid[i]);\n        }\n        \n        // Calculate height array\n        memset(height, 0, sizeof(height));\n        for (int i = 0; i < H; i++) {\n            for (int j = 0; j < W; j++) {\n                if (grid[i][j] == '.') {\n                    if (i == 0) {\n                        height[i][j] = 1;\n                    } else {\n                        height[i][j] = height[i-1][j] + 1;\n                    }\n                } else {\n                    height[i][j] = 0;\n                }\n            }\n        }\n        \n        int maxArea = 0;\n        \n        // For each row, find largest rectangle in histogram\n        for (int i = 0; i < H; i++) {\n            // For each column as left boundary\n            for (int left = 0; left < W; left++) {\n                if (height[i][left] == 0) continue;\n                \n                int minHeight = height[i][left];\n                for (int right = left; right < W; right++) {\n                    if (height[i][right] == 0) break;\n                    \n                    if (height[i][right] < minHeight) {\n                        minHeight = height[i][right];\n                    }\n                    \n                    int width = right - left + 1;\n                    int area = minHeight * width;\n                    if (area > maxArea) {\n                        maxArea = area;\n                    }\n                }\n            }\n        }\n        \n        printf(\"%d\\n\", maxArea);\n    }\n    \n    return 0;\n}\n", "perturbed_sampled": ["#include <stdio.h>  grid[505][505]; int height[505][505]; while (scanf(\"%d %d\", &H,  (int  H; i++) { scanf(\"%s\", grid[i]); } //  sizeof(height)); for (int i = 0; i <  0)  height[i-1][j] + 1;  =  maxArea = 0; // For each row, find largest  i = 0; i < H; i++) { // For each column  left = 0; left < W; left++) { if (height[i][left] == 0) continue; int  right  minHeight = height[i][right]; } int   maxArea); } return 0; }"], "perturbed_original": ["#include <stdio.h>  i,j,k,h,w,min,ans,mat[700][700],max[700][700]; char c; int main(){ while(scanf(\"%d %d\",&h,&w)*h*w){  if(c=='.')k++; else k=0;  } printf(\"%d\\n\",ans); } return 0; }"], "original_ll": -1.0355095863342285, "sampled_ll": -0.5008054971694946, "all_perturbed_sampled_ll": [-2.2702434062957764], "all_perturbed_original_ll": [-2.2054483890533447], "perturbed_sampled_ll": -2.2702434062957764, "perturbed_original_ll": -2.2054483890533447, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import java.util.Scanner;\n\n//Rectangular Searching\npublic class Main{\n\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\twhile(true){\n\t\t\tint h = sc.nextInt();\n\t\t\tint w = sc.nextInt();\n\t\t\tif((h|w)==0)break;\n\t\t\tchar[][] m = new char[h][w];\n\t\t\tfor(int i=0;i<h;i++)m[i]=sc.next().toCharArray();\n\t\t\tint[][] c = new int[h][w];\n\t\t\tfor(int i=0;i<h;i++){\n\t\t\t\tint x = 1;\n\t\t\t\tfor(int j=w-1;j>=0;j--){\n\t\t\t\t\tif(m[i][j]=='.'){\n\t\t\t\t\t\tc[i][j] = x++;\n\t\t\t\t\t}\n\t\t\t\t\telse{\n\t\t\t\t\t\tc[i][j] = 0;\n\t\t\t\t\t\tx = 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tint max = 0;\n\t\t\tfor(int i=0;i<h;i++){\n\t\t\t\tfor(int j=0;j<w;j++){\n\t\t\t\t\tif(0<i&&c[i][j]==c[i-1][j]||c[i][j]==0)continue;\n\t\t\t\t\tint k = 1;\n\t\t\t\t\tint min = c[i][j];\n\t\t\t\t\tmax = Math.max(max, k*min);\n\t\t\t\t\twhile(i+k<h&&c[i+k][j]>0){\n\t\t\t\t\t\tmin = Math.min(min, c[i+k][j]);\n\t\t\t\t\t\tk++;\n\t\t\t\t\t\tmax = Math.max(max, k*min);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(max);\n\t\t}\n\t}\n}", "sampled": "import java.util.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        \n        while (true) {\n            int H = sc.nextInt();\n            int W = sc.nextInt();\n            \n            if (H == 0 && W == 0) break;\n            \n            sc.nextLine();\n            char[][] grid = new char[H][W];\n            \n            for (int i = 0; i < H; i++) {\n                String line = sc.nextLine();\n                for (int j = 0; j < W; j++) {\n                    grid[i][j] = line.charAt(j);\n                }\n            }\n            \n            int[][] height = new int[H][W];\n            \n            for (int j = 0; j < W; j++) {\n                for (int i = 0; i < H; i++) {\n                    if (grid[i][j] == '*') {\n                        height[i][j] = 0;\n                    } else {\n                        if (i == 0) {\n                            height[i][j] = 1;\n                        } else {\n                            height[i][j] = height[i-1][j] + 1;\n                        }\n                    }\n                }\n            }\n            \n            int maxArea = 0;\n            \n            for (int i = 0; i < H; i++) {\n                maxArea = Math.max(maxArea, largestRectangleInHistogram(height[i]));\n            }\n            \n            System.out.println(maxArea);\n        }\n        \n        sc.close();\n    }\n    \n    static int largestRectangleInHistogram(int[] heights) {\n        Stack<Integer> stack = new Stack<>();\n        int maxArea = 0;\n        int n = heights.length;\n        \n        for (int i = 0; i < n; i++) {\n            while (!stack.isEmpty() && heights[i] < heights[stack.peek()]) {\n                int h = heights[stack.pop()];\n                int w = stack.isEmpty() ? i : i - stack.peek() - 1;\n                maxArea = Math.max(maxArea, h * w);\n            }\n            stack.push(i);\n        }\n        \n        while (!stack.isEmpty()) {\n            int h = heights[stack.pop()];\n            int w = stack.isEmpty() ? n : n - stack.peek() - 1;\n            maxArea = Math.max(maxArea, h * w);\n        }\n        \n        return maxArea;\n    }\n}\n", "perturbed_sampled": ["import  public static void main(String[]  { int H = sc.nextInt();  (H  for (int i = 0; i < H; i++) {  { grid[i][j]  height =  W; j++) { for  < H; i++)  { height[i][j] = 0; } else  { height[i][j] =   i < H; i++) { maxArea = Math.max(maxArea, largestRectangleInHistogram(height[i]));    int maxArea = 0; int n = heights.length; for (int i   int h  stack.isEmpty() ? i : i  while (!stack.isEmpty()) { int  = stack.isEmpty() ? n : n - stack.peek() - 1; maxArea = Math.max(maxArea, h  } }"], "perturbed_original": ["import  Main{ public static void main(String[] args)  = sc.nextInt();  char[][] m  int[][] c = new int[h][w]; for(int i=0;i<h;i++){ int x  c[i][j] = x++; } else{ c[i][j] = 0;  =  while(i+k<h&&c[i+k][j]>0){ min  =  System.out.println(max); } } }"], "original_ll": -0.8140360116958618, "sampled_ll": -0.2861210107803345, "all_perturbed_sampled_ll": [-2.4623687267303467], "all_perturbed_original_ll": [-2.62162184715271], "perturbed_sampled_ll": -2.4623687267303467, "perturbed_original_ll": -2.62162184715271, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "from itertools import product\nwhile(True):\n    H,W = map(int,input().split())\n    if not H: break\n    ma = 0\n    for i in range(H):\n        ma |= (int(input().replace(\".\",\"0\").replace(\"*\",\"1\"),2) << ((H-i-1)*W))\n    flag = False\n    hw = [[h,w] for h,w in product(range(H,0,-1),range(W,0,-1))]\n    hw = sorted(hw,key=lambda x: -x[1]*x[0])\n    ans = 0\n    for h,w in hw:\n        for i,j in product(range(H-h+1),range(W-w+1)):\n            b = (sum([((2**w-1) << j) << k*W for k in range(h)]) ) << i*W\n            c = ma&b\n            if not c :flag = True; ans = max(ans,h*w); break\n        else:\n            continue\n        if flag: break\n    print(ans)\n\n", "sampled": "def maximal_rectangle(matrix):\n    if not matrix or not matrix[0]:\n        return 0\n    \n    H = len(matrix)\n    W = len(matrix[0])\n    \n    # Build height matrix\n    heights = [[0] * W for _ in range(H)]\n    \n    for j in range(W):\n        for i in range(H):\n            if matrix[i][j] == '.':\n                if i == 0:\n                    heights[i][j] = 1\n                else:\n                    heights[i][j] = heights[i-1][j] + 1\n            else:\n                heights[i][j] = 0\n    \n    # Find max rectangle for each row using histogram method\n    max_area = 0\n    \n    for i in range(H):\n        max_area = max(max_area, largest_rectangle_in_histogram(heights[i]))\n    \n    return max_area\n\ndef largest_rectangle_in_histogram(heights):\n    stack = []\n    max_area = 0\n    index = 0\n    \n    while index < len(heights):\n        if not stack or heights[index] >= heights[stack[-1]]:\n            stack.append(index)\n            index += 1\n        else:\n            top = stack.pop()\n            width = index if not stack else index - stack[-1] - 1\n            area = heights[top] * width\n            max_area = max(max_area, area)\n    \n    while stack:\n        top = stack.pop()\n        width = index if not stack else index - stack[-1] - 1\n        area = heights[top] * width\n        max_area = max(max_area, area)\n    \n    return max_area\n\nwhile True:\n    line = input().split()\n    H, W = int(line[0]), int(line[1])\n    \n    if H == 0 and W == 0:\n        break\n    \n    matrix = []\n    for _ in range(H):\n        row = input().strip()\n        matrix.append(row)\n    \n    result = maximal_rectangle(matrix)\n    print(result)\n", "perturbed_sampled": [" or  =  Build height matrix   i in  if i == 0: heights[i][j]  Find max rectangle for each row using histogram method max_area = 0 for i in range(H): max_area = max(max_area, largest_rectangle_in_histogram(heights[i])) return max_area def largest_rectangle_in_histogram(heights): stack =   stack.append(index) index += 1 else: top  1 area = heights[top] * width max_area  stack else index -  heights[top]  area) return  input().split()  and W ==  for _ in range(H): row =  print(result)"], "perturbed_original": ["from  H: break  in  ((H-i-1)*W)) flag = False hw =  hw = sorted(hw,key=lambda x:  h,w in hw: for i,j in product(range(H-h+1),range(W-w+1)): b    ma&b if not  continue if flag: break print(ans)"], "original_ll": -1.5882657766342163, "sampled_ll": -0.4644571542739868, "all_perturbed_sampled_ll": [-3.316249132156372], "all_perturbed_original_ll": [-4.16621208190918], "perturbed_sampled_ll": -3.316249132156372, "perturbed_original_ll": -4.16621208190918, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "#include<stdio.h>\n#define rep(i,n) for(i=0;i<n;i++)\nint min(int a,int b){return a<b?a:b;}\nint main(void)\n{\n  int n,m,mat[20][20],i,j,k,a,b,c,d;\n  scanf(\"%d%d\",&n,&m);\n  rep(i,n)rep(j,n)mat[i][j]=i-j?1<<21:0;\n  rep(i,m){\n    scanf(\"%d,%d,%d,%d\",&a,&b,&c,&d);a--,b--;\n    mat[a][b]=c;mat[b][a]=d;\n  }\n  rep(i,n)rep(j,n)rep(k,n)mat[j][k]=min(mat[j][k],mat[j][i]+mat[i][k]);\n  scanf(\"%d,%d,%d,%d\",&a,&b,&c,&d);a--,b--;\n  printf(\"%d\\n\",c-mat[a][b]-mat[b][a]-d);\n  return 0;\n}", "sampled": "#include <stdio.h>\n#include <string.h>\n#include <limits.h>\n\n#define MAX_N 21\n#define INF INT_MAX\n\nint n, m;\nint cost[MAX_N][MAX_N];\nint dist[MAX_N];\nint visited[MAX_N];\n\nvoid dijkstra(int start) {\n    for (int i = 1; i <= n; i++) {\n        dist[i] = INF;\n        visited[i] = 0;\n    }\n    dist[start] = 0;\n    \n    for (int i = 0; i < n; i++) {\n        int u = -1;\n        int minDist = INF;\n        for (int j = 1; j <= n; j++) {\n            if (!visited[j] && dist[j] < minDist) {\n                minDist = dist[j];\n                u = j;\n            }\n        }\n        \n        if (u == -1) break;\n        visited[u] = 1;\n        \n        for (int v = 1; v <= n; v++) {\n            if (cost[u][v] != INF && dist[u] != INF) {\n                if (dist[u] + cost[u][v] < dist[v]) {\n                    dist[v] = dist[u] + cost[u][v];\n                }\n            }\n        }\n    }\n}\n\nint main() {\n    scanf(\"%d\", &n);\n    scanf(\"%d\", &m);\n    \n    for (int i = 1; i <= n; i++) {\n        for (int j = 1; j <= n; j++) {\n            cost[i][j] = INF;\n        }\n    }\n    \n    for (int i = 0; i < m; i++) {\n        int a, b, c, d;\n        scanf(\"%d,%d,%d,%d\", &a, &b, &c, &d);\n        cost[a][b] = c;\n        cost[b][a] = d;\n    }\n    \n    int s, g, V, P;\n    scanf(\"%d,%d,%d,%d\", &s, &g, &V, &P);\n    \n    dijkstra(s);\n    int costToG = dist[g];\n    \n    dijkstra(g);\n    int costFromG = dist[s];\n    \n    int totalCost = costToG + costFromG + P;\n    int reward = V - totalCost;\n    \n    printf(\"%d\\n\", reward);\n    \n    return 0;\n}\n", "perturbed_sampled": ["#include <stdio.h> #include <string.h> #include <limits.h>  INT_MAX int n, m; int cost[MAX_N][MAX_N];  dijkstra(int  = 1; i <= n; i++) { dist[i]  }   n;  = 1;  if (!visited[j] && dist[j] < minDist)   (u == -1)  v <=  != INF) { if (dist[u]   } }  { scanf(\"%d\", &n); scanf(\"%d\", &m); for (int i = 1; i <= n; i++) {   m;  c,  &d); cost[a][b] = c; cost[b][a] =   costToG =   int reward = V - totalCost; printf(\"%d\\n\", reward); return 0; }"], "perturbed_original": ["#include<stdio.h> #define  b){return  n,m,mat[20][20],i,j,k,a,b,c,d; scanf(\"%d%d\",&n,&m);  rep(i,n)rep(j,n)rep(k,n)mat[j][k]=min(mat[j][k],mat[j][i]+mat[i][k]); scanf(\"%d,%d,%d,%d\",&a,&b,&c,&d);a--,b--; printf(\"%d\\n\",c-mat[a][b]-mat[b][a]-d); return 0; }"], "original_ll": -1.0346885919570923, "sampled_ll": -0.4420737624168396, "all_perturbed_sampled_ll": [-2.589003086090088], "all_perturbed_original_ll": [-1.9875351190567017], "perturbed_sampled_ll": -2.589003086090088, "perturbed_original_ll": -1.9875351190567017, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import java.util.Arrays;\nimport java.util.Scanner;\n\npublic class Main {\n\n\t/**\n\t * @param args\n\t */\n\tpublic static final int INF = Integer.MAX_VALUE;\n\tpublic static void main(String[] args) {\n\t\tdoIt();\n\t}\n\t\n\tpublic static void doIt(){\n\t\tScanner sc = new Scanner(System.in);\n\t\tint n = sc.nextInt();\n\t\t//int[][] d = new int[n][n]; \n\t\tint m = sc.nextInt();\n\t\tint[][] road = new int[m][4];\n\t\tfor(int i = 0; i < m; i++){\n\t\t\tString s = sc.next();\n\t\t\tString[] ss = s.split(\",\");\n\t\t\tfor(int j = 0; j < 4; j++){\n\t\t\t\troad[i][j] = Integer.parseInt(ss[j]);\n\t\t\t}\n\t\t}\n\t\tint[] input = new int[4];\n\t\tString s = sc.next();\n\t\tString[] ss = s.split(\",\");\n\t\tfor(int j = 0; j < 4; j++){\n\t\t\tinput[j] = Integer.parseInt(ss[j]);\n\t\t}\n\t\tint start = input[0];\n\t\tint goal = input[1];\n\t\t//start\u304b\u3089goal\u306e\u6700\u77ed\u8ddd\u96e2\u3092\u6c42\u3081\u308b\n\t\t//start\u304b\u3089\u306e\u8ddd\u96e2\n\t\tint[] d = new int[n];\n\t\tArrays.fill(d, INF);\n\t\td[start - 1] = 0;\n\t\twhile(true){\n\t\t\tboolean bChange = false;\n\t\t\t//\u9053\u3092\u898b\u3066\u3044\u304f\n\t\t\tfor(int i = 0; i < m; i++){\n\t\t\t\tint from = road[i][0];\n\t\t\t\tint to = road[i][1];\n\t\t\t\tint cost = road[i][2];\n\t\t\t\tif(d[from - 1] != INF && d[from - 1] + cost < d[to - 1]){\n\t\t\t\t\td[to - 1] = d[from - 1] + cost;\n\t\t\t\t\tbChange = true;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t\n\t\t\t\tfrom = road[i][1];\n\t\t\t\tto = road[i][0];\n\t\t\t\tcost = road[i][3];\n\t\t\t\tif(d[from - 1] != INF && d[from - 1] + cost < d[to - 1]){\n\t\t\t\t\td[to - 1] = d[from - 1] + cost;\n\t\t\t\t\tbChange = true;\n\t\t\t\t}\n\t\t\t}\n\t\t\t//print(d);\n\t\t\tif(bChange == false) break;\n\t\t}\n\t\tint sum = d[goal - 1];\n\t\t\n\t\t//\u4eca\u5ea6\u306f\u30b4\u30fc\u30eb\u304b\u3089\u30b9\u30bf\u30fc\u30c8\u307e\u3067\u306e\u6700\u77ed\u8ddd\u96e2\n\t\tstart = input[1];\n\t\tgoal = input[0];\n\t\tArrays.fill(d, INF);\n\t\td[start - 1] = 0;\n\t\twhile(true){\n\t\t\tboolean bChange = false;\n\t\t\t//\u9053\u3092\u898b\u3066\u3044\u304f\n\t\t\tfor(int i = 0; i < m; i++){\n\t\t\t\tint from = road[i][0];\n\t\t\t\tint to = road[i][1];\n\t\t\t\tint cost = road[i][2];\n\t\t\t\tif(d[from - 1] != INF && d[from - 1] + cost < d[to - 1]){\n\t\t\t\t\td[to - 1] = d[from - 1] + cost;\n\t\t\t\t\tbChange = true;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t\n\t\t\t\tfrom = road[i][1];\n\t\t\t\tto = road[i][0];\n\t\t\t\tcost = road[i][3];\n\t\t\t\tif(d[from - 1] != INF && d[from - 1] + cost < d[to - 1]){\n\t\t\t\t\td[to - 1] = d[from - 1] + cost;\n\t\t\t\t\tbChange = true;\n\t\t\t\t}\n\t\t\t}\n\t\t\t//print(d);\n\t\t\tif(bChange == false) break;\n\t\t}\n\t\t//System.out.println(d[goal - 1]);\n\t\tsum += d[goal - 1];\n\t\t\n\t\tSystem.out.println(input[2] - input[3] - sum);\n\t\t\n\t}\n\t\n\tpublic static void print(int[] d){\n\t\tfor(int a : d){\n\t\t\tSystem.out.print(a + \" \");\n\t\t}\n\t\tSystem.out.println();\n\t}\n\n}", "sampled": "import java.util.*;\n\npublic class Main {\n    static class Edge {\n        int to;\n        int cost;\n        \n        Edge(int to, int cost) {\n            this.to = to;\n            this.cost = cost;\n        }\n    }\n    \n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        \n        int n = sc.nextInt();\n        int m = sc.nextInt();\n        sc.nextLine();\n        \n        List<List<Edge>> graph = new ArrayList<>();\n        for (int i = 0; i <= n; i++) {\n            graph.add(new ArrayList<>());\n        }\n        \n        for (int i = 0; i < m; i++) {\n            String line = sc.nextLine();\n            String[] parts = line.split(\",\");\n            int a = Integer.parseInt(parts[0]);\n            int b = Integer.parseInt(parts[1]);\n            int c = Integer.parseInt(parts[2]);\n            int d = Integer.parseInt(parts[3]);\n            \n            graph.get(a).add(new Edge(b, c));\n            graph.get(b).add(new Edge(a, d));\n        }\n        \n        String[] lastLine = sc.nextLine().split(\",\");\n        int s = Integer.parseInt(lastLine[0]);\n        int g = Integer.parseInt(lastLine[1]);\n        int V = Integer.parseInt(lastLine[2]);\n        int P = Integer.parseInt(lastLine[3]);\n        \n        int[] distToG = dijkstra(graph, n, s, g);\n        int[] distFromG = dijkstra(graph, n, g, s);\n        \n        int minCost = distToG[g] + distFromG[s];\n        int reward = V - P - minCost;\n        \n        System.out.println(reward);\n        \n        sc.close();\n    }\n    \n    static int[] dijkstra(List<List<Edge>> graph, int n, int start, int end) {\n        int[] dist = new int[n + 1];\n        Arrays.fill(dist, Integer.MAX_VALUE);\n        dist[start] = 0;\n        \n        PriorityQueue<int[]> pq = new PriorityQueue<>((a, b) -> a[1] - b[1]);\n        pq.offer(new int[]{start, 0});\n        \n        while (!pq.isEmpty()) {\n            int[] curr = pq.poll();\n            int u = curr[0];\n            int d = curr[1];\n            \n            if (d > dist[u]) continue;\n            \n            for (Edge edge : graph.get(u)) {\n                int v = edge.to;\n                int newDist = dist[u] + edge.cost;\n                \n                if (newDist < dist[v]) {\n                    dist[v] = newDist;\n                    pq.offer(new int[]{v, newDist});\n                }\n            }\n        }\n        \n        return dist;\n    }\n}\n", "perturbed_sampled": ["import java.util.*; public class Main { static class Edge   = new Scanner(System.in); int n = sc.nextInt();  ArrayList<>()); } for (int i = 0; i < m; i++) {  parts = line.split(\",\"); int a = Integer.parseInt(parts[0]); int b  Integer.parseInt(parts[3]); graph.get(a).add(new Edge(b, c)); graph.get(b).add(new  =  int g = Integer.parseInt(lastLine[1]); int V = Integer.parseInt(lastLine[2]); int P  int[] distFromG  int minCost = distToG[g] + distFromG[s]; int reward = V -  } static int[] dijkstra(List<List<Edge>> graph,  end)  Integer.MAX_VALUE); dist[start] = 0; PriorityQueue<int[]> pq  int[]{start, 0}); while (!pq.isEmpty())  int u = curr[0];   (newDist < dist[v]) { dist[v]  }  }"], "perturbed_original": ["import java.util.Arrays; import java.util.Scanner; public class Main {  static  new Scanner(System.in); int n =  int[n][n]; int m = sc.nextInt(); int[][] road  =  String[] ss  j++){ road[i][j] =  = new int[4]; String s = sc.next(); String[] ss  0;   = input[1]; //start\u304b\u3089goal\u306e\u6700\u77ed\u8ddd\u96e2\u3092\u6c42\u3081\u308b //start\u304b\u3089\u306e\u8ddd\u96e2 int[] d = new int[n]; Arrays.fill(d,  0; while(true){ boolean bChange = false; //\u9053\u3092\u898b\u3066\u3044\u304f for(int i = 0; i < m; i++){  to   d[to -  d[from -   cost < d[to - 1]){ d[to - 1] = d[from -   == false) break; } int sum = d[goal  input[1]; goal =  1] = 0; while(true){ boolean bChange = false; //\u9053\u3092\u898b\u3066\u3044\u304f for(int i = 0;  to = road[i][1]; int cost =  bChange =   road[i][3]; if(d[from - 1] != INF  cost < d[to - 1]){  - 1] + cost; bChange   System.out.println(input[2] - input[3]  void print(int[] d){  + \" \"); } System.out.println(); } }"], "original_ll": -0.5172399878501892, "sampled_ll": -0.43150803446769714, "all_perturbed_sampled_ll": [-2.609140157699585], "all_perturbed_original_ll": [-2.6870174407958984], "perturbed_sampled_ll": -2.609140157699585, "perturbed_original_ll": -2.6870174407958984, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "def floyd(P,m):\n    for k in range(m):\n        for i in range(m):\n            for j in range(m):\n                P[i][j]=min(P[i][j],P[i][k]+P[k][j])\n\nn=input()\nm=input()\nINF=1e10\nC=[[INF]*n for i in range(n)]\nfor i in range(n):\n    C[i][i]=0\nfor i in range(m):\n    a1,b1,c1,d1=map(int,raw_input().split(\",\"))\n    C[a1-1][b1-1]=c1\n    C[b1-1][a1-1]=d1\nfloyd(C,n)\nx1,x2,y1,y2=map(int,raw_input().split(\",\"))\nprint y1-y2-C[x1-1][x2-1]-C[x2-1][x1-1]", "sampled": "import sys\nfrom collections import defaultdict\nimport heapq\n\ndef dijkstra(graph, start, n):\n    dist = [float('inf')] * (n + 1)\n    dist[start] = 0\n    pq = [(0, start)]\n    \n    while pq:\n        d, u = heapq.heappop(pq)\n        if d > dist[u]:\n            continue\n        for v, cost in graph[u]:\n            if dist[u] + cost < dist[v]:\n                dist[v] = dist[u] + cost\n                heapq.heappush(pq, (dist[v], v))\n    \n    return dist\n\nn = int(input())\nm = int(input())\n\ngraph_forward = defaultdict(list)\ngraph_backward = defaultdict(list)\n\nfor _ in range(m):\n    line = input().strip()\n    parts = line.split(',')\n    a = int(parts[0])\n    b = int(parts[1])\n    c = int(parts[2])\n    d = int(parts[3])\n    \n    graph_forward[a].append((b, c))\n    graph_backward[b].append((a, d))\n\nlast_line = input().strip()\nparts = last_line.split(',')\ns = int(parts[0])\ng = int(parts[1])\nV = int(parts[2])\nP = int(parts[3])\n\ndist_from_s = dijkstra(graph_forward, s, n)\ndist_from_g = dijkstra(graph_backward, g, n)\n\ntotal_cost = dist_from_s[g] + dist_from_g[s] + P\nreward = V - total_cost\n\nprint(reward)\n", "perturbed_sampled": [" defaultdict  n): dist = [float('inf')] * (n + 1) dist[start] = 0     = int(input()) graph_forward =  _ in range(m): line = input().strip() parts = line.split(',') a  = int(parts[3]) graph_forward[a].append((b, c)) graph_backward[b].append((a, d)) last_line =   = int(parts[3]) dist_from_s =   dist_from_s[g] + dist_from_g[s] + P reward = V - total_cost print(reward)"], "perturbed_original": ["def floyd(P,m): for k in range(m): for i in  range(n)] for i  C[b1-1][a1-1]=d1 floyd(C,n) x1,x2,y1,y2=map(int,raw_input().split(\",\")) print y1-y2-C[x1-1][x2-1]-C[x2-1][x1-1]"], "original_ll": -0.9487079977989197, "sampled_ll": -0.659919798374176, "all_perturbed_sampled_ll": [-3.0518808364868164], "all_perturbed_original_ll": [-2.5465054512023926], "perturbed_sampled_ll": -3.0518808364868164, "perturbed_original_ll": -2.5465054512023926, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "#include<stdio.h>\n\n#define MAX 100\nchar farm[MAX][MAX];\n\nvoid divide(int i, int j, int H, int W, char moji)\n{\n    if( farm[i][j] == moji ){\n        farm[i][j] = '+';\n        if( j + 1 < W ) divide(i, j + 1, H, W, moji);\n        if( i + 1 < H ) divide(i + 1, j, H, W, moji);\n        if( j - 1 >= 0 )divide(i, j - 1, H, W, moji);\n        if( i - 1 >= 0 )divide(i - 1, j, H, W, moji);\n    }\n}\n\nint main()\n{\n    int H, W, i, j, cnt;\n    while(1){\n        cnt = 0;\n        scanf(\"%d %d\", &H, &W);\n        if(H == 0 && W == 0) break;\n\n        for(i = 0; i < H; i++){\n            scanf(\"%s\", farm[i]);\n        }\n        for(i = 0; i < H; i++ ){\n            for(j = 0; j < W; j++){\n                if(farm[i][j] == '+') continue;\n                cnt++;\n                divide(i, j, H, W, farm[i][j]);\n            }\n        }\n        printf(\"%d\\n\", cnt);\n    }\n    return 0;\n}", "sampled": "#include <stdio.h>\n#include <string.h>\n\nchar grid[100][101];\nint visited[100][100];\nint H, W;\n\nvoid dfs(int i, int j, char c) {\n    if (i < 0 || i >= H || j < 0 || j >= W) return;\n    if (visited[i][j]) return;\n    if (grid[i][j] != c) return;\n    \n    visited[i][j] = 1;\n    \n    dfs(i-1, j, c);\n    dfs(i+1, j, c);\n    dfs(i, j-1, c);\n    dfs(i, j+1, c);\n}\n\nint main() {\n    while (1) {\n        scanf(\"%d %d\", &H, &W);\n        if (H == 0 && W == 0) break;\n        \n        for (int i = 0; i < H; i++) {\n            scanf(\"%s\", grid[i]);\n        }\n        \n        memset(visited, 0, sizeof(visited));\n        \n        int count = 0;\n        for (int i = 0; i < H; i++) {\n            for (int j = 0; j < W; j++) {\n                if (!visited[i][j]) {\n                    dfs(i, j, grid[i][j]);\n                    count++;\n                }\n            }\n        }\n        \n        printf(\"%d\\n\", count);\n    }\n    \n    return 0;\n}\n", "perturbed_sampled": ["#include <stdio.h> #include <string.h> char grid[100][101];   char c) { if  < 0 ||  (visited[i][j]) return; if (grid[i][j] != c) return; visited[i][j] = 1; dfs(i-1, j, c); dfs(i+1, j, c); dfs(i, j-1, c); dfs(i,   %d\", &H, &W); if  == 0) break; for (int  j <  {  } } printf(\"%d\\n\", count); } return 0; }"], "perturbed_original": [" farm[MAX][MAX]; void divide(int i, int  farm[i][j] == moji ){  + 1 < W ) divide(i,  moji); if( i + 1 < H ) divide(i   >= 0 )divide(i, j - 1, H,  1 >= 0 )divide(i -   j,    0) break; for(i = 0; i <   '+') continue; cnt++;  } return 0; }"], "original_ll": -0.5867226719856262, "sampled_ll": -0.3324683606624603, "all_perturbed_sampled_ll": [-1.9677796363830566], "all_perturbed_original_ll": [-3.4934818744659424], "perturbed_sampled_ll": -1.9677796363830566, "perturbed_original_ll": -3.4934818744659424, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import java.io.*;\nimport java.util.*;\n\npublic class Main{\n\tpublic static void main(String args[]){\n\t\ttry{\n\t\t\tnew Main();\n\t\t}catch(IOException err){\n\t\t\terr.printStackTrace();\n\t\t}\n\t}\n\t\n\tint[][] offset = new int[][]{\n\t\t\t{-1, 0}, {1, 0}, {0, -1}, {0, 1}\n\t};\n\n\n\tpublic Main() throws IOException, StackOverflowError{\n\t\tBufferedReader in = new BufferedReader(new InputStreamReader(System.in));\n\t\tList<Integer> Ans = new ArrayList<Integer>();\n\t\tString line = in.readLine();\n\t\tString[] dst = line.split(\" \");\n\t\tInteger.parseInt(dst[0]);\n\n\t\t\n\t}\n\n\tpublic void grouping(int[][] data, int[][] label, int x, int y){\n\t\tList<point> cue = new ArrayList<point>();\n\t\tcue.add(new point(x, y));\n\t\twhile(cue.size() != 0){\n\t\t\tpoint p = cue.get(0);\n\t\t\tcue.remove(0);\n\t\t\tfor(int d=0; d<4; d++){\n\t\t\t\tint xx = p.x + offset[d][0];\n\t\t\t\tint yy = p.y + offset[d][1];\n\t\t\t\tif(label[yy][xx] == 0 && data[yy][xx] == data[p.y][p.x]){\n\t\t\t\t\tlabel[yy][xx] = label[p.y][p.x];\n\t\t\t\t\tcue.add(new point(xx, yy));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nclass point{\n\tint x;\n\tint y;\n\t\n\tpublic point(int x, int y){\n\t\tthis.x = x;\n\t\tthis.y = y;\n\t}\n}", "sampled": "import java.util.*;\n\npublic class Main {\n    static int H, W;\n    static char[][] grid;\n    static boolean[][] visited;\n    static int[] dx = {-1, 1, 0, 0};\n    static int[] dy = {0, 0, -1, 1};\n    \n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        \n        while (true) {\n            H = sc.nextInt();\n            W = sc.nextInt();\n            \n            if (H == 0 && W == 0) break;\n            \n            grid = new char[H][W];\n            visited = new boolean[H][W];\n            \n            for (int i = 0; i < H; i++) {\n                String line = sc.next();\n                for (int j = 0; j < W; j++) {\n                    grid[i][j] = line.charAt(j);\n                }\n            }\n            \n            int count = 0;\n            for (int i = 0; i < H; i++) {\n                for (int j = 0; j < W; j++) {\n                    if (!visited[i][j]) {\n                        dfs(i, j, grid[i][j]);\n                        count++;\n                    }\n                }\n            }\n            \n            System.out.println(count);\n        }\n        \n        sc.close();\n    }\n    \n    static void dfs(int x, int y, char fruit) {\n        if (x < 0 || x >= H || y < 0 || y >= W) return;\n        if (visited[x][y]) return;\n        if (grid[x][y] != fruit) return;\n        \n        visited[x][y] = true;\n        \n        for (int i = 0; i < 4; i++) {\n            int nx = x + dx[i];\n            int ny = y + dy[i];\n            dfs(nx, ny, fruit);\n        }\n    }\n}\n", "perturbed_sampled": [" { static int H, W; static char[][] grid;  dx   0, -1, 1}; public static void  && W == 0) break;  = new boolean[H][W]; for (int i = 0; i  line =  0; j <  count = 0; for (int i = 0; i < H; i++) { for (int j = 0; j  (!visited[i][j]) {  }  static void dfs(int x,  if (x    x + dx[i];  dy[i]; dfs(nx, ny, fruit); } } }"], "perturbed_original": [" class Main{ public  err.printStackTrace(); } } int[][] offset = new int[][]{ {-1, 0},  1} }; public Main()   Ans = new ArrayList<Integer>(); String line =    != 0){ point p = cue.get(0); cue.remove(0); for(int d=0; d<4; d++){ int xx  label[yy][xx] = label[p.y][p.x]; cue.add(new  } } class point{ int x; int y; public point(int  } }"], "original_ll": -0.9950542449951172, "sampled_ll": -0.2508944571018219, "all_perturbed_sampled_ll": [-2.589790105819702], "all_perturbed_original_ll": [-3.35221004486084], "perturbed_sampled_ll": -2.589790105819702, "perturbed_original_ll": -3.35221004486084, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "def wa(h, w, f):\n    if not (0 <= h <= H-1 and 0 <= w <= W-1):\n        return\n    elif mapp[h][w] != f:\n        return\n    else:\n        mapp[h][w] = '$'\n        wa(h, w+1, f)\n        wa(h-1, w, f)\n        wa(h, w-1, f)\n        wa(h+1, w, f)\n\nwhile True:\n    H, W = map(int, raw_input().split(' '))\n    if H == 0: break\n    mapp = [list(raw_input()) for i in range(H)]\n    count = 0\n    for h in range(H):\n        for w in range(W):\n            if mapp[h][w] == '@':\n                wa(h, w, '@')\n            elif mapp[h][w] == '#':\n                wa(h, w, '#')\n            elif mapp[h][w] == '*':\n                wa(h, w, '*')\n            else:\n                continue\n            count += 1\n    else:\n        print count", "sampled": "def count_regions(H, W, grid):\n    visited = [[False] * W for _ in range(H)]\n    count = 0\n    \n    def dfs(i, j, fruit_type):\n        if i < 0 or i >= H or j < 0 or j >= W:\n            return\n        if visited[i][j]:\n            return\n        if grid[i][j] != fruit_type:\n            return\n        \n        visited[i][j] = True\n        dfs(i-1, j, fruit_type)\n        dfs(i+1, j, fruit_type)\n        dfs(i, j-1, fruit_type)\n        dfs(i, j+1, fruit_type)\n    \n    for i in range(H):\n        for j in range(W):\n            if not visited[i][j]:\n                dfs(i, j, grid[i][j])\n                count += 1\n    \n    return count\n\nwhile True:\n    line = input().split()\n    H, W = int(line[0]), int(line[1])\n    \n    if H == 0 and W == 0:\n        break\n    \n    grid = []\n    for _ in range(H):\n        grid.append(input().strip())\n    \n    result = count_regions(H, W, grid)\n    print(result)\n", "perturbed_sampled": ["def count_regions(H, W, not in<extra_id_4>] =<extra_id_5>j,<extra_id_6>visited [ j<extra_id_7>\" ] =<extra_id_8>count +=<extra_id_9>visited[i][j] : count<extra_id_6>] : count ,<extra_id_10>+= 1 return count<extra_id_11>1<extra_id_12>= 0<extra_id_13>count +=<extra_id_14>if visited[-1][j] in<extra_id_15>k = 0<extra_id_16>, j,<extra_id_17>i<extra_id_18>1 :<extra_id_19>for<extra_id_20>[<extra_id_21>j ] range(H)] count = 0 def dfs(i, j, fruit_type): if i < 0 or i >= H or j < 0 or  != fruit_type:  not visited[i][j]:  1 return count while True:  = int(line[0]), int(line[1]) if H == 0 and W == 0: break  print(result)"], "perturbed_original": ["def wa(h, w, f): if  w <= W-1):  return else:  f)  while True: H, W = map(int, raw_input().split(' ')) if H == 0: break mapp =  count  range(H): for w  '@': wa(h, w,    1 else: print count"], "original_ll": -0.7983009815216064, "sampled_ll": -0.4746793210506439, "all_perturbed_sampled_ll": [-2.4773383140563965], "all_perturbed_original_ll": [-3.621432304382324], "perturbed_sampled_ll": -2.4773383140563965, "perturbed_original_ll": -3.621432304382324, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "/*\nAizuOnline A0119\nTitle Taro's obsession\n*/\n#include <stdio.h>\n// Select Below\n//#include <stdlib.h>\n//#include <string.h>\n//#include <float.h>\n//#include <math.h>\n//#include <limits.h>\n//Global data section\n#define SHOUGENNO 100\n#define NINZUU 20\nint n,m;\nint x[SHOUGENNO],y[SHOUGENNO];\nint flag[NINZUU+1];\n//\nvoid show()\n{\n  int i;\n  for(i=1;i<=n;i++)\n    printf(\"%d:\",flag[i]);\n  printf(\"\\n\");\n}\nmain()\n{\n  int i,cnt;\n\n  scanf(\"%d \",&n);\n  scanf(\"%d \",&m);\n  for(i=0;i<m;i++)\n    scanf(\"%d %d\",&x[i],&y[i]);\n  for(i=0;i<n;i++)\n    flag[i]=0;\n\n  cnt=n;\n\n  while(cnt>1)\n    {\n      for(i=1;i<=n;i++)\n\tif(flag[i]>0)\n\t  flag[i]=0;\n      //show();\n      for(i=0;i<m;i++)\n\tif(flag[x[i]]!=-1)\n\t  flag[y[i]]=1;\n      for(i=1;i<=n;i++)\n\t{\n\t  if(flag[i]==0 && i!=2)\n\t    {\n\t      printf(\"%d\\n\",i);\n\t      cnt--;\n\t      flag[i]=-1;\n\t    }\n\t}\n      //show();\n    }\n  printf(\"2\\n\");\nreturn(0);\n}", "sampled": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nint main() {\n    int m, n;\n    scanf(\"%d\", &m);\n    scanf(\"%d\", &n);\n    \n    int adj[21][21] = {0};\n    int indegree[21] = {0};\n    \n    for (int i = 0; i < n; i++) {\n        int x, y;\n        scanf(\"%d %d\", &x, &y);\n        if (!adj[x][y]) {\n            adj[x][y] = 1;\n            indegree[y]++;\n        }\n    }\n    \n    int result[21];\n    int used[21] = {0};\n    int pos = 0;\n    \n    while (pos < m) {\n        for (int i = 1; i <= m; i++) {\n            if (used[i]) continue;\n            if (indegree[i] == 0) {\n                result[pos++] = i;\n                used[i] = 1;\n                for (int j = 1; j <= m; j++) {\n                    if (adj[i][j]) {\n                        indegree[j]--;\n                    }\n                }\n                break;\n            }\n        }\n    }\n    \n    for (int i = 0; i < m; i++) {\n        printf(\"%d\\n\", result[i]);\n    }\n    \n    return 0;\n}\n", "perturbed_sampled": ["#include <stdio.h> #include <stdlib.h> #include <string.h> int main() {  scanf(\"%d\",  int indegree[21] = {0}; for (int i = 0;  %d\",  adj[x][y]  int  int pos = 0; while (pos < m)   j <= m; j++) { if (adj[i][j]) { indegree[j]--;  }  { printf(\"%d\\n\", result[i]); } return 0; }"], "perturbed_original": ["/* AizuOnline   //#include <float.h> //#include <math.h> //#include <limits.h> //Global data section  20 int n,m; int x[SHOUGENNO],y[SHOUGENNO];  { int i; for(i=1;i<=n;i++) printf(\"%d:\",flag[i]); printf(\"\\n\"); } main() { int i,cnt;  scanf(\"%d %d\",&x[i],&y[i]); for(i=0;i<n;i++)  return(0); }"], "original_ll": -1.5200926065444946, "sampled_ll": -0.4678477644920349, "all_perturbed_sampled_ll": [-2.2844111919403076], "all_perturbed_original_ll": [-2.6901915073394775], "perturbed_sampled_ll": -2.2844111919403076, "perturbed_original_ll": -2.6901915073394775, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import java.util.Arrays;\nimport java.util.Comparator;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.Map;\nimport java.util.Scanner;\nimport java.util.Set;\n    \npublic class Main {\n    public static void main(String[] args) {\n        (new Main()).execute();\n    }\n    private void execute() {\n        Scanner sc = new Scanner(System.in);\n\n        int m = sc.nextInt();\n        int n = sc.nextInt();\n\n        ObsessionComparator comp = new ObsessionComparator(m);\n        for(int i = 0 ; i < n ; i++) {comp.add(sc.nextInt(), sc.nextInt());}\n        \n        Integer[] list = new Integer[m];\n        for(int i = 0 ; i < m ; i++) {list[i] = Integer.valueOf(i+1);}\n        \n        Arrays.sort(list, comp);\n        \n        for(Integer i : list){System.out.println(i);}\n        sc.close();\n    }\n    \n    private class ObsessionComparator implements Comparator<Integer> {\n    \tprivate Map<Integer, Set<Integer>> sortMap = new HashMap<Integer, Set<Integer>>();\n    \tprivate ObsessionComparator(int count) {\n    \t\tfor(int i = 1 ; i <= count ; i++) {\n    \t\t\tsortMap.put(Integer.valueOf(i), new HashSet<Integer>());\n    \t\t}\n    \t}\n\n    \tprivate void add(Integer x, Integer y) {\n    \t\tsortMap.get(x).add(y);\n    \t}\n    \tprivate boolean isSorted(Integer x, Integer y) {\n    \t\tif(sortMap.get(x).contains(y)) {\n    \t\t\treturn true;\n    \t\t} else if(sortMap.get(x).isEmpty()) {\n    \t\t\treturn false;\n    \t\t} else {\n    \t\t\tfor(Integer next : sortMap.get(x)) {\n    \t\t\t\tif(isSorted(next, y)){\n    \t\t\t\t\treturn true;\n    \t\t\t\t}\n    \t\t\t}\n    \t\t\treturn false;\n    \t\t}\n    \t}\n    \t\n    \t@Override\n\t\tpublic int compare(Integer arg0, Integer arg1) {\n    \t\treturn isSorted(arg0, arg1) ? -1 : 1;\n\t\t}\n    }\n}", "sampled": "import java.util.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int m = sc.nextInt();\n        int n = sc.nextInt();\n        \n        List<List<Integer>> graph = new ArrayList<>();\n        int[] indegree = new int[m + 1];\n        \n        for (int i = 0; i <= m; i++) {\n            graph.add(new ArrayList<>());\n        }\n        \n        for (int i = 0; i < n; i++) {\n            int x = sc.nextInt();\n            int y = sc.nextInt();\n            graph.get(x).add(y);\n            indegree[y]++;\n        }\n        \n        Queue<Integer> queue = new LinkedList<>();\n        for (int i = 1; i <= m; i++) {\n            if (indegree[i] == 0) {\n                queue.offer(i);\n            }\n        }\n        \n        List<Integer> result = new ArrayList<>();\n        while (!queue.isEmpty()) {\n            int current = queue.poll();\n            result.add(current);\n            \n            for (int next : graph.get(current)) {\n                indegree[next]--;\n                if (indegree[next] == 0) {\n                    queue.offer(next);\n                }\n            }\n        }\n        \n        for (int suspect : result) {\n            System.out.println(suspect);\n        }\n        \n        sc.close();\n    }\n}\n", "perturbed_sampled": ["import java.util.*; public  void  = new Scanner(System.in); int m = sc.nextInt(); int n = sc.nextInt(); List<List<Integer>> graph = new  { graph.add(new ArrayList<>()); } for (int i  i++) { int x = sc.nextInt(); int y = sc.nextInt(); graph.get(x).add(y); indegree[y]++; } Queue<Integer> queue =  = 1; i <= m;   int  { indegree[next]--;  sc.close(); } }"], "perturbed_original": [" java.util.HashMap;    main(String[] args) {    sc.nextInt(); int n = sc.nextInt(); ObsessionComparator  i = 0 ; i < n ; i++) {comp.add(sc.nextInt(), sc.nextInt());} Integer[] list = new Integer[m];  Arrays.sort(list, comp); for(Integer i  class ObsessionComparator implements Comparator<Integer>  for(int  <= count ; i++) { sortMap.put(Integer.valueOf(i), new HashSet<Integer>()); } } private  { sortMap.get(x).add(y); } private boolean isSorted(Integer  { return true; } else if(sortMap.get(x).isEmpty()) { return false;  } return false; } }  }"], "original_ll": -0.8189771771430969, "sampled_ll": -0.2850877046585083, "all_perturbed_sampled_ll": [-2.3740553855895996], "all_perturbed_original_ll": [-2.753120183944702], "perturbed_sampled_ll": -2.3740553855895996, "perturbed_original_ll": -2.753120183944702, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "def solve(a):\n\tif len(a) == m: return a\n\tfor i in M-set(a):\n\t\tfor x,y in xy:\n\t\t\tif x == i and y not in a: break\n\t\telse:\n\t\t\tr = solve([i]+a)\n\t\t\tif r: return r\nm = input()\nM = set(range(1,m+1))\nxy = [map(int,raw_input().split()) for i in range(input())]\nfor i in solve([]): print i", "sampled": "from collections import defaultdict, deque\n\ndef topological_sort(m, edges):\n    # Build adjacency list and in-degree count\n    graph = defaultdict(list)\n    in_degree = [0] * (m + 1)\n    \n    for x, y in edges:\n        graph[x].append(y)\n        in_degree[y] += 1\n    \n    # Find all nodes with in-degree 0\n    queue = deque()\n    for i in range(1, m + 1):\n        if in_degree[i] == 0:\n            queue.append(i)\n    \n    result = []\n    while queue:\n        # Pick the smallest numbered node (for consistency)\n        queue = deque(sorted(queue))\n        node = queue.popleft()\n        result.append(node)\n        \n        # Reduce in-degree for neighbors\n        for neighbor in graph[node]:\n            in_degree[neighbor] -= 1\n            if in_degree[neighbor] == 0:\n                queue.append(neighbor)\n    \n    return result\n\n# Read input\nm = int(input())\nn = int(input())\nedges = []\nfor _ in range(n):\n    x = int(input())\n    y = int(input())\n    edges.append((x, y))\n\n# Perform topological sort\norder = topological_sort(m, edges)\n\n# Output result\nfor suspect in order:\n    print(suspect)\n", "perturbed_sampled": [" def topological_sort(m, edges): # Build adjacency list and in-degree   += 1 # Find all nodes  deque() for i in range(1, m + 1): if in_degree[i]  Pick the  =  in graph[node]: in_degree[neighbor] -=  queue.append(neighbor) return result # Read input m   in  # Perform topological sort  Output result for suspect in order: print(suspect)"], "perturbed_original": ["def solve(a):  xy: if x  in a: break  r:  M = set(range(1,m+1)) xy = [map(int,raw_input().split()) for i in  print i"], "original_ll": -1.6689385175704956, "sampled_ll": -0.7054641246795654, "all_perturbed_sampled_ll": [-3.3529796600341797], "all_perturbed_original_ll": [-3.589073896408081], "perturbed_sampled_ll": -3.3529796600341797, "perturbed_original_ll": -3.589073896408081, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "#include <stdio.h>\n#include <string.h>\n#include <math.h>\n\n#define SQ(x) ((x) * (x))\n#define INF (100000000)\n#define EPS (1e-5)\n\ndouble len;\ndouble cake[12];\ndouble dp[1 << 12][12];\nint n;\n\ndouble min(double a, double b)\n{\n    return (b > a ? a : b);\n}\n\ndouble tsp(int bit, int now)\n{\n    int i;\n    double res;\n    \n    if (dp[bit][now] >= 0){\n        return (dp[bit][now]);\n    }\n    \n    if (bit == (1 << n) - 1 && now == 0){\n        return (dp[bit][now] = 0);\n    }\n    \n    res = INF;\n    for (i = 0; i < n; i++){\n        if (!((bit >> i) & 1)){\n            res = min(res, tsp(bit | (1 << i), i) + sqrt(SQ(cake[i] + cake[now]) - SQ(cake[i] - cake[now])));\n        }\n    }\n    \n    return (dp[bit][now] = res);\n}\n\nint main(void)\n{\n    int i, j;\n    \n    while (scanf(\"%lf\", &len) != EOF){\n        getchar();\n        n = 0;\n        while (1){\n            scanf(\"%lf\", &cake[n++]);\n            \n            if (getchar() == '\\n'){\n                break;\n            }\n        }\n        \n        for (i = 0; i < (1 << 12); i++){\n            for (j = 0; j < 12; j++){\n                dp[i][j] = -1 * INF;\n            }\n        }\n        \n        if (tsp(0, 0) < len + EPS){\n            printf(\"OK\\n\");\n        }\n        else {\n            printf(\"NA\\n\");\n        }\n    }\n    \n    return (0);\n}", "sampled": "#include <stdio.h>\n#include <stdlib.h>\n#include <math.h>\n#include <string.h>\n\nint n;\nint r[12];\nint perm[12];\nint used[12];\ndouble W;\n\ndouble calc_width(int *order, int len) {\n    if (len == 0) return 0;\n    if (len == 1) return 2.0 * r[order[0]];\n    \n    double pos[12];\n    pos[0] = r[order[0]];\n    \n    for (int i = 1; i < len; i++) {\n        double max_pos = r[order[i]];\n        \n        for (int j = 0; j < i; j++) {\n            double ri = r[order[i]];\n            double rj = r[order[j]];\n            double d = 2.0 * sqrt(ri * rj);\n            double candidate = pos[j] + d;\n            if (candidate > max_pos) {\n                max_pos = candidate;\n            }\n        }\n        \n        pos[i] = max_pos;\n    }\n    \n    double max_right = 0;\n    for (int i = 0; i < len; i++) {\n        double right = pos[i] + r[order[i]];\n        if (right > max_right) {\n            max_right = right;\n        }\n    }\n    \n    return max_right;\n}\n\nint try_permutation(int depth) {\n    if (depth == n) {\n        double width = calc_width(perm, n);\n        return width <= W + 1e-9;\n    }\n    \n    for (int i = 0; i < n; i++) {\n        if (!used[i]) {\n            used[i] = 1;\n            perm[depth] = i;\n            if (try_permutation(depth + 1)) {\n                return 1;\n            }\n            used[i] = 0;\n        }\n    }\n    \n    return 0;\n}\n\nint main() {\n    char line[1000];\n    \n    while (fgets(line, sizeof(line), stdin)) {\n        n = 0;\n        char *token = strtok(line, \" \\n\");\n        W = atof(token);\n        \n        while ((token = strtok(NULL, \" \\n\")) != NULL) {\n            r[n++] = atoi(token);\n        }\n        \n        if (n == 0) continue;\n        \n        memset(used, 0, sizeof(used));\n        \n        if (try_permutation(0)) {\n            printf(\"OK\\n\");\n        } else {\n            printf(\"NA\\n\");\n        }\n    }\n    \n    return 0;\n}\n", "perturbed_sampled": [" W; double calc_width(int  (len == 0) return 0;  2.0 * r[order[0]];  1; i < len; i++) { double max_pos = r[order[i]]; for (int j = 0; j   = 2.0  candidate = pos[j] +  { max_pos = candidate; } } pos[i] = max_pos;  for (int i  i++) { double right  (right  right; } } return max_right; } int try_permutation(int depth) { if (depth == n) {  i  (!used[i]) { used[i] = 1; perm[depth]  1)) {  0; } int main() { char line[1000];  while  =  sizeof(used)); if (try_permutation(0)) { printf(\"OK\\n\"); }  return 0; }"], "perturbed_original": ["#include <stdio.h> #include <string.h> #include  #define EPS (1e-5) double len; double cake[12]; double dp[1 << 12][12]; int n; double min(double     n; i++){ if (!((bit >> i) & 1)){ res = min(res, tsp(bit | (1 << i),  } } return (dp[bit][now] = res); }  j; while (scanf(\"%lf\", &len) != EOF){  } } for (i = 0; i < (1 << 12); i++){ for  -1 * INF; } } if  EPS){ printf(\"OK\\n\"); } else  (0); }"], "original_ll": -0.827989399433136, "sampled_ll": -0.6663442254066467, "all_perturbed_sampled_ll": [-2.7891318798065186], "all_perturbed_original_ll": [-2.519277572631836], "perturbed_sampled_ll": -2.7891318798065186, "perturbed_original_ll": -2.519277572631836, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import java.io.*;\nimport java.util.*;\n\npublic class Main{\n\tpublic static void main(String args[]){\n\t\ttry{\n\t\t\tnew Main();\n\t\t}catch(IOException err){\n\t\t\terr.printStackTrace();\n\t\t}\n\t}\n\n\tpublic Main() throws IOException{\n\t\tBufferedReader in = new BufferedReader(new InputStreamReader(System.in));\n\t\tArrayList<String> Ans = new ArrayList<String>();\n\t\tString line;\n\n\t\twhile((line = in.readLine()) != null){\n\t\t\tString[] dst = line.split(\" \");\n\t\t\tint size = Integer.parseInt(dst[0]);\n\n\t\t\tif(size == 0) break;\n\t\t\tint[] seq = new int[dst.length-1];\n\t\t\tint[] radius = new int[dst.length-1];\n\t\t\tfor(int i=1; i<dst.length; i++){\n\t\t\t\tradius[i-1] = Integer.parseInt(dst[i]);\n\t\t\t}\n\n\t\t\tfor(int i=0; i<dst.length-1; i++){\n\t\t\t\tseq[i] = i;\n\t\t\t}\n\n\t\t\tint ok = 0;\n\t\t\tdo{\n//\t\t\t\tfor(int i=0; i<seq.length; i++){\n//\t\t\t\t\tSystem.out.print(seq[i]);\n//\t\t\t\t}\n//\t\t\t\tSystem.out.println();\n\n\t\t\t\tdouble cakes = calcSize(radius, seq);\n\t\t\t\tif(size >= cakes){\n\t\t\t\t\tAns.add(\"OK\");\n\t\t\t\t\tok = 1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}while(nextArray(seq));\n\n\t\t\tif(ok == 0){\n\t\t\t\tAns.add(\"NA\");\n\t\t\t}\n\t\t}\n\n\t\tfor(int n=0; n<Ans.size(); n++){\n\t\t\tSystem.out.println(Ans.get(n));\n\t\t}\n\t}\n\n\tpublic boolean nextArray(int[] seq){\n\t\tint s = seq.length-1;\n\t\twhile(true){\n\t\t\tif(seq[s] > seq[s-1]){\n\t\t\t\tint min = seq[s];\n\t\t\t\tint index = s;\n\t\t\t\tfor(int n=s+1; n<seq.length; n++){\n\t\t\t\t\tif(min > seq[n] && seq[n] > seq[s-1]){\n\t\t\t\t\t\tmin = seq[n];\n\t\t\t\t\t\tindex = n;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tseq[index] = seq[s-1];\n\t\t\t\tseq[s-1] = min;\n\t\t\t\tArrays.sort(seq, s, seq.length-1);\n\t\t\t\treturn true;\n\n\t\t\t}else{\n\t\t\t\ts--;\n\t\t\t}\n\n\t\t\tif(s == 0){\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t}\n\n\tpublic double calcSize(int[] data, int[] seq){\n\t\tdouble sum = 0.0;\n\t\t\n\t\t\n\t\treturn sum;\n\t}\n}", "sampled": "import java.util.*;\nimport java.io.*;\n\npublic class Main {\n    static double EPS = 1e-9;\n    \n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        \n        while (sc.hasNext()) {\n            String line = sc.nextLine().trim();\n            if (line.isEmpty()) continue;\n            \n            String[] parts = line.split(\"\\\\s+\");\n            int W = Integer.parseInt(parts[0]);\n            \n            List<Integer> radii = new ArrayList<>();\n            for (int i = 1; i < parts.length; i++) {\n                radii.add(Integer.parseInt(parts[i]));\n            }\n            \n            int n = radii.size();\n            if (n == 0) {\n                System.out.println(\"OK\");\n                continue;\n            }\n            \n            boolean found = false;\n            int[] perm = new int[n];\n            for (int i = 0; i < n; i++) {\n                perm[i] = i;\n            }\n            \n            do {\n                double width = calculateWidth(radii, perm);\n                if (width <= W + EPS) {\n                    found = true;\n                    break;\n                }\n            } while (nextPermutation(perm));\n            \n            System.out.println(found ? \"OK\" : \"NA\");\n        }\n        \n        sc.close();\n    }\n    \n    static double calculateWidth(List<Integer> radii, int[] perm) {\n        int n = perm.length;\n        if (n == 0) return 0;\n        if (n == 1) return 2.0 * radii.get(perm[0]);\n        \n        double[] positions = new double[n];\n        positions[0] = radii.get(perm[0]);\n        \n        for (int i = 1; i < n; i++) {\n            double maxPos = radii.get(perm[i]);\n            \n            for (int j = 0; j < i; j++) {\n                double r1 = radii.get(perm[j]);\n                double r2 = radii.get(perm[i]);\n                double dist = 2.0 * Math.sqrt(r1 * r2);\n                double pos = positions[j] + dist;\n                maxPos = Math.max(maxPos, pos);\n            }\n            \n            positions[i] = maxPos;\n        }\n        \n        double minX = Double.MAX_VALUE;\n        double maxX = -Double.MAX_VALUE;\n        \n        for (int i = 0; i < n; i++) {\n            double r = radii.get(perm[i]);\n            minX = Math.min(minX, positions[i] - r);\n            maxX = Math.max(maxX, positions[i] + r);\n        }\n        \n        return maxX - minX;\n    }\n    \n    static boolean nextPermutation(int[] array) {\n        int i = array.length - 2;\n        while (i >= 0 && array[i] >= array[i + 1]) {\n            i--;\n        }\n        \n        if (i < 0) {\n            return false;\n        }\n        \n        int j = array.length - 1;\n        while (array[j] <= array[i]) {\n            j--;\n        }\n        \n        swap(array, i, j);\n        reverse(array, i + 1, array.length - 1);\n        \n        return true;\n    }\n    \n    static void swap(int[] array, int i, int j) {\n        int temp = array[i];\n        array[i] = array[j];\n        array[j] = temp;\n    }\n    \n    static void reverse(int[] array, int start, int end) {\n        while (start < end) {\n            swap(array, start, end);\n            start++;\n            end--;\n        }\n    }\n}\n", "perturbed_sampled": ["import java.util.*; import java.io.*; public class Main { static double  void  = new Scanner(System.in); while (sc.hasNext()) { String  new ArrayList<>(); for (int i = 1; i < parts.length; i++) { radii.add(Integer.parseInt(parts[i])); } int n = radii.size(); if  } do  int[] perm)  if (n == 0) return 0; if   new double[n]; positions[0] = radii.get(perm[0]); for (int i = 1; i  maxPos = radii.get(perm[i]); for (int j = 0;  double r1 = radii.get(perm[j]); double r2  2.0 * Math.sqrt(r1  positions[j] + dist; maxPos = Math.max(maxPos, pos); } positions[i] = maxPos; } double minX =  for (int i  i++)  - r);  -   (i >= 0 &&   while (array[j]  i + 1, array.length - 1); return true; } static void swap(int[]   = temp; } static void reverse(int[] array, int start, int   start++; end--; } } }"], "perturbed_original": ["import java.io.*; import java.util.*; public class Main{  public Main()  Ans  while((line = in.readLine()) != null){ String[]   0) break; int[] seq  i=1; i<dst.length; i++){  i=0;  0; do{ // for(int i=0; i<seq.length; i++){ // System.out.print(seq[i]); //  =  Ans.add(\"OK\"); ok = 1; break;  } } public boolean nextArray(int[] seq){  min  s; for(int n=s+1; n<seq.length; n++){  seq[n]; index = n;  seq[s-1]  return false; } } } public double calcSize(int[] data, int[]  return sum; } }"], "original_ll": -0.9014003872871399, "sampled_ll": -0.4328192472457886, "all_perturbed_sampled_ll": [-2.5152060985565186], "all_perturbed_original_ll": [-2.90796160697937], "perturbed_sampled_ll": -2.5152060985565186, "perturbed_original_ll": -2.90796160697937, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "# -*- coding: utf-8 -*-\n\"\"\"\nhttp://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=0120\n\n\"\"\"\nimport sys\nfrom sys import stdin\ninput = stdin.readline\n\n\ndef calc_width(cakes):\n    # ??\u00b1????????????????????????(?????????)????????????????????????????????????????\u00a8??????????\n    if len(cakes) == 1:\n        return cakes[0]*2\n\n    prev_r = cakes[0]\n    width = prev_r\n\n    for r in cakes[1:]:\n        h_diff = abs(prev_r - r)\n        w = ((prev_r + r)**2 - h_diff**2)**0.5\n        width += w\n        prev_r = r\n    width += cakes[-1]\n\n    return width\n\n\ndef main(args):\n    for line in sys.stdin:\n        data = [int(x) for x in line.strip().split()]\n        box_size = data[0]\n        temp = data[1:]\n        temp.sort()\n\n        # ??\u00b1??????????????????????????????????????????????????????????????????????????????\n        min_width = float('inf')\n\n        cakes = [temp[0]]\n        temp = temp[1:]\n        pick_large = True\n        while temp:\n            if pick_large:\n                pick = temp[-1]\n                temp = temp[:-1]\n                pick_large = False\n                diff_front = abs(pick - cakes[0])\n                diff_rear = abs(pick - cakes[-1])\n                if diff_front > diff_rear:\n                    cakes.insert(0, pick)\n                else:\n                    cakes.append(pick)\n            else:\n                pick = temp[0]\n                temp = temp[1:]\n                pick_large = True\n                diff_front = abs(pick - cakes[0])\n                diff_rear = abs(pick - cakes[-1])\n                if diff_front > diff_rear:\n                    cakes.insert(0, pick)\n                else:\n                    cakes.append(pick)\n\n        result = calc_width(cakes)\n        min_width = min(result, min_width)\n\n        if min_width <= box_size:\n            print('OK')\n        else:\n            print('NA')\n\n\nif __name__ == '__main__':\n    main(sys.argv[1:])\n    ", "sampled": "import sys\nimport math\nfrom itertools import permutations\n\ndef calc_distance(r1, r2):\n    # Distance between centers of two circles touching each other and both touching the bottom\n    return 2 * math.sqrt(r1 * r2)\n\ndef calc_width(radii):\n    if len(radii) == 0:\n        return 0\n    if len(radii) == 1:\n        return 2 * radii[0]\n    \n    # Position circles one by one\n    positions = [radii[0]]  # x-coordinate of center of each circle\n    \n    for i in range(1, len(radii)):\n        # Find the rightmost position where circle i can be placed\n        min_x = radii[i]  # At least this far from left wall\n        \n        for j in range(i):\n            # Must be at least calc_distance away from circle j\n            required_dist = calc_distance(radii[i], radii[j])\n            min_x = max(min_x, positions[j] + required_dist)\n        \n        positions.append(min_x)\n    \n    # Total width is rightmost position + its radius\n    return positions[-1] + radii[-1]\n\ndef solve(W, radii):\n    n = len(radii)\n    \n    if n == 0:\n        return \"OK\"\n    \n    # Try all permutations\n    for perm in permutations(radii):\n        width = calc_width(list(perm))\n        if width <= W:\n            return \"OK\"\n    \n    return \"NA\"\n\nfor line in sys.stdin:\n    parts = list(map(int, line.strip().split()))\n    W = parts[0]\n    radii = parts[1:]\n    print(solve(W, radii))\n", "perturbed_sampled": ["import sys import math from itertools   the bottom return 2 * math.sqrt(r1 *   2  one by  x-coordinate of center of each  len(radii)): # Find the rightmost position where circle i  this far from left wall for j in range(i): # Must  = calc_distance(radii[i], radii[j])  positions[-1]  n == 0: return \"OK\"  perm in permutations(radii): width  W: return \"OK\"  line.strip().split())) W = parts[0] radii = parts[1:] print(solve(W, radii))"], "perturbed_original": ["# -*- coding: utf-8 -*- \"\"\" http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=0120 \"\"\" import sys from sys import  width  h_diff**2)**0.5 width += w prev_r = r width += cakes[-1] return  float('inf')  temp[1:] pick_large = True while temp: if pick_large: pick =   diff_front   abs(pick - cakes[0]) diff_rear = abs(pick - cakes[-1]) if diff_front > diff_rear: cakes.insert(0,  calc_width(cakes) min_width = min(result, min_width) if min_width <= box_size: print('OK') else: print('NA') if __name__ == '__main__': main(sys.argv[1:])"], "original_ll": -1.0922144651412964, "sampled_ll": -1.2865324020385742, "all_perturbed_sampled_ll": [-4.125437259674072], "all_perturbed_original_ll": [-3.036956310272217], "perturbed_sampled_ll": -4.125437259674072, "perturbed_original_ll": -3.036956310272217, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "#include<iostream>\n#include<cstdio>\n#include<queue>\n#include<algorithm>\n#include<string>\n#include<vector>\n#include<cstdlib>\n\nusing namespace std;\n\n#define maxn 305\n\nint map[3][5];\n\nint main()\n{\n\tint i,j;\ncin>>i;\ncout<<1<<endl;\n\n\n\treturn 0;\n}\n\n", "sampled": "#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n\n#define MAX_STATES 362880\n\ntypedef struct {\n    int state[8];\n    int dist;\n} Node;\n\nint visited[MAX_STATES];\nNode queue[MAX_STATES];\nint front, rear;\n\nint encode(int state[8]) {\n    int code = 0;\n    int base = 1;\n    for (int i = 7; i >= 0; i--) {\n        int digit = state[i];\n        for (int j = i + 1; j < 8; j++) {\n            if (state[j] < state[i]) digit--;\n        }\n        code += digit * base;\n        base *= (8 - i);\n    }\n    return code;\n}\n\nint bfs(int start[8]) {\n    memset(visited, -1, sizeof(visited));\n    front = rear = 0;\n    \n    memcpy(queue[rear].state, start, sizeof(int) * 8);\n    queue[rear].dist = 0;\n    rear++;\n    \n    int start_code = encode(start);\n    visited[start_code] = 0;\n    \n    int goal[8] = {0, 1, 2, 3, 4, 5, 6, 7};\n    int goal_code = encode(goal);\n    \n    if (start_code == goal_code) return 0;\n    \n    while (front < rear) {\n        Node current = queue[front++];\n        \n        int pos0 = -1;\n        for (int i = 0; i < 8; i++) {\n            if (current.state[i] == 0) {\n                pos0 = i;\n                break;\n            }\n        }\n        \n        int row = pos0 / 4;\n        int col = pos0 % 4;\n        \n        int dr[] = {-1, 1, 0, 0};\n        int dc[] = {0, 0, -1, 1};\n        \n        for (int d = 0; d < 4; d++) {\n            int new_row = row + dr[d];\n            int new_col = col + dc[d];\n            \n            if (new_row >= 0 && new_row < 2 && new_col >= 0 && new_col < 4) {\n                int new_pos = new_row * 4 + new_col;\n                \n                int new_state[8];\n                memcpy(new_state, current.state, sizeof(int) * 8);\n                \n                int temp = new_state[pos0];\n                new_state[pos0] = new_state[new_pos];\n                new_state[new_pos] = temp;\n                \n                int new_code = encode(new_state);\n                \n                if (visited[new_code] == -1) {\n                    visited[new_code] = current.dist + 1;\n                    \n                    if (new_code == goal_code) {\n                        return current.dist + 1;\n                    }\n                    \n                    memcpy(queue[rear].state, new_state, sizeof(int) * 8);\n                    queue[rear].dist = current.dist + 1;\n                    rear++;\n                }\n            }\n        }\n    }\n    \n    return -1;\n}\n\nint main() {\n    int state[8];\n    \n    while (scanf(\"%d\", &state[0]) == 1) {\n        for (int i = 1; i < 8; i++) {\n            scanf(\"%d\", &state[i]);\n        }\n        \n        int result = bfs(state);\n        printf(\"%d\\n\", result);\n    }\n    \n    return 0;\n}\n", "perturbed_sampled": ["#include <stdio.h> #include <string.h> #include <stdlib.h> #define MAX_STATES 362880 typedef  dist; } Node; int visited[MAX_STATES]; Node queue[MAX_STATES]; int front, rear; int  = 0; int  >= 0; i--) { int digit = state[i]; for (int j =  8;  +=  -1,  0; memcpy(queue[rear].state, start, sizeof(int) * 8); queue[rear].dist  {0, 1, 2, 3, 4,  = encode(goal); if (start_code == goal_code) return 0; while (front < rear)    { pos0 =  dr[]  int dc[] = {0, 0, -1, 1}; for (int  4; d++) {  dr[d];  dc[d];   new_pos = new_row *  new_state[pos0]; new_state[pos0] = new_state[new_pos]; new_state[new_pos] = temp; int new_code = encode(new_state); if (visited[new_code] == -1) { visited[new_code] = current.dist  goal_code) { return  new_state, sizeof(int) *  } int main() { int state[8];   bfs(state); printf(\"%d\\n\", result); } return 0; }"], "perturbed_original": ["#include<iostream>  #include<cstdlib> using namespace std; #define   cout<<1<<endl; return 0; }"], "original_ll": -1.7629609107971191, "sampled_ll": -0.5100234746932983, "all_perturbed_sampled_ll": [-2.5216147899627686], "all_perturbed_original_ll": [-2.6424906253814697], "perturbed_sampled_ll": -2.5216147899627686, "perturbed_original_ll": -2.6424906253814697, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.LinkedList;\nimport java.util.Scanner;\n\npublic class Main {\n\tMyScanner sc = new MyScanner();\n\tScanner sc2 = new Scanner(System.in);\n\n\tvoid run() {\n\t\tHashMap<ArrayList<Integer>, Integer> hm = new HashMap<ArrayList<Integer>, Integer>();\n\t\tArrayList<Integer> list = new ArrayList<Integer>();\n\t\tfor (int i = 0; i < 8; i++) {\n\t\t\tlist.add(i);\n\t\t}\n\t\tint cnt = 0;\n\t\thm.put(list, cnt);\n\n\t\tLinkedList<ArrayList<Integer>> queue = new LinkedList<ArrayList<Integer>>();\n\t\tqueue.add(list);\n\t\twhile (!queue.isEmpty()) {\n\t\t\tint size = queue.size();\n\t\t\tfor (int i = 0; i < size; i++) {\n\t\t\t\tArrayList<Integer> l = queue.poll();\n\t\t\t\tint zeroIndex = 0;\n\t\t\t\tfor (int j = 0; j < 8; j++) {\n\t\t\t\t\tif (l.get(j) == 0) {\n\t\t\t\t\t\tzeroIndex = j;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (zeroIndex - 1 >= 0 && zeroIndex != 4) {\n\t\t\t\t\tArrayList<Integer> add = new ArrayList<Integer>(l);\n\t\t\t\t\tint t = l.get(zeroIndex);\n\t\t\t\t\tint r = l.get(zeroIndex - 1);\n\t\t\t\t\tadd.set(zeroIndex, r);\n\t\t\t\t\tadd.set(zeroIndex - 1, t);\n\t\t\t\t\tif (!hm.containsKey(add)) {\n\t\t\t\t\t\thm.put(add, cnt + 1);\n\t\t\t\t\t\tqueue.add(add);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (zeroIndex + 1 < 8 && zeroIndex != 3) {\n\t\t\t\t\tArrayList<Integer> add = new ArrayList<Integer>(l);\n\t\t\t\t\tint t = l.get(zeroIndex);\n\t\t\t\t\tint r = l.get(zeroIndex + 1);\n\t\t\t\t\tadd.set(zeroIndex, r);\n\t\t\t\t\tadd.set(zeroIndex + 1, t);\n\t\t\t\t\tif (!hm.containsKey(add)) {\n\t\t\t\t\t\thm.put(add, cnt + 1);\n\t\t\t\t\t\tqueue.add(add);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tArrayList<Integer> add = new ArrayList<Integer>(l);\n\t\t\t\tint t = l.get(zeroIndex);\n\t\t\t\tint r = l.get((zeroIndex + 4) % 8);\n\t\t\t\tadd.set(zeroIndex, r);\n\t\t\t\tadd.set((zeroIndex + 4) % 8, t);\n\t\t\t\tif (!hm.containsKey(add)) {\n\t\t\t\t\thm.put(add, cnt + 1);\n\t\t\t\t\tqueue.add(add);\n\t\t\t\t}\n\t\t\t}\n\t\t\tcnt++;\n\t\t}\n\t\twhile (sc2.hasNext()) {\n\t\t\tString input[] = sc2.nextLine().split(\" \");\n\t\t\tArrayList<Integer> in = new ArrayList<Integer>();\n\t\t\tfor (int i = 0; i < 8; i++) {\n\t\t\t\tin.add(Integer.valueOf(input[i]));\n\t\t\t}\n\t\t\tSystem.out.println(hm.get(in));\n\t\t}\n\t}\n\n\tboolean check(ArrayList<Integer> list) {\n\t\tboolean judge = true;\n\t\tfor (int i = 0; i < 8; i++) {\n\t\t\tif (list.get(i) != i) {\n\t\t\t\tjudge = false;\n\t\t\t}\n\t\t}\n\t\treturn judge;\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n\n\tvoid debug(Object... o) {\n\t\tSystem.out.println(Arrays.deepToString(o));\n\t}\n\n\tvoid debug2(int[][] array) {\n\t\tfor (int i = 0; i < array.length; i++) {\n\t\t\tfor (int j = 0; j < array[i].length; j++) {\n\t\t\t\tSystem.out.print(array[i][j]);\n\t\t\t}\n\t\t\tSystem.out.println();\n\t\t}\n\t}\n\n\tclass MyScanner {\n\t\tint nextInt() {\n\t\t\ttry {\n\t\t\t\tint c = System.in.read();\n\t\t\t\twhile (c != '-' && (c < '0' || '9' < c))\n\t\t\t\t\tc = System.in.read();\n\t\t\t\tif (c == '-')\n\t\t\t\t\treturn -nextInt();\n\t\t\t\tint res = 0;\n\t\t\t\tdo {\n\t\t\t\t\tres *= 10;\n\t\t\t\t\tres += c - '0';\n\t\t\t\t\tc = System.in.read();\n\t\t\t\t} while ('0' <= c && c <= '9');\n\t\t\t\treturn res;\n\t\t\t} catch (Exception e) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\n\t\tdouble nextDouble() {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\n\t\tString next() {\n\t\t\ttry {\n\t\t\t\tStringBuilder res = new StringBuilder(\"\");\n\t\t\t\tint c = System.in.read();\n\t\t\t\twhile (Character.isWhitespace(c))\n\t\t\t\t\tc = System.in.read();\n\t\t\t\tdo {\n\t\t\t\t\tres.append((char) c);\n\t\t\t\t} while (!Character.isWhitespace(c = System.in.read()));\n\t\t\t\treturn res.toString();\n\t\t\t} catch (Exception e) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t}\n\t}\n}", "sampled": "import java.util.*;\n\npublic class Main {\n    static final int[] TARGET = {0, 1, 2, 3, 4, 5, 6, 7};\n    static final int[][] MOVES = {{1}, {0, 2}, {1, 3}, {2}, {5}, {4, 6}, {5, 7}, {6}};\n    \n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        \n        while (sc.hasNextLine()) {\n            String line = sc.nextLine().trim();\n            if (line.isEmpty()) break;\n            \n            String[] parts = line.split(\"\\\\s+\");\n            int[] initial = new int[8];\n            for (int i = 0; i < 8; i++) {\n                initial[i] = Integer.parseInt(parts[i]);\n            }\n            \n            System.out.println(bfs(initial));\n        }\n        sc.close();\n    }\n    \n    static int bfs(int[] initial) {\n        if (Arrays.equals(initial, TARGET)) {\n            return 0;\n        }\n        \n        Queue<State> queue = new LinkedList<>();\n        Set<String> visited = new HashSet<>();\n        \n        State start = new State(initial, 0);\n        queue.offer(start);\n        visited.add(stateToString(initial));\n        \n        while (!queue.isEmpty()) {\n            State current = queue.poll();\n            \n            int zeroPos = -1;\n            for (int i = 0; i < 8; i++) {\n                if (current.board[i] == 0) {\n                    zeroPos = i;\n                    break;\n                }\n            }\n            \n            for (int nextPos : MOVES[zeroPos]) {\n                int[] newBoard = current.board.clone();\n                newBoard[zeroPos] = newBoard[nextPos];\n                newBoard[nextPos] = 0;\n                \n                if (Arrays.equals(newBoard, TARGET)) {\n                    return current.moves + 1;\n                }\n                \n                String stateStr = stateToString(newBoard);\n                if (!visited.contains(stateStr)) {\n                    visited.add(stateStr);\n                    queue.offer(new State(newBoard, current.moves + 1));\n                }\n            }\n        }\n        \n        return -1;\n    }\n    \n    static String stateToString(int[] board) {\n        StringBuilder sb = new StringBuilder();\n        for (int i = 0; i < 8; i++) {\n            sb.append(board[i]);\n        }\n        return sb.toString();\n    }\n    \n    static class State {\n        int[] board;\n        int moves;\n        \n        State(int[] board, int moves) {\n            this.board = board;\n            this.moves = moves;\n        }\n    }\n}\n", "perturbed_sampled": ["import  = {0, 1,  7}; static final int[][] MOVES = {{1}, {0,  {4,  static  while (sc.hasNextLine())  if  line.split(\"\\\\s+\");   } static int bfs(int[] initial)  return 0; }  Set<String> visited =  int zeroPos = -1; for (int i = 0; i < 8; i++) { if (current.board[i] == 0) { zeroPos =  { int[] newBoard = current.board.clone(); newBoard[zeroPos] = newBoard[nextPos]; newBoard[nextPos] =  return current.moves + 1; } String stateStr = stateToString(newBoard); if (!visited.contains(stateStr))  + 1)); }   =  int moves) { this.board = board; this.moves = moves; } } }"], "perturbed_original": ["import  import java.util.Scanner;  sc  = new  HashMap<ArrayList<Integer>, Integer>(); ArrayList<Integer> list =  =  cnt = 0; hm.put(list, cnt); LinkedList<ArrayList<Integer>> queue = new   (int i = 0;  ArrayList<Integer> l = queue.poll(); int   (l.get(j) == 0) { zeroIndex =  - 1 >= 0 && zeroIndex != 4) { ArrayList<Integer> add = new ArrayList<Integer>(l); int  add.set(zeroIndex, r); add.set(zeroIndex - 1,   }  t = l.get(zeroIndex); int r =  add.set(zeroIndex + 1, t);  +  int t = l.get(zeroIndex); int r = l.get((zeroIndex  r); add.set((zeroIndex + 4) % 8, t);  + 1); queue.add(add); } } cnt++; } while  i < 8; i++)  } boolean check(ArrayList<Integer> list) { boolean  i =  judge; } public static void main(String[] args) { new Main().run(); }  {  i   } class MyScanner {  int c = System.in.read(); while (c != '-' && (c   *=   (Exception e) { return -1;   res =  System.in.read(); while (Character.isWhitespace(c)) c  c); } while (!Character.isWhitespace(c = System.in.read())); return res.toString(); } catch (Exception e) { return null; } } } }"], "original_ll": -0.5006299018859863, "sampled_ll": -0.4328977167606354, "all_perturbed_sampled_ll": [-2.6069154739379883], "all_perturbed_original_ll": [-2.4905800819396973], "perturbed_sampled_ll": -2.6069154739379883, "perturbed_original_ll": -2.4905800819396973, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "from collections import deque\n\ndic = {}\ndic[(0,1,2,3,4,5,6,7)] = 0\n\n\nswap_dic = {0:(1, 4), 1:(0, 2, 5), 2:(1, 3, 6), 3:(2, 7),\n            4:(0, 5), 5:(1, 4, 6), 6:(2, 5, 7), 7:(3, 6)}\n\ndef swap(puz, i, j):\n  new = [k for k in puz]\n  new[i], new[j] = new[j], new[i]\n  return tuple(new)\n\nque = deque()\nque.append((0, (0,1,2,3,4,5,6,7)))\nwhile que:\n  score, puz = que.popleft()\n  score += 1\n  z_ind = puz.index(0)\n\n  for swap_ind in swap_dic[z_ind]:\n    new_puz = swap(puz, z_ind, swap_ind)\n    if not new_puz in dic:\n      dic[new_puz] = score\n      que.append((score, new_puz))\n\nwhile True:\n  try:\n    print(dic[tuple(map(int, input().split()))])\n  except EOFError:\n    break\n", "sampled": "from collections import deque\nimport sys\n\ndef solve(start):\n    goal = tuple(range(8))\n    if start == goal:\n        return 0\n    \n    visited = {start}\n    queue = deque([(start, 0)])\n    \n    while queue:\n        state, dist = queue.popleft()\n        \n        # Find position of 0\n        pos = state.index(0)\n        row = pos // 4\n        col = pos % 4\n        \n        # Try all 4 directions\n        moves = []\n        if col > 0:  # left\n            moves.append(pos - 1)\n        if col < 3:  # right\n            moves.append(pos + 1)\n        if row > 0:  # up\n            moves.append(pos - 4)\n        if row < 1:  # down\n            moves.append(pos + 4)\n        \n        for new_pos in moves:\n            new_state = list(state)\n            new_state[pos], new_state[new_pos] = new_state[new_pos], new_state[pos]\n            new_state = tuple(new_state)\n            \n            if new_state == goal:\n                return dist + 1\n            \n            if new_state not in visited:\n                visited.add(new_state)\n                queue.append((new_state, dist + 1))\n    \n    return -1\n\nfor line in sys.stdin:\n    line = line.strip()\n    if line:\n        nums = tuple(map(int, line.split()))\n        print(solve(nums))\n", "perturbed_sampled": ["from collections import deque  == goal: return 0 visited = {start} queue = deque([(start,  =   col = pos % 4 # Try all 4 directions moves  0: # left   + 1) if row >  tuple(new_state) if new_state  1 if new_state not in visited: visited.add(new_state) queue.append((new_state, dist +  in sys.stdin: line =  tuple(map(int, line.split())) print(solve(nums))"], "perturbed_original": ["from collections import deque   6), 6:(2, 5,  i,  k in puz] new[i], new[j] = new[j], new[i] return tuple(new) que = deque() que.append((0,    dic[new_puz] = score que.append((score, new_puz)) while True: try: print(dic[tuple(map(int, input().split()))]) except EOFError: break"], "original_ll": -0.92852383852005, "sampled_ll": -0.6551464200019836, "all_perturbed_sampled_ll": [-3.372326135635376], "all_perturbed_original_ll": [-3.173762321472168], "perturbed_sampled_ll": -3.372326135635376, "perturbed_original_ll": -3.173762321472168, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "#include <stdio.h>          // printf(), scanf()\n#include <stdbool.h>\n\n#define MAX_N 10\n#define MAX_M 10\n#define MAX_G 9\n\nint sx, sy;\nint n;\nint scx[MAX_N], scy[MAX_N];\n\nbool\nb_survival()\n{\n\tbool field[MAX_M][MAX_M];\n\tint px[MAX_G], py[MAX_G];\n\tstatic const int dx2[12] = {-1, 0, 1, 2, 2, 2,-1, 0, 1,-2,-2,-2};\n\tstatic const int dy2[12] = {-2,-2,-2,-1, 0, 1, 2, 2, 2,-1, 0, 1};\n\n\tint ix = 0;\n\tpx[ix] = sx, py[ix] = sy;\n\tix++;\n\n\tfor (int u = 0; u < n; ++u)\n\t{\n\t\tfor (int dy = -1; dy <= 1; ++dy)\n\t\t{\n\t\t\tfor (int dx = -1; dx <= 1; ++dx)\n\t\t\t{\n\t\t\t\tint nx = scx[u] + dx, ny = scy[u] + dy;\n\t\t\t\tif (0 <= nx && nx < MAX_M && 0 <= ny && ny < MAX_M)\n\t\t\t\t\tfield[ny][nx] = false;\n\t\t\t}\n\t\t}\n\n\t\tfor (int i = 0; i < ix; ++i)\n\t\t{\n\t\t\tfor (int j = 0; j < 12; ++j)\n\t\t\t{\n\t\t\t\tint nx = px[i] + dx2[j], ny = py[i] + dy2[j];\n\t\t\t\tif (0 <= nx && nx < MAX_M && 0 <= ny && ny < MAX_M)\n\t\t\t\t\tfield[ny][nx] = true;\n\t\t\t}\n\t\t}\n\n\t\tix = 0;\n\t\tfor (int dy = -1; dy <= 1; ++dy)\n\t\t{\n\t\t\tfor (int dx = -1; dx <= 1; ++dx)\n\t\t\t{\n\t\t\t\tint nx = scx[u] + dx, ny = scy[u] + dy;\n\t\t\t\tif (0 <= nx && nx < MAX_M && 0 <= ny && ny < MAX_M && field[ny][nx])\n\t\t\t\t{\n\t\t\t\t\tpx[ix] = nx;\n\t\t\t\t\tpy[ix] = ny;\n\t\t\t\t\tix++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (ix == 0)\n\t\t\treturn false;\n\t}\n\n\treturn true;\n}\n\nint\nmain(int argc, char **argv)\n{\n\tint lineno = 0;\n\twhile (true)\n\t{\n\t\tlineno++;\n\t\tscanf(\"%d%d\", &sx, &sy);\n\t\tif (sx == 0 && sy == 0)\n\t\t\tbreak;\n\n\t\tlineno++;\n\t\tscanf(\"%d\", &n);\n\n\t\tlineno++;\n\t\tfor (int i = 0; i < n; ++i)\n\t\t\tscanf(\"%d%d\", &scx[i], &scy[i]);\n\n\t\tprintf(\"%s\\n\", b_survival() ? \"OK\" : \"NA\");\n\t}\n\n\treturn 0;\n}", "sampled": "#include <stdio.h>\n#include <stdlib.h>\n\nint can_reach(int fx, int fy, int sx, int sy) {\n    int dx = abs(fx - sx);\n    int dy = abs(fy - sy);\n    \n    if ((dx == 2 && dy == 2) || (dx == 0 && dy == 3) || (dx == 3 && dy == 0)) {\n        return 1;\n    }\n    return 0;\n}\n\nint in_spray(int x, int y, int sx, int sy) {\n    int dx = abs(x - sx);\n    int dy = abs(y - sy);\n    \n    if (dx <= 1 && dy <= 1) {\n        return 1;\n    }\n    return 0;\n}\n\nint in_bounds(int x, int y) {\n    return x >= 0 && x <= 9 && y >= 0 && y <= 9;\n}\n\nint solve(int px, int py, int n, int sx[], int sy[]) {\n    int possible[10][10];\n    int next_possible[10][10];\n    \n    for (int i = 0; i < 10; i++) {\n        for (int j = 0; j < 10; j++) {\n            possible[i][j] = 0;\n        }\n    }\n    \n    for (int x = 0; x < 10; x++) {\n        for (int y = 0; y < 10; y++) {\n            if (can_reach(px, py, x, y) && in_bounds(x, y) && in_spray(x, y, sx[0], sy[0])) {\n                possible[x][y] = 1;\n            }\n        }\n    }\n    \n    for (int i = 1; i < n; i++) {\n        for (int x = 0; x < 10; x++) {\n            for (int y = 0; y < 10; y++) {\n                next_possible[x][y] = 0;\n            }\n        }\n        \n        for (int fx = 0; fx < 10; fx++) {\n            for (int fy = 0; fy < 10; fy++) {\n                if (possible[fx][fy]) {\n                    for (int tx = 0; tx < 10; tx++) {\n                        for (int ty = 0; ty < 10; ty++) {\n                            if (can_reach(fx, fy, tx, ty) && in_bounds(tx, ty) && in_spray(tx, ty, sx[i], sy[i])) {\n                                next_possible[tx][ty] = 1;\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        \n        for (int x = 0; x < 10; x++) {\n            for (int y = 0; y < 10; y++) {\n                possible[x][y] = next_possible[x][y];\n            }\n        }\n    }\n    \n    for (int x = 0; x < 10; x++) {\n        for (int y = 0; y < 10; y++) {\n            if (possible[x][y]) {\n                return 1;\n            }\n        }\n    }\n    \n    return 0;\n}\n\nint main() {\n    int px, py;\n    \n    while (scanf(\"%d %d\", &px, &py) == 2) {\n        if (px == 0 && py == 0) {\n            break;\n        }\n        \n        int n;\n        scanf(\"%d\", &n);\n        \n        int sx[10], sy[10];\n        for (int i = 0; i < n; i++) {\n            scanf(\"%d %d\", &sx[i], &sy[i]);\n        }\n        \n        if (solve(px, py, n, sx, sy)) {\n            printf(\"OK\\n\");\n        } else {\n            printf(\"NA\\n\");\n        }\n    }\n    \n    return 0;\n}\n", "perturbed_sampled": [" can_reach(int fx,  sy)   abs(fy - sy); if  == 2) || (dx == 0 && dy   return 0; }  int  sx); int dy =  1; } return 0;  y) { return x >= 0 && x <=  && y <=  int py, int n, int  (int i  i++)   { possible[i][j] = 0; } }  x  (int y = 0; y  (can_reach(px, py, x, y) && in_bounds(x, y) && in_spray(x, y, sx[0], sy[0])) { possible[x][y] = 1; } } } for (int i  i++)  0; x < 10;  fx++) { for (int fy = 0;  if (possible[fx][fy]) { for  < 10;  = 0;  ty) && in_bounds(tx,  sy[i]))  } for (int x = 0; x < 10; x++) { for (int y  y++) {    10; y++) { if (possible[x][y]) { return 1; }  %d\", &px,  (px == 0 && py == 0) { break;  int sx[10], sy[10];  {   sy))  0; }"], "perturbed_original": ["#include  { bool field[MAX_M][MAX_M]; int px[MAX_G], py[MAX_G]; static  0,  dy2[12] = {-2,-2,-2,-1, 0, 1, 2, 2, 2,-1,  0; px[ix] = sx, py[ix] =    { int nx  = scy[u] + dy; if  < MAX_M && 0 <=   for (int i = 0; i < ix; ++i) { for  < 12; ++j) { int nx =  py[i] + dy2[j]; if (0 <= nx && nx  ny  ix =  ++dy) { for (int dx = -1; dx <= 1; ++dx) { int nx =  field[ny][nx]) { px[ix] = nx;  } return true; } int main(int  (true) { lineno++; scanf(\"%d%d\",  0) break; lineno++; scanf(\"%d\", &n); lineno++; for (int i =  scanf(\"%d%d\",  \"OK\" : \"NA\"); } return 0; }"], "original_ll": -0.6900525093078613, "sampled_ll": -0.36025571823120117, "all_perturbed_sampled_ll": [-2.620293617248535], "all_perturbed_original_ll": [-2.7325196266174316], "perturbed_sampled_ll": -2.620293617248535, "perturbed_original_ll": -2.7325196266174316, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "\nimport java.util.ArrayDeque;\nimport java.util.Deque;\nimport java.util.Scanner;\n\npublic class Main {\n\tstatic int[] fy = { -2, -2, -2, -1, -1, 0, 0, 1, 1, 2, 2, 2 };\n\tstatic int[] fx = { -1, 0, 1, -2, 2, -2, 2, -2, 2, -1, 0, 1 };\n\n\tpublic static void main(String[] args) {\n\t\tScanner scanner = new Scanner(System.in);\n\t\twhile (true) {\n\t\t\tint kx = scanner.nextInt();\n\t\t\tint ky = scanner.nextInt();\n\t\t\tif (ky == 0 && kx == 0)\n\t\t\t\tbreak;\n\t\t\tint n = scanner.nextInt();\n\t\t\tint[][] num = new int[n][2];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tnum[i][0] = scanner.nextInt();\n\t\t\t\tnum[i][1] = scanner.nextInt();\n\t\t\t}\n\t\t\tDeque<int[]> deque = new ArrayDeque<int[]>();\n\t\t\tdeque.offer(new int[] { ky, kx });\n\t\t\tboolean flag = true;\n\t\t\tloop: for (int i = 0; i < n; i++) {\n\t\t\t\tint size = deque.size();\n\t\t\t\tDeque<int[]> dequetmp = new ArrayDeque<int[]>();\n\t\t\t\twhile (size-- > 0) {\n\t\t\t\t\tint[] m = deque.pop();\n\t\t\t\t\tslove(m, num[i], dequetmp);\n\t\t\t\t}\n\t\t\t\tif (dequetmp.isEmpty()) {\n\t\t\t\t\tflag = false;\n\t\t\t\t\tbreak loop;\n\t\t\t\t}\n\t\t\t\tdeque = dequetmp;\n\t\t\t}\n\t\t\tSystem.out.println(flag ? \"OK\" : \"NA\");\n\t\t}\n\n\t}\n\n\tprivate static void slove(int[] m, int[] num, Deque<int[]> dequetmp) {\n\t\tboolean[][] map = new boolean[14][14];\n\t\tfor (int i = 1; i < 4; i++) {\n\t\t\tfor (int j = 1; j < 4; j++) {\n\t\t\t\tint y = num[1] + i;\n\t\t\t\tint x = num[0] + j;\n\t\t\t\tif (2 <= y && y <= 12 && 2 <= x && x <= 12)\n\t\t\t\t\tmap[y][x] = true;\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < fy.length; i++) {\n\t\t\tint py = m[0] + fy[i] + 2;\n\t\t\tint px = m[1] + fx[i] + 2;\n\t\t\tif (map[py][px]) {\n\t\t\t\tpy -= 2;\n\t\t\t\tpx -= 2;\n\t\t\t\tboolean flag = true;\n\t\t\t\tfor (int[] t : dequetmp) {\n\t\t\t\t\tif (t[0] == py && t[1] == px) {\n\t\t\t\t\t\tflag = false;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (flag) {\n\t\t\t\t\tdequetmp.push(new int[] { py, px });\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}", "sampled": "import java.util.*;\n\npublic class Main {\n    static int[][] jumpOffsets = {\n        {-2, -1}, {-2, 1}, {-1, -2}, {-1, 2},\n        {1, -2}, {1, 2}, {2, -1}, {2, 1}\n    };\n    \n    static int[][] waterOffsets = {\n        {-1, -1}, {-1, 0}, {-1, 1},\n        {0, -1}, {0, 0}, {0, 1},\n        {1, -1}, {1, 0}, {1, 1}\n    };\n    \n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        \n        while (true) {\n            int px = sc.nextInt();\n            int py = sc.nextInt();\n            \n            if (px == 0 && py == 0) break;\n            \n            int n = sc.nextInt();\n            int[][] sprinklers = new int[n][2];\n            \n            for (int i = 0; i < n; i++) {\n                sprinklers[i][0] = sc.nextInt();\n                sprinklers[i][1] = sc.nextInt();\n            }\n            \n            if (canSurvive(px, py, sprinklers)) {\n                System.out.println(\"OK\");\n            } else {\n                System.out.println(\"NA\");\n            }\n        }\n        \n        sc.close();\n    }\n    \n    static boolean canSurvive(int px, int py, int[][] sprinklers) {\n        Set<String> currentPositions = new HashSet<>();\n        currentPositions.add(px + \",\" + py);\n        \n        for (int i = 0; i < sprinklers.length; i++) {\n            int sx = sprinklers[i][0];\n            int sy = sprinklers[i][1];\n            \n            Set<String> nextPositions = new HashSet<>();\n            \n            for (String posStr : currentPositions) {\n                String[] parts = posStr.split(\",\");\n                int x = Integer.parseInt(parts[0]);\n                int y = Integer.parseInt(parts[1]);\n                \n                for (int[] offset : jumpOffsets) {\n                    int nx = x + offset[0];\n                    int ny = y + offset[1];\n                    \n                    if (nx >= 0 && nx <= 9 && ny >= 0 && ny <= 9) {\n                        if (isInWaterRange(nx, ny, sx, sy)) {\n                            nextPositions.add(nx + \",\" + ny);\n                        }\n                    }\n                }\n            }\n            \n            if (nextPositions.isEmpty()) {\n                return false;\n            }\n            \n            currentPositions = nextPositions;\n        }\n        \n        return true;\n    }\n    \n    static boolean isInWaterRange(int x, int y, int sx, int sy) {\n        for (int[] offset : waterOffsets) {\n            if (sx + offset[0] == x && sy + offset[1] == y) {\n                return true;\n            }\n        }\n        return false;\n    }\n}\n", "perturbed_sampled": ["import java.util.*; public class Main  1},    -1}, {-1,  {0, 0}, {0, 1}, {1,  sc =  int px  0) break; int n = sc.nextInt(); int[][] sprinklers =  = 0; i < n; i++)  (canSurvive(px, py, sprinklers)) { System.out.println(\"OK\"); } else { System.out.println(\"NA\"); } } sc.close(); } static boolean canSurvive(int px,  Set<String> currentPositions = new HashSet<>();  for  int sx = sprinklers[i][0]; int sy  new  currentPositions) { String[] parts =  for (int[] offset : jumpOffsets) { int  int ny  (nx >= 0 && nx <= 9  ny <=   (nextPositions.isEmpty())  =  static  (sx + offset[0] == x && sy + offset[1] ==  } return false; } }"], "perturbed_original": ["import java.util.ArrayDeque; import java.util.Deque; import java.util.Scanner; public  fy =  -1, 0, 0,  =   public static void main(String[] args)  int  = scanner.nextInt(); if (ky == 0   0; i <   ArrayDeque<int[]>(); deque.offer(new int[] { ky, kx }); boolean flag  i = 0; i < n; i++) { int size  new ArrayDeque<int[]>(); while (size--  dequetmp); } if (dequetmp.isEmpty()) { flag = false; break loop; } deque = dequetmp;  static void slove(int[] m,   <  = num[1] + i; int x = num[0] + j; if (2 <= y && y <= 12 &&  <= 12)  i++) { int py =   fx[i] + 2; if (map[py][px]) { py -= 2; px -= 2; boolean flag = true;  false; break; }  } }"], "original_ll": -0.6362054347991943, "sampled_ll": -0.43334752321243286, "all_perturbed_sampled_ll": [-2.9556093215942383], "all_perturbed_original_ll": [-2.717759609222412], "perturbed_sampled_ll": -2.9556093215942383, "perturbed_original_ll": -2.717759609222412, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "R1=range(-2,3)\nR2=range(-1,2)\nA1=[(x,y) for x in R1 for y in R1 if 3<x**2+y**2<6]\nA2=[(x,y) for x in R2 for y in R2]\ndef fi(): return map(int,raw_input().split(\" \"))\ndef f(p,i):\n  x,y=p\n  A=[A1,A2][i>0]\n  return set([(x+dx,y+dy) for dx,dy in A if 0<=x+dx<10 and 0<=y+dy<10])\n\nwhile 1:\n  xf,yf=fi()\n  if yf==xf==0: break\n  raw_input()\n  tmp=fi()\n  PA=zip(tmp[0::2],tmp[1::2])\n  FA=set([(xf,yf)])\n  for ps in PA:\n    SA=f(ps,1)\n    tmp=set([])\n    for pf in FA: tmp=tmp|(SA&f(pf,0))\n    FA=tmp\n  print [\"NA\",\"OK\"][len(FA)>0]", "sampled": "import sys\nfrom collections import deque\n\ndef get_jump_positions(x, y):\n    \"\"\"Returns all valid positions that can be reached from (x, y) with one jump\"\"\"\n    jumps = [\n        (-2, -1), (-2, 1), (2, -1), (2, 1),\n        (-1, -2), (-1, 2), (1, -2), (1, 2)\n    ]\n    positions = []\n    for dx, dy in jumps:\n        nx, ny = x + dx, y + dy\n        if 0 <= nx <= 9 and 0 <= ny <= 9:\n            positions.append((nx, ny))\n    return positions\n\ndef get_water_positions(x, y):\n    \"\"\"Returns all positions covered by water from sprinkler at (x, y)\"\"\"\n    positions = set()\n    for dx in range(-2, 3):\n        for dy in range(-2, 3):\n            if abs(dx) + abs(dy) <= 2:\n                nx, ny = x + dx, y + dy\n                if 0 <= nx <= 9 and 0 <= ny <= 9:\n                    positions.add((nx, ny))\n    return positions\n\ndef solve(px, py, sprinklers):\n    n = len(sprinklers)\n    \n    # BFS to find if there's a path\n    # State: (current_position, sprinkler_index)\n    # We start by jumping from initial position when first sprinkler activates\n    \n    if n == 0:\n        return \"NA\"\n    \n    # Get all positions reachable from initial position\n    initial_jumps = get_jump_positions(px, py)\n    \n    # Check which of these positions are covered by first sprinkler\n    first_sprinkler_water = get_water_positions(sprinklers[0][0], sprinklers[0][1])\n    \n    # Queue: (position, sprinkler_index)\n    queue = deque()\n    visited = set()\n    \n    for pos in initial_jumps:\n        if pos in first_sprinkler_water:\n            queue.append((pos, 0))\n            visited.add((pos, 0))\n    \n    # If we reach the last sprinkler, we survived\n    while queue:\n        (x, y), spr_idx = queue.popleft()\n        \n        # If we're at the last sprinkler, we survived\n        if spr_idx == n - 1:\n            return \"OK\"\n        \n        # Try to jump to next sprinkler's water area\n        next_spr_idx = spr_idx + 1\n        next_water = get_water_positions(sprinklers[next_spr_idx][0], sprinklers[next_spr_idx][1])\n        \n        # Get all positions we can jump to\n        jump_positions = get_jump_positions(x, y)\n        \n        for next_pos in jump_positions:\n            if next_pos in next_water:\n                state = (next_pos, next_spr_idx)\n                if state not in visited:\n                    visited.add(state)\n                    queue.append(state)\n    \n    return \"NA\"\n\n# Read input\nwhile True:\n    line = input().split()\n    px, py = int(line[0]), int(line[1])\n    \n    if px == 0 and py == 0:\n        break\n    \n    n = int(input())\n    coords = list(map(int, input().split()))\n    \n    sprinklers = []\n    for i in range(n):\n        x = coords[2 * i]\n        y = coords[2 * i + 1]\n        sprinklers.append((x, y))\n    \n    result = solve(px, py, sprinklers)\n    print(result)\n", "perturbed_sampled": ["import sys from collections import deque def get_jump_positions(x, y):  can be reached from (x, y) with   -2), (1, 2) ] positions = [] for dx, dy in jumps:   0 <= nx  ny  \"\"\"Returns all positions covered by  y)\"\"\" positions = set() for dx in range(-2,  3): if abs(dx) + abs(dy)   dy  9  positions def solve(px, py, sprinklers): n =  if  #  which of these positions  # Queue: (position, sprinkler_index) queue = deque() visited = set() for pos  first_sprinkler_water: queue.append((pos, 0)) visited.add((pos, 0)) # If we  survived  = queue.popleft()  if spr_idx ==  all positions we can jump to jump_positions = get_jump_positions(x, y) for  in next_water: state   =   coords = list(map(int, input().split())) sprinklers = [] for  coords[2 * i] y = coords[2 * i + 1] sprinklers.append((x, y)) result = solve(px, py, sprinklers) print(result)"], "perturbed_original": [" in R1   map(int,raw_input().split(\" \")) def  for dx,dy in A if 0<=x+dx<10  if yf==xf==0:  for ps in PA: SA=f(ps,1)  tmp=tmp|(SA&f(pf,0)) FA=tmp print [\"NA\",\"OK\"][len(FA)>0]"], "original_ll": -1.726151943206787, "sampled_ll": -0.8041810393333435, "all_perturbed_sampled_ll": [-2.973634958267212], "all_perturbed_original_ll": [-4.626946449279785], "perturbed_sampled_ll": -2.973634958267212, "perturbed_original_ll": -4.626946449279785, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "#include<stdio.h>\n\nint main(){\n  float x,y;\n  \n  while(scanf(\"%f%f\",&x,&y)!=EOF){   \n    if(x<35.5&&y<71)\n      puts(\"AAA\");\n    else if(x<37.5&&y<77)\n      puts(\"AA\");\n    else if(x<40&&y<83)\n      puts(\"A\");\n    else if(x<43&&y<89)\n      puts(\"B\");\n    else if(x<50&&y<105)\n      puts(\"C\");\n    else if(x<55&&y<116)\n      puts(\"D\");\n    else if(x<70&&y<148)\n      puts(\"E\");\n    else\n      puts(\"NA\");\n  }\n  return 0;\n}", "sampled": "#include <stdio.h>\n\nint main() {\n    double t1, t2;\n    \n    while (scanf(\"%lf %lf\", &t1, &t2) == 2) {\n        if (t1 < 35.50 && t2 < 71.00) {\n            printf(\"AAA\\n\");\n        } else if (t1 < 37.50 && t2 < 77.00) {\n            printf(\"AA\\n\");\n        } else if (t1 < 40.00 && t2 < 83.00) {\n            printf(\"A\\n\");\n        } else if (t1 < 43.00 && t2 < 89.00) {\n            printf(\"B\\n\");\n        } else if (t1 < 50.00 && t2 < 105.00) {\n            printf(\"C\\n\");\n        } else if (t1 < 55.00 && t2 < 116.00) {\n            printf(\"D\\n\");\n        } else if (t1 < 70.00 && t2 < 148.00) {\n            printf(\"E\\n\");\n        } else {\n            printf(\"NA\\n\");\n        }\n    }\n    \n    return 0;\n}\n", "perturbed_sampled": ["#include <stdio.h>  t2; while (scanf(\"%lf %lf\", &t1, &t2)  < 35.50 && t2 < 71.00) {  <   printf(\"A\\n\"); } else  t2 < 89.00) { printf(\"B\\n\"); }  {  < 55.00 && t2 < 116.00)  t2 < 148.00) {  } } return 0; }"], "perturbed_original": ["#include<stdio.h> int main(){ float x,y;  if(x<50&&y<105) puts(\"C\"); else if(x<55&&y<116)  puts(\"NA\"); } return 0; }"], "original_ll": -0.9408214688301086, "sampled_ll": -0.5461478233337402, "all_perturbed_sampled_ll": [-2.0886940956115723], "all_perturbed_original_ll": [-2.253239870071411], "perturbed_sampled_ll": -2.0886940956115723, "perturbed_original_ll": -2.253239870071411, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import java.util.Scanner;\n\npublic class Main {\n\n\tpublic static void main(String[] args) {\n\t\tScanner sc=new Scanner(System.in);\n\t\tdouble eps=0.000000000000000001;\n\t\twhile(sc.hasNext()){\n\t\t\tdouble n=sc.nextDouble();\n\t\t\tdouble m=sc.nextDouble();\n\t\t\tif(n<35.5-eps && m<71.0-eps){\n\t\t\t\tSystem.out.println(\"AAA\");\n\t\t\t}\n\t\t\telse if(n<37.5-eps && m<77.0-eps){\n\t\t\t\tSystem.out.println(\"AA\");\n\t\t\t}\n\t\t\telse if(n<40.0-eps && m<83.0-eps){\n\t\t\t\tSystem.out.println(\"A\");\n\t\t\t}\n\t\t\telse if(n<43.0-eps && m<89.0-eps){\n\t\t\t\tSystem.out.println(\"B\");\n\t\t\t}\n\t\t\telse if(n<50.0-eps && m<105.0-eps){\n\t\t\t\tSystem.out.println(\"C\");\n\t\t\t}\n\t\t\telse if(n<55.0-eps && m<116.0-eps){\n\t\t\t\tSystem.out.println(\"D\");\n\t\t\t}\n\t\t\telse if(n<70.0-eps && m<148.0-eps){\n\t\t\t\tSystem.out.println(\"E\");\n\t\t\t}\n\t\t\telse{\n\t\t\t\tSystem.out.println(\"NA\");\n\t\t\t}\n\t\t}\n\t}\n\n}", "sampled": "import java.util.Scanner;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        \n        while (sc.hasNext()) {\n            double t1 = sc.nextDouble();\n            double t2 = sc.nextDouble();\n            \n            String result = \"NA\";\n            \n            if (t1 < 35.50 && t2 < 71.00) {\n                result = \"AAA\";\n            } else if (t1 < 37.50 && t2 < 77.00) {\n                result = \"AA\";\n            } else if (t1 < 40.00 && t2 < 83.00) {\n                result = \"A\";\n            } else if (t1 < 43.00 && t2 < 89.00) {\n                result = \"B\";\n            } else if (t1 < 50.00 && t2 < 105.00) {\n                result = \"C\";\n            } else if (t1 < 55.00 && t2 < 116.00) {\n                result = \"D\";\n            } else if (t1 < 70.00 && t2 < 148.00) {\n                result = \"E\";\n            }\n            \n            System.out.println(result);\n        }\n        \n        sc.close();\n    }\n}\n", "perturbed_sampled": ["import java.util.Scanner; public  Scanner sc = new Scanner(System.in);  =  && t2 < 71.00) { result = \"AAA\"; } else if (t1 < 37.50 && t2 <  } else if (t1  (t1 < 43.00 && t2  (t1  105.00) { result = \"C\"; } else if (t1  \"D\"; } else if  =  } }"], "perturbed_original": ["import java.util.Scanner;  static  sc=new  n=sc.nextDouble(); double m=sc.nextDouble(); if(n<35.5-eps && m<71.0-eps){ System.out.println(\"AAA\");  System.out.println(\"AA\"); } else if(n<40.0-eps && m<83.0-eps){ System.out.println(\"A\"); }  m<148.0-eps){ System.out.println(\"E\"); } else{ System.out.println(\"NA\"); } } } }"], "original_ll": -0.5994848012924194, "sampled_ll": -0.526497483253479, "all_perturbed_sampled_ll": [-2.050656318664551], "all_perturbed_original_ll": [-2.106247663497925], "perturbed_sampled_ll": -2.050656318664551, "perturbed_original_ll": -2.106247663497925, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "\n# 500 M\t1000 M\n# AAA \u7d1a\t35 \u79d2 50\t1 \u5206 11 \u79d2 00\n# AA \u7d1a\t37 \u79d2 50\t1 \u5206 17 \u79d2 00\n# A \u7d1a\t40 \u79d2 00\t1 \u5206 23 \u79d2 00\n# B \u7d1a\t43 \u79d2 00\t1 \u5206 29 \u79d2 00\n# C \u7d1a\t50 \u79d2 00\t1 \u5206 45 \u79d2 00\n# D \u7d1a\t55 \u79d2 00\t1 \u5206 56 \u79d2 00\n# E \u7d1a\t1\u520610 \u79d2 00\t2 \u5206 28 \u79d2 00\n\nranks = [\"AAA\",\"AA\",\"A\",\"B\",\"C\",\"D\",\"E\",\"NA\"]\ntimesA = [35.50,37.50,40,43,50,55,70]\ntimesB = [71,77,83,89,105,116,148]\n\nwhile(1):\n    try:\n        a,b = (float(x) for x in input().split())\n        rankA = rankB = 7\n        # checkA\n        for i in range(0,7):\n            if timesA[i] > a:\n                rankA = i\n                break\n        # checkB\n        for i in range(rankA,7):\n            if timesB[i] > b:\n                rankB = max(rankA,i)\n                break\n        print(ranks[rankB])\n    except:\n        break\n", "sampled": "import sys\n\ngrades = [\n    (\"AAA\", 35.50, 71.00),\n    (\"AA\", 37.50, 77.00),\n    (\"A\", 40.00, 83.00),\n    (\"B\", 43.00, 89.00),\n    (\"C\", 50.00, 105.00),\n    (\"D\", 55.00, 116.00),\n    (\"E\", 70.00, 148.00)\n]\n\nfor line in sys.stdin:\n    t1, t2 = map(float, line.strip().split())\n    \n    result = \"NA\"\n    for grade, time_500, time_1000 in grades:\n        if t1 < time_500 and t2 < time_1000:\n            result = grade\n            break\n    \n    print(result)\n", "perturbed_sampled": ["import sys  71.00), (\"AA\", 37.50, 77.00), (\"A\", 40.00,  \"NA\" for  if t1 < time_500 and t2 < time_1000: result = grade break print(result)"], "perturbed_original": ["# 500 M 1000 M # AAA \u7d1a 35 \u79d2 50 1 \u5206 11 \u79d2 00 # AA \u7d1a   1 \u5206 23  43  \u79d2   \u79d2   \u79d2 00 # E \u7d1a 1\u520610 \u79d2 00 2  = [\"AAA\",\"AA\",\"A\",\"B\",\"C\",\"D\",\"E\",\"NA\"] timesA = [35.50,37.50,40,43,50,55,70] timesB = [71,77,83,89,105,116,148] while(1):  in range(0,7): if timesA[i]   break"], "original_ll": -1.1890257596969604, "sampled_ll": -1.0157948732376099, "all_perturbed_sampled_ll": [-3.123185396194458], "all_perturbed_original_ll": [-2.5602893829345703], "perturbed_sampled_ll": -3.123185396194458, "perturbed_original_ll": -2.5602893829345703, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "#include<stdio.h>\ntypedef struct{\n  char name[20];\n  int point;\n}P;\nmain(){\n  int a,b,c,n,i,j,flag=0;\n  while(1){\n\n    scanf(\"%d\",&n);\n    if(n==0)break;\n    if(flag!=0)printf(\"\\n\");\n    flag=1;\n    P temp[n];\n    P flg;\n    for(i=0;i<n;i++){\n      scanf(\"%s %d %d %d\",temp[i].name,&a,&b,&c);\n      temp[i].point=a*3+c;\n    }\n\n    for(i=0;i<n-1;i++){\n      for(j=n-1;j>i;j--){\n\tif(temp[j].point>temp[j-1].point){\n\t  flg=temp[j];\n\t  temp[j]=temp[j-1];\n\t  temp[j-1]=flg;\n\t}\n      }\n    }\n    for(i=0;i<n;i++)printf(\"%s,%d\\n\",temp[i].name,temp[i].point);}\n    \n  return 0;\n}", "sampled": "#include <stdio.h>\n#include <string.h>\n\ntypedef struct {\n    char name[21];\n    int points;\n    int order;\n} Team;\n\nint main() {\n    int n;\n    int first = 1;\n    \n    while (1) {\n        scanf(\"%d\", &n);\n        if (n == 0) break;\n        \n        if (!first) {\n            printf(\"\\n\");\n        }\n        first = 0;\n        \n        Team teams[10];\n        \n        for (int i = 0; i < n; i++) {\n            int w, l, d;\n            scanf(\"%s %d %d %d\", teams[i].name, &w, &l, &d);\n            teams[i].points = w * 3 + d * 1;\n            teams[i].order = i;\n        }\n        \n        // Bubble sort\n        for (int i = 0; i < n - 1; i++) {\n            for (int j = 0; j < n - 1 - i; j++) {\n                if (teams[j].points < teams[j + 1].points ||\n                    (teams[j].points == teams[j + 1].points && teams[j].order > teams[j + 1].order)) {\n                    Team temp = teams[j];\n                    teams[j] = teams[j + 1];\n                    teams[j + 1] = temp;\n                }\n            }\n        }\n        \n        for (int i = 0; i < n; i++) {\n            printf(\"%s,%d\\n\", teams[i].name, teams[i].points);\n        }\n    }\n    \n    return 0;\n}\n", "perturbed_sampled": ["#include <stdio.h>  char name[21];    while  (n ==  printf(\"\\n\");  = 0; i < n; i++) { int w, l, d; scanf(\"%s %d %d %d\", teams[i].name, &w, &l, &d); teams[i].points = w *   Bubble sort for  < n  { if (teams[j].points < teams[j + 1].points || (teams[j].points ==   1]; teams[j + 1]   i <  teams[i].points); } } return 0; }"], "perturbed_original": ["#include<stdio.h> typedef struct{  P temp[n]; P flg; for(i=0;i<n;i++){ scanf(\"%s %d %d  if(temp[j].point>temp[j-1].point){  } for(i=0;i<n;i++)printf(\"%s,%d\\n\",temp[i].name,temp[i].point);} return 0; }"], "original_ll": -1.0306744575500488, "sampled_ll": -0.4913131892681122, "all_perturbed_sampled_ll": [-2.5780177116394043], "all_perturbed_original_ll": [-2.526618719100952], "perturbed_sampled_ll": -2.5780177116394043, "perturbed_original_ll": -2.526618719100952, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import java.util.*;\n\nclass Main {\n  public static void main (String[] args) {\n    Scanner scanner = new Scanner(System.in);\n    String out = \"\";\n    while (scanner.hasNext()) {\n      int n = scanner.nextInt();\n      if (n == 0) {\n        break;\n      }\n      List<String> ts = new ArrayList<String>();\n      for (int ii = 0; ii < n; ii++) {\n        String t = scanner.next();\n        int w = scanner.nextInt();\n        int l = scanner.nextInt();\n        int d = scanner.nextInt();\n        String wp = \"0000\" + (w * 3 + d);\n        wp = wp.substring(wp.length() - 5);\n        String idx = \"00\" + (n - ii);\n        idx = idx.substring(idx.length() - 3);\n        ts.add(wp + \",\" + idx + \",\" + t);\n      }\n      Collections.sort(ts);\n      Collections.reverse(ts);\n      for (String el : ts) {\n        String[] works = el.split(\",\");\n        int wp = Integer.parseInt(works[0]);\n        out += works[2] + \",\" + wp + \"\\n\";\n      }\n      out += \"\\n\";\n    }\n    System.out.print(out.substring(0, out.length() - 1));\n  }\n}", "sampled": "import java.util.*;\n\npublic class Main {\n    static class Team {\n        String name;\n        int points;\n        int order;\n        \n        Team(String name, int points, int order) {\n            this.name = name;\n            this.points = points;\n            this.order = order;\n        }\n    }\n    \n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        boolean first = true;\n        \n        while (true) {\n            int n = sc.nextInt();\n            if (n == 0) break;\n            \n            if (!first) {\n                System.out.println();\n            }\n            first = false;\n            \n            List<Team> teams = new ArrayList<>();\n            \n            for (int i = 0; i < n; i++) {\n                String name = sc.next();\n                int w = sc.nextInt();\n                int l = sc.nextInt();\n                int d = sc.nextInt();\n                \n                int points = w * 3 + d * 1;\n                teams.add(new Team(name, points, i));\n            }\n            \n            teams.sort((a, b) -> {\n                if (a.points != b.points) {\n                    return b.points - a.points;\n                }\n                return a.order - b.order;\n            });\n            \n            for (Team team : teams) {\n                System.out.println(team.name + \",\" + team.points);\n            }\n        }\n        \n        sc.close();\n    }\n}\n", "perturbed_sampled": ["import java.util.*; public  Team {  points, int order) { this.name = name; this.points  }  = new Scanner(System.in); boolean first = true; while (true) { int n = sc.nextInt();  ArrayList<>(); for (int i = 0;  int w = sc.nextInt(); int  = sc.nextInt(); int   teams.sort((a, b) -> { if (a.points != b.points)  } return a.order -  }"], "perturbed_original": ["import  args) { Scanner scanner =  int n = scanner.nextInt();  break; } List<String> ts = new ArrayList<String>(); for (int   = scanner.next(); int w = scanner.nextInt(); int l = scanner.nextInt(); int d =   d);  String idx =  idx =  el :  el.split(\",\"); int  wp + \"\\n\";  System.out.print(out.substring(0, out.length() - 1)); } }"], "original_ll": -0.9681492447853088, "sampled_ll": -0.4723587930202484, "all_perturbed_sampled_ll": [-2.8395867347717285], "all_perturbed_original_ll": [-3.448209762573242], "perturbed_sampled_ll": -2.8395867347717285, "perturbed_original_ll": -3.448209762573242, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "isPrint = False\n\nwhile True:\n\n    inputCount = int(input())\n\n    if inputCount == 0:\n        break\n\n    if isPrint:\n        print()\n    else:\n        isPrint = True\n\n    matchList = []\n\n    for lp in range(inputCount):\n\n        name, win, lose, draw = [item for item in input().split(\" \")]\n        score = int(win) * 3 + int(draw)\n\n        matchList.append([name, score])\n\n    matchList.sort(key=lambda item: -item[1])\n\n    for name, score in matchList:\n        print(name + \",\" + str(score))\n\n", "sampled": "results = []\nwhile True:\n    n = int(input())\n    if n == 0:\n        break\n    \n    teams = []\n    for i in range(n):\n        parts = input().split()\n        name = parts[0]\n        w = int(parts[1])\n        l = int(parts[2])\n        d = int(parts[3])\n        points = w * 3 + d * 1\n        teams.append((name, points, i))\n    \n    teams.sort(key=lambda x: (-x[1], x[2]))\n    \n    result = []\n    for team in teams:\n        result.append(f\"{team[0]},{team[1]}\")\n    \n    results.append(result)\n\nfor i, result in enumerate(results):\n    for line in result:\n        print(line)\n    if i < len(results) - 1:\n        print()\n", "perturbed_sampled": ["results = [] while True: <<extra_id_2>) if<extra_id_3>= None if name<extra_id_4>( name<extra_id_5>) if name else<extra_id_18>name<extra_id_19>\"name\" ] =<extra_id_20>[ i = [] for i in range(n): parts  = int(parts[2])  d * 1 teams.append((name, points,  results.append(result) for i, result in enumerate(results): for line in result: print(line) if  print()"], "perturbed_original": ["isPrint = False while True: inputCount = int(input()) if inputCount == 0:  isPrint  matchList.sort(key=lambda item: -item[1]) for name, score in matchList: print(name + \",\" + str(score))"], "original_ll": -1.357729196548462, "sampled_ll": -0.8269041180610657, "all_perturbed_sampled_ll": [-3.606795310974121], "all_perturbed_original_ll": [-2.4108781814575195], "perturbed_sampled_ll": -3.606795310974121, "perturbed_original_ll": -2.4108781814575195, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "#include<stdio.h>\n#include<time.h>\n#include<string.h>\nint main(void) {\n\ttime_t tim1,tim2;\n\tstruct tm d;\n\tdouble diff;\n\tint year1, year2, month1, month2, day1, day2;\n\twhile (1) {\n\t\tscanf(\"%d %d %d %d %d %d\",&year1,&month1,&day1,&year2,&month2,&day2);\n\t\tif (month1 == -1 || year1 == -1 || day1 == -1 ||month2 == -1 || year2 == -1 || day2 == -1) break;\n\t\tmemset(&d,0,sizeof(d));\n\t\td.tm_year = year1 - 1900;\n\t\td.tm_mon = month1 - 1;\n\t\td.tm_mday = day1;\n\t\ttim1 = mktime(&d);\n\t\td.tm_year = year2 - 1900;\n\t\td.tm_mon = month2 - 1;\n\t\td.tm_mday = day2;\n\t\ttim2 = mktime(&d);\n\n\t\tdiff = difftime(tim2, tim1);\n\n\t\tprintf(\"%d\\n\",(int)(diff/60/60/24+0.5));\n\t}\n\treturn 0;\n}", "sampled": "#include <stdio.h>\n\nint is_leap(int year) {\n    if (year % 400 == 0) return 1;\n    if (year % 100 == 0) return 0;\n    if (year % 4 == 0) return 1;\n    return 0;\n}\n\nint days_in_month(int year, int month) {\n    int days[] = {0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};\n    if (month == 2 && is_leap(year)) {\n        return 29;\n    }\n    return days[month];\n}\n\nint days_from_epoch(int year, int month, int day) {\n    int total = 0;\n    \n    // Add days for complete years from year 1\n    for (int y = 1; y < year; y++) {\n        if (is_leap(y)) {\n            total += 366;\n        } else {\n            total += 365;\n        }\n    }\n    \n    // Add days for complete months in the current year\n    for (int m = 1; m < month; m++) {\n        total += days_in_month(year, m);\n    }\n    \n    // Add the days\n    total += day;\n    \n    return total;\n}\n\nint main() {\n    int y1, m1, d1, y2, m2, d2;\n    \n    while (scanf(\"%d %d %d %d %d %d\", &y1, &m1, &d1, &y2, &m2, &d2) == 6) {\n        if (y1 < 0 || m1 < 0 || d1 < 0 || y2 < 0 || m2 < 0 || d2 < 0) {\n            break;\n        }\n        \n        int days1 = days_from_epoch(y1, m1, d1);\n        int days2 = days_from_epoch(y2, m2, d2);\n        \n        printf(\"%d\\n\", days2 - days1);\n    }\n    \n    return 0;\n}\n", "perturbed_sampled": ["#include <extra_id_12>hours if (month2<extra_id_13>] > 0 )<extra_id_14>weekdays2 =<extra_id_15>=<extra_id_16>d1 >= 365: {<extra_id_17>} }<extra_id_18> if (year  100 == 0) return 0; if (year % 4 == 0)  int days_in_month(int year, int month) { int days[] = {0, 31, 28, 31,  && is_leap(year)) {   month, int day) { int total = 0; //  (int y = 1; y   // Add days for complete months  (int m = 1; m  total += day;  { int y1, m1, d1, y2, m2, d2;   < 0 || d1 <   int days2 = days_from_epoch(y2, m2, d2); printf(\"%d\\n\", days2 - days1); } return 0; }"], "perturbed_original": ["#include<stdio.h>  time_t tim1,tim2; struct tm  year2, month1, month2,  %d %d\",&year1,&month1,&day1,&year2,&month2,&day2);  year1  || year2 == -1 || day2 == -1) break; memset(&d,0,sizeof(d)); d.tm_year  year2 - 1900; d.tm_mon = month2 - 1; d.tm_mday  diff =  0; }"], "original_ll": -0.6600609421730042, "sampled_ll": -0.37911221385002136, "all_perturbed_sampled_ll": [-2.5019032955169678], "all_perturbed_original_ll": [-2.3106577396392822], "perturbed_sampled_ll": -2.5019032955169678, "perturbed_original_ll": -2.3106577396392822, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import java.util.Scanner;\n\n\npublic class Main {\n\n\tfinal int DAY_MONTH[]={0, 31, 28, 31, 30, 31, 30, 31, 31, 30 ,31, 30 ,31};\n\t\n\tScanner sc;\n\t\n\tint isLeap(int y){\n\t\tif(y%4==0){\n\t\t\tif(y%100==0){\n\t\t\t\tif(y%400==0){\n\t\t\t\t\treturn 1;\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse{\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t}\n\t\telse{\n\t\t\treturn 0;\n\t\t}\n\t}\n\t\n\tint dayCount(int y, int m1, int d1, int m2, int d2){\n\t\tint days=-d1;\n\t\tfor(int m=m1;m<=m2;++m){\n\t\t\tdays+=DAY_MONTH[m];\n\t\t\tif(m==2) days+=isLeap(y);\n\t\t}\n\t\tdays-=DAY_MONTH[m2]+(m2==2?isLeap(y):0)-d2;\n\t\treturn days;\n\t}\n\t\n\tint solve(int y1, int m1, int d1, int y2, int m2, int d2){\n\t\tint days=0;\n\t\tif(y2-y1>=2){\n\t\t\tfor(int y=y1+1;y<y2;++y){\n\t\t\t\tdays+=365+isLeap(y);\n\t\t\t}\n\t\t}\n\t\tif(y2-y1>=1){\n\t\t\tdays+=dayCount(y1, m1, d1, 12, 31)+dayCount(y2, 1, 1, m2, d2)+1;\n\t\t}\n\t\telse{\n\t\t\tdays=dayCount(y1, m1, d1, m2, d2);\n\t\t}\n\t\treturn days;\n\t}\n\t\n\tint ni(){\n\t\treturn sc.nextInt();\n\t}\n\t\n\tvoid io(){\n\t\tsc=new Scanner(System.in);\n\t\t\n\t\twhile(true){\n\t\t\tint y1=ni(), m1=ni(), d1=ni(), y2=ni(), m2=ni(), d2=ni();\n\t\t\tif(y1<0||m1<0||d1<0||y2<0||m2<0||d2<0) break;\n\t\t\t\n\t\t\tSystem.out.println(solve(y1, m1, d1, y2, m2, d2));\n\t\t}\n\t\t\n\t\tsc.close();\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\t// TODO Auto-generated method stub\n\t\tnew Main().io();\n\t}\n\n}", "sampled": "import java.util.Scanner;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        \n        while (true) {\n            int y1 = sc.nextInt();\n            int m1 = sc.nextInt();\n            int d1 = sc.nextInt();\n            int y2 = sc.nextInt();\n            int m2 = sc.nextInt();\n            int d2 = sc.nextInt();\n            \n            if (y1 < 0 || m1 < 0 || d1 < 0 || y2 < 0 || m2 < 0 || d2 < 0) {\n                break;\n            }\n            \n            int days = countDays(y1, m1, d1, y2, m2, d2);\n            System.out.println(days);\n        }\n        \n        sc.close();\n    }\n    \n    static int countDays(int y1, int m1, int d1, int y2, int m2, int d2) {\n        int days1 = toDays(y1, m1, d1);\n        int days2 = toDays(y2, m2, d2);\n        return days2 - days1;\n    }\n    \n    static int toDays(int year, int month, int day) {\n        int days = 0;\n        \n        // Count days for complete years from year 1\n        for (int y = 1; y < year; y++) {\n            if (isLeapYear(y)) {\n                days += 366;\n            } else {\n                days += 365;\n            }\n        }\n        \n        // Count days for complete months in the current year\n        for (int m = 1; m < month; m++) {\n            days += getDaysInMonth(year, m);\n        }\n        \n        // Add remaining days\n        days += day;\n        \n        return days;\n    }\n    \n    static boolean isLeapYear(int year) {\n        if (year % 400 == 0) {\n            return true;\n        }\n        if (year % 100 == 0) {\n            return false;\n        }\n        if (year % 4 == 0) {\n            return true;\n        }\n        return false;\n    }\n    \n    static int getDaysInMonth(int year, int month) {\n        int[] days = {0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};\n        \n        if (month == 2 && isLeapYear(year)) {\n            return 29;\n        }\n        \n        return days[month];\n    }\n}\n", "perturbed_sampled": ["import java.util.Scanner; public class Main { public  Scanner sc = new Scanner(System.in);   sc.nextInt(); int d1 = sc.nextInt(); int  = sc.nextInt(); if (y1 < 0 ||  < 0 || d2 < 0) {  m2, d2); System.out.println(days); } sc.close(); } static int countDays(int y1, int m1, int d1, int y2, int m2, int d2) { int days1 = toDays(y1, m1,  m2, d2); return days2 - days1; } static  int day)   y++) { if   months    days  static boolean isLeapYear(int year) { if (year % 400 == 0) { return true; } if (year %  return  int[] days =   isLeapYear(year))  days[month]; } }"], "perturbed_original": ["import java.util.Scanner; public class Main { final int DAY_MONTH[]={0, 31, 28, 31, 30, 31, 30, 31,  return 1; }  else{ return 1; } } else{ return  y, int m1, int d1,  if(m==2) days+=isLeap(y); } days-=DAY_MONTH[m2]+(m2==2?isLeap(y):0)-d2;  y1, int m1,  m2, int d2){ int  m1, d1, 12, 31)+dayCount(y2, 1, 1,  m1, d1, m2,  Scanner(System.in);  sc.close(); }  { //  Main().io(); } }"], "original_ll": -0.6482090950012207, "sampled_ll": -0.30383339524269104, "all_perturbed_sampled_ll": [-2.1630992889404297], "all_perturbed_original_ll": [-2.3701932430267334], "perturbed_sampled_ll": -2.1630992889404297, "perturbed_original_ll": -2.3701932430267334, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "def f1():\n    if y1 == y2 and m1 == m2:\n        return d2- d1\n    \n    a = 0\n    if y1 % 400 == 0 or (y1 % 4 == 0 and y1 % 100 != 0):\n        a = 29\n    else:\n        a = 28\n    \n    t = 0\n    if m1 in [4,6,9,11]:\n        t += (30 - d1 + 1)\n    elif m1 in [1,3,5,7,8,10,12]:\n        t += (31 - d1 + 1)\n    else:\n        t += (a - d1 + 1)\n        \n        \n    if y1 == y2:\n        return f3(t, m1+1)\n    else:\n        for m in range(m1+1, 13):\n            if m in [4,6,9,11]:\n                t += 30\n            elif m in [1,3,5,7,8,10,12]:\n                t += 31\n            else:\n                t += a\n            \n        return f2(t)\n    \ndef f2(t):\n    for y in range(y1+1, y2):\n        if y % 400 == 0 or (y % 4 == 0 and y % 100 != 0):\n            t += 366\n        else:\n            t += 365\n    \n    return f3(t, 1)\n    \ndef f3(t, s):\n    a = 0\n    if y2 % 400 == 0 or (y2 % 4 == 0 and y2 % 100 != 0):\n        a = 29\n    else:\n        a = 28\n        \n    for m in range(s, m2):\n        if m in [4,6,9,11]:\n            t += 30\n        elif m in [1,3,5,7,8,10,12]:\n            t += 31\n        else:\n            t += a\n            \n    t += (d2 - 1)\n            \n    return t\n            \nwhile True:\n    y1, m1, d1, y2, m2, d2 = map(int, raw_input().split())\n    if y1 < 0 or m1 < 0 or d1 < 0 or y2 < 0 or m2 < 0 or d2 < 0:\n        break\n    print f1()", "sampled": "def is_leap_year(year):\n    if year % 400 == 0:\n        return True\n    if year % 100 == 0:\n        return False\n    if year % 4 == 0:\n        return True\n    return False\n\ndef days_in_month(year, month):\n    if month in [1, 3, 5, 7, 8, 10, 12]:\n        return 31\n    elif month in [4, 6, 9, 11]:\n        return 30\n    elif month == 2:\n        return 29 if is_leap_year(year) else 28\n\ndef days_from_epoch(year, month, day):\n    # Calculate days from year 0\n    days = 0\n    \n    # Add days for complete years\n    for y in range(1, year):\n        if is_leap_year(y):\n            days += 366\n        else:\n            days += 365\n    \n    # Add days for complete months in the current year\n    for m in range(1, month):\n        days += days_in_month(year, m)\n    \n    # Add remaining days\n    days += day\n    \n    return days\n\nwhile True:\n    line = list(map(int, input().split()))\n    y1, m1, d1, y2, m2, d2 = line\n    \n    if y1 < 0 or m1 < 0 or d1 < 0 or y2 < 0 or m2 < 0 or d2 < 0:\n        break\n    \n    days1 = days_from_epoch(y1, m1, d1)\n    days2 = days_from_epoch(y2, m2, d2)\n    \n    print(days2 - days1)\n", "perturbed_sampled": ["def is_leap_year(year):  0: return True if year  True return False def days_in_month(year, month): if month in  10, 12]:  ==  else 28  Calculate days   is_leap_year(y): days   in range(1, month): days += days_in_month(year, m) # Add remaining days days += day  = list(map(int, input().split()))  y1 < 0  d1 < 0 or y2 < 0 or m2 < 0 or d2   days_from_epoch(y2, m2, d2) print(days2 - days1)"], "perturbed_original": ["def f1(): if y1 ==  return d2- d1 a = 0  y1 % 100 != 0):  0 if m1 in [4,6,9,11]: t += (30   (31 - d1 +   if m in  m  else: t  range(y1+1, y2): if   0 and y % 100 !=  t += 365 return f3(t, 1) def f3(t,  y2 % 400 == 0 or (y2  else: a =  m2): if m in   - 1) return t  y2,  if y1   or y2 < 0 or m2 < 0 or d2 < 0: break print f1()"], "original_ll": -0.6622870564460754, "sampled_ll": -0.4395093619823456, "all_perturbed_sampled_ll": [-2.6570465564727783], "all_perturbed_original_ll": [-3.0410871505737305], "perturbed_sampled_ll": -2.6570465564727783, "perturbed_original_ll": -3.0410871505737305, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "v[81],e[81];\nB(p,s0,s1){\n\tint f[10]={0},i,j;\n\tfor(i=0;i<3;i++){\n\t\tfor(j=0;j<3;j++){\n\t\t\tif(f[v[p]])\n\t\t\t\te[~f[v[p]]]=e[p]=1;\n\t\t\telse\n\t\t\t\tf[v[p]]=~p;\n\t\t\tp+=s0;\n\t\t}\n\t\tp+=s1-3*s0;\n\t}\n}\nmain(i,f){\n\tscanf(\"%*d\\n\");\n\tfor(f=i=0;~scanf(\"%d\",v+i);){\n\t\tif(++i==81){\n\t\t\tmemset(e,0,sizeof(e));\n\t\t\tfor(i=0;i<9;i++){\n\t\t\t\tB(0+i*9,1+0*9,3+0*9);\n\t\t\t\tB(i+0*9,0+1*9,0+3*9);\n\t\t\t\tB(i%3*3+i/3*3*9,1+0*9,0+1*9);\n\t\t\t}\n\t\t\tif(f++)\n\t\t\t\tputs(\"\");\n\t\t\tfor(i=0;i<81;i++){\n\t\t\t\tprintf(\"%c%d\",e[i]?'*':' ',v[i]);\n\t\t\t\tif(i%9==8)\n\t\t\t\t\tputs(\"\");\n\t\t\t}\n\t\t\ti=0;\n\t\t}\n\t}\n}", "sampled": "#include <stdio.h>\n#include <string.h>\n\nint main() {\n    int n;\n    scanf(\"%d\", &n);\n    \n    for (int dataset = 0; dataset < n; dataset++) {\n        int grid[9][9];\n        int error[9][9];\n        \n        // Read input\n        for (int i = 0; i < 9; i++) {\n            for (int j = 0; j < 9; j++) {\n                scanf(\"%d\", &grid[i][j]);\n                error[i][j] = 0;\n            }\n        }\n        \n        // Check rows\n        for (int i = 0; i < 9; i++) {\n            int count[10] = {0};\n            for (int j = 0; j < 9; j++) {\n                count[grid[i][j]]++;\n            }\n            for (int j = 0; j < 9; j++) {\n                if (count[grid[i][j]] > 1) {\n                    error[i][j] = 1;\n                }\n            }\n        }\n        \n        // Check columns\n        for (int j = 0; j < 9; j++) {\n            int count[10] = {0};\n            for (int i = 0; i < 9; i++) {\n                count[grid[i][j]]++;\n            }\n            for (int i = 0; i < 9; i++) {\n                if (count[grid[i][j]] > 1) {\n                    error[i][j] = 1;\n                }\n            }\n        }\n        \n        // Check 3x3 blocks\n        for (int block_i = 0; block_i < 3; block_i++) {\n            for (int block_j = 0; block_j < 3; block_j++) {\n                int count[10] = {0};\n                for (int i = block_i * 3; i < block_i * 3 + 3; i++) {\n                    for (int j = block_j * 3; j < block_j * 3 + 3; j++) {\n                        count[grid[i][j]]++;\n                    }\n                }\n                for (int i = block_i * 3; i < block_i * 3 + 3; i++) {\n                    for (int j = block_j * 3; j < block_j * 3 + 3; j++) {\n                        if (count[grid[i][j]] > 1) {\n                            error[i][j] = 1;\n                        }\n                    }\n                }\n            }\n        }\n        \n        // Output\n        for (int i = 0; i < 9; i++) {\n            for (int j = 0; j < 9; j++) {\n                if (error[i][j]) {\n                    printf(\"*%d\", grid[i][j]);\n                } else {\n                    printf(\" %d\", grid[i][j]);\n                }\n                if (j < 8) printf(\" \");\n            }\n            printf(\"\\n\");\n        }\n        \n        if (dataset < n - 1) {\n            printf(\"\\n\");\n        }\n    }\n    \n    return 0;\n}\n", "perturbed_sampled": ["#include  = 0; dataset < n; dataset++)  // Read input for (int i = 0;  for (int  9;    j < 9; j++) { count[grid[i][j]]++; } for (int j = 0; j  (count[grid[i][j]] >  Check columns for (int j =  {0}; for (int i  i++) { count[grid[i][j]]++;  0; i < 9; i++) { if  = 1; }  = 0; block_i < 3; block_i++) {  block_j   * 3 + 3; i++) { for (int j = block_j  * 3 + 3;   block_i   < block_j * 3 +  > 1) { error[i][j] =  } // Output for (int i =  = 0; j < 9; j++) {   (dataset < n - 1) { printf(\"\\n\"); } } return 0; }"], "perturbed_original": ["v[81],e[81]; B(p,s0,s1){ int f[10]={0},i,j; for(i=0;i<3;i++){ B(i%10*3+j/10*3*9*9,u*9+j/8*9,0+1*9);} }<extra_id_1>} } main(i,f){ scanf(\"%*d\\n\"); for(f=i=0;~scanf(\"%d\",v+i);){  B(i%3*3+i/3*3*9,1+0*9,0+1*9); } if(f++) puts(\"\");  }"], "original_ll": -1.7335526943206787, "sampled_ll": -0.24266508221626282, "all_perturbed_sampled_ll": [-2.3556108474731445], "all_perturbed_original_ll": [-3.2087507247924805], "perturbed_sampled_ll": -2.3556108474731445, "perturbed_original_ll": -3.2087507247924805, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import java.io.IOException;\nimport java.io.BufferedReader;\nimport java.io.InputStreamReader;\n\nclass Main {\n    public static void main(String[] args) throws IOException {\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        int n = Integer.parseInt(br.readLine());\n        for (int i = 0; i < n; i++) {\n            int[][] map = new int[9][9];\n            boolean[][] ok = new boolean[9][9];\n            for (int j = 0; j < 9; j++) {\n                String[] input = br.readLine().split(\" \");\n                for (int k = 0; k < 9; k++) {\n                    map[j][k] = Integer.parseInt(input[k]);\n                }\n            }\n\n            // horizontal check\n            for (int j = 0; j < 9; j++) {\n                boolean[] oneToNine = new boolean[10]; // index0\u306f\u4f7f\u308f\u306a\u3044\n                for (int k = 0; k < 9; k++) {\n                    if (!oneToNine[map[j][k]]) {\n                        oneToNine[map[j][k]] = true;\n                    } else {\n                        ok[j][k] = true;\n                        for (int l = 0; l < k; l++) {\n                            if (map[j][l] == map[j][k]) {\n                                ok[j][l] = true;\n                                break;\n                            }\n                        }\n                    }\n                }\n            }\n\n            // vertical check\n            for (int j = 0; j < 9; j++) {\n                boolean[] oneToNine = new boolean[10];\n                for (int k = 0; k < 9; k++) {\n                    if (!oneToNine[map[k][j]]) {\n                        oneToNine[map[k][j]] = true;\n                    } else {\n                        ok[k][j] = true;\n                        for (int l = 0; l < k; l++) {\n                            if (map[l][j] == map[k][j]) {\n                                ok[l][j] = true;\n                                break;\n                            }\n                        }\n                    }\n                }\n            }\n\n            // display\n            for (int j = 0; j < 9; j++) {\n                for (int k = 0; k < 9; k++) {\n                    if (ok[j][k])\n                        System.out.print(\"*\");\n                    else\n                        System.out.print(\" \");\n\n                    System.out.print(map[j][k]);\n                }\n                System.out.println();\n            }\n\n        }\n    }\n}\n", "sampled": "import java.util.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int n = sc.nextInt();\n        sc.nextLine();\n        \n        for (int t = 0; t < n; t++) {\n            if (t > 0) {\n                System.out.println();\n            }\n            \n            int[][] grid = new int[9][9];\n            for (int i = 0; i < 9; i++) {\n                String line = sc.nextLine();\n                String[] tokens = line.trim().split(\"\\\\s+\");\n                for (int j = 0; j < 9; j++) {\n                    grid[i][j] = Integer.parseInt(tokens[j]);\n                }\n            }\n            \n            boolean[][] error = new boolean[9][9];\n            \n            // Check rows\n            for (int i = 0; i < 9; i++) {\n                int[] count = new int[10];\n                for (int j = 0; j < 9; j++) {\n                    count[grid[i][j]]++;\n                }\n                for (int j = 0; j < 9; j++) {\n                    if (count[grid[i][j]] > 1) {\n                        error[i][j] = true;\n                    }\n                }\n            }\n            \n            // Check columns\n            for (int j = 0; j < 9; j++) {\n                int[] count = new int[10];\n                for (int i = 0; i < 9; i++) {\n                    count[grid[i][j]]++;\n                }\n                for (int i = 0; i < 9; i++) {\n                    if (count[grid[i][j]] > 1) {\n                        error[i][j] = true;\n                    }\n                }\n            }\n            \n            // Check 3x3 blocks\n            for (int blockRow = 0; blockRow < 3; blockRow++) {\n                for (int blockCol = 0; blockCol < 3; blockCol++) {\n                    int[] count = new int[10];\n                    for (int i = blockRow * 3; i < blockRow * 3 + 3; i++) {\n                        for (int j = blockCol * 3; j < blockCol * 3 + 3; j++) {\n                            count[grid[i][j]]++;\n                        }\n                    }\n                    for (int i = blockRow * 3; i < blockRow * 3 + 3; i++) {\n                        for (int j = blockCol * 3; j < blockCol * 3 + 3; j++) {\n                            if (count[grid[i][j]] > 1) {\n                                error[i][j] = true;\n                            }\n                        }\n                    }\n                }\n            }\n            \n            // Output\n            for (int i = 0; i < 9; i++) {\n                for (int j = 0; j < 9; j++) {\n                    if (error[i][j]) {\n                        System.out.print(\"*\");\n                    } else {\n                        System.out.print(\" \");\n                    }\n                    System.out.print(grid[i][j]);\n                }\n                System.out.println();\n            }\n        }\n        \n        sc.close();\n    }\n}\n", "perturbed_sampled": ["import java.util.*; public class Main { public static    (int t = 0; t  (t > 0) {  new   sc.nextLine(); String[] tokens =   { grid[i][j] = Integer.parseInt(tokens[j]); } } boolean[][] error = new  i < 9; i++)  9; j++) { count[grid[i][j]]++; } for (int j =  { if (count[grid[i][j]] >  Check columns for (int j = 0; j < 9; j++) { int[] count = new int[10]; for (int i = 0; i < 9;   if  = true; } } } //  blockRow =  3; blockCol++)  j < blockCol *  * 3;  + 3; i++) {  3; j++) { if (count[grid[i][j]] > 1) { error[i][j] = true;  // Output for  for (int j   System.out.print(\" \"); } System.out.print(grid[i][j]); } System.out.println(); } } sc.close(); } }"], "perturbed_original": ["import java.io.IOException; import  { public static void    0; i < n; i++) { int[][] map = new int[9][9]; boolean[][] ok = new boolean[9][9]; for (int j = 0;  String[]   < 9; k++) { map[j][k] = Integer.parseInt(input[k]); } } //  if (!oneToNine[map[j][k]])  else { ok[j][k] = true;  l  ok[j][l] = true; break; } } }  for (int j = 0; j <  =  (!oneToNine[map[k][j]]) { oneToNine[map[k][j]] = true; } else { ok[k][j] = true; for  < k; l++) {   // display  j < 9; j++)   } System.out.println(); } } } }"], "original_ll": -0.4084216356277466, "sampled_ll": -0.23799411952495575, "all_perturbed_sampled_ll": [-2.3502840995788574], "all_perturbed_original_ll": [-2.263028144836426], "perturbed_sampled_ll": -2.3502840995788574, "perturbed_original_ll": -2.263028144836426, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "R=range(9)\ndef f1(M):\n  global F\n  for y in R:\n    A=M[y]\n    if len(set(A))==9: continue\n    for x in R:\n      if A.count(A[x])>=2: F[y][x]=\"*\"\n  return\ndef f2(M):\n  global F\n  for x in R:\n    A=[M[y][x] for y in R]\n    if len(set(A))==9: continue\n    for y in R:\n      if A.count(A[y])>=2: F[y][x]=\"*\"\n  return\ndef f3(M):\n  global F\n  for i in R:\n    x=i%3*3\n    y=i/3*3\n    A=M[y][x:x+3]+M[y+1][x:x+3]+M[y+2][x:x+3]\n    if len(set(A))==9: continue\n    for j in R:\n      if A.count(A[j])>=2: F[y+j/3][x+j%3]=\"*\"\n  return\n\nn=input()\nwhile n:\n  M=[]\n  F=[[\" \" for _ in [0]*9] for _ in [0]*9]\n  M=[map(int,raw_input().split()) for _ in [0]*9]\n  f1(M)\n  f2(M)\n  f3(M)\n  for i in R:\n    s=zip(F[i],map(str,M[i]))\n    print \"\".join([a+b for a,b in s])\n  if n>1: print\n  n-=1", "sampled": "def solve():\n    n = int(input())\n    \n    for dataset_idx in range(n):\n        grid = []\n        for _ in range(9):\n            row = list(map(int, input().split()))\n            grid.append(row)\n        \n        # Mark errors\n        errors = [[False] * 9 for _ in range(9)]\n        \n        # Check rows\n        for i in range(9):\n            counts = {}\n            for j in range(9):\n                val = grid[i][j]\n                if val not in counts:\n                    counts[val] = []\n                counts[val].append(j)\n            \n            for val, positions in counts.items():\n                if len(positions) > 1:\n                    for j in positions:\n                        errors[i][j] = True\n        \n        # Check columns\n        for j in range(9):\n            counts = {}\n            for i in range(9):\n                val = grid[i][j]\n                if val not in counts:\n                    counts[val] = []\n                counts[val].append(i)\n            \n            for val, positions in counts.items():\n                if len(positions) > 1:\n                    for i in positions:\n                        errors[i][j] = True\n        \n        # Check 3x3 blocks\n        for block_row in range(3):\n            for block_col in range(3):\n                counts = {}\n                for i in range(block_row * 3, block_row * 3 + 3):\n                    for j in range(block_col * 3, block_col * 3 + 3):\n                        val = grid[i][j]\n                        if val not in counts:\n                            counts[val] = []\n                        counts[val].append((i, j))\n                \n                for val, positions in counts.items():\n                    if len(positions) > 1:\n                        for i, j in positions:\n                            errors[i][j] = True\n        \n        # Output\n        for i in range(9):\n            output = []\n            for j in range(9):\n                if errors[i][j]:\n                    output.append('*' + str(grid[i][j]))\n                else:\n                    output.append(' ' + str(grid[i][j]))\n            print(''.join(output))\n        \n        if dataset_idx < n - 1:\n            print()\n\nsolve()\n", "perturbed_sampled": ["def  in range(9): row =  errors  # Check rows for i in range(9):   in counts.items():  j in positions: errors[i][j] = True   for  grid[i][j] if val not in counts: counts[val] = [] counts[val].append(i) for   in positions: errors[i][j]  * 3, block_row * 3 + 3): for j in range(block_col * 3,   for val, positions in counts.items(): if len(positions) > 1: for i, j in  range(9): output = [] for j in range(9): if errors[i][j]: output.append('*'  dataset_idx < n - 1: print() solve()"], "perturbed_original": [" for y in R: A=M[y] if len(set(A))==9: continue for  in R: A=[M[y][x] for y  x=i%3*3  if A.count(A[j])>=2: F[y+j/3][x+j%3]=\"*\" return n=input() while n: M=[] F=[[\" \" for  in [0]*9] M=[map(int,raw_input().split()) for _ in [0]*9]  in R: s=zip(F[i],map(str,M[i])) print  if n>1: print n-=1"], "original_ll": -1.0750250816345215, "sampled_ll": -0.44643113017082214, "all_perturbed_sampled_ll": [-3.103502035140991], "all_perturbed_original_ll": [-3.4112470149993896], "perturbed_sampled_ll": -3.103502035140991, "perturbed_original_ll": -3.4112470149993896, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "#include <stdio.h>\n#include <math.h>\n\n#define EPS (1e-7)\n\ntypedef struct {\n\tint x,y,r;\n} wall_t;\n\ntypedef struct {\n\tint tx,ty,sx,sy;\n} query_t;\n\nint hitcheck_circle(wall_t w,query_t q) {\n\tint in=0;\n\tint a,b,c;\n\tint minx,miny,maxx,maxy,temp;\n\t/* sieve */\n\tminx=q.tx;maxx=q.sx;\n\tif(minx>maxx){temp=minx;minx=maxx;maxx=temp;}\n\tminy=q.ty;maxy=q.sy;\n\tif(miny>maxy){temp=miny;miny=maxy;maxy=temp;}\n\tif(w.x+w.r<minx || maxx<w.x-w.r)return 0;\n\tif(w.y+w.r<miny || maxy<w.y-w.r)return 0;\n\t/* check if dist<=r */\n\tif((q.tx-w.x)*(q.tx-w.x)+(q.ty-w.y)*(q.ty-w.y)<=w.r*w.r)in++;\n\tif((q.sx-w.x)*(q.sx-w.x)+(q.sy-w.y)*(q.sy-w.y)<=w.r*w.r)in++;\n\tif(in==1)return 1;\n\tif(in==2)return 0;\n\ta=q.ty-q.sy;\n\tb=q.sx-q.tx;\n\tc=(q.tx-q.sx)*q.ty-(q.ty-q.sy)*q.tx;\n\tif((a*w.x+b*w.y+c)*(a*w.x+b*w.y+c)<=w.r*w.r*(a*a+b*b)) {\n\t\t/* check if really hit */\n\t\tc=-c; /* convert a*x+b*y+c=0 to a*x+b*y=c */\n\t\tif(b==0) {\n\t\t\tdouble yy=w.r*w.r-((double)c/a-w.x)*((double)c/a-w.x);\n\t\t\tdouble y1,y2;\n\t\t\ty1=sqrt(yy);y2=-y1;\n\t\t\ty1+=w.y;y2+=w.y;\n\t\t\treturn (miny<y1+EPS && y1<maxy+EPS) || (miny<y2+EPS && y2<maxy+EPS);\n\t\t} else {\n\t\t\tdouble cb=(double)c/b;\n\t\t\tdouble ab=(double)a/b;\n\t\t\tdouble x2k,xk,tk;\n\t\t\tdouble x1,x2;\n\t\t\tx2k=1.0+ab*ab;\n\t\t\txk=-2*w.x+2.0*(w.y-cb)*ab;\n\t\t\ttk=w.x*w.x+(w.y-cb)*(w.y-cb)-w.r*w.r;\n\t\t\tx1=(-xk+sqrt(xk*xk-4.0*x2k*tk))/(2.0*x2k);\n\t\t\tx2=(-xk-sqrt(xk*xk-4.0*x2k*tk))/(2.0*x2k);\n\t\t\treturn (minx<x1+EPS && x1<maxx+EPS) || (minx<x2+EPS && x2<maxx+EPS);\n\t\t}\n\t}\n\treturn 0;\n}\nint main(void) {\n\tint n;\n\twall_t w[100];\n\tint m;\n\tint i;\n\twhile(scanf(\"%d\",&n)==1 && n>0) {\n\t\tfor(i=0;i<n;i++)scanf(\"%d%d%d\",&w[i].x,&w[i].y,&w[i].r);\n\t\tscanf(\"%d\",&m);\n\t\tfor(i=0;i<m;i++) {\n\t\t\tquery_t q;\n\t\t\tint j;\n\t\t\tint hidden;\n\t\t\tscanf(\"%d%d%d%d\",&q.tx,&q.ty,&q.sx,&q.sy);\n\t\t\thidden=0;\n\t\t\tif(q.tx!=q.sx || q.ty!=q.sy) {\n\t\t\t\tfor(j=0;j<n;j++) {\n\t\t\t\t\tif(hitcheck_circle(w[j],q)) {\n\t\t\t\t\t\thidden=1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tputs(hidden?\"Safe\":\"Danger\");\n\t\t}\n\t}\n\treturn 0;\n}", "sampled": "#include <stdio.h>\n#include <math.h>\n\ntypedef struct {\n    double x, y;\n} Point;\n\ntypedef struct {\n    Point center;\n    double radius;\n} Circle;\n\nint isInsideCircle(Point p, Circle c) {\n    double dx = p.x - c.center.x;\n    double dy = p.y - c.center.y;\n    return (dx * dx + dy * dy) < (c.radius * c.radius);\n}\n\nint lineSegmentIntersectsCircle(Point p1, Point p2, Circle c) {\n    // Check if either endpoint is inside the circle\n    if (isInsideCircle(p1, c) || isInsideCircle(p2, c)) {\n        return 1;\n    }\n    \n    // Vector from p1 to p2\n    double dx = p2.x - p1.x;\n    double dy = p2.y - p1.y;\n    \n    // Vector from p1 to circle center\n    double fx = c.center.x - p1.x;\n    double fy = c.center.y - p1.y;\n    \n    // Project circle center onto line segment\n    double len_sq = dx * dx + dy * dy;\n    double t = (fx * dx + fy * dy) / len_sq;\n    \n    // Clamp t to [0, 1] to stay on segment\n    if (t < 0) t = 0;\n    if (t > 1) t = 1;\n    \n    // Find closest point on segment\n    double closest_x = p1.x + t * dx;\n    double closest_y = p1.y + t * dy;\n    \n    // Check distance from closest point to circle center\n    double dist_x = c.center.x - closest_x;\n    double dist_y = c.center.y - closest_y;\n    double dist_sq = dist_x * dist_x + dist_y * dist_y;\n    \n    return dist_sq < (c.radius * c.radius);\n}\n\nint isBlocked(Point taro, Point oni, Circle walls[], int n) {\n    // Check if Taro and Oni are both inside the same circle\n    for (int i = 0; i < n; i++) {\n        if (isInsideCircle(taro, walls[i]) && isInsideCircle(oni, walls[i])) {\n            // Both inside same wall, check if blocked by another wall\n            int blocked = 0;\n            for (int j = 0; j < n; j++) {\n                if (i != j && lineSegmentIntersectsCircle(taro, oni, walls[j])) {\n                    blocked = 1;\n                    break;\n                }\n            }\n            if (!blocked) {\n                return 0; // They can see each other\n            }\n        }\n    }\n    \n    // Check if line segment intersects any wall\n    for (int i = 0; i < n; i++) {\n        int taroInside = isInsideCircle(taro, walls[i]);\n        int oniInside = isInsideCircle(oni, walls[i]);\n        \n        // If one is inside and one is outside, blocked\n        if (taroInside != oniInside) {\n            return 1;\n        }\n        \n        // If both outside, check if line intersects wall\n        if (!taroInside && !oniInside) {\n            if (lineSegmentIntersectsCircle(taro, oni, walls[i])) {\n                return 1;\n            }\n        }\n    }\n    \n    return 0;\n}\n\nint main() {\n    int n;\n    while (scanf(\"%d\", &n) == 1 && n != 0) {\n        Circle walls[100];\n        for (int i = 0; i < n; i++) {\n            scanf(\"%lf %lf %lf\", &walls[i].center.x, &walls[i].center.y, &walls[i].radius);\n        }\n        \n        int m;\n        scanf(\"%d\", &m);\n        \n        for (int i = 0; i < m; i++) {\n            Point taro, oni;\n            scanf(\"%lf %lf %lf %lf\", &taro.x, &taro.y, &oni.x, &oni.y);\n            \n            if (isBlocked(taro, oni, walls, n)) {\n                printf(\"Safe\\n\");\n            } else {\n                printf(\"Danger\\n\");\n            }\n        }\n    }\n    \n    return 0;\n}\n", "perturbed_sampled": ["#include <stdio.h> #include <math.h> typedef struct { double x,  p.x - c.center.x; double dy = p.y - c.center.y; return  * c.radius); } int lineSegmentIntersectsCircle(Point  { // Check if either endpoint is inside the circle if (isInsideCircle(p1,  return 1;  from p1 to circle center double  double fy =  segment  dx + dy *  * dx   on segment if (t < 0) t =  t  closest_y = p1.y + t *  closest  dist_x = c.center.x - closest_x; double dist_y = c.center.y - closest_y; double dist_sq = dist_x *  return dist_sq <  Circle  Check if Taro and  same circle for (int i = 0; i < n; i++) { if (isInsideCircle(taro, walls[i])  Both inside same  j = 0; j < n; j++) {  lineSegmentIntersectsCircle(taro, oni, walls[j]))  { return 0; // They can   segment  i  i++) { int taroInside  If  is  intersects    n; while (scanf(\"%d\", &n) == 1  Circle walls[100];  i < n; i++) {   taro, oni; scanf(\"%lf %lf  &oni.y); if (isBlocked(taro, oni, walls, n)) { printf(\"Safe\\n\"); } else { printf(\"Danger\\n\"); } } } return 0; }"], "perturbed_original": ["#include <stdio.h> #include <math.h> #define EPS (1e-7)  { int tx,ty,sx,sy; }  {  minx=q.tx;maxx=q.sx; if(minx>maxx){temp=minx;minx=maxx;maxx=temp;} miny=q.ty;maxy=q.sy; if(miny>maxy){temp=miny;miny=maxy;maxy=temp;} if(w.x+w.r<minx ||  a=q.ty-q.sy;   { double yy=w.r*w.r-((double)c/a-w.x)*((double)c/a-w.x); double y1,y2; y1=sqrt(yy);y2=-y1; y1+=w.y;y2+=w.y; return (miny<y1+EPS && y1<maxy+EPS) || (miny<y2+EPS && y2<maxy+EPS); } else { double  double x1,x2; x2k=1.0+ab*ab; xk=-2*w.x+2.0*(w.y-cb)*ab; tk=w.x*w.x+(w.y-cb)*(w.y-cb)-w.r*w.r; x1=(-xk+sqrt(xk*xk-4.0*x2k*tk))/(2.0*x2k); x2=(-xk-sqrt(xk*xk-4.0*x2k*tk))/(2.0*x2k); return (minx<x1+EPS && x1<maxx+EPS) || (minx<x2+EPS   int    if(q.tx!=q.sx  } } } puts(hidden?\"Safe\":\"Danger\"); } } return 0; }"], "original_ll": -1.0586460828781128, "sampled_ll": -0.5832756161689758, "all_perturbed_sampled_ll": [-2.925776481628418], "all_perturbed_original_ll": [-1.926337718963623], "perturbed_sampled_ll": -2.925776481628418, "perturbed_original_ll": -1.926337718963623, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import java.io.*;\nimport java.util.*;\n\npublic class Main{\n\tpublic static void main(String args[]){\n\t\ttry{\n\t\t\tnew Main();\n\t\t}catch(IOException e){\n\t\t\te.printStackTrace();\n\t\t}\n\t}\n\n\tpublic Main() throws IOException{\n\t\tBufferedReader in = new BufferedReader(new InputStreamReader(System.in));\n\t\tList<Integer> Ans = new ArrayList<Integer>();\n\t\tString line;\n\n\t\twhile((line = in.readLine()) != null){\n\t\t\tint nTube = Integer.parseInt(line);\n\n\t\t\tif(nTube==0) break;\n\n\t\t\tTube[] tubes = new Tube[nTube];\n\t\t\tfor(int n=0; n<nTube; n++){\n\t\t\t\tline = in.readLine();\n\t\t\t\tString[] dst = line.split(\" \");\n\t\t\t\tint x = Integer.parseInt(dst[0]);\n\t\t\t\tint y = Integer.parseInt(dst[1]);\n\t\t\t\tint r = Integer.parseInt(dst[2]);\n\t\t\t\ttubes[n] = new Tube(x, y, r);\n\t\t\t}\n\n\t\t\tline = in.readLine();\n\t\t\tint nSet = Integer.parseInt(line);\n\t\t\tfor(int n=0; n<nSet; n++){\n\t\t\t\tline = in.readLine();\n\t\t\t\tString[] dst = line.split(\" \");\n\t\t\t\tdouble x1 = Double.parseDouble(dst[0]);\n\t\t\t\tdouble y1 = Double.parseDouble(dst[1]);\n\t\t\t\tdouble x2 = Double.parseDouble(dst[2]);\n\t\t\t\tdouble y2 = Double.parseDouble(dst[3]);\n\n\t\t\t\tint hide = 0;\n\t\t\t\tfor(int m=0; m<tubes.length; m++){\n\t\t\t\t\tdouble a, b, c, d, e1, e2, x0, min, max;\n\t\t\t\t\tif(x1 != x2){\n\t\t\t\t\t\tdouble p = (y1 - y2) / (x1 - x2);\n\t\t\t\t\t\tdouble q = y1 - p * x1;\n\t\t\t\t\t\ta = p * p + 1.0;\n\t\t\t\t\t\tb = 2.0 * p * (q - tubes[m].y) - 2.0 * tubes[m].x;\n\t\t\t\t\t\tc = Math.pow(tubes[m].x, 2.0) + Math.pow(q - tubes[m].y, 2.0) - Math.pow(tubes[m].r, 2.0);\n\t\t\t\t\t\td = b * b - 4.0 * a * c;\n\t\t\t\t\t\te1 = a * x1 * x1 + b * x1 + c;\n\t\t\t\t\t\te2 = a * x2 * x2 + b * x2 + c;\n\t\t\t\t\t\tx0 = - b / (2.0 * a);\n\t\t\t\t\t\tmin = Math.min(x1, x2);\n\t\t\t\t\t\tmax = Math.max(x1, x2);\n\t\t\t\t\t}\n\t\t\t\t\telse{\n\t\t\t\t\t\ta = 1.0;\n\t\t\t\t\t\tb = -2.0 * tubes[m].y;\n\t\t\t\t\t\tc = Math.pow(tubes[m].y, 2.0) + Math.pow(x1 - tubes[m].x, 2.0) - Math.pow(tubes[m].r, 2.0);\n\t\t\t\t\t\td = b * b - 4.0 * a * c;\n\t\t\t\t\t\te1 = a * y1 * y1 + b * y1 + c;\n\t\t\t\t\t\te2 = a * y2 * y2 + b * y2 + c;\n\t\t\t\t\t\tx0 = - b / (2.0 * a);\n\t\t\t\t\t\tmin = Math.min(y1, y2);\n\t\t\t\t\t\tmax = Math.max(y1, y2);\n\t\t\t\t\t}\n\n\t\t\t\t\tif(x0 >= min && x0 <= max){\n\t\t\t\t\t\tif(d*e1 >= 0 || d*e2 >= 0){\n\t\t\t\t\t\t\tAns.add(1);\n\t\t\t\t\t\t\thide = 1;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse{\n\t\t\t\t\t\tif(e1 * e2 <= 0){\n\t\t\t\t\t\t\tAns.add(1);\n\t\t\t\t\t\t\thide = 1;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif(hide == 0){\n\t\t\t\t\tAns.add(-1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfor(int n=0; n<Ans.size(); n++){\n\t\t\tint i = Ans.get(n);\n\t\t\tif(i==1){\n\t\t\t\tSystem.out.println(\"Safe\");\n\t\t\t}else{\n\t\t\t\tSystem.out.println(\"Danger\");\n\t\t\t}\n\t\t}\n\t}\n}\n\nclass Tube{\n\tdouble x;\n\tdouble y;\n\tdouble r;\n\n\tpublic Tube(int x, int y, int r){\n\t\tthis.x = (double)x;\n\t\tthis.y = (double)y;\n\t\tthis.r = (double)r;\n\t}\n}", "sampled": "import java.util.*;\nimport java.io.*;\n\npublic class Main {\n    static class Circle {\n        double x, y, r;\n        Circle(double x, double y, double r) {\n            this.x = x;\n            this.y = y;\n            this.r = r;\n        }\n    }\n    \n    public static void main(String[] args) throws IOException {\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        String line;\n        \n        while ((line = br.readLine()) != null) {\n            int n = Integer.parseInt(line.trim());\n            if (n == 0) break;\n            \n            Circle[] walls = new Circle[n];\n            for (int i = 0; i < n; i++) {\n                String[] parts = br.readLine().trim().split(\"\\\\s+\");\n                double wx = Double.parseDouble(parts[0]);\n                double wy = Double.parseDouble(parts[1]);\n                double r = Double.parseDouble(parts[2]);\n                walls[i] = new Circle(wx, wy, r);\n            }\n            \n            int m = Integer.parseInt(br.readLine().trim());\n            for (int i = 0; i < m; i++) {\n                String[] parts = br.readLine().trim().split(\"\\\\s+\");\n                double tx = Double.parseDouble(parts[0]);\n                double ty = Double.parseDouble(parts[1]);\n                double sx = Double.parseDouble(parts[2]);\n                double sy = Double.parseDouble(parts[3]);\n                \n                boolean visible = isVisible(tx, ty, sx, sy, walls);\n                System.out.println(visible ? \"Danger\" : \"Safe\");\n            }\n        }\n    }\n    \n    static boolean isVisible(double tx, double ty, double sx, double sy, Circle[] walls) {\n        // Check if both points are inside the same wall\n        for (Circle wall : walls) {\n            boolean tInside = isInside(tx, ty, wall);\n            boolean sInside = isInside(sx, sy, wall);\n            \n            if (tInside && sInside) {\n                // Both inside same wall - check if line segment intersects any other wall\n                boolean blocked = false;\n                for (Circle other : walls) {\n                    if (other == wall) continue;\n                    if (lineIntersectsCircle(tx, ty, sx, sy, other)) {\n                        blocked = true;\n                        break;\n                    }\n                }\n                if (!blocked) return true;\n            } else if (tInside || sInside) {\n                // One inside, one outside - not visible\n                return false;\n            }\n        }\n        \n        // Both outside all walls - check if line segment intersects any wall\n        for (Circle wall : walls) {\n            if (lineIntersectsCircle(tx, ty, sx, sy, wall)) {\n                return false;\n            }\n        }\n        \n        return true;\n    }\n    \n    static boolean isInside(double px, double py, Circle circle) {\n        double dx = px - circle.x;\n        double dy = py - circle.y;\n        return dx * dx + dy * dy < circle.r * circle.r;\n    }\n    \n    static boolean lineIntersectsCircle(double x1, double y1, double x2, double y2, Circle circle) {\n        double dx = x2 - x1;\n        double dy = y2 - y1;\n        double fx = x1 - circle.x;\n        double fy = y1 - circle.y;\n        \n        double a = dx * dx + dy * dy;\n        double b = 2 * (fx * dx + fy * dy);\n        double c = fx * fx + fy * fy - circle.r * circle.r;\n        \n        double discriminant = b * b - 4 * a * c;\n        \n        if (discriminant < 0) {\n            return false;\n        }\n        \n        double sqrtDisc = Math.sqrt(discriminant);\n        double t1 = (-b - sqrtDisc) / (2 * a);\n        double t2 = (-b + sqrtDisc) / (2 * a);\n        \n        // Check if intersection points are within the line segment\n        if ((t1 >= 0 && t1 <= 1) || (t2 >= 0 && t2 <= 1)) {\n            return true;\n        }\n        \n        // Check if the segment is completely inside the circle\n        if (t1 < 0 && t2 > 1) {\n            return true;\n        }\n        \n        return false;\n    }\n}\n", "perturbed_sampled": [" class Main {  x, y, r;   BufferedReader br = new BufferedReader(new InputStreamReader(System.in)); String line; while  Integer.parseInt(line.trim());  Circle[n]; for (int    Double.parseDouble(parts[2]); walls[i] = new   < m; i++) { String[] parts  Double.parseDouble(parts[0]); double ty = Double.parseDouble(parts[1]); double sx  isVisible(tx, ty, sx, sy,  \"Safe\"); } } } static boolean isVisible(double tx,  sy,   the  :  isInside(tx, ty, wall);  wall); if  Both inside same  segment intersects any other  other)) {  true; } else if (tInside ||  one outside - not visible return false;  if line segment intersects any  walls) { if (lineIntersectsCircle(tx,  return false; } } return true; } static boolean  circle) { double dx = px -    x1,  y2, Circle circle) { double dx = x2 -  - y1; double  = dx * dx  b =  + fy *  * fx + fy * fy - circle.r * circle.r; double discriminant = b * b - 4  (discriminant < 0) {   (-b - sqrtDisc) / (2 * a); double t2 =  *  line   (t2 >= 0 && t2 <= 1)) {   (t1 < 0 && t2 > 1) {  } }"], "perturbed_original": ["import java.io.*; import java.util.*;  new Main(); }catch(IOException e){ e.printStackTrace(); } } public Main()  new BufferedReader(new InputStreamReader(System.in)); List<Integer> Ans  while((line =  = Integer.parseInt(line);   n++){ line  = Integer.parseInt(dst[0]);  r = Integer.parseInt(dst[2]); tubes[n] = new Tube(x, y,  int nSet  n++){ line = in.readLine(); String[] dst = line.split(\"   x2  Double.parseDouble(dst[3]);  m=0; m<tubes.length; m++){ double a,  x0, min, max; if(x1 !=  = y1 - p * x1;       + b * x1 + c; e2 = a * x2  x2 + c; x0 = - b / (2.0 * a); min = Math.min(x1,  Math.pow(tubes[m].y, 2.0) + Math.pow(x1 - tubes[m].x, 2.0) - Math.pow(tubes[m].r, 2.0); d =  *  y1 + b * y1 + c; e2 = a * y2 *  Math.min(y1, y2); max = Math.max(y1, y2); } if(x0  max){ if(d*e1 >= 0  hide =  1; break; } }  n=0; n<Ans.size(); n++){  } }   int r){  (double)y; this.r = (double)r; } }"], "original_ll": -0.6500680446624756, "sampled_ll": -0.4632396697998047, "all_perturbed_sampled_ll": [-3.1039040088653564], "all_perturbed_original_ll": [-2.7629055976867676], "perturbed_sampled_ll": -3.1039040088653564, "perturbed_original_ll": -2.7629055976867676, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import math as M\ndef R(A): return (A[0]**2+A[1]**2)**.5\ndef I(i): return [map(int,raw_input().split()) for _ in [0]*i]\ndef C(a,b): return a>b or abs(a-b)<1e-6\ndef f(e1):\n  tx,ty,sx,sy=e1\n  x=[]\n  for e2 in WP:\n    wx,wy,r=e2\n    wt=[tx-wx,ty-wy]; rwt=R(wt)\n    sw=[wx-sx,wy-sy]; rsw=R(sw)\n    st=[tx-sx,ty-sy]; rst=R(st)\n    F=[rwt<r,rsw<r]\n    if rst==0: c=1\n    elif F==[1,1]: c=1\n    elif F==[1,0] or F==[0,1]: c=0\n    elif F==[0,0]:\n      c=0\n      a=M.pi/2-M.acos(r/rsw)\n      b=M.acos((sw[0]*st[0]+sw[1]*st[1])/rsw/rst)\n#      if C(a,b) and C(rst**2,rsw**2-r**2): c=0\n#      else: c=1\n    x.append(c)\n  return all(x)\n\nwhile 1:\n  n=input()\n  if n==0: break\n  WP=I(n)\n  P=I(input())\n  for e in P: print [\"Safe\",\"Danger\"][f(e)]", "sampled": "import math\n\ndef point_in_circle(px, py, cx, cy, r):\n    dist_sq = (px - cx) ** 2 + (py - cy) ** 2\n    return dist_sq < r ** 2\n\ndef line_segment_intersects_circle(x1, y1, x2, y2, cx, cy, r):\n    # Check if either endpoint is inside the circle\n    if point_in_circle(x1, y1, cx, cy, r) or point_in_circle(x2, y2, cx, cy, r):\n        return True\n    \n    # Vector from point 1 to point 2\n    dx = x2 - x1\n    dy = y2 - y1\n    \n    # Vector from point 1 to circle center\n    fx = x1 - cx\n    fy = y1 - cy\n    \n    # Quadratic equation coefficients for line-circle intersection\n    a = dx * dx + dy * dy\n    b = 2 * (fx * dx + fy * dy)\n    c = fx * fx + fy * fy - r * r\n    \n    discriminant = b * b - 4 * a * c\n    \n    if discriminant < 0:\n        return False\n    \n    # Check if intersection points are within the line segment\n    sqrt_discriminant = math.sqrt(discriminant)\n    t1 = (-b - sqrt_discriminant) / (2 * a)\n    t2 = (-b + sqrt_discriminant) / (2 * a)\n    \n    # Check if any t is in [0, 1]\n    if (0 <= t1 <= 1) or (0 <= t2 <= 1):\n        return True\n    \n    return False\n\ndef is_visible(tx, ty, sx, sy, walls):\n    # Check if both Taro and Oni are inside the same wall\n    taro_walls = []\n    oni_walls = []\n    \n    for wx, wy, r in walls:\n        if point_in_circle(tx, ty, wx, wy, r):\n            taro_walls.append((wx, wy, r))\n        if point_in_circle(sx, sy, wx, wy, r):\n            oni_walls.append((wx, wy, r))\n    \n    # If they are both inside the same wall\n    for tw in taro_walls:\n        if tw in oni_walls:\n            # They are in the same wall, check if any other wall blocks\n            for wx, wy, r in walls:\n                if (wx, wy, r) != tw:\n                    if line_segment_intersects_circle(tx, ty, sx, sy, wx, wy, r):\n                        return False\n            return True\n    \n    # If one is inside a wall and the other is not, they can't see each other\n    if len(taro_walls) > 0 or len(oni_walls) > 0:\n        return False\n    \n    # Both are outside all walls, check if any wall blocks the line of sight\n    for wx, wy, r in walls:\n        if line_segment_intersects_circle(tx, ty, sx, sy, wx, wy, r):\n            return False\n    \n    return True\n\nwhile True:\n    n = int(input())\n    if n == 0:\n        break\n    \n    walls = []\n    for _ in range(n):\n        wx, wy, r = map(int, input().split())\n        walls.append((wx, wy, r))\n    \n    m = int(input())\n    for _ in range(m):\n        tx, ty, sx, sy = map(int, input().split())\n        if is_visible(tx, ty, sx, sy, walls):\n            print(\"Danger\")\n        else:\n            print(\"Safe\")\n", "perturbed_sampled": ["import math def point_in_circle(px, py, cx, cy, r):  ** 2  2 return dist_sq <  y1, x2, y2, cx, cy,  circle if point_in_circle(x1,  point_in_circle(x2, y2, cx, cy, r): return True # Vector from point 1 to point   y1 #  x1 - cx fy = y1 - cy  dy * dy b =  c = fx  fy  = b * b - 4 * a *  if  line segment  # Check if  1]  True return False def is_visible(tx, ty, sx, sy, walls): # Check if  inside the  walls: if point_in_circle(tx, ty, wx, wy, r): taro_walls.append((wx, wy, r)) if point_in_circle(sx, sy, wx, wy, r): oni_walls.append((wx, wy, r)) # If they are both inside the same  if tw in oni_walls: #  wall, check  for wx, wy, r  r) != tw: if line_segment_intersects_circle(tx, ty,  #    Both are outside all  blocks the line  r  True while True: n     sx,  is_visible(tx, ty, sx, sy, walls): print(\"Danger\") else: print(\"Safe\")"], "perturbed_original": ["import math as M def R(A):  f(e1): tx,ty,sx,sy=e1 x=[] for e2   if rst==0:  F==[1,0] or F==[0,1]: c=0 elif   return all(x) while  WP=I(n) P=I(input()) for e in P: print [\"Safe\",\"Danger\"][f(e)]"], "original_ll": -1.749093770980835, "sampled_ll": -0.6696426272392273, "all_perturbed_sampled_ll": [-2.8640997409820557], "all_perturbed_original_ll": [-4.342107772827148], "perturbed_sampled_ll": -2.8640997409820557, "perturbed_original_ll": -4.342107772827148, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "#include<stdio.h>\n#include<string.h>\nint n,i,j,p;\nchar c,t,l[27];\nint main()\n{\n\tscanf(\"%d\",&n);\n\tgetchar();\n\tfor(i=0;i<n;i++)\n\t{\n\t\tp=13;\n\t\tmemset(l,0,27);\n\t\tfor(;scanf(\"%c\",&l[p])!=-1;)\n\t\t{\n\t\t\t~scanf(\"%c\",&c);\n\t\t\tif(c=='-'||c=='<')\n\t\t\t\tgetchar(),c=='-'?p++:p--;\n\t\t\telse\n\t\t\t\tbreak;\n\t\t}\n\t\tfor(j=0;!l[j];j++);\n\t\tputs(l+j);\n\t}\n\treturn 0;\n}", "sampled": "#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n\nint main() {\n    int n;\n    scanf(\"%d\", &n);\n    getchar();\n    \n    for (int i = 0; i < n; i++) {\n        char line[1025];\n        fgets(line, 1025, stdin);\n        \n        // Parse the movements\n        char cars[26];\n        int carCount = 0;\n        int carPos[26]; // Position of each car (a-z)\n        for (int j = 0; j < 26; j++) {\n            carPos[j] = -1;\n        }\n        \n        // Parse first car\n        char currentCar = line[0];\n        cars[carCount] = currentCar;\n        carPos[currentCar - 'a'] = carCount;\n        carCount++;\n        \n        int pos = 0;\n        int minPos = 0, maxPos = 0;\n        \n        // Parse movements\n        int idx = 1;\n        while (line[idx] != '\\0' && line[idx] != '\\n') {\n            // Read direction\n            char dir[3];\n            dir[0] = line[idx];\n            dir[1] = line[idx + 1];\n            dir[2] = '\\0';\n            idx += 2;\n            \n            // Read next car\n            char nextCar = line[idx];\n            idx++;\n            \n            int nextCarIdx = nextCar - 'a';\n            \n            if (strcmp(dir, \"->\") == 0) {\n                // Moving to next car (right)\n                if (carPos[nextCarIdx] == -1) {\n                    // New car on the right\n                    pos++;\n                    carPos[nextCarIdx] = pos;\n                    if (pos > maxPos) maxPos = pos;\n                } else {\n                    pos = carPos[nextCarIdx];\n                }\n            } else { // \"<-\"\n                // Moving to previous car (left)\n                if (carPos[nextCarIdx] == -1) {\n                    // New car on the left\n                    pos--;\n                    carPos[nextCarIdx] = pos;\n                    if (pos < minPos) minPos = pos;\n                } else {\n                    pos = carPos[nextCarIdx];\n                }\n            }\n        }\n        \n        // Build result string\n        int length = maxPos - minPos + 1;\n        char result[27];\n        for (int j = 0; j < length; j++) {\n            result[j] = ' ';\n        }\n        result[length] = '\\0';\n        \n        for (int j = 0; j < 26; j++) {\n            if (carPos[j] != -1) {\n                int actualPos = carPos[j] - minPos;\n                result[actualPos] = 'a' + j;\n            }\n        }\n        \n        printf(\"%s\\n\", result);\n    }\n    \n    return 0;\n}\n", "perturbed_sampled": ["#include <stdio.h> #include  &n); getchar();  int carCount = 0; int carPos[26];  (a-z)  j <  -1;   =  carCount;  int minPos   != '\\n') { // Read direction char dir[3];   char  'a'; if (strcmp(dir, \"->\") == 0)    on the  maxPos = pos; } else { pos  {  (carPos[nextCarIdx] == -1) { // New car on the left pos--; carPos[nextCarIdx] =  minPos = pos; } else { pos = carPos[nextCarIdx]; } } } // Build result  j = 0; j <  ' '; } result[length] = '\\0'; for  < 26; j++) { if (carPos[j] != -1) { int actualPos = carPos[j]   result); } return 0; }"], "perturbed_original": ["#include<stdio.h> #include<string.h> int n,i,j,p;  scanf(\"%d\",&n);  for(;scanf(\"%c\",&l[p])!=-1;)  } return 0; }"], "original_ll": -1.661453127861023, "sampled_ll": -0.6973742842674255, "all_perturbed_sampled_ll": [-2.9103150367736816], "all_perturbed_original_ll": [-2.7611241340637207], "perturbed_sampled_ll": -2.9103150367736816, "perturbed_original_ll": -2.7611241340637207, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "package jp.ac.saburou.volume1;\n\nimport java.util.Scanner;\n\nclass p130 {\n\tpublic static void main(String[] args) {\n\t\tScanner s = new Scanner(System.in);\n\t\tint n = s.nextInt();\n\t\tint[][] result = null;\n\t\tfor (int t = 0; t < n; t++) {\n\t\t\tchar[] train = s.next().toCharArray();\n\t\t\tif (train.length > 1) {\n\t\t\t\tresult = createTrainGraph(train);\n\t\t\t\t/* \u5148\u982d\u8eca\u4e21\u3092\u6c7a\u5b9a\u3059\u308b */\n\t\t\t\tint next = NO_CONNECTION;\n\t\t\t\tfor (int i = 0; i < result.length; i++) {\n\t\t\t\t\tif (result[i][0] == NO_CONNECTION\n\t\t\t\t\t\t\t&& result[i][1] != NO_CONNECTION) {\n\t\t\t\t\t\tnext = i;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t/* \u51fa\u529b */\n\t\t\t\twhile (next != -1) {\n\t\t\t\t\tSystem.out.printf(\"%c\", next + 'a');\n\t\t\t\t\tnext = result[next][REAR];\n\t\t\t\t}\n\t\t\t\tSystem.out.println();\n\t\t\t} else {\n\t\t\t\tSystem.out.println(train[0]);\n\t\t\t}\n\t\t}\n\t}\n\n\tstatic final int FRONT = 0;\n\tstatic final int REAR = 1;\n\tstatic final int NO_CONNECTION = -1;\n\n\tstatic int[][] createTrainGraph(char[] input) {\n\t\tint[][] train = new int[26][2];\n\t\tfor (int i = 0; i < train.length; i++) {\n\t\t\tfor (int j = 0; j < train[0].length; j++) {\n\t\t\t\ttrain[i][j] = NO_CONNECTION;\n\t\t\t}\n\t\t}\n\t\tboolean front = false;\n\t\tint before = input[0];\n\t\tfor (int i = 1; i < input.length; i++) {\n\t\t\tint current = input[i];\n\t\t\tif ('a' <= current && current <= 'z') {\n\t\t\t\tif (front) {\n\t\t\t\t\ttrain[before - 'a'][FRONT] = current - 'a';\n\t\t\t\t\ttrain[current - 'a'][REAR] = before - 'a';\n\t\t\t\t} else {\n\t\t\t\t\ttrain[before - 'a'][REAR] = current - 'a';\n\t\t\t\t\ttrain[current - 'a'][FRONT] = before - 'a';\n\t\t\t\t}\n\t\t\t\tbefore = current;\n\t\t\t} else if (current == '>') {\n\t\t\t\tfront = false;\n\t\t\t} else if (current == '<') {\n\t\t\t\tfront = true;\n\t\t\t}\n\t\t}\n\t\treturn train;\n\t}\n}", "sampled": "import java.util.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int n = sc.nextInt();\n        sc.nextLine();\n        \n        for (int i = 0; i < n; i++) {\n            String line = sc.nextLine();\n            System.out.println(solve(line));\n        }\n        sc.close();\n    }\n    \n    static String solve(String record) {\n        String[] tokens = record.split(\"(<-|->)\");\n        String[] directions = record.split(\"[a-z]\");\n        \n        Map<Character, Set<Character>> next = new HashMap<>();\n        Map<Character, Set<Character>> prev = new HashMap<>();\n        Set<Character> cars = new HashSet<>();\n        \n        for (String token : tokens) {\n            if (!token.isEmpty()) {\n                char c = token.charAt(0);\n                cars.add(c);\n                next.putIfAbsent(c, new HashSet<>());\n                prev.putIfAbsent(c, new HashSet<>());\n            }\n        }\n        \n        for (int i = 0; i < tokens.length - 1; i++) {\n            char from = tokens[i].charAt(0);\n            char to = tokens[i + 1].charAt(0);\n            String dir = directions[i + 1];\n            \n            if (dir.equals(\"->\")) {\n                next.get(from).add(to);\n                prev.get(to).add(from);\n            } else {\n                prev.get(from).add(to);\n                next.get(to).add(from);\n            }\n        }\n        \n        // Build the train\n        List<Character> train = new ArrayList<>();\n        \n        // Find a starting car (one with no prev or just one end)\n        char start = ' ';\n        for (char c : cars) {\n            Set<Character> p = prev.get(c);\n            Set<Character> n = next.get(c);\n            \n            // Remove inconsistencies\n            p.removeAll(n);\n            n.removeAll(p);\n            \n            if (p.isEmpty()) {\n                start = c;\n                break;\n            }\n        }\n        \n        if (start == ' ') {\n            start = cars.iterator().next();\n        }\n        \n        // Build forward\n        Set<Character> visited = new HashSet<>();\n        char current = start;\n        train.add(current);\n        visited.add(current);\n        \n        while (true) {\n            Set<Character> nextCars = next.get(current);\n            nextCars.removeAll(prev.get(current));\n            \n            char nextCar = ' ';\n            for (char c : nextCars) {\n                if (!visited.contains(c)) {\n                    nextCar = c;\n                    break;\n                }\n            }\n            \n            if (nextCar == ' ') break;\n            \n            train.add(nextCar);\n            visited.add(nextCar);\n            current = nextCar;\n        }\n        \n        // Build backward from start\n        current = start;\n        while (true) {\n            Set<Character> prevCars = prev.get(current);\n            prevCars.removeAll(next.get(current));\n            \n            char prevCar = ' ';\n            for (char c : prevCars) {\n                if (!visited.contains(c)) {\n                    prevCar = c;\n                    break;\n                }\n            }\n            \n            if (prevCar == ' ') break;\n            \n            train.add(0, prevCar);\n            visited.add(prevCar);\n            current = prevCar;\n        }\n        \n        StringBuilder result = new StringBuilder();\n        for (char c : train) {\n            result.append(c);\n        }\n        \n        return result.toString();\n    }\n}\n", "perturbed_sampled": [" main(String[] args)   Map<Character, Set<Character>> next = new  new HashMap<>(); Set<Character> cars =  : tokens)  c =  prev.putIfAbsent(c, new HashSet<>()); }  0; i < tokens.length  directions[i + 1]; if (dir.equals(\"->\")) { next.get(from).add(to); prev.get(to).add(from); } else { prev.get(from).add(to); next.get(to).add(from); } }  train = new  ' '; for (char c : cars) { Set<Character> p = prev.get(c); Set<Character> n = next.get(c); //  (p.isEmpty()) { start =  } // Build forward Set<Character> visited = new HashSet<>(); char   = next.get(current); nextCars.removeAll(prev.get(current)); char nextCar  if  (nextCar == ' ') break; train.add(nextCar);  // Build  start; while (true) {  char prevCar = ' '; for (char c : prevCars) { if (!visited.contains(c)) {  } if (prevCar == ' ') break;  (char  } return result.toString(); } }"], "perturbed_original": ["package jp.ac.saburou.volume1; import java.util.Scanner; class p130 { public static void main(String[]  new Scanner(System.in); int n = s.nextInt(); int[][] result = null;   if (train.length > 1) { result = createTrainGraph(train); /* \u5148\u982d\u8eca\u4e21\u3092\u6c7a\u5b9a\u3059\u308b */ int next  = 0;  if (result[i][0] == NO_CONNECTION && result[i][1] != NO_CONNECTION) {  System.out.printf(\"%c\", next + 'a'); next =  final int  int NO_CONNECTION = -1; static int[][] createTrainGraph(char[] input)  train.length; i++) { for  train[i][j] = NO_CONNECTION; } }  before =  <= 'z') { if (front) {   -  else if (current == '>') { front = false; } else if  return train; } }"], "original_ll": -0.8345298767089844, "sampled_ll": -0.6184890866279602, "all_perturbed_sampled_ll": [-2.531465768814087], "all_perturbed_original_ll": [-2.9279935359954834], "perturbed_sampled_ll": -2.531465768814087, "perturbed_original_ll": -2.9279935359954834, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "# AOJ 0130 Train\n# Python3 2018.6.19 bal4u\n\nfor _ in range(int(input())):\n\ts = list(input())\n\tans = []\n\tdir = '>'\n\tfor i in range(len(s)):\n\t\tif s[i].isalpha():\n\t\t\tif dir == '>':\n\t\t\t\tif s[i] not in ans: ans.append(s[i])\n\t\t\telse:\n\t\t\t\tif s[i] not in ans: ans.insert(0, s[i])\n\t\telif s[i] == '>' or s[i] == '<': dir = s[i]\n\tprint(*ans, sep='')\n", "sampled": "def solve(s):\n    # Parse the movements\n    tokens = s.replace('<-', ' <- ').replace('->', ' -> ').split()\n    \n    # Build adjacency relationships\n    cars = set()\n    neighbors = {}\n    \n    current = tokens[0]\n    cars.add(current)\n    \n    i = 1\n    while i < len(tokens):\n        direction = tokens[i]\n        next_car = tokens[i + 1]\n        cars.add(next_car)\n        \n        if current not in neighbors:\n            neighbors[current] = set()\n        if next_car not in neighbors:\n            neighbors[next_car] = set()\n        \n        neighbors[current].add(next_car)\n        neighbors[next_car].add(current)\n        \n        current = next_car\n        i += 2\n    \n    # Find the train composition (it forms a path)\n    # Find cars with degree 1 (endpoints)\n    endpoints = []\n    for car in cars:\n        if car not in neighbors or len(neighbors[car]) == 1:\n            endpoints.append(car)\n    \n    # If no endpoints found (circular), pick any car\n    if not endpoints:\n        endpoints = [list(cars)[0]]\n    \n    # Build the path from one endpoint\n    start = endpoints[0]\n    path = [start]\n    visited = {start}\n    current = start\n    \n    while True:\n        if current not in neighbors:\n            break\n        next_found = False\n        for next_car in neighbors[current]:\n            if next_car not in visited:\n                path.append(next_car)\n                visited.add(next_car)\n                current = next_car\n                next_found = True\n                break\n        if not next_found:\n            break\n    \n    return ''.join(path)\n\nn = int(input())\nfor _ in range(n):\n    s = input().strip()\n    print(solve(s))\n", "perturbed_sampled": [" movements tokens = s.replace('<-', ' <- ').replace('->', '  neighbors = {} current = tokens[0] cars.add(current) i  len(tokens): direction = tokens[i] next_car  neighbors: neighbors[current] = set() if next_car   composition (it forms a  = [] for  not in  endpoints.append(car) # If no endpoints found (circular), pick any car if not endpoints: endpoints =   endpoints[0] path =  = start  in neighbors: break next_found = False  break return  = input().strip() print(solve(s))"], "perturbed_original": ["# AOJ 0130  s   in range(len(s)): if s[i].isalpha():  s[i] not in ans: ans.append(s[i]) else: if s[i] not in  s[i] print(*ans, sep='')"], "original_ll": -1.5715724229812622, "sampled_ll": -1.0423117876052856, "all_perturbed_sampled_ll": [-4.475594997406006], "all_perturbed_original_ll": [-2.7525603771209717], "perturbed_sampled_ll": -4.475594997406006, "perturbed_original_ll": -2.7525603771209717, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "#include<stdio.h>\n#include<string.h>\nint main(){\n\tint i,j,n,s[12][12],a[12][12];\n\tscanf(\"%d\",&n);\n\twhile(n--){\n\t\tfor(i=0;i<10;i++)for(j=0;j<10;j++)scanf(\"%d\",&s[i][j]);\n\t\tmemset(a,0,sizeof(a));\n\t\tfor(i=0;i<9;i++){\n\t\t\tfor(j=0;j<10;j++){\n\t\t\t\tif(s[i][j]%2==1){\n\t\t\t\t\ta[i+1][j]=1;\n\t\t\t\t\ts[i][j]++;\n\t\t\t\t\ts[i+1][j]++;\n\t\t\t\t\ts[i+1][j-1]++;\n\t\t\t\t\ts[i+1][j+1]++;\n\t\t\t\t\ts[i+2][j]++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(i=0;i<10;i++){for(j=0;j<10;j++)printf(\"%d \",a[i][j]);printf(\"\\n\");}\n\t}\n\treturn 0;\n}", "sampled": "#include <stdio.h>\n\nint main() {\n    int n;\n    scanf(\"%d\", &n);\n    \n    while (n--) {\n        int grid[10][10];\n        int solution[10][10] = {0};\n        \n        // Read input\n        for (int i = 0; i < 10; i++) {\n            for (int j = 0; j < 10; j++) {\n                scanf(\"%d\", &grid[i][j]);\n            }\n        }\n        \n        // Solve using Gaussian elimination in GF(2)\n        // Each cell (i,j) being hit affects itself and neighbors\n        // We need to solve: A*x = b where A is the effect matrix\n        \n        // Create augmented matrix\n        int matrix[100][101];\n        for (int i = 0; i < 100; i++) {\n            for (int j = 0; j <= 100; j++) {\n                matrix[i][j] = 0;\n            }\n        }\n        \n        // Build the system of equations\n        for (int row = 0; row < 10; row++) {\n            for (int col = 0; col < 10; col++) {\n                int eq = row * 10 + col;\n                matrix[eq][100] = grid[row][col];\n                \n                // Check which positions affect this cell\n                for (int r = 0; r < 10; r++) {\n                    for (int c = 0; c < 10; c++) {\n                        int var = r * 10 + c;\n                        // Position (r,c) affects (row,col) if:\n                        // - (r,c) == (row,col) or\n                        // - (r,c) is adjacent to (row,col)\n                        if ((r == row && c == col) ||\n                            (r == row && (c == col-1 || c == col+1)) ||\n                            (c == col && (r == row-1 || r == row+1))) {\n                            matrix[eq][var] = 1;\n                        }\n                    }\n                }\n            }\n        }\n        \n        // Gaussian elimination in GF(2)\n        for (int col = 0; col < 100; col++) {\n            // Find pivot\n            int pivot = -1;\n            for (int row = col; row < 100; row++) {\n                if (matrix[row][col] == 1) {\n                    pivot = row;\n                    break;\n                }\n            }\n            \n            if (pivot == -1) continue;\n            \n            // Swap rows\n            if (pivot != col) {\n                for (int j = 0; j <= 100; j++) {\n                    int temp = matrix[col][j];\n                    matrix[col][j] = matrix[pivot][j];\n                    matrix[pivot][j] = temp;\n                }\n            }\n            \n            // Eliminate\n            for (int row = 0; row < 100; row++) {\n                if (row != col && matrix[row][col] == 1) {\n                    for (int j = 0; j <= 100; j++) {\n                        matrix[row][j] ^= matrix[col][j];\n                    }\n                }\n            }\n        }\n        \n        // Back substitution to get solution\n        int result[100] = {0};\n        for (int i = 0; i < 100; i++) {\n            result[i] = matrix[i][100];\n        }\n        \n        // Convert to 2D and output\n        for (int i = 0; i < 10; i++) {\n            for (int j = 0; j < 10; j++) {\n                if (j > 0) printf(\" \");\n                printf(\"%d\", result[i * 10 + j]);\n            }\n            printf(\"\\n\");\n        }\n    }\n    \n    return 0;\n}\n", "perturbed_sampled": ["#include <stdio.h> int main() { int n; scanf(\"%d\", &n); while (n--) { int (i,j)<extra_id_5>10 + j]); }<extra_id_6>A*X =<extra_id_7>x<extra_id_8>15<extra_id_9>]<extra_id_10>0 ] ; if (<extra_id_11>[ j<extra_id_12>; j<extra_id_13>} var<extra_id_14>] ; break<extra_id_15>} matrix [<extra_id_16>j ] = A<extra_id_17>}<extra_id_18>] ,<extra_id_19>}<extra_id_20>x<extra_id_21>[<extra_id_22>x ] ; int x<extra_id_23>) { int // Read input for (int i = 0; i < 10; i++) { for (int j  j++)  elimination in GF(2) // Each cell (i,j) being hit affects itself and neighbors // We need to solve: A*x  the effect matrix // Create augmented matrix int matrix[100][101]; for (int   <= 100; j++) {  // Build the system of equations for (int  (int  eq = row  = grid[row][col];  this cell for (int r  r++) { for (int c = 0; c <   - (r,c)  (r,c)   == col+1))  }  elimination in GF(2) for (int col = 0; col < 100;   row < 100; row++) { if  -1) continue; // Swap  { for (int j = 0; j    col && matrix[row][col] ==  = 0; j <= 100; j++) {   (int i = 0;  and output for (int i = 0; i  {  10 + j]); }  }"], "perturbed_original": ["#include<stdio.h> #include<string.h>  while(n--){ for(i=0;i<10;i++)for(j=0;j<10;j++)scanf(\"%d\",&s[i][j]); memset(a,0,sizeof(a)); for(i=0;i<9;i++){ for(j=0;j<10;j++){  } for(i=0;i<10;i++){for(j=0;j<10;j++)printf(\"%d \",a[i][j]);printf(\"\\n\");} } return 0; }"], "original_ll": -0.7046756148338318, "sampled_ll": -0.6228181719779968, "all_perturbed_sampled_ll": [-2.586892604827881], "all_perturbed_original_ll": [-1.1859441995620728], "perturbed_sampled_ll": -2.586892604827881, "perturbed_original_ll": -1.1859441995620728, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import java.util.Scanner;\n\npublic class Main {\n\tstatic byte ans[][];\n\n\tpublic static boolean f(int a[][], int s[], int n) {\n\t\tif (10 <= n) {\n\t\t\tint b[][] = new int[10][10];\n\t\t\tans = new byte[10][10];\n\t\t\tfor (int i = 0; i < 10; i++) {\n\t\t\t\tfor (int j = 0; j < 10; j++) {\n\t\t\t\t\tb[i][j] = a[i][j];\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (int i = 0; i < 10; i++) {\n\t\t\t\tif (s[i] == 1) {\n\t\t\t\t\treverse(b, 0, i);\n\t\t\t\t\tans[0][i] = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (int i = 1; i < 10; i++) {\n\t\t\t\tfor (int j = 0; j < 10; j++) {\n\t\t\t\t\tif (b[i - 1][j] == 1) {\n\t\t\t\t\t\treverse(b, i, j);\n\t\t\t\t\t\tans[i][j] = 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (check(b)) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t} else {\n\t\t\ts[n] = 0;\n\t\t\tif (f(a, s, n + 1)) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\ts[n] = 1;\n\t\t\tif (f(a, s, n + 1)) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\n\tpublic static void reverse(int a[][], int i, int j) {\n\t\ta[i][j] = (a[i][j] + 1) % 2;\n\t\tif (0 <= i - 1) {\n\t\t\ta[i - 1][j] = (a[i - 1][j] + 1) % 2;\n\t\t}\n\t\tif (i + 1 < 10) {\n\t\t\ta[i + 1][j] = (a[i + 1][j] + 1) % 2;\n\t\t}\n\t\tif (0 <= j - 1) {\n\t\t\ta[i][j - 1] = (a[i][j - 1] + 1) % 2;\n\t\t}\n\t\tif (j + 1 < 10) {\n\t\t\ta[i][j + 1] = (a[i][j + 1] + 1) % 2;\n\t\t}\n\t}\n\n\tpublic static boolean check(int a[][]) {\n\t\tfor (int i = 0; i < 10; i++) {\n\t\t\tfor (int j = 0; j < 10; j++) {\n\t\t\t\tif (a[i][j] == 1) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n\n\tpublic static void main(String args[]) {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint n;\n\t\tint a[][];\n\n\t\tn = sc.nextInt();\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\ta = new int[10][10];\n\t\t\tfor (int j = 0; j < 10; j++) {\n\t\t\t\tfor (int k = 0; k < 10; k++) {\n\t\t\t\t\ta[j][k] = sc.nextInt();\n\t\t\t\t}\n\t\t\t}\n\t\t\tf(a, new int[10], 0);\n\t\t\tfor (int j = 0; j < 10; j++) {\n\t\t\t\tString s = \"\";\n\t\t\t\tfor (int k = 0; k < 10; k++) {\n\t\t\t\t\tSystem.out.print(s + ans[j][k]);\n\t\t\t\t\ts = \" \";\n\t\t\t\t}\n\t\t\t\tSystem.out.println();\n\t\t\t}\n\t\t}\n\t}\n}", "sampled": "import java.util.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int n = sc.nextInt();\n        \n        for (int t = 0; t < n; t++) {\n            int[][] grid = new int[10][10];\n            for (int i = 0; i < 10; i++) {\n                for (int j = 0; j < 10; j++) {\n                    grid[i][j] = sc.nextInt();\n                }\n            }\n            \n            int[][] result = solve(grid);\n            \n            for (int i = 0; i < 10; i++) {\n                for (int j = 0; j < 10; j++) {\n                    if (j > 0) System.out.print(\" \");\n                    System.out.print(result[i][j]);\n                }\n                System.out.println();\n            }\n        }\n        sc.close();\n    }\n    \n    static int[][] solve(int[][] grid) {\n        // Use Gaussian elimination over GF(2)\n        // Each cell (i,j) can be toggled, affecting itself and neighbors\n        // We need to solve for which cells to toggle to turn all lights off\n        \n        int[][] solution = new int[10][10];\n        \n        // Create augmented matrix for the system\n        // 100 variables (one for each cell), 100 equations (one for each cell)\n        int size = 100;\n        int[][] matrix = new int[size][size + 1];\n        \n        // Build the system of equations\n        for (int i = 0; i < 10; i++) {\n            for (int j = 0; j < 10; j++) {\n                int row = i * 10 + j;\n                \n                // Check which toggles affect cell (i,j)\n                for (int ti = 0; ti < 10; ti++) {\n                    for (int tj = 0; tj < 10; tj++) {\n                        int col = ti * 10 + tj;\n                        \n                        // Cell (ti,tj) affects (i,j) if they are adjacent\n                        if ((ti == i && tj == j) ||\n                            (ti == i && Math.abs(tj - j) == 1) ||\n                            (tj == j && Math.abs(ti - i) == 1)) {\n                            matrix[row][col] = 1;\n                        }\n                    }\n                }\n                \n                // Right side: current state of cell (i,j)\n                matrix[row][size] = grid[i][j];\n            }\n        }\n        \n        // Gaussian elimination in GF(2)\n        for (int col = 0; col < size; col++) {\n            // Find pivot\n            int pivot = -1;\n            for (int row = col; row < size; row++) {\n                if (matrix[row][col] == 1) {\n                    pivot = row;\n                    break;\n                }\n            }\n            \n            if (pivot == -1) continue;\n            \n            // Swap rows\n            if (pivot != col) {\n                int[] temp = matrix[col];\n                matrix[col] = matrix[pivot];\n                matrix[pivot] = temp;\n            }\n            \n            // Eliminate\n            for (int row = 0; row < size; row++) {\n                if (row != col && matrix[row][col] == 1) {\n                    for (int c = 0; c <= size; c++) {\n                        matrix[row][c] ^= matrix[col][c];\n                    }\n                }\n            }\n        }\n        \n        // Back substitution\n        int[] vars = new int[size];\n        for (int i = 0; i < size; i++) {\n            vars[i] = matrix[i][size];\n        }\n        \n        // Convert to 2D array\n        for (int i = 0; i < 10; i++) {\n            for (int j = 0; j < 10; j++) {\n                solution[i][j] = vars[i * 10 + j];\n            }\n        }\n        \n        return solution;\n    }\n}\n", "perturbed_sampled": ["import java.util.*; public class Main   int[10][10]; for (int i  j = 0;  grid[i][j] = sc.nextInt(); } } int[][]  < 10; i++) { for (int j = 0;   \"); System.out.print(result[i][j]); } System.out.println(); } } sc.close(); } static  GF(2) // Each cell (i,j) can be toggled, affecting itself and neighbors // We need to solve for  turn all lights off int[][] solution = new int[10][10]; // Create  equations (one  = 100; int[][] matrix = new int[size][size +  0; j  for  * 10  affects (i,j) if they are adjacent if ((ti  j) || (ti == i &&  == 1)) { matrix[row][col]  //  cell  } // Gaussian elimination in GF(2) for (int col = 0; col < size;  int  < size; row++) { if  = row; break; } } if  !=  matrix[pivot] = temp; } // Eliminate for (int row = 0; row <  == 1) {  { matrix[row][c] ^= matrix[col][c];  Back substitution  for (int i = 0; i < size; i++) { vars[i] =   (int j = 0; j < 10; j++) {  return solution; } }"], "perturbed_original": ["import java.util.Scanner; public class Main {<extra_id_1>if (1)<extra_id_2>(int<extra_id_3>int n = sc.nextInt();<extra_id_4>1) { case<extra_id_5>j -<extra_id_6>) { char<extra_id_7>char c[i] = a[1][j<extra_id_8>c[i][j ] .<extra_id_9>] +<extra_id_10>[j-j] = (a[1][j]<extra_id_11>. s[n<extra_id_12>int<extra_id_13>) { int v [<extra_id_14>[<extra_id_15>] ==<extra_id_16>1  if  0;  for (int j = 0; j < 10; j++) { b[i][j] = a[i][j]; } } for (int i  i++) { if   i = 1; i < 10; i++)  - 1][j] == 1) {  1; } } } if   n + 1)) { return true; } s[n]   true; } } return false; } public static void reverse(int  { a[i][j] =  if (0  a[i - 1][j] = (a[i - 1][j]  +  } if  { a[i][j - 1] = (a[i][j -   + 1] = (a[i][j  2; }  a[][]) { for (int i = 0;  for (int j   1) {   void main(String args[]) { Scanner sc  int a[][]; n = sc.nextInt(); for (int i = 0;  for (int j = 0; j < 10; j++) { for  < 10; k++) { a[j][k]   } } }"], "original_ll": -0.4018569886684418, "sampled_ll": -0.6124557852745056, "all_perturbed_sampled_ll": [-2.8924596309661865], "all_perturbed_original_ll": [-2.187026023864746], "perturbed_sampled_ll": -2.8924596309661865, "perturbed_original_ll": -2.187026023864746, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "def attack(table, i, j):\n    table[i][j] = 1 - table[i][j]\n    table[i-1][j] = 1 - table[i-1][j]\n    table[i+1][j] = 1 - table[i+1][j]\n    table[i][j-1] = 1 - table[i][j-1]\n    table[i][j+1] = 1 - table[i][j+1]\n\ndef printans(ans):\n    for i in range(1, 11):\n        for j in range(1, 11):\n            print(ans[i][j], end=\"\")\n            if j < 10:\n                print(\" \", end=\"\")\n        print(\"\")\n\ndef solve(table, i, j, ans):\n\n    #print(i,j)\n    if i == 11:\n        flag = True\n        for k in range(1,11):\n            if table[10][k] == 1:\n                flag = False\n                break\n        if flag:\n            printans(ans)\n        return\n\n    if table[i-1][j] == 1:\n        ans[i][j] = 1\n        attack(table, i, j)\n        if j == 10:\n            solve(table, i+1, 1, ans)\n        else:\n            solve(table, i, j+1, ans)\n        attack(table, i, j)\n        ans[i][j] = 0\n    else:\n        ans[i][j] = 0\n        if j == 10:\n            solve(table, i+1, 1, ans)\n        else:\n            solve(table, i, j+1, ans)\n\n\ndef check(table, i, ans):\n\n    if i == 11:\n        solve(table, 2, 1, ans)\n        return\n\n    ans[1][i] = 0\n    check(table, i+1, ans)\n\n    ans[1][i] = 1\n    attack(table, 1, i)\n    check(table, i+1, ans)\n    attack(table, 1, i)\n\nN = int(input())\n\nfor l in range(N):\n    table= [[0 for i in range(12)] for j in range(12)]\n    ans= [[0 for i in range(12)] for j in range(12)]\n    for i in range(1, 11):\n        nums = [int(k) for k in input().split()]\n        for j in range(1, 11):\n            table[i][j] = nums[j-1]\n\n    check(table, 1, ans)\n", "sampled": "def solve_lights_out(grid):\n    # This is a lights-out puzzle problem over GF(2)\n    # We need to solve a system of linear equations in GF(2)\n    \n    # Create the coefficient matrix\n    # For a 10x10 grid, we have 100 variables and 100 equations\n    n = 10\n    size = n * n\n    \n    # Build the augmented matrix [A|b]\n    # A[i][j] = 1 if pressing button j affects light i\n    A = [[0] * size for _ in range(size)]\n    b = [0] * size\n    \n    # Fill the coefficient matrix\n    for i in range(n):\n        for j in range(n):\n            light_idx = i * n + j\n            b[light_idx] = grid[i][j]\n            \n            # Pressing button at (r, c) affects lights at (r, c) and adjacent cells\n            for r in range(n):\n                for c in range(n):\n                    button_idx = r * n + c\n                    \n                    # Check if pressing button (r,c) affects light (i,j)\n                    if (r == i and c == j):\n                        continue  # The button itself doesn't light up\n                    \n                    # Check if (i,j) is adjacent to (r,c)\n                    if (abs(r - i) + abs(c - j)) == 1:\n                        A[light_idx][button_idx] = 1\n    \n    # Gaussian elimination in GF(2)\n    augmented = [A[i] + [b[i]] for i in range(size)]\n    \n    # Forward elimination\n    for col in range(size):\n        # Find pivot\n        pivot_row = -1\n        for row in range(col, size):\n            if augmented[row][col] == 1:\n                pivot_row = row\n                break\n        \n        if pivot_row == -1:\n            continue\n        \n        # Swap rows\n        augmented[col], augmented[pivot_row] = augmented[pivot_row], augmented[col]\n        \n        # Eliminate\n        for row in range(size):\n            if row != col and augmented[row][col] == 1:\n                for k in range(size + 1):\n                    augmented[row][k] ^= augmented[col][k]\n    \n    # Back substitution\n    solution = [0] * size\n    for i in range(size):\n        if augmented[i][i] == 1:\n            solution[i] = augmented[i][size]\n    \n    # Convert solution to 2D grid\n    result = [[0] * n for _ in range(n)]\n    for i in range(n):\n        for j in range(n):\n            result[i][j] = solution[i * n + j]\n    \n    return result\n\n# Read input\nn_datasets = int(input())\nfor _ in range(n_datasets):\n    grid = []\n    for i in range(10):\n        row = list(map(int, input().split()))\n        grid.append(row)\n    \n    result = solve_lights_out(grid)\n    \n    for row in result:\n        print(' '.join(map(str, row)))\n", "perturbed_sampled": ["def solve_lights_out(grid):  puzzle problem over   equations in GF(2) # Create the coefficient matrix # For a  variables and 100 equations n =   i A =  in range(size)] b = [0] * size # Fill the coefficient   +  Pressing button at  (r, c) and adjacent cells for r in range(n): for c in range(n): button_idx  c #  affects light  itself doesn't light up #  [b[i]] for i in  -1 for row in range(col, size): if  row  continue # Swap rows augmented[col],  Eliminate for row in range(size): if  == 1:  # Back  1: solution[i] = augmented[i][size] #  n for _ in range(n)] for i in range(n): for  j] return result # Read input  in range(n_datasets): grid = [] for  in result: print(' '.join(map(str, row)))"], "perturbed_original": ["def attack(table, i, j): table[i][j] = 1 - table[i][j] table[i-1][j] = 1 - table[i-1][j] table[i+1][j] = 1    solve(table, i, j, ans): #print(i,j) if i == 11: flag = True for  == 1: flag = False break if flag:   i, j) if  1, ans) else: solve(table, i, j+1, ans)  0  i+1,  == 11:  ans[1][i] = 0 check(table, i+1, ans) ans[1][i] =  i) N  range(N): table= [[0 for  for i in  for k in input().split()] for  = nums[j-1] check(table, 1, ans)"], "original_ll": -0.623970627784729, "sampled_ll": -0.8954487442970276, "all_perturbed_sampled_ll": [-4.057770729064941], "all_perturbed_original_ll": [-2.2889556884765625], "perturbed_sampled_ll": -4.057770729064941, "perturbed_original_ll": -2.2889556884765625, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "#include <stdio.h>          // printf(), scanf()\n#include <stdlib.h>         // qsort()\n#include <string.h>         // memset(), memcpy(), strchr()\n#include <stdbool.h>\n\n// #define DEBUG 1\n\n#define MAX_W 20\n#define MAX_H 20\n#define MAX_N 10\n\ntypedef struct order_tbl\n{\n\tint s;\n\tint bx;\n\tint by;\n\tint angle;\n\tdouble rate;\n} order_t;\n\nconst char NUL = '\\0';\n\n#ifdef DEBUG\nstatic int O = 0;\n#endif\n\nint H, W;\nchar field[MAX_H][MAX_W + 1];\nchar puzzle[MAX_H][MAX_W + 1];\nint n;\nint h0[MAX_N][4];\nint w0[MAX_N][4];\nchar piece[MAX_N][4][MAX_H][MAX_W + 1];\nint k;\nint t[MAX_N];\n\nvoid\nbury(order_t *u)\n{\n\tint s = u->s;\n\tint a = u->angle;\n\tint h = h0[s][a];\n\tint w = w0[s][a];\n\n\tfor (int y = 0; y < h; ++y)\n\t{\n\t\tfor (int x = 0; x < w; ++x)\n\t\t{\n\t\t\tif (piece[s][a][y][x] == '#')\n\t\t\t\tfield[u->by + y][u->bx + x] = '*';\n\t\t}\n\t}\n}\n\ndouble\nfitin(order_t *u, int a, int bx, int by)\n{\n\tint s = u->s;\n\tint h = h0[s][a];\n\tint w = w0[s][a];\n\n\tint dx[4] = { 0, 1, 0,-1};\n\tint dy[4] = { 1, 0,-1, 0};\n\n\tint count = 0;\n\tint total = 0;\n\tfor (int x = -1; x <= w; ++x)\n\t{\n\t\tint nx = bx + x;\n\t\tfor (int y = -1; y <= h; ++y)\n\t\t{\n\t\t\tint ny = by + y;\n\t\t\tif (0 <= x && x < w && 0 <= y && y < h && piece[s][a][y][x] == '#')\n\t\t\t{\n\t\t\t\tif (0 <= nx && nx < W && 0 <= ny && ny < H && field[ny][nx] != '.')\n\t\t\t\t\treturn -100.0;\n\t\t\t}\n\t\t\telse // piece[s][a][y][x] == '.' ?\n\t\t\t{\n\t\t\t\tint i;\n\t\t\t\tfor (i = 0; i < 4; ++i)\n\t\t\t\t{\n\t\t\t\t\tint tx = x + dx[i], ty = y + dy[i];\n\t\t\t\t\tif (0 <= tx && tx < w && 0 <= ty && ty < h && piece[s][a][ty][tx] == '#')\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tif (i < 4)\n\t\t\t\t{\n\t\t\t\t\ttotal++;\n\t\t\t\t\tif (nx < 0 || W <= nx || ny < 0 || H <= ny || field[ny][nx] != '.')\n\t\t\t\t\t\tcount++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn count * 100.0 / total;\n}\n\nvoid\nprobe(order_t *u)\n{\n\tint s = u->s;\n\tfor (int a = 0; a < 4; ++a)\n\t{\n\t\tint h = h0[s][a];\n\t\tint w = w0[s][a];\n\n\t\tint fx = strchr(piece[s][a][0], '#') - piece[s][a][0];\n\t\tfor (int by = 0; by + h <= H; ++by)\n\t\t{\n\t\t\tfor (int bx = 0; bx + w <= W; ++bx)\n\t\t\t{\n\t\t\t\tif (field[by][bx + fx] == '.')\n\t\t\t\t{\n#ifdef DEBUG\n\t\t\t\t\tO++;\n#endif\n\t\t\t\t\tdouble r = fitin(u, a, bx, by);\n\t\t\t\t\tif (r > u->rate)\n\t\t\t\t\t{\n\t\t\t\t\t\tu->rate = r;\n\t\t\t\t\t\tu->bx = bx;\n\t\t\t\t\t\tu->by = by;\n\t\t\t\t\t\tu->angle = a;\n\n\t\t\t\t\t\tif (u->rate >= 100.0)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tbury(u);\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nint\ncmp_func(const void *l_, const void *r_)\n{\n\tconst order_t *l = (const order_t*) l_;\n\tconst order_t *r = (const order_t*) r_;\n\n\tif (l->rate < r->rate)\n\t\treturn 1;\n\n\tif (l->rate > r->rate)\n\t\treturn -1;\n\n\treturn 0;\n}\n\nbool\nsolve()\n{\n\torder_t u;\n\torder_t order[MAX_N];\n\tint memo[MAX_N];\n\tint ix, ix2;\n\n\tmemcpy(field, puzzle, sizeof(field));\n\tix = 0;\n\tfor (int i = 0; i < k; ++i)\n\t\tmemo[ix++] = t[i];\n\n\twhile (ix != 0)\n\t{\n\t\tix2 = 0;\n\t\tfor (int i = 0; i < ix; ++i)\n\t\t{\n#ifdef DEBUG\n\t\t\tmemset(&u, 0x00, sizeof(u));\n#endif\n\t\t\tu.s = memo[i];\n\t\t\tu.rate = -100.0;\n\t\t\tprobe(&u);\n\t\t\tif (u.rate != 100.0)\n\t\t\t\torder[ix2++] = u;\n\t\t}\n\n\t\tif (ix2 == 0)\n\t\t\tbreak;\n\n\t\tqsort(order, ix2, sizeof(order_t), cmp_func);\n\t\tif (order[0].rate == -100.0)\n\t\t\treturn false;\n\n\t\tbury(&order[0]);\n\n\t\tix = 0;\n\t\tfor (int i = 1; i < ix2; ++i)\n\t\t\tmemo[ix++] = order[i].s;\n\t}\n\n\tfor (int y = 0; y < H; ++y)\n\t{\n\t\tfor (int x = 0; x < W; ++x)\n\t\t{\n\t\t\tif (field[y][x] == '.')\n\t\t\t\treturn false;\n\t\t}\n\t}\n\n\treturn true;\n}\n\nint\nmain(int argc, char **argv)\n{\n\twhile (true)\n\t{\n\t\tscanf(\"%d%d\\n\", &H, &W);\n\t\tif (H == 0 && W == 0)\n\t\t\tbreak;\n\n\t\tfor (int i = 0; i < H; ++i)\n\t\t\tscanf(\"%s\", &puzzle[i][0]);\n\n\t\tscanf(\"%d\", &n);\n\t\tfor (int s = 0; s < n; ++s)\n\t\t{\n\t\t\tscanf(\"%d%d\\n\", &h0[s][0], &w0[s][0]);\n\t\t\tint h = h0[s][0];\n\t\t\tint w = w0[s][0];\n\n\t\t\tfor (int y = 0; y < h; ++y)\n\t\t\t\tscanf(\"%s\", &piece[s][0][y][0]);\n\n\t\t\th0[s][1] = w;\n\t\t\tw0[s][1] = h;\n\t\t\tfor (int y = 0; y < h; ++y)\n\t\t\t{\n\t\t\t\tfor (int x = 0; x < w; ++x)\n\t\t\t\t\tpiece[s][1][x][h - y - 1] = piece[s][0][y][x];\n\t\t\t}\n\n#ifdef DEBUG\n\t\t\tfor (int x = 0; x < w; ++x)\n\t\t\t\tpiece[s][1][x][h] = NUL;\n#endif\n\n\t\t\th0[s][2] = h;\n\t\t\tw0[s][2] = w;\n\t\t\tfor (int y = 0; y < h; ++y)\n\t\t\t{\n\t\t\t\tfor (int x = 0; x < w; ++x)\n\t\t\t\t\tpiece[s][2][h - 1 - y][w - 1 - x] = piece[s][0][y][x];\n\n#ifdef DEBUG\n\t\t\t\tpiece[s][2][h - 1 - y][w] = NUL;\n#endif\n\t\t\t}\n\n\t\t\tw0[s][3] = h;\n\t\t\th0[s][3] = w;\n\t\t\tfor (int y = 0; y < h; ++y)\n\t\t\t{\n\t\t\t\tfor (int x = 0; x < w; ++x)\n\t\t\t\t\tpiece[s][3][w - 1 - x][y] = piece[s][0][y][x];\n\t\t\t}\n\n#ifdef DEBUG\n\t\t\tfor (int x = 0; x < w; ++x)\n\t\t\t\tpiece[s][3][x][h] = NUL;\n#endif\n\t\t}\n\n\t\tint p;\n\t\tscanf(\"%d\", &p);\n\t\tfor (int i = 0; i < p; ++i)\n\t\t{\n\t\t\tscanf(\"%d\", &k);\n\t\t\tfor (int j = 0; j < k; ++j)\n\t\t\t{\n\t\t\t\tscanf(\"%d\", &t[j]);\n\t\t\t\tt[j]--;\n\t\t\t}\n\n\t\t\tprintf(\"%s\\n\", solve() ? \"YES\" : \"NO\");\n\t\t}\n\t}\n\n#ifdef DEBUG\n\tfprintf(stderr, \"O:%d\\n\", O);\n#endif\n\treturn 0;\n}", "sampled": "#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n\n#define MAX_SIZE 20\n#define MAX_PIECES 10\n\nchar grid[MAX_SIZE][MAX_SIZE+1];\nchar pieces[MAX_PIECES][MAX_SIZE][MAX_SIZE+1];\nint piece_h[MAX_PIECES], piece_w[MAX_PIECES];\nint H, W, n;\n\ntypedef struct {\n    char data[MAX_SIZE][MAX_SIZE+1];\n    int h, w;\n} Piece;\n\nvoid rotate90(Piece *src, Piece *dst) {\n    dst->h = src->w;\n    dst->w = src->h;\n    for (int i = 0; i < dst->h; i++) {\n        for (int j = 0; j < dst->w; j++) {\n            dst->data[i][j] = src->data[src->h - 1 - j][i];\n        }\n        dst->data[i][dst->w] = '\\0';\n    }\n}\n\nint canPlace(char board[MAX_SIZE][MAX_SIZE+1], Piece *p, int y, int x) {\n    for (int i = 0; i < p->h; i++) {\n        for (int j = 0; j < p->w; j++) {\n            if (p->data[i][j] == '#') {\n                if (y + i >= H || x + j >= W || board[y+i][x+j] != '.') {\n                    return 0;\n                }\n            }\n        }\n    }\n    return 1;\n}\n\nvoid place(char board[MAX_SIZE][MAX_SIZE+1], Piece *p, int y, int x) {\n    for (int i = 0; i < p->h; i++) {\n        for (int j = 0; j < p->w; j++) {\n            if (p->data[i][j] == '#') {\n                board[y+i][x+j] = '#';\n            }\n        }\n    }\n}\n\nvoid unplace(char board[MAX_SIZE][MAX_SIZE+1], Piece *p, int y, int x) {\n    for (int i = 0; i < p->h; i++) {\n        for (int j = 0; j < p->w; j++) {\n            if (p->data[i][j] == '#') {\n                board[y+i][x+j] = '.';\n            }\n        }\n    }\n}\n\nint isComplete(char board[MAX_SIZE][MAX_SIZE+1]) {\n    for (int i = 0; i < H; i++) {\n        for (int j = 0; j < W; j++) {\n            if (board[i][j] == '.') return 0;\n        }\n    }\n    return 1;\n}\n\nint solve(char board[MAX_SIZE][MAX_SIZE+1], Piece rotations[][4], int selected[], int k, int used[], int idx) {\n    if (isComplete(board)) {\n        for (int i = 0; i < k; i++) {\n            if (!used[i]) return 0;\n        }\n        return 1;\n    }\n    \n    if (idx >= k) return 0;\n    \n    for (int pi = 0; pi < k; pi++) {\n        if (used[pi]) continue;\n        \n        for (int rot = 0; rot < 4; rot++) {\n            for (int y = 0; y < H; y++) {\n                for (int x = 0; x < W; x++) {\n                    if (canPlace(board, &rotations[pi][rot], y, x)) {\n                        place(board, &rotations[pi][rot], y, x);\n                        used[pi] = 1;\n                        if (solve(board, rotations, selected, k, used, idx + 1)) {\n                            return 1;\n                        }\n                        used[pi] = 0;\n                        unplace(board, &rotations[pi][rot], y, x);\n                    }\n                }\n            }\n        }\n    }\n    \n    return 0;\n}\n\nint checkPlayer(int selected[], int k) {\n    char board[MAX_SIZE][MAX_SIZE+1];\n    for (int i = 0; i < H; i++) {\n        strcpy(board[i], grid[i]);\n    }\n    \n    Piece rotations[MAX_PIECES][4];\n    for (int i = 0; i < k; i++) {\n        int idx = selected[i] - 1;\n        rotations[i][0].h = piece_h[idx];\n        rotations[i][0].w = piece_w[idx];\n        for (int r = 0; r < piece_h[idx]; r++) {\n            strcpy(rotations[i][0].data[r], pieces[idx][r]);\n        }\n        \n        rotate90(&rotations[i][0], &rotations[i][1]);\n        rotate90(&rotations[i][1], &rotations[i][2]);\n        rotate90(&rotations[i][2], &rotations[i][3]);\n    }\n    \n    int used[MAX_PIECES] = {0};\n    return solve(board, rotations, selected, k, used, 0);\n}\n\nint main() {\n    while (1) {\n        scanf(\"%d %d\", &H, &W);\n        if (H == 0 && W == 0) break;\n        \n        for (int i = 0; i < H; i++) {\n            scanf(\"%s\", grid[i]);\n        }\n        \n        scanf(\"%d\", &n);\n        for (int i = 0; i < n; i++) {\n            scanf(\"%d %d\", &piece_h[i], &piece_w[i]);\n            for (int j = 0; j < piece_h[i]; j++) {\n                scanf(\"%s\", pieces[i][j]);\n            }\n        }\n        \n        int p;\n        scanf(\"%d\", &p);\n        for (int i = 0; i < p; i++) {\n            int k;\n            scanf(\"%d\", &k);\n            int selected[MAX_PIECES];\n            for (int j = 0; j < k; j++) {\n                scanf(\"%d\", &selected[j]);\n            }\n            \n            if (checkPlayer(selected, k)) {\n                printf(\"YES\\n\");\n            } else {\n                printf(\"NO\\n\");\n            }\n        }\n    }\n    \n    return 0;\n}\n", "perturbed_sampled": ["#include <stdio.h> #include <string.h> #include  MAX_PIECES 10  piece_h[MAX_PIECES], piece_w[MAX_PIECES];  int h, w; }  *dst) { dst->h = src->w;  < dst->h; i++) { for (int j = 0; j < dst->w;  -  = '\\0'; } } int canPlace(char board[MAX_SIZE][MAX_SIZE+1], Piece *p,  i++) {  '#')  + j >= W || board[y+i][x+j] != '.') { return 0; } } } } return 1; }  { for (int i = 0; i < p->h; i++)  0;   board[y+i][x+j] =  x) { for (int i = 0; i < p->h; i++)  0; j < p->w; j++) { if (p->data[i][j] == '#') { board[y+i][x+j] =  int isComplete(char board[MAX_SIZE][MAX_SIZE+1]) { for  < H;  = 0;  int selected[],  idx)   if (!used[i]) return 0;    for (int rot    1; if (solve(board, rotations, selected, k, used, idx + 1)) { return 1; } used[pi] = 0; unplace(board, &rotations[pi][rot], y, x); } } } } } return 0; }  {  = 0; i < H; i++) { strcpy(board[i], grid[i]); } Piece rotations[MAX_PIECES][4]; for (int i  i++) { int idx = selected[i]  rotations[i][0].w = piece_w[idx]; for (int r = 0; r < piece_h[idx]; r++) {   ==  = 0; i < H;  for (int  piece_h[i]; j++) { scanf(\"%s\", pieces[i][j]);  &p); for  int selected[MAX_PIECES]; for (int j = 0;  scanf(\"%d\", &selected[j]); } if (checkPlayer(selected, k)) { printf(\"YES\\n\");  }"], "perturbed_original": ["#include  <string.h> // memset(), memcpy(), strchr()  1 #define MAX_W 20 #define  typedef struct order_tbl  double rate; }  '\\0'; #ifdef DEBUG static int  H,  int w0[MAX_N][4];  bury(order_t *u)   h = h0[s][a]; int w =  0;  for (int x = 0; x  (piece[s][a][y][x] == '#')  = '*'; } } } double fitin(order_t *u, int a,   w = w0[s][a]; int dx[4] = { 0, 1, 0,-1}; int dy[4] = {   = -1; x <= w; ++x)  <= x && x < w && 0  < W && 0 <= ny &&  == '.' ?   dy[i]; if (0  w && 0 <= ty && ty < h &&   '.') count++; } } } }  *u) { int s =  0; a < 4; ++a)  int  piece[s][a][0];  (int bx = 0;  ++bx) { if (field[by][bx + fx] == '.') { #ifdef  by); if (r > u->rate)  = bx;  a; if (u->rate  order_t *l = (const order_t*) l_; const order_t *r  1; if (l->rate > r->rate) return -1; return 0; } bool  order[MAX_N]; int  puzzle, sizeof(field)); ix = 0; for (int i = 0; i  t[i];  ix2 = 0;  i < ix; ++i) { #ifdef DEBUG memset(&u, 0x00, sizeof(u)); #endif u.s =  if (u.rate != 100.0) order[ix2++] = u; } if (ix2 == 0) break; qsort(order,  == -100.0) return false; bury(&order[0]); ix =  1; i < ix2;  for (int y =  { for (int  W; ++x) { if  } int  &H, &W); if (H ==  H; ++i) scanf(\"%s\", &puzzle[i][0]); scanf(\"%d\", &n); for   = w0[s][0]; for (int y =  scanf(\"%s\", &piece[s][0][y][0]); h0[s][1] = w; w0[s][1] = h; for (int y  ++y)  0; x  y - 1] = piece[s][0][y][x];  x = 0; x <  #endif  y][w - 1 - x] =  1  } w0[s][3] =    < w;  } int  i  ++i) { scanf(\"%d\", &k); for (int j = 0; j < k; ++j) { scanf(\"%d\",  ? \"YES\" : \"NO\");  \"O:%d\\n\", O); #endif return 0; }"], "original_ll": -0.7032430171966553, "sampled_ll": -0.4032168686389923, "all_perturbed_sampled_ll": [-2.320814847946167], "all_perturbed_original_ll": [-2.6730377674102783], "perturbed_sampled_ll": -2.320814847946167, "perturbed_original_ll": -2.6730377674102783, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.*;\nimport java.util.Calendar.Builder;\n\nimport javax.jws.soap.SOAPBinding.Use;\n\n\n\npublic class Main {\n\tstatic int H;\n\tstatic int W;\n\tstatic int[] map;\n\tstatic Piece[] p;\n\tpublic static void main(String[] args) {\t\n\t\tFastScanner sc = new FastScanner();\n\t\t//Scanner sc = new Scanner(System.in);\n\t\tPrintWriter out = new PrintWriter(System.out);\n\t\twhile(true) {\n\t\t\tH = sc.nextInt();\n\t\t\tW = sc.nextInt();\n\t\t\tif(H == 0 && W == 0) break;\n\t\t\tmap = new int[H];\n\t\t\tint mapCount = 0;\n\t\t\tfor(int i = 0; i < H; i++) {\n\t\t\t\tString in = sc.next();\n\t\t\t\tin = in.replace('.', '0');\n\t\t\t\tin = in.replace('#', '1');\n\t\t\t\tint bin = Integer.parseInt(in,2);\n\t\t\t\tmap[i] = bin;\n\t\t\t\tmapCount += W - Integer.bitCount(bin);\n\t\t\t}\n\t\t\tint n = sc.nextInt();\n\t\t\tp = new Piece[n];\n\t\t\tfor(int i = 0; i < n; i++) {\n\t\t\t\tint h = sc.nextInt();\n\t\t\t\tint w = sc.nextInt();\n\t\t\t\tString[] map = new String[h];\n\t\t\t\tfor(int j = 0; j < h; j++) {\n\t\t\t\t\tString in = sc.next();\n\t\t\t\t\tmap[j] = in;\n\t\t\t\t}\n\t\t\t\tp[i] = new Piece(h,w,map);\n\t\t\t}\n\t\t\t\n\t\t\tint p = sc.nextInt();\n\t\t\tfor(int i = 0; i < p; i++) {\n\t\t\t\tint k = sc.nextInt();\n\t\t\t\tint[] t = new int[k];\n\t\t\t\tfor(int j = 0; j < k; j++) {\n\t\t\t\t\tt[j] = sc.nextInt()-1;\n\t\t\t\t}\n\t\t\t\tint bitCount = 0;\n\t\t\t\tfor(int j = 0; j < k; j++) {\n\t\t\t\t\tfor(int l = 0; l < Main.p[t[j]].h[0]; l++) {\n\t\t\t\t\t\tbitCount += Integer.bitCount(Main.p[t[j]].map[0][l]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tboolean ans = false;\n\t\t\t\tif(bitCount == mapCount) {\n\t\t\t\t\tans = check(new boolean[k],t,map,0,0,0);\n\t\t\t\t}\n\t\t\t\tif(ans) System.out.println(\"YES\");\n\t\t\t\telse System.out.println(\"NO\");\n\t\t\t}\n\t\t}\n\t}\n\tstatic boolean check(boolean[] used, int[] use, int[] map, int y, int x,int c) {\n\t\tif(x == W) return check(used,use,map,y+1,0,c);\n\t\tif(y == H && c == use.length) {\n\t\t\treturn true;\n\t\t}\n\t\telse if(y == H) return false;\n\t\tif((map[y] & (1 << (W - x - 1))) == 0) {\n\t\t\tfor(int i = 0; i < use.length; i++) {\n\t\t\t\tif(used[i]) continue;\n\t\t\t\tint sel = use[i];\n\t\t\t\tfor(int j = 0; j < 4; j++) {\n\t\t\t\t\tint xx = x - p[sel].vw[j];\n\t\t\t\t\tif(xx < 0) continue;\n\t\t\t\t\tboolean cf = checkCanFill(y,xx,j,map,p[sel]);\n\t\t\t\t\tif(!cf) continue;\n\t\t\t\t\tfill(y,xx,j,map,p[sel]);\n\t\t\t\t\tused[i] = true;\n\t\t\t\t\tboolean rt = check(used,use,map,y,x+1,c+1);\n\t\t\t\t\tif(rt) {\n\t\t\t\t\t\tused[i] = false;\n\t\t\t\t\t\tfill(y,xx,j,map,p[sel]);\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t\tused[i] = false;\n\t\t\t\t\tfill(y,xx,j,map,p[sel]);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn false;\n\t\t}\n\t\telse {\n\t\t\treturn check(used,use,map,y,x+1,c);\n\t\t}\n\t}\n\tstatic boolean checkCanFill(int A, int B, int C,int[] map, Piece p) {\n\t\tif(p.h[C] + A > H) return false;\n\t\tif(p.w[C] + B > W || W - p.w[C] - B < 0) return false;\n\t\tfor(int i = 0; i < p.h[C]; i++) {\n\t\t\tif((map[i + A] & (p.map[C][i] << (W - p.w[C] - B))) != 0) return false;\n\t\t}\n\t\treturn true;\n\t}\n\tstatic void fill(int A, int B, int C, int[] map, Piece p) {\n\t\tfor(int i = 0; i < p.h[C]; i++) {\n\t\t\tmap[i + A] ^= (p.map[C][i] << (W - p.w[C] - B));\n\t\t}\n\t}\n\tstatic boolean checkFill(int[] map) {\n\t\tfor(int i = 0; i < H; i++) {\n\t\t\tif(map[i] != (1 << W)-1) return false;\n\t\t}\n\t\treturn true;\n\t}\n\t\n\tstatic String[] rotate(String[] map) {\n\t\tchar[][] in = new char[map.length][];\n\t\tfor(int i = 0; i < map.length; i++) {\n\t\t\tin[i] = map[i].toCharArray();\n\t\t}\n\t\tchar[][] ret = new char[in[0].length][in.length];\n\t\tfor(int i = 0; i < in[0].length; i++) {\n\t\t\tfor(int j = 0; j < in.length; j++) {\n\t\t\t\tret[i][j] = in[in.length - j - 1][i];\n\t\t\t}\n\t\t}\n\t\tString[] retu = new String[ret.length];\n\t\tfor(int i = 0; i < ret.length; i++) {\n\t\t\tretu[i] = String.valueOf(ret[i]);\n\t\t}\n\t\treturn retu;\n\t\t\n\t}\n\t\n\t\n\tstatic class Piece {\n\t\tint[] h;\n\t\tint[] w;\n\t\tint[][] map;\n\t\tint[] vw;\n\t\tPiece(int a, int b, String[] c) {\n\t\t\th = new int[4];\n\t\t\tw = new int[4];\n\t\t\tvw = new int[4];\n\t\t\tmap = new int[4][];\n\t\t\tfor(int i = 0; i < 4; i++) {\n\t\t\t\th[i] = a;\n\t\t\t\tw[i] = b;\n\t\t\t\tmap[i] = new int[h[i]];\n\t\t\t\tfor(int j = 0; j < w[i]; j++) {\n\t\t\t\t\tif(c[0].charAt(j) == '#') {\n\t\t\t\t\t\tvw[i] = j;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfor(int j = 0; j < h[i]; j++) {\n\t\t\t\t\tString in = c[j];\n\t\t\t\t\tin = in.replace('.', '0');\n\t\t\t\t\tin = in.replace('#', '1');\n\t\t\t\t\tint bin = Integer.parseInt(in,2);\n\t\t\t\t\tmap[i][j] = bin;\n\t\t\t\t}\n\t\t\t\tint tmp = a;\n\t\t\t\ta = b;\n\t\t\t\tb = tmp;\n\t\t\t\tc = rotate(c);\n\t\t\t}\n\t\t}\n\t}\n\n}\n\nclass FastScanner {\n    private final InputStream in = System.in;\n    private final byte[] buffer = new byte[1024];\n    private int ptr = 0;\n    private int buflen = 0;\n    private boolean hasNextByte() {\n        if (ptr < buflen) {\n            return true;\n        }else{\n            ptr = 0;\n            try {\n                buflen = in.read(buffer);\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n            if (buflen <= 0) {\n                return false;\n            }\n        }\n        return true;\n    }\n    private int readByte() { if (hasNextByte()) return buffer[ptr++]; else return -1;}\n    private static boolean isPrintableChar(int c) { return 33 <= c && c <= 126;}\n    private void skipUnprintable() { while(hasNextByte() && !isPrintableChar(buffer[ptr])) ptr++;}\n    public boolean hasNext() { skipUnprintable(); return hasNextByte();}\n    public String next() {\n        if (!hasNext()) throw new NoSuchElementException();\n        StringBuilder sb = new StringBuilder();\n        int b = readByte();\n        while(isPrintableChar(b)) {\n            sb.appendCodePoint(b);\n            b = readByte();\n        }\n        return sb.toString();\n    }\n    public long nextLong() {\n        if (!hasNext()) throw new NoSuchElementException();\n        long n = 0;\n        boolean minus = false;\n        int b = readByte();\n        if (b == '-') {\n            minus = true;\n            b = readByte();\n        }\n        if (b < '0' || '9' < b) {\n            throw new NumberFormatException();\n        }\n        while(true){\n            if ('0' <= b && b <= '9') {\n                n *= 10;\n                n += b - '0';\n            }else if(b == -1 || !isPrintableChar(b)){\n                return minus ? -n : n;\n            }else{\n                throw new NumberFormatException();\n            }\n            b = readByte();\n        }\n    }\n    public int nextInt() {\n        if (!hasNext()) throw new NoSuchElementException();\n        int n = 0;\n        boolean minus = false;\n        int b = readByte();\n        if (b == '-') {\n            minus = true;\n            b = readByte();\n        }\n        if (b < '0' || '9' < b) {\n            throw new NumberFormatException();\n        }\n        while(true){\n            if ('0' <= b && b <= '9') {\n                n *= 10;\n                n += b - '0';\n            }else if(b == -1 || !isPrintableChar(b)){\n                return minus ? -n : n;\n            }else{\n                throw new NumberFormatException();\n            }\n            b = readByte();\n        }\n    }\n}", "sampled": "import java.util.*;\nimport java.io.*;\n\npublic class Main {\n    static char[][] grid;\n    static List<char[][]> pieces;\n    static int H, W;\n    \n    public static void main(String[] args) throws IOException {\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        String line;\n        \n        while ((line = br.readLine()) != null) {\n            String[] hw = line.trim().split(\"\\\\s+\");\n            H = Integer.parseInt(hw[0]);\n            W = Integer.parseInt(hw[1]);\n            \n            if (H == 0 && W == 0) break;\n            \n            grid = new char[H][W];\n            for (int i = 0; i < H; i++) {\n                String row = br.readLine();\n                grid[i] = row.toCharArray();\n            }\n            \n            int n = Integer.parseInt(br.readLine().trim());\n            pieces = new ArrayList<>();\n            \n            for (int i = 0; i < n; i++) {\n                String[] size = br.readLine().trim().split(\"\\\\s+\");\n                int h = Integer.parseInt(size[0]);\n                int w = Integer.parseInt(size[1]);\n                char[][] piece = new char[h][w];\n                for (int j = 0; j < h; j++) {\n                    String row = br.readLine();\n                    piece[j] = row.toCharArray();\n                }\n                pieces.add(piece);\n            }\n            \n            int p = Integer.parseInt(br.readLine().trim());\n            \n            for (int i = 0; i < p; i++) {\n                String[] selection = br.readLine().trim().split(\"\\\\s+\");\n                int k = Integer.parseInt(selection[0]);\n                List<Integer> selected = new ArrayList<>();\n                for (int j = 1; j <= k; j++) {\n                    selected.add(Integer.parseInt(selection[j]) - 1);\n                }\n                \n                if (canSolve(selected)) {\n                    System.out.println(\"YES\");\n                } else {\n                    System.out.println(\"NO\");\n                }\n            }\n        }\n    }\n    \n    static boolean canSolve(List<Integer> selected) {\n        char[][] testGrid = new char[H][W];\n        for (int i = 0; i < H; i++) {\n            for (int j = 0; j < W; j++) {\n                testGrid[i][j] = grid[i][j];\n            }\n        }\n        \n        return tryPlace(testGrid, selected, 0);\n    }\n    \n    static boolean tryPlace(char[][] testGrid, List<Integer> selected, int idx) {\n        if (idx == selected.size()) {\n            return isComplete(testGrid);\n        }\n        \n        int pieceIdx = selected.get(idx);\n        char[][] piece = pieces.get(pieceIdx);\n        \n        for (int rot = 0; rot < 4; rot++) {\n            char[][] rotated = rotate(piece, rot);\n            for (int i = 0; i <= H - rotated.length; i++) {\n                for (int j = 0; j <= W - rotated[0].length; j++) {\n                    if (canPlace(testGrid, rotated, i, j)) {\n                        char[][] backup = copyGrid(testGrid);\n                        place(testGrid, rotated, i, j);\n                        if (tryPlace(testGrid, selected, idx + 1)) {\n                            return true;\n                        }\n                        restoreGrid(testGrid, backup);\n                    }\n                }\n            }\n        }\n        \n        return false;\n    }\n    \n    static boolean canPlace(char[][] testGrid, char[][] piece, int r, int c) {\n        for (int i = 0; i < piece.length; i++) {\n            for (int j = 0; j < piece[0].length; j++) {\n                if (piece[i][j] == '#') {\n                    if (testGrid[r + i][c + j] != '.') {\n                        return false;\n                    }\n                }\n            }\n        }\n        return true;\n    }\n    \n    static void place(char[][] testGrid, char[][] piece, int r, int c) {\n        for (int i = 0; i < piece.length; i++) {\n            for (int j = 0; j < piece[0].length; j++) {\n                if (piece[i][j] == '#') {\n                    testGrid[r + i][c + j] = '#';\n                }\n            }\n        }\n    }\n    \n    static boolean isComplete(char[][] testGrid) {\n        for (int i = 0; i < H; i++) {\n            for (int j = 0; j < W; j++) {\n                if (testGrid[i][j] == '.') {\n                    return false;\n                }\n            }\n        }\n        return true;\n    }\n    \n    static char[][] rotate(char[][] piece, int times) {\n        char[][] result = piece;\n        for (int t = 0; t < times; t++) {\n            int h = result.length;\n            int w = result[0].length;\n            char[][] newPiece = new char[w][h];\n            for (int i = 0; i < h; i++) {\n                for (int j = 0; j < w; j++) {\n                    newPiece[j][h - 1 - i] = result[i][j];\n                }\n            }\n            result = newPiece;\n        }\n        return result;\n    }\n    \n    static char[][] copyGrid(char[][] grid) {\n        char[][] copy = new char[grid.length][grid[0].length];\n        for (int i = 0; i < grid.length; i++) {\n            for (int j = 0; j < grid[0].length; j++) {\n                copy[i][j] = grid[i][j];\n            }\n        }\n        return copy;\n    }\n    \n    static void restoreGrid(char[][] grid, char[][] backup) {\n        for (int i = 0; i < grid.length; i++) {\n            for (int j = 0; j < grid[0].length; j++) {\n                grid[i][j] = backup[i][j];\n            }\n        }\n    }\n}\n", "perturbed_sampled": [" class Main { static char[][] grid; static  W; public static void main(String[] args) throws IOException   ((line  H = Integer.parseInt(hw[0]); W =   for (int i =  } int n =    int w =  = 0; j  row  p = Integer.parseInt(br.readLine().trim()); for  < p; i++) {  k = Integer.parseInt(selection[0]); List<Integer> selected = new ArrayList<>(); for (int j = 1; j  - 1); } if (canSolve(selected)) {  { char[][] testGrid = new char[H][W]; for (int  H; i++) { for (int j = 0; j  return tryPlace(testGrid, selected, 0); } static boolean tryPlace(char[][] testGrid, List<Integer> selected, int  }  (int rot  rot++)  rot); for (int i  0; j <= W -  place(testGrid, rotated, i, j); if (tryPlace(testGrid, selected,  true; } restoreGrid(testGrid,  return false; } static boolean canPlace(char[][] testGrid, char[][] piece, int r,  i = 0;    i][c + j] != '.') { return false; } } }  void place(char[][] testGrid, char[][] piece, int r, int c) { for  for  if (piece[i][j] ==  + j]    i++) {  } } }  rotate(char[][]   t = 0; t < times; t++) { int h  new  i++) { for  < w; j++) {  result = newPiece;  char[][] copyGrid(char[][] grid)  char[grid.length][grid[0].length];   0; j < grid[0].length; j++) { copy[i][j]  copy; } static void restoreGrid(char[][] grid, char[][]  = 0; i < grid.length; i++) {  {  } }"], "perturbed_original": ["import   p; public static void main(String[] args) { FastScanner sc = new FastScanner(); //Scanner sc = new Scanner(System.in); PrintWriter out =  =  == 0  map = new  for(int i =  sc.next(); in =  '1'); int bin = Integer.parseInt(in,2); map[i] =  Integer.bitCount(bin); } int n = sc.nextInt(); p = new Piece[n]; for(int i = 0; i < n; i++) { int h = sc.nextInt();  {  int p =  i < p;  sc.nextInt(); int[]  j = 0; j   < Main.p[t[j]].h[0]; l++)  } boolean    System.out.println(\"NO\");  int[] map, int y,  == W) return check(used,use,map,y+1,0,c); if(y == H  return true; } else if(y == H) return false; if((map[y] & (1 << (W -  {  < use.length; i++) { if(used[i]) continue;  j = 0; j <  = x - p[sel].vw[j];   false; fill(y,xx,j,map,p[sel]); return true; } used[i] = false; fill(y,xx,j,map,p[sel]); }  { return check(used,use,map,y,x+1,c); } } static boolean checkCanFill(int A, int B, int C,int[] map, Piece p)  || W    false; } return true; } static  i  i++) {  << (W - p.w[C]  i < H; i++) { if(map[i] != (1  return true; } static String[] rotate(String[] map) {  for(int  =  = 0; i < in[0].length; i++) { for(int j = 0; j < in.length; j++) { ret[i][j] = in[in.length  new String[ret.length]; for(int i = 0;  retu[i] = String.valueOf(ret[i]);  h; int[] w; int[][] map; int[] vw; Piece(int  int[4]; w = new  map = new int[4][]; for(int i = 0; i <  j < w[i]; j++) { if(c[0].charAt(j) == '#')  }   in = in.replace('#',  map[i][j] = bin; } int tmp = a; a = b; b  buffer = new byte[1024]; private int ptr = 0;  private  < buflen) { return true; }else{  <=   return 33 <= c && c <= 126;} private void skipUnprintable() { while(hasNextByte()  hasNext() { skipUnprintable(); return hasNextByte();} public String next() { if (!hasNext()) throw new NoSuchElementException(); StringBuilder sb = new    false; int  readByte(); } if  <  <= '9') { n *= 10; n += b  -1 || !isPrintableChar(b)){ return minus ? -n :  } } public int nextInt() { if (!hasNext()) throw  0;  b  true; b  new NumberFormatException(); } while(true){ if ('0' <= b && b <= '9') { n *= 10; n += b - '0';   }"], "original_ll": -0.6502135992050171, "sampled_ll": -0.3444550037384033, "all_perturbed_sampled_ll": [-2.6225011348724365], "all_perturbed_original_ll": [-2.7142930030822754], "perturbed_sampled_ll": -2.6225011348724365, "perturbed_original_ll": -2.7142930030822754, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import copy\ndef rot90(A):\n  return zip(*A[::-1])\n\ndef count_board(Board):\n  X = [[0 for _ in [0]*(Width+1)] for _ in [0]*(Height+1)]\n  for i in range(Height)[::-1]:\n    for j in range(Width)[::-1]:\n      X[i][j] = X[i+1][j] + X[i][j+1] - X[i+1][j+1] + (Board[i][j]=='.')\n  return X\n\ndef check_sum(TRIALS):\n  return sum([B[e] for e in TRIALS]) != DOTS[0][0]\n\ndef tmp_put(Board, piece, y, x):\n  N = range(len(piece[0]))\n  for i in range(len(piece)):\n    tmp = piece[i]\n    BoardRow = Board[y+i]\n    for j in N:\n      if tmp[j]=='#' and BoardRow[x+j]!='.': return 0\n  return 1\n\ndef get_put(Board, piece, y, x, mode):\n  c = '#.'[mode]\n  W = range(len(piece[0]))\n  for i in range(len(piece)):\n    tmp = piece[i]\n    Y = y+i\n    for j in W:\n      if tmp[j]=='#': Board[Y][x+j]=c\n  return Board\n\ndef PrintBoard(Board):\n  for e in Board:\n    print \"\".join(e)\n  print\n  return\n\ndef PrintDots(DOTS):\n  for e in DOTS:\n    print e\n  print\n  return\n\ndef solve(TRIALS, Board):\n  if TRIALS==[]: return 1\n  n = TRIALS[0]\n  DOTS = count_board(Board)\n  for direction in C[n]:\n    P = PIECE[(n, direction)]\n    h = len(P)\n    w = len(P[0])\n    s = B[n]\n    POS=[]\n    H = range(Height-h+1)\n    W = range(Width-w+1)\n    for i in H:\n      A1 = DOTS[i]\n      A2 = DOTS[i+h]\n      for j in W:\n        tmp = A1[j] - A2[j] - A1[j+w] + A2[j+w]\n        if tmp>=s and tmp_put(Board, P, i, j):\n          Board = get_put(Board, P, i, j, 0)\n          if solve(TRIALS[1:], Board): return 1\n          Board = get_put(Board, P, i, j, 1)\n  return 0\n\ndef CheckPieceType(i):\n  def f(x1, x2):\n    for j in range(len(PIECE[i, x1])):\n      if \"\".join(PIECE[i, x1][j])!=\"\".join(PIECE[i, x2][j]): return 0\n    return 1\n  flg = [0,1,2,3]\n  for a, b in [[0,1], [1,3], [0,2]]:\n    if f(a, b): flg[b] = flg[a]\n  return list(set(flg))\n\nwhile 1:\n  Height, Width = map(int,raw_input().split())\n  if Height*Width==0: break\n  try: Board = [list(raw_input()) for _ in [0]*Height]\n  except: break\n  DOTS = count_board(Board)\n  PIECE = {}\n  n = input()\n  B = [0] * n\n  C = [[0, 0, 0, 0] for _ in [0] * n]\n  for i in range(n):\n    height, width = map(int, raw_input().split())\n    tmp = [list(raw_input()) for _ in [0] * height]\n    B[i] = sum([e.count('#') for e in tmp])\n    for direction in [0, 1, 2, 3]:\n      PIECE[(i, direction)] = tmp\n      tmp = rot90(tmp)\n    C[i] = CheckPieceType(i)\n  for _ in [0]*input():\n    a = map(int, raw_input().split())[1:]\n    a = sorted([[B[e-1], e-1] for e in a], key = lambda x:{-x[0]})\n    TRIALS = list(zip(*a)[1])\n    if check_sum(TRIALS): print \"NO\"\n    else: print [\"NO\", \"YES\"][solve(TRIALS, copy.deepcopy(Board))]", "sampled": "import sys\nfrom copy import deepcopy\n\ndef read_input():\n    datasets = []\n    while True:\n        line = sys.stdin.readline()\n        if not line:\n            break\n        parts = line.strip().split()\n        if len(parts) == 2:\n            H, W = int(parts[0]), int(parts[1])\n            if H == 0 and W == 0:\n                break\n            \n            # Read puzzle grid\n            grid = []\n            for _ in range(H):\n                grid.append(sys.stdin.readline().strip())\n            \n            # Read number of pieces\n            n = int(sys.stdin.readline().strip())\n            \n            # Read pieces\n            pieces = []\n            for _ in range(n):\n                h = int(sys.stdin.readline().strip())\n                w = int(sys.stdin.readline().strip())\n                piece = []\n                for _ in range(h):\n                    piece.append(sys.stdin.readline().strip())\n                pieces.append(piece)\n            \n            # Read players\n            p = int(sys.stdin.readline().strip())\n            players = []\n            for _ in range(p):\n                line = sys.stdin.readline().strip().split()\n                k = int(line[0])\n                selected = [int(line[i+1]) - 1 for i in range(k)]\n                players.append(selected)\n            \n            datasets.append((H, W, grid, pieces, players))\n    \n    return datasets\n\ndef rotate_90(piece):\n    h = len(piece)\n    w = len(piece[0])\n    rotated = []\n    for j in range(w):\n        row = \"\"\n        for i in range(h-1, -1, -1):\n            row += piece[i][j]\n        rotated.append(row)\n    return rotated\n\ndef get_rotations(piece):\n    rotations = [piece]\n    current = piece\n    for _ in range(3):\n        current = rotate_90(current)\n        rotations.append(current)\n    return rotations\n\ndef get_piece_coords(piece):\n    coords = []\n    for i in range(len(piece)):\n        for j in range(len(piece[i])):\n            if piece[i][j] == '#':\n                coords.append((i, j))\n    return coords\n\ndef try_place(grid, H, W, piece, start_r, start_c):\n    piece_coords = get_piece_coords(piece)\n    placed = []\n    for dr, dc in piece_coords:\n        r = start_r + dr\n        c = start_c + dc\n        if r < 0 or r >= H or c < 0 or c >= W:\n            return None\n        if grid[r][c] != '.':\n            return None\n        placed.append((r, c))\n    return placed\n\ndef solve(H, W, grid, selected_pieces):\n    # Create a mutable grid\n    target = []\n    for i in range(H):\n        row = list(grid[i])\n        target.append(row)\n    \n    # Get all rotations for each piece\n    all_rotations = []\n    for piece in selected_pieces:\n        all_rotations.append(get_rotations(piece))\n    \n    def backtrack(piece_idx):\n        if piece_idx == len(selected_pieces):\n            # Check if all '.' are filled\n            for i in range(H):\n                for j in range(W):\n                    if target[i][j] == '.':\n                        return False\n            return True\n        \n        piece_rotations = all_rotations[piece_idx]\n        \n        for rotation in piece_rotations:\n            # Try all possible positions\n            for start_r in range(-19, H+20):\n                for start_c in range(-19, W+20):\n                    placed = try_place(target, H, W, rotation, start_r, start_c)\n                    if placed:\n                        # Mark cells\n                        for r, c in placed:\n                            target[r][c] = '#'\n                        \n                        if backtrack(piece_idx + 1):\n                            return True\n                        \n                        # Unmark cells\n                        for r, c in placed:\n                            target[r][c] = '.'\n        \n        return False\n    \n    return backtrack(0)\n\ndef main():\n    datasets = read_input()\n    \n    for H, W, grid, pieces, players in datasets:\n        for selected_indices in players:\n            selected_pieces = [pieces[i] for i in selected_indices]\n            if solve(H, W, grid, selected_pieces):\n                print(\"YES\")\n            else:\n                print(\"NO\")\n\nif __name__ == \"__main__\":\n    main()\n", "perturbed_sampled": ["import sys from copy import deepcopy def  if not line: break parts = line.strip().split()  and W == 0:  grid = [] for _ in range(H): grid.append(sys.stdin.readline().strip()) # Read number  # Read pieces pieces  range(n): h  _ in range(h): piece.append(sys.stdin.readline().strip())  = int(sys.stdin.readline().strip())   k =    = [] for j in range(w): row = \"\" for i in range(h-1,  rotated.append(row) return rotated  _ in range(3): current = rotate_90(current) rotations.append(current) return rotations def get_piece_coords(piece): coords = []  j in range(len(piece[i])): if piece[i][j] == '#': coords.append((i, j)) return coords  get_piece_coords(piece) placed = []  dr c =  < 0    grid[r][c] != '.': return None placed.append((r, c)) return placed   target  target.append(row) # Get all rotations  i in   False return  H+20): for start_c in  H, W, rotation, start_r, start_c) if placed: # Mark cells for r, c in placed: target[r][c]   in  for H, W, grid,  selected_indices in players: selected_pieces = [pieces[i] for i in selected_indices] if solve(H,  \"__main__\": main()"], "perturbed_original": ["import copy def rot90(A):   [0]*(Height+1)] for i in  (Board[i][j]=='.') return X def   N = range(len(piece[0]))  Board[y+i] for j in N: if tmp[j]=='#' and BoardRow[x+j]!='.':  mode): c =  i in range(len(piece)):    in Board:  PrintDots(DOTS): for  print return def  1 n = TRIALS[0] DOTS = count_board(Board) for direction in  h = len(P) w = len(P[0]) s = B[n] POS=[]  range(Width-w+1) for i in  = DOTS[i+h] for  tmp>=s and tmp_put(Board, P, i, j): Board    in range(len(PIECE[i, x1])): if \"\".join(PIECE[i, x1][j])!=\"\".join(PIECE[i, x2][j]):   in  if Height*Width==0: break try: Board   count_board(Board) PIECE =  = [0] * n C = [[0, 0,  [0] * n] for i in range(n): height, width = map(int, raw_input().split()) tmp =  * height] B[i] = sum([e.count('#') for e in tmp]) for direction  PIECE[(i, direction)] =  =  for e in  print [\"NO\", \"YES\"][solve(TRIALS, copy.deepcopy(Board))]"], "original_ll": -1.3644311428070068, "sampled_ll": -0.6744669079780579, "all_perturbed_sampled_ll": [-3.150204658508301], "all_perturbed_original_ll": [-3.6881942749023438], "perturbed_sampled_ll": -3.150204658508301, "perturbed_original_ll": -3.6881942749023438, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "#include <stdio.h>\n#include <string.h>\n\nint rotate(char pat[8][9]) {\n\tchar buf[8][9];\n\tint x,y;\n\tfor(y=0;y<8;y++) {\n\t\tfor(x=0;x<8;x++) {\n\t\t\tbuf[x][7-y]=pat[y][x];\n\t\t}\n\t}\n\tmemcpy(pat,buf,sizeof(pat));\n}\n\nint main(void) {\n\tchar buf[8][9];\n\tint i;\n\tfor(i=0;i<8;i++)scanf(\"%s\",buf[i]);\n\trotate(buf);\n\tputs(\"90\");\n\tfor(i=0;i<8;i++)printf(\"%s\\n\",buf[i]);\n\trotate(buf);\n\tputs(\"180\");\n\tfor(i=0;i<8;i++)printf(\"%s\\n\",buf[i]);\n\trotate(buf);\n\tputs(\"270\");\n\tfor(i=0;i<8;i++)printf(\"%s\\n\",buf[i]);\n\treturn 0;\n}", "sampled": "#include <stdio.h>\n\nint main() {\n    char pattern[8][9];\n    int i, j;\n    \n    // Read input\n    for (i = 0; i < 8; i++) {\n        scanf(\"%s\", pattern[i]);\n    }\n    \n    // 90 degrees\n    printf(\"90\\n\");\n    for (i = 0; i < 8; i++) {\n        for (j = 7; j >= 0; j--) {\n            printf(\"%c\", pattern[j][i]);\n        }\n        printf(\"\\n\");\n    }\n    \n    // 180 degrees\n    printf(\"180\\n\");\n    for (i = 7; i >= 0; i--) {\n        for (j = 7; j >= 0; j--) {\n            printf(\"%c\", pattern[i][j]);\n        }\n        printf(\"\\n\");\n    }\n    \n    // 270 degrees\n    printf(\"270\\n\");\n    for (i = 7; i >= 0; i--) {\n        for (j = 0; j < 8; j++) {\n            printf(\"%c\", pattern[j][i]);\n        }\n        printf(\"\\n\");\n    }\n    \n    return 0;\n}\n", "perturbed_sampled": ["#include   Read input for (i =  // 90  0; i < 8; i++) { for (j = 7; j >= 0; j--)  7; i >= 0; i--) {  >= 0;  degrees printf(\"270\\n\"); for (i  i--) { for (j  0; }"], "perturbed_original": ["#include <stdio.h> #include   { for(x=0;x<8;x++)  } int  i; for(i=0;i<8;i++)scanf(\"%s\",buf[i]); rotate(buf); puts(\"90\");  puts(\"270\"); for(i=0;i<8;i++)printf(\"%s\\n\",buf[i]); return 0; }"], "original_ll": -0.9061835408210754, "sampled_ll": -0.41113215684890747, "all_perturbed_sampled_ll": [-2.95212721824646], "all_perturbed_original_ll": [-2.2024834156036377], "perturbed_sampled_ll": -2.95212721824646, "perturbed_original_ll": -2.2024834156036377, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\n\npublic class Main {\n\n\tpublic static void main(String[] args) throws IOException {\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\tString line = \"\";\n\n\t\tchar[][] pattern = new char[8][8];\n\t\tfor (int i = 0; i < 8; i++) {\n\t\t\tline = br.readLine();\n\t\t\tfor (int j = 0; j < 8; j++) {\n\t\t\t\tpattern[i][j] = line.charAt(j);\n\t\t\t}\n\t\t}\n\t\tfor (int i = 1; i <= 3; i++) {\n\t\t\tpattern = rotate(pattern);\n\t\t\tSystem.out.println(i * 90);\n\t\t\tfor (int j = 0; j < 8; j++) {\n\t\t\t\tSystem.out.println(new String(pattern[j]));\n\t\t\t}\n\t\t}\n\t}\n\n\tstatic char[][] rotate(char[][] pattern) {\n\t\tchar[][] rotate = new char[8][8];\n\t\tfor (int i = 0; i < 8; i++) {\n\t\t\tfor (int j = 0; j < 8; j++) {\n\t\t\t\trotate[j][7 - i] = pattern[i][j];\n\t\t\t}\n\t\t}\n\t\treturn rotate;\n\t}\n}", "sampled": "import java.util.Scanner;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        char[][] pattern = new char[8][8];\n        \n        for (int i = 0; i < 8; i++) {\n            String line = sc.nextLine();\n            for (int j = 0; j < 8; j++) {\n                pattern[i][j] = line.charAt(j);\n            }\n        }\n        \n        // 90 degrees\n        System.out.println(\"90\");\n        char[][] rotated90 = rotate90(pattern);\n        printPattern(rotated90);\n        \n        // 180 degrees\n        System.out.println(\"180\");\n        char[][] rotated180 = rotate90(rotated90);\n        printPattern(rotated180);\n        \n        // 270 degrees\n        System.out.println(\"270\");\n        char[][] rotated270 = rotate90(rotated180);\n        printPattern(rotated270);\n        \n        sc.close();\n    }\n    \n    private static char[][] rotate90(char[][] pattern) {\n        char[][] result = new char[8][8];\n        for (int i = 0; i < 8; i++) {\n            for (int j = 0; j < 8; j++) {\n                result[i][j] = pattern[7 - j][i];\n            }\n        }\n        return result;\n    }\n    \n    private static void printPattern(char[][] pattern) {\n        for (int i = 0; i < 8; i++) {\n            for (int j = 0; j < 8; j++) {\n                System.out.print(pattern[i][j]);\n            }\n            System.out.println();\n        }\n    }\n}\n", "perturbed_sampled": ["import java.util.Scanner; public class Main { public static char[8][8];<extra_id_5>char[][] j<extra_id_6>{ int j<extra_id_7>= 0;<extra_id_8>= new<extra_id_9>(<extra_id_10>j ; j<extra_id_11>j<extra_id_12>} } }    String line = sc.nextLine(); for (int j = 0; j  char[][] rotated90 = rotate90(pattern); printPattern(rotated90); // 180 degrees System.out.println(\"180\"); char[][]  char[8][8];  {  j  = pattern[7 - j][i]; } } return result; } private static void printPattern(char[][] pattern) { for (int i = 0; i < 8;  = 0; j  }"], "perturbed_original": [" java.io.InputStreamReader; public class Main { public static  pattern =  = 0; i < 8; i++) { line = br.readLine(); for (int j  line.charAt(j);  =  System.out.println(i * 90); for (int j = 0;  pattern)  char[8][8]; for (int i = 0; i < 8; i++)  0;  rotate[j][7  } return rotate; } }"], "original_ll": -0.5110419392585754, "sampled_ll": -0.2992696166038513, "all_perturbed_sampled_ll": [-2.537760019302368], "all_perturbed_original_ll": [-2.795006036758423], "perturbed_sampled_ll": -2.537760019302368, "perturbed_original_ll": -2.795006036758423, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "d=[list(raw_input()) for i in range(8)]\np=[d,[],[],[]]\nfor r in range(3):\n\tprint 90*(r+1)\n\tfor j in range(8):\n\t\tp[r+1].append([p[r][i][j] for i in range(7,-1,-1)])\n\t\tprint \"\".join(p[r+1][j])", "sampled": "# Read input\npattern = []\nfor _ in range(8):\n    pattern.append(input())\n\n# 90 degree rotation (clockwise)\nrotated_90 = []\nfor col in range(8):\n    row_str = \"\"\n    for row in range(7, -1, -1):\n        row_str += pattern[row][col]\n    rotated_90.append(row_str)\n\n# 180 degree rotation\nrotated_180 = []\nfor row in range(7, -1, -1):\n    rotated_180.append(pattern[row][::-1])\n\n# 270 degree rotation (clockwise)\nrotated_270 = []\nfor col in range(7, -1, -1):\n    row_str = \"\"\n    for row in range(8):\n        row_str += pattern[row][col]\n    rotated_270.append(row_str)\n\n# Output\nprint(\"90\")\nfor row in rotated_90:\n    print(row)\nprint(\"180\")\nfor row in rotated_180:\n    print(row)\nprint(\"270\")\nfor row in rotated_270:\n    print(row)\n", "perturbed_sampled": ["# Read <extra_id_9>(2, 3)<extra_id_10>-1,<extra_id_11>#<extra_id_12>= '<extra_id_13>for<extra_id_14>0 : row_str =<extra_id_15>[<extra_id_16>+=<extra_id_17>[<extra_id_18>== ( col -<extra_id_19>== (<extra_id_20># (0,3 _ in range(8):  (clockwise) rotated_90 = [] for  range(7, -1, -1): row_str += pattern[row][col] rotated_90.append(row_str) # 180  -1, -1): rotated_180.append(pattern[row][::-1]) # 270  [] for  row_str =  row_str +=   rotated_180: print(row)  print(row)"], "perturbed_original": ["  print 90*(r+1) for j in  range(7,-1,-1)]) print \"\".join(p[r+1][j])"], "original_ll": -1.9614473581314087, "sampled_ll": -0.5773162245750427, "all_perturbed_sampled_ll": [-2.8066296577453613], "all_perturbed_original_ll": [-3.783440113067627], "perturbed_sampled_ll": -2.8066296577453613, "perturbed_original_ll": -3.783440113067627, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "#include<stdio.h>\n\nint main(){\n\n  int n, sum, in, i;\n\n  sum = 0;\n\n  scanf(\"%d\",&n);\n\n  for(i = 0; i < n; i++){\n    scanf(\"%d\",&in);\n    sum += in;\n  }\n\n  printf(\"%d\\n\",sum/n);\n\n  return 0;\n\n}", "sampled": "#include <stdio.h>\n\nint main() {\n    int n;\n    scanf(\"%d\", &n);\n    \n    long long sum = 0;\n    for (int i = 0; i < n; i++) {\n        int v;\n        scanf(\"%d\", &v);\n        sum += v;\n    }\n    \n    printf(\"%lld\\n\", sum / n);\n    \n    return 0;\n}\n", "perturbed_sampled": ["#include <stdio.h> int  &n);  0; i  v;  } printf(\"%lld\\n\", sum / n); return 0; }"], "perturbed_original": ["#include<stdio.h> int  i < n; i++){ scanf(\"%d\",&in); sum += in; } printf(\"%d\\n\",sum/n); return 0; }"], "original_ll": -1.0676270723342896, "sampled_ll": -0.5388792753219604, "all_perturbed_sampled_ll": [-3.636850357055664], "all_perturbed_original_ll": [-2.4304661750793457], "perturbed_sampled_ll": -3.636850357055664, "perturbed_original_ll": -2.4304661750793457, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.util.InputMismatchException;\nimport java.util.LinkedList;\n\n\n \npublic class Main {\n  public static void main(String[] args) {\n    InputReader sc = new InputReader(System.in);\n \n    int n = sc.nextInt();\n    long sum = 0;\n    for(int i = 0; i < n; i++){\n      sum += sc.nextInt();\n    }\n    System.out.println(sum/n);\n\n\n  }\n \n  \n \n  static class InputReader {\n      private InputStream stream;\n      private byte[] buf = new byte[1024];\n      private int curChar;\n      private int numChars;\n      private SpaceCharFilter filter;\n\n      public InputReader(InputStream stream) {\n          this.stream = stream;\n      }\n \n      public int next() {\n          if (numChars == -1)\n              throw new InputMismatchException();\n          if (curChar >= numChars) {\n              curChar = 0;\n              try {\n                  numChars = stream.read(buf);\n              } catch (IOException e) {\n                  throw new InputMismatchException();\n              }\n              if (numChars <= 0)\n                  return -1;\n          }\n          return buf[curChar++];\n      }\n \n      public String nextStr() {\n        int c = next();\n        while(isSpaceChar(c)){c = next();}\n        StringBuffer str = new StringBuffer();\n        do{\n          str.append((char)c);\n          c = next();\n        }while(!isSpaceChar(c));\n        return str.toString();\n      }\n\n      public int nextInt() {\n          int c = next();\n          while (isSpaceChar(c))\n              c = next();\n          int sgn = 1;\n          if (c == '-') {\n              sgn = -1;\n              c = next();\n          }\n          int res = 0;\n          do {\n              if (c < '0' || c > '9')\n                  throw new InputMismatchException();\n              res *= 10;\n              res += c - '0';\n              c = next();\n          } while (!isSpaceChar(c));\n          return res * sgn;\n      }\n \n      public boolean isSpaceChar(int c) {\n          if (filter != null)\n              return filter.isSpaceChar(c);\n          return c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n      }\n \n      public interface SpaceCharFilter {\n          public boolean isSpaceChar(int ch);\n      }\n  }\n}", "sampled": "import java.util.Scanner;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int n = sc.nextInt();\n        long sum = 0;\n        for (int i = 0; i < n; i++) {\n            sum += sc.nextInt();\n        }\n        System.out.println(sum / n);\n        sc.close();\n    }\n}\n", "perturbed_sampled": ["  args) { Scanner sc = new Scanner(System.in); int n = sc.nextInt(); long sum = 0;  sc.close(); } }"], "perturbed_original": ["import java.io.IOException; import java.io.InputStream; import java.io.PrintWriter; import java.util.Arrays; import java.util.InputMismatchException;  { public  InputReader sc = new InputReader(System.in); int n  0; i < n; i++){ sum +=   this.stream = stream; } public int next() { if (numChars == -1) throw new InputMismatchException(); if (curChar >= numChars) { curChar = 0; try { numChars =  String nextStr()  while(isSpaceChar(c)){c   =  } int res =  < '0' || c > '9') throw new InputMismatchException(); res *= 10; res +=  next(); } while (!isSpaceChar(c)); return res * sgn; }  if (filter != null) return filter.isSpaceChar(c); return c == ' '  c == '\\r'   } }"], "original_ll": -0.5630581378936768, "sampled_ll": -0.37894129753112793, "all_perturbed_sampled_ll": [-2.203463315963745], "all_perturbed_original_ll": [-2.371610403060913], "perturbed_sampled_ll": -2.203463315963745, "perturbed_original_ll": -2.371610403060913, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "def main():\n    n = int(input())\n    a = 0\n    for _ in range(n):\n        a += int(input())\n    ans = a // n\n    print(ans)\n\n\nif __name__ == \"__main__\":\n    main()", "sampled": "n = int(input())\ntotal = 0\nfor _ in range(n):\n    total += int(input())\nprint(total // n)\n", "perturbed_sampled": ["n += int ( input(t))  += int(input()) print(total // n)"], "perturbed_original": ["def main(): n = int(input()) a   print(ans) if __name__ == \"__main__\": main()"], "original_ll": -0.7077473402023315, "sampled_ll": -1.1342601776123047, "all_perturbed_sampled_ll": [-5.693041801452637], "all_perturbed_original_ll": [-2.599180221557617], "perturbed_sampled_ll": -5.693041801452637, "perturbed_original_ll": -2.599180221557617, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "#include <stdio.h>\n\nint main(void)\n{\n    int n;\n    int h, m;\n    int i;\n    double angle;\n    \n    scanf(\"%d\", &n);\n    for (i = 0; i < n; i++){\n        scanf(\"%d:%d\", &h, &m);\n        \n        angle = h * 360 / 12 + 360 / 12 * m / 60.0;\n        angle -= (360 / 60 * m);\n        \n        if (angle > 180){\n            angle -= 360;\n        }\n        \n        if (-30 < angle && angle < 30){\n            printf(\"alert\\n\");\n        }\n        else if (-90 < angle && angle < 90){\n            printf(\"warning\\n\");\n        }\n        else {\n            printf(\"safe\\n\");\n        }\n    }\n    return (0);\n}", "sampled": "#include <stdio.h>\n#include <stdlib.h>\n\nint main() {\n    int n;\n    scanf(\"%d\", &n);\n    \n    for (int i = 0; i < n; i++) {\n        int hh, mm;\n        scanf(\"%d:%d\", &hh, &mm);\n        \n        // Calculate angle of minute hand (6 degrees per minute)\n        double minute_angle = mm * 6.0;\n        \n        // Calculate angle of hour hand (30 degrees per hour + 0.5 degrees per minute)\n        double hour_angle = (hh % 12) * 30.0 + mm * 0.5;\n        \n        // Calculate the absolute difference\n        double diff = abs(hour_angle - minute_angle);\n        if (diff > 180.0) {\n            diff = 360.0 - diff;\n        }\n        \n        // Determine the output\n        if (diff >= 0 && diff < 30) {\n            printf(\"alert\\n\");\n        } else if (diff >= 90 && diff <= 180) {\n            printf(\"safe\\n\");\n        } else {\n            printf(\"warning\\n\");\n        }\n    }\n    \n    return 0;\n}\n", "perturbed_sampled": ["#include <stdio.h>  int n; scanf(\"%d\", &n); for  < n; i++) {  degrees  hour + 0.5 degrees per minute) double hour_angle  0.5; // Calculate the  abs(hour_angle - minute_angle); if  = 360.0 - diff; } //  < 30) { printf(\"alert\\n\"); } else  diff  else { printf(\"warning\\n\"); } } return 0; }"], "perturbed_original": ["#include <stdio.h> int +90;<extra_id_9>}<extra_id_10>}<extra_id_11>&&<extra_id_12>&& 17500<extra_id_13>; #include<extra_id_14><stdio.h<extra_id_15>\\t } \\n\"<extra_id_16>h<extra_id_17>, h , &<extra_id_18>) ;<extra_id_19>\"  < n; i++){ scanf(\"%d:%d\", &h, &m); angle = h * 360 / 12 +  / 60.0;    && angle <  (-90 < angle && angle  {  }"], "original_ll": -0.916720986366272, "sampled_ll": -0.6982060074806213, "all_perturbed_sampled_ll": [-3.0245258808135986], "all_perturbed_original_ll": [-2.7293450832366943], "perturbed_sampled_ll": -3.0245258808135986, "perturbed_original_ll": -2.7293450832366943, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import java.util.Scanner;\n\nclass Main{\n    public static void main(String[] args) {\n        Scanner sc=new Scanner(System.in);\n        int n=sc.nextInt();\n        for(int i=0;i<n;i++) {\n           String[] s=sc.next().split(\":\");\n           int a=Integer.parseInt(s[0])*60;\n           int b=Integer.parseInt(s[1]);\n           int d=Math.abs((a+b)/2-b*6);\n           System.out.println(d<30||d>330?\"alert\":d<90||d>270?\"warning\":\"safe\");\n        }\n    }\n}\n", "sampled": "import java.util.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int n = sc.nextInt();\n        sc.nextLine();\n        \n        for (int i = 0; i < n; i++) {\n            String time = sc.nextLine();\n            String[] parts = time.split(\":\");\n            int hh = Integer.parseInt(parts[0]);\n            int mm = Integer.parseInt(parts[1]);\n            \n            // Calculate angle of hour hand from 12 o'clock\n            // Hour hand moves 30 degrees per hour and 0.5 degrees per minute\n            double hourAngle = (hh % 12) * 30.0 + mm * 0.5;\n            \n            // Calculate angle of minute hand from 12 o'clock\n            // Minute hand moves 6 degrees per minute\n            double minuteAngle = mm * 6.0;\n            \n            // Calculate the difference\n            double diff = Math.abs(hourAngle - minuteAngle);\n            \n            // The angle should be the smaller one (between 0 and 180)\n            if (diff > 180) {\n                diff = 360 - diff;\n            }\n            \n            if (diff >= 0 && diff < 30) {\n                System.out.println(\"alert\");\n            } else if (diff >= 90 && diff <= 180) {\n                System.out.println(\"safe\");\n            } else {\n                System.out.println(\"warning\");\n            }\n        }\n        \n        sc.close();\n    }\n}\n", "perturbed_sampled": ["import java.util.*; public class  main(String[]  new Scanner(System.in); int n =  = 0; i <  = sc.nextLine(); String[] parts = time.split(\":\"); int hh = Integer.parseInt(parts[0]); int mm = Integer.parseInt(parts[1]); // Calculate angle of hour hand from 12  minute  mm * 0.5; //  from  minute  6.0; // Calculate the difference  minuteAngle);  (diff > 180) {  }  System.out.println(\"alert\"); } else if (diff >=   } }"], "perturbed_original": [" static void  Scanner(System.in);  String[] s=sc.next().split(\":\"); int a=Integer.parseInt(s[0])*60; int b=Integer.parseInt(s[1]);  }"], "original_ll": -1.3546119928359985, "sampled_ll": -0.6108269691467285, "all_perturbed_sampled_ll": [-3.1003713607788086], "all_perturbed_original_ll": [-2.5763614177703857], "perturbed_sampled_ll": -3.1003713607788086, "perturbed_original_ll": -2.5763614177703857, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "N = int(input())\nfor i in range(N):\n    h, m = map(int, input().split(\":\"))\n    d = abs(60*h - 11*m)\n    v = min(d, 720 - d)\n    if v < 60:\n        print(\"alert\")\n    elif v < 180:\n        print(\"warning\")\n    else:\n        print(\"safe\")\n\n", "sampled": "n = int(input())\nfor _ in range(n):\n    time = input().strip()\n    hh, mm = map(int, time.split(':'))\n    \n    # Calculate hour hand angle (from 12 o'clock)\n    hour_angle = (hh % 12) * 30 + mm * 0.5\n    \n    # Calculate minute hand angle (from 12 o'clock)\n    minute_angle = mm * 6\n    \n    # Calculate the difference\n    diff = abs(hour_angle - minute_angle)\n    \n    # Take the smaller angle\n    if diff > 180:\n        diff = 360 - diff\n    \n    # Determine the status\n    if 0 <= diff < 30:\n        print(\"alert\")\n    elif 90 <= diff <= 180:\n        print(\"safe\")\n    else:\n        print(\"warning\")\n", "perturbed_sampled": ["n = int(input()) for _ in range(n): time = input().strip() hh, mm = map(int, time.split(':')) # Calculate hour  12) * 30 + mm * 0.5 #   diff = 360  status if 0  <= 180: print(\"safe\") else: print(\"warning\")"], "perturbed_original": ["N = int(input()) for i in range(N):  11*m) v =   v < 180: print(\"warning\") else: print(\"safe\")"], "original_ll": -1.1729199886322021, "sampled_ll": -0.8702866435050964, "all_perturbed_sampled_ll": [-2.5549800395965576], "all_perturbed_original_ll": [-3.452834129333496], "perturbed_sampled_ll": -2.5549800395965576, "perturbed_original_ll": -3.452834129333496, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "#include<stdio.h>\nint main(void)\n{\n\tint i,j,num[24+1],temp01;\n\tfloat time[24+1],temp02;\n\tfor(i=0;i<24;i++) {\n\t\tscanf(\"%d %f\",&num[i],&time[i]);\n\t}\n\tfor(i=0;i<8-1;i++) {\n\t\tfor(j=i+1;j<8;j++) {\n\t\t\tif(time[i]>time[j]) {\n\t\t\t\ttemp01=num[i];\n\t\t\t\tnum[i]=num[j];\n\t\t\t\tnum[j]=temp01;\n\t\t\t\ttemp02=time[i];\n\t\t\t\ttime[i]=time[j];\n\t\t\t\ttime[j]=temp02;\n\t\t\t}\n\t\t}\n\t}\n\tfor(i=8;i<16-1;i++) {\n\t\tfor(j=i+1;j<16;j++) {\n\t\t\tif(time[i]>time[j]) {\n\t\t\t\ttemp01=num[i];\n\t\t\t\tnum[i]=num[j];\n\t\t\t\tnum[j]=temp01;\n\t\t\t\ttemp02=time[i];\n\t\t\t\ttime[i]=time[j];\n\t\t\t\ttime[j]=temp02;\n\t\t\t}\n\t\t}\n\t}\n\tfor(i=16;i<24-1;i++) {\n\t\tfor(j=i+1;j<24;j++) {\n\t\t\tif(time[i]>time[j]) {\n\t\t\t\ttemp01=num[i];\n\t\t\t\tnum[i]=num[j];\n\t\t\t\tnum[j]=temp01;\n\t\t\t\ttemp02=time[i];\n\t\t\t\ttime[i]=time[j];\n\t\t\t\ttime[j]=temp02;\n\t\t\t}\n\t\t}\n\t}\n\tfor(i=0;i<2;i++) {\n\t\tprintf(\"%d %f\\n\",num[i],time[i]);\n\t\ttime[i]=100.00;\n\t}\n\tfor(i=8;i<10;i++) {\n\t\tprintf(\"%d %f\\n\",num[i],time[i]);\n\t\ttime[i]=100.00;\n\t}\n\tfor(i=16;i<18;i++) {\n\t\tprintf(\"%d %f\\n\",num[i],time[i]);\n\t\ttime[i]=100.00;\n\t}\n\tfor(i=0;i<24-1;i++) {\n\t\tfor(j=i+1;j<24;j++) {\n\t\t\tif(time[i]>time[j]) {\n\t\t\t\ttemp01=num[i];\n\t\t\t\tnum[i]=num[j];\n\t\t\t\tnum[j]=temp01;\n\t\t\t\ttemp02=time[i];\n\t\t\t\ttime[i]=time[j];\n\t\t\t\ttime[j]=temp02;\n\t\t\t}\n\t\t}\n\t}\n\tfor(i=0;i<2;i++) {\n\t\tprintf(\"%d %f\\n\",num[i],time[i]);\n\t}\n\treturn 0;\n}", "sampled": "#include <stdio.h>\n#include <stdlib.h>\n\ntypedef struct {\n    int player;\n    double time;\n} Record;\n\nint compare(const void *a, const void *b) {\n    Record *r1 = (Record *)a;\n    Record *r2 = (Record *)b;\n    if (r1->time < r2->time) return -1;\n    if (r1->time > r2->time) return 1;\n    return 0;\n}\n\nint main() {\n    Record groups[3][8];\n    Record qualifiers[8];\n    Record others[18];\n    int others_count = 0;\n    \n    // Read input\n    for (int i = 0; i < 3; i++) {\n        for (int j = 0; j < 8; j++) {\n            scanf(\"%d %lf\", &groups[i][j].player, &groups[i][j].time);\n        }\n    }\n    \n    // Sort each group by time\n    for (int i = 0; i < 3; i++) {\n        qsort(groups[i], 8, sizeof(Record), compare);\n    }\n    \n    // First 2 from each group\n    qualifiers[0] = groups[0][0];\n    qualifiers[1] = groups[0][1];\n    qualifiers[2] = groups[1][0];\n    qualifiers[3] = groups[1][1];\n    qualifiers[4] = groups[2][0];\n    qualifiers[5] = groups[2][1];\n    \n    // Collect 3rd place and below from all groups\n    for (int i = 0; i < 3; i++) {\n        for (int j = 2; j < 8; j++) {\n            others[others_count++] = groups[i][j];\n        }\n    }\n    \n    // Sort others by time\n    qsort(others, others_count, sizeof(Record), compare);\n    \n    // Top 2 from others\n    qualifiers[6] = others[0];\n    qualifiers[7] = others[1];\n    \n    // Output\n    for (int i = 0; i < 8; i++) {\n        printf(\"%d %.2f\\n\", qualifiers[i].player, qualifiers[i].time);\n    }\n    \n    return 0;\n}\n", "perturbed_sampled": ["#include <stdio.h> #include <stdlib.h> typedef struct { int player;  compare(const void *a,  *r1 = (Record *)a; Record *r2 = (Record    input for (int i = 0; i  j < 8; j++) {  } // Sort each group by time for (int  3; i++)  from each group qualifiers[0] = groups[0][0]; qualifiers[1]  qualifiers[3] = groups[1][1]; qualifiers[4] = groups[2][0];  from all  0;  2; j < 8; j++) { others[others_count++] = groups[i][j]; } }  others  others[1]; // Output for (int i   }"], "perturbed_original": ["#include<stdio.h> int main(void) { int  scanf(\"%d %f\",&num[i],&time[i]); } for(i=0;i<8-1;i++) {  time[j]=temp02; } } } for(i=8;i<16-1;i++) { for(j=i+1;j<16;j++)  }  time[j]=temp02; } } } for(i=0;i<2;i++) { printf(\"%d  printf(\"%d  printf(\"%d %f\\n\",num[i],time[i]); time[i]=100.00; }  temp02=time[i]; time[i]=time[j]; time[j]=temp02; }  %f\\n\",num[i],time[i]); } return 0; }"], "original_ll": -0.37221649289131165, "sampled_ll": -0.5337332487106323, "all_perturbed_sampled_ll": [-2.9212863445281982], "all_perturbed_original_ll": [-1.688552975654602], "perturbed_sampled_ll": -2.9212863445281982, "perturbed_original_ll": -1.688552975654602, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import java.util.Arrays;\nimport java.util.Scanner;\nclass Player implements Comparable<Player>{\n\tint party;\n\tint num;\n\tString time;\n\tPlayer(int p,int n,String t){\n\t\tthis.party = p;\n\t\tthis.num = n;\n\t\tthis.time = t;\n\t}\n\t/*@Override\n\tpublic int compareTo(Player p) {\n\t\treturn this.time.compareTo(p.num);\n\t}\n\t*/\n\t@Override\n\tpublic int compareTo(Player o) {\n\t\t// TODO Auto-generated method stub\n\t\treturn this.time.compareTo(o.time);\n\t}\n\t\n}\n\npublic class Main{\n\tpublic static void main(String[] args){\n\t\tScanner sc = new Scanner(System.in);\n\t\tPlayer[] person = new Player[24];\n\t\tint[][] rank = new int[3][8];\n\t\tint[] cnt = new int[3]; \n\t\tint cnt1 = 0;\n\t\tint cnt2 = 0;\n\t\tint cnt3 = 0;\n\t\tfor(int i = 0;i < 3;i++){\n\t\t\tfor(int j = 0;j < 8;j++){\n\t\t\t\tperson[i*8+j] = new Player(i,sc.nextInt(),sc.next());\n\t\t\t}\n\t\t}\n\t\tArrays.sort(person);\n\t\tfor(int i = 0;i < 24;i++){\n\t\t\trank[person[i].party][cnt[person[i].party]] = i;\n\t\t\tcnt[person[i].party]++;\n\t\t}\n\t\tfor(int i = 0;i < 3;i++){\n\t\t\tfor(int j = 0;j < 2;j++){\n\t\t\t\tSystem.out.println(person[rank[i][j]].num+\" \"+person[rank[i][j]].time);\n\t\t\t\tperson[rank[i][j]].time = \"999\";\n\t\t\t}\n\t\t}\n\t\tArrays.sort(person);\n\t\tfor(int j = 0;j < 2;j++){\n\t\t\tSystem.out.println(person[j].num+\" \"+person[j].time);\n\t\t}\n\t\t\n\t}\n}", "sampled": "import java.util.*;\n\npublic class Main {\n    static class Athlete implements Comparable<Athlete> {\n        int number;\n        double time;\n        \n        Athlete(int number, double time) {\n            this.number = number;\n            this.time = time;\n        }\n        \n        @Override\n        public int compareTo(Athlete other) {\n            return Double.compare(this.time, other.time);\n        }\n    }\n    \n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        \n        List<Athlete>[] groups = new List[3];\n        for (int i = 0; i < 3; i++) {\n            groups[i] = new ArrayList<>();\n        }\n        \n        // Read input\n        for (int i = 0; i < 24; i++) {\n            int number = sc.nextInt();\n            double time = sc.nextDouble();\n            int group = i / 8;\n            groups[group].add(new Athlete(number, time));\n        }\n        \n        // Sort each group by time\n        for (int i = 0; i < 3; i++) {\n            Collections.sort(groups[i]);\n        }\n        \n        // Output top 2 from each group\n        List<Athlete> finalists = new ArrayList<>();\n        for (int i = 0; i < 3; i++) {\n            finalists.add(groups[i].get(0));\n            finalists.add(groups[i].get(1));\n        }\n        \n        // Get 3rd place and below from all groups\n        List<Athlete> remaining = new ArrayList<>();\n        for (int i = 0; i < 3; i++) {\n            for (int j = 2; j < groups[i].size(); j++) {\n                remaining.add(groups[i].get(j));\n            }\n        }\n        \n        // Sort remaining athletes and get top 2\n        Collections.sort(remaining);\n        finalists.add(remaining.get(0));\n        finalists.add(remaining.get(1));\n        \n        // Output all finalists\n        for (Athlete a : finalists) {\n            System.out.println(a.number + \" \" + a.time);\n        }\n        \n        sc.close();\n    }\n}\n", "perturbed_sampled": [" { static class  = time; } @Override public int compareTo(Athlete other) { return   Scanner sc = new Scanner(System.in); List<Athlete>[] groups = new  0; i  =  24; i++) { int  groups[group].add(new  each group by time for  < 3; i++) { Collections.sort(groups[i]);  finalists = new ArrayList<>(); for (int i = 0; i < 3;  new ArrayList<>(); for   (int j = 2; j  }  and get top 2  a : finalists) { System.out.println(a.number + \" \" + a.time); } sc.close(); } }"], "perturbed_original": ["import java.util.Arrays;  Comparable<Player>{ int party; int num; String time; Player(int p,int n,String t){ this.party  /*@Override public int compareTo(Player p) { return  //     new Player[24]; int[][] rank = new int[3][8]; int[] cnt = new int[3]; int  = 0; int  =  = 0;j  Player(i,sc.nextInt(),sc.next()); }  0;i < 24;i++){ rank[person[i].party][cnt[person[i].party]] = i; cnt[person[i].party]++;  \"999\"; } }  } } }"], "original_ll": -0.8175483345985413, "sampled_ll": -0.5593482255935669, "all_perturbed_sampled_ll": [-2.953551769256592], "all_perturbed_original_ll": [-2.7838234901428223], "perturbed_sampled_ll": -2.953551769256592, "perturbed_original_ll": -2.7838234901428223, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "l1,l2,l3=[],[],[]\nfinal=[]\ncount=0\nfor i in range(24):\n    p,t=map(float,input().split())\n    if count<=7:l1.append([t,p])\n    elif 7<count<=15:l2.append([t,p])\n    elif 15<count<=23:l3.append([t,p])\n    count +=1\nl1=sorted(l1)\nl2=sorted(l2)\nl3=sorted(l3)\nfinal +=[l1[0],l1[1],l2[0],l2[1],l3[0],l3[1]]\ndel l1[0],l1[0],l2[0],l2[0],l3[0],l3[0]\nthird=sorted(l1+l2+l3)\nfinal +=[third[0],third[1]]\nfor i in range(8):print(int(final[i][1]),final[i][0])\n", "sampled": "# Read all 24 runners\nrunners = []\nfor i in range(24):\n    line = input().split()\n    p = int(line[0])\n    t = float(line[1])\n    runners.append((p, t))\n\n# Split into 3 groups\ngroup1 = runners[0:8]\ngroup2 = runners[8:16]\ngroup3 = runners[16:24]\n\n# Sort each group by time\ngroup1.sort(key=lambda x: x[1])\ngroup2.sort(key=lambda x: x[1])\ngroup3.sort(key=lambda x: x[1])\n\n# Top 2 from each group\nqualifiers = []\nqualifiers.append(group1[0])\nqualifiers.append(group1[1])\nqualifiers.append(group2[0])\nqualifiers.append(group2[1])\nqualifiers.append(group3[0])\nqualifiers.append(group3[1])\n\n# Collect 3rd place and below from all groups\nremaining = []\nremaining.extend(group1[2:])\nremaining.extend(group2[2:])\nremaining.extend(group3[2:])\n\n# Sort remaining by time and take top 2\nremaining.sort(key=lambda x: x[1])\nqualifiers.append(remaining[0])\nqualifiers.append(remaining[1])\n\n# Output\nfor p, t in qualifiers:\n    print(f\"{p} {t:.2f}\")\n", "perturbed_sampled": ["# Read all 24   t = float(line[1]) runners.append((p, t))   runners[8:16] group3 = runners[16:24] # Sort each group  group2.sort(key=lambda  # Top 2 from  = [] remaining.extend(group1[2:]) remaining.extend(group2[2:]) remaining.extend(group3[2:]) # Sort remaining by time  # Output for p, t in qualifiers: print(f\"{p} {t:.2f}\")"], "perturbed_original": ["l1,l2,l3=[],[],[] final=[] count=0 for i  l1[0],l1[0],l2[0],l2[0],l3[0],l3[0] third=sorted(l1+l2+l3) final +=[third[0],third[1]] for i in range(8):print(int(final[i][1]),final[i][0])"], "original_ll": -1.0655614137649536, "sampled_ll": -0.8165257573127747, "all_perturbed_sampled_ll": [-3.107009172439575], "all_perturbed_original_ll": [-1.8799903392791748], "perturbed_sampled_ll": -3.107009172439575, "perturbed_original_ll": -1.8799903392791748, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "#include<stdio.h>\n\nint main(void){\n  char w[201];\n  int a,i,j,k;\n  scanf(\"%d\",&a);\n  for(j=0;j<a;j++){\n    scanf(\"%s\",w);\n    if(w[0]!='>'){printf(\"NA\\n\");continue;}\n    if(w[1]=='\\''){\n      for(i=2;w[i]!='#';i++){\n\tif(w[i]!='='){printf(\"NA\\n\");continue;}\n      }\n      int t=i-1;\n      for(k=t;t>0;t--){\n\tif(w[i++]!='='){printf(\"NA\\n\");continue;}\n      }\n      if(w[i++]!='~'){printf(\"NA\\n\");continue;}\n      if(w[i]!='\\0'){printf(\"NA\\n\");continue;}\n      printf(\"A\\n\");\n    }\n    if(w[1]=='^'){\n      for(i=2;w[i]=='~';i+=2){\n\tif(w[i]!='Q'){printf(\"NA\\n\");continue;}\n\tif(w[i+1]!='='){printf(\"NA\\n\");continue;}\n      }\n      if(w[i]!='~'){printf(\"NA\\n\");continue;}\n      if(w[i+1]!='~'){printf(\"NA\\n\");continue;}\n      if(w[i+2]!='\\0'){printf(\"NA\\n\");continue;}\n      printf(\"B\\n\");\n    }\n  }\nreturn 0;\n}", "sampled": "#include <stdio.h>\n#include <string.h>\n\nint checkA(char *s) {\n    int len = strlen(s);\n    if (len < 6) return 0;\n    if (s[0] != '>' || s[1] != '\\'') return 0;\n    if (s[len-1] != '~') return 0;\n    \n    int i = 2;\n    int count1 = 0;\n    while (i < len && s[i] == '=') {\n        count1++;\n        i++;\n    }\n    \n    if (count1 == 0) return 0;\n    if (i >= len || s[i] != '#') return 0;\n    i++;\n    \n    int count2 = 0;\n    while (i < len && s[i] == '=') {\n        count2++;\n        i++;\n    }\n    \n    if (count2 != count1) return 0;\n    if (i != len - 1) return 0;\n    if (s[i] != '~') return 0;\n    \n    return 1;\n}\n\nint checkB(char *s) {\n    int len = strlen(s);\n    if (len < 6) return 0;\n    if (s[0] != '>' || s[1] != '^') return 0;\n    if (len < 2 || s[len-1] != '~' || s[len-2] != '~') return 0;\n    \n    int i = 2;\n    int count = 0;\n    while (i < len - 2) {\n        if (s[i] == 'Q' && i + 1 < len - 2 && s[i+1] == '=') {\n            count++;\n            i += 2;\n        } else {\n            return 0;\n        }\n    }\n    \n    if (count == 0) return 0;\n    if (i != len - 2) return 0;\n    \n    return 1;\n}\n\nint main() {\n    int n;\n    scanf(\"%d\", &n);\n    \n    for (int i = 0; i < n; i++) {\n        char s[201];\n        scanf(\"%s\", s);\n        \n        if (checkA(s)) {\n            printf(\"A\\n\");\n        } else if (checkB(s)) {\n            printf(\"B\\n\");\n        } else {\n            printf(\"NA\\n\");\n        }\n    }\n    \n    return 0;\n}\n", "perturbed_sampled": ["#include <extra_id_8>i< len<extra_id_9>(int<extra_id_10>> 0)<extra_id_11>> 0)<extra_id_12>s[i]<extra_id_13>+(count <= len-2) if (count+1)<extra_id_14>if (count > 1)<extra_id_15>*s<extra_id_16>count1 ><extra_id_17>0 ;<extra_id_18>} } *s) { int   '~') return 0; int i = 2;  (i < len && s[i] == '=')  '#') return  0; while   } if (count2 != count1) return 0;  (s[i] !=   int    if  int count = 0; while  { if (s[i] == 'Q' && i  2 && s[i+1] == '=') {  else { return 0; } } if (count == 0) return 0; if (i != len - 2) return 0;  { int n; scanf(\"%d\", &n); for (int i = 0; i < n; i++) {   } } return 0; }"], "perturbed_original": [" if(w[i]!='='){printf(\"NA\\n\");continue;} } int t=i-1; for(k=t;t>0;t--){  } if(w[1]=='^'){ for(i=2;w[i]=='~';i+=2){ if(w[i]!='Q'){printf(\"NA\\n\");continue;} if(w[i+1]!='='){printf(\"NA\\n\");continue;} }  } return 0; }"], "original_ll": -1.0813062191009521, "sampled_ll": -0.568453311920166, "all_perturbed_sampled_ll": [-2.3695666790008545], "all_perturbed_original_ll": [-2.099959373474121], "perturbed_sampled_ll": -2.3695666790008545, "perturbed_original_ll": -2.099959373474121, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import java.io.*;\nimport java.util.*;\n\npublic class Main{\n\tpublic static void main(String[] args){\n\t\ttry{\n\t\t\tnew Main();\n\t\t}catch(IOException e){\n\t\t\te.printStackTrace();\n\t\t}\n\t}\n\t\n\tpublic Main() throws IOException{\n\t\tBufferedReader in = new BufferedReader(new InputStreamReader(System.in));\n\t\tList<String> Ans = new ArrayList<String>();\n\t\tString line = in.readLine();\n\t\t\n\t\tint size = Integer.parseInt(line);\n\t\tfor(int n=0; n<size; n++){\n\t\t\tline = in.readLine();\n\t\t\tint type = 0;\n\t\t\t\n\t\t\tString c = line.substring(0, 2);\n\t\t\tif(c.equals(\">'\")){\n\t\t\t\tint count = 0;\n\t\t\t\tint sharp = 0;\n\t\t\t\tfor(int i=2; i<line.length(); i++){\n\t\t\t\t\tc = line.substring(i, i+1);\n\t\t\t\t\tif(c.equals(\"=\")){\n\t\t\t\t\t\tcount++;\n\t\t\t\t\t}\n\t\t\t\t\telse if(c.equals(\"#\")){\n\t\t\t\t\t\tif(count > 0){\n\t\t\t\t\t\t\tcount = -count;\n\t\t\t\t\t\t\tsharp = 1;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse{\n\t\t\t\t\t\t\ttype = -1;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse if(c.equals(\"~\")){\n\t\t\t\t\t\tif(i != line.length()-1){\n\t\t\t\t\t\t\ttype = -1;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t\tif(count==0 && sharp==1){\n\t\t\t\t\t\t\ttype = 1;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse{\n\t\t\t\t\t\t\ttype = -1;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse{\n\t\t\t\t\t\ttype = -1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if(c.equals(\">^\")){\n\t\t\t\tint count = 0;\n\t\t\t\tfor(int i=2; i<line.length(); i++){\n\t\t\t\t\tc = line.substring(i, i+1);\n\t\t\t\t\tif(count%2==0 && count>=2 && c.equals(\"~\")){\n\t\t\t\t\t\tif(i==line.length()-1){\n\t\t\t\t\t\t\ttype = -1;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t\tc = line.substring(i+1, i+2);\n\t\t\t\t\t\tif(c.equals(\"~\")){\n\t\t\t\t\t\t\ttype = 2;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse{\n\t\t\t\t\t\t\ttype = -1;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(i%2==0){\n\t\t\t\t\t\tif(!c.equals(\"Q\")){\n\t\t\t\t\t\t\ttype = -1;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcount++;\n\t\t\t\t\t}\n\t\t\t\t\tif(i%2==1){\n\t\t\t\t\t\tif(!c.equals(\"=\")){\n\t\t\t\t\t\t\ttype = -1;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcount++;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tif(!c.equals(\"Q\") && !c.equals(\"=\") && !c.equals(\"~\")){\n\t\t\t\t\t\ttype = -1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse{\n\t\t\t\ttype = -1;\n\t\t\t}\n\t\t\t\n\t\t\tswitch(type){\n\t\t\t\tcase 1:\n\t\t\t\t\tAns.add(\"A\");\n\t\t\t\t\tbreak;\n\t\t\t\t\t\n\t\t\t\tcase 2:\n\t\t\t\t\tAns.add(\"B\");\n\t\t\t\t\tbreak;\n\t\t\t\t\t\n\t\t\t\tdefault:\n\t\t\t\t\tAns.add(\"NA\");\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor(int n=0; n<Ans.size(); n++){\n\t\t\tSystem.out.println(Ans.get(n));\n\t\t}\n\t}\n}", "sampled": "import java.util.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int n = sc.nextInt();\n        sc.nextLine();\n        \n        for (int i = 0; i < n; i++) {\n            String s = sc.nextLine();\n            System.out.println(classify(s));\n        }\n        sc.close();\n    }\n    \n    static String classify(String s) {\n        if (isTypeA(s)) {\n            return \"A\";\n        } else if (isTypeB(s)) {\n            return \"B\";\n        } else {\n            return \"NA\";\n        }\n    }\n    \n    static boolean isTypeA(String s) {\n        // Pattern: >'=+#=+~\n        // Must start with >'\n        if (!s.startsWith(\">'\")) {\n            return false;\n        }\n        \n        // Must end with ~\n        if (!s.endsWith(\"~\")) {\n            return false;\n        }\n        \n        // Find # position\n        int hashPos = s.indexOf('#');\n        if (hashPos == -1) {\n            return false;\n        }\n        \n        // Check if there's only one #\n        if (s.indexOf('#', hashPos + 1) != -1) {\n            return false;\n        }\n        \n        // Extract parts\n        String beforeHash = s.substring(2, hashPos);\n        String afterHash = s.substring(hashPos + 1, s.length() - 1);\n        \n        // Both parts must be non-empty and consist only of '='\n        if (beforeHash.length() == 0 || afterHash.length() == 0) {\n            return false;\n        }\n        \n        // Both parts must have same length and only contain '='\n        if (beforeHash.length() != afterHash.length()) {\n            return false;\n        }\n        \n        for (char c : beforeHash.toCharArray()) {\n            if (c != '=') {\n                return false;\n            }\n        }\n        \n        for (char c : afterHash.toCharArray()) {\n            if (c != '=') {\n                return false;\n            }\n        }\n        \n        return true;\n    }\n    \n    static boolean isTypeB(String s) {\n        // Pattern: >^(Q=)+~~\n        // Must start with >^\n        if (!s.startsWith(\">^\")) {\n            return false;\n        }\n        \n        // Must end with ~~\n        if (!s.endsWith(\"~~\")) {\n            return false;\n        }\n        \n        // Extract middle part\n        String middle = s.substring(2, s.length() - 2);\n        \n        // Middle must be non-empty\n        if (middle.length() == 0) {\n            return false;\n        }\n        \n        // Middle must be repetitions of \"Q=\"\n        if (middle.length() % 2 != 0) {\n            return false;\n        }\n        \n        for (int i = 0; i < middle.length(); i += 2) {\n            if (middle.charAt(i) != 'Q' || middle.charAt(i + 1) != '=') {\n                return false;\n            }\n        }\n        \n        return true;\n    }\n}\n", "perturbed_sampled": [" main(String[] args) { Scanner sc   < n;  sc.nextLine(); System.out.println(classify(s)); } sc.close(); } static String classify(String s) {    // Must start with >' if (!s.startsWith(\">'\"))   (!s.endsWith(\"~\"))  Find # position int hashPos = s.indexOf('#'); if   return false; }  afterHash = s.substring(hashPos  // Both parts must be non-empty and consist only of   same length and only contain '=' if (beforeHash.length()  } for (char  (c != '=') { return false; } } for  if (c != '=') { return false; } } return true; } static boolean  >^(Q=)+~~ // Must  { return    = s.substring(2, s.length() - 2); // Middle must be non-empty if (middle.length() ==   %  false; }  i < middle.length(); i += 2) { if  }"], "perturbed_original": ["import java.io.*; import java.util.*; public   }catch(IOException e){ e.printStackTrace(); } }  n<size; n++){   line.substring(0, 2); if(c.equals(\">'\")){ int  i<line.length(); i++){  count++; } else  -1; break; } if(count==0 &&  -1; break; } } else{   count =  c = line.substring(i, i+1); if(count%2==0 && count>=2  -1; break; } c =  2; break; } else{ type = -1; break; }  -1; break; } count++; } if(i%2==1){ if(!c.equals(\"=\")){ type = -1; break; } count++; }  type  1: Ans.add(\"A\"); break; case 2: Ans.add(\"B\"); break; default: Ans.add(\"NA\"); } }  } } }"], "original_ll": -0.7134687304496765, "sampled_ll": -0.6665359139442444, "all_perturbed_sampled_ll": [-3.4189016819000244], "all_perturbed_original_ll": [-2.461003065109253], "perturbed_sampled_ll": -3.4189016819000244, "perturbed_original_ll": -2.461003065109253, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "# -*- coding: utf-8 -*-\n\nimport sys\nimport os\n\nN = int(input())\n\ndef is_A(s):\n    if s[0:2] != \">'\":\n        return False\n\n    if s[-1] != '~':\n        return False\n\n    body = s[2:-1]\n\n    if len(body) % 2 == 0:\n        return False\n\n    # body = '==#=='\n    center_index = len(body) // 2\n    if body[center_index] != '#':\n        return False\n\n    if body.count('#') != 1:\n        return False\n\n    lst = body.split('#')\n    if len(lst) != 2:\n        return False\n\n    if len(lst[0]) > 0 and lst[0] == lst[1] and len(lst[0]) == lst[0].count('='):\n        return True\n    else:\n        return False\n\ndef is_B(s):\n    if s[0:2] != \">^\":\n        return False\n\n    if s[-2:] != '~~':\n        return False\n\n    body = s[2:-2]\n\n    if len(body) % 2 != 0:\n        return False\n    elif body.count('Q=') > 0 and body.count('Q=') == len(body) // 2:\n        return True\n    else:\n        return False\n\nfor s in sys.stdin:\n    s = s.strip()\n\n    if is_A(s):\n        print('A')\n    elif is_B(s):\n        print('B')\n    else:\n        print('NA')", "sampled": "import re\n\nn = int(input())\nfor _ in range(n):\n    s = input().strip()\n    \n    # Check for Type A: >'=+#=+~\n    match_a = re.match(r\"^>\\'(=+)#\\1~$\", s)\n    if match_a:\n        print(\"A\")\n        continue\n    \n    # Check for Type B: >^(Q=)+~~\n    match_b = re.match(r\"^>\\^(Q=)+~~$\", s)\n    if match_b:\n        print(\"B\")\n        continue\n    \n    print(\"NA\")\n", "perturbed_sampled": ["import re n = int(input())  = input().strip() #   Check for Type B: >^(Q=)+~~ match_b =  continue print(\"NA\")"], "perturbed_original": [" import   if s[-1] !=   '#':   body.split('#') if  if len(lst[0]) > 0 and lst[0]  if s[0:2] != \">^\": return False if s[-2:] != '~~': return False body = s[2:-2]  0:  0 and body.count('Q=') == len(body) // 2: return  s in sys.stdin: s = s.strip() if is_A(s): print('A') elif is_B(s): print('B') else: print('NA')"], "original_ll": -0.9942391514778137, "sampled_ll": -1.8081978559494019, "all_perturbed_sampled_ll": [-5.986949443817139], "all_perturbed_original_ll": [-2.8180201053619385], "perturbed_sampled_ll": -5.986949443817139, "perturbed_original_ll": -2.8180201053619385, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "#include <stdio.h>\nint main(){\n\tchar tei[15]={0,1,2,3,4,5,6,7,8,9,5,4,3,2,1},ans[1000][20];\n\tint n,i,to,from,j;\n\tscanf(\"%d\",&n);\n\tfor(i=0;i<n;i++){\n\t\tscanf(\"%d %d\",&from,&to);\n\t\tif(from<to){\n\t\t\t\tfor(j=from;j<to;j++){\n\t\t\t\t\tprintf(\"%d \",j);\n\t\t\t\t}\n\t\t\t\tprintf(\"%d\\n\",to);\n\t\t}else if(to==5){\n\t\t\tfor(j=from;j<=9;j++){\n\t\t\t\tprintf(\"%d \",j);\n\t\t\t}\n\t\t\tputs(\"5\");\n\t\t}else if(from>to){\n\t\t\tif(from>=6&&from<=9){\n\t\t\t\tfor(j=from;j<=9;j++){\n\t\t\t\t\tprintf(\"%d \",j);\n\t\t\t\t}\n\t\t\t\tfor(j=5;j>to;j--){\n\t\t\t\t\tprintf(\"%d \",j);\n\t\t\t\t}\n\t\t\t\tprintf(\"%d\\n\",to);\n\t\t\t}else{\n\t\t\t\tfor(j=from;j>to;j--){\n\t\t\t\t\tprintf(\"%d \",j);\n\t\t\t\t}\n\t\t\t\tprintf(\"%d\\n\",to);\n\t\t\t}\n\t\t}\n\t}\n\t\n\treturn 0;\n}", "sampled": "#include <stdio.h>\n\nint main() {\n    int n;\n    scanf(\"%d\", &n);\n    \n    while (n--) {\n        int start, end;\n        scanf(\"%d %d\", &start, &end);\n        \n        // Calculate distances for different routes\n        int dist_forward = 0;\n        int dist_backward = 0;\n        \n        // Going forward (clockwise direction)\n        if (start <= 5 && end <= 5) {\n            if (end > start) {\n                dist_forward = end - start;\n            } else {\n                // Need to go through the loop\n                dist_forward = (5 - start) + 1 + (9 - 5) + 1 + (5 - end);\n            }\n        } else if (start <= 5 && end > 5) {\n            // From main line to loop\n            if (start <= 5) {\n                dist_forward = (5 - start) + (end - 5);\n            }\n        } else if (start > 5 && end <= 5) {\n            // From loop to main line\n            if (end <= 5) {\n                if (start == 9) dist_forward = 1 + end;\n                else if (start == 8) dist_forward = 2 + end;\n                else if (start == 7) dist_forward = 3 + end;\n                else if (start == 6) dist_forward = 4 + end;\n            }\n        } else {\n            // Both in loop\n            if (end > start) {\n                dist_forward = end - start;\n            } else {\n                dist_forward = (9 - start) + 1 + (end - 5);\n            }\n        }\n        \n        // Going backward (counter-clockwise)\n        if (start <= 5 && end <= 5) {\n            if (end < start) {\n                dist_backward = start - end;\n            } else {\n                // Need to go through the loop\n                dist_backward = start + 1 + (9 - 5) + 1 + (5 - end);\n            }\n        } else if (start <= 5 && end > 5) {\n            // From main line to loop through 0\n            dist_backward = start + 1 + (9 - end) + 1;\n        } else if (start > 5 && end <= 5) {\n            // From loop to main line\n            if (start == 6) dist_backward = 1 + (5 - end);\n            else if (start == 7) dist_backward = 2 + (5 - end);\n            else if (start == 8) dist_backward = 3 + (5 - end);\n            else if (start == 9) dist_backward = 4 + (5 - end);\n        } else {\n            // Both in loop\n            if (end < start) {\n                dist_backward = start - end;\n            } else {\n                dist_backward = (start - 5) + 1 + (9 - end) + 1;\n            }\n        }\n        \n        // Choose the shorter route\n        int go_forward = (dist_forward <= dist_backward);\n        \n        int pos = start;\n        printf(\"%d\", pos);\n        \n        while (pos != end) {\n            if (go_forward) {\n                if (pos < 5) {\n                    pos++;\n                } else if (pos == 5) {\n                    if (end > 5 || end == 0) {\n                        pos = 6;\n                    } else {\n                        pos--;\n                    }\n                } else if (pos >= 6 && pos <= 8) {\n                    pos++;\n                } else if (pos == 9) {\n                    pos = 5;\n                }\n            } else {\n                if (pos > 0 && pos <= 5) {\n                    pos--;\n                } else if (pos == 6) {\n                    pos = 5;\n                } else if (pos >= 7 && pos <= 9) {\n                    pos--;\n                } else if (pos == 0) {\n                    pos = 1;\n                }\n            }\n            printf(\" %d\", pos);\n        }\n        printf(\"\\n\");\n    }\n    \n    return 0;\n}\n", "perturbed_sampled": ["#include <stdio.h> int main() { int n; scanf(\"%d\",  start, end; scanf(\"%d %d\", &start, &end); // Calculate  { if (end   (9 - 5) + 1 + (5 - end); } } else if (start <= 5 && end >  dist_forward = (5 - start) +  5 && end <= 5) { // From loop to  dist_forward = 2 + end; else if (start == 7) dist_forward = 3 + end; else if (start  else {  (end >  - start; }  - start) + 1  } // Going backward (counter-clockwise) if  <=  start - end; } else { // Need to go through the loop dist_backward = start + 1 + (9 - 5) + 1 + (5 - end); } } else  to loop through 0 dist_backward     to main line if (start == 6) dist_backward = 1 +  = 2 + (5  == 8) dist_backward = 3 + (5 - end);  (5 - end);    { dist_backward = (start - 5) +  + 1; } } // Choose the shorter  <= dist_backward); int pos   else {  (pos >= 6  pos++;   if (pos >  { pos--;  6) {  if (pos >= 7 && pos <= 9)   }"], "perturbed_original": ["  printf(\"%d  for(j=from;j<=9;j++){  if(from>to){ if(from>=6&&from<=9){ for(j=from;j<=9;j++){  \",j); } printf(\"%d\\n\",to); }else{ for(j=from;j>to;j--){ printf(\"%d \",j); } printf(\"%d\\n\",to); } } } return 0; }"], "original_ll": -0.9631760716438293, "sampled_ll": -0.6340625286102295, "all_perturbed_sampled_ll": [-2.695021867752075], "all_perturbed_original_ll": [-2.3197150230407715], "perturbed_sampled_ll": -2.695021867752075, "perturbed_original_ll": -2.3197150230407715, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import java.io.*;\nimport java.util.*;\nimport java.math.*;\nclass Main{\n    public static void main(String[] args){\n\tBufferedReader sc=new BufferedReader(new InputStreamReader(System.in));\n\ttry {\n\t    int n = Integer.valueOf(sc.readLine());\n\t    ArrayList<Integer> road;\n\t    for(int i=0; i<n; i++){\n\t\troad = new ArrayList<Integer>();\n\t\tString[] st = sc.readLine().split(\" \");\n\t\tint in = Integer.valueOf(st[0]), out = Integer.valueOf(st[1]);\n\t\tif(in<=5)\n\t\t    if(in>out)\n\t\t\tfor(int j=in; j>=out; j--)\n\t\t\t    road.add(j);\n\t\t    else\n\t\t\tfor(int j=in; j<=out; j++)\n\t\t\t    road.add(j);\n\t\telse{\n\t\t    if(out>in)\n\t\t\tfor(int j=in; j<=out; j++)\n\t\t\t    road.add(j);\n\t\t    else{\n\t\t\tfor(int j=in; j<=9; j++)\n\t\t\t    road.add(j);\n\t\t\tif(out>=5){\n\t\t\t    for(int j=5; j>=0; j--)\n\t\t\t\troad.add(j);\n\t\t\t    for(int j=1; j<=out; j++)\n\t\t\t\troad.add(j);\n\t\t\t}\n\t\t\telse\n\t\t\t    for(int j=5; j>=out; j--)\n\t\t\t\troad.add(j);\n\t\t    }\n\t\t}\n\t\tfor(int j=0; j<road.size()-1; j++)\n\t\t    System.out.print(road.get(j)+\" \");\n\t\tSystem.out.println(road.get(road.size()-1));\n\t    }\n\t}catch(Exception e){\n\t    System.out.println(\"Error\");\n\t}\n    }\n}", "sampled": "import java.util.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int n = sc.nextInt();\n        \n        for (int i = 0; i < n; i++) {\n            int start = sc.nextInt();\n            int end = sc.nextInt();\n            \n            List<Integer> path = findPath(start, end);\n            \n            for (int j = 0; j < path.size(); j++) {\n                if (j > 0) System.out.print(\" \");\n                System.out.print(path.get(j));\n            }\n            System.out.println();\n        }\n        \n        sc.close();\n    }\n    \n    static List<Integer> findPath(int start, int end) {\n        List<Integer> path = new ArrayList<>();\n        \n        // Calculate distances for both directions\n        int dist1 = distanceClockwise(start, end);\n        int dist2 = distanceCounterClockwise(start, end);\n        \n        if (dist1 <= dist2) {\n            // Go clockwise\n            int current = start;\n            path.add(current);\n            while (current != end) {\n                current = next(current);\n                path.add(current);\n            }\n        } else {\n            // Go counterclockwise\n            int current = start;\n            path.add(current);\n            while (current != end) {\n                current = prev(current);\n                path.add(current);\n            }\n        }\n        \n        return path;\n    }\n    \n    static int distanceClockwise(int start, int end) {\n        int dist = 0;\n        int current = start;\n        while (current != end) {\n            current = next(current);\n            dist++;\n            if (dist > 20) return Integer.MAX_VALUE; // Safety check\n        }\n        return dist;\n    }\n    \n    static int distanceCounterClockwise(int start, int end) {\n        int dist = 0;\n        int current = start;\n        while (current != end) {\n            current = prev(current);\n            dist++;\n            if (dist > 20) return Integer.MAX_VALUE; // Safety check\n        }\n        return dist;\n    }\n    \n    static int next(int pos) {\n        if (pos >= 0 && pos < 5) {\n            return pos + 1;\n        } else if (pos == 5) {\n            return 6;\n        } else if (pos == 6) {\n            return 7;\n        } else if (pos == 7) {\n            return 8;\n        } else if (pos == 8) {\n            return 9;\n        } else if (pos == 9) {\n            return 5;\n        }\n        return -1;\n    }\n    \n    static int prev(int pos) {\n        if (pos >= 1 && pos <= 5) {\n            return pos - 1;\n        } else if (pos == 6) {\n            return 5;\n        } else if (pos == 7) {\n            return 6;\n        } else if (pos == 8) {\n            return 7;\n        } else if (pos == 9) {\n            return 8;\n        } else if (pos == 0) {\n            return -1; // Can't go back from 0\n        }\n        return -1;\n    }\n}\n", "perturbed_sampled": ["import java.util.*; public  void  = new Scanner(System.in); int n  n; i++) {   } System.out.println(); } sc.close(); } static List<Integer> findPath(int start, int end)   both directions   if (dist1 <= dist2) { // Go clockwise int current = start; path.add(current);  current = next(current); path.add(current); } } else  while  = prev(current); path.add(current);  int end)   } static int distanceCounterClockwise(int start, int end) { int dist =  while (current != end) { current = prev(current); dist++;  Integer.MAX_VALUE; // Safety check } return dist; } static int next(int pos) { if (pos >= 0 && pos < 5) { return pos + 1; } else if (pos   }   if (pos  } else if (pos == 9)  -1; }    pos - 1; }  else if (pos  ==  else if (pos   // Can't go back  } }"], "perturbed_original": ["import java.io.*; import java.util.*; import java.math.*; class  args){  Integer.valueOf(sc.readLine()); ArrayList<Integer> road;  st = sc.readLine().split(\" \"); int  Integer.valueOf(st[1]); if(in<=5)   for(int j=in; j<=out; j++)  j=5; j>=0; j--) road.add(j); for(int j=1; j<=out;  } } for(int  System.out.println(road.get(road.size()-1)); } }catch(Exception e){ System.out.println(\"Error\"); } } }"], "original_ll": -0.8656141757965088, "sampled_ll": -0.3843637704849243, "all_perturbed_sampled_ll": [-2.5462589263916016], "all_perturbed_original_ll": [-2.7413837909698486], "perturbed_sampled_ll": -2.5462589263916016, "perturbed_original_ll": -2.7413837909698486, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "for _ in [0]*input():\n  A = \"012345678954321\"\n  A += A\n  a, b = raw_input().split()\n  i1 = A.index(a)\n  i2 = A.index(a,i1+1)\n  i3 = A.index(b,i1)\n  if i2<i3: i1=i2\n  print \" \".join(A[i1:i3+1])", "sampled": "from collections import deque\n\ndef find_path(start, end):\n    # BFS to find shortest path\n    queue = deque([(start, [start])])\n    visited = {start}\n    \n    while queue:\n        current, path = queue.popleft()\n        \n        if current == end:\n            return path\n        \n        # Get neighbors based on bus route structure\n        neighbors = []\n        \n        if current == 0:\n            neighbors = [1]\n        elif current == 1:\n            neighbors = [0, 2]\n        elif current == 2:\n            neighbors = [1, 3]\n        elif current == 3:\n            neighbors = [2, 4]\n        elif current == 4:\n            neighbors = [3, 5]\n        elif current == 5:\n            neighbors = [4, 6, 9]\n        elif current == 6:\n            neighbors = [5, 7]\n        elif current == 7:\n            neighbors = [6, 8]\n        elif current == 8:\n            neighbors = [7, 9]\n        elif current == 9:\n            neighbors = [8, 5]\n        \n        for neighbor in neighbors:\n            if neighbor not in visited:\n                visited.add(neighbor)\n                queue.append((neighbor, path + [neighbor]))\n    \n    return []\n\nn = int(input())\nfor _ in range(n):\n    start, end = map(int, input().split())\n    path = find_path(start, end)\n    print(' '.join(map(str, path)))\n", "perturbed_sampled": ["from  end): # BFS to  deque([(start, [start])]) visited = {start} while queue: current,  neighbors = [] if current == 0: neighbors  2]   == 3: neighbors = [2, 4]  neighbors = [5, 7] elif current ==  elif current == 8: neighbors = [7, 9] elif current  in visited: visited.add(neighbor) queue.append((neighbor, path +   start,  = find_path(start, end) print(' '.join(map(str, path)))"], "perturbed_original": ["for  \"012345678954321\"  = raw_input().split() i1 =  i1=i2 print \" \".join(A[i1:i3+1])"], "original_ll": -1.6256858110427856, "sampled_ll": -0.483831524848938, "all_perturbed_sampled_ll": [-2.8811206817626953], "all_perturbed_original_ll": [-3.2294085025787354], "perturbed_sampled_ll": -2.8811206817626953, "perturbed_original_ll": -3.2294085025787354, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "// Aizu Vol-1 0141:   Spiral Pattern\n// 2017.8.4\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nchar *gets(char *);\nchar buf[100];\n\nchar a[105][105];\n#define U 1\n#define R 2\n#define D 3\n#define L 4\n\nint main()\n{\n\tint r, c, n, d, stop;\n\tint ci, cn;\n\n\tgets(buf);\n\tcn = atoi(buf);\n\tfor (ci = 0; ci < cn; ci++) {\n\t\tgets(buf);\n\t\tn = atoi(buf);\n\t\tmemset(a, ' ', sizeof(a));\n\t\tfor (r = 0; r < n + 4; r += n + 3) {\n\t\t\tfor (c = 0; c < n + 4; c++) a[r][c] = '#';\n\t\t}\n\t\tfor (c = 0; c < n + 4; c += n + 3) {\n\t\t\tfor (r = 0; r < n + 4; r++) a[r][c] = '#';\n\t\t}\n\t\tr = n + 1, c = 2, d = U, stop = 0, a[r][c] = '#';\n\t\twhile (1) {\n\t\t\tif (stop >= 4) break;\n\t\t\tif (d == U) {\n\t\t\t\tif (a[r-2][c] == '#' || a[r-1][c] == '#' || a[r-1][c+1] == '#') d = R, stop++;\n\t\t\t\telse a[--r][c] = '#', stop = 0;\n\t\t\t}\n\t\t\tif (d == R) {\n\t\t\t\tif (a[r][c+2] == '#' || a[r][c+1] == '#' || a[r+1][c+1] == '#') d = D, stop++;\n\t\t\t\telse a[r][++c] = '#', stop = 0;\n\t\t\t}\n\t\t\tif (d == D) {\n\t\t\t\tif (a[r+2][c] == '#' || a[r+1][c] == '#' || a[r+1][c-1] == '#') d = L, stop++;\n\t\t\t\telse a[++r][c] = '#', stop = 0;\n\t\t\t}\n\t\t\tif (d == L){\n\t\t\t\tif (a[r][c-2] == '#' || a[r][c-1] == '#' || a[r-1][c-1] == '#') d = U, stop++;\n\t\t\t\telse a[r][--c] = '#', stop = 0;\n\t\t\t}\n\t\t}\n\t\tif (ci > 0) putchar('\\n');\n\t\tfor (r = 2; r < n + 2; r++) {\n\t\t\ta[r][n + 2] = 0;\n\t\t\tputs(a[r]+2);\n\t\t}\n\t}\n\treturn 0;\n}", "sampled": "#include <stdio.h>\n#include <string.h>\n\nint main() {\n    int d, n;\n    scanf(\"%d\", &d);\n    \n    for (int dataset = 0; dataset < d; dataset++) {\n        scanf(\"%d\", &n);\n        \n        char grid[100][100];\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < n; j++) {\n                grid[i][j] = ' ';\n            }\n        }\n        \n        int minRow = 0, maxRow = n - 1;\n        int minCol = 0, maxCol = n - 1;\n        \n        while (minRow <= maxRow && minCol <= maxCol) {\n            // Bottom row (left to right)\n            for (int j = minCol; j <= maxCol; j++) {\n                grid[maxRow][j] = '#';\n            }\n            \n            // Right column (bottom to top)\n            for (int i = maxRow; i >= minRow; i--) {\n                grid[i][maxCol] = '#';\n            }\n            \n            // Top row (right to left)\n            if (minRow < maxRow) {\n                for (int j = maxCol; j >= minCol; j--) {\n                    grid[minRow][j] = '#';\n                }\n            }\n            \n            // Left column (top to bottom)\n            if (minCol < maxCol) {\n                for (int i = minRow; i <= maxRow; i++) {\n                    grid[i][minCol] = '#';\n                }\n            }\n            \n            minRow += 2;\n            maxRow -= 2;\n            minCol += 2;\n            maxCol -= 2;\n        }\n        \n        // Print grid\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < n; j++) {\n                printf(\"%c\", grid[i][j]);\n            }\n            printf(\"\\n\");\n        }\n        \n        if (dataset < d - 1) {\n            printf(\"\\n\");\n        }\n    }\n    \n    return 0;\n}\n", "perturbed_sampled": [" main() { int d, n;  =  { scanf(\"%d\", &n); char grid[100][100]; for  for (int j = 0;    0, maxCol =  Bottom row (left to   } //  for (int  minRow; i--)   maxRow) { for (int j = maxCol; j >= minCol; j--) { grid[minRow][j] =  column (top to bottom) if  (int i = minRow; i    i = 0; i < n; i++) { for (int j = 0; j  if (dataset < d - 1) { printf(\"\\n\"); } } return 0; }"], "perturbed_original": ["// Aizu Vol-1 0141: Spiral  #include <stdlib.h>  char buf[100]; char a[105][105]; #define U 1 #define R 2 #define D  main() {  stop; int ci, cn; gets(buf); cn = atoi(buf); for (ci  = atoi(buf); memset(a, ' ', sizeof(a));   0;  c++)  (c = 0; c < n + 4; c += n + 3) { for (r = 0; r < n + 4; r++) a[r][c] =    (stop >=  U) { if (a[r-2][c] ==  else  (a[r][c+2] ==   =   if (d ==    = L,  stop = 0; } if  == '#' || a[r-1][c-1] == '#') d = U, stop++;  = 0; }   2; r++) {   }"], "original_ll": -0.8177950382232666, "sampled_ll": -0.37082165479660034, "all_perturbed_sampled_ll": [-2.460537910461426], "all_perturbed_original_ll": [-2.8395063877105713], "perturbed_sampled_ll": -2.460537910461426, "perturbed_original_ll": -2.8395063877105713, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import java.util.Arrays;\nimport java.util.Scanner;\n\npublic class Main {\n\tMyScanner sc = new MyScanner();\n\tScanner sc2 = new Scanner(System.in);\n\tint mod = 1000000007;\n\tint[] dx = { 1, 0, 0, -1 };\n\tint[] dy = { 0, 1, -1, 0 };\n\n\tvoid run() {\n\t\tint D = sc.nextInt();\n\t\tboolean first = true;\n\t\twhile (D-- > 0) {\n\t\t\tif (!first) {\n\t\t\t\tSystem.out.println();\n\t\t\t\tfirst = false;\n\t\t\t}\n\t\t\tint n = sc.nextInt();\n\t\t\tchar[][] field = new char[n][n];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tArrays.fill(field[i], ' ');\n\t\t\t}\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tfield[i][0] = '#';\n\t\t\t\tfield[0][i] = '#';\n\t\t\t}\n\t\t\tif (n < 3) {\n\t\t\t\tdebug2(field);\n\t\t\t} else if (n == 3) {\n\t\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\t\tfield[i][n - 1] = '#';\n\t\t\t\t}\n\t\t\t\tdebug2(field);\n\t\t\t} else {\n\t\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\t\tfield[i][n - 1] = '#';\n\t\t\t\t}\n\t\t\t\tint nowX = n - 1;\n\t\t\t\tint nowY = n - 1;\n\t\t\t\tboolean go = true;\n\t\t\t\twhile (go) {\n\t\t\t\t\tgo = false;\n\t\t\t\t\twhile (nowX - 2 >= 0 && field[nowY - 1][nowX - 1] != '#'\n\t\t\t\t\t\t\t&& field[nowY][nowX - 2] != '#' && field[nowY][nowX-1] != '#') {\n\t\t\t\t\t\tfield[nowY][--nowX] = '#';\n\t\t\t\t\t\tgo = true;\n\t\t\t\t\t}\n\t\t\t\t\twhile (nowY - 2 >= 0 && field[nowY - 1][nowX + 1] != '#'\n\t\t\t\t\t\t\t&& field[nowY - 2][nowX] != '#' && field[nowY-1][nowX] != '#') {\n\t\t\t\t\t\tfield[--nowY][nowX] = '#';\n\t\t\t\t\t\tgo = true;\n\t\t\t\t\t}\n\t\t\t\t\twhile (nowX + 2 < n && field[nowY + 1][nowX + 1] != '#'\n\t\t\t\t\t\t\t&& field[nowY][nowX + 2] != '#' ) {\n\t\t\t\t\t\tfield[nowY][++nowX] = '#';\n\t\t\t\t\t\tgo = true;\n\t\t\t\t\t}\n\t\t\t\t\twhile (nowY + 2 < n && field[nowY + 1][nowX - 1] != '#'\n\t\t\t\t\t\t\t&& field[nowY + 2][nowX] != '#' ) {\n\t\t\t\t\t\tfield[++nowY][nowX] = '#';\n\t\t\t\t\t\tgo = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tdebug2(field);\n\t\t\t}\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n\n\tvoid debug(Object... o) {\n\t\tSystem.out.println(Arrays.deepToString(o));\n\t}\n\n\tvoid debug2(char[][] array) {\n\t\tfor (int i = 0; i < array.length; i++) {\n\t\t\tfor (int j = 0; j < array[i].length; j++) {\n\t\t\t\tSystem.out.print(array[i][j]);\n\t\t\t}\n\t\t\tSystem.out.println();\n\t\t}\n\t}\n\n\tclass MyScanner {\n\t\tint nextInt() {\n\t\t\ttry {\n\t\t\t\tint c = System.in.read();\n\t\t\t\twhile (c != '-' && (c < '0' || '9' < c))\n\t\t\t\t\tc = System.in.read();\n\t\t\t\tif (c == '-')\n\t\t\t\t\treturn -nextInt();\n\t\t\t\tint res = 0;\n\t\t\t\tdo {\n\t\t\t\t\tres *= 10;\n\t\t\t\t\tres += c - '0';\n\t\t\t\t\tc = System.in.read();\n\t\t\t\t} while ('0' <= c && c <= '9');\n\t\t\t\treturn res;\n\t\t\t} catch (Exception e) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\n\t\tdouble nextDouble() {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\n\t\tString next() {\n\t\t\ttry {\n\t\t\t\tStringBuilder res = new StringBuilder(\"\");\n\t\t\t\tint c = System.in.read();\n\t\t\t\twhile (Character.isWhitespace(c))\n\t\t\t\t\tc = System.in.read();\n\t\t\t\tdo {\n\t\t\t\t\tres.append((char) c);\n\t\t\t\t} while (!Character.isWhitespace(c = System.in.read()));\n\t\t\t\treturn res.toString();\n\t\t\t} catch (Exception e) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t}\n\t}\n}", "sampled": "import java.util.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int d = sc.nextInt();\n        \n        for (int dataset = 0; dataset < d; dataset++) {\n            int n = sc.nextInt();\n            char[][] grid = new char[n][n];\n            \n            for (int i = 0; i < n; i++) {\n                for (int j = 0; j < n; j++) {\n                    grid[i][j] = ' ';\n                }\n            }\n            \n            int row = n - 1;\n            int col = 0;\n            int dir = 0; // 0: right, 1: up, 2: left, 3: down\n            int[] dr = {0, -1, 0, 1};\n            int[] dc = {1, 0, -1, 0};\n            \n            int steps = n;\n            int currentSteps = 0;\n            int dirChanges = 0;\n            boolean placed = false;\n            \n            while (steps > 0) {\n                for (int i = 0; i < steps; i++) {\n                    if (row >= 0 && row < n && col >= 0 && col < n) {\n                        grid[row][col] = '#';\n                    }\n                    if (i < steps - 1) {\n                        row += dr[dir];\n                        col += dc[dir];\n                    }\n                }\n                \n                row += dr[dir];\n                col += dc[dir];\n                \n                dir = (dir + 1) % 4;\n                dirChanges++;\n                \n                if (dirChanges % 2 == 0) {\n                    steps--;\n                }\n            }\n            \n            for (int i = 0; i < n; i++) {\n                System.out.println(new String(grid[i]));\n            }\n            \n            if (dataset < d - 1) {\n                System.out.println();\n            }\n        }\n        \n        sc.close();\n    }\n}\n", "perturbed_sampled": ["import java.util.*; public class Main { public static void main(String[] args)  Scanner(System.in); int d  = 0; dataset  n = sc.nextInt();   dir = 0; // 0: right, 1: up, 2:  = {0, -1, 0,  0, -1, 0}; int steps  0; boolean placed  0) {   && col >= 0 && col < n)  if (i < steps - 1) { row  } } row +=  = (dir + 1) %  2 == 0)  i < n; i++) { System.out.println(new  d -  sc.close(); } }"], "perturbed_original": ["import java.util.Arrays; import  MyScanner sc = new  Scanner(System.in); int mod =  }; int[] dy = {  if (!first) { System.out.println(); first = false; } int n = sc.nextInt();  '); } for (int  n; i++) { field[i][0] = '#'; field[0][i]   else   { field[i][n -   i  i++)   true; while (go)  (nowX - 2 >= 0 &&  && field[nowY][nowX-1]   while (nowY -  -  && field[nowY - 2][nowX] !=  { field[--nowY][nowX] = '#'; go =  2  1][nowX + 1] != '#' &&  ) {  &&  + 2][nowX] != '#' )  =  void main(String[] args) { new Main().run();   array.length; i++) { for (int j = 0;   class MyScanner { int nextInt() { try   '9' <  (c == '-') return -nextInt(); int res = 0; do { res *= 10; res  = System.in.read(); } while  <= '9'); return res; }  -1;  return Double.parseDouble(next()); } String next() { try { StringBuilder res = new StringBuilder(\"\"); int c = System.in.read();   while (!Character.isWhitespace(c = System.in.read())); return res.toString(); } catch (Exception e) {  }"], "original_ll": -0.5349701046943665, "sampled_ll": -0.5847939848899841, "all_perturbed_sampled_ll": [-2.809906005859375], "all_perturbed_original_ll": [-2.595580577850342], "perturbed_sampled_ll": -2.809906005859375, "perturbed_original_ll": -2.595580577850342, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "class Vector:\n\n    def __init__(self, x, y):\n        self.x = x\n        self.y = y\n\n    def move(self, offset):\n        self.x += offset[0]\n        self.y += offset[1]\n\n    def move_offset(self, offset, multiple=1):\n        x = self.x + offset[0] * multiple\n        y = self.y + offset[1] * multiple\n        return Vector(x, y)\n\n\nclass Pattern:\n    NOTHING = \" \"\n    EXIST = \"#\"\n    SENTINEL = \"?\"\n\n    MOVE = [\n        [[-1, -1], [-1, +0], [-1, +1]],\n        [[-1, +1], [-0, +1], [+1, +1]],\n        [[+1, +1], [+1, +0], [+1, -1]],\n        [[+1, -1], [+0, -1], [-1, -1]],\n    ]\n\n    @classmethod\n    def create_area(cls, size):\n        area = [[cls.SENTINEL] * 2 + [cls.NOTHING] * size + [cls.SENTINEL] * 2 for _ in range(size)]\n        tmp = [[cls.SENTINEL] * size + [cls.SENTINEL] * 2 * 2]\n        area = tmp * 2 + area + tmp * 2\n        return area\n\n    @classmethod\n    def even_spiral_pattern(cls, area, point):\n        move_index = 0\n        area[point.x][point.y] = cls.EXIST\n\n        while True:\n\n            left, center, right = cls.MOVE[move_index]\n            end1, end2 = point.move_offset(left), point.move_offset(right)\n            offset, offset2 = point.move_offset(center), point.move_offset(center, 2)\n\n            if area[end1.x][end1.y] == cls.EXIST or area[end2.x][end2.y] == cls.EXIST:\n                return area\n            elif area[offset.x][offset.y] == cls.NOTHING and area[offset2.x][offset2.y] != cls.EXIST:\n                point.move(center)\n                area[point.x][point.y] = cls.EXIST\n            else:\n                move_index += 1\n                move_index %= 4\n\n    @classmethod\n    def odd_spiral_pattern(cls, area, point):\n        move_index = 0\n        is_end = False\n        area[point.x][point.y] = cls.EXIST\n\n        while True:\n\n            left, center, right = cls.MOVE[move_index]\n            offset, offset2 = point.move_offset(center), point.move_offset(center, 2)\n\n            if area[offset.x][offset.y] == cls.NOTHING and area[offset2.x][offset2.y] != cls.EXIST:\n                point.move(center)\n                area[point.x][point.y] = cls.EXIST\n                is_end = False\n            else:\n                if is_end:\n                    return area\n                else:\n                    is_end = True\n\n                move_index += 1\n                move_index %= 4\n\n    @classmethod\n    def formater(cls, area):\n        output = [\"\".join(item[2:-2]) for item in area[2:-2]]\n        output = \"\\n\".join(output)\n        return output\n\n    @classmethod\n    def solve(cls, size):\n        area = cls.create_area(size)\n        point = Vector(size - 1 + 2, 2)\n\n        if size % 2 == 0:\n            result = cls.even_spiral_pattern(area, point)\n        else:\n            result = cls.odd_spiral_pattern(area, point)\n\n        return cls.formater(result)\n\n\nsizes = [int(input()) for _ in range(int(input()))]\nresults = [Pattern.solve(num) for num in sizes]\nprint(\"\\n\\n\".join(results))\n\n", "sampled": "def generate_spiral(n):\n    grid = [[' ' for _ in range(n)] for _ in range(n)]\n    \n    # Start from bottom-left, go clockwise\n    row, col = n - 1, 0\n    dr, dc = 0, 1  # Start moving right\n    \n    visited = set()\n    visited.add((row, col))\n    grid[row][col] = '#'\n    \n    while True:\n        # Try to move in current direction\n        next_row, next_col = row + dr, col + dc\n        \n        # Check if we can continue in current direction\n        can_continue = (0 <= next_row < n and \n                       0 <= next_col < n and \n                       (next_row, next_col) not in visited)\n        \n        if can_continue:\n            row, col = next_row, next_col\n            visited.add((row, col))\n            grid[row][col] = '#'\n        else:\n            # Try to turn clockwise\n            # Clockwise from bottom-left: right(0,1) -> up(-1,0) -> left(0,-1) -> down(1,0)\n            if (dr, dc) == (0, 1):  # right -> up\n                dr, dc = -1, 0\n            elif (dr, dc) == (-1, 0):  # up -> left\n                dr, dc = 0, -1\n            elif (dr, dc) == (0, -1):  # left -> down\n                dr, dc = 1, 0\n            elif (dr, dc) == (1, 0):  # down -> right\n                dr, dc = 0, 1\n            \n            next_row, next_col = row + dr, col + dc\n            \n            # Check if we can move after turning\n            if (0 <= next_row < n and \n                0 <= next_col < n and \n                (next_row, next_col) not in visited):\n                row, col = next_row, next_col\n                visited.add((row, col))\n                grid[row][col] = '#'\n            else:\n                # Can't move anywhere, done\n                break\n    \n    return grid\n\nd = int(input())\nresults = []\n\nfor i in range(d):\n    n = int(input())\n    grid = generate_spiral(n)\n    results.append(grid)\n\nfor i, grid in enumerate(results):\n    for row in grid:\n        print(''.join(row))\n    if i < len(results) - 1:\n        print()\n", "perturbed_sampled": [" ' for _ in   clockwise  1,  '#'  next_row, next_col = row + dr, col + dc # Check if we can continue in current direction   (next_row, next_col) not in visited) if can_continue: row, col   # Clockwise  -> left(0,-1)   = -1, 0 elif (dr, dc)  -> left dr, dc =  ==  # down -> right dr, dc = 0, 1 next_row, next_col = row + dr, col +  if (0  0 <= next_col <   grid[row][col] = '#' else: # Can't move anywhere, done break return grid d = int(input()) results =  n   < len(results) - 1: print()"], "perturbed_original": [" y): self.x =  move(self, offset): self.x  def move_offset(self, offset, multiple=1): x = self.x + offset[0]  + offset[1] *  \" EXIST = \"#\"  [ [[-1, -1], [-1, +0], [-1, +1]], [[-1, +1], [-0, +1], [+1, +1]], [[+1, +1], [+1, +0],   def create_area(cls, size): area = [[cls.SENTINEL] * 2 + [cls.NOTHING] * size + [cls.SENTINEL] * 2 for  [[cls.SENTINEL] * size +     end1, end2  if  == cls.EXIST: return   move_index += 1 move_index  area, point): move_index = 0 is_end   if area[offset.x][offset.y] == cls.NOTHING and   True move_index  output = [\"\".join(item[2:-2]) for item in area[2:-2]]  = Vector(size -  0: result = cls.even_spiral_pattern(area, point) else: result = cls.odd_spiral_pattern(area, point) return cls.formater(result) sizes  range(int(input()))] results =  print(\"\\n\\n\".join(results))"], "original_ll": -0.8351041674613953, "sampled_ll": -0.6593042612075806, "all_perturbed_sampled_ll": [-3.294650077819824], "all_perturbed_original_ll": [-2.8178272247314453], "perturbed_sampled_ll": -3.294650077819824, "perturbed_original_ll": -2.8178272247314453, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "#include <stdio.h>\n#include <string.h>\nint main(){\n  int exp[10001], n, i, j, mod[10001], a[10001], c, count[6000], h, d;\n\n  for(i = 1; i < 10001; ++i) exp[i] = i * i;\n\n  while(scanf(\"%d\", &n) && n){\n    memset(count , 0, sizeof(count));\n    for(i = 1; i < n; ++i) mod[i] = exp[i] % n;\n    c = 0;\n    for(i = 1; i < n; ++i){\n      for(j = 0; j < c; ++j)\n\tif(mod[i] == a[j]) break;\n      if(j == c) a[c++] = mod[i];\n    }\n    h = (n - 1) / 2;\n    for(i = 0; i < c; ++i){\n      for(j = 0; j < c; ++j){\n\tif(a[i] != a[j]){\n\t  d = a[i] - a[j];\n\t  if(d < 0) d += n;\n\t  if(d > h) d = n - d;\n\t  count[d]++;\n\t}\n      }\n    }\n\n    for(i = 1; i <= h; ++i) printf(\"%d\\n\", count[i]);  \n  }\n  return 0;\n}", "sampled": "#include <stdio.h>\n#include <stdlib.h>\n\nint main() {\n    int n;\n    \n    while(1) {\n        scanf(\"%d\", &n);\n        if(n == 0) break;\n        \n        int *squares = (int*)malloc(n * sizeof(int));\n        int unique_count = 0;\n        int *unique_squares = (int*)malloc(n * sizeof(int));\n        \n        // Calculate squares mod n\n        for(int i = 1; i < n; i++) {\n            squares[i] = (i * i) % n;\n        }\n        \n        // Find unique squares\n        for(int i = 1; i < n; i++) {\n            int found = 0;\n            for(int j = 0; j < unique_count; j++) {\n                if(unique_squares[j] == squares[i]) {\n                    found = 1;\n                    break;\n                }\n            }\n            if(!found) {\n                unique_squares[unique_count++] = squares[i];\n            }\n        }\n        \n        int max_diff = (n - 1) / 2;\n        int *count = (int*)calloc(max_diff + 1, sizeof(int));\n        \n        // Calculate differences\n        for(int i = 0; i < unique_count; i++) {\n            for(int j = 0; j < unique_count; j++) {\n                if(i != j) {\n                    int a = unique_squares[i];\n                    int b = unique_squares[j];\n                    int diff = a - b;\n                    \n                    // If negative, add n\n                    if(diff < 0) {\n                        diff += n;\n                    }\n                    \n                    // If greater than (n-1)/2, subtract from n\n                    if(diff > max_diff) {\n                        diff = n - diff;\n                    }\n                    \n                    if(diff >= 1 && diff <= max_diff) {\n                        count[diff]++;\n                    }\n                }\n            }\n        }\n        \n        // Output counts\n        for(int i = 1; i <= max_diff; i++) {\n            printf(\"%d\\n\", count[i]);\n        }\n        \n        free(squares);\n        free(unique_squares);\n        free(count);\n    }\n    \n    return 0;\n}\n", "perturbed_sampled": ["#include <stdio.h> #include <stdlib.h>  while(1) {  (int*)malloc(n * sizeof(int)); int unique_count = 0; int *unique_squares =  squares mod   squares[i] = (i *   =  0;  (n - 1) / 2; int *count = (int*)calloc(max_diff + 1, sizeof(int)); // Calculate differences for(int i = 0; i < unique_count; i++) { for(int j = 0; j < unique_count; j++) { if(i != j) { int a = unique_squares[i]; int b = unique_squares[j]; int diff =  negative, add n if(diff    }  for(int  count[i]); }  0; }"], "perturbed_original": ["#include <stdio.h> #include <string.h> int main(){ int exp[10001], n, i, j, mod[10001],  for(i = 1;  = i * i; while(scanf(\"%d\", &n)   c  i < n; ++i){ for(j  h = (n - 1) / 2; for(i = 0; i < c;   a[j]){ d = a[i] - a[j];  d = n -  }"], "original_ll": -0.9079139232635498, "sampled_ll": -0.5551327466964722, "all_perturbed_sampled_ll": [-2.4112484455108643], "all_perturbed_original_ll": [-2.6020307540893555], "perturbed_sampled_ll": -2.4112484455108643, "perturbed_original_ll": -2.6020307540893555, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import java.util.*;\nimport java.lang.*;\nimport java.math.*;\nimport java.io.*;\n\nimport static java.lang.Math.*;\nimport static java.util.Arrays.*;\n\npublic class Main{\n\n\tScanner sc=new Scanner(System.in);\n\n\tint INF=1<<28;\n\tdouble EPS=1e-9;\n\n\tint n;\n\n\tvoid run(){\n\t\tfor(;;){\n\t\t\tn=sc.nextInt();\n\t\t\tif(n==0){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tsolve();\n\t\t}\n\t\tSystem.out.flush();\n\t}\n\n\tvoid solve(){\n\t\tTreeSet<Integer> set=new TreeSet<Integer>();\n\t\tfor(int i=1; i<n; i++){\n\t\t\tset.add(i*i%n);\n\t\t}\n\t\tint[] c=new int[n];\n\t\tfor(int j : set){\n\t\t\tfor(int i : set){\n\t\t\t\tif(i!=j){\n\t\t\t\t\tint a=i-j;\n\t\t\t\t\tif(a<0){\n\t\t\t\t\t\ta+=n;\n\t\t\t\t\t}\n\t\t\t\t\tif(a>(n-1)/2){\n\t\t\t\t\t\ta=n-a;\n\t\t\t\t\t}\n\t\t\t\t\tc[a]++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t// debug(set.toArray());\n\t\t// debug(c);\n\t\tfor(int i=1; i<=(n-1)/2; i++){\n\t\t\tprintln(\"\"+c[i]);\n\t\t}\n\t}\n\n\tvoid debug(Object... os){\n\t\tSystem.err.println(Arrays.deepToString(os));\n\t}\n\n\tvoid print(String s){\n\t\tSystem.out.print(s);\n\t}\n\n\tvoid println(String s){\n\t\tSystem.out.println(s);\n\t}\n\n\tpublic static void main(String[] args){\n\t\tSystem.setOut(new PrintStream(new BufferedOutputStream(System.out)));\n\t\tnew Main().run();\n\t}\n}", "sampled": "import java.util.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        \n        while (true) {\n            int n = sc.nextInt();\n            if (n == 0) break;\n            \n            // Step 1: Calculate squares mod n\n            Set<Integer> squares = new HashSet<>();\n            for (int i = 1; i < n; i++) {\n                int sq = (i * i) % n;\n                squares.add(sq);\n            }\n            \n            // Step 2: Calculate differences between all pairs\n            List<Integer> squareList = new ArrayList<>(squares);\n            int maxDiff = (n - 1) / 2;\n            int[] frequency = new int[maxDiff + 1];\n            \n            for (int i = 0; i < squareList.size(); i++) {\n                for (int j = i + 1; j < squareList.size(); j++) {\n                    int a = squareList.get(i);\n                    int b = squareList.get(j);\n                    \n                    // Calculate difference\n                    int diff = a - b;\n                    \n                    // If negative, add n\n                    if (diff < 0) {\n                        diff += n;\n                    }\n                    \n                    // If greater than (n-1)/2, subtract from n\n                    if (diff > maxDiff) {\n                        diff = n - diff;\n                    }\n                    \n                    frequency[diff]++;\n                }\n            }\n            \n            // Step 3: Output frequencies for 1 to (n-1)/2\n            for (int i = 1; i <= maxDiff; i++) {\n                System.out.println(frequency[i]);\n            }\n        }\n        \n        sc.close();\n    }\n}\n", "perturbed_sampled": [" n = sc.nextInt();  // Step 1: Calculate squares mod n Set<Integer> squares = new HashSet<>(); for (int i = 1; i < n; i++) { int sq = (i *  // Step 2: Calculate differences between all   int[maxDiff + 1]; for (int i = 0; i < squareList.size();   diff = a - b; // If negative, add n if (diff < 0) { diff  } frequency[diff]++;  to (n-1)/2 for (int i  i++)  } }"], "perturbed_original": ["import java.util.*;  java.io.*;  java.util.Arrays.*; public class Main{ Scanner sc=new Scanner(System.in); int INF=1<<28; double EPS=1e-9; int  if(n==0){ break; }   i=1;  c=new int[n]; for(int j : set){ for(int i  a=n-a; }  } }   void println(String   BufferedOutputStream(System.out))); new Main().run(); } }"], "original_ll": -1.0591042041778564, "sampled_ll": -0.6555579900741577, "all_perturbed_sampled_ll": [-2.7834298610687256], "all_perturbed_original_ll": [-3.1023154258728027], "perturbed_sampled_ll": -2.7834298610687256, "perturbed_original_ll": -3.1023154258728027, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import itertools\n\nr = 10001\ns = int(r**0.5)\np = [1]*r\np[0] = 0\nfor i in range(1,s):\n\tif p[i]:\n\t\tp[2*i + 1::i + 1] = [0 for x in range(2*i + 1, r, i + 1)]\n\nwhile 1:\n\tn = input()\n\tif n == 0: break\n\tm = (n - 1) / 2\n\ta = sorted(list(set([i**2%n for i in range(1,n)])))\n\tl = len(a)\n\tif n%4 == 3 and p[n - 1] == 1:\n\t\tll = l*(l - 1) / m\n\t\tfor i in range(m):\n\t\t\tprint ll\n\t\tcontinue\n\th = [0]*(m+1)\n\tfor i,j in itertools.combinations(a,2):\n\t\td = j - i\n\t\th[min(d,n - d)] += 2\n\tfor i in range(1,m+1):\n\t\tprint h[i]", "sampled": "def solve(n):\n    # Calculate squares mod n\n    squares = set()\n    for i in range(1, n):\n        squares.add((i * i) % n)\n    \n    squares = list(squares)\n    \n    # Calculate differences\n    max_diff = (n - 1) // 2\n    diff_count = [0] * (max_diff + 1)\n    \n    for i in range(len(squares)):\n        for j in range(i + 1, len(squares)):\n            a = squares[i]\n            b = squares[j]\n            \n            # Calculate difference\n            diff = a - b\n            if diff < 0:\n                diff += n\n            if diff > max_diff:\n                diff = n - diff\n            \n            diff_count[diff] += 1\n    \n    # Output frequencies for 1 to max_diff\n    for i in range(1, max_diff + 1):\n        print(diff_count[i])\n\nwhile True:\n    n = int(input())\n    if n == 0:\n        break\n    solve(n)\n", "perturbed_sampled": ["def solve(n): #  in  %  Calculate differences  // 2 diff_count = [0] * (max_diff  range(len(squares)): for  len(squares)): a = squares[i]  difference diff = a - b   max_diff: diff  max_diff  + 1): print(diff_count[i]) while True: n  0: break solve(n)"], "perturbed_original": ["import itertools r = 10001 s = int(r**0.5) p = [1]*r p[0]  + 1::i + 1] =  + 1)] while 1: n = input() if n ==  i in range(1,n)])))   1]  print ll continue h = [0]*(m+1)  h[min(d,n - d)] += 2  h[i]"], "original_ll": -1.4017674922943115, "sampled_ll": -0.7774476408958435, "all_perturbed_sampled_ll": [-3.7896225452423096], "all_perturbed_original_ll": [-3.257732391357422], "perturbed_sampled_ll": -3.7896225452423096, "perturbed_original_ll": -3.257732391357422, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "// Aizu Vol-2 0143   Altair and Vega\n// 2017.8.8\n\n#include <stdio.h>\n\nint atSameSide(int x1, int y1, int x2, int y2, int xa, int ya, int xb, int yb)\n{\n\tint sa, sb;\n\n\tsa = (x2 - x1) * (ya - y1) + (y2 - y1) * (x1 - xa);\n\tsb = (x2 - x1) * (yb - y1) + (y2 - y1) * (x1 - xb);\n//\tif (sb == 0) return 0;  \t\t // xb,yb in line\n\treturn (sa * sb >= 0);           // xa,ya xb,yb at same side\n}\n\nint main()\n{\n\tint n;\n\tint x1, y1, x2, y2, x3, y3, xk, yk, xs, ys;\n\tint kin, sin;\n\n\tscanf(\"%d\", &n);\n\twhile (n-- > 0) {\n\t\tscanf(\"%d%d%d%d%d%d%d%d%d%d\", &x1, &y1, &x2, &y2, &x3, &y3, &xk, &yk, &xs, &ys);\n\t\tkin = atSameSide(x1, y1, x2, y2, x3, y3, xk, yk) &&\n\t\t\t  atSameSide(x2, y2, x3, y3, x1, y1, xk, yk) &&\n\t\t\t  atSameSide(x3, y3, x1, y1, x2, y2, xk, yk);\n\t\tsin = atSameSide(x1, y1, x2, y2, x3, y3, xs, ys) &&\n\t\t  \t  atSameSide(x2, y2, x3, y3, x1, y1, xs, ys) &&\n\t\t\t  atSameSide(x3, y3, x1, y1, x2, y2, xs, ys);\n\t\tputs(kin ^ sin ? \"OK\" : \"NG\");\n\t}\n\treturn 0;\n}", "sampled": "#include <stdio.h>\n\nint sign(double x) {\n    if (x > 0) return 1;\n    if (x < 0) return -1;\n    return 0;\n}\n\ndouble cross_product(double x1, double y1, double x2, double y2, double x3, double y3) {\n    return (x2 - x1) * (y3 - y1) - (y2 - y1) * (x3 - x1);\n}\n\nint point_in_triangle(double px, double py, double x1, double y1, double x2, double y2, double x3, double y3) {\n    double d1 = cross_product(x1, y1, x2, y2, px, py);\n    double d2 = cross_product(x2, y2, x3, y3, px, py);\n    double d3 = cross_product(x3, y3, x1, y1, px, py);\n    \n    int s1 = sign(d1);\n    int s2 = sign(d2);\n    int s3 = sign(d3);\n    \n    int has_neg = (s1 < 0) || (s2 < 0) || (s3 < 0);\n    int has_pos = (s1 > 0) || (s2 > 0) || (s3 > 0);\n    \n    return !(has_neg && has_pos);\n}\n\nint main() {\n    int n;\n    scanf(\"%d\", &n);\n    \n    for (int i = 0; i < n; i++) {\n        double xp1, yp1, xp2, yp2, xp3, yp3, xk, yk, xs, ys;\n        scanf(\"%lf %lf %lf %lf %lf %lf %lf %lf %lf %lf\",\n              &xp1, &yp1, &xp2, &yp2, &xp3, &yp3, &xk, &yk, &xs, &ys);\n        \n        int k_inside = point_in_triangle(xk, yk, xp1, yp1, xp2, yp2, xp3, yp3);\n        int s_inside = point_in_triangle(xs, ys, xp1, yp1, xp2, yp2, xp3, yp3);\n        \n        if (k_inside != s_inside) {\n            printf(\"OK\\n\");\n        } else {\n            printf(\"NG\\n\");\n        }\n    }\n    \n    return 0;\n}\n", "perturbed_sampled": ["#include <stdio.h> int sign(double  y1, double x2, double y2, double x3, double  x1); } int  x1, double y1, double x2, double y2, double x3,  d2 = cross_product(x2, y2, x3, y3, px,  y3, x1, y1, px, py);  s2 = sign(d2); int s3 = sign(d3); int has_neg = (s1 < 0)  has_pos = (s1 >  || (s3  = 0; i < n; i++)  yk, xs, ys; scanf(\"%lf %lf %lf %lf  %lf\", &xp1,  &xk, &yk, &xs,  yk, xp1, yp1, xp2, yp2,  point_in_triangle(xs, ys, xp1,  if (k_inside != s_inside) {  }"], "perturbed_original": ["// Aizu Vol-2 0143 Altair and  int atSameSide(int  int y2, int xa,  yb) { int sa, sb;  * (ya -   * (yb - y1) + (y2 - y1)   0; // xb,yb in line return (sa * sb >= 0); // xa,ya xb,yb at same  y1, x2, y2, x3, y3, xk, yk, xs, ys; int kin, sin;  &y3, &xk,  atSameSide(x1, y1,   x1, y1, x2,  atSameSide(x1,   y3,  } return 0; }"], "original_ll": -0.943423330783844, "sampled_ll": -0.40711045265197754, "all_perturbed_sampled_ll": [-2.3845582008361816], "all_perturbed_original_ll": [-3.1952662467956543], "perturbed_sampled_ll": -2.3845582008361816, "perturbed_original_ll": -3.1952662467956543, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import java.awt.geom.Point2D;\nimport java.util.Scanner;\npublic class Main {\n\tScanner in = new Scanner(System.in);\n\tpublic static void main(String[] args) {\n\t\tnew Main();\n\t}\n\tpublic Main() {\n\t\tint n = in.nextInt();\n\t\tfor(int i=0;i<n;i++)new AOJ0143().doIt();\n\t\t\n\t}\n\tclass AOJ0143{\n\t\tvoid doIt(){\n\t\t\tPoint2D ps[] = new Point2D[3];\n\t\t\tfor(int i=0;i<3;i++)ps[i] = new Point2D.Double(in.nextInt(),in.nextInt());;\n\t\t\tPoint2D a = new Point2D.Double(in.nextInt(),in.nextInt());\n\t\t\tPoint2D b = new Point2D.Double(in.nextInt(),in.nextInt());\n\t\t\tint c = contains(ps, a);\n\t\t\tint d = contains(ps, b);\n//\t\t\tSystem.out.println(c+\" \"+d);\n\t\t\tif(c==d)System.out.println(\"NG\");\n\t\t\telse System.out.println(\"OK\");\n\t\t}\n\t\tPoint2D sub(Point2D p1,Point2D p2){\n\t\t\treturn new Point2D.Double(p1.getX()-p2.getX(),p1.getY()-p2.getY());\n\t\t}\n\t\tdouble cross(Point2D p1,Point2D p2){\n\t\t\treturn p1.getX()*p2.getY()-p1.getY()*p2.getX();\n\t\t}\n\t\tdouble dot(Point2D p1,Point2D p2){\n\t\t\treturn p1.getX()*p2.getX()+p1.getY()*p2.getY();\n\t\t}\n\t\tprivate int contains(Point2D[] plist,Point2D p) {\n\t\t\tboolean isin = false;\n\t\t\tint n = plist.length;\n\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\tPoint2D a = sub(plist[i], p);\n\t\t\t\tPoint2D b = sub(plist[(i+1) % n], p);\n\t\t\t\tif(a.getY() > b.getY()){\n\t\t\t\t\tPoint2D temp = (Point2D) a.clone();\n\t\t\t\t\ta = b;\n\t\t\t\t\tb = temp;\n\t\t\t\t}\n\t\t\t\tif(a.getY() <= 0 && 0 < b.getY()){\n\t\t\t\t\tif(cross(a,b) < 0) isin = ! isin;\n\t\t\t\t}\n\t\t\t\tif(cross(a,b) == 0 && dot(a, b) <= 0) return 0;\n\t\t\t}\n\t\t\treturn isin ? 1 : -1;\n\t\t}\n\t}\n}", "sampled": "import java.util.Scanner;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int n = sc.nextInt();\n        \n        for (int i = 0; i < n; i++) {\n            double xp1 = sc.nextDouble();\n            double yp1 = sc.nextDouble();\n            double xp2 = sc.nextDouble();\n            double yp2 = sc.nextDouble();\n            double xp3 = sc.nextDouble();\n            double yp3 = sc.nextDouble();\n            double xk = sc.nextDouble();\n            double yk = sc.nextDouble();\n            double xs = sc.nextDouble();\n            double ys = sc.nextDouble();\n            \n            boolean kInside = isInside(xp1, yp1, xp2, yp2, xp3, yp3, xk, yk);\n            boolean sInside = isInside(xp1, yp1, xp2, yp2, xp3, yp3, xs, ys);\n            \n            if (kInside != sInside) {\n                System.out.println(\"OK\");\n            } else {\n                System.out.println(\"NG\");\n            }\n        }\n        sc.close();\n    }\n    \n    static boolean isInside(double x1, double y1, double x2, double y2, double x3, double y3, double px, double py) {\n        double sign1 = sign(px, py, x1, y1, x2, y2);\n        double sign2 = sign(px, py, x2, y2, x3, y3);\n        double sign3 = sign(px, py, x3, y3, x1, y1);\n        \n        boolean hasNeg = (sign1 < 0) || (sign2 < 0) || (sign3 < 0);\n        boolean hasPos = (sign1 > 0) || (sign2 > 0) || (sign3 > 0);\n        \n        return !(hasNeg && hasPos);\n    }\n    \n    static double sign(double px, double py, double x1, double y1, double x2, double y2) {\n        return (px - x2) * (y1 - y2) - (x1 - x2) * (py - y2);\n    }\n}\n", "perturbed_sampled": ["import  public static void main(String[] args) { Scanner sc =  n; i++) { double   sc.nextDouble();  yk = sc.nextDouble(); double xs = sc.nextDouble();   xp3, yp3, xs, ys); if (kInside != sInside) { System.out.println(\"OK\"); } else { System.out.println(\"NG\"); } } sc.close(); } static boolean isInside(double x1, double y1, double x2, double y2,  px,  = sign(px, py, x1, y1, x2,  x1, y1); boolean hasNeg = (sign1 <  > 0) || (sign2 > 0) || (sign3 > 0);  double y2) { return (px - x2) *  - y2); } }"], "perturbed_original": ["import java.awt.geom.Point2D; =<extra_id_1>= 0;i<n;i++){ int p =<extra_id_2>if(a.getX()<b.getX()){ new Scanner(System.in); public static void main(String[] args) { new Main(); } public Main() { int =<extra_id_3>>=b.getX(); if(a.getX()<b.getX()){<extra_id_4>= 0;<extra_id_5>|=<extra_id_6>! isin) {<extra_id_7>> (0);<extra_id_8>} // print(a)<extra_id_9>println(b+\" = new Point2D[3]; for(int i=0;i<3;i++)ps[i]  = new  Point2D.Double(in.nextInt(),in.nextInt()); int  d = contains(ps, b); // System.out.println(c+\" \"+d);  new Point2D.Double(p1.getX()-p2.getX(),p1.getY()-p2.getY()); } double cross(Point2D   p1.getX()*p2.getX()+p1.getY()*p2.getY(); }   for(int  p); Point2D b = sub(plist[(i+1) % n], p); if(a.getY() > b.getY()){    = ! isin; }  ? 1 : -1; } } }"], "original_ll": -0.855695366859436, "sampled_ll": -0.41313210129737854, "all_perturbed_sampled_ll": [-2.5261900424957275], "all_perturbed_original_ll": [-2.815077543258667], "perturbed_sampled_ll": -2.5261900424957275, "perturbed_original_ll": -2.815077543258667, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "class Vector:\n    def __init__(self, x, y):\n        self.x = x\n        self.y = y\n\n    def __sub__(self, other):\n        return Vector(self.x - other.x, self.y - other.y)\n\n    @staticmethod\n    def cross_product(point1, point2):\n        return point1.x * point2.y - point1.y * point2.x\n\n\nclass Triangle:\n    def __init__(self, x1, y1, x2, y2, x3, y3):\n        self.point1 = Vector(x1, y1)\n        self.point2 = Vector(x2, y2)\n        self.point3 = Vector(x3, y3)\n\n    def is_contain(self, point):\n        line1 = point - self.point1\n        line2 = self.point2 - self.point1\n        direct1 = Vector.cross_product(line1, line2)\n\n        line1 = point - self.point2\n        line2 = self.point3 - self.point2\n        direct2 = Vector.cross_product(line1, line2)\n\n        line1 = point - self.point3\n        line2 = self.point1 - self.point3\n        direct3 = Vector.cross_product(line1, line2)\n\n        if 0 < direct1 and 0 < direct2 and 0 < direct3:\n            return 1\n        elif direct1 < 0 and direct2 < 0 and direct3 < 0:\n            return 1\n        else:\n            return -1\n\n\nfor _ in range(int(input())):\n    data = [int(item) for item in input().split(\" \")]\n\n    triangle = Triangle(data[0], data[1], data[2], data[3], data[4], data[5])\n    altair_point = Vector(data[6], data[7])\n    vega_point = Vector(data[8], data[9])\n\n    is_contain1 = triangle.is_contain(altair_point)\n    is_contain2 = triangle.is_contain(vega_point)\n    result = is_contain1 * is_contain2\n\n    if result == -1:\n        print(\"OK\")\n    else:\n        print(\"NG\")\n\n", "sampled": "def sign(p1, p2, p3):\n    return (p1[0] - p3[0]) * (p2[1] - p3[1]) - (p2[0] - p3[0]) * (p1[1] - p3[1])\n\ndef point_in_triangle(pt, v1, v2, v3):\n    d1 = sign(pt, v1, v2)\n    d2 = sign(pt, v2, v3)\n    d3 = sign(pt, v3, v1)\n    \n    has_neg = (d1 < 0) or (d2 < 0) or (d3 < 0)\n    has_pos = (d1 > 0) or (d2 > 0) or (d3 > 0)\n    \n    return not (has_neg and has_pos)\n\nn = int(input())\nfor _ in range(n):\n    coords = list(map(int, input().split()))\n    p1 = (coords[0], coords[1])\n    p2 = (coords[2], coords[3])\n    p3 = (coords[4], coords[5])\n    k = (coords[6], coords[7])\n    s = (coords[8], coords[9])\n    \n    k_inside = point_in_triangle(k, p1, p2, p3)\n    s_inside = point_in_triangle(s, p1, p2, p3)\n    \n    if (k_inside and not s_inside) or (not k_inside and s_inside):\n        print(\"OK\")\n    else:\n        print(\"NG\")\n", "perturbed_sampled": ["def sign(p1,  p3[0]) * (p1[1] - p3[1])  d1 = sign(pt, v1,  v3) d3 = sign(pt, v3,  > 0) or (d2 > 0) or  (has_neg and has_pos) n =  p2  (coords[6], coords[7]) s = (coords[8], coords[9]) k_inside = point_in_triangle(k, p1, p2, p3) s_inside = point_in_triangle(s, p1, p2, p3)  s_inside): print(\"OK\") else: print(\"NG\")"], "perturbed_original": ["class Vector: def __init__(self, x, y): self.x = x self.y =   other.y) @staticmethod def  point2.y  Triangle:  = Vector(x1, y1)  = Vector(x3, y3)   =  self.point3 direct3 = Vector.cross_product(line1, line2) if  < direct3: return 1 elif direct1 < 0 and direct2 < 0 and direct3   range(int(input())): data = [int(item) for item in input().split(\" \")] triangle = Triangle(data[0], data[1], data[2], data[3],  data[7]) vega_point = Vector(data[8],  result == -1: print(\"OK\") else: print(\"NG\")"], "original_ll": -0.5611461400985718, "sampled_ll": -0.47811925411224365, "all_perturbed_sampled_ll": [-2.409424304962158], "all_perturbed_original_ll": [-2.5018904209136963], "perturbed_sampled_ll": -2.409424304962158, "perturbed_original_ll": -2.5018904209136963, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "#include <stdio.h>\n\nint r[100][100];\nint n;\n\nint dijkstra(int start, int goal) {\n  int i;\n  int minimum, p;\n  int d[100], f[100];\n\n  for(i = 0; i < 100; i++) {\n    d[i] = 100000;\n    f[i] = 0;\n  }\n  d[start-1] = 1;\n  while(1) {\n    minimum = 100000;\n    for(i = 0; i < n; i++) {\n      if(d[i] < minimum && f[i] == 0) {\n\tminimum = d[i];\n\tp = i;\n      }\n    }\n    if(minimum == 100000) break;\n    f[p] = 1;\n\n    for(i = 0; i < n; i++) {\n      if(d[p] + r[p][i] < d[i]) {\n\td[i] = d[p] + r[p][i];\n      }\n    }\n  }\n\n  return d[goal-1];\n}\n\nint main() {\n  int i, j, r1, k1, p, s1, d1, v1, temp;\n\n  for(i = 0; i < 100; i++)\n    for(j = 0; j < 100; j++)\n      r[i][j] = 100000;\n\n  scanf(\"%d\", &n);\n  for(i = 0; i < n; i++) {\n    scanf(\"%d %d\", &r1, &k1);\n    for(j = 0; j < k1; j++) {\n      scanf(\"%d\", &temp);\n      r[r1-1][temp-1] = 1;\n    }\n  }\n  scanf(\"%d\", &p);\n  for(i = 0; i < p; i++) {\n    scanf(\"%d %d %d\", &s1, &d1, &v1);\n    temp = dijkstra(s1, d1);\n    if(v1 - temp < 0) {\n      printf(\"NA\\n\");\n    } else {\n      printf(\"%d\\n\", temp);\n    }\n  }\n  return 0;\n}", "sampled": "#include <stdio.h>\n#include <string.h>\n#include <limits.h>\n\n#define MAX_N 101\n#define INF INT_MAX\n\nint adj[MAX_N][MAX_N];\nint adjCount[MAX_N];\nint dist[MAX_N];\nint visited[MAX_N];\n\nint bfs(int start, int end, int n) {\n    int queue[MAX_N * MAX_N];\n    int front = 0, rear = 0;\n    \n    for (int i = 1; i <= n; i++) {\n        dist[i] = INF;\n        visited[i] = 0;\n    }\n    \n    queue[rear++] = start;\n    dist[start] = 1;\n    visited[start] = 1;\n    \n    while (front < rear) {\n        int u = queue[front++];\n        \n        if (u == end) {\n            return dist[end];\n        }\n        \n        for (int i = 0; i < adjCount[u]; i++) {\n            int v = adj[u][i];\n            if (!visited[v]) {\n                visited[v] = 1;\n                dist[v] = dist[u] + 1;\n                queue[rear++] = v;\n            }\n        }\n    }\n    \n    return -1;\n}\n\nint main() {\n    int n;\n    scanf(\"%d\", &n);\n    \n    for (int i = 1; i <= n; i++) {\n        adjCount[i] = 0;\n    }\n    \n    for (int i = 0; i < n; i++) {\n        int r, k;\n        scanf(\"%d %d\", &r, &k);\n        adjCount[r] = k;\n        for (int j = 0; j < k; j++) {\n            scanf(\"%d\", &adj[r][j]);\n        }\n    }\n    \n    int p;\n    scanf(\"%d\", &p);\n    \n    for (int i = 0; i < p; i++) {\n        int s, d, v;\n        scanf(\"%d %d %d\", &s, &d, &v);\n        \n        int minDist = bfs(s, d, n);\n        \n        if (minDist == -1) {\n            printf(\"NA\\n\");\n        } else {\n            int hops = minDist - 1;\n            if (v >= hops) {\n                printf(\"%d\\n\", minDist);\n            } else {\n                printf(\"NA\\n\");\n            }\n        }\n    }\n    \n    return 0;\n}\n", "perturbed_sampled": [" <limits.h> #define MAX_N 101  n) { int queue[MAX_N * MAX_N]; int front = 0, rear   INF; visited[i] = 0; }  1; visited[start] = 1; while (front   end) {   adjCount[u];  visited[v] =  1; queue[rear++] = v; } } } return -1; } int main()  for (int i  i = 0; i < n; i++) { int  &k);  j = 0; j < k;  }   < p;  &s, &d, &v);  n); if (minDist  else { int hops =  minDist); }  } return 0; }"], "perturbed_original": ["  goal) { int i; int  for(i = 0; i  0; } d[start-1] = 1;  < n; i++) { if(d[i] < minimum && f[i]  d[i]; p =  100000)  =  { if(d[p] + r[p][i]  d[p] + r[p][i];  k1, p,  = 0; i < 100; i++) for(j = 0;  for(i = 0; i < n; i++) {  } } scanf(\"%d\", &p); for(i =  { scanf(\"%d %d %d\",   } else {  0; }"], "original_ll": -0.6065195202827454, "sampled_ll": -0.48266300559043884, "all_perturbed_sampled_ll": [-2.7432942390441895], "all_perturbed_original_ll": [-2.630471706390381], "perturbed_sampled_ll": -2.7432942390441895, "perturbed_original_ll": -2.630471706390381, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import java.io.*;\nimport java.util.*;\n\npublic class Main{\n\tpublic static void main(String args[]){\n\t\ttry{\n\t\t\tnew Main();\n\t\t}catch(IOException e){\n\t\t\te.printStackTrace();\n\t\t}\n\t}\n\t\n\tpublic Main() throws IOException{\n\t\tBufferedReader in = new BufferedReader(new InputStreamReader(System.in));\n\t\tString line = in.readLine();\n\t\n\t\tint size = Integer.parseInt(line);\n\t\tNode[] nodes = new Node[size];\n\t\tfor(int i=0; i<size; i++){\n\t\t\tline = in.readLine();\n\t\t\tString[] tmp = line.split(\" \");\n\t\t\tint id = Integer.parseInt(tmp[0])-1;\n\t\t\tnodes[id] = new Node();\n\t\t\tint n_to = Integer.parseInt(tmp[1]);\n\t\t\tfor(int j=2; j<2+n_to; j++){\n\t\t\t\tint to = Integer.parseInt(tmp[j])-1;\n\t\t\t\tnodes[id].add_edge(to, 1);\n\t\t\t}\n\t\t}\n\t\t\n\t\tline = in.readLine();\n\t\tsize = Integer.parseInt(line);\n\t\tfor(int i=0; i<size; i++){\n\t\t\tNode[] clone = deepClone(nodes);\n\t\t\tline = in.readLine();\n\t\t\tString[] tmp = line.split(\" \");\n\t\t\tint s = Integer.parseInt(tmp[0])-1;\n\t\t\tint g = Integer.parseInt(tmp[1])-1;\n\t\t\tint ttl = Integer.parseInt(tmp[2]);\n\t\t\tint total = calcCost(clone, s, g);\n\t\t\tif(ttl >= total && total != -1){\n\t\t\t\tSystem.out.println(total);\n\t\t\t}else{\n\t\t\t\tSystem.out.println(\"NA\");\n\t\t\t}\n\t\t}\n\t}\n\t\n\tpublic int calcCost(Node[] nodes, int s, int g){\n\t\tList<Node> que = new ArrayList<Node>();\n\t\tnodes[s].cost = 1;\n\t\tque.add(nodes[s]);\n\t\tNode done = null;\n\t\twhile(que.size()!=0){\n\t\t\tdone = que.get(0);\n\t\t\tque.remove(0);\n\t\t\tdone.visited = true;\n\t\t\tfor(int i=0; i<done.edge_to.size(); i++){\n\t\t\t\tint cost = done.cost + done.edge_cost.get(i);\n\t\t\t\tint to = done.edge_to.get(i);\n\t\t\t\tif(nodes[to].cost < 0 || cost < nodes[to].cost){\n\t\t\t\t\tnodes[to].cost = cost;\n\t\t\t\t\tif(!que.contains(nodes[to])){\n\t\t\t\t\t\tque.add(nodes[to]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn nodes[g].cost;\n\t}\n\t\n\tpublic Node[] deepClone(Node[] nodes){\n\t\tint m = nodes.length;\n\t\tNode[] clone = new Node[m];\n\t\tfor(int i=0; i<m; i++){\n\t\t\tclone[i] = new Node(nodes[i]);\n\t\t}\n\t\treturn clone;\n\t}\n}\n\nclass Node{\n\tint cost;\n\tboolean visited;\n\tList<Integer> edge_to;\n\tList<Integer> edge_cost;\n\t\n\tpublic Node(){\n\t\tthis.cost = -1;\n\t\tthis.visited = false;\n\t\tthis.edge_cost = new ArrayList<Integer>();\n\t\tthis.edge_to = new ArrayList<Integer>();\n\t}\n\t\n\tpublic Node(Node n){\n\t\tthis.cost = n.cost;\n\t\tthis.visited = n.visited;\n\t\tthis.edge_to = new ArrayList<Integer>(n.edge_to);\n\t\tthis.edge_cost = new ArrayList<Integer>(n.edge_cost);\n\t}\n\t\n\tpublic void add_edge(int to, int cost){\n\t\tthis.edge_cost.add(cost);\n\t\tthis.edge_to.add(to);\n\t}\n}", "sampled": "import java.util.*;\n\npublic class Main {\n    static class Router {\n        int id;\n        List<Integer> connections;\n        \n        Router(int id) {\n            this.id = id;\n            this.connections = new ArrayList<>();\n        }\n    }\n    \n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        \n        int n = sc.nextInt();\n        Map<Integer, Router> routers = new HashMap<>();\n        \n        for (int i = 0; i < n; i++) {\n            int routerId = sc.nextInt();\n            Router router = new Router(routerId);\n            int k = sc.nextInt();\n            for (int j = 0; j < k; j++) {\n                router.connections.add(sc.nextInt());\n            }\n            routers.put(routerId, router);\n        }\n        \n        int p = sc.nextInt();\n        for (int i = 0; i < p; i++) {\n            int source = sc.nextInt();\n            int dest = sc.nextInt();\n            int ttl = sc.nextInt();\n            \n            int minHops = bfs(routers, source, dest);\n            \n            if (minHops == -1 || ttl < minHops - 1) {\n                System.out.println(\"NA\");\n            } else {\n                System.out.println(minHops);\n            }\n        }\n        \n        sc.close();\n    }\n    \n    static int bfs(Map<Integer, Router> routers, int source, int dest) {\n        Queue<Integer> queue = new LinkedList<>();\n        Map<Integer, Integer> distance = new HashMap<>();\n        \n        queue.offer(source);\n        distance.put(source, 1);\n        \n        while (!queue.isEmpty()) {\n            int current = queue.poll();\n            int currentDist = distance.get(current);\n            \n            if (current == dest) {\n                return currentDist;\n            }\n            \n            Router router = routers.get(current);\n            if (router != null) {\n                for (int next : router.connections) {\n                    if (!distance.containsKey(next)) {\n                        distance.put(next, currentDist + 1);\n                        queue.offer(next);\n                    }\n                }\n            }\n        }\n        \n        return -1;\n    }\n}\n", "perturbed_sampled": ["import java.util.*;   List<Integer> connections; Router(int id) {  new  void   0; i  routerId = sc.nextInt(); Router router = new Router(routerId); int k = sc.nextInt(); for (int j = 0; j < k; j++) { router.connections.add(sc.nextInt()); } routers.put(routerId, router); } int p  =  { int source =  int  =  bfs(Map<Integer, Router> routers, int  queue = new LinkedList<>(); Map<Integer, Integer> distance   current = queue.poll(); int currentDist  dest) { return currentDist; } Router router =     return -1; } }"], "perturbed_original": ["import java.io.*; import java.util.*;   Main(); }catch(IOException e){  String[] tmp = line.split(\"  nodes[id] = new Node(); int n_to = Integer.parseInt(tmp[1]); for(int j=2;  Integer.parseInt(tmp[j])-1; nodes[id].add_edge(to, 1); } } line = in.readLine(); size = Integer.parseInt(line); for(int   Integer.parseInt(tmp[2]); int   != -1){ System.out.println(total); }else{ System.out.println(\"NA\"); }  nodes, int  =  que.add(nodes[s]);  done = que.get(0); que.remove(0);  i<done.edge_to.size(); i++){ int cost  to = done.edge_to.get(i);  < nodes[to].cost){ nodes[to].cost = cost;  }  deepClone(Node[]  Node[]  i=0;  } } class Node{ int cost;  edge_cost; public Node(){ this.cost = -1; this.visited = false;  = new ArrayList<Integer>(); }  n.cost; this.visited  ArrayList<Integer>(n.edge_to); this.edge_cost = new ArrayList<Integer>(n.edge_cost);  int cost){ this.edge_cost.add(cost); this.edge_to.add(to); } }"], "original_ll": -0.668572187423706, "sampled_ll": -0.4895699620246887, "all_perturbed_sampled_ll": [-2.9353957176208496], "all_perturbed_original_ll": [-2.9979090690612793], "perturbed_sampled_ll": -2.9353957176208496, "perturbed_original_ll": -2.9979090690612793, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "def solve(A):\n  s,d,v = A\n  C = [-1 for _ in [0]*(n+1)]\n  c = 1\n  C[s] = c\n  SP = M[s]\n  while 1:\n    if SP==[]: return \"NA\"\n    c += 1\n    X = []\n    for p in SP:\n      if C[p]>0: continue\n      C[p] = c\n      X += [e for e in M[p] if C[e]<0 and e not in SP]\n      if p==d: return [C[d],\"NA\"][C[p]>v]\n    SP = X\n\nn = int(raw_input())\nM = {}\n\nfor _ in [0]*n:\n  x = map(int, raw_input().split())\n  M[x[0]] = x[2:]\nfor _ in [0]*int(raw_input()):\n  print solve(map(int,raw_input().split()))", "sampled": "from collections import deque, defaultdict\n\ndef bfs(graph, start, end, n):\n    if start == end:\n        return 0\n    \n    visited = [False] * (n + 1)\n    queue = deque([(start, 0)])\n    visited[start] = True\n    \n    while queue:\n        node, dist = queue.popleft()\n        \n        if node in graph:\n            for neighbor in graph[node]:\n                if not visited[neighbor]:\n                    if neighbor == end:\n                        return dist + 1\n                    visited[neighbor] = True\n                    queue.append((neighbor, dist + 1))\n    \n    return -1\n\nn = int(input())\ngraph = defaultdict(list)\n\nfor _ in range(n):\n    line = list(map(int, input().split()))\n    router_id = line[0]\n    k = line[1]\n    if k > 0:\n        connections = line[2:2+k]\n        graph[router_id] = connections\n\np = int(input())\n\nfor _ in range(p):\n    s, d, v = map(int, input().split())\n    \n    min_hops = bfs(graph, s, d, n)\n    \n    if min_hops == -1:\n        print(\"NA\")\n    else:\n        if v >= min_hops:\n            print(min_hops + 1)\n        else:\n            print(\"NA\")\n", "perturbed_sampled": ["from collections import deque, defaultdict def bfs(graph, start, end, n): if start == end:  * (n +  visited[start] =  in graph: for   visited[neighbor] = True queue.append((neighbor,   range(n): line =  k = line[1] if k > 0:  connections p  range(p):  input().split()) min_hops = bfs(graph, s, d,  1) else: print(\"NA\")"], "perturbed_original": ["def  1 C[s] = c SP = M[s] while 1: if SP==[]: return \"NA\" c += 1 X   [e for e in M[p] if C[e]<0    _   _ in [0]*int(raw_input()): print solve(map(int,raw_input().split()))"], "original_ll": -1.7584834098815918, "sampled_ll": -0.7765875458717346, "all_perturbed_sampled_ll": [-3.42855167388916], "all_perturbed_original_ll": [-4.401365280151367], "perturbed_sampled_ll": -3.42855167388916, "perturbed_original_ll": -4.401365280151367, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "#include <stdio.h>\n\nint main(){\n  int c1[100],c2[100],i,j,k,n,s=0,a,amax=0,amaxi;\n\n  scanf(\"%d\\n\",&n);\n  for(i=0;i<n;i++) scanf(\"%d %d\\n\",&c1[i],&c2[i]);\n\n  for(i=0;i<n-1;i++){\n    for(j=0;j<n-i-1;j++){\n      a=c2[j]*c1[j+1];\n      if(a>amax || (a==amax && c1[j]*c2[j+1] < c1[amaxi]*c2[amaxi+1])){\n        amax=a;\n        amaxi=j;\n      }\n    }\n    s+=c1[amaxi]*c2[amaxi]*c1[amaxi+1]*c2[amaxi+1];\n    c2[amaxi]=c2[amaxi+1];\n    for(j=amaxi+1;j<n-i;j++){\n      c1[j]=c1[j+1];\n      c2[j]=c2[j+1];\n    }\n    amax=0;\n  }\n  printf(\"%d\\n\",s);\n  return 0;\n}", "sampled": "#include <stdio.h>\n#include <limits.h>\n\nint n;\nint a[101], b[101];\nlong long dp[101][101];\n\nlong long solve(int l, int r) {\n    if (l == r) return 0;\n    if (dp[l][r] != -1) return dp[l][r];\n    \n    long long min_cost = LLONG_MAX;\n    \n    for (int k = l; k < r; k++) {\n        long long cost = solve(l, k) + solve(k + 1, r);\n        cost += (long long)a[l] * b[k] * a[k + 1] * b[r];\n        if (cost < min_cost) {\n            min_cost = cost;\n        }\n    }\n    \n    dp[l][r] = min_cost;\n    return min_cost;\n}\n\nint main() {\n    scanf(\"%d\", &n);\n    \n    for (int i = 1; i <= n; i++) {\n        scanf(\"%d %d\", &a[i], &b[i]);\n    }\n    \n    for (int i = 0; i <= n; i++) {\n        for (int j = 0; j <= n; j++) {\n            dp[i][j] = -1;\n        }\n    }\n    \n    printf(\"%lld\\n\", solve(1, n));\n    \n    return 0;\n}\n", "perturbed_sampled": ["#include <stdio.h> #include <limits.h>  long long dp[101][101]; long long solve(int  for (int k = l; k < r; k++) {  k) + solve(k + 1, r);  b[k] * a[k + 1] * b[r]; if  (int i =  { scanf(\"%d %d\", &a[i],  n;   -1; } } printf(\"%lld\\n\", solve(1, n)); return 0; }"], "perturbed_original": [" c1[100],c2[100],i,j,k,n,s=0,a,amax=0,amaxi;  for(j=0;j<n-i-1;j++){  c1[j]*c2[j+1] < c1[amaxi]*c2[amaxi+1])){ amax=a; amaxi=j; } }   0; }"], "original_ll": -0.8633320331573486, "sampled_ll": -0.4128352701663971, "all_perturbed_sampled_ll": [-2.330104351043701], "all_perturbed_original_ll": [-2.468611001968384], "perturbed_sampled_ll": -2.330104351043701, "perturbed_original_ll": -2.468611001968384, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import java.util.*;\npublic class Main {\n\tfinal int INF = Integer.MAX_VALUE / 4;\n\n\tprivate void doit(){\n\t\tScanner sc = new Scanner(System.in);\n\t\tString a = sc.next();\n\t\t\n\t\tint n = Integer.parseInt(a);\n\t\tint [][] data = new int[n][2];\n\t\tint [][] memo = new int[n][n];\n\t\tfor(int i=0; i < n; i++){\n\t\t\tArrays.fill(memo[i], INF);\n\t\t\tmemo[i][i] = 0;\n\t\t}\n\t\tfor(int i=0; i < n; i++){\n\t\t\tdata[i][0] = sc.nextInt();\n\t\t\tdata[i][1] = sc.nextInt();\n\t\t}\n\t\tSystem.out.println(\"440\");\n//\t\tfor(int i = 0; i < n-1; i++){\n//\t\t\tmemo[i][i+1] = data[i][0] * data[i][1] * data[i+1][0] * data[i+1][1];\n//\t\t}\n//\n//\t\tfor(int k = 2; k < n; k++){\n//\t\t\tfor(int i =0; i + k < n; i++){\n//\t\t\t\tfor(int j = i; j < i + k; j++){\n//\t\t\t\t\tint value2 = (data[i][0] * data[i+j][1]) * (data[i+j+1][0] * data[i+k][1]);\n//\t\t\t\t\tint value = memo[i][i+j] + memo[i+j+1][i+k] +value2;\n//\t\t\t\t\tmemo[i][i+k] = Math.min(memo[i][i+k], value);\n//\t\t\t\t}\n//\t\t\t}\n//\t\t}\n\t\t//\t\t\t//debug\n\t\t//\t\t\tSystem.out.println(\"D= \");\n\t\t//\t\t\tfor(int i=0; i < n; i++){\n\t\t//\t\t\t\tfor(int j = 0;  i+ j < n;j++){\n\t\t//\t\t\t\t\tSystem.out.print(memo[j][i+j] + \" \");\n\t\t//\t\t\t\t}\n\t\t//\t\t\t\tSystem.out.println();\n\t\t//\t\t\t}\n\n\t\tSystem.out.println(memo[0][n-1]);\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tMain obj = new Main();\n\t\tobj.doit();\n\t}\n}", "sampled": "import java.util.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int n = sc.nextInt();\n        int[][] cards = new int[n][2];\n        \n        for (int i = 0; i < n; i++) {\n            cards[i][0] = sc.nextInt(); // top\n            cards[i][1] = sc.nextInt(); // bottom\n        }\n        \n        // dp[i][j] = minimum cost to merge piles from i to j into one pile\n        long[][] dp = new long[n][n];\n        // result[i][j][0] = top card after merging i to j\n        // result[i][j][1] = bottom card after merging i to j\n        int[][][] result = new int[n][n][2];\n        \n        // Initialize single piles\n        for (int i = 0; i < n; i++) {\n            dp[i][i] = 0;\n            result[i][i][0] = cards[i][0];\n            result[i][i][1] = cards[i][1];\n        }\n        \n        // Fill DP table for increasing lengths\n        for (int len = 2; len <= n; len++) {\n            for (int i = 0; i <= n - len; i++) {\n                int j = i + len - 1;\n                dp[i][j] = Long.MAX_VALUE;\n                \n                // Try all possible split points\n                for (int k = i; k < j; k++) {\n                    // Merge [i..k] and [k+1..j]\n                    // Left pile (i..k) goes on top of right pile (k+1..j)\n                    long cost = dp[i][k] + dp[k+1][j];\n                    cost += (long)result[i][k][0] * result[i][k][1] * result[k+1][j][0] * result[k+1][j][1];\n                    \n                    if (cost < dp[i][j]) {\n                        dp[i][j] = cost;\n                        result[i][j][0] = result[i][k][0]; // top from left pile\n                        result[i][j][1] = result[k+1][j][1]; // bottom from right pile\n                    }\n                }\n            }\n        }\n        \n        System.out.println(dp[0][n-1]);\n        sc.close();\n    }\n}\n", "perturbed_sampled": ["import java.util.*;  static  sc = new  int[][] cards = new int[n][2]; for (int  cards[i][1] = sc.nextInt(); // bottom  from i to j into one pile long[][] dp  = top card  =  n; i++) {  cards[i][0]; result[i][i][1] = cards[i][1]; } // Fill DP table for increasing lengths for (int len =  {  i <= n - len; i++) { int j =  dp[i][j] =  k  k++) { // Merge [i..k] and [k+1..j] // Left pile (i..k)  result[k+1][j][1]; if (cost  cost; result[i][j][0] = result[i][k][0];  bottom from  } System.out.println(dp[0][n-1]); sc.close(); } }"], "perturbed_original": [" { final int  sc = new Scanner(System.in); String a = sc.next(); int  data = new  new  n; i++){ Arrays.fill(memo[i], INF); memo[i][i] =  < n;    memo[i][i+1] = data[i][0] * data[i][1] * data[i+1][0] * data[i+1][1]; // } //  k  i; j < i + k; j++){ // int  // memo[i][i+k] = Math.min(memo[i][i+k], value);    \"); // } // System.out.println(); // } System.out.println(memo[0][n-1]); } public static void main(String[] args) { Main obj = new Main(); obj.doit(); } }"], "original_ll": -0.8328409194946289, "sampled_ll": -0.6348987221717834, "all_perturbed_sampled_ll": [-2.8114819526672363], "all_perturbed_original_ll": [-2.2818763256073], "perturbed_sampled_ll": -2.8114819526672363, "perturbed_original_ll": -2.2818763256073, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "n = int(raw_input())\nCard = [[] for _ in [0]*n]\nCost = {}\nfor i in range(n):\n  Card[i] = map(int, raw_input().split())\n  Cost[(i, i)] = 0\nfor i in range(1, n):\n  for j in range(0, n-i):\n    a = j+i\n    Cost[(j, a)] = min([Card[j][0] * Card[k][1] * Card[k+1][0] * Card[a][1] + Cost[(j, k)] + Cost[(k+1, a)] for k in range(j, j+i)])\nprint Cost[0, n-1]", "sampled": "def solve():\n    n = int(input())\n    piles = []\n    for _ in range(n):\n        a, b = map(int, input().split())\n        piles.append((a, b))\n    \n    if n == 1:\n        print(0)\n        return\n    \n    # dp[i][j] = minimum cost to merge piles from i to j into one pile\n    # result[i][j] = (top, bottom) of the merged pile from i to j\n    dp = [[0] * n for _ in range(n)]\n    result = [[None] * n for _ in range(n)]\n    \n    # Initialize single piles\n    for i in range(n):\n        result[i][i] = piles[i]\n    \n    # Length of the segment\n    for length in range(2, n + 1):\n        for i in range(n - length + 1):\n            j = i + length - 1\n            dp[i][j] = float('inf')\n            \n            # Try all possible split points\n            for k in range(i, j):\n                # Merge [i, k] and [k+1, j]\n                # Cost = dp[i][k] + dp[k+1][j] + cost of merging these two groups\n                \n                # Get the top and bottom of left merged pile\n                left_top, left_bottom = result[i][k] if result[i][k] else piles[i]\n                # Get the top and bottom of right merged pile\n                right_top, right_bottom = result[k+1][j] if result[k+1][j] else piles[k+1]\n                \n                # Cost of merging left pile onto right pile\n                merge_cost = left_top * left_bottom * right_top * right_bottom\n                \n                total_cost = dp[i][k] + dp[k+1][j] + merge_cost\n                \n                if total_cost < dp[i][j]:\n                    dp[i][j] = total_cost\n                    # After merging, top is from left, bottom is from right\n                    result[i][j] = (left_top, right_bottom)\n    \n    print(dp[0][n-1])\n\nsolve()\n", "perturbed_sampled": ["def solve(): n = int(input()) piles =  a, b = map(int, input().split()) piles.append((a, b)) if n  dp[i][j] = minimum cost to merge piles from i  #  i to  range(n)] result = [[None] *  # Initialize single  Length of the segment for length in  i in range(n - length  dp[i][j]  possible split points for k in   Cost = dp[i][k] + dp[k+1][j] + cost  merged   result[k+1][j] if result[k+1][j] else piles[k+1] # Cost of merging left pile onto  merge_cost if total_cost  # After merging, top  from  print(dp[0][n-1]) solve()"], "perturbed_original": ["n = int(raw_input()) Card = [[] for  {} for i in  Cost[(i, i)] = 0 for i in range(1, n): for j in    Cost[0, n-1]"], "original_ll": -1.246390700340271, "sampled_ll": -0.7813050150871277, "all_perturbed_sampled_ll": [-3.170175552368164], "all_perturbed_original_ll": [-3.559903860092163], "perturbed_sampled_ll": -3.170175552368164, "perturbed_original_ll": -3.559903860092163, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "#include<stdio.h>\n#include<stdlib.h>\nint a[110],b[110],c[110],n;\ndouble f(int i,int j,int k){\n  int w=0,l;\n  if(j==0)return 0;\n  for(l=0;l<n;l++){\n    if(j&(1<<l))w+=c[l]*20;\n  }\n  return abs(b[k]-b[i])*(w+70)/2000.0;\n}\ndouble d[20][1<<16]={};\nint fr[20][1<<16]={};\nint main(){\n  int i,j,k,r[110];\n  scanf(\"%d\",&n);\n  for(i=0;i<n;i++)scanf(\"%d %d %d\",&a[i],&b[i],&c[i]);\n  for(i=0;i<n;i++){\n    for(j=0;j<(1<<n);j++)d[i][j]=1e9;\n  }//printf(\"a\\n\");\n  for(i=0;i<n;i++){\n    for(j=0;j<(1<<n);j++)fr[i][j]=-1;\n  }\n  for(i=0;i<n;i++)d[i][1<<i]=0;\n  for(j=0;j<(1<<n);j++){\n    for(i=0;i<n;i++){\n      if((1<<i)&j==0)continue;\n      for(k=0;k<n;k++){\n\tif(j&(1<<k))continue;\n\tif(d[k][j+(1<<k)]>d[i][j]+f(i,j,k)){\n\t  d[k][j+(1<<k)]=d[i][j]+f(i,j,k);\n\t  fr[k][j+(1<<k)]=i;\n\t}\n      }\n    }\n  }//printf(\"b\\n\");\n  /*for(i=0;i<n;i++){\n    for(j=0;j<(1<<n);j++)printf(\"%f \",d[i][j]);printf(\"\\n\");\n  }\n  for(i=0;i<n;i++){\n    for(j=0;j<(1<<n);j++)printf(\"%d \",fr[i][j]);printf(\"\\n\");\n    }//*/\n  k=j-1;\n  for(i=j=0;i<n;i++){\n    if(d[i][k]<d[j][k])j=i;\n  }//printf(\"%d %d\\n\",j,fr[j][k]);\n  r[n-1]=j;\n  for(i=1;i<n;i++){//printf(\"%d:\",j);\n    r[n-i-1]=fr[r[n-i]][k];\n    k-=(1<<r[n-i]);\n    //j=fr[r[n-i-1]][k];\n  }//printf(\"d\\n\");\n  //for(i=0;i<n;i++)printf(\"%d \",r[i]);printf(\"\\n\");\n  for(i=0;i<n-1;i++)printf(\"%d \",a[r[i]]);\n  printf(\"%d\\n\",a[r[i]]);\n  return 0;\n}", "sampled": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#define MAX_N 15\n#define INF 1e18\n\ntypedef struct {\n    int id;\n    int dist;\n    int boxes;\n} Warehouse;\n\nWarehouse wh[MAX_N];\nint n;\ndouble dp[1 << MAX_N][MAX_N];\nint parent[1 << MAX_N][MAX_N];\nint order[MAX_N];\n\ndouble calc_time(int dist, int weight) {\n    return (double)dist / (2000.0 / (70.0 + weight));\n}\n\nint main() {\n    scanf(\"%d\", &n);\n    \n    for (int i = 0; i < n; i++) {\n        scanf(\"%d %d %d\", &wh[i].id, &wh[i].dist, &wh[i].boxes);\n    }\n    \n    int full_mask = (1 << n) - 1;\n    \n    for (int mask = 0; mask <= full_mask; mask++) {\n        for (int i = 0; i < n; i++) {\n            dp[mask][i] = INF;\n            parent[mask][i] = -1;\n        }\n    }\n    \n    for (int i = 0; i < n; i++) {\n        dp[1 << i][i] = 0;\n    }\n    \n    for (int mask = 0; mask <= full_mask; mask++) {\n        for (int last = 0; last < n; last++) {\n            if (!(mask & (1 << last))) continue;\n            if (dp[mask][last] >= INF) continue;\n            \n            int total_weight = 0;\n            for (int i = 0; i < n; i++) {\n                if (mask & (1 << i)) {\n                    total_weight += wh[i].boxes * 20;\n                }\n            }\n            \n            for (int next = 0; next < n; next++) {\n                if (mask & (1 << next)) continue;\n                \n                int new_mask = mask | (1 << next);\n                int dist = abs(wh[next].dist - wh[last].dist);\n                double time = calc_time(dist, total_weight);\n                double new_time = dp[mask][last] + time;\n                \n                if (new_time < dp[new_mask][next]) {\n                    dp[new_mask][next] = new_time;\n                    parent[new_mask][next] = last;\n                }\n            }\n        }\n    }\n    \n    double min_time = INF;\n    int last_pos = -1;\n    for (int i = 0; i < n; i++) {\n        if (dp[full_mask][i] < min_time) {\n            min_time = dp[full_mask][i];\n            last_pos = i;\n        }\n    }\n    \n    int mask = full_mask;\n    int pos = last_pos;\n    int idx = n - 1;\n    \n    while (pos != -1) {\n        order[idx--] = wh[pos].id;\n        int prev = parent[mask][pos];\n        if (prev == -1) break;\n        mask ^= (1 << pos);\n        pos = prev;\n    }\n    \n    for (int i = 0; i < n; i++) {\n        if (i > 0) printf(\" \");\n        printf(\"%d\", order[i]);\n    }\n    printf(\"\\n\");\n    \n    return 0;\n}\n", "perturbed_sampled": ["#include <stdio.h> #include <stdlib.h>  } Warehouse; Warehouse wh[MAX_N]; int n; double dp[1  calc_time(int dist, int weight) { return (double)dist / (2000.0 / (70.0 + weight));  = 0; i < n;  &wh[i].id, &wh[i].dist, &wh[i].boxes);  for (int mask =  { for (int i = 0; i  =  << i][i] = 0;  0; mask <= full_mask; mask++) { for  < n; last++)  << last))) continue; if (dp[mask][last] >=  0;   if (mask  total_weight += wh[i].boxes * 20;  = 0;  if  continue; int new_mask  next); int dist =  = calc_time(dist, total_weight);  time; if (new_time  new_time;   n; i++) {  min_time =  full_mask; int  =  = wh[pos].id; int prev  = prev;  0; i < n; i++) {  \"); printf(\"%d\", order[i]); } printf(\"\\n\"); return 0; }"], "perturbed_original": [" f(int  if(j==0)return  int fr[20][1<<16]={}; int main(){ int i,j,k,r[110]; scanf(\"%d\",&n); for(i=0;i<n;i++)scanf(\"%d  for(i=0;i<n;i++){  if((1<<i)&j==0)continue; for(k=0;k<n;k++){  } } }//printf(\"b\\n\"); /*for(i=0;i<n;i++){ for(j=0;j<(1<<n);j++)printf(\"%f    //j=fr[r[n-i-1]][k]; }//printf(\"d\\n\"); //for(i=0;i<n;i++)printf(\"%d \",r[i]);printf(\"\\n\"); for(i=0;i<n-1;i++)printf(\"%d \",a[r[i]]); printf(\"%d\\n\",a[r[i]]); return 0; }"], "original_ll": -0.9309648871421814, "sampled_ll": -0.5668311715126038, "all_perturbed_sampled_ll": [-2.8964030742645264], "all_perturbed_original_ll": [-2.020021915435791], "perturbed_sampled_ll": -2.8964030742645264, "perturbed_original_ll": -2.020021915435791, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import java.util.*;\nimport java.io.*;\n\npublic class Main {\n\t\n\tpublic void sort(int[][] data){\n\t\tfor(int i = 0; i < data.length; i++){\n\t\t\tint min = i;\n\t\t\tfor(int j = i+1; j < data.length; j++){\n\t\t\t\tif( data[min][2] > data[j][2] ){\n\t\t\t\t\tmin = j;\n\t\t\t\t} else if( data[min][2] == data[j][2] ){\n\t\t\t\t\tif( data[min][1] > data[j][1] ){\n\t\t\t\t\t\tmin = j;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(int j = 0; j < 3; j++){\n\t\t\t\tint temp = data[min][j];\n\t\t\t\tdata[min][j] = data[i][j];\n\t\t\t\tdata[i][j] = temp;\n\t\t\t}\n\t\t}\n\t}\n\tpublic int[] nextPermutation(int[] x, int index){\n\t\tint max = index;\n\t\tboolean[] temp = new boolean[x.length];\n\t\tfor(int i = index; i < x.length; i++){\n\t\t\ttemp[x[i]-1] = true;\n\t\t\tif( x[i] > x[max] ){\n\t\t\t\tmax = i;\n\t\t\t}\n\t\t}\n\t\tint key = index+1;\n\t\tif( max == index ){\n\t\t\tfor(; index > 0; index--){\n\t\t\t\ttemp[x[index-1]-1] = true;\n\t\t\t\tif( x[index] > x[index-1] ){\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif( index == 0 ){\n\t\t\t\tx[0] = -1;\n\t\t\t\treturn x;\n\t\t\t}\n\t\t\tkey = index;\n\t\t} \n\n\t\tfor(int i = x[key-1]; i < temp.length; i++){\n\t\t\tif( temp[i] ){\n\t\t\t\tx[key-1] = i+1;\n\t\t\t\ttemp[i] = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\t\t\n\t\tint count = 0;\n\t\tfor(int i = 0; i < temp.length; i++){\n\t\t\tif( temp[i] ){\n\t\t\t\tx[key+count] = i+1;\n\t\t\t\tcount++;\n\t\t\t}\n\t\t}\t\t\t\n\t\treturn x;\n\t}\n\t\t\t\n\tpublic  void solve() throws IOException{\n\t\tint n = nextInt();\n\t\tlong start = System.currentTimeMillis();\n\t\tint[][] data = new int[n][3];\t\t\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tdata[i][0] = nextInt();\n\t\t\tdata[i][1] = nextInt();\n\t\t\tdata[i][2] = nextInt();\t\t\t\n\t\t}\n\t\tsort(data);\t\t\n\t\tint[] x = new int[n];\n\t\tfor(int i = 0; i < x.length; i++){\n\t\t\tx[i] = i+1;\n\t\t}\n\t\tdouble min = 1000000001;\n\t\tint[] ans = new int[n];\n\t\tSystem.arraycopy(x, 0, ans, 0, n);\n\t\tint count = 0;\n\t\twhile( x[0] > 0 ){\n\t\t\tcount++;\n\t\t\tint[] total = new int[n];\n\t\t\tint high = data[x[n-1]-1][1];\n\t\t\tint low = high;\n\t\t\tfor(int i = n-2; i >= 0; i--){\n\t\t\t\tint a = data[x[i]-1][1];\t\t\n\t\t\t\thigh = Math.max(high, a);\n\t\t\t\tlow = Math.min(low, a);\n\t\t\t\ttotal[i] = high+low+Math.min(high-a, a-low);\n\t\t\t}\t\t\n\t\t\tdouble sum = 0;\n\t\t\tdouble w = 0;\n\t\t\tdouble v = (double)2000/70;\t\n\t\t\tint i = 0;\t\t\n\t\t\tfor(; i < x.length-1; i++){\n\t\t\t\tif( sum + total[i]/v > min ){\n\t//\t\t\t\twriter.println(\"cut at \" + i + \", v = \" + v + \", sum = \" + sum);\n\t\t\t\t\tsum = min;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tint len = Math.abs(data[x[i]-1][1]-data[x[i+1]-1][1]);\n\t\t\t\tw += 20*data[x[i]-1][2];\n\t\t\t\tv = 2000/(70+w);\n\t\t\t\tsum += len/v;\t\t\t\t\t\t\t\t\n\t\t\t}\n\t\t\tif( sum < min ){\n\t\t\t\tSystem.arraycopy(x, 0, ans, 0, n);\n\t\t\t\tmin = sum;\n\t\t\t}\n\t\t\ti = Math.min(i, n-1);\n\t\t\tx = nextPermutation(x, i);\t\t\t\n\t\t}\n\t\twriter.println(count);\n\t\twriter.println(min);\n\t\twriter.print(data[ans[0]-1][0]);\n\t\tfor(int i = 1; i < n; i++){\n\t\t\twriter.print(\" \" + data[ans[i]-1][0]);\n\t\t}\n\t\twriter.println();\t\n\t\tlong fin = System.currentTimeMillis();\n\t\twriter.println(fin-start);\t\n\t\twriter.flush();\t\t\t\n\t}\n\tpublic static void main (String args[]) throws IOException{\n\t\tnew Main().run();\n\t}\n\t\n\tBufferedReader reader;\n\tStringTokenizer tokenizer;\n\tPrintWriter writer;\n\t\n\tpublic void run() throws IOException{\n\t\ttry{\n\t\t\treader = new BufferedReader(new InputStreamReader(System.in));\n\t\t\ttokenizer = null;\n\t\t\twriter = new PrintWriter(System.out);\n\t\t\tsolve();\n\t\t\treader.close();\n\t\t\twriter.close();\n\t\t} catch (Exception e){\n\t\t\te.printStackTrace();\n\t\t\tSystem.exit(1);\n\t\t}\n\t}\n\tpublic int nextInt() throws IOException{\n\t\treturn Integer.parseInt(nextToken());\n\t}\t\t\n\tpublic String nextToken() throws IOException{\n\t\twhile( tokenizer == null || !tokenizer.hasMoreTokens() ){\n\t\t\ttokenizer = new StringTokenizer(reader.readLine());\n\t\t}\n\t\treturn tokenizer.nextToken();\n\t}\n}", "sampled": "import java.util.*;\n\npublic class Main {\n    static class Warehouse {\n        int id;\n        int distance;\n        int boxes;\n        \n        Warehouse(int id, int distance, int boxes) {\n            this.id = id;\n            this.distance = distance;\n            this.boxes = boxes;\n        }\n    }\n    \n    static int n;\n    static Warehouse[] warehouses;\n    static double minTime;\n    static int[] bestOrder;\n    \n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        n = sc.nextInt();\n        warehouses = new Warehouse[n];\n        \n        for (int i = 0; i < n; i++) {\n            int id = sc.nextInt();\n            int distance = sc.nextInt();\n            int boxes = sc.nextInt();\n            warehouses[i] = new Warehouse(id, distance, boxes);\n        }\n        \n        minTime = Double.MAX_VALUE;\n        bestOrder = new int[n];\n        \n        permute(new ArrayList<>(), new boolean[n], 0);\n        \n        for (int i = 0; i < n; i++) {\n            if (i > 0) System.out.print(\" \");\n            System.out.print(bestOrder[i]);\n        }\n        System.out.println();\n    }\n    \n    static void permute(List<Integer> current, boolean[] used, int depth) {\n        if (depth == n) {\n            double time = calculateTime(current);\n            if (time < minTime) {\n                minTime = time;\n                for (int i = 0; i < n; i++) {\n                    bestOrder[i] = warehouses[current.get(i)].id;\n                }\n            }\n            return;\n        }\n        \n        for (int i = 0; i < n; i++) {\n            if (!used[i]) {\n                used[i] = true;\n                current.add(i);\n                permute(current, used, depth + 1);\n                current.remove(current.size() - 1);\n                used[i] = false;\n            }\n        }\n    }\n    \n    static double calculateTime(List<Integer> order) {\n        double totalTime = 0.0;\n        int totalWeight = 0;\n        \n        for (int i = 0; i < n - 1; i++) {\n            int currentIdx = order.get(i);\n            int nextIdx = order.get(i + 1);\n            \n            totalWeight += warehouses[currentIdx].boxes * 20;\n            \n            int distance = Math.abs(warehouses[nextIdx].distance - warehouses[currentIdx].distance);\n            double speed = 2000.0 / (70.0 + totalWeight);\n            double time = distance / speed;\n            \n            totalTime += time;\n        }\n        \n        return totalTime;\n    }\n}\n", "perturbed_sampled": ["import  static class Warehouse { int id; int  int  = id;  boxes; } }  warehouses; static double minTime; static  sc = new Scanner(System.in); n = sc.nextInt();    id  sc.nextInt(); int boxes = sc.nextInt(); warehouses[i]  }   i = 0; i < n; i++)  System.out.print(\" \"); System.out.print(bestOrder[i]); } System.out.println(); }  used, int depth) {   (time < minTime) {    =  used[i] = true; current.add(i); permute(current,  -  calculateTime(List<Integer> order) { double  i = 0; i < n  currentIdx = order.get(i); int nextIdx =    speed = 2000.0 / (70.0  distance / speed;  totalTime; } }"], "perturbed_original": ["import  =  int min = i; for(int j = i+1; j <  data[j][2] ){ min = j; } else if(  data[min][1] > data[j][1] ){ min = j; }  data[min][j]; data[min][j] = data[i][j]; data[i][j] =  int[] nextPermutation(int[] x, int index){ int max = index; boolean[] temp = new boolean[x.length]; for(int i = index; i < x.length; i++){ temp[x[i]-1]  x[max] ){ max =  = index+1; if( max == index ){ for(; index > 0; index--){ temp[x[index-1]-1] = true; if( x[index]  0 ){ x[0]    temp[i] = false; break; }   temp[i] ){ x[key+count] = i+1; count++;   i++){ data[i][0]  data[i][2]  x  = 0; i <  } double min = 1000000001; int[] ans = new int[n]; System.arraycopy(x, 0, ans, 0, n);  count++; int[] total =   for(int i  sum +   +  v + \", sum = \" + sum);  int len  v = 2000/(70+w); sum += len/v; } if( sum < min ){  x =  writer.print(data[ans[0]-1][0]); for(int i = 1; i < n;  } public static void main  Main().run(); } BufferedReader  public void run()   null; writer = new PrintWriter(System.out); solve(); reader.close();  e.printStackTrace(); System.exit(1); } }  return Integer.parseInt(nextToken());  IOException{ while(   }"], "original_ll": -0.8479388952255249, "sampled_ll": -0.5018692016601562, "all_perturbed_sampled_ll": [-3.57259464263916], "all_perturbed_original_ll": [-2.6076769828796387], "perturbed_sampled_ll": -3.57259464263916, "perturbed_original_ll": -2.6076769828796387, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "n = int(input())\nD = [list(map(int, input().split())) for i in range(n)]\n# [cost, order]\nmemo = {(2**n-1, i): (0, ()) for i in range(n)}\ndef dfs(state, pos, w):\n    if (state, pos) in memo:\n        return memo[state, pos]\n    res = None\n    for i in range(n):\n        if (state >> i) & 1 == 0:\n            d0 = D[pos][1]\n            s, d1, v = D[i]\n            r = dfs(state | (1 << i), i, w + 20*v)\n            val = (r[0]+abs(d0-d1)*(70+w), r[1]+(s,))\n            if res is None or val < res:\n                res = val\n    if res:\n        memo[state, pos] = res\n    return res\ndef solve():\n    for i in range(n):\n        s0, d0, v0 = D[i]\n        result = dfs(1 << i, i, 20*v0)\n        yield result[0], result[1]+(s0,)\nans = min(solve())\nprint(*reversed(ans[1]))", "sampled": "from itertools import permutations\n\ndef calculate_time(order, warehouses):\n    total_time = 0\n    current_pos = 0\n    current_weight = 0\n    \n    for i, idx in enumerate(order):\n        warehouse = warehouses[idx]\n        pos = warehouse[1]\n        boxes = warehouse[2]\n        \n        # Move to this warehouse\n        distance = abs(pos - current_pos)\n        speed = 2000 / (70 + current_weight)\n        time = distance / speed\n        total_time += time\n        \n        # Pick up boxes\n        current_weight += boxes * 20\n        current_pos = pos\n    \n    return total_time\n\nn = int(input())\nwarehouses = []\nfor _ in range(n):\n    parts = list(map(int, input().split()))\n    warehouses.append((parts[0], parts[1], parts[2]))\n\nmin_time = float('inf')\nbest_order = None\n\nfor perm in permutations(range(n)):\n    time = calculate_time(perm, warehouses)\n    if time < min_time:\n        min_time = time\n        best_order = perm\n\nresult = [warehouses[i][0] for i in best_order]\nprint(' '.join(map(str, result)))\n", "perturbed_sampled": ["from    enumerate(order):  # Move to this warehouse distance  distance /  Pick up boxes current_weight  =  int(input()) warehouses  range(n):  parts[1], parts[2])) min_time = float('inf') best_order = None for perm in permutations(range(n)): time = calculate_time(perm, warehouses) if time < min_time:  perm result = [warehouses[i][0] for  result)))"], "perturbed_original": ["n = int(input()) D = [list(map(int, input().split())) for  order] memo = {(2**n-1,   pos]  in range(n): if (state >> i) & 1  D[i] r = dfs(state | (1 << i),  = (r[0]+abs(d0-d1)*(70+w),  res: memo[state, pos]  = D[i] result = dfs(1 << i, i, 20*v0) yield  print(*reversed(ans[1]))"], "original_ll": -1.4479782581329346, "sampled_ll": -1.0304558277130127, "all_perturbed_sampled_ll": [-4.027489185333252], "all_perturbed_original_ll": [-3.5257272720336914], "perturbed_sampled_ll": -4.027489185333252, "perturbed_original_ll": -3.5257272720336914, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "main(){\n\tint n,c=0;\n\twhile(~scanf(\"%d\",&n)){\n\t\tif(n==95)c++;\n\t}\n\treturn (c?1:0);\n}", "sampled": "#include <stdio.h>\n\ntypedef struct {\n    int group_id;\n    int leave_time;\n} Seat;\n\ntypedef struct {\n    int group_id;\n    int arrival_time;\n    int size;\n    int eating_time;\n} Group;\n\nint main() {\n    int n;\n    \n    while (scanf(\"%d\", &n) != EOF) {\n        Seat seats[17];\n        Group groups[100];\n        int queue[100];\n        int queue_front = 0, queue_rear = 0;\n        \n        // Initialize seats\n        for (int i = 0; i < 17; i++) {\n            seats[i].group_id = -1;\n            seats[i].leave_time = -1;\n        }\n        \n        // Initialize groups\n        for (int i = 0; i < 100; i++) {\n            groups[i].group_id = i;\n            groups[i].arrival_time = 5 * i;\n            groups[i].size = (i % 5 == 1) ? 5 : 2;\n            groups[i].eating_time = 17 * (i % 2) + 3 * (i % 3) + 19;\n        }\n        \n        int seated_time[100];\n        for (int i = 0; i < 100; i++) {\n            seated_time[i] = -1;\n        }\n        \n        int next_arrival = 0;\n        int time = 0;\n        \n        while (1) {\n            // Process departures\n            for (int i = 0; i < 17; i++) {\n                if (seats[i].group_id != -1 && seats[i].leave_time == time) {\n                    seats[i].group_id = -1;\n                    seats[i].leave_time = -1;\n                }\n            }\n            \n            // Try to seat groups from queue\n            while (queue_front < queue_rear) {\n                int gid = queue[queue_front];\n                int size = groups[gid].size;\n                \n                // Find continuous empty seats\n                int found = -1;\n                for (int start = 0; start <= 17 - size; start++) {\n                    int ok = 1;\n                    for (int j = 0; j < size; j++) {\n                        if (seats[start + j].group_id != -1) {\n                            ok = 0;\n                            break;\n                        }\n                    }\n                    if (ok) {\n                        found = start;\n                        break;\n                    }\n                }\n                \n                if (found != -1) {\n                    // Seat the group\n                    for (int j = 0; j < size; j++) {\n                        seats[found + j].group_id = gid;\n                        seats[found + j].leave_time = time + groups[gid].eating_time;\n                    }\n                    seated_time[gid] = time;\n                    queue_front++;\n                } else {\n                    break;\n                }\n            }\n            \n            // Handle arrivals at this time\n            while (next_arrival < 100 && groups[next_arrival].arrival_time == time) {\n                int gid = next_arrival;\n                int size = groups[gid].size;\n                \n                if (queue_front < queue_rear) {\n                    // Queue exists, join queue\n                    queue[queue_rear++] = gid;\n                } else {\n                    // Try to seat immediately\n                    int found = -1;\n                    for (int start = 0; start <= 17 - size; start++) {\n                        int ok = 1;\n                        for (int j = 0; j < size; j++) {\n                            if (seats[start + j].group_id != -1) {\n                                ok = 0;\n                                break;\n                            }\n                        }\n                        if (ok) {\n                            found = start;\n                            break;\n                        }\n                    }\n                    \n                    if (found != -1) {\n                        // Seat immediately\n                        for (int j = 0; j < size; j++) {\n                            seats[found + j].group_id = gid;\n                            seats[found + j].leave_time = time + groups[gid].eating_time;\n                        }\n                        seated_time[gid] = time;\n                    } else {\n                        // Join queue\n                        queue[queue_rear++] = gid;\n                    }\n                }\n                \n                next_arrival++;\n            }\n            \n            // Check if we're done\n            if (seated_time[n] != -1) {\n                break;\n            }\n            \n            time++;\n        }\n        \n        printf(\"%d\\n\", seated_time[n] - groups[n].arrival_time);\n    }\n    \n    return 0;\n}\n", "perturbed_sampled": ["#include <stdio.h> typedef struct  } Seat; typedef struct { int group_id;  eating_time; } Group;  while (scanf(\"%d\", &n)  Group   (int i = 0; i < 17; i++) { seats[i].group_id =  groups[i].eating_time = 17 * (i % 2) + 3 * (i %  seated_time[100]; for (int i =  { seated_time[i]  = 0; int  { // Process departures  } }  size = groups[gid].size; // Find continuous empty seats int found  = 0; start <= 17 - size; start++) {  (int j = 0; j < size; j++) { if (seats[start + j].group_id != -1) { ok =  start; break; }  {    seats[found + j].leave_time = time + groups[gid].eating_time; } seated_time[gid] = time; queue_front++; } else  Handle arrivals at this time while  gid  groups[gid].size; if (queue_front < queue_rear) { //  = gid; } else  immediately int found = -1; for (int start = 0;  start++) { int   size; j++) { if  { ok = 0; break;  j = 0; j < size; j++)   else { //  }  break; }  groups[n].arrival_time); } return 0; }"], "perturbed_original": ["main(){ int n,c=0;  }"], "original_ll": -2.3260116577148438, "sampled_ll": -0.6059977412223816, "all_perturbed_sampled_ll": [-2.877995729446411], "all_perturbed_original_ll": [-4.143065452575684], "perturbed_sampled_ll": -2.877995729446411, "perturbed_original_ll": -4.143065452575684, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.List;\n\npublic class Main {\n\n\t/** \u5bfe\u8c61\u5916 */\n\tprivate static final int EXEMPT = -1;\n\n\t/** \u30b0\u30eb\u30fc\u30d7\u6570 */\n\tprivate static final int GROUP_NUM = 100;\n\n\t/** \u6a19\u6e96\u5165\u529b */\n\tprivate static BufferedReader br;\n\n\t/** \u5ea7\u5e2d\u6570 \u6700\u5f8c\u306e\u5ea7\u5e2d\u756a\u53f7 */\n\tprivate static int seatsNum, firstSeatNum;\n\n\t/** \u5230\u7740\u6642\u9593 \u5ba2\u6570 \u98df\u4e8b\u6642\u9593 \u5f85\u3061\u6642\u9593 */\n\tprivate static int[] arriveMinutes, customersNum, mealMinutes, waitMinutes;\n\n\t/** \u5ea7\u5e2d */\n\tprivate static String[] seats;\n\n\t/** \u521d\u671f\u5316 */\n\tstatic {\n\n\t\tbr = new BufferedReader(new InputStreamReader(System.in));\n\t\tseatsNum = 17;\n\t\tarriveMinutes = new int[GROUP_NUM];\n\t\tcustomersNum = new int[GROUP_NUM];\n\t\tmealMinutes = new int[GROUP_NUM];\n\t\twaitMinutes = new int[GROUP_NUM];\n\t\tseats = new String[seatsNum];\n\n\t\tfor (int i = 0; i < GROUP_NUM; i++) {\n\t\t\t// \u30b0\u30eb\u30fc\u30d7\u6570\u5206\u7e70\u308a\u8fd4\u3059\n\n\t\t\t// \u5230\u7740\u6642\u9593\n\t\t\tarriveMinutes[i] = 5 * i;\n\n\t\t\t// \u4eba\u6570\n\t\t\tcustomersNum[i] = i % 5 == 1 ? 5 : 2;\n\n\t\t\t// \u98df\u4e8b\u6642\u9593\n\t\t\tmealMinutes[i] = seatsNum * (i % 2) + 3 * (i % 3) + 19;\n\n\t\t}\n\n\t\t// \u5f85\u3061\u6642\u9593\u3092\u4f5c\u6210\n\t\tcreateWaitMinutes();\n\n\t}\n\n\t/** \u5f85\u3061\u6642\u9593\u3092\u4f5c\u6210\u3059\u308b */\n\tprivate static void createWaitMinutes() {\n\t\t// \u9806\u756a\n\t\tint groupOrder;\n\n\t\t// \u884c\u5217\u30ea\u30b9\u30c8\n\t\tList<Integer> waitList = new ArrayList<Integer>();\n\n\t\t// \u884c\u5217\u6392\u9664\u30ea\u30b9\u30c8\n\t\tList<Integer> removeList = new ArrayList<Integer>();\n\n\t\tfor (int currentMinutes = 0, totalGroupNum = 0; totalGroupNum < GROUP_NUM; currentMinutes++) {\n\t\t\t// \u884c\u5217\u304c\u7d42\u4e86\u3059\u308b\u307e\u3067\u3001\u4e00\u5206\u6bce\u306b\u7e70\u308a\u8fd4\u3059\n\n\t\t\t// \u98df\u4e8b\u306e\u6642\u9593\u304c\u7d42\u4e86\u3057\u305f\u5ba2\u3092\u96e2\u5e2d\u3055\u305b\u308b\n\t\t\toutCustomer(currentMinutes);\n\n\t\t\tif ((groupOrder = searchGroupNum(arriveMinutes, currentMinutes)) != EXEMPT) {\n\t\t\t\t// \u5230\u7740\u6642\u9593\u306e\u5834\u5408\n\n\t\t\t\tif (waitList.isEmpty()) {\n\t\t\t\t\t// \u884c\u5217\u304c\u306a\u3044\u5834\u5408\n\n\t\t\t\t\tif (isEmpty(groupOrder)) {\n\t\t\t\t\t\t// \u7740\u5e2d\u53ef\u80fd\u306e\u5834\u5408\n\n\t\t\t\t\t\t// \u5ea7\u5e2d\u306b\u7740\u5e2d\u3055\u305b\u308b\n\t\t\t\t\t\tsetSeat(Integer.toString(groupOrder), totalGroupNum);\n\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// \u7740\u5e2d\u4e0d\u53ef\u306e\u5834\u5408\n\n\t\t\t\t\t\t// \u884c\u5217\u306b\u4e26\u3070\u305b\u308b\n\t\t\t\t\t\twaitList.add(groupOrder);\n\t\t\t\t\t}\n\n\t\t\t\t} else {\n\t\t\t\t\t// \u884c\u5217\u304c\u3042\u308b\u5834\u5408\n\n\t\t\t\t\t// \u884c\u5217\u306b\u4e26\u3070\u305b\u308b\n\t\t\t\t\twaitList.add(groupOrder);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (!waitList.isEmpty()) {\n\t\t\t\t// \u884c\u5217\u304c\u3042\u308b\u5834\u5408\n\n\t\t\t\tfor (int index = 0; index < waitList.size(); index++) {\n\t\t\t\t\t// \u884c\u5217\u30ea\u30b9\u30c8\u5206\u3001\u7e70\u308a\u8fd4\u3059\n\n\t\t\t\t\tif (isEmpty(waitList.get(index))) {\n\t\t\t\t\t\t// \u7740\u5e2d\u53ef\u80fd\u306e\u5834\u5408\n\n\t\t\t\t\t\t// \u5ea7\u5e2d\u306b\u7740\u5e2d\u3055\u305b\u308b\n\t\t\t\t\t\tsetSeat(Integer.toString(waitList.get(index)), totalGroupNum);\n\n\t\t\t\t\t\t// \u5f85\u3063\u305f\u6642\u9593\u3092\u8a2d\u5b9a\u3059\u308b\n\t\t\t\t\t\twaitMinutes[waitList.get(index)] = currentMinutes\n\t\t\t\t\t\t\t\t- arriveMinutes[waitList.get(index)];\n\n\t\t\t\t\t\t// \u7740\u5e2d\u3057\u305f\u30b0\u30eb\u30fc\u30d7\u3092\u884c\u5217\u6392\u9664\u30ea\u30b9\u30c8\u306b\u8ffd\u52a0\u3059\u308b\n\t\t\t\t\t\tremoveList.add(index);\n\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// \u7740\u5e2d\u4e0d\u53ef\u306e\u5834\u5408\n\n\t\t\t\t\t\t// \u884c\u5217\u306e\u5148\u982d\u304c\u7740\u5e2d\u3067\u304d\u306a\u3044\u305f\u3081\u3001\u6b8b\u308a\u306e\u884c\u5217\u3082\u7740\u5e2d\u4e0d\u53ef\u306b\u3059\u308b\u3002\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (!removeList.isEmpty()) {\n\t\t\t\t// \u884c\u5217\u6392\u9664\u30ea\u30b9\u30c8\u306b\u7740\u5e2d\u3057\u305f\u30b0\u30eb\u30fc\u30d7\u304c\u8ffd\u52a0\u3055\u308c\u3066\u3044\u305f\u5834\u5408\n\n\t\t\t\t// \u30ea\u30b9\u30c8\u306e\u964d\u9806\u3067\u30bd\u30fc\u30c8\u3059\u308b\uff08\u30ea\u30e0\u30fc\u30d6\u3059\u308b\u305f\u3081\uff09\n\t\t\t\tCollections.reverse(removeList);\n\n\t\t\t\tfor (int remove : removeList) {\n\t\t\t\t\t// \u884c\u5217\u6392\u9664\u30ea\u30b9\u30c8\u5206\u3001\u7e70\u308a\u8fd4\u3059\n\n\t\t\t\t\t// \u884c\u5217\u30ea\u30b9\u30c8\u304b\u3089\u884c\u5217\u6392\u9664\u30ea\u30b9\u30c8\u306e\u756a\u53f7\u3092\u524a\u9664\u3059\u308b\n\t\t\t\t\twaitList.remove(remove);\n\t\t\t\t}\n\n\t\t\t\t// \u521d\u671f\u5316\n\t\t\t\tremoveList = new ArrayList<Integer>();\n\t\t\t}\n\t\t}\n\t}\n\n\t/** \u30e1\u30a4\u30f3 */\n\tpublic static void main(String[] args) throws IOException {\n\t\tString line;\n\t\tList<Integer> inputList = new ArrayList<Integer>();\n\n\t\twhile (!isNull(line = br.readLine()) && !line.isEmpty()) {\n\t\t\tinputList.add(Integer.parseInt(line));\n\t\t}\n\t\tfor (int input : inputList) {\n\t\t\tSystem.out.println(waitMinutes[input]);\n\t\t}\n\n\t}\n\n\t/** \u73fe\u5728\u6642\u9593\u306b\u5230\u7740\u3059\u308b\u30b0\u30eb\u30fc\u30d7\u756a\u53f7\u3092\u691c\u7d22\u3057\u8fd4\u3059 */\n\tprivate static int searchGroupNum(int[] targets, int currentMinutes) {\n\t\tint order = 0;\n\t\tfor (int target : targets) {\n\t\t\tif (isSame(target, currentMinutes)) {\n\t\t\t\treturn order;\n\t\t\t}\n\t\t\torder++;\n\t\t}\n\t\treturn EXEMPT;\n\t}\n\n\t/** \u96e2\u5e2d\u3055\u305b\u308b */\n\tprivate static void outCustomer(int currentMinutes) {\n\n\t\tfor (int seatNum = 0; seatNum < seats.length; seatNum++) {\n\t\t\t// \u5ea7\u5e2d\u6570\u5206\u7e70\u308a\u8fd4\u3059\n\n\t\t\tif (isNull(seats[seatNum])) {\n\t\t\t\t// \u7a7a\u5e2d\u306e\u5834\u5408\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (finishedMeal(currentMinutes, seats[seatNum])) {\n\t\t\t\t// \u98df\u4e8b\u306e\u6642\u9593\u304c\u7d42\u4e86\u3057\u305f\u5834\u5408\n\n\t\t\t\t// \u7a7a\u5e2d\u306b\u3059\u308b\n\t\t\t\tseats[seatNum] = null;\n\t\t\t}\n\t\t}\n\n\t}\n\n\t/** \u5f15\u6570\u304cnull\u304b\u7a7a\u767d\u306e\u5834\u5408\u3001true\u3092\u8fd4\u3059 */\n\tprivate static boolean isNull(String param) {\n\t\treturn param == null;\n\t}\n\n\t/** \u98df\u4e8b\u306e\u6642\u9593\u304c\u7d42\u4e86\u3057\u305f\u5ea7\u5e2d\u306e\u5834\u5408\u3001true\u3092\u8fd4\u3059 */\n\tprivate static boolean finishedMeal(int currentMinutes, String seat) {\n\t\treturn currentMinutes\n\t\t\t\t- (arriveMinutes[Integer.parseInt(seat)] + waitMinutes[Integer\n\t\t\t\t\t\t.parseInt(seat)]) >= mealMinutes[Integer.parseInt(seat)];\n\t}\n\n\t/** \u7740\u5e2d\u3055\u305b\u308b */\n\tprivate static void setSeat(String groupOrder, int totalGroupNum) {\n\n\t\tfor (int count = 0; count < customersNum[Integer.parseInt(groupOrder)]; count++) {\n\t\t\t// \u7740\u5e2d\u3059\u308b\u4eba\u6570\u5206\u7e70\u308a\u8fd4\u3059\n\n\t\t\t// \u5ea7\u5e2d\u306b\u30b0\u30eb\u30fc\u30d7\u756a\u53f7\u3092\u8a2d\u5b9a\u3059\u308b\n\t\t\tseats[firstSeatNum++] = groupOrder;\n\t\t}\n\t\ttotalGroupNum++;\n\t}\n\n\t/** \u5f15\u6570\u306e\u30b0\u30eb\u30fc\u30d7\u756a\u53f7\u306e\u5ba2\u6570\u5206\u3001\u7a7a\u5e2d\u304b\u3069\u3046\u304b\u78ba\u8a8d\u3059\u308b */\n\tprivate static boolean isEmpty(int groupsNum) {\n\n\t\t// \u7a7a\u5e2d\u6570\n\t\tint emptyseatsNum = 0;\n\t\tint i = 0;\n\n\t\tfor (; i < seatsNum || customersNum[groupsNum] <= seatsNum - i; i++) {\n\t\t\t// \u6b8b\u5ea7\u5e2d\u6570\u304c\u5ba2\u306e\u6570\u4ee5\u4e0b\u306b\u306a\u308b\u307e\u3067\u5ea7\u5e2d\u6570\u5206\u7e70\u308a\u8fd4\u3059\n\n\t\t\tif (isSame(customersNum[groupsNum], emptyseatsNum)) {\n\t\t\t\t// \u9023\u7d9a\u3057\u305f\u7a7a\u5e2d\u304c\u5ba2\u306e\u6570\u3060\u3051\u3042\u3063\u305f\u5834\u5408\n\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t\tif (isNull(seats[i])) {\n\t\t\t\t// \u7a7a\u5e2d\u304b\u3064\u7e70\u308a\u8fd4\u3059\u5e2d\u304c\u9867\u5ba2\u6570\u5206\u4ee5\u4e0a\u5b58\u5728\u3059\u308b\u5834\u5408\n\n\t\t\t\temptyseatsNum++;\n\n\t\t\t\tcontinue;\n\n\t\t\t} else {\n\t\t\t\t// \u7a7a\u5e2d\u3067\u306a\u3044\u5834\u5408\n\n\t\t\t\t// \u7a7a\u5e2d\u6570\u3092\u521d\u671f\u5316\n\t\t\t\temptyseatsNum = 0;\n\t\t\t}\n\t\t}\n\t\tif (isSame(customersNum[groupsNum], emptyseatsNum)) {\n\t\t\t// \u7a7a\u5e2d\u306e\u6700\u521d\u306e\u5ea7\u5e2d\u756a\u53f7\u3092\u8a2d\u5b9a\u3059\u308b\n\t\t\tfirstSeatNum = i - emptyseatsNum;\n\t\t\treturn true;\n\t\t}\n\n\t\treturn false;\n\t}\n\n\t/** \u7b2c\u4e00\u5f15\u6570\u3068\u7b2c\u4e8c\u5f15\u6570\u304c\u540c\u3058\u5834\u5408\u3001true\u3092\u8fd4\u3059 */\n\tprivate static boolean isSame(int param, int target) {\n\t\treturn param == target;\n\t}\n}", "sampled": "import java.util.*;\n\npublic class Main {\n    static class Group {\n        int id;\n        int arrivalTime;\n        int size;\n        int eatingTime;\n        int seatedTime;\n        \n        Group(int id) {\n            this.id = id;\n            this.arrivalTime = 5 * id;\n            this.size = (id % 5 == 1) ? 5 : 2;\n            this.eatingTime = 17 * (id % 2) + 3 * (id % 3) + 19;\n            this.seatedTime = -1;\n        }\n    }\n    \n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        \n        while (sc.hasNext()) {\n            int n = sc.nextInt();\n            System.out.println(simulate(n));\n        }\n        sc.close();\n    }\n    \n    static int simulate(int targetGroup) {\n        int[] seats = new int[17];\n        Arrays.fill(seats, -1);\n        int[] leaveTime = new int[17];\n        \n        Group[] groups = new Group[100];\n        for (int i = 0; i < 100; i++) {\n            groups[i] = new Group(i);\n        }\n        \n        Queue<Group> queue = new LinkedList<>();\n        int nextGroupToArrive = 0;\n        \n        for (int time = 0; time <= 10000; time++) {\n            // Step 1: Process departures\n            for (int i = 0; i < 17; i++) {\n                if (seats[i] != -1 && leaveTime[i] == time) {\n                    seats[i] = -1;\n                }\n            }\n            \n            // Step 2: Seat groups from queue\n            while (!queue.isEmpty()) {\n                Group g = queue.peek();\n                int pos = findSeats(seats, g.size);\n                if (pos != -1) {\n                    queue.poll();\n                    for (int i = pos; i < pos + g.size; i++) {\n                        seats[i] = g.id;\n                        leaveTime[i] = time + g.eatingTime;\n                    }\n                    g.seatedTime = time;\n                } else {\n                    break;\n                }\n            }\n            \n            // Step 3: Process arrivals\n            while (nextGroupToArrive < 100 && groups[nextGroupToArrive].arrivalTime == time) {\n                Group g = groups[nextGroupToArrive];\n                nextGroupToArrive++;\n                \n                if (queue.isEmpty()) {\n                    int pos = findSeats(seats, g.size);\n                    if (pos != -1) {\n                        for (int i = pos; i < pos + g.size; i++) {\n                            seats[i] = g.id;\n                            leaveTime[i] = time + g.eatingTime;\n                        }\n                        g.seatedTime = time;\n                    } else {\n                        queue.offer(g);\n                    }\n                } else {\n                    queue.offer(g);\n                }\n            }\n            \n            if (groups[targetGroup].seatedTime != -1) {\n                return groups[targetGroup].seatedTime - groups[targetGroup].arrivalTime;\n            }\n        }\n        \n        return 0;\n    }\n    \n    static int findSeats(int[] seats, int size) {\n        for (int i = 0; i <= 17 - size; i++) {\n            boolean canSit = true;\n            for (int j = i; j < i + size; j++) {\n                if (seats[j] != -1) {\n                    canSit = false;\n                    break;\n                }\n            }\n            if (canSit) {\n                return i;\n            }\n        }\n        return -1;\n    }\n}\n", "perturbed_sampled": ["import java.util.*; public  Group { int id;  eatingTime;  this.size = (id % 5 == 1)  = 17 * (id % 2)  3) + 19;   new Scanner(System.in); while (sc.hasNext()) {  } sc.close(); } static int simulate(int targetGroup)  leaveTime = new int[17]; Group[] groups = new Group[100]; for  < 100;  = new LinkedList<>(); int  <=  1: Process departures for (int  17; i++) {  seats[i] = -1; } } // Step 2:  (pos != -1) { queue.poll(); for (int i = pos; i < pos + g.size; i++) { seats[i] =    g = groups[nextGroupToArrive]; nextGroupToArrive++; if  != -1) { for (int i = pos; i < pos +  g.id; leaveTime[i] = time +  } else  {  != -1) {   i++)  for (int j = i; j <  { canSit  if  } return -1; } }"], "perturbed_original": [" java.io.InputStreamReader; import java.util.ArrayList; import  Main {   /**  int GROUP_NUM = 100; /** \u6a19\u6e96\u5165\u529b */ private  \u6700\u5f8c\u306e\u5ea7\u5e2d\u756a\u53f7  */ private static String[] seats; /** \u521d\u671f\u5316 */ static { br = new BufferedReader(new InputStreamReader(System.in)); seatsNum = 17; arriveMinutes = new  0; i <  // \u5230\u7740\u6642\u9593 arriveMinutes[i] = 5 * i;   5 : 2; // \u98df\u4e8b\u6642\u9593 mealMinutes[i] = seatsNum  3 *  }  \u5f85\u3061\u6642\u9593\u3092\u4f5c\u6210\u3059\u308b  { // \u9806\u756a int groupOrder; // \u884c\u5217\u30ea\u30b9\u30c8  // \u884c\u5217\u6392\u9664\u30ea\u30b9\u30c8   < GROUP_NUM; currentMinutes++) {  // \u5230\u7740\u6642\u9593\u306e\u5834\u5408 if (waitList.isEmpty()) { // \u884c\u5217\u304c\u306a\u3044\u5834\u5408 if   \u884c\u5217\u306b\u4e26\u3070\u305b\u308b waitList.add(groupOrder); } }   for (int index = 0; index < waitList.size(); index++)   setSeat(Integer.toString(waitList.get(index)), totalGroupNum); //  \u7740\u5e2d\u4e0d\u53ef\u306e\u5834\u5408 // \u884c\u5217\u306e\u5148\u982d\u304c\u7740\u5e2d\u3067\u304d\u306a\u3044\u305f\u3081\u3001\u6b8b\u308a\u306e\u884c\u5217\u3082\u7740\u5e2d\u4e0d\u53ef\u306b\u3059\u308b\u3002 break; } } } if  \u30ea\u30b9\u30c8\u306e\u964d\u9806\u3067\u30bd\u30fc\u30c8\u3059\u308b\uff08\u30ea\u30e0\u30fc\u30d6\u3059\u308b\u305f\u3081\uff09 Collections.reverse(removeList); for (int  main(String[] args) throws IOException   = br.readLine())  for (int input : inputList) { System.out.println(waitMinutes[input]);  int order = 0; for  if (isSame(target, currentMinutes)) { return order; }  seats.length; seatNum++) { // \u5ea7\u5e2d\u6570\u5206\u7e70\u308a\u8fd4\u3059 if (isNull(seats[seatNum])) { // \u7a7a\u5e2d\u306e\u5834\u5408 continue; } if  // \u7a7a\u5e2d\u306b\u3059\u308b  private  return param == null; }   { return currentMinutes - (arriveMinutes[Integer.parseInt(seat)] + waitMinutes[Integer .parseInt(seat)]) >=  private static void setSeat(String groupOrder, int totalGroupNum) { for (int count = 0; count < customersNum[Integer.parseInt(groupOrder)]; count++) { //   i; i++) {  // \u7a7a\u5e2d\u304b\u3064\u7e70\u308a\u8fd4\u3059\u5e2d\u304c\u9867\u5ba2\u6570\u5206\u4ee5\u4e0a\u5b58\u5728\u3059\u308b\u5834\u5408 emptyseatsNum++; continue;  0; } } if (isSame(customersNum[groupsNum], emptyseatsNum)) { // \u7a7a\u5e2d\u306e\u6700\u521d\u306e\u5ea7\u5e2d\u756a\u53f7\u3092\u8a2d\u5b9a\u3059\u308b firstSeatNum = i - emptyseatsNum; return true; }  isSame(int param, int target) { return param == target; } }"], "original_ll": -1.139337420463562, "sampled_ll": -0.6518452763557434, "all_perturbed_sampled_ll": [-2.9131884574890137], "all_perturbed_original_ll": [-2.912109851837158], "perturbed_sampled_ll": -2.9131884574890137, "perturbed_original_ll": -2.912109851837158, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "# -*- coding: utf-8 -*-\n\"\"\"\nhttp://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=0147\n\n\"\"\"\nimport sys\nfrom sys import stdin\nfrom heapq import heappop, heappush\nfrom collections import deque\ninput = stdin.readline\n\n\nclass Seat():\n    def __init__(self, n):\n        self.seat = '_' * n\n\n    def get(self, num):\n        i = self.seat.find('_'*num)\n        if i != -1:\n            self.seat = self.seat[0:i] + 'o'*num + self.seat[i+num:]\n            return i\n        return None\n\n    def release(self, i, num):\n        self.seat = self.seat[0:i] + '_'*num + self.seat[i+num:]\n\n\ndef solve():\n    waiting_time = [-1] * 100\n    NUM_OF_SEAT = 17\n    seat = Seat(NUM_OF_SEAT)\n    LEAVE = 0\n    COME = 1\n    in_out = []                 #  ??\\?????????????????????????????????\n    Q = deque()                      #  ??\u00a7??????????????????\n    # 100???????????\\????????????????????????\n    for group_id in range(100):\n        if group_id % 5 == 1:\n            num = 5\n        else:\n            num = 2\n        heappush(in_out, (group_id * 5, COME, NUM_OF_SEAT+1, group_id, num))\n\n    while in_out:\n        time, event, start_seat, group_id, num = heappop(in_out)\n        if event == COME:\n            Q.append((time, group_id, num))\n        else:\n            seat.release(start_seat, num)\n        while Q:\n            res = seat.get(Q[0][2])\n            if res is not None:\n                arrive, group_id, num = Q.popleft()\n                waiting_time[group_id] = time - arrive\n                eating_time = 17 * (group_id % 2) + 3*(group_id % 3) + 19\n                heappush(in_out, (time + eating_time, LEAVE, res, group_id, num))\n            else:\n                break\n    return waiting_time\n\n\ndef main(args):\n    waiting_time = solve()\n\n    for line in sys.stdin:\n        print(waiting_time[int(line)])\n\n\nif __name__ == '__main__':\n    main(sys.argv[1:])\n    ", "sampled": "import sys\n\ndef solve(n):\n    # Initialize seats (17 seats, -1 means empty)\n    seats = [-1] * 17\n    # Queue of groups waiting\n    queue = []\n    # Dictionary to store group info: arrival_time, size, eat_time, seated_time\n    groups = {}\n    \n    # Generate all 100 groups\n    for i in range(100):\n        arrival = 5 * i\n        size = 5 if i % 5 == 1 else 2\n        eat_time = 17 * (i % 2) + 3 * (i % 3) + 19\n        groups[i] = {\n            'arrival': arrival,\n            'size': size,\n            'eat_time': eat_time,\n            'seated_time': None,\n            'leave_time': None\n        }\n    \n    # Simulate\n    max_time = 5 * 99 + 100  # Safe upper bound\n    \n    for t in range(max_time + 1):\n        # Step 1: Remove groups whose eating time is up\n        for seat_idx in range(17):\n            if seats[seat_idx] != -1:\n                group_id = seats[seat_idx]\n                if groups[group_id]['leave_time'] == t:\n                    seats[seat_idx] = -1\n        \n        # Step 2: Try to seat groups from queue\n        while queue:\n            group_id = queue[0]\n            size = groups[group_id]['size']\n            \n            # Find leftmost position where group can sit\n            seated = False\n            for start in range(18 - size):\n                if all(seats[start + j] == -1 for j in range(size)):\n                    # Seat the group\n                    for j in range(size):\n                        seats[start + j] = group_id\n                    groups[group_id]['seated_time'] = t\n                    groups[group_id]['leave_time'] = t + groups[group_id]['eat_time']\n                    queue.pop(0)\n                    seated = True\n                    break\n            \n            if not seated:\n                break\n        \n        # Step 3: Handle arriving groups\n        for i in range(100):\n            if groups[i]['arrival'] == t:\n                if queue:\n                    # Queue exists, join queue\n                    queue.append(i)\n                else:\n                    # No queue, try to seat directly\n                    size = groups[i]['size']\n                    seated = False\n                    for start in range(18 - size):\n                        if all(seats[start + j] == -1 for j in range(size)):\n                            # Seat the group\n                            for j in range(size):\n                                seats[start + j] = i\n                            groups[i]['seated_time'] = t\n                            groups[i]['leave_time'] = t + groups[i]['eat_time']\n                            seated = True\n                            break\n                    \n                    if not seated:\n                        queue.append(i)\n        \n        # Check if group n has been seated\n        if groups[n]['seated_time'] is not None:\n            wait_time = groups[n]['seated_time'] - groups[n]['arrival']\n            return wait_time\n    \n    return 0\n\n# Read input and process\nfor line in sys.stdin:\n    n = int(line.strip())\n    print(solve(n))\n", "perturbed_sampled": ["import sys  empty) seats = [-1] * 17 # Queue  [] # Dictionary to store group info:   else  (i % 2) + 3 *   'size':  * 99 + 100 # Safe   for seat_idx in  group_id = seats[seat_idx] if groups[group_id]['leave_time'] == t: seats[seat_idx] = -1 # Step  from queue while queue: group_id = queue[0] size = groups[group_id]['size'] # Find leftmost position where group can sit  in range(size)): # Seat the  groups[group_id]['leave_time']  seated = True break  Step 3: Handle arriving groups  queue: # Queue  # No queue, try to  seated  range(18 - size):  group for j in range(size):  groups[i]['seated_time'] = t groups[i]['leave_time'] =  True  if groups[n]['seated_time'] is not None: wait_time = groups[n]['seated_time'] - groups[n]['arrival'] return wait_time return 0 #  = int(line.strip()) print(solve(n))"], "perturbed_original": [" self.seat.find('_'*num) if   def release(self, i, num): self.seat  self.seat[i+num:] def solve(): waiting_time = [-1] * 100 NUM_OF_SEAT = 17 seat = Seat(NUM_OF_SEAT) LEAVE = 0 COME =  # ??\u00a7?????????????????? # 100???????????\\???????????????????????? for group_id in  == 1: num = 5 else: num = 2 heappush(in_out, (group_id *  while in_out: time, event, start_seat, group_id, num = heappop(in_out) if event  Q: res = seat.get(Q[0][2]) if res   % 2)  eating_time,  break return waiting_time def main(args): waiting_time = solve() for  __name__ == '__main__': main(sys.argv[1:])"], "original_ll": -1.3466238975524902, "sampled_ll": -1.0123385190963745, "all_perturbed_sampled_ll": [-3.253638982772827], "all_perturbed_original_ll": [-3.227003574371338], "perturbed_sampled_ll": -3.253638982772827, "perturbed_original_ll": -3.227003574371338, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "#include <stdio.h>\n\nint main(void)\n{\n\tint a,n,i;\n\tprintf(\"?????\u00a3????????\u00a3????????\u00b0?????\\?????????????????????\",a);\n\tscanf(\"%d\",&a) ;\n\ti=a%39;\n\tif(i==0)\n\t{\n\t\tprintf(\"????????????????????????\");\n\t}\n\telse\n\t{\n\t\tprintf(\"3C%d\\n\",i);\n\t}\n\treturn 0;\n}", "sampled": "#include <stdio.h>\n\nint main() {\n    int a;\n    while (scanf(\"%d\", &a) != EOF) {\n        int student = a % 39;\n        if (student == 0) {\n            student = 39;\n        }\n        printf(\"3C%02d\\n\", student);\n    }\n    return 0;\n}\n", "perturbed_sampled": ["#include  != EOF) { int student = a % 39; if  =  return 0; }"], "perturbed_original": [" int a,n,i;  { printf(\"3C%d\\n\",i); } return 0; }"], "original_ll": -1.992280125617981, "sampled_ll": -1.161375880241394, "all_perturbed_sampled_ll": [-4.683187007904053], "all_perturbed_original_ll": [-3.6601576805114746], "perturbed_sampled_ll": -4.683187007904053, "perturbed_original_ll": -3.6601576805114746, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import java.util.Scanner;\n\npublic class Main {\n\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\twhile(sc.hasNext()){\n\t\t\tSystem.out.printf(\"3C%01d\\n\",(sc.nextInt())%39);\n\t\t}\n\t}\n}", "sampled": "import java.util.Scanner;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        \n        while (sc.hasNext()) {\n            int candies = sc.nextInt();\n            int studentNumber = candies % 39;\n            \n            if (studentNumber == 0) {\n                studentNumber = 39;\n            }\n            \n            System.out.printf(\"3C%02d%n\", studentNumber);\n        }\n        \n        sc.close();\n    }\n}\n", "perturbed_sampled": ["import java.util.Scanner; public  void main(String[] args) { Scanner sc =  int  if (studentNumber ==   } }"], "perturbed_original": [" { public static void main(String[] args) {  }"], "original_ll": -1.4652525186538696, "sampled_ll": -1.006607174873352, "all_perturbed_sampled_ll": [-3.5554134845733643], "all_perturbed_original_ll": [-2.0887372493743896], "perturbed_sampled_ll": -3.5554134845733643, "perturbed_original_ll": -2.0887372493743896, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "try:\n    while True:\n        ame = int(input())\n        num1 = ame % 39\n        if num1 == 0:\n            num1 = 39\n        if num1 < 10:\n            print(\"3C0\" + str(num1))\n        else:\n            print(\"3C\" + str(num1))\nexcept EOFError as e:\n    num = 0\n", "sampled": "import sys\n\nfor line in sys.stdin:\n    a = int(line.strip())\n    student = a % 39\n    if student == 0:\n        student = 39\n    print(f\"3C{student:02d}\")\n", "perturbed_sampled": ["import sys for  == 0: student = 39 print(f\"3C{student:02d}\")"], "perturbed_original": [" %   str(num1)) else: print(\"3C\" + str(num1)) except EOFError as e: num = 0"], "original_ll": -1.4087200164794922, "sampled_ll": -1.704241156578064, "all_perturbed_sampled_ll": [-4.474724769592285], "all_perturbed_original_ll": [-3.6178650856018066], "perturbed_sampled_ll": -4.474724769592285, "perturbed_original_ll": -3.6178650856018066, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "#include <stdio.h>\n\nint rn[4], ln[4];\n\nint main(void)\n{\n\tdouble right, left;\n\tdouble EPS;\n\tint i;\n\t\n\tEPS = 1e-8;\n\t\n\twhile (scanf(\"%lf %lf\", &right, &left) != EOF){\n\t\t\n\t\tif (right >= 1.1){\n\t\t\trn[0]++;\n\t\t}\n\t\telse if (right >= 0.6){\n\t\t\trn[1]++;\n\t\t}\n\t\telse if(right >= 0.2){\n\t\t\trn[2]++;\n\t\t}\n\t\telse {\n\t\t\trn[3]++;\n\t\t}\n\t\tif (left >= 1.1){\n\t\t\tln[0]++;\n\t\t}\n\t\telse if (left >= 0.6){\n\t\t\tln[1]++;\n\t\t}\n\t\telse if(left >= 0.2){\n\t\t\tln[2]++;\n\t\t}\n\t\telse {\n\t\t\tln[3]++;\n\t\t}\n\t}\n\tfor (i = 0; i < 4; i++){\n\t\tprintf(\"%d %d\\n\", rn[i], ln[i]);\n\t}\n\treturn (0);\n}\n\t\t\t", "sampled": "#include <stdio.h>\n\nint main() {\n    double l, r;\n    int countA_L = 0, countA_R = 0;\n    int countB_L = 0, countB_R = 0;\n    int countC_L = 0, countC_R = 0;\n    int countD_L = 0, countD_R = 0;\n    \n    while (scanf(\"%lf %lf\", &l, &r) == 2) {\n        // Left eye\n        if (l >= 1.1) {\n            countA_L++;\n        } else if (l >= 0.6) {\n            countB_L++;\n        } else if (l >= 0.2) {\n            countC_L++;\n        } else {\n            countD_L++;\n        }\n        \n        // Right eye\n        if (r >= 1.1) {\n            countA_R++;\n        } else if (r >= 0.6) {\n            countB_R++;\n        } else if (r >= 0.2) {\n            countC_R++;\n        } else {\n            countD_R++;\n        }\n    }\n    \n    printf(\"%d %d\\n\", countA_L, countA_R);\n    printf(\"%d %d\\n\", countB_L, countB_R);\n    printf(\"%d %d\\n\", countC_L, countC_R);\n    printf(\"%d %d\\n\", countD_L, countD_R);\n    \n    return 0;\n}\n", "perturbed_sampled": [" countA_L = 0, countA_R  0, countB_R  0, countC_R  while (scanf(\"%lf %lf\", &l, &r) == 2) { // Left  {   else {  if (r  else if (r >= 0.6) { countB_R++;  0.2) { countC_R++; } else { countD_R++;  countA_R); printf(\"%d %d\\n\",  countD_R); return 0; }"], "perturbed_original": ["#include <stdio.h> int  double  i; EPS = 1e-8; while (scanf(\"%lf  if (right >= 1.1){ rn[0]++; } else if    for (i = 0; i < 4; i++){ printf(\"%d %d\\n\", rn[i], ln[i]); } return (0); }"], "original_ll": -0.8063955903053284, "sampled_ll": -0.40311920642852783, "all_perturbed_sampled_ll": [-2.390556812286377], "all_perturbed_original_ll": [-2.9980857372283936], "perturbed_sampled_ll": -2.390556812286377, "perturbed_original_ll": -2.9980857372283936, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import java.util.Arrays;\nimport java.util.Scanner;\n\n\npublic class Main {\n\n\tScanner sc;\n\t\n\tdouble nd(){\n\t\treturn sc.nextDouble();\n\t}\n\t\n\tvoid io(){\n\t\tsc=new Scanner (System.in);\n\t\t\n\t\tint[][] num=new int[4][2];\n\t\tfor(int[] e:num)Arrays.fill(e,0);\n\t\tint side=0;\n\t\t\n\t\twhile(sc.hasNext()){\n\t\t\tdouble eye=nd();\n\t\t\tif(eye>=1.1) ++num[0][side];\n\t\t\telse if(eye>=0.6) ++num[1][side];\n\t\t\telse if(eye>=0.2) ++num[2][side];\n\t\t\telse ++num[3][side];\n\t\t\tside^=1;\n\t\t}\n\t\tfor(int i=0;i<4;++i)System.out.println(num[i][0]+\" \"+num[i][1]);\n\t\t\n\t\tsc.close();\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\t// TODO Auto-generated method stub\n\t\tnew Main().io();\n\t}\n}", "sampled": "import java.util.Scanner;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        \n        int[] leftCount = new int[4];\n        int[] rightCount = new int[4];\n        \n        while (sc.hasNext()) {\n            double left = sc.nextDouble();\n            double right = sc.nextDouble();\n            \n            leftCount[getCategory(left)]++;\n            rightCount[getCategory(right)]++;\n        }\n        \n        for (int i = 0; i < 4; i++) {\n            System.out.println(leftCount[i] + \" \" + rightCount[i]);\n        }\n        \n        sc.close();\n    }\n    \n    private static int getCategory(double vision) {\n        if (vision >= 1.1) {\n            return 0; // A\n        } else if (vision >= 0.6) {\n            return 1; // B\n        } else if (vision >= 0.2) {\n            return 2; // C\n        } else {\n            return 3; // D\n        }\n    }\n}\n", "perturbed_sampled": ["import java.util.Scanner;  static void main(String[] args) {  int[] leftCount = new int[4]; int[] rightCount = new int[4]; while   i < 4; i++) { System.out.println(leftCount[i]   if (vision >= 1.1) { return 0; // A }    0.2) { return  {  } }"], "perturbed_original": ["import java.util.Arrays; import java.util.Scanner; public    int[][] num=new int[4][2]; for(int[] e:num)Arrays.fill(e,0); int side=0; while(sc.hasNext()){ double eye=nd(); if(eye>=1.1)  \"+num[i][1]); sc.close(); }  { // TODO Auto-generated  }"], "original_ll": -1.1762874126434326, "sampled_ll": -0.5471305847167969, "all_perturbed_sampled_ll": [-2.6441993713378906], "all_perturbed_original_ll": [-3.273984432220459], "perturbed_sampled_ll": -2.6441993713378906, "perturbed_original_ll": -3.273984432220459, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "c = [1.1,0.6,0.2,0.0]\nr = [0,0,0,0,0,0,0,0]\nwhile 1:\n    try:\n        e = map(float, raw_input().split())\n        for i in range(2):\n            for j in range(4):\n                if e[i] >= c[j]:\n                \tr[i+2*j] += 1\n                \tbreak\n    except:\n        break\nfor i in range(0,8,2):\n\tprint r[i],r[i+1]", "sampled": "import sys\n\ndef classify(vision):\n    if vision >= 1.1:\n        return 'A'\n    elif vision >= 0.6:\n        return 'B'\n    elif vision >= 0.2:\n        return 'C'\n    else:\n        return 'D'\n\nleft_count = {'A': 0, 'B': 0, 'C': 0, 'D': 0}\nright_count = {'A': 0, 'B': 0, 'C': 0, 'D': 0}\n\nfor line in sys.stdin:\n    l, r = map(float, line.strip().split())\n    left_count[classify(l)] += 1\n    right_count[classify(r)] += 1\n\nprint(left_count['A'], right_count['A'])\nprint(left_count['B'], right_count['B'])\nprint(left_count['C'], right_count['C'])\nprint(left_count['D'], right_count['D'])\n", "perturbed_sampled": ["   0.2: return 'C' else: return 'D' left_count = {'A':  'D': 0}  0, 'C': 0, 'D': 0}  r = map(float, line.strip().split())  1 print(left_count['A'],  print(left_count['D'], right_count['D'])"], "perturbed_original": ["c = [1.1,0.6,0.2,0.0] r =  i in  if e[i] >= c[j]: r[i+2*j] +=  r[i],r[i+1]"], "original_ll": -1.3346502780914307, "sampled_ll": -0.5886207222938538, "all_perturbed_sampled_ll": [-2.8002898693084717], "all_perturbed_original_ll": [-3.074204206466675], "perturbed_sampled_ll": -2.8002898693084717, "perturbed_original_ll": -3.074204206466675, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "m[4][65536],i,l,L,p,c;main(n){for(;~scanf(\"%d\\n\",&n);L=n&&!printf(\"%d\\n\",L))for(p=255;++p<256-~n*n;)for(c=getchar(i=4);i--;L=l>L?l:L)l=m[i][p]=c-49?0:m[i][p-(i?n+i-1:1)]+1;}", "sampled": "#include <stdio.h>\n#include <string.h>\n\nint main() {\n    int n;\n    char grid[256][256];\n    \n    while(scanf(\"%d\", &n) == 1 && n != 0) {\n        for(int i = 0; i < n; i++) {\n            scanf(\"%s\", grid[i]);\n        }\n        \n        int max_count = 0;\n        \n        // Check horizontal\n        for(int i = 0; i < n; i++) {\n            int count = 0;\n            for(int j = 0; j < n; j++) {\n                if(grid[i][j] == '1') {\n                    count++;\n                    if(count > max_count) max_count = count;\n                } else {\n                    count = 0;\n                }\n            }\n        }\n        \n        // Check vertical\n        for(int j = 0; j < n; j++) {\n            int count = 0;\n            for(int i = 0; i < n; i++) {\n                if(grid[i][j] == '1') {\n                    count++;\n                    if(count > max_count) max_count = count;\n                } else {\n                    count = 0;\n                }\n            }\n        }\n        \n        // Check diagonal (top-left to bottom-right)\n        // Starting from first row\n        for(int start_col = 0; start_col < n; start_col++) {\n            int count = 0;\n            int i = 0, j = start_col;\n            while(i < n && j < n) {\n                if(grid[i][j] == '1') {\n                    count++;\n                    if(count > max_count) max_count = count;\n                } else {\n                    count = 0;\n                }\n                i++;\n                j++;\n            }\n        }\n        // Starting from first column (excluding 0,0)\n        for(int start_row = 1; start_row < n; start_row++) {\n            int count = 0;\n            int i = start_row, j = 0;\n            while(i < n && j < n) {\n                if(grid[i][j] == '1') {\n                    count++;\n                    if(count > max_count) max_count = count;\n                } else {\n                    count = 0;\n                }\n                i++;\n                j++;\n            }\n        }\n        \n        // Check diagonal (top-right to bottom-left)\n        // Starting from first row\n        for(int start_col = 0; start_col < n; start_col++) {\n            int count = 0;\n            int i = 0, j = start_col;\n            while(i < n && j >= 0) {\n                if(grid[i][j] == '1') {\n                    count++;\n                    if(count > max_count) max_count = count;\n                } else {\n                    count = 0;\n                }\n                i++;\n                j--;\n            }\n        }\n        // Starting from last column (excluding 0,n-1)\n        for(int start_row = 1; start_row < n; start_row++) {\n            int count = 0;\n            int i = start_row, j = n - 1;\n            while(i < n && j >= 0) {\n                if(grid[i][j] == '1') {\n                    count++;\n                    if(count > max_count) max_count = count;\n                } else {\n                    count = 0;\n                }\n                i++;\n                j--;\n            }\n        }\n        \n        printf(\"%d\\n\", max_count);\n    }\n    \n    return 0;\n}\n", "perturbed_sampled": ["#include <stdio.h> #include <string.h> int  grid[256][256];  n != 0) { for(int i = 0; i < n; i++) { scanf(\"%s\", grid[i]); } int max_count = 0; // Check horizontal for(int i = 0; i < n; i++) { int count  0;     { int count = 0; for(int i =  { if(grid[i][j] == '1') { count++; if(count > max_count) max_count = count; } else { count  int i =  < n)  count++; if(count > max_count) max_count =  j++; } } // Starting  start_row < n; start_row++) { int count =   n && j < n) { if(grid[i][j] == '1') { count++;  count;  0; } i++; j++;  (top-right to bottom-left) // Starting from first row  <  &&  if(count > max_count) max_count = count; } else   (excluding 0,n-1) for(int start_row = 1; start_row   =  1; while(i     }  }"], "perturbed_original": ["m[4][65536],i,l,L,p,c;main(n){for(;~scanf(\"%d\\n\",&n);L=n&&!printf(\"%d\\n\",L))for(p=255;++p<256-~n*n;)for(c=getchar(i=4);i--;L=l>L?l:L)l=m[i][p]=c-49?0:m[i][p-(i?n+i-1:1)]+1;}"], "original_ll": -3.3190577030181885, "sampled_ll": -0.2597476840019226, "all_perturbed_sampled_ll": [-2.408338785171509], "all_perturbed_original_ll": [-3.3190577030181885], "perturbed_sampled_ll": -2.408338785171509, "perturbed_original_ll": -3.3190577030181885, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import java.util.Arrays;\nimport java.util.LinkedList;\nimport java.util.List;\nimport java.util.Scanner;\n\n\npublic class Main {\n\t\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\t\n\t\twhile(true){\n\t\t\tfinal int n = sc.nextInt();\n\t\t\t\n\t\t\tif(n == 0){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\n\t\t\tboolean[][] map = new boolean[n][n];\n\t\t\t\n\t\t\tfor(int i = 0; i < n; i++){\n\t\t\t\tchar[] ch = sc.next().toCharArray();\n\t\t\t\t\n\t\t\t\tfor(int j = 0; j < n; j++){\n\t\t\t\t\tmap[i][j] = ch[j] == '1';\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tint max = 0;\n\t\t\tfor(int i = 0; i < n; i++){\n\t\t\t\tint count = 0;\n\t\t\t\t\n\t\t\t\tfor(int j = 0; j < n; j++){\n\t\t\t\t\tif(map[i][j] == true){\n\t\t\t\t\t\tcount++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tmax = Math.max(max, count);\n\t\t\t}\n\t\t\t\n\t\t\tfor(int i = 0; i < n; i++){\n\t\t\t\tint count = 0;\n\t\t\t\t\n\t\t\t\tfor(int j = 0; j < n; j++){\n\t\t\t\t\tif(map[j][i] == true){\n\t\t\t\t\t\tcount++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tmax = Math.max(max, count);\n\t\t\t}\n\t\t\t\n\t\t\tfor(int i = 0; i < n; i++){\n\t\t\t\tint count = 0;\n\t\t\t\t\n\t\t\t\tfor(int j = 0; j <= i; j++){\n\t\t\t\t\t//System.out.print(\"( \" + (i - j) +\" \" + j + \") \");\n\t\t\t\t\tif(map[i - j][j] == true){\n\t\t\t\t\t\tcount++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t//System.out.println();\n\t\t\t\tmax = Math.max(max, count);\n\t\t\t}\n\t\t\t\n\t\t\tfor(int i = 0; i < n; i++){\n\t\t\t\tint count = 0;\n\t\t\t\t\n\t\t\t\tfor(int j = n - 1; j >= i; j--){\n\t\t\t\t\t//System.out.print(\"( \" + j +\" \" + (j - i) + \") \");\n\t\t\t\t\tif(map[j][j-i] == true){\n\t\t\t\t\t\tcount++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t//System.out.println();\n\t\t\t\tmax = Math.max(max, count);\n\t\t\t}\n\t\t\t\n\t\t\tfor(int i = 0; i < n; i++){\n\t\t\t\tint count = 0;\n\t\t\t\t\n\t\t\t\tfor(int j = 0; j < (n - i) ; j++){\n\t\t\t\t\t//System.out.print(\"( \" + (j) +\" \" + (i+j) + \") \");\n\t\t\t\t\tif(map[j][i+j] == true){\n\t\t\t\t\t\tcount++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t//System.out.println();\n\t\t\t\tmax = Math.max(max, count);\n\t\t\t}\n\t\t\t\n\t\t\tfor(int i = 0; i < n; i++){\n\t\t\t\tint count = 0;\n\t\t\t\t\n\t\t\t\tfor(int j = 0; j < (n - i); j++){\n\t\t\t\t\t//System.out.print(\"( \" + (i + j) +\" \" + (i) + \") \");\n\t\t\t\t\tif(map[i+j][i] == true){\n\t\t\t\t\t\tcount++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t//System.out.println();\n\t\t\t\tmax = Math.max(max, count);\n\t\t\t}\n\t\t\t\n\t\t\tSystem.out.println(max);\n\t\t}\n\n\t}\n\n}", "sampled": "import java.util.Scanner;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        \n        while (true) {\n            int n = sc.nextInt();\n            if (n == 0) break;\n            \n            int[][] grid = new int[n][n];\n            for (int i = 0; i < n; i++) {\n                String line = sc.next();\n                for (int j = 0; j < n; j++) {\n                    grid[i][j] = line.charAt(j) - '0';\n                }\n            }\n            \n            int maxConsecutive = 0;\n            \n            // Check horizontal\n            for (int i = 0; i < n; i++) {\n                int count = 0;\n                for (int j = 0; j < n; j++) {\n                    if (grid[i][j] == 1) {\n                        count++;\n                        maxConsecutive = Math.max(maxConsecutive, count);\n                    } else {\n                        count = 0;\n                    }\n                }\n            }\n            \n            // Check vertical\n            for (int j = 0; j < n; j++) {\n                int count = 0;\n                for (int i = 0; i < n; i++) {\n                    if (grid[i][j] == 1) {\n                        count++;\n                        maxConsecutive = Math.max(maxConsecutive, count);\n                    } else {\n                        count = 0;\n                    }\n                }\n            }\n            \n            // Check diagonal (top-left to bottom-right)\n            for (int start = 0; start < n; start++) {\n                // Starting from first row\n                int count = 0;\n                for (int i = 0, j = start; i < n && j < n; i++, j++) {\n                    if (grid[i][j] == 1) {\n                        count++;\n                        maxConsecutive = Math.max(maxConsecutive, count);\n                    } else {\n                        count = 0;\n                    }\n                }\n                \n                // Starting from first column (skip 0,0 as it's already covered)\n                if (start > 0) {\n                    count = 0;\n                    for (int i = start, j = 0; i < n && j < n; i++, j++) {\n                        if (grid[i][j] == 1) {\n                            count++;\n                            maxConsecutive = Math.max(maxConsecutive, count);\n                        } else {\n                            count = 0;\n                        }\n                    }\n                }\n            }\n            \n            // Check diagonal (top-right to bottom-left)\n            for (int start = 0; start < n; start++) {\n                // Starting from first row\n                int count = 0;\n                for (int i = 0, j = start; i < n && j >= 0; i++, j--) {\n                    if (grid[i][j] == 1) {\n                        count++;\n                        maxConsecutive = Math.max(maxConsecutive, count);\n                    } else {\n                        count = 0;\n                    }\n                }\n                \n                // Starting from last column (skip top-right corner as it's already covered)\n                if (start > 0) {\n                    count = 0;\n                    for (int i = start, j = n - 1; i < n && j >= 0; i++, j--) {\n                        if (grid[i][j] == 1) {\n                            count++;\n                            maxConsecutive = Math.max(maxConsecutive, count);\n                        } else {\n                            count = 0;\n                        }\n                    }\n                }\n            }\n            \n            System.out.println(maxConsecutive);\n        }\n        \n        sc.close();\n    }\n}\n", "perturbed_sampled": ["import java.util.Scanner; public  Scanner sc = new Scanner(System.in); while (true) { int n = sc.nextInt(); if (n == 0)  int[n][n]; for (int   j = 0; j < n; j++) { grid[i][j]  } int maxConsecutive = 0; //    n;  (int j = 0; j < n; j++)  for (int i  i++) { if (grid[i][j]  else { count = 0; } } } // Check diagonal (top-left to bottom-right) for (int start = 0; start <  from first row  j =  j  { count++; maxConsecutive = Math.max(maxConsecutive,  = 0; } } // Starting from first   0) { count =  j < n; i++,  0; }  0; start < n; start++) { // Starting from  0; for (int i = 0, j  && j >= 0;  == 1) {  } else { count = 0;  last  && j >= 0;  == 1)  count); } else { count = 0; }  sc.close(); } }"], "perturbed_original": [" java.util.List; import java.util.Scanner; public class Main { public static void main(String[] args) {   break; } boolean[][]  i =  char[]  = 0;  =  int max = 0; for(int i =   j = 0; j <  = Math.max(max, count); } for(int i = 0; i < n; i++){ int count = 0;  == true){ count++; } } max = Math.max(max, count); } for(int  = 0; j <= i; j++){ //System.out.print(\"( \" + (i - j) +\"  } //System.out.println(); max   = n - 1;  i) +   j < (n   + (i+j) + \") \"); if(map[j][i+j]  //System.out.println(); max = Math.max(max,  0;  count = 0; for(int j =  +\" \" + (i) + \") \"); if(map[i+j][i] == true){ count++;  } } }"], "original_ll": -0.36214011907577515, "sampled_ll": -0.2527104616165161, "all_perturbed_sampled_ll": [-2.1984877586364746], "all_perturbed_original_ll": [-2.4170491695404053], "perturbed_sampled_ll": -2.1984877586364746, "perturbed_original_ll": -2.4170491695404053, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "def ge(n):\n    for i in xrange(n):\n        yield [(i,j) for j in xrange(n)]\n        yield [(j,i) for j in xrange(n)]\n        yield [(i-j,j) for j in xrange(i+1)]\n        yield [(n-i+j-1,n-j-1) for j in xrange(i+1)]\n\nwhile True:\n    n = input()\n    if n == 0:\n        break\n    A = [map(int,list(raw_input())) for _ in xrange(n)]\n    print max(sum(map(lambda (i,j): A[i][j], p)) for p in ge(n))", "sampled": "def count_consecutive(line):\n    max_count = 0\n    current_count = 0\n    for char in line:\n        if char == '1':\n            current_count += 1\n            max_count = max(max_count, current_count)\n        else:\n            current_count = 0\n    return max_count\n\ndef solve(n, grid):\n    max_consecutive = 0\n    \n    # Check horizontal\n    for row in grid:\n        max_consecutive = max(max_consecutive, count_consecutive(row))\n    \n    # Check vertical\n    for col in range(n):\n        column = ''.join(grid[row][col] for row in range(n))\n        max_consecutive = max(max_consecutive, count_consecutive(column))\n    \n    # Check diagonals (top-left to bottom-right)\n    # Diagonals starting from first row\n    for start_col in range(n):\n        diagonal = ''.join(grid[i][start_col + i] for i in range(n - start_col))\n        max_consecutive = max(max_consecutive, count_consecutive(diagonal))\n    \n    # Diagonals starting from first column (excluding top-left corner)\n    for start_row in range(1, n):\n        diagonal = ''.join(grid[start_row + i][i] for i in range(n - start_row))\n        max_consecutive = max(max_consecutive, count_consecutive(diagonal))\n    \n    # Check diagonals (top-right to bottom-left)\n    # Diagonals starting from first row\n    for start_col in range(n):\n        diagonal = ''.join(grid[i][start_col - i] for i in range(start_col + 1))\n        max_consecutive = max(max_consecutive, count_consecutive(diagonal))\n    \n    # Diagonals starting from last column (excluding top-right corner)\n    for start_row in range(1, n):\n        diagonal = ''.join(grid[start_row + i][n - 1 - i] for i in range(n - start_row))\n        max_consecutive = max(max_consecutive, count_consecutive(diagonal))\n    \n    return max_consecutive\n\nwhile True:\n    n = int(input())\n    if n == 0:\n        break\n    \n    grid = []\n    for _ in range(n):\n        grid.append(input().strip())\n    \n    result = solve(n, grid)\n    print(result)\n", "perturbed_sampled": ["def count_consecutive(line): max_count = 0 current_count  line: if char == '1': current_count += 1 max_count = max(max_count, current_count) else: current_count = 0  Check horizontal for row in grid: max_consecutive = max(max_consecutive, count_consecutive(row)) # Check vertical for col in range(n):   range(n):  max(max_consecutive, count_consecutive(diagonal)) # Diagonals starting from first column (excluding top-left  n): diagonal = ''.join(grid[start_row + i][i] for i  = max(max_consecutive,   =  in range(start_col +  last column (excluding top-right corner) for   1 -  while True:   []  result = solve(n, grid) print(result)"], "perturbed_original": ["def ge(n): for i in <extra_id_1>while<extra_id_2>( i<extra_id_3>==<extra_id_4>) .<extra_id_5>for i in<extra_id_6>n<extra_id_7>i] ) )  [(i-j,j) for  for j in xrange(i+1)] while True: n = input() if  (i,j): A[i][j], p)) for p in ge(n))"], "original_ll": -1.3500720262527466, "sampled_ll": -0.5049533247947693, "all_perturbed_sampled_ll": [-2.8356497287750244], "all_perturbed_original_ll": [-3.253527879714966], "perturbed_sampled_ll": -2.8356497287750244, "perturbed_original_ll": -3.253527879714966, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "#include <stdio.h>\n\ntypedef struct{\n\tint no;\n\tint score;\n} Info;\n\nvoid sortInfo(int n,Info t[]){\n\tint i,j;\n\tfor(i=0;i<n-1;i++){\n\t\tfor(j=i+1;j<n;j++){\n\t\t\tif(t[i].score < t[j].score ||\n\t\t\t   t[i].score == t[j].score && t[i].no > t[j].no){\n\t\t\t\tInfo tmp = t[i];\n\t\t\t\tt[i] = t[j];\n\t\t\t\tt[j] = tmp;\n\t\t\t}\n\t\t}\n\t}\n}\n\nint scoring(void){\n\tint i, x, total, frame, time, sum, flgSpare, flgStrike;\n\t\n\ttotal = sum = 0;\n\tframe = time = 1;\n\tflgSpare = flgStrike = 0;\n\t\n\twhile(frame < 10){\n\t\tscanf(\"%d\",&x);\n\t\tsum += x;\n\t\t\n\t\tif(flgSpare){\n\t\t\ttotal += x;\n\t\t\tflgSpare = 0;\n\t\t}\n\t\telse if(flgStrike){\n\t\t\tif(flgStrike == 3){\n\t\t\t\ttotal += x;\n\t\t\t\tflgStrike--;\n\t\t\t}\n\t\t\ttotal += x;\n\t\t\tflgStrike--;\n\t\t}\n\t\t\n\t\tif(time == 2){\n\t\t\ttotal += sum;\n\t\t\tif(sum == 10){\n\t\t\t\tflgSpare = 1;\n\t\t\t}\n\t\t\tsum = 0;\n\t\t\ttime = 1;\n\t\t\tframe++;\n\t\t}\n\t\telse if(time == 1){\n\t\t\ttime++;\n\t\t\tif(x == 10){\n\t\t\t\ttotal += 10;\n\t\t\t\tflgStrike += 2;\n\t\t\t\tsum = 0;\n\t\t\t\ttime = 1;\n\t\t\t\tframe++;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tfor(i=0;i<3;i++){\n\t\tif(i == 2 && sum < 10) break;\n\t\t\n\t\tscanf(\"%d\",&x);\n\t\ttotal += x;\n\t\tsum += x;\n\t\t\n\t\tif(flgSpare){\n\t\t\ttotal += x;\n\t\t\tflgSpare = 0;\n\t\t}\n\t\telse if(flgStrike){\n\t\t\tif(flgStrike == 3){\n\t\t\t\ttotal += x;\n\t\t\t\tflgStrike--;\n\t\t\t}\n\t\t\ttotal += x;\n\t\t\tflgStrike--;\n\t\t}\n\t}\n\n\treturn total;\n}\n\nint main(void){\n\tint i, n;\n\tInfo info[40];\n\t\n\twhile(scanf(\"%d\",&n) && n){\n\t\tfor(i=0;i<n;i++){\n\t\t\tscanf(\"%d\",&info[i].no);\n\t\t\tinfo[i].score = scoring();\n\t\t}\n\t\tsortInfo(n,info);\n\t\tfor(i=0;i<n;i++){\n\t\t\tprintf(\"%d %d\\n\",info[i].no,info[i].score);\n\t\t}\n\t}\n\t\n\treturn 0;\n}", "sampled": "#include <stdio.h>\n#include <stdlib.h>\n\ntypedef struct {\n    int id;\n    int score;\n} Player;\n\nint calculate_score(int pins[], int n) {\n    int total = 0;\n    int pin_idx = 0;\n    \n    for (int frame = 0; frame < 10; frame++) {\n        if (frame < 9) {\n            if (pins[pin_idx] == 10) { // Strike\n                total += 10 + pins[pin_idx + 1] + pins[pin_idx + 2];\n                pin_idx++;\n            } else if (pins[pin_idx] + pins[pin_idx + 1] == 10) { // Spare\n                total += 10 + pins[pin_idx + 2];\n                pin_idx += 2;\n            } else {\n                total += pins[pin_idx] + pins[pin_idx + 1];\n                pin_idx += 2;\n            }\n        } else { // 10th frame\n            total += pins[pin_idx] + pins[pin_idx + 1];\n            if (pins[pin_idx] == 10 || pins[pin_idx] + pins[pin_idx + 1] == 10) {\n                total += pins[pin_idx + 2];\n            }\n        }\n    }\n    \n    return total;\n}\n\nint compare_players(const void *a, const void *b) {\n    Player *pa = (Player *)a;\n    Player *pb = (Player *)b;\n    \n    if (pa->score != pb->score) {\n        return pb->score - pa->score; // Higher score first\n    }\n    return pa->id - pb->id; // Lower ID first\n}\n\nint main() {\n    int m;\n    \n    while (scanf(\"%d\", &m) == 1 && m != 0) {\n        Player players[40];\n        \n        for (int i = 0; i < m; i++) {\n            int id;\n            int pins[21];\n            int n = 0;\n            \n            scanf(\"%d\", &id);\n            \n            while (n < 21) {\n                if (scanf(\"%d\", &pins[n]) != 1) break;\n                n++;\n                \n                // Check if we should stop reading (peek next character)\n                int c = getchar();\n                if (c == '\\n' || c == EOF) {\n                    ungetc(c, stdin);\n                    break;\n                }\n                ungetc(c, stdin);\n            }\n            \n            players[i].id = id;\n            players[i].score = calculate_score(pins, n);\n        }\n        \n        qsort(players, m, sizeof(Player), compare_players);\n        \n        for (int i = 0; i < m; i++) {\n            printf(\"%d %d\\n\", players[i].id, players[i].score);\n        }\n    }\n    \n    return 0;\n}\n", "perturbed_sampled": ["#include <stdio.h> #include <stdlib.h>  int calculate_score(int pins[], int  0; int pin_idx =  0;  { if (pins[pin_idx] == 10) { // Strike total += 10 + pins[pin_idx + 1] +  else if (pins[pin_idx] + pins[pin_idx +  Spare total += 10 +  pins[pin_idx + 1]; pin_idx += 2; }  frame total += pins[pin_idx] + pins[pin_idx + 1]; if (pins[pin_idx] == 10 || pins[pin_idx] +  } return total;   Player *pb = (Player *)b; if (pa->score != pb->score) { return  score first } return pa->id - pb->id;  int   < m; i++)  int n =  <  should stop reading (peek next character) int  == EOF) {  } } return 0; }"], "perturbed_original": ["#include <stdio.h>  i,j; for(i=0;i<n-1;i++){ for(j=i+1;j<n;j++){ if(t[i].score < t[j].score || t[i].score ==   tmp; } } } } int scoring(void){ int i, x, total, frame, time, sum, flgSpare,  0; frame = time =  scanf(\"%d\",&x); sum  x; flgSpare = 0; } else if(flgStrike){ if(flgStrike == 3){  total += sum;  1; }  if(time ==  0; time =  for(i=0;i<3;i++){ if(i == 2 && sum  x; if(flgSpare){  += x; flgStrike--;  } } return  i,  n){ for(i=0;i<n;i++){ scanf(\"%d\",&info[i].no); info[i].score = scoring(); }  } return 0; }"], "original_ll": -0.7490174174308777, "sampled_ll": -0.5939926505088806, "all_perturbed_sampled_ll": [-2.572281837463379], "all_perturbed_original_ll": [-2.5650408267974854], "perturbed_sampled_ll": -2.572281837463379, "perturbed_original_ll": -2.5650408267974854, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import java.util.*;\nimport java.lang.*;\nimport java.math.*;\n\npublic class Main {\n\tScanner sc = new Scanner(System.in);\n\n\tclass score implements Comparable<score> {\n\t\tString id;\n\t\tint s;\n\n\t\tscore(Scanner sc) {\n\t\t\tid = sc.next();\n\t\t\tint f = 0;\n\t\t\tint x1 = 0;\n\t\t\tint x2 = 0;\n\t\t\tint c = 0;\n\t\t\tint q = 0;\n\t\t\tint e = 0;\n\t\t\ts = 0;\n\t\t\tfor (;;) {\n\t\t\t\tif(f == 9 && e == 1 && c==3){\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif(f == 9 && e == 0 && c==2){\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tint v = sc.nextInt();\n\t\t\t\tif (x1 > 0) {\n\t\t\t\t\tx1--;\n\t\t\t\t\ts+=v;\n\t\t\t\t}\n\t\t\t\tif (x2 > 0) {\n\t\t\t\t\tx2--;\n\t\t\t\t\tx1++;\n\t\t\t\t\ts+=v;\n\t\t\t\t}\n\t\t\t\ts+=v;\n//\t\t\t\tSystem.out.println(s);\n\t\t\t\tif (f == 9) {\n\t\t\t\t\tif(c==0){\n\t\t\t\t\t\tif(v==10){\n\t\t\t\t\t\t\te=1;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tq=v;\n\t\t\t\t\t\tc++;\n\t\t\t\t\t}else if(c== 1 && q+v==10){\n\t\t\t\t\t\te=1;\n\t\t\t\t\t\tc++;\n\t\t\t\t\t}else{\n\t\t\t\t\t\tc++;\n\t\t\t\t\t}\n\t\t\t\t} else if (v == 10) {\n\t\t\t\t\tx2 += 1;\n\t\t\t\t\tc = 0;\n\t\t\t\t\tq=0;\n\t\t\t\t\tf++;\n\t\t\t\t} else if (q + v == 10) {\n\t\t\t\t\tx1 += 1;\n\t\t\t\t\tc = 0;\n\t\t\t\t\tq=0;\n\t\t\t\t\tf++;\n\t\t\t\t} else if (c == 1) {\n\t\t\t\t\tc = 0;\n\t\t\t\t\tq=0;\n\t\t\t\t\tf++;\n\t\t\t\t} else {\n\t\t\t\t\tq = v;\n\t\t\t\t\tc++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t@Override\n\t\tpublic int compareTo(score arg0) {\n\t\t\tint a;\n\t\t\ta = arg0.s - s;\n\t\t\tif (a == 0) {\n\t\t\t\ta = id.compareTo(arg0.id);\n\t\t\t}\n\t\t\treturn a;\n\t\t}\n\t\t\n\t}\n\n\tvoid run() {\n\t\tfor (;;) {\n\t\t\tint n = sc.nextInt();\n\t\t\tif (n == 0) {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tscore[] c = new score[n];\n\t\t\tfor(int i =0;i<n;i++){\n\t\t\t//\tSystem.out.println(i);\n\t\t\t\tc[i] = new score(sc);\n\t\t\t}\n\t\t\tArrays.sort(c);\n\t\t\t\n\t\t\tfor(int i =0 ; i < n;i++){\n\t\t\t\tSystem.out.println(c[i].id+\" \"+c[i].s);\n\t\t\t}\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tMain m = new Main();\n\t\tm.run();\n\t}\n}", "sampled": "import java.util.*;\n\npublic class Main {\n    static class Player implements Comparable<Player> {\n        int id;\n        int score;\n        \n        public Player(int id, int score) {\n            this.id = id;\n            this.score = score;\n        }\n        \n        @Override\n        public int compareTo(Player other) {\n            if (this.score != other.score) {\n                return other.score - this.score;\n            }\n            return this.id - other.id;\n        }\n    }\n    \n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        \n        while (true) {\n            int m = sc.nextInt();\n            if (m == 0) break;\n            \n            List<Player> players = new ArrayList<>();\n            \n            for (int i = 0; i < m; i++) {\n                int id = sc.nextInt();\n                List<Integer> rolls = new ArrayList<>();\n                \n                String line = sc.nextLine().trim();\n                String[] tokens = line.split(\"\\\\s+\");\n                for (String token : tokens) {\n                    rolls.add(Integer.parseInt(token));\n                }\n                \n                int score = calculateScore(rolls);\n                players.add(new Player(id, score));\n            }\n            \n            Collections.sort(players);\n            \n            for (Player p : players) {\n                System.out.println(p.id + \" \" + p.score);\n            }\n        }\n        \n        sc.close();\n    }\n    \n    static int calculateScore(List<Integer> rolls) {\n        int score = 0;\n        int rollIndex = 0;\n        \n        for (int frame = 0; frame < 10; frame++) {\n            if (frame < 9) {\n                if (rolls.get(rollIndex) == 10) {\n                    score += 10 + rolls.get(rollIndex + 1) + rolls.get(rollIndex + 2);\n                    rollIndex++;\n                } else if (rolls.get(rollIndex) + rolls.get(rollIndex + 1) == 10) {\n                    score += 10 + rolls.get(rollIndex + 2);\n                    rollIndex += 2;\n                } else {\n                    score += rolls.get(rollIndex) + rolls.get(rollIndex + 1);\n                    rollIndex += 2;\n                }\n            } else {\n                if (rolls.get(rollIndex) == 10) {\n                    score += rolls.get(rollIndex) + rolls.get(rollIndex + 1) + rolls.get(rollIndex + 2);\n                    rollIndex += 3;\n                } else if (rolls.get(rollIndex) + rolls.get(rollIndex + 1) == 10) {\n                    score += rolls.get(rollIndex) + rolls.get(rollIndex + 1) + rolls.get(rollIndex + 2);\n                    rollIndex += 3;\n                } else {\n                    score += rolls.get(rollIndex) + rolls.get(rollIndex + 1);\n                    rollIndex += 2;\n                }\n            }\n        }\n        \n        return score;\n    }\n}\n", "perturbed_sampled": ["import java.util.*; public class Main { static class Player implements Comparable<Player> { int id; int score; public   { return  this.id - other.id;  main(String[] args) {  while (true) { int m =  break; List<Player>   : tokens) { rolls.add(Integer.parseInt(token)); } int score = calculateScore(rolls); players.add(new Player(id,   p.score); } }  rolls) {  9) { if (rolls.get(rollIndex) == 10) { score += 10 +    score += 10 + rolls.get(rollIndex + 2);  + rolls.get(rollIndex +  } else { if (rolls.get(rollIndex) == 10) {  + 1)  += 3;  rolls.get(rollIndex + 1) == 10) { score += rolls.get(rollIndex) + rolls.get(rollIndex + 1) + rolls.get(rollIndex +  else   2; }  }"], "perturbed_original": ["import java.util.*; import java.lang.*; import java.math.*; public class Main { Scanner sc =  { id =   x2 = 0;  q = 0; int  if(f == 9 && e ==  e == 0 && c==2){ break; } int v = sc.nextInt(); if (x1 > 0) { x1--; s+=v; } if (x2 > 0) { x2--; x1++; s+=v;  (f == 9) { if(c==0){   e=1; c++; }else{ c++; }   c = 0; q=0;  + v == 10) { x1 +=  {   } } void  if (n == 0)  =  new score(sc); } Arrays.sort(c); for(int  Main m = new Main(); m.run(); } }"], "original_ll": -0.8920667171478271, "sampled_ll": -0.3418894112110138, "all_perturbed_sampled_ll": [-2.130681037902832], "all_perturbed_original_ll": [-2.663034200668335], "perturbed_sampled_ll": -2.130681037902832, "perturbed_original_ll": -2.663034200668335, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "def f1():\n    frame = 1\n    total = 0\n    i = 0\n    while frame < 10:\n        if score[i] == 10:\n            total += (score[i] + score[i+1] + score[i+2])\n            i += 1\n        elif score[i] + score[i+1] == 10:\n            total += (score[i] + score[i+1] + score[i+2])\n            i += 2\n        else:\n            total += (score[i] + score[i+1])\n            i += 2\n        frame += 1\n    else:\n        total += sum(score[i:])\n        res[sn] = total\n\ndef f2():\n    for k, v in sorted(res.items(), key=lambda x: (x[1], x[0]), reverse=True):\n        print -k, v\n\nwhile True:\n    n = input()\n    if n == 0: break\n    res = {}\n    for i in range(n):\n        L = map(int, raw_input().split())\n        sn = -L[0]\n        score = L[1:]\n        f1()\n    else:\n        f2()", "sampled": "def calculate_bowling_score(pins):\n    score = 0\n    pin_idx = 0\n    \n    for frame in range(10):\n        if frame < 9:  # Frames 1-9\n            if pins[pin_idx] == 10:  # Strike\n                score += 10 + pins[pin_idx + 1] + pins[pin_idx + 2]\n                pin_idx += 1\n            elif pins[pin_idx] + pins[pin_idx + 1] == 10:  # Spare\n                score += 10 + pins[pin_idx + 2]\n                pin_idx += 2\n            else:  # Regular\n                score += pins[pin_idx] + pins[pin_idx + 1]\n                pin_idx += 2\n        else:  # Frame 10\n            score += pins[pin_idx] + pins[pin_idx + 1] + pins[pin_idx + 2]\n            pin_idx += 3\n    \n    return score\n\nwhile True:\n    m = int(input())\n    if m == 0:\n        break\n    \n    results = []\n    for _ in range(m):\n        data = list(map(int, input().split()))\n        student_id = data[0]\n        pins = data[1:]\n        score = calculate_bowling_score(pins)\n        results.append((student_id, score))\n    \n    # Sort by score (descending), then by student_id (ascending)\n    results.sort(key=lambda x: (-x[1], x[0]))\n    \n    for student_id, score in results:\n        print(f\"{student_id} {score}\")\n", "perturbed_sampled": ["  in range(10): if frame < 9:  ==  10  pins[pin_idx + 2] pin_idx +=  # Spare score += 10 + pins[pin_idx + 2]  Regular score  pins[pin_idx + 1]  while True: m  0: break results = []  = data[0]  calculate_bowling_score(pins)  score (descending),  x: (-x[1], x[0])) for student_id, score in results: print(f\"{student_id} {score}\")"], "perturbed_original": ["def f1(): frame = 1  0 while frame < 10: if score[i] == 10: total += (score[i]  += 1  + score[i+1] + score[i+2]) i += 2  score[i+1])   res[sn] = total def f2(): for k, v    if  f1() else: f2()"], "original_ll": -1.0330616235733032, "sampled_ll": -0.6169936656951904, "all_perturbed_sampled_ll": [-3.4515960216522217], "all_perturbed_original_ll": [-2.8631458282470703], "perturbed_sampled_ll": -3.4515960216522217, "perturbed_original_ll": -2.8631458282470703, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "// Aizu Vol-1 0153: Triangle and Circle\n// 2017.8.12 bal4u@uu\n\n#include <stdio.h>\n\nlong long x[10], y[10];\nlong long xe, ye, r;\n\nint atSameSide(long long x1, long long y1, long long x2, long long y2,\n\tlong long xa, long long ya, long long xb, long long yb)\n{\n\tlong long sa, sb;\n\tsa = (x2 - x1) * (ya - y1) + (y2 - y1) * (x1 - xa);\n\tsb = (x2 - x1) * (yb - y1) + (y2 - y1) * (x1 - xb);\n\treturn (sa >= 0 && sb >= 0) || (sa < 0 && sb < 0);\n}\n\nint between(long long x1, long long y1, long long x2, long long y2,\n\tlong long x, long long y)\n{\n\tlong long sa, sb;\n\tsa = (x2 - x1) * (x - x1) + (y2 - y1) * (y - y1);\n\tsb = (x1 - x2) * (x - x2) + (y1 - y2) * (y - y2);\n\treturn (sa >= 0 && sb >= 0) || (sa < 0 && sb < 0);\n}\n\nint disCmp(long long x1, long long y1, long long x2, long long y2,\n\tlong long x, long long y, long long r)\n{\n\tlong long a, b, c, t;\t\t\t/* ax + by + c = 0 */\n\tlong long squ;\n\ta = y1 - y2, b = x2 - x1, c = y2*x1-x2*y1;\n\tsqu = a*a + b*b;\n\tif (squ == 0) return 0;\n\tt = (a * x) + (b * y) + c;\n\tt = t*t - r*r*squ;\n\tif (t > 0) return 1;\n\tif (t < 0) return -1;\n\treturn 0;\n}\n\nint main()\n{\n\tint i, f;\n\tlong long d[3], rr;\n\n\twhile (1) {\n\t\tfor (i = 0; i < 3; i++) {\n\t\t\tscanf(\"%lld%lld\", x + i, y + i);\n\t\t\tif (!i && !x[0] && !y[0]) return 0;\n\t\t\tx[i + 3] = x[i], y[i + 3] = y[i];\n\t\t}\n\t\tscanf(\"%lld%lld%lld\", &xe, &ye, &r); rr = r*r;\n\n\t\tfor (i = 0; i < 3; i++)\n\t\t\td[i] = (x[i] - xe)*(x[i] - xe) + (y[i] - ye)*(y[i] - ye);\n\t\tif (rr >= d[0] && rr >= d[1] && rr >= d[2]) { puts(\"b\"); continue; }\n\t\tif (rr >= d[0] || rr >= d[1] || rr >= d[2]) { puts(\"c\"); continue; }\n\n\t\tfor (f = 1, i = 0; f && i < 3; i++)\n\t\t\tf = atSameSide(x[i], y[i], x[i + 1], y[i + 1],\n\t\t\t\tx[i + 2], y[i + 2], xe, ye);\n\t\tfor (i = 0; i < 3; i++)\n\t\t\td[i] = disCmp(x[i], y[i], x[i + 1], y[i + 1], xe, ye, r);\n\t\tif (f) { puts(d[0] >= 0 && d[1] >= 0 && d[2] >= 0 ? \"a\" : \"c\"); continue; }\n\t\tif (d[0] > 0 && d[1] > 0 && d[2] > 0) { puts(\"d\"); continue; }\n\n\t\tfor (f = 1, i = 0; f && i < 3; i++)\n\t\t\tif (between(x[i], y[i], x[i + 1], y[i + 1], xe, ye) && d[i] <= 0) f = 0;\n\t\tputs(f ? \"d\" : \"c\");\n\t}\n\treturn 0;\n}", "sampled": "#include <stdio.h>\n#include <math.h>\n\n#define EPS 1e-9\n\ntypedef struct {\n    double x, y;\n} Point;\n\ndouble dist(Point a, Point b) {\n    double dx = a.x - b.x;\n    double dy = a.y - b.y;\n    return sqrt(dx * dx + dy * dy);\n}\n\ndouble dot(Point a, Point b, Point c) {\n    return (b.x - a.x) * (c.x - a.x) + (b.y - a.y) * (c.y - a.y);\n}\n\ndouble cross(Point a, Point b, Point c) {\n    return (b.x - a.x) * (c.y - a.y) - (b.y - a.y) * (c.x - a.x);\n}\n\ndouble distPointToSegment(Point p, Point a, Point b) {\n    if (dot(a, b, p) < -EPS) return dist(p, a);\n    if (dot(b, a, p) < -EPS) return dist(p, b);\n    return fabs(cross(a, b, p)) / dist(a, b);\n}\n\nint pointInTriangle(Point p, Point t1, Point t2, Point t3) {\n    double c1 = cross(t1, t2, p);\n    double c2 = cross(t2, t3, p);\n    double c3 = cross(t3, t1, p);\n    \n    if (c1 >= -EPS && c2 >= -EPS && c3 >= -EPS) return 1;\n    if (c1 <= EPS && c2 <= EPS && c3 <= EPS) return 1;\n    return 0;\n}\n\nint main() {\n    int x1, y1, x2, y2, x3, y3, xc, yc, r;\n    \n    while (1) {\n        scanf(\"%d %d\", &x1, &y1);\n        if (x1 == 0 && y1 == 0) break;\n        scanf(\"%d %d\", &x2, &y2);\n        scanf(\"%d %d\", &x3, &y3);\n        scanf(\"%d %d\", &xc, &yc);\n        scanf(\"%d\", &r);\n        \n        Point t1 = {x1, y1};\n        Point t2 = {x2, y2};\n        Point t3 = {x3, y3};\n        Point c = {xc, yc};\n        \n        // Check if circle is inside triangle\n        int circleInTriangle = 1;\n        if (!pointInTriangle(c, t1, t2, t3)) {\n            circleInTriangle = 0;\n        } else {\n            double d1 = distPointToSegment(c, t1, t2);\n            double d2 = distPointToSegment(c, t2, t3);\n            double d3 = distPointToSegment(c, t3, t1);\n            if (d1 < r - EPS || d2 < r - EPS || d3 < r - EPS) {\n                circleInTriangle = 0;\n            }\n        }\n        \n        // Check if triangle is inside circle\n        int triangleInCircle = 1;\n        if (dist(c, t1) > r + EPS || dist(c, t2) > r + EPS || dist(c, t3) > r + EPS) {\n            triangleInCircle = 0;\n        }\n        \n        // Check if they intersect\n        int intersect = 0;\n        double d1 = distPointToSegment(c, t1, t2);\n        double d2 = distPointToSegment(c, t2, t3);\n        double d3 = distPointToSegment(c, t3, t1);\n        \n        if (d1 <= r + EPS || d2 <= r + EPS || d3 <= r + EPS) {\n            if (pointInTriangle(c, t1, t2, t3) || \n                dist(c, t1) <= r + EPS || \n                dist(c, t2) <= r + EPS || \n                dist(c, t3) <= r + EPS) {\n                intersect = 1;\n            }\n        }\n        \n        if (circleInTriangle) {\n            printf(\"a\\n\");\n        } else if (triangleInCircle) {\n            printf(\"b\\n\");\n        } else if (intersect) {\n            printf(\"c\\n\");\n        } else {\n            printf(\"d\\n\");\n        }\n    }\n    \n    return 0;\n}\n", "perturbed_sampled": ["#include <stdio.h> #include <math.h> #define EPS 1e-9 typedef struct { double x, y; } Point; double dist(Point a, Point  a.x - b.x; double  return  * dy); } double dot(Point a, Point b, Point  a.x) + (b.y - a.y) *  cross(Point  a.y) - (b.y - a.y)     return dist(p,  / dist(a, b); }   t2, p); double c2 = cross(t2,  cross(t3, t1, p); if (c1 >= -EPS && c2 >= -EPS && c3 >= -EPS) return  &&  return   if (x1 == 0 && y1 == 0) break; scanf(\"%d  &x3, &y3); scanf(\"%d  Point  t2  = {x3, y3}; Point c = {xc, yc}; //  triangle int circleInTriangle =  0; } else { double d1 = distPointToSegment(c, t1,  - EPS || d2 < r  r - EPS)  if (dist(c, t1) > r + EPS ||  >  double d1   double d3 = distPointToSegment(c, t3, t1); if (d1 <= r + EPS || d2 <= r   r + EPS || dist(c, t2) <= r + EPS  + EPS) { intersect =  return 0; }"], "perturbed_original": ["// Aizu Vol-1 0153: Triangle  xe, ye, r; int atSameSide(long long x1, long long y1, long long  long  long xb, long long yb) { long  (x2 - x1) * (ya - y1) + (y2 - y1)  = (x2 - x1) * (yb - y1) + (y2  xb);  (sa  long x1,   sa, sb; sa = (x2 - x1) * (x  y1) * (y - y1); sb = (x1 - x2) *  -  return (sa >= 0 && sb  0);   long y, long long r) { long long a, b, c, t; /* ax + by + c = 0  = y1 - y2,  c  + b*b; if (squ ==  c; t = t*t - r*r*squ; if (t > 0) return 1; if (t < 0) return  main() { int i,  < 3; i++) { scanf(\"%lld%lld\", x + i, y  3] = y[i];  (i    && rr >= d[1]    d[2]) {  0;  i++) f =  + 1],  r); if (f) {  >=  continue; } if (d[0] > 0 && d[1]   for  0; f && i < 3;  1], xe, ye) && d[i] <= 0) f =  }"], "original_ll": -0.7878744602203369, "sampled_ll": -0.39695581793785095, "all_perturbed_sampled_ll": [-2.4111220836639404], "all_perturbed_original_ll": [-2.809041738510132], "perturbed_sampled_ll": -2.4111220836639404, "perturbed_original_ll": -2.809041738510132, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import java.awt.geom.Point2D;\nimport java.util.Scanner;\n\npublic class Main {\n\n\tpublic static void main(String[] args) throws Exception {\n\t\tScanner sc = new Scanner(System.in);\n\t\tsc.useDelimiter(\",|\\\\s+\");\n\t\twhile (true) {\n\t\t\tint x1 = sc.nextInt();\n\t\t\tint y1 = sc.nextInt();\n\t\t\tif ((x1 | y1) == 0)\n\t\t\t\tbreak;\n\t\t\tint x2 = sc.nextInt();\n\t\t\tint y2 = sc.nextInt();\n\t\t\tint x3 = sc.nextInt();\n\t\t\tint y3 = sc.nextInt();\n\t\t\tint x4 = sc.nextInt();\n\t\t\tint y4 = sc.nextInt();\n\t\t\tint r = sc.nextInt();\n\t\t\t// 1\u884c\u76ee \u4e09\u89d2\u5f62\u306e\u7b2c1\u306e\u9802\u70b9\u306e\u5ea7\u6a19x1 y1\uff08\u6574\u6570 \u6574\u6570\uff1b\u534a\u89d2\u7a7a\u767d\u533a\u5207\u308a\uff09\n\t\t\t// 2\u884c\u76ee \u4e09\u89d2\u5f62\u306e\u7b2c2\u306e\u9802\u70b9\u306e\u5ea7\u6a19x2 y2\uff08\u6574\u6570 \u6574\u6570\uff1b\u534a\u89d2\u7a7a\u767d\u533a\u5207\u308a\uff09\n\t\t\t// 3\u884c\u76ee \u4e09\u89d2\u5f62\u306e\u7b2c3\u306e\u9802\u70b9\u306e\u5ea7\u6a19x3 y3\uff08\u6574\u6570 \u6574\u6570\uff1b\u534a\u89d2\u7a7a\u767d\u533a\u5207\u308a\uff09\n\t\t\t// 4\u884c\u76ee \u5186\u306e\u4e2d\u5fc3\u306e\u5ea7\u6a19x4 y4\uff08\u6574\u6570 \u6574\u6570\uff1b\u534a\u89d2\u7a7a\u767d\u533a\u5207\u308a\uff09\n\t\t\t// 5\u884c\u76ee \u5186\u306e\u534a\u5f84r\uff08\u6574\u6570\uff09\n\t\t\t//\n\t\t\tPoint2D.Double[] ps = new Point2D.Double[4];\n\t\t\tps[0] = new Point2D.Double(x1, y1);\n\t\t\tps[1] = new Point2D.Double(x2, y2);\n\t\t\tps[2] = new Point2D.Double(x3, y3);\n\t\t\tps[3] = new Point2D.Double(x4, y4);\n\t\t\tdouble max = 0;\n\t\t\tfor (int i = 0; i < 3; i++) {\n\n\t\t\t\tmax = Math.max(max, nor(ps[3], ps[i]));\n\t\t\t}\n\t\t\tif (r * r >= max) {\n\t\t\t\tSystem.out.println(\"b\");\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tdouble min = Double.MAX_VALUE;\n\t\t\tfor (int i = 0; i < 3; i++) {\n\t\t\t\tdouble dis = Math.max(Line.distanceSP(new Line(ps[i],\n\t\t\t\t\t\tps[(i + 1) % 3]), ps[3]), Line.distanceSP(new Line(\n\t\t\t\t\t\tps[i], ps[(i + 1) % 3]), ps[3]));\n\t\t\t\tmin = Math.min(min, dis);\n\t\t\t}\n\t\t\tboolean right = true;\n\t\t\tboolean left = true;\n\t\t\tfor (int i = 0; i < 3; i++) {\n\t\t\t\tdouble ep = new Line(ps[i], ps[(i + 1) % 3]).ep(new Line(ps[i],\n\t\t\t\t\t\tps[3]));\n\t\t\t\tif (ep < 0)\n\t\t\t\t\tleft = false;\n\t\t\t\telse if (ep > 0)\n\t\t\t\t\tright = false;\n\t\t\t}\n\t\t\tboolean in = left | right;\n\t\t\tif (r <= min && in)\n\t\t\t\tSystem.out.println(\"a\");\n\t\t\telse if (!in && r < min)\n\t\t\t\tSystem.out.println(\"d\");\n\t\t\telse\n\t\t\t\tSystem.out.println(\"c\");\n\t\t}\n\t}\n\n\tpublic static double nor(Point2D.Double p, Point2D.Double q) {\n\t\treturn (p.x - q.x) * (p.x - q.x) + (p.y - q.y) * (p.y - q.y);\n\t}\n}\n\n// Output\n//\n// \u5165\u529b\u30c7\u30fc\u30bf\u30bb\u30c3\u30c8\u3054\u3068\u306b\u4ee5\u4e0b\u306e\u5224\u5b9a\u7d50\u679c\u3092\u51fa\u529b\u3057\u307e\u3059\u3002\n//\n// \u5186\u304c\u4e09\u89d2\u5f62\u306b\u542b\u307e\u308c\u308b\u5834\u5408 a\n// \u4e09\u89d2\u5f62\u304c\u5186\u306b\u542b\u307e\u308c\u308b\u5834\u5408 b\n// \u305d\u308c\u4ee5\u5916\u306e\u5834\u5408\u3067\u3001\u5171\u901a\u90e8\u5206\u304c\u3042\u308b\u5834\u5408\u306b\u306f c\n// \u5171\u901a\u90e8\u5206\u304c\u306a\u3044\u5834\u5408\u306b\u306f d\n\nclass Line {\n\tpublic Point2D.Double p1;\n\tpublic Point2D.Double p2;\n\n\tLine(Point2D.Double p1, Point2D.Double p2) {\n\t\tthis.p1 = p1;\n\t\tthis.p2 = p2;\n\t}\n\n\tpublic double length() {\n\t\treturn Math.sqrt((p1.x - p2.x) * (p1.x - p2.x) + (p1.y - p2.y)\n\t\t\t\t* (p1.y - p2.y));\n\t}\n\n\tpublic double ip(Line l) {\n\t\tPoint2D.Double q1 = l.p1;\n\t\tPoint2D.Double q2 = l.p2;\n\t\treturn (p2.x - p1.x) * (q2.x - q1.x) + (p2.y - p1.y) * (q2.y - q1.y);\n\t}\n\n\tpublic double ep(Line l) {\n\t\tPoint2D.Double q1 = l.p1;\n\t\tPoint2D.Double q2 = l.p2;\n\t\treturn (p2.x - p1.x) * (q2.y - q1.y) - (p2.y - p1.y) * (q2.x - q1.x);\n\t}\n\n\tpublic static double distanceSP(Line s, Point2D.Double p) {\n\t\tPoint2D.Double r = proj(s, p);\n\t\tif (intersectSP(s, r))\n\t\t\treturn norm(sub(r, p));\n\t\treturn Math.min(norm(sub(s.p1, p)), norm(sub(s.p2, p)));\n\t}\n\n\tpublic static boolean intersectSP(Line s, Point2D.Double p) {\n\t\treturn ccw(s.p1, s.p2, p) == 0;\n\t}\n\n\tpublic static int ccw(Point2D.Double a, Point2D.Double b, Point2D.Double c) {\n\t\tPoint2D.Double p = sub(b, a);\n\t\tPoint2D.Double q = sub(c, a);\n\t\tif (extp(p, q) > EPS)\n\t\t\treturn 1; // counter clockwise\n\t\tif (extp(p, q) < -EPS)\n\t\t\treturn -1; // clockwise\n\t\tif (inp(p, q) < -EPS)\n\t\t\treturn 2; // c--a--b on line\n\t\tif (Math.abs(norm(p) - norm(q)) < EPS)\n\t\t\treturn -2; // a--b--c on line\n\t\treturn 0; // a--c--b(or a--c=b) on line\n\t}\n\n\tpublic static Point2D.Double sub(Point2D.Double p1, Point2D.Double p2) {\n\t\treturn new Point2D.Double(p1.x - p2.x, p1.y - p2.y);\n\t}\n\n\tpublic static Point2D.Double proj(Line l, Point2D.Double p) {\n\t\tdouble t = inp(sub(p, l.p1), sub(l.p1, l.p2))\n\t\t\t\t/ Math.pow(norm(sub(l.p1, l.p2)), 2);\n\t\tPoint2D.Double tp = sub(l.p1, l.p2);\n\t\treturn new Point2D.Double(l.p1.x + t * tp.x, l.p1.y + t * tp.y);\n\t}\n\n\tpublic static double inp(Point2D.Double p1, Point2D.Double p2) {\n\t\treturn p1.x * p2.x + p1.y * p2.y;\n\t}\n\n\tpublic static double extp(Point2D.Double p1, Point2D.Double p2) {\n\t\treturn p1.x * p2.y - p2.x * p1.y;\n\t}\n\n\tpublic static final double EPS = 1.0e-8;\n\n\tpublic static double norm(Point2D.Double p) {\n\t\treturn Math.hypot(p.x, p.y);\n\t}\n\n\tpublic double disToPoint(Point2D.Double q1) {\n\t\tLine p1q1 = new Line(p1, q1);\n\t\tdouble ip1 = p1q1.ip(this);\n\t\tdouble ip2 = this.ip(this);\n\t\tif (ip1 <= 0)\n\t\t\treturn p1q1.length();\n\t\telse if (0 < ip1 && ip1 < ip2) {\n\t\t\tdouble d2 = ip1 / this.length();\n\t\t\tdouble size = p1q1.length();\n\t\t\treturn Math.sqrt(size * size - d2 * d2);\n\t\t} else {\n\t\t\tLine p2q1 = new Line(p2, q1);\n\t\t\treturn p2q1.length();\n\t\t}\n\t}\n\n\tpublic boolean isCross(Line q1q2) {\n\t\tPoint2D.Double q1 = q1q2.p1;\n\t\tPoint2D.Double q2 = q1q2.p2;\n\t\tLine p1q1 = new Line(p1, q1);\n\t\tLine p1q2 = new Line(p1, q2);\n\t\tLine q1p1 = new Line(q1, p1);\n\t\tLine q1p2 = new Line(q1, p2);\n\t\tif (this.ep(p1q1) * this.ep(p1q2) < 0\n\t\t\t\t&& q1q2.ep(q1p1) * q1q2.ep(q1p2) < 0)\n\t\t\treturn true;\n\t\telse\n\t\t\treturn false;\n\t}\n\n\tpublic double minDistance(Line q1q2) {\n\t\tif (this.isCross(q1q2))\n\t\t\treturn 0;\n\t\tdouble ans = Double.MAX_VALUE;\n\t\tPoint2D.Double q1 = q1q2.p1;\n\t\tPoint2D.Double q2 = q1q2.p2;\n\t\tans = Math.min(ans, this.disToPoint(q1));\n\t\tans = Math.min(ans, this.disToPoint(q2));\n\t\tans = Math.min(ans, q1q2.disToPoint(p1));\n\t\tans = Math.min(ans, q1q2.disToPoint(p2));\n\t\treturn ans;\n\t}\n\n\tpublic String toString() {\n\t\treturn p1 + \"=>\" + p2;\n\t}\n}", "sampled": "import java.util.*;\nimport java.io.*;\n\npublic class Main {\n    static final double EPS = 1e-9;\n    \n    static class Point {\n        double x, y;\n        Point(double x, double y) {\n            this.x = x;\n            this.y = y;\n        }\n        Point sub(Point p) {\n            return new Point(x - p.x, y - p.y);\n        }\n        Point add(Point p) {\n            return new Point(x + p.x, y + p.y);\n        }\n        Point mul(double t) {\n            return new Point(x * t, y * t);\n        }\n        double dot(Point p) {\n            return x * p.x + y * p.y;\n        }\n        double cross(Point p) {\n            return x * p.y - y * p.x;\n        }\n        double norm() {\n            return Math.sqrt(x * x + y * y);\n        }\n    }\n    \n    static double distancePointToSegment(Point p, Point a, Point b) {\n        if (a.sub(b).norm() < EPS) return a.sub(p).norm();\n        Point ab = b.sub(a);\n        Point ap = p.sub(a);\n        double t = ap.dot(ab) / ab.dot(ab);\n        if (t < 0) return ap.norm();\n        if (t > 1) return p.sub(b).norm();\n        Point projection = a.add(ab.mul(t));\n        return p.sub(projection).norm();\n    }\n    \n    static boolean isPointInTriangle(Point p, Point a, Point b, Point c) {\n        double d1 = b.sub(a).cross(p.sub(a));\n        double d2 = c.sub(b).cross(p.sub(b));\n        double d3 = a.sub(c).cross(p.sub(c));\n        \n        boolean hasNeg = (d1 < -EPS) || (d2 < -EPS) || (d3 < -EPS);\n        boolean hasPos = (d1 > EPS) || (d2 > EPS) || (d3 > EPS);\n        \n        return !(hasNeg && hasPos);\n    }\n    \n    static boolean circleInTriangle(Point c, double r, Point a, Point b, Point p) {\n        if (!isPointInTriangle(c, a, b, p)) return false;\n        \n        double d1 = distancePointToSegment(c, a, b);\n        double d2 = distancePointToSegment(c, b, p);\n        double d3 = distancePointToSegment(c, p, a);\n        \n        return d1 >= r - EPS && d2 >= r - EPS && d3 >= r - EPS;\n    }\n    \n    static boolean triangleInCircle(Point c, double r, Point a, Point b, Point p) {\n        double d1 = c.sub(a).norm();\n        double d2 = c.sub(b).norm();\n        double d3 = c.sub(p).norm();\n        \n        return d1 <= r + EPS && d2 <= r + EPS && d3 <= r + EPS;\n    }\n    \n    static boolean circleSegmentIntersect(Point c, double r, Point a, Point b) {\n        double dist = distancePointToSegment(c, a, b);\n        return dist <= r + EPS;\n    }\n    \n    static boolean hasIntersection(Point c, double r, Point a, Point b, Point p) {\n        if (circleSegmentIntersect(c, r, a, b)) return true;\n        if (circleSegmentIntersect(c, r, b, p)) return true;\n        if (circleSegmentIntersect(c, r, p, a)) return true;\n        \n        if (isPointInTriangle(c, a, b, p)) return true;\n        \n        return false;\n    }\n    \n    public static void main(String[] args) throws IOException {\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        String line;\n        \n        while ((line = br.readLine()) != null) {\n            String[] tokens = line.trim().split(\"\\\\s+\");\n            if (tokens.length == 2 && tokens[0].equals(\"0\") && tokens[1].equals(\"0\")) {\n                break;\n            }\n            \n            Point p1 = new Point(Double.parseDouble(tokens[0]), Double.parseDouble(tokens[1]));\n            \n            tokens = br.readLine().trim().split(\"\\\\s+\");\n            Point p2 = new Point(Double.parseDouble(tokens[0]), Double.parseDouble(tokens[1]));\n            \n            tokens = br.readLine().trim().split(\"\\\\s+\");\n            Point p3 = new Point(Double.parseDouble(tokens[0]), Double.parseDouble(tokens[1]));\n            \n            tokens = br.readLine().trim().split(\"\\\\s+\");\n            Point center = new Point(Double.parseDouble(tokens[0]), Double.parseDouble(tokens[1]));\n            \n            tokens = br.readLine().trim().split(\"\\\\s+\");\n            double radius = Double.parseDouble(tokens[0]);\n            \n            if (circleInTriangle(center, radius, p1, p2, p3)) {\n                System.out.println(\"a\");\n            } else if (triangleInCircle(center, radius, p1, p2, p3)) {\n                System.out.println(\"b\");\n            } else if (hasIntersection(center, radius, p1, p2, p3)) {\n                System.out.println(\"c\");\n            } else {\n                System.out.println(\"d\");\n            }\n        }\n    }\n}\n", "perturbed_sampled": ["import java.util.*; import java.io.*; public class Main  =   double   sub(Point  p.y); } Point add(Point p) {  y + p.y); } Point mul(double t) {  y  p) { return x * p.x +  x  p.x; } double norm() { return Math.sqrt(x * x + y * y); } } static double  b) { if (a.sub(b).norm() < EPS) return   t  ap.norm(); if (t > 1) return p.sub(b).norm(); Point projection =  = c.sub(b).cross(p.sub(b)); double d3 = a.sub(c).cross(p.sub(c));  -EPS) || (d2 < -EPS) ||  || (d2 >  } static boolean circleInTriangle(Point c, double  (!isPointInTriangle(c,   d3  d1 >= r - EPS && d2 >=   { double d1 = c.sub(a).norm(); double d2  c.sub(p).norm();  EPS  EPS && d3 <=  + EPS; }   (circleSegmentIntersect(c, r, a, b)) return true; if (circleSegmentIntersect(c, r, b, p)) return true; if (circleSegmentIntersect(c,  if (isPointInTriangle(c, a,  void main(String[] args) throws IOException { BufferedReader  = br.readLine()) != null) { String[]   tokens[1].equals(\"0\")) { break; } Point p1 = new Point(Double.parseDouble(tokens[0]), Double.parseDouble(tokens[1])); tokens = br.readLine().trim().split(\"\\\\s+\"); Point p2 =  br.readLine().trim().split(\"\\\\s+\"); Point  Double.parseDouble(tokens[1])); tokens = br.readLine().trim().split(\"\\\\s+\"); double radius = Double.parseDouble(tokens[0]); if (circleInTriangle(center,  System.out.println(\"a\"); }  { System.out.println(\"d\"); } } } }"], "perturbed_original": ["import java.awt.geom.Point2D; import java.util.Scanner; public class  main(String[] args) throws Exception { Scanner sc = new Scanner(System.in); sc.useDelimiter(\",|\\\\s+\"); while (true)  == 0) break;  y2 = sc.nextInt(); int x3 = sc.nextInt(); int y3 = sc.nextInt();  y4  y1\uff08\u6574\u6570 \u6574\u6570\uff1b\u534a\u89d2\u7a7a\u767d\u533a\u5207\u308a\uff09 // 2\u884c\u76ee  // 5\u884c\u76ee \u5186\u306e\u534a\u5f84r\uff08\u6574\u6570\uff09 // Point2D.Double[]  =  ps[3] = new Point2D.Double(x4, y4); double max = 0;  nor(ps[3],  r   0;  double dis = Math.max(Line.distanceSP(new Line(ps[i], ps[(i + 1) % 3]), ps[3]), Line.distanceSP(new Line( ps[i],  ps[3])); min = Math.min(min, dis);  i++) { double ep = new Line(ps[i],  Line(ps[i], ps[3]));  = false; else  = false;  | right; if (r <= min  double  * (p.x - q.x)  (p.y - q.y); } } // Output //  a // \u4e09\u89d2\u5f62\u304c\u5186\u306b\u542b\u307e\u308c\u308b\u5834\u5408   Point2D.Double p2; Line(Point2D.Double p1, Point2D.Double p2) { this.p1  } public double length()  *  - p2.y)  public double ip(Line l)  Point2D.Double q2 = l.p2; return (p2.x - p1.x)  (q2.y - q1.y); } public double   q1.y) - (p2.y - p1.y) * (q2.x - q1.x); } public  =  return norm(sub(r, p)); return Math.min(norm(sub(s.p1, p)), norm(sub(s.p2,   {  a); if (extp(p, q) >  < -EPS) return -1; //  c--a--b on line if (Math.abs(norm(p) - norm(q))  0; // a--c--b(or  new Point2D.Double(p1.x -  public static Point2D.Double proj(Line l, Point2D.Double p)  + t * tp.y); }  p1.x * p2.x  public static double extp(Point2D.Double   double norm(Point2D.Double p) { return Math.hypot(p.x, p.y); } public double  = new Line(p1, q1); double ip1  0) return p1q1.length(); else if (0 < ip1 && ip1 < ip2)  /  return Math.sqrt(size * size  else { Line  return p2q1.length(); } } public  q2 = q1q2.p2; Line p1q1 = new Line(p1,  =  < 0 && q1q2.ep(q1p1) * q1q2.ep(q1p2) < 0) return  public double minDistance(Line q1q2) {  ans = Double.MAX_VALUE;  = Math.min(ans, this.disToPoint(q1)); ans = Math.min(ans,  ans =  public String toString() {  p2; } }"], "original_ll": -0.7610049247741699, "sampled_ll": -0.36770009994506836, "all_perturbed_sampled_ll": [-2.2359583377838135], "all_perturbed_original_ll": [-2.551231861114502], "perturbed_sampled_ll": -2.2359583377838135, "perturbed_original_ll": -2.551231861114502, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "def In(): return map(int,raw_input().split())\ndef D(a,b): return ((a[0]-b[0])**2+(a[1]-b[1])**2)**.5\ndef side(a, b, c): return (c[1]-a[1])*(b[0]-a[0])-(b[1]-a[1])*(c[0]-a[0])>0\ndef isIn(x,p0,p1,p2): return (side(p0,p1,x)==side(p1,p2,x)==side(p2,p0,x))\ndef S(a,b,c): return abs(a[0]*(b[1]-c[1])+b[0]*(c[1]-a[1])+c[0]*(a[1]-b[1]))/2.0\ndef H(P1,P2,P3): return 2*S(P1,P2,P3)/D(P2,P3)\ndef CinT(P4,r,P1,P2,P3):\n  f1 = isIn(P4,P1,P2,P3)\n  f = [H(P4,P1,P2)>=r, H(P4,P2,P3)>=r, H(P4,P3,P1)>=r]\n  if f1:\n    if all(f): return 1\n    elif any(f): return 3\n  return 0\n\ndef TinC(P4,r,P1,P2,P3):\n  f = [D(P4,P1)<=r, D(P4,P2)<=r, D(P4,P3)<=r]\n  if all(f): return 2\n  elif any(f): return 3\n  return 0\n  \nwhile 1:\n  P1 = In()\n  if P1[0]==P1[1]==0: break\n  P2 = In()\n  P3 = In()\n  P4 = In()\n  r = int(raw_input())\n  f = CinT(P4,r,P1,P2,P3)\n  if not f: f = TinC(P4,r,P1,P2,P3)\n  print 'dabc'[f]", "sampled": "import sys\nfrom math import sqrt\n\ndef read_input():\n    datasets = []\n    lines = sys.stdin.read().strip().split('\\n')\n    i = 0\n    while i < len(lines):\n        parts = lines[i].split()\n        if len(parts) == 2 and parts[0] == '0' and parts[1] == '0':\n            break\n        \n        # Read 3 triangle vertices\n        x1, y1 = map(int, lines[i].split())\n        x2, y2 = map(int, lines[i+1].split())\n        x3, y3 = map(int, lines[i+2].split())\n        \n        # Read circle center and radius\n        xc, yc = map(int, lines[i+3].split())\n        r = int(lines[i+4])\n        \n        datasets.append(((x1, y1), (x2, y2), (x3, y3), (xc, yc), r))\n        i += 5\n    \n    return datasets\n\ndef distance(p1, p2):\n    return sqrt((p1[0] - p2[0])**2 + (p1[1] - p2[1])**2)\n\ndef point_to_segment_distance(p, a, b):\n    ax, ay = a\n    bx, by = b\n    px, py = p\n    \n    abx = bx - ax\n    aby = by - ay\n    apx = px - ax\n    apy = py - ay\n    \n    ab_ab = abx * abx + aby * aby\n    if ab_ab == 0:\n        return distance(p, a)\n    \n    ap_ab = apx * abx + apy * aby\n    t = max(0, min(1, ap_ab / ab_ab))\n    \n    closest_x = ax + t * abx\n    closest_y = ay + t * aby\n    \n    return distance(p, (closest_x, closest_y))\n\ndef point_in_triangle(p, v1, v2, v3):\n    def sign(p1, p2, p3):\n        return (p1[0] - p3[0]) * (p2[1] - p3[1]) - (p2[0] - p3[0]) * (p1[1] - p3[1])\n    \n    d1 = sign(p, v1, v2)\n    d2 = sign(p, v2, v3)\n    d3 = sign(p, v3, v1)\n    \n    has_neg = (d1 < 0) or (d2 < 0) or (d3 < 0)\n    has_pos = (d1 > 0) or (d2 > 0) or (d3 > 0)\n    \n    return not (has_neg and has_pos)\n\ndef circle_in_triangle(v1, v2, v3, center, r):\n    # Check if center is in triangle\n    if not point_in_triangle(center, v1, v2, v3):\n        return False\n    \n    # Check distance from center to all edges\n    d1 = point_to_segment_distance(center, v1, v2)\n    d2 = point_to_segment_distance(center, v2, v3)\n    d3 = point_to_segment_distance(center, v3, v1)\n    \n    return d1 >= r and d2 >= r and d3 >= r\n\ndef triangle_in_circle(v1, v2, v3, center, r):\n    d1 = distance(center, v1)\n    d2 = distance(center, v2)\n    d3 = distance(center, v3)\n    \n    return d1 <= r and d2 <= r and d3 <= r\n\ndef circle_triangle_intersect(v1, v2, v3, center, r):\n    # Check if any vertex is inside or on the circle\n    for v in [v1, v2, v3]:\n        if distance(center, v) <= r:\n            return True\n    \n    # Check if center is inside triangle\n    if point_in_triangle(center, v1, v2, v3):\n        return True\n    \n    # Check if any edge intersects the circle\n    for a, b in [(v1, v2), (v2, v3), (v3, v1)]:\n        if point_to_segment_distance(center, a, b) <= r:\n            return True\n    \n    return False\n\ndef solve(v1, v2, v3, center, r):\n    if circle_in_triangle(v1, v2, v3, center, r):\n        return 'a'\n    elif triangle_in_circle(v1, v2, v3, center, r):\n        return 'b'\n    elif circle_triangle_intersect(v1, v2, v3, center, r):\n        return 'c'\n    else:\n        return 'd'\n\ndatasets = read_input()\nfor v1, v2, v3, center, r in datasets:\n    print(solve(v1, v2, v3, center, r))\n", "perturbed_sampled": ["import sys from math import sqrt def read_input(): datasets =  lines[i].split() if len(parts)  '0':     y3), (xc, yc), r)) i += 5 return datasets def distance(p1, p2):  (p1[1] -  ax, ay = a bx, by = b px,  bx - ax aby = by - ay apx = px -  * aby if   min(1, ap_ab /  = ay  point_in_triangle(p,   p3[0]) * (p1[1]  0) or (d2 < 0) or (d3 <   or (d3 >  v3, center, r): # Check if center  point_in_triangle(center, v1, v2, v3): return False # Check distance  d1 >= r and d2 >= r and d3  v3, center, r): d1  <= r  r): # Check if any vertex is inside  v in [v1, v2, v3]: if distance(center, v) <= r:   return True # Check if any edge intersects the circle  v2), (v2, v3), (v3, v1)]: if point_to_segment_distance(center, a, b) <= r: return True  r): return 'a'  circle_triangle_intersect(v1, v2, v3, center, r): return 'c' else: return 'd' datasets = read_input() for v1, v2, v3, center, r in datasets: print(solve(v1, v2, v3, center, r))"], "perturbed_original": ["   CinT(P4,r,P1,P2,P3): f1 =  H(P4,P3,P1)>=r] if f1: if all(f): return 1 elif any(f): return 3 return 0 def TinC(P4,r,P1,P2,P3): f = [D(P4,P1)<=r, D(P4,P2)<=r, D(P4,P3)<=r]  any(f): return  P1[0]==P1[1]==0:  =  = int(raw_input()) f  f = TinC(P4,r,P1,P2,P3) print 'dabc'[f]"], "original_ll": -1.0256099700927734, "sampled_ll": -0.4620826542377472, "all_perturbed_sampled_ll": [-2.5881588459014893], "all_perturbed_original_ll": [-2.6726016998291016], "perturbed_sampled_ll": -2.5881588459014893, "perturbed_original_ll": -2.6726016998291016, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "#include <stdio.h>\n\nint count;\nvoid solve(int depth, int card[][2], int n, int total, int goal) {\n\tint i;\n\tif(depth == n) {\n\t\tif(total == goal)\n\t\t\tcount++;\n\t\treturn;\n\t}\n\t\n\tfor(i=0;i<=card[depth][1];i++) {\n\t\tsolve(depth+1, card, n, total + card[depth][0] * i, goal);\n\t}\n}\n\nint main(void) {\n\tint n, g;\n\tint i;\n\tint goal;\n\tint j[1001];\n\tint card[1001][2];\n\twhile(1) {\n\t\tcount = 0;\n\t\tscanf(\"%d\\n\", &n);\n\t\tif(n==0) break;\n\t\tfor(i=0;i<n;i++) {\n\t\t\tscanf(\"%d %d\\n\", &card[i][0], &card[i][1]);\n\t\t}\n\t\tscanf(\"%d\\n\", &g);\n\t\tfor(i-0;i<g;i++) {\n\t\t\tscanf(\"%d\\n\", &goal);\n\t\t\tsolve(0, card, n, 0, goal);\t\n\t\t\tprintf(\"%d\\n\", count);\n\t\t}\n\t}\n\treturn 0;\n}", "sampled": "#include <stdio.h>\n\nint m, g;\nint a[7], b[7];\nint n;\nint count;\n\nvoid dfs(int idx, int sum) {\n    if (idx == m) {\n        if (sum == n) {\n            count++;\n        }\n        return;\n    }\n    \n    for (int i = 0; i <= b[idx]; i++) {\n        dfs(idx + 1, sum + i * a[idx]);\n    }\n}\n\nint main() {\n    while (1) {\n        scanf(\"%d\", &m);\n        if (m == 0) break;\n        \n        for (int i = 0; i < m; i++) {\n            scanf(\"%d %d\", &a[i], &b[i]);\n        }\n        \n        scanf(\"%d\", &g);\n        \n        for (int i = 0; i < g; i++) {\n            scanf(\"%d\", &n);\n            count = 0;\n            dfs(0, 0);\n            printf(\"%d\\n\", count);\n        }\n    }\n    \n    return 0;\n}\n", "perturbed_sampled": ["#include <stdio.h>  (idx == m)  { count++; } return; } for (int i = 0; i <= b[idx];  sum + i *  i < m; i++)  (int i = 0; i < g; i++) { scanf(\"%d\", &n); count = 0;  } return 0; }"], "perturbed_original": ["#include <stdio.h> int count; void solve(int depth, int card[][2], int n, int )<extra_id_5>n /<extra_id_6>= n %<extra_id_7>i %<extra_id_8>] ) ; if (<extra_id_9>== 1 ) {<extra_id_10>i %<extra_id_11>p<extra_id_12>++ == 0 )<extra_id_13>; }<extra_id_14>count * 1 %<extra_id_15>] [ n ]<extra_id_16>;<extra_id_17>= n; count++<extra_id_18>\\n\" ,<extra_id_19>] ;<extra_id_20>} i; if(depth ==   + card[depth][0]  int main(void) { int n, g; int i; int goal; int  &n);  %d\\n\",  solve(0,   }"], "original_ll": -0.9316422939300537, "sampled_ll": -0.5729726552963257, "all_perturbed_sampled_ll": [-2.8438169956207275], "all_perturbed_original_ll": [-2.7039551734924316], "perturbed_sampled_ll": -2.8438169956207275, "perturbed_original_ll": -2.7039551734924316, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import java.util.*;\n\npublic class AOJ_0154{\n    class Card{\n        int a;\n        int b;\n        Card(int a, int b){\n            this.a = a;\n            this.b = b;\n        }\n    }\n    void run(){\n        Scanner sc = new Scanner(System.in);\n        while(true){\n            int[] card_num = new int[101];\n            int m = sc.nextInt();\n            if(m==0){\n                break;\n            }\n            Card[] cards = new Card[m];\n            for(int i = 0; i < m; i++){\n                cards[i] = new Card(sc.nextInt(), sc.nextInt());\n            }\n            int ub = 7*100*10;\n            int[] dp = new int[ub];\n            dp[0] = 1;\n            for(int i = 0; i < m; i++){\n                for(int ii = 7 * 100 * 10 - cards[i].a -1; ii >= 0; ii--){\n                    for(int iii = 1; iii <= cards[i].b; iii++){\n                        if(ii + cards[i].a*iii < ub-1){\n                            dp[ii + cards[i].a*iii] += dp[ii];\n                        }\n                    }\n                }\n            }\n            /*\n              System.out.println(Arrays.toString(dp));\n              for(int i = 0; i < 100; i++){\n              System.out.println(i + \" : \" + dp[i]);\n              }\n            */\n            int g = sc.nextInt();\n            for(int i = 0; i < g; i++){\n                System.out.println(dp[sc.nextInt()]);\n            }\n        }\n    }\n    public static void main(String[] args){\n        new AOJ_0154().run();\n    }\n}", "sampled": "import java.util.*;\n\npublic class Main {\n    static int[] values;\n    static int[] counts;\n    static int m;\n    \n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        \n        while (true) {\n            m = sc.nextInt();\n            if (m == 0) break;\n            \n            values = new int[m];\n            counts = new int[m];\n            \n            for (int i = 0; i < m; i++) {\n                values[i] = sc.nextInt();\n                counts[i] = sc.nextInt();\n            }\n            \n            int g = sc.nextInt();\n            for (int i = 0; i < g; i++) {\n                int n = sc.nextInt();\n                int result = countCombinations(n);\n                System.out.println(result);\n            }\n        }\n        sc.close();\n    }\n    \n    static int countCombinations(int target) {\n        return dfs(0, target);\n    }\n    \n    static int dfs(int index, int remaining) {\n        if (remaining == 0) {\n            return 1;\n        }\n        if (remaining < 0 || index >= m) {\n            return 0;\n        }\n        \n        int total = 0;\n        for (int i = 0; i <= counts[index]; i++) {\n            int newRemaining = remaining - (i * values[index]);\n            if (newRemaining < 0) break;\n            total += dfs(index + 1, newRemaining);\n        }\n        \n        return total;\n    }\n}\n", "perturbed_sampled": ["import java.util.*; public class Main  int[] counts; static int   int[m]; for (int i = 0; i < m; i++)  (int i = 0; i <   countCombinations(n); System.out.println(result);  return dfs(0, target); } static int  { return 1; } if (remaining < 0 || index >=  int total   i++) { int newRemaining  values[index]); if (newRemaining < 0)  1, newRemaining); } return total; } }"], "perturbed_original": ["import java.util.*; public class AOJ_0154{ class Card{ int a; int  void run(){ Scanner sc = new Scanner(System.in); while(true){ int[] card_num = new   i   sc.nextInt()); } int  =  for(int ii  10 - cards[i].a -1; ii  } } } }  0; i < 100;  \" + dp[i]); } */ int g = sc.nextInt(); for(int i =  System.out.println(dp[sc.nextInt()]); } } } public static void  }"], "original_ll": -0.8275666832923889, "sampled_ll": -0.5494576096534729, "all_perturbed_sampled_ll": [-2.8639721870422363], "all_perturbed_original_ll": [-3.271428108215332], "perturbed_sampled_ll": -2.8639721870422363, "perturbed_original_ll": -3.271428108215332, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import sys\nfrom array import array\n\ndef main():\n\twhile True:\n\t\tm = input()\n\t\tif m == 0: return 0\n\t\tdp = [array('I', [0] * 1001) for i in range(m + 1)]\n\t\tdp[0][0] = 1\n\t\tfor i in xrange(m):\n\t\t\tv, c = map(int, raw_input().split())\n\t\t\tfor j in xrange(1001):\n\t\t\t\tfor k in xrange(c + 1):\n\t\t\t\t\tnext = j + v * k\n\t\t\t\t\tif next > 1000: continue\n\t\t\t\t\tdp[i + 1][next] += dp[i][j]\n\t\tn = input()\n\t\tfor i in range(n):\n\t\t\tx = input()\n\t\t\tprint dp[m][x]\n\nif __name__ == '__main__':\n\tsys.exit(main())", "sampled": "import sys\nfrom itertools import product\n\ndef count_combinations(cards, target):\n    count = 0\n    # Generate all possible combinations\n    ranges = [range(b + 1) for a, b in cards]\n    \n    for combination in product(*ranges):\n        total = sum(combination[i] * cards[i][0] for i in range(len(cards)))\n        if total == target:\n            count += 1\n    \n    return count\n\ndef main():\n    lines = []\n    for line in sys.stdin:\n        lines.append(line.strip())\n    \n    idx = 0\n    while idx < len(lines):\n        m = int(lines[idx])\n        if m == 0:\n            break\n        \n        idx += 1\n        cards = []\n        for _ in range(m):\n            a, b = map(int, lines[idx].split())\n            cards.append((a, b))\n            idx += 1\n        \n        g = int(lines[idx])\n        idx += 1\n        \n        for _ in range(g):\n            n = int(lines[idx])\n            idx += 1\n            result = count_combinations(cards, n)\n            print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "perturbed_sampled": ["import sys from itertools import product def  # Generate all    1 return count  for line  0 while idx <   [] for _ in range(m): a, b =  += 1 g   = int(lines[idx]) idx += 1 result = count_combinations(cards, n) print(result) if __name__ == \"__main__\": main()"], "perturbed_original": ["import   dp =  i in range(m  v, c = map(int, raw_input().split()) for j in xrange(1001): for k in xrange(c + 1):   1][next] += dp[i][j] n  range(n): x = input() print  sys.exit(main())"], "original_ll": -0.9920486211776733, "sampled_ll": -0.8145204782485962, "all_perturbed_sampled_ll": [-3.554133653640747], "all_perturbed_original_ll": [-3.7531752586364746], "perturbed_sampled_ll": -3.554133653640747, "perturbed_original_ll": -3.7531752586364746, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "//from PKU1125\n#define M 101\ndouble dist[M][M],d;\nnext[M][M],x[M],y[M];\nmain(){\n\tint a,b,k,n,i,j;\n\tfor(;scanf(\"%d\",&n),n;){\n\t\t/*initialize*/\n\t\tfor(i=1;i<=n;i++)scanf(\"%d\",&a),scanf(\"%d%d\",x+a,y+a);\n\t\tfor(i=1;i<=n;i++)for(j=1;j<=n;next[i][j]=j,j++)\n\t\t\tdist[i][j]=(d=hypot(x[i]-x[j],y[i]-y[j]))<50.1?d:999;\n\n\t\t{/*warshall-floyd*/\n\t\t\tint k,i,j;\n\t\t\tfor(k=1;k<=n;k++)\n\t\t\t\tfor(i=1;i<=n;i++)\n\t\t\t\t\tfor(j=1;j<=n;j++){\n\t\t\t\t\t\tif(dist[i][j]>dist[i][k]+dist[k][j])\n\t\t\t\t\t\t\tdist[i][j]=dist[i][k]+dist[k][j],next[i][j]=next[i][k];\n\t\t\t\t\t}\n\t\t}\n\n\t\t{/*query*/\n\t\t\tfor(scanf(\"%d\",&k);k;k--){\n\t\t\t\tscanf(\"%d%d\",&a,&b);\n\t\t\t\tif(dist[a][b]>998)puts(\"NA\");\n\t\t\t\telse{\n\t\t\t\t\tfor(j=a;j!=b;j=next[j][b])printf(\"%d \",j);\n\t\t\t\t\tprintf(\"%d\\n\",b);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}exit(0);\n}", "sampled": "#include <stdio.h>\n#include <stdlib.h>\n#include <math.h>\n#include <string.h>\n\n#define MAX_N 101\n#define INF 1e9\n\ntypedef struct {\n    int id;\n    int x, y;\n} Building;\n\nBuilding buildings[MAX_N];\nint n;\ndouble dist[MAX_N][MAX_N];\nint next_node[MAX_N][MAX_N];\n\ndouble calc_dist(int i, int j) {\n    double dx = buildings[i].x - buildings[j].x;\n    double dy = buildings[i].y - buildings[j].y;\n    return sqrt(dx * dx + dy * dy);\n}\n\nvoid floyd_warshall() {\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < n; j++) {\n            if (i == j) {\n                dist[i][j] = 0;\n                next_node[i][j] = -1;\n            } else {\n                double d = calc_dist(i, j);\n                if (d <= 50.0) {\n                    dist[i][j] = d;\n                    next_node[i][j] = j;\n                } else {\n                    dist[i][j] = INF;\n                    next_node[i][j] = -1;\n                }\n            }\n        }\n    }\n    \n    for (int k = 0; k < n; k++) {\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < n; j++) {\n                if (dist[i][k] + dist[k][j] < dist[i][j]) {\n                    dist[i][j] = dist[i][k] + dist[k][j];\n                    next_node[i][j] = next_node[i][k];\n                }\n            }\n        }\n    }\n}\n\nvoid print_path(int start, int end) {\n    if (dist[start][end] >= INF) {\n        printf(\"NA\\n\");\n        return;\n    }\n    \n    printf(\"%d\", buildings[start].id);\n    int current = start;\n    while (current != end) {\n        current = next_node[current][end];\n        printf(\" %d\", buildings[current].id);\n    }\n    printf(\"\\n\");\n}\n\nint main() {\n    while (1) {\n        scanf(\"%d\", &n);\n        if (n == 0) break;\n        \n        for (int i = 0; i < n; i++) {\n            scanf(\"%d %d %d\", &buildings[i].id, &buildings[i].x, &buildings[i].y);\n        }\n        \n        floyd_warshall();\n        \n        int m;\n        scanf(\"%d\", &m);\n        \n        for (int i = 0; i < m; i++) {\n            int s, g;\n            scanf(\"%d %d\", &s, &g);\n            \n            int si = -1, gi = -1;\n            for (int j = 0; j < n; j++) {\n                if (buildings[j].id == s) si = j;\n                if (buildings[j].id == g) gi = j;\n            }\n            \n            print_path(si, gi);\n        }\n    }\n    \n    return 0;\n}\n", "perturbed_sampled": ["#include <stdio.h>  <string.h> #define  typedef struct { int id;  Building buildings[MAX_N]; int n; double dist[MAX_N][MAX_N]; int next_node[MAX_N][MAX_N];  { double dx = buildings[i].x   floyd_warshall() { for (int i = 0;  for (int j = 0;  { dist[i][j] = 0; next_node[i][j] = -1;   <= 50.0) {  j; }  next_node[i][j] = -1; } }  =  {   for (int j  { dist[i][j] = dist[i][k] + dist[k][j]; next_node[i][j] = next_node[i][k]; } }  { printf(\"NA\\n\"); return; } printf(\"%d\", buildings[start].id);  (current  next_node[current][end]; printf(\" %d\", buildings[current].id); }  &n);  0; i < n;  &buildings[i].id,  m; scanf(\"%d\",   gi = -1; for (int j = 0;  if (buildings[j].id ==  (buildings[j].id  }  0; }"], "perturbed_original": ["//from  dist[M][M],d;   for(j=1;j<=n;j++){ if(dist[i][j]>dist[i][k]+dist[k][j])  scanf(\"%d%d\",&a,&b); if(dist[a][b]>998)puts(\"NA\"); else{ for(j=a;j!=b;j=next[j][b])printf(\"%d \",j); printf(\"%d\\n\",b); } } } }exit(0); }"], "original_ll": -1.3808962106704712, "sampled_ll": -0.361834853887558, "all_perturbed_sampled_ll": [-2.2079930305480957], "all_perturbed_original_ll": [-2.4759328365325928], "perturbed_sampled_ll": -2.2079930305480957, "perturbed_original_ll": -2.4759328365325928, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.NoSuchElementException;\nimport java.util.Scanner;\npublic class Main {\n\tstatic PrintWriter out = new PrintWriter(System.out);\n\tstatic Scanner stdIn = new Scanner(System.in);\n\tstatic FastScanner sc = new FastScanner();\n\tstatic int INF = 2 << 20;\n\t\n\tpublic static void main(String[] args) {\n\t\twhile(true) {\n\t\t\tint n = sc.nextInt();\n\t\t\tif(n == 0) break;\n\t\t\tdouble [][] cost = new double[n+1][n+1];\n\t\t\t\n\t\t\tfor(int i = 0; i < n+1; i++) {\n\t\t\t\tArrays.fill(cost[i], INF);\n\t\t\t}\n\t\t\tData[] list = new Data[n];\n\t\t\tfor(int i = 0; i < n; i++) {\n\t\t\t\tint a = sc.nextInt();\n\t\t\t\tint b = sc.nextInt();\n\t\t\t\tint c = sc.nextInt();\n\t\t\t\tlist[i] = new Data(a,b,c);\n\t\t\t}\n\t\t\tfor(int i = 0; i < n; i++) {\n\t\t\t\tfor(int j = 0; j < n; j++) {\n\t\t\t\t\tdouble sum = Math.sqrt((list[i].x - list[j].x)*(list[i].x - list[j].x) + (list[i].y - list[j].y) * (list[i].y - list[j].y));\n\t\t\t\t\tif(sum > 50.0) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tcost[list[i].id][list[j].id] = sum;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tint m = sc.nextInt();\n\t\t\t\n\t\t\tfor(int i = 0; i < m; i++) {\n\t\t\t\tdouble[] d = new double[n+1];\n\t\t\t\tboolean[] used = new boolean[n+1];\n\t\t\t\tint[] prev = new int[n+1];\n\t\t\t\tint s = sc.nextInt();\n\t\t\t\tint g = sc.nextInt();\n\t\t\t\t\n\t\t\t\tArrays.fill(d, INF);\n\t\t\t\tArrays.fill(used, false);\n\t\t\t\tArrays.fill(prev, -1);\n\t\t\t\td[s] = 0;\n\t\t\t\t\n\t\t\t\twhile(true) {\n\t\t\t\t\tint v = -1;\n\t\t\t\t\tfor(int u= 0; u < n+1; u++) {\n\t\t\t\t\t\tif(!used[u] && (v == -1 || d[u] < d[v])) v = u;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tif(v == -1) break;\n\t\t\t\t\tused[v] = true;\n\t\t\t\t\t\n\t\t\t\t\tfor(int u = 0; u < n+1; u++) {\n\t\t\t\t\t\tif(d[u] > d[v] + cost[v][u]) {\n\t\t\t\t\t\t\td[u] = d[v] + cost[v][u];\n\t\t\t\t\t\t\tprev[u] = v;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif(d[g] == INF) {\n\t\t\t\t\tout.println(\"NA\");\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tArrayList<Integer> Xist = new ArrayList<Integer>();\n\t\t\t\tfor(; g != -1; g = prev[g]) Xist.add(g);\n\t\t\t\t\n\t\t\t\tCollections.reverse(Xist);\n\t\t\t\tout.print(Xist.get(0));\n\t\t\t\tfor(int j = 1; j < Xist.size(); j++) {\n\t\t\t\t\tout.print(\" \" + Xist.get(j));\n\t\t\t\t}\n\t\t\t\tout.println();\n\t\t\t\t\n\t\t\t\t\n\t\t\t}\n\t\t\t\n\t\t\t\n\t\t\t\n\t\t}\n\t\tout.flush();\n\t}\n\t\n\tstatic class Data {\n\t\tint id;\n\t\tint x;\n\t\tint y;\n\t\t\n\t\tData(int a, int b, int c) {\n\t\t\tid = a;\n\t\t\tx = b;\n\t\t\ty = c;\n\t\t}\n\t}\n\t\n\n\n}\n\nclass FastScanner {\n    private final InputStream in = System.in;\n    private final byte[] buffer = new byte[1024];\n    private int ptr = 0;\n    private int buflen = 0;\n    private boolean hasNextByte() {\n        if (ptr < buflen) {\n            return true;\n        }else{\n            ptr = 0;\n            try {\n                buflen = in.read(buffer);\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n            if (buflen <= 0) {\n                return false;\n            }\n        }\n        return true;\n    }\n    private int readByte() { if (hasNextByte()) return buffer[ptr++]; else return -1;}\n    private static boolean isPrintableChar(int c) { return 33 <= c && c <= 126;}\n    private void skipUnprintable() { while(hasNextByte() && !isPrintableChar(buffer[ptr])) ptr++;}\n    public boolean hasNext() { skipUnprintable(); return hasNextByte();}\n    public String next() {\n        if (!hasNext()) throw new NoSuchElementException();\n        StringBuilder sb = new StringBuilder();\n        int b = readByte();\n        while(isPrintableChar(b)) {\n            sb.appendCodePoint(b);\n            b = readByte();\n        }\n        return sb.toString();\n    }\n    public long nextLong() {\n        if (!hasNext()) throw new NoSuchElementException();\n        long n = 0;\n        boolean minus = false;\n        int b = readByte();\n        if (b == '-') {\n            minus = true;\n            b = readByte();\n        }\n        if (b < '0' || '9' < b) {\n            throw new NumberFormatException();\n        }\n        while(true){\n            if ('0' <= b && b <= '9') {\n                n *= 10;\n                n += b - '0';\n            }else if(b == -1 || !isPrintableChar(b)){\n                return minus ? -n : n;\n            }else{\n                throw new NumberFormatException();\n            }\n            b = readByte();\n        }\n    }\n     \n    public int nextInt() {\n        return (int)nextLong();\n    }\n     \n    public double nextDouble() {\n        return Double.parseDouble(next());\n    }\n     \n \n}", "sampled": "import java.util.*;\n\npublic class Main {\n    static class Building {\n        int id;\n        int x, y;\n        \n        Building(int id, int x, int y) {\n            this.id = id;\n            this.x = x;\n            this.y = y;\n        }\n        \n        double distance(Building other) {\n            return Math.sqrt((x - other.x) * (x - other.x) + (y - other.y) * (y - other.y));\n        }\n    }\n    \n    static class State implements Comparable<State> {\n        int buildingId;\n        double distance;\n        \n        State(int buildingId, double distance) {\n            this.buildingId = buildingId;\n            this.distance = distance;\n        }\n        \n        @Override\n        public int compareTo(State other) {\n            return Double.compare(this.distance, other.distance);\n        }\n    }\n    \n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        \n        while (true) {\n            int n = sc.nextInt();\n            if (n == 0) break;\n            \n            Map<Integer, Building> buildings = new HashMap<>();\n            \n            for (int i = 0; i < n; i++) {\n                int id = sc.nextInt();\n                int x = sc.nextInt();\n                int y = sc.nextInt();\n                buildings.put(id, new Building(id, x, y));\n            }\n            \n            int m = sc.nextInt();\n            \n            for (int i = 0; i < m; i++) {\n                int start = sc.nextInt();\n                int goal = sc.nextInt();\n                \n                List<Integer> path = findPath(buildings, start, goal);\n                \n                if (path == null) {\n                    System.out.println(\"NA\");\n                } else {\n                    StringBuilder sb = new StringBuilder();\n                    for (int j = 0; j < path.size(); j++) {\n                        if (j > 0) sb.append(\" \");\n                        sb.append(path.get(j));\n                    }\n                    System.out.println(sb.toString());\n                }\n            }\n        }\n        \n        sc.close();\n    }\n    \n    static List<Integer> findPath(Map<Integer, Building> buildings, int start, int goal) {\n        Map<Integer, Double> dist = new HashMap<>();\n        Map<Integer, Integer> prev = new HashMap<>();\n        PriorityQueue<State> pq = new PriorityQueue<>();\n        \n        for (int id : buildings.keySet()) {\n            dist.put(id, Double.MAX_VALUE);\n        }\n        \n        dist.put(start, 0.0);\n        pq.offer(new State(start, 0.0));\n        \n        while (!pq.isEmpty()) {\n            State current = pq.poll();\n            int currentId = current.buildingId;\n            \n            if (current.distance > dist.get(currentId)) {\n                continue;\n            }\n            \n            if (currentId == goal) {\n                break;\n            }\n            \n            Building currentBuilding = buildings.get(currentId);\n            \n            for (int nextId : buildings.keySet()) {\n                if (nextId == currentId) continue;\n                \n                Building nextBuilding = buildings.get(nextId);\n                double distance = currentBuilding.distance(nextBuilding);\n                \n                if (distance <= 50.0) {\n                    double newDist = dist.get(currentId) + distance;\n                    \n                    if (newDist < dist.get(nextId)) {\n                        dist.put(nextId, newDist);\n                        prev.put(nextId, currentId);\n                        pq.offer(new State(nextId, newDist));\n                    }\n                }\n            }\n        }\n        \n        if (!prev.containsKey(goal) && start != goal) {\n            return null;\n        }\n        \n        List<Integer> path = new ArrayList<>();\n        int current = goal;\n        \n        while (current != start) {\n            path.add(current);\n            if (!prev.containsKey(current)) {\n                return null;\n            }\n            current = prev.get(current);\n        }\n        path.add(start);\n        \n        Collections.reverse(path);\n        return path;\n    }\n}\n", "perturbed_sampled": ["import java.util.*;  class Building   int y) { this.id = id; this.x = x;  Math.sqrt((x -   buildingId; double distance; State(int buildingId, double distance) { this.buildingId = buildingId;  public int compareTo(State other) { return Double.compare(this.distance, other.distance); } } public static void main(String[] args) { Scanner sc = new  n = sc.nextInt(); if  HashMap<>(); for (int i = 0;  int id =  buildings.put(id, new Building(id, x, y)); } int m = sc.nextInt(); for (int i = 0;  int start =    <  static List<Integer> findPath(Map<Integer,  goal) { Map<Integer, Double>  Integer>  pq =  Double.MAX_VALUE); } dist.put(start, 0.0);  { State  = current.buildingId; if  } if (currentId  Building  buildings.get(nextId); double distance = currentBuilding.distance(nextBuilding);  double newDist = dist.get(currentId)   currentId); pq.offer(new State(nextId, newDist)); } } } } if (!prev.containsKey(goal)  return   goal; while (current !=  { return null; }  }"], "perturbed_original": [" java.io.PrintWriter; import java.util.ArrayList; import java.util.Arrays;  {  FastScanner();   sc.nextInt(); if(n ==  i   Data[n]; for(int  n; i++) {  = new Data(a,b,c); } for(int  - list[j].x)*(list[i].x - list[j].x)  (list[i].y -   = sc.nextInt(); for(int i = 0; i < m; i++) { double[] d = new double[n+1]; boolean[] used  = new int[n+1]; int s =  Arrays.fill(d, INF); Arrays.fill(used, false); Arrays.fill(prev, -1); d[s] = 0; while(true)   ||   { if(d[u] > d[v] + cost[v][u]) { d[u] = d[v] + cost[v][u]; prev[u] = v; } } } if(d[g] ==  ArrayList<Integer>(); for(; g != -1; g =   \" + Xist.get(j)); } out.println(); } }  { int id; int x; int y; Data(int a, int b, int c) { id = a; x = b; y =  InputStream in = System.in; private final byte[] buffer =  buflen = 0;  = 0;  } catch (IOException e) { e.printStackTrace(); }  return false; } } return true; }  (hasNextByte())  private static   !isPrintableChar(buffer[ptr])) ptr++;} public boolean hasNext() { skipUnprintable(); return hasNextByte();} public String next()  NoSuchElementException();  nextLong() { if  n = 0;  b = readByte(); if (b == '-')  = readByte();  { throw new  <= b && b <= '9')  || !isPrintableChar(b)){ return minus ? -n : n; }else{ throw new NumberFormatException(); }  public int nextInt() { return (int)nextLong(); } public double  }"], "original_ll": -0.5654093027114868, "sampled_ll": -0.38648414611816406, "all_perturbed_sampled_ll": [-2.754869222640991], "all_perturbed_original_ll": [-2.693180561065674], "perturbed_sampled_ll": -2.754869222640991, "perturbed_original_ll": -2.693180561065674, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import copy, math\n\ndef f(n, d, D, res, buil):\n    global sd, ans\n    d += D\n    res.append(n)\n    if sd is not None and sd <= d:\n        return\n    elif n == g:\n        ans = res\n        sd = d\n        return\n    else:\n        new_buil = copy.deepcopy(buil)\n        A = new_buil[n]\n        del new_buil[n]\n        for m, B in new_buil.items():\n            D = py(A, B)\n            if D:\n                f(m, d, D, res[:], new_buil)\n            \ndef py(A, B):\n    x = 0\n    y = 1\n    D = math.sqrt((B[x]-A[x])**2+(B[y]-A[y])**2)\n    if D <= 50:\n        return D\n\nwhile True:\n    N = input()\n    if N == 0: break\n    buil = {}\n    for i in range(N):\n        n, x, y = map(int, raw_input().split())\n        buil[n] = (x, y)\n    for i in range(input()):\n        s, g = map(int, raw_input().split())\n        sd = None\n        ans = None\n        f(s, 0, 0, [], buil)\n        if ans:\n            print ' '.join(map(str, ans))\n        else:\n            print 'NA'", "sampled": "import sys\nfrom collections import deque\nimport math\n\ndef distance(p1, p2):\n    return math.sqrt((p1[0] - p2[0])**2 + (p1[1] - p2[1])**2)\n\ndef bfs(start, goal, buildings, adjacency):\n    if start == goal:\n        return [start]\n    \n    queue = deque([(start, [start])])\n    visited = {start}\n    \n    while queue:\n        current, path = queue.popleft()\n        \n        for neighbor in adjacency[current]:\n            if neighbor in visited:\n                continue\n            \n            visited.add(neighbor)\n            new_path = path + [neighbor]\n            \n            if neighbor == goal:\n                return new_path\n            \n            queue.append((neighbor, new_path))\n    \n    return None\n\nwhile True:\n    n = int(input())\n    if n == 0:\n        break\n    \n    buildings = {}\n    for _ in range(n):\n        parts = list(map(int, input().split()))\n        b_id = parts[0]\n        x = parts[1]\n        y = parts[2]\n        buildings[b_id] = (x, y)\n    \n    # Build adjacency list\n    adjacency = {b_id: [] for b_id in buildings}\n    for b1 in buildings:\n        for b2 in buildings:\n            if b1 != b2:\n                dist = distance(buildings[b1], buildings[b2])\n                if dist <= 50:\n                    adjacency[b1].append(b2)\n    \n    m = int(input())\n    results = []\n    for _ in range(m):\n        s, g = map(int, input().split())\n        path = bfs(s, g, buildings, adjacency)\n        if path is None:\n            results.append(\"NA\")\n        else:\n            results.append(\" \".join(map(str, path)))\n    \n    for result in results:\n        print(result)\n", "perturbed_sampled": ["import sys from collections import deque import math def distance(p1, p2):  return  visited = {start} while queue: current, path = queue.popleft() for neighbor in adjacency[current]: if neighbor  if neighbor  break  in range(n): parts =   [] for b_id  buildings: for b2 in buildings: if b1 != b2: dist = distance(buildings[b1], buildings[b2]) if dist   path = bfs(s, g, buildings, adjacency) if path is  path))) for result in results: print(result)"], "perturbed_original": ["import  D res.append(n) if sd  <=  g: ans = res  new_buil = copy.deepcopy(buil) A  if D: f(m, d, D,  x = 0 y = 1  while True: N = input()  i in range(N): n, x,  = (x, y) for i in  raw_input().split()) sd  buil)  ans)) else: print 'NA'"], "original_ll": -1.3316826820373535, "sampled_ll": -0.5126494765281677, "all_perturbed_sampled_ll": [-3.018784523010254], "all_perturbed_original_ll": [-4.141317844390869], "perturbed_sampled_ll": -3.018784523010254, "perturbed_original_ll": -4.141317844390869, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "#include <stdio.h>\n#include <string.h>\n\ntypedef struct {\n    int ty;\n    int tx;\n    int sharp;\n} POINT;\n\nPOINT queue[10000000];\nint head, tail;\n\nvoid enq(POINT t)\n{\n    queue[tail++] = t;\n    if (tail == 10000000){\n        tail = 0;\n    }\n}\n\nvoid deq(POINT *t)\n{\n    *t = queue[head++];\n    if (head == 10000000){\n        head = 0;\n    }\n}\n\nint main(void)\n{\n    POINT temp, add;\n    int ans;\n    int i, j;\n    int x, y;\n    int mx, my;\n    int dx[4] = {1, 0, -1, 0};\n    int dy[4] = {0, 1, 0, -1};\n    int cost[102][102];\n    char map[102][103];\n    \n    while (1){\n        scanf(\"%d%d\", &x, &y);\n        \n        if (x + y == 0){\n            break;\n        }\n        getchar();\n        \n        memset(map, '.', sizeof(map));\n        \n        for (i = 1; i <= y; i++){\n            for (j = 1; j <= x; j++){\n                scanf(\"%c\", &map[i][j]);\n                \n                if (map[i][j] == '&'){\n                    temp.tx = j;\n                    temp.ty = i;\n                }\n            }\n            getchar();\n        }\n        \n        for (i = 0; i <= y + 1; i++){\n            for (j = 0; j <= x + 1; j++){\n                cost[i][j] = 100000;\n            }\n        }\n        \n        cost[temp.ty][temp.tx] = 0;\n        temp.sharp = 0;\n        head = tail = 0;\n        enq(temp);\n        ans = 100000;\n        \n        while (head != tail){\n            deq(&temp);\n            \n            if (0 == temp.tx || 0 == temp.ty || x + 1 == temp.tx || y + 1 == temp.ty){\n                ans = (ans > temp.sharp ? temp.sharp : ans);\n                continue;\n            }\n            \n            for (i = 0; i < 4; i++){\n                mx = temp.tx + dx[i];\n                my = temp.ty + dy[i];\n                add = temp;\n                if (cost[my][mx] > add.sharp){\n                    if ((map[my][mx] == '.') && map[temp.ty][temp.tx] == '#'){\n                        add.sharp++;\n                    }\n                    cost[my][mx] = add.sharp;\n                    add.tx = mx;\n                    add.ty = my;\n                    enq(add);\n                }\n            }\n        }\n        \n        printf(\"%d\\n\", ans);\n    }\n    \n    return (0);\n}", "sampled": "#include <stdio.h>\n#include <string.h>\n#include <limits.h>\n\n#define MAXN 105\n\ntypedef struct {\n    int x, y, cost;\n} State;\n\ntypedef struct {\n    State data[MAXN * MAXN];\n    int front, rear;\n} Queue;\n\nvoid initQueue(Queue *q) {\n    q->front = 0;\n    q->rear = 0;\n}\n\nvoid enqueue(Queue *q, State s) {\n    q->data[q->rear++] = s;\n}\n\nState dequeue(Queue *q) {\n    return q->data[q->front++];\n}\n\nint isEmpty(Queue *q) {\n    return q->front == q->rear;\n}\n\nint main() {\n    int n, m;\n    char grid[MAXN][MAXN];\n    int dist[MAXN][MAXN];\n    int dx[] = {0, 0, 1, -1};\n    int dy[] = {1, -1, 0, 0};\n    \n    while (scanf(\"%d %d\", &n, &m) == 2 && (n || m)) {\n        int startX = -1, startY = -1;\n        \n        for (int i = 0; i < m; i++) {\n            scanf(\"%s\", grid[i]);\n            for (int j = 0; j < n; j++) {\n                if (grid[i][j] == '&') {\n                    startX = i;\n                    startY = j;\n                }\n                dist[i][j] = INT_MAX;\n            }\n        }\n        \n        // Check if we can reach from boundary\n        Queue q;\n        initQueue(&q);\n        \n        // Start from all boundary cells\n        for (int i = 0; i < m; i++) {\n            for (int j = 0; j < n; j++) {\n                if (i == 0 || i == m-1 || j == 0 || j == n-1) {\n                    State s;\n                    s.x = i;\n                    s.y = j;\n                    if (grid[i][j] == '#') {\n                        s.cost = 1;\n                    } else {\n                        s.cost = 0;\n                    }\n                    dist[i][j] = s.cost;\n                    enqueue(&q, s);\n                }\n            }\n        }\n        \n        while (!isEmpty(&q)) {\n            State cur = dequeue(&q);\n            int x = cur.x;\n            int y = cur.y;\n            int cost = cur.cost;\n            \n            if (cost > dist[x][y]) continue;\n            \n            for (int d = 0; d < 4; d++) {\n                int nx = x + dx[d];\n                int ny = y + dy[d];\n                \n                if (nx >= 0 && nx < m && ny >= 0 && ny < n) {\n                    int newCost = cost;\n                    if (grid[x][y] == '#' && grid[nx][ny] != '#') {\n                        newCost = cost + 1;\n                    }\n                    \n                    if (newCost < dist[nx][ny]) {\n                        dist[nx][ny] = newCost;\n                        State ns;\n                        ns.x = nx;\n                        ns.y = ny;\n                        ns.cost = newCost;\n                        enqueue(&q, ns);\n                    }\n                }\n            }\n        }\n        \n        if (dist[startX][startY] == INT_MAX) {\n            printf(\"-1\\n\");\n        } else {\n            printf(\"%d\\n\", dist[startX][startY]);\n        }\n    }\n    \n    return 0;\n}\n", "perturbed_sampled": [" <limits.h> #define MAXN 105 typedef struct { int  data[MAXN * MAXN]; int front, rear; }  q->front  = s; }  q->data[q->front++];   n, m; char  -1};  2 &&  = -1;  i <  0; j < n; j++) { if (grid[i][j] == '&') { startX =  we  q;  boundary cells for (int i = 0; i  j < n;  0 || i == m-1 || j == 0 ||  s; s.x  { s.cost = 1; } else { s.cost = 0; } dist[i][j] = s.cost; enqueue(&q,  (!isEmpty(&q)) { State cur   int cost = cur.cost; if (cost >   d++)  + dx[d]; int   ny  n) { int newCost = cost;  grid[nx][ny] !=  (newCost < dist[nx][ny]) {  ns.x   } } } } if (dist[startX][startY] == INT_MAX) { printf(\"-1\\n\"); } else  return 0; }"], "perturbed_original": [" struct { int ty;  head, tail;  = t; if (tail ==  } void deq(POINT *t) { *t  10000000){  int main(void) { POINT temp, add; int     while (1){ scanf(\"%d%d\",  } getchar(); memset(map, '.', sizeof(map)); for (i    &map[i][j]); if (map[i][j]  } getchar(); } for (i  (j  cost[temp.ty][temp.tx] =  = tail = 0; enq(temp); ans = 100000; while (head != tail){ deq(&temp); if (0 == temp.tx || 0 == temp.ty  temp.tx || y  ?  mx  (cost[my][mx] > add.sharp){ if ((map[my][mx] == '.') && map[temp.ty][temp.tx] == '#'){ add.sharp++; } cost[my][mx] = add.sharp; add.tx = mx;  } }  }"], "original_ll": -0.750607967376709, "sampled_ll": -0.4473927617073059, "all_perturbed_sampled_ll": [-2.8621745109558105], "all_perturbed_original_ll": [-2.932476043701172], "perturbed_sampled_ll": -2.8621745109558105, "perturbed_original_ll": -2.932476043701172, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "\nimport java.util.ArrayDeque;\nimport java.util.Arrays;\nimport java.util.Deque;\nimport java.util.List;\nimport java.util.Scanner;\n\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tScanner scanner = new Scanner(System.in);\n\t\twhile (true) {\n\t\t\tint w = scanner.nextInt();\n\t\t\tint h = scanner.nextInt();\n\t\t\tif (w == 0 && h == 0)\n\t\t\t\tbreak;\n\t\t\tint gy = -1;\n\t\t\tint gx = -1;\n\t\t\tboolean[][] map = new boolean[h + 2][w + 2];\n\t\t\tfor (int i = 1; i <= h; i++) {\n\t\t\t\tchar[] c = scanner.next().toCharArray();\n\t\t\t\tfor (int j = 1; j <= w; j++) {\n\t\t\t\t\tif (c[j - 1] == '#') {\n\t\t\t\t\t\tmap[i][j] = true;\n\t\t\t\t\t} else if (c[j - 1] == '&') {\n\t\t\t\t\t\tgy = i;\n\t\t\t\t\t\tgx = j;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tint[][] dxy = { { -1, 0 }, { 0, -1 }, { 0, 1 }, { 1, 0 } };\n\t\t\tint[][] cnt = new int[h + 2][w + 2];\n\t\t\t\n\t\t\tfor (int[] c : cnt) {\n\t\t\t\tArrays.fill(c, 1 << 10);\n\t\t\t}\n\t\t\tcnt[0][0] = 0;\n\t\t\tDeque<List<Integer>> deque = new ArrayDeque<List<Integer>>();\n\t\t\tdeque.offer(Arrays.asList(0, 0));\n\t\t\twhile (!deque.isEmpty()) {\n\t\t\t\tList<Integer> list = deque.poll();\n\t\t\t\tint y = list.get(0);\n\t\t\t\tint x = list.get(1);\n\t\t\t\tfor (int[] d : dxy) {\n\t\t\t\t\tint dy = y + d[0];\n\t\t\t\t\tint dx = x + d[1];\n\t\t\t\t\tif (0 <= dy && dy < h + 2 && 0 <= dx & dx < w + 2) {\n\t\t\t\t\t\tint r;\n\t\t\t\t\t\tif (map[y][x] && !map[dy][dx]) {\n\t\t\t\t\t\t\tr = 1;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tr = 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (cnt[dy][dx] > cnt[y][x] + r) {\n\t\t\t\t\t\t\tcnt[dy][dx] = cnt[y][x] + r;\n\t\t\t\t\t\t\tdeque.offer(Arrays.asList(dy, dx));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(cnt[gy][gx]);\n\t\t}\n\t}\n}", "sampled": "import java.util.*;\nimport java.io.*;\n\npublic class Main {\n    static class State implements Comparable<State> {\n        int x, y, climbs;\n        \n        State(int x, int y, int climbs) {\n            this.x = x;\n            this.y = y;\n            this.climbs = climbs;\n        }\n        \n        @Override\n        public int compareTo(State other) {\n            return this.climbs - other.climbs;\n        }\n    }\n    \n    public static void main(String[] args) throws IOException {\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        String line;\n        \n        while ((line = br.readLine()) != null) {\n            String[] parts = line.trim().split(\"\\\\s+\");\n            int n = Integer.parseInt(parts[0]);\n            int m = Integer.parseInt(parts[1]);\n            \n            if (n == 0 && m == 0) break;\n            \n            char[][] grid = new char[m][n];\n            int targetX = -1, targetY = -1;\n            \n            for (int i = 0; i < m; i++) {\n                String row = br.readLine();\n                for (int j = 0; j < n; j++) {\n                    grid[i][j] = row.charAt(j);\n                    if (grid[i][j] == '&') {\n                        targetX = i;\n                        targetY = j;\n                    }\n                }\n            }\n            \n            int result = solve(grid, m, n, targetX, targetY);\n            System.out.println(result);\n        }\n    }\n    \n    static int solve(char[][] grid, int m, int n, int targetX, int targetY) {\n        int[][] minClimbs = new int[m][n];\n        for (int i = 0; i < m; i++) {\n            Arrays.fill(minClimbs[i], Integer.MAX_VALUE);\n        }\n        \n        PriorityQueue<State> pq = new PriorityQueue<>();\n        \n        // Start from all border cells\n        for (int i = 0; i < m; i++) {\n            for (int j = 0; j < n; j++) {\n                if (i == 0 || i == m - 1 || j == 0 || j == n - 1) {\n                    int initialClimbs = (grid[i][j] == '#') ? 1 : 0;\n                    pq.offer(new State(i, j, initialClimbs));\n                    minClimbs[i][j] = initialClimbs;\n                }\n            }\n        }\n        \n        int[] dx = {-1, 1, 0, 0};\n        int[] dy = {0, 0, -1, 1};\n        \n        while (!pq.isEmpty()) {\n            State current = pq.poll();\n            \n            if (current.x == targetX && current.y == targetY) {\n                return current.climbs;\n            }\n            \n            if (current.climbs > minClimbs[current.x][current.y]) {\n                continue;\n            }\n            \n            for (int i = 0; i < 4; i++) {\n                int nx = current.x + dx[i];\n                int ny = current.y + dy[i];\n                \n                if (nx >= 0 && nx < m && ny >= 0 && ny < n) {\n                    boolean currentInMoat = (grid[current.x][current.y] == '#');\n                    boolean nextInMoat = (grid[nx][ny] == '#');\n                    \n                    int newClimbs = current.climbs;\n                    if (currentInMoat && !nextInMoat) {\n                        newClimbs++;\n                    }\n                    \n                    if (newClimbs < minClimbs[nx][ny]) {\n                        minClimbs[nx][ny] = newClimbs;\n                        pq.offer(new State(nx, ny, newClimbs));\n                    }\n                }\n            }\n        }\n        \n        return minClimbs[targetX][targetY];\n    }\n}\n", "perturbed_sampled": ["import   x,  = y; this.climbs = climbs; }  throws IOException {  InputStreamReader(System.in)); String line; while ((line = br.readLine()) != null) { String[] parts = line.trim().split(\"\\\\s+\"); int n = Integer.parseInt(parts[0]); int m = Integer.parseInt(parts[1]); if (n == 0 && m == 0) break; char[][] grid = new char[m][n];  i  i++) { String row   '&')  =  result  static  minClimbs =   i++) {  = new PriorityQueue<>(); //  for  for (int j    { int initialClimbs = (grid[i][j] == '#') ?  j, initialClimbs)); minClimbs[i][j] = initialClimbs; }  0, -1, 1}; while (!pq.isEmpty()) {  (current.x == targetX && current.y  } if (current.climbs > minClimbs[current.x][current.y]) { continue; } for (int i = 0;  +  + dy[i]; if (nx  m && ny >= 0  boolean  boolean nextInMoat = (grid[nx][ny]  !nextInMoat) { newClimbs++; } if (newClimbs < minClimbs[nx][ny]) { minClimbs[nx][ny] = newClimbs; pq.offer(new  } }"], "perturbed_original": ["import java.util.ArrayDeque;    main(String[]  new Scanner(System.in); while (true) {  (w == 0 && h == 0)  boolean[h +  <= h; i++) { char[] c =    == '#')  else if (c[j - 1] == '&') { gy = i; gx = j; }  { { -1,  }, { 0,  { Arrays.fill(c, 1 << 10); } cnt[0][0] =  ArrayDeque<List<Integer>>(); deque.offer(Arrays.asList(0,  { int dy = y + d[0]; int dx = x  dy  dx &  {  !map[dy][dx]) { r  + r) { cnt[dy][dx] = cnt[y][x] + r; deque.offer(Arrays.asList(dy, dx)); } } } } System.out.println(cnt[gy][gx]); } } }"], "original_ll": -0.546765923500061, "sampled_ll": -0.35110238194465637, "all_perturbed_sampled_ll": [-2.317781925201416], "all_perturbed_original_ll": [-2.8713502883911133], "perturbed_sampled_ll": -2.317781925201416, "perturbed_original_ll": -2.8713502883911133, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "from heapq import heappush, heappop\n\nwhile True:\n  n, m = map(int, input().split())\n  if n == 0: break\n\n  mp = [\"X\" + input() + \"X\" for _ in range(m)]\n  mp.insert(0, \"X\" * (n + 2))\n  mp.append(\"X\" * (n + 2))\n  \n  que = []\n  visited = [[False] * (n + 2) for _ in range(m + 2)]\n  sur_flag = False\n  for i in range(1, n + 1):\n    if mp[1][i] ==\"&\" or mp[m][i] == \"&\":\n      sur_flag = True\n      break\n    c1, s1 = (1, 0) if mp[1][i] == \"#\" else (0, 1)\n    c2, s2 = (1, 0) if mp[m][i] == \"#\" else (0, 1)\n    heappush(que, (c1, s1, (i, 1)))\n    heappush(que, (c2, s2, (i, m)))\n    visited[1][i] = True\n    visited[m][i] = True\n  \n  for i in range(1, m + 1):\n    if mp[i][1] == \"&\" or mp[i][n] == \"&\":\n      sur_flag = True\n      break\n    c1, s1 = (1, 0) if mp[i][1] == \"#\" else (0, 1)\n    c2, s2 = (1, 0) if mp[i][n] == \"#\" else (0, 1)\n    heappush(que, (c1, s1, (1, i)))\n    heappush(que, (c2, s2, (n, i)))\n    visited[i][1] = True\n    visited[i][n] = True\n  \n  if sur_flag:\n    print(0)\n    continue\n  \n  direct = ((0, 1), (0, -1), (1, 0), (-1, 0))\n  reached = False\n  \n  while que and not reached:\n    cost, status, point = heappop(que)\n    x, y = point\n    for dx, dy in direct:\n      newx, newy = x + dx, y + dy\n      if not visited[newy][newx]:\n        visited[newy][newx] = True\n        if mp[newy][newx] == \"&\":\n          print(cost)\n          reached = True\n          break\n        elif mp[newy][newx] == \"#\":\n          if status == 1:\n            heappush(que, (cost + 1, 0, (newx, newy)))\n          else:\n            heappush(que, (cost, 0, (newx, newy)))\n        elif mp[newy][newx] == \".\":\n          heappush(que,(cost, 1, (newx, newy)))\n", "sampled": "from collections import deque\n\ndef solve(n, m, grid):\n    # Find the position of '&' (castle keep)\n    castle_pos = None\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == '&':\n                castle_pos = (i, j)\n                break\n        if castle_pos:\n            break\n    \n    # BFS with state (row, col, climbs)\n    # We want to find minimum climbs to reach castle from outside\n    # Outside means any position on the border or reachable from border\n    \n    # Use 0-1 BFS (or Dijkstra-like approach)\n    # State: (climbs, row, col, in_moat)\n    # in_moat: True if currently in a moat\n    \n    visited = {}  # (row, col, in_moat) -> min_climbs\n    pq = deque()\n    \n    # Start from all border positions\n    for i in range(m):\n        for j in range(n):\n            if i == 0 or i == m-1 or j == 0 or j == n-1:\n                in_moat = (grid[i][j] == '#')\n                pq.append((0, i, j, in_moat))\n                visited[(i, j, in_moat)] = 0\n    \n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    \n    while pq:\n        climbs, row, col, in_moat = pq.popleft()\n        \n        if row == castle_pos[0] and col == castle_pos[1]:\n            return climbs\n        \n        if visited.get((row, col, in_moat), float('inf')) < climbs:\n            continue\n        \n        for dr, dc in directions:\n            nr, nc = row + dr, col + dc\n            if 0 <= nr < m and 0 <= nc < n:\n                next_is_moat = (grid[nr][nc] == '#')\n                \n                # Calculate climbs needed\n                new_climbs = climbs\n                if in_moat and not next_is_moat:\n                    # Climbing out of moat\n                    new_climbs = climbs + 1\n                \n                if visited.get((nr, nc, next_is_moat), float('inf')) > new_climbs:\n                    visited[(nr, nc, next_is_moat)] = new_climbs\n                    if new_climbs == climbs:\n                        pq.appendleft((new_climbs, nr, nc, next_is_moat))\n                    else:\n                        pq.append((new_climbs, nr, nc, next_is_moat))\n    \n    return -1\n\nwhile True:\n    line = input().split()\n    n, m = int(line[0]), int(line[1])\n    if n == 0 and m == 0:\n        break\n    \n    grid = []\n    for _ in range(m):\n        grid.append(input().strip())\n    \n    result = solve(n, m, grid)\n    print(result)\n", "perturbed_sampled": [" solve(n, m, grid): # Find  for j in range(n): if  (i, j) break if castle_pos: break # BFS with state (row, col, climbs) # We want to find  from outside # Outside means any position on the border or reachable  True if currently in a   pq = deque() # Start   ==  in_moat = (grid[i][j]  in_moat)) visited[(i,  = [(0, 1),    in_moat), float('inf')) < climbs: continue for dr, dc in directions: nr, nc =  dc   Calculate climbs needed  and not next_is_moat: # Climbing out of moat new_climbs = climbs  visited[(nr, nc, next_is_moat)] =  pq.appendleft((new_climbs,  nr, nc, next_is_moat))  =  0: break grid = [] for _ in range(m): grid.append(input().strip())  print(result)"], "perturbed_original": ["from heapq import heappush, heappop while True:  mp.insert(0, \"X\" * (n + 2)) mp.append(\"X\" * (n + 2)) que =  n + 1):  = (1, 0)  (0, 1) c2, s2 = (1, 0) if  =  + 1): if mp[i][1] == \"&\" or mp[i][n] == \"&\": sur_flag = True break c1, s1 = (1, 0)  mp[i][n] ==  (c1, s1, (1, i))) heappush(que, (c2, s2, (n, i))) visited[i][1]  if sur_flag: print(0) continue direct = ((0, 1), (0, -1), (1, 0), (-1, 0)) reached =  if not visited[newy][newx]: visited[newy][newx] = True if mp[newy][newx] == \"&\": print(cost) reached = True break elif mp[newy][newx] == \"#\":   0, (newx,  heappush(que,(cost, 1, (newx, newy)))"], "original_ll": -0.570551872253418, "sampled_ll": -0.8655345439910889, "all_perturbed_sampled_ll": [-3.396620988845825], "all_perturbed_original_ll": [-2.025660753250122], "perturbed_sampled_ll": -3.396620988845825, "perturbed_original_ll": -2.025660753250122, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\ntypedef struct {\n\tint h;\n\tint r;\n} DOLL;\n\nint cmp(const void *a, const void *b)\n{\n\tDOLL x, y;\n\t\n\tx = *(DOLL *)a;\n\ty = *(DOLL *)b;\n\t\n\tif (x.r - y.r){\n\t\treturn (x.r - y.r);\n\t}\n\treturn (x.h - y.h);\n}\n\nint main(void)\n{\n\tDOLL rusd[256];\n\tint dp[256];\n\tint n, m;\n\tint i, j;\n\tint ans;\n\t\n\twhile (1){\n\t\tans = 0;\n\t\tmemset(dp, 0, sizeof(dp));\n\t\tscanf(\"%d\", &n);\n\t\tif (n == 0) break;\n\t\tfor (i = 0; i < n; i++){\n\t\t\tscanf(\"%d %d\", &rusd[i].h, &rusd[i].r);\n\t\t}\n\t\tscanf(\"%d\", &m);\n\t\tfor (j = 0; j < m; j++){\n\t\t\tscanf(\"%d %d\", &rusd[n + j].h, &rusd[n + j].r);\n\t\t}\n\t\tqsort(rusd, n + m, sizeof(DOLL), cmp);\n\t\t\n\t\tfor (i = 0; i < n + m; i++){\n\t\t\tdp[i] = 1;\n\t\t\tfor (j = 0; j < i; j++){\n\t\t\t\tif (rusd[i].h > rusd[j].h && rusd[i].r > rusd[j].r){\n\t\t\t\t\tif (dp[i] < dp[j] + 1){\n\t\t\t\t\t\tdp[i] = dp[j] + 1;\n\t\t\t\t\t\tif (ans < dp[i]){\n\t\t\t\t\t\t\tans = dp[i];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\", ans);\n\t}\n\t\n\treturn (0);\n}", "sampled": "#include <stdio.h>\n#include <string.h>\n\ntypedef struct {\n    int h, r;\n} Doll;\n\nint n, m;\nDoll dolls[205];\nint dp[205];\nint parent[205];\n\nint canContain(int i, int j) {\n    return dolls[i].h < dolls[j].h && dolls[i].r < dolls[j].r;\n}\n\nint compare(const void *a, const void *b) {\n    Doll *da = (Doll *)a;\n    Doll *db = (Doll *)b;\n    if (da->h != db->h) return da->h - db->h;\n    return da->r - db->r;\n}\n\nint main() {\n    while (1) {\n        scanf(\"%d\", &n);\n        if (n == 0) break;\n        \n        for (int i = 0; i < n; i++) {\n            scanf(\"%d %d\", &dolls[i].h, &dolls[i].r);\n        }\n        \n        scanf(\"%d\", &m);\n        for (int i = 0; i < m; i++) {\n            scanf(\"%d %d\", &dolls[n + i].h, &dolls[n + i].r);\n        }\n        \n        int total = n + m;\n        \n        qsort(dolls, total, sizeof(Doll), compare);\n        \n        for (int i = 0; i < total; i++) {\n            dp[i] = 1;\n            parent[i] = -1;\n        }\n        \n        int maxLen = 1;\n        for (int i = 1; i < total; i++) {\n            for (int j = 0; j < i; j++) {\n                if (canContain(j, i)) {\n                    if (dp[j] + 1 > dp[i]) {\n                        dp[i] = dp[j] + 1;\n                        parent[i] = j;\n                    }\n                }\n            }\n            if (dp[i] > maxLen) {\n                maxLen = dp[i];\n            }\n        }\n        \n        printf(\"%d\\n\", maxLen);\n    }\n    \n    return 0;\n}\n", "perturbed_sampled": ["#include <stdio.h> #include <string.h> typedef struct    j) { return dolls[i].h < dolls[j].h  int compare(const void  Doll *da =  !=  return da->r - db->r; } int main() { while (1) {  0) break; for (int i = 0; i < n; i++) { scanf(\"%d %d\",   i < m; i++) { scanf(\"%d %d\",  i].r); }  compare); for (int i = 0; i  i =  (dp[j] + 1 >   } } } if   maxLen); } return 0; }"], "perturbed_original": ["#include  typedef struct  } DOLL; int cmp(const void *a, const void *b)  = *(DOLL *)a; y = *(DOLL *)b; if (x.r - y.r){ return    for (i = 0; i < n; i++){  + j].r); } qsort(rusd, n + m, sizeof(DOLL),  m; i++){ dp[i] = 1; for (j =  if (dp[i] < dp[j] + 1){ dp[i] = dp[j] + 1; if  dp[i]; } } } } }  }"], "original_ll": -0.580566942691803, "sampled_ll": -0.45426276326179504, "all_perturbed_sampled_ll": [-2.8386471271514893], "all_perturbed_original_ll": [-2.679934024810791], "perturbed_sampled_ll": -2.8386471271514893, "perturbed_original_ll": -2.679934024810791, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import java.util.Arrays;\nimport java.util.Scanner;\n\npublic class Main {\n\tMyScanner sc = new MyScanner();\n\tScanner sc2 = new Scanner(System.in);\n\tint mod = 1000000007;\n\tint[][] data;\n\tint[] memo;\n\tboolean[] use;\n\tint n, m, N;\n\n\tvoid run() {\n\t\tfor (;;) {\n\t\t\tn = sc.nextInt();\n\t\t\tif (n == 0) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tdata = new int[201][2];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tdata[i][0] = sc.nextInt();\n\t\t\t\tdata[i][1] = sc.nextInt();\n\t\t\t}\n\t\t\tm = sc.nextInt();\n\t\t\tfor (int i = n; i < m + n; i++) {\n\t\t\t\tdata[i][0] = sc.nextInt();\n\t\t\t\tdata[i][1] = sc.nextInt();\n\t\t\t}\n\n\t\t\tN = n + m;\n\t\t\tmemo = new int[n + m];\n\t\t\tuse = new boolean[n + m];\n\t\t\tint ans = 0;\n\t\t\tfor (int i = 0; i < N; i++) {\n\t\t\t\tans = Math.max(ans, dfs(i));\n\t\t\t}\n\t\t\tSystem.out.println(ans);\n\t\t}\n\t}\n\n\tint dfs(int index) {\n\t\tif (memo[index] > 0) {\n\t\t\treturn memo[index];\n\t\t}\n\t\tint res = 1;\n\t\tuse[index] = true;\n\t\tfor (int i = 0; i < N; i++) {\n\t\t\tif (!use[i]) {\n\t\t\t\tif (data[i][0] < data[index][0] && data[i][1] < data[index][1]) {\n\t\t\t\t\tres = Math.max(res, dfs(i) + 1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tuse[index] = false;\n\t\treturn memo[index] = res;\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n\n\tvoid debug(Object... o) {\n\t\tSystem.out.println(Arrays.deepToString(o));\n\t}\n\n\tvoid debug2(int[][] array) {\n\t\tfor (int i = 0; i < array.length; i++) {\n\t\t\tfor (int j = 0; j < array[i].length; j++) {\n\t\t\t\tSystem.out.print(array[i][j]);\n\t\t\t}\n\t\t\tSystem.out.println();\n\t\t}\n\t}\n\n\tclass MyScanner {\n\t\tint nextInt() {\n\t\t\ttry {\n\t\t\t\tint c = System.in.read();\n\t\t\t\twhile (c != '-' && (c < '0' || '9' < c))\n\t\t\t\t\tc = System.in.read();\n\t\t\t\tif (c == '-')\n\t\t\t\t\treturn -nextInt();\n\t\t\t\tint res = 0;\n\t\t\t\tdo {\n\t\t\t\t\tres *= 10;\n\t\t\t\t\tres += c - '0';\n\t\t\t\t\tc = System.in.read();\n\t\t\t\t} while ('0' <= c && c <= '9');\n\t\t\t\treturn res;\n\t\t\t} catch (Exception e) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\n\t\tdouble nextDouble() {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\n\t\tString next() {\n\t\t\ttry {\n\t\t\t\tStringBuilder res = new StringBuilder(\"\");\n\t\t\t\tint c = System.in.read();\n\t\t\t\twhile (Character.isWhitespace(c))\n\t\t\t\t\tc = System.in.read();\n\t\t\t\tdo {\n\t\t\t\t\tres.append((char) c);\n\t\t\t\t} while (!Character.isWhitespace(c = System.in.read()));\n\t\t\t\treturn res.toString();\n\t\t\t} catch (Exception e) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t}\n\t}\n}", "sampled": "import java.util.*;\n\npublic class Main {\n    static class Doll implements Comparable<Doll> {\n        int h, r;\n        \n        Doll(int h, int r) {\n            this.h = h;\n            this.r = r;\n        }\n        \n        @Override\n        public int compareTo(Doll other) {\n            if (this.h != other.h) {\n                return this.h - other.h;\n            }\n            return this.r - other.r;\n        }\n    }\n    \n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        \n        while (true) {\n            int n = sc.nextInt();\n            if (n == 0) break;\n            \n            List<Doll> dolls = new ArrayList<>();\n            \n            for (int i = 0; i < n; i++) {\n                int h = sc.nextInt();\n                int r = sc.nextInt();\n                dolls.add(new Doll(h, r));\n            }\n            \n            int m = sc.nextInt();\n            for (int i = 0; i < m; i++) {\n                int h = sc.nextInt();\n                int r = sc.nextInt();\n                dolls.add(new Doll(h, r));\n            }\n            \n            Collections.sort(dolls);\n            \n            int[] dp = new int[dolls.size()];\n            Arrays.fill(dp, 1);\n            \n            for (int i = 1; i < dolls.size(); i++) {\n                for (int j = 0; j < i; j++) {\n                    if (dolls.get(j).h < dolls.get(i).h && dolls.get(j).r < dolls.get(i).r) {\n                        dp[i] = Math.max(dp[i], dp[j] + 1);\n                    }\n                }\n            }\n            \n            int max = 0;\n            for (int i = 0; i < dolls.size(); i++) {\n                max = Math.max(max, dp[i]);\n            }\n            \n            System.out.println(max);\n        }\n        \n        sc.close();\n    }\n}\n", "perturbed_sampled": ["import java.util.*; public  Doll implements  Doll(int  = h; this.r =  compareTo(Doll other) { if (this.h != other.h) { return  this.r - other.r; } } public static  h = sc.nextInt(); int r  }  (int i = 0; i < m; i++) { int h = sc.nextInt();  Doll(h, r));  for  for (int j = 0; j  dp[i] =  } } int max = 0; for (int i   dp[i]); } System.out.println(max); } sc.close(); } }"], "perturbed_original": ["import java.util.Arrays; import java.util.Scanner; public  = new MyScanner();  int[][] data; int[]  n = sc.nextInt(); if (n == 0) { return; } data = new  i++) {  sc.nextInt();  (int i = n; i < m  = sc.nextInt(); data[i][1] = sc.nextInt(); } N  m]; use =  ans = 0;  0) { return memo[index];  use[index]  = 0; i  (!use[i]) { if (data[i][0] < data[index][0] && data[i][1] < data[index][1])   use[index] = false; return memo[index]    debug2(int[][] array) {  i <  < array[i].length; j++)  } class MyScanner { int nextInt() {  System.in.read(); while (c != '-' && (c < '0' ||   += c -  while ('0'  catch  } } double nextDouble() { return Double.parseDouble(next()); } String next()  c = System.in.read(); while (Character.isWhitespace(c)) c = System.in.read(); do {  { return null; } } } }"], "original_ll": -0.5554324388504028, "sampled_ll": -0.2872489094734192, "all_perturbed_sampled_ll": [-2.7862138748168945], "all_perturbed_original_ll": [-2.52193284034729], "perturbed_sampled_ll": -2.7862138748168945, "perturbed_original_ll": -2.52193284034729, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "from operator import itemgetter\n\ndef f(f1, f2):\n    res = 1\n    c = 0\n    i = 0\n    while c < len(L)-1:\n        if L[i][f1] > L[i+1][f1] and L[i][f2] > L[i+1][f2]:\n            res += 1\n            i += 1\n        else:\n            del L[i+1]\n        c += 1\n    return res\n\nwhile True:\n    n = input()\n    if n == 0: break\n    L = [map(int, raw_input().split()) for i in range(n)]\n    for i in range(input()):\n        L.append(map(int, raw_input().split()))\n    else:\n        h = 0\n        r = 1\n        L.sort(key=itemgetter(0,1), reverse=True)\n        res1 = f(h, r)\n        L.sort(key=itemgetter(1,0), reverse=True)\n        res2 = f(r, h)\n        if res2 < res1:\n            print res1\n        else:\n            print res2", "sampled": "import sys\nfrom bisect import bisect_left\n\ndef longest_chain(dolls):\n    if not dolls:\n        return 0\n    \n    # Sort by height, then by radius\n    dolls.sort()\n    \n    # dp[i] = minimum radius for a chain of length i+1\n    dp = []\n    \n    for h, r in dolls:\n        # Find the longest chain where we can add this doll\n        # We need to find largest index where dp[index] < r\n        pos = bisect_left(dp, r)\n        \n        if pos < len(dp):\n            dp[pos] = r\n        else:\n            dp.append(r)\n    \n    return len(dp)\n\nwhile True:\n    n = int(input())\n    if n == 0:\n        break\n    \n    dolls1 = []\n    for _ in range(n):\n        h, r = map(int, input().split())\n        dolls1.append((h, r))\n    \n    m = int(input())\n    dolls2 = []\n    for _ in range(m):\n        h, r = map(int, input().split())\n        dolls2.append((h, r))\n    \n    # Combine all dolls\n    all_dolls = dolls1 + dolls2\n    \n    # Find longest chain\n    result = longest_chain(all_dolls)\n    print(result)\n", "perturbed_sampled": ["import sys from bisect import  Sort  h, r   We need to find  r pos = bisect_left(dp, r) if pos < len(dp): dp[pos] = r else: dp.append(r) return len(dp) while True: n = int(input()) if n == 0:  _ in range(n): h, r  = []  r =   Find longest chain result = longest_chain(all_dolls) print(result)"], "perturbed_original": ["from operator import itemgetter def f(f1, f2): res  += 1 i +=  while True: n = input() if n  in  = 0 r = 1 L.sort(key=itemgetter(0,1),  L.sort(key=itemgetter(1,0), reverse=True) res2 = f(r, h)  res1 else: print res2"], "original_ll": -1.029225468635559, "sampled_ll": -0.9653249382972717, "all_perturbed_sampled_ll": [-3.5029568672180176], "all_perturbed_original_ll": [-2.866825819015503], "perturbed_sampled_ll": -3.5029568672180176, "perturbed_original_ll": -2.866825819015503, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "#include<stdio.h>\nint main(){\n  int n,c;\n  while(1){\n    scanf(\"%d\",&n);\n    if(n==0)break;\n    for(c=0;n!=1;c++){\n      if(n%2==0){\n\tn/=2;\n      }\n      else{\n\tn=n*3+1;\n      }\n    }\n    printf(\"%d\\n\",c);\n  }\n  return 0;\n}", "sampled": "#include <stdio.h>\n\nint main() {\n    int n;\n    \n    while(1) {\n        scanf(\"%d\", &n);\n        if(n == 0) break;\n        \n        int count = 0;\n        while(n != 1) {\n            if(n % 2 == 0) {\n                n = n / 2;\n            } else {\n                n = 3 * n + 1;\n            }\n            count++;\n        }\n        \n        printf(\"%d\\n\", count);\n    }\n    \n    return 0;\n}\n", "perturbed_sampled": ["#include <stdio.h>   == 0) break; int count =   { n = 3 * n + 1; }  return 0; }"], "perturbed_original": ["#include<stdio.h> int main(){ int n,c;  n/=2;  printf(\"%d\\n\",c); } return 0; }"], "original_ll": -0.8196861743927002, "sampled_ll": -0.4779272675514221, "all_perturbed_sampled_ll": [-3.506821632385254], "all_perturbed_original_ll": [-2.0780463218688965], "perturbed_sampled_ll": -3.506821632385254, "perturbed_original_ll": -2.0780463218688965, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import java.util.*;\nimport java.io.*;\n\nclass Main {\n\n    public static void main(String[] args) {\n\n\tfinal Scanner stdin = new Scanner(System.in);\n\n\twhile ( true ) {\n\t    int n = stdin.nextInt();\n\t    if ( n == 0 ) {\n\t\tbreak;\n\t    }\n\n\t    int count = 0;\n\t    while ( n != 1 ) {\n\t\tif ( n % 2 == 0 ) {\n\t\t    n /= 2;\n\t\t} else {\n\t\t    n = n * 3 + 1;\n\t\t}\n\t\tcount++;\n\t    }\n\t    System.out.println( count );\n\t}\t\n    }    \n}", "sampled": "import java.util.Scanner;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        \n        while (true) {\n            int n = sc.nextInt();\n            if (n == 0) break;\n            \n            int count = 0;\n            while (n != 1) {\n                if (n % 2 == 0) {\n                    n = n / 2;\n                } else {\n                    n = n * 3 + 1;\n                }\n                count++;\n            }\n            \n            System.out.println(count);\n        }\n        \n        sc.close();\n    }\n}\n", "perturbed_sampled": ["import java.util.Scanner; public class  n = sc.nextInt();  int count = 0;  if (n % 2 == 0) {  } else { n = n *  } }"], "perturbed_original": [" Main { public  final Scanner stdin = new Scanner(System.in); while (  = stdin.nextInt(); if ( n == 0 ) {   else {  + 1; } count++; }  }"], "original_ll": -0.7804263234138489, "sampled_ll": -0.3872094452381134, "all_perturbed_sampled_ll": [-2.391380786895752], "all_perturbed_original_ll": [-3.183326244354248], "perturbed_sampled_ll": -2.391380786895752, "perturbed_original_ll": -3.183326244354248, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "while True:\n\tn = int(input())\n\tif n == 0: break\n\tk = 0\n\twhile n > 1:\n\t\tif n & 1:\n\t\t\tn = n + ((n+1)>>1)\n\t\t\tk += 2\n\t\telse:\n\t\t\tn >>= 1\n\t\t\tk += 1\n\tprint(k)\n", "sampled": "while True:\n    n = int(input())\n    if n == 0:\n        break\n    \n    count = 0\n    while n != 1:\n        if n % 2 == 0:\n            n = n // 2\n        else:\n            n = 3 * n + 1\n        count += 1\n    \n    print(count)\n", "perturbed_sampled": [" if n  1: if n %  n  3 * n + 1 count += 1 print(count)"], "perturbed_original": ["while True: n =  n = n + ((n+1)>>1) k += 2 else:  1 print(k)"], "original_ll": -1.0571006536483765, "sampled_ll": -0.5038818717002869, "all_perturbed_sampled_ll": [-3.649674654006958], "all_perturbed_original_ll": [-3.682910203933716], "perturbed_sampled_ll": -3.649674654006958, "perturbed_original_ll": -3.682910203933716, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "#include<stdio.h>\nint main(){\nint n,a[1001],b[1001],c[1001],i,k=1001;\ndouble x,y,z,d[1001],w=10000;\nwhile(1){\nscanf(\"%d\\n\",&n);\nif(n==0){\nbreak;\n}\nfor(i=0;i<n;i++){\nscanf(\"%d %d %d\\n\",&a[i],&b[i],&c[i]);\nx=b[i],y=c[i];\nx=x/100;\nz=y/(x*x);\nif(z>22){\nz=z-22;\n}\nelse{\nz=22-z;\n}\nd[i]=z;\nif((z<w) || (z==w && k>a[i])){\nw=z;\nk=a[i];\n}\n}\nfor(i=0;i<n;i++){\nif(w==d[i]){\nprintf(\"%d\\n\",a[i]);\nbreak;\n}\n}\nw=10000,k=1001;\n}\nreturn 0;\n}\n", "sampled": "#include <stdio.h>\n#include <math.h>\n\nint main() {\n    int n;\n    \n    while(scanf(\"%d\", &n) == 1 && n != 0) {\n        int best_p = -1;\n        double min_diff = -1;\n        \n        for(int i = 0; i < n; i++) {\n            int p, h, w;\n            scanf(\"%d %d %d\", &p, &h, &w);\n            \n            double height_m = h / 100.0;\n            double bmi = w / (height_m * height_m);\n            double diff = fabs(bmi - 22.0);\n            \n            if(min_diff < 0 || diff < min_diff || (diff == min_diff && p < best_p)) {\n                min_diff = diff;\n                best_p = p;\n            }\n        }\n        \n        printf(\"%d\\n\", best_p);\n    }\n    \n    return 0;\n}\n", "perturbed_sampled": ["#include <stdio.h> #include <math.h>  while(scanf(\"%d\", &n) ==  { int best_p = -1; double min_diff = -1; for(int i  i++)  &h, &w);  w / (height_m *    (diff == min_diff && p  } return 0; }"], "perturbed_original": ["#include<stdio.h>  x,y,z,d[1001],w=10000; while(1){ scanf(\"%d\\n\",&n); if(n==0){ break;   && k>a[i])){ w=z; k=a[i]; } } for(i=0;i<n;i++){ if(w==d[i]){ printf(\"%d\\n\",a[i]);  return 0; }"], "original_ll": -1.132500171661377, "sampled_ll": -0.802773654460907, "all_perturbed_sampled_ll": [-3.4407005310058594], "all_perturbed_original_ll": [-2.2460010051727295], "perturbed_sampled_ll": -3.4407005310058594, "perturbed_original_ll": -2.2460010051727295, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import java.util.*;\nimport java.lang.*;\nimport java.math.*;\nimport java.io.*;\n\nimport static java.lang.Math.*;\nimport static java.util.Arrays.*;\n\npublic class Main{\n\n\tScanner sc=new Scanner(System.in);\n\n\tint INF=1<<28;\n\tdouble EPS=1e-9;\n\n\tint n;\n\tR[] rs;\n\n\tvoid run(){\n\t\tfor(;;){\n\t\t\tn=sc.nextInt();\n\t\t\tif(n==0){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\trs=new R[n];\n\t\t\tfor(int i=0; i<n; i++){\n\t\t\t\tint id=sc.nextInt();\n\t\t\t\tint h=sc.nextInt();\n\t\t\t\tint w=sc.nextInt();\n\t\t\t\trs[i]=new R(id, h, w);\n\t\t\t}\n\t\t\tsolve();\n\t\t}\n\t}\n\n\tvoid solve(){\n\t\tArrays.sort(rs);\n\t\tprintln(\"\"+rs[0].id);\n\t}\n\n\tclass R implements Comparable<R>{\n\t\tint id;\n\t\tdouble error;\n\n\t\tR(int id, int h, int w){\n\t\t\tthis.id=id;\n\t\t\terror=Math.abs(22-10000.*w/h/h);\n\t\t}\n\n\t\t@Override\n\t\tpublic int compareTo(R r){\n\t\t\tif(error+EPS<r.error){\n\t\t\t\treturn -1;\n\t\t\t}else if(error>r.error+EPS){\n\t\t\t\treturn 1;\n\t\t\t}else{\n\t\t\t\treturn id-r.id;\n\t\t\t}\n\t\t}\n\t}\n\n\tvoid debug(Object... os){\n\t\tSystem.err.println(Arrays.deepToString(os));\n\t}\n\n\tvoid print(String s){\n\t\tSystem.out.print(s);\n\t}\n\n\tvoid println(String s){\n\t\tSystem.out.println(s);\n\t}\n\n\tpublic static void main(String[] args){\n\t\t// System.setOut(new PrintStream(new BufferedOutputStream(System.out)));\n\t\tnew Main().run();\n\t}\n}", "sampled": "import java.util.Scanner;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        \n        while (true) {\n            int n = sc.nextInt();\n            if (n == 0) break;\n            \n            int bestP = Integer.MAX_VALUE;\n            double minDiff = Double.MAX_VALUE;\n            \n            for (int i = 0; i < n; i++) {\n                int p = sc.nextInt();\n                int h = sc.nextInt();\n                int w = sc.nextInt();\n                \n                double heightInMeters = h / 100.0;\n                double bmi = w / (heightInMeters * heightInMeters);\n                double diff = Math.abs(bmi - 22.0);\n                \n                if (diff < minDiff || (diff == minDiff && p < bestP)) {\n                    minDiff = diff;\n                    bestP = p;\n                }\n            }\n            \n            System.out.println(bestP);\n        }\n        \n        sc.close();\n    }\n}\n", "perturbed_sampled": ["import java.util.Scanner; public class  while (true) { int n = sc.nextInt();  double minDiff = Double.MAX_VALUE; for (int i   sc.nextInt(); int h =  double heightInMeters = h / 100.0; double  * heightInMeters); double diff = Math.abs(bmi   } System.out.println(bestP); } sc.close(); } }"], "perturbed_original": ["import java.util.*; import  import static java.lang.Math.*; import static java.util.Arrays.*; public class  INF=1<<28;   R[n]; for(int i=0; i<n;  int w=sc.nextInt(); rs[i]=new R(id, h, w); } solve(); } } void solve(){ Arrays.sort(rs); println(\"\"+rs[0].id); } class R  void debug(Object... os){ System.err.println(Arrays.deepToString(os)); } void print(String   System.setOut(new PrintStream(new BufferedOutputStream(System.out))); new Main().run(); } }"], "original_ll": -1.0101274251937866, "sampled_ll": -0.6852039694786072, "all_perturbed_sampled_ll": [-3.012784481048584], "all_perturbed_original_ll": [-2.923219680786133], "perturbed_sampled_ll": -3.012784481048584, "perturbed_original_ll": -2.923219680786133, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "while True:\n    n = input()\n    if n == 0: break\n    pb = None\n    ans = 0\n    for i in range(n):\n        i, h, w = map(int, raw_input().split())\n        bmi = w/((float(h)/100)**2)\n        a = abs(22-bmi)\n        if pb is None:\n            pb = a\n            ans = i\n        elif pb is not None and a < pb:\n            pb = a\n            ans = i\n    else:\n        print ans", "sampled": "while True:\n    n = int(input())\n    if n == 0:\n        break\n    \n    best_person = None\n    best_diff = float('inf')\n    \n    for _ in range(n):\n        data = list(map(int, input().split()))\n        p, h, w = data[0], data[1], data[2]\n        \n        # Convert height from cm to m\n        h_m = h / 100.0\n        \n        # Calculate BMI\n        bmi = w / (h_m * h_m)\n        \n        # Calculate difference from ideal BMI (22)\n        diff = abs(bmi - 22)\n        \n        # Update best if this is closer, or same distance but smaller reception number\n        if diff < best_diff or (diff == best_diff and p < best_person):\n            best_diff = diff\n            best_person = p\n    \n    print(best_person)\n", "perturbed_sampled": ["while True:   for  list(map(int, input().split())) p, h,  cm to m h_m = h / 100.0 # Calculate BMI bmi = w /  best if this is closer,   best_diff or (diff == best_diff  = diff best_person = p print(best_person)"], "perturbed_original": ["while True:  = None ans = 0 for i in range(n): i, h, w  w/((float(h)/100)**2) a =  pb  elif  =  print ans"], "original_ll": -1.4683277606964111, "sampled_ll": -1.0928175449371338, "all_perturbed_sampled_ll": [-4.671989917755127], "all_perturbed_original_ll": [-4.1978840827941895], "perturbed_sampled_ll": -4.671989917755127, "perturbed_original_ll": -4.1978840827941895, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "#include<stdio.h>\nint main(){\n  int n,x,y,h,w,s,s1,s2,a,i;\n  int m[]={600,800,1000,1200,1400,1600,0};\n  while(1){\n    scanf(\"%d\",&n);\n    if(n==0)break;\n    a=0;\n    for(i=0;i<n;i++){\n      scanf(\"%d %d %d %d\",&x,&y,&h,&w);\n      if     (x+y+h>160)s1=6;\n      else if(x+y+h>140)s1=5;\n      else if(x+y+h>120)s1=4;\n      else if(x+y+h>100)s1=3;\n      else if(x+y+h> 80)s1=2;\n      else if(x+y+h> 60)s1=1;\n      else              s1=0;\n      if     (w>25)s2=6;\n      else if(w>20)s2=5;\n      else if(w>15)s2=4;\n      else if(w>10)s2=3;\n      else if(w>5 )s2=2;\n      else if(w>2 )s2=1;\n      else         s2=0;\n      if(s1>s2)s=s1;\n      else     s=s2;\n      a+=m[s];\n    }\n    printf(\"%d\\n\",a);\n  }\n  return 0;\n}", "sampled": "#include <stdio.h>\n\nint main() {\n    int n;\n    \n    while (1) {\n        scanf(\"%d\", &n);\n        if (n == 0) break;\n        \n        int total = 0;\n        \n        for (int i = 0; i < n; i++) {\n            int x, y, h, w;\n            scanf(\"%d %d %d %d\", &x, &y, &h, &w);\n            \n            int size = x + y + h;\n            int price = 0;\n            \n            // Determine the category based on size and weight\n            if (size <= 60 && w <= 2) {\n                price = 600;\n            } else if (size <= 80 && w <= 5) {\n                price = 800;\n            } else if (size <= 100 && w <= 10) {\n                price = 1000;\n            } else if (size <= 120 && w <= 15) {\n                price = 1200;\n            } else if (size <= 140 && w <= 20) {\n                price = 1400;\n            } else if (size <= 160 && w <= 25) {\n                price = 1600;\n            }\n            // If it exceeds F size, price remains 0 and won't be added\n            \n            total += price;\n        }\n        \n        printf(\"%d\\n\", total);\n    }\n    \n    return 0;\n}\n", "perturbed_sampled": ["#include <stdio.h> int  (1) { scanf(\"%d\", &n); if (n == 0) break;   w; scanf(\"%d %d   // Determine  <= 2) { price = 600; } else if (size <= 80 && w <= 5) { price =  <= 100 && w <= 10) {  if (size <= 120  price = 1200; }  && w <= 20) { price = 1400;   exceeds F size, price   0; }"], "perturbed_original": ["#include<stdio.h> int  if(x+y+h>140)s1=5; else  80)s1=2; else if(x+y+h> 60)s1=1; else s1=0; if (w>25)s2=6;  else if(w>2 )s2=1; else s2=0; if(s1>s2)s=s1; else  return 0; }"], "original_ll": -0.7838627099990845, "sampled_ll": -0.6224116086959839, "all_perturbed_sampled_ll": [-2.60624623298645], "all_perturbed_original_ll": [-2.354647397994995], "perturbed_sampled_ll": -2.60624623298645, "perturbed_original_ll": -2.354647397994995, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.Map.Entry;\nimport java.util.StringTokenizer;\nimport java.util.TreeMap;\n\n/**\n * Delivery Fee\n */\npublic class Main {\n\n\tstatic P0160 main = new P0160();\n\tstatic TreeMap<Parcel, Integer> fee = new TreeMap<Parcel, Integer>() {\n\t\t{\n\t\t\tput(main.new Parcel(60, 2), 600);\n\t\t\tput(main.new Parcel(80, 5), 800);\n\t\t\tput(main.new Parcel(100, 10), 1000);\n\t\t\tput(main.new Parcel(120, 15), 1200);\n\t\t\tput(main.new Parcel(140, 20), 1400);\n\t\t\tput(main.new Parcel(160, 25), 1600);\n\t\t}\n\t};\n\n\tpublic static void main(String[] args) throws IOException {\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\tString line = \"\";\n\n\t\twhile (!(line = br.readLine()).equals(\"0\")) {\n\t\t\tint n, sum = 0;\n\t\t\tn = Integer.parseInt(line);\n\t\t\tfor (int i = 0; i < n; ++i) {\n\t\t\t\tParcel p = main.new Parcel(br.readLine());\n\t\t\t\tEntry<Parcel, Integer> e;\n\t\t\t\tif ((e = fee.ceilingEntry(p)) != null) {\n\t\t\t\t\tsum += e.getValue();\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(sum);\n\t\t}\n\t}\n\n\tclass Parcel implements Comparable<Parcel> {\n\t\tint size, weight;\n\n\t\tParcel(int size, int weight) {\n\t\t\tthis.size = size;\n\t\t\tthis.weight = weight;\n\t\t}\n\n\t\tParcel(int x, int y, int h, int w) {\n\t\t\tthis(x + y + h, w);\n\t\t}\n\n\t\tParcel(String info) {\n\t\t\tStringTokenizer st = new StringTokenizer(info);\n\t\t\tint x, y, h, w;\n\t\t\tx = Integer.parseInt(st.nextToken());\n\t\t\ty = Integer.parseInt(st.nextToken());\n\t\t\th = Integer.parseInt(st.nextToken());\n\t\t\tw = Integer.parseInt(st.nextToken());\n\t\t\tsize = x + y + h;\n\t\t\tweight = w;\n\t\t}\n\n\t\t@Override\n\t\tpublic int compareTo(Parcel o) {\n\t\t\tint r1 = this.weight - o.weight;\n\t\t\tint r2 = this.size - o.size;\n\t\t\tif (r1 > 0 || r2 > 0) {\n\t\t\t\treturn 1;\n\t\t\t} else if (r1 == 0 && r2 == 0) {\n\t\t\t\treturn 0;\n\t\t\t} else {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\t}\n}", "sampled": "import java.util.Scanner;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        \n        while (true) {\n            int n = sc.nextInt();\n            if (n == 0) break;\n            \n            int totalCost = 0;\n            \n            for (int i = 0; i < n; i++) {\n                int x = sc.nextInt();\n                int y = sc.nextInt();\n                int h = sc.nextInt();\n                int w = sc.nextInt();\n                \n                int size = x + y + h;\n                int cost = getPrice(size, w);\n                totalCost += cost;\n            }\n            \n            System.out.println(totalCost);\n        }\n        \n        sc.close();\n    }\n    \n    static int getPrice(int size, int weight) {\n        int[] sizeLimits = {60, 80, 100, 120, 140, 160};\n        int[] weightLimits = {2, 5, 10, 15, 20, 25};\n        int[] prices = {600, 800, 1000, 1200, 1400, 1600};\n        \n        for (int i = 0; i < 6; i++) {\n            if (size <= sizeLimits[i] && weight <= weightLimits[i]) {\n                return prices[i];\n            }\n        }\n        \n        return 0;\n    }\n}\n", "perturbed_sampled": ["import java.util.Scanner; public class Main { public static void  = sc.nextInt(); if (n == 0) break;  sc.nextInt(); int h = sc.nextInt(); int w = sc.nextInt(); int size = x + y + h; int cost = getPrice(size, w); totalCost +=  }  10, 15, 20,  800, 1000, 1200, 1400, 1600}; for (int i = 0;  } return 0; } }"], "perturbed_original": ["import java.io.BufferedReader;  java.util.Map.Entry;  static P0160 main = new P0160(); static TreeMap<Parcel, Integer> fee = new TreeMap<Parcel, Integer>() { { put(main.new Parcel(60, 2),   Parcel(140, 20), 1400); put(main.new Parcel(160, 25), 1600); } }; public static void main(String[] args)   (!(line = br.readLine()).equals(\"0\")) { int  = Integer.parseInt(line); for (int  n;  e;  e.getValue(); } } System.out.println(sum); } } class Parcel  weight; Parcel(int size, int weight)    Integer.parseInt(st.nextToken()); y = Integer.parseInt(st.nextToken()); h = Integer.parseInt(st.nextToken()); w = Integer.parseInt(st.nextToken());  + h;  public int  int r2 = this.size - o.size; if  >    { return -1; } } } }"], "original_ll": -0.6943483352661133, "sampled_ll": -0.49310070276260376, "all_perturbed_sampled_ll": [-1.9412341117858887], "all_perturbed_original_ll": [-2.7343616485595703], "perturbed_sampled_ll": -1.9412341117858887, "perturbed_original_ll": -2.7343616485595703, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "size = [60,80,100,120,140,160]        \nweight = [2,5,10,16,20,25]\nfee= [600,800,1000,1200,1400,1600]\nwhile True:\n    n = int(input())\n    if n==0:\n        break\n    total = 0\n    for _ in range(n):\n        [x,y,h,wt] = list(map(int, input().split()))\n        sz = x+y+h\n        if sz > size[-1] or wt > weight[-1]:\n            #print(\"NotAccept\")\n            continue\n        isz = len(list(filter(lambda x: x<sz,   size)))\n        iwt = len(list(filter(lambda x: x<wt, weight)))\n        f   = fee[max(isz,iwt)]\n        #print(\"%d %d %d %d %d\" % (x,y,h,wt,f))\n        total += f\n\n    print(total)", "sampled": "while True:\n    n = int(input())\n    if n == 0:\n        break\n    \n    total = 0\n    for _ in range(n):\n        x, y, h, w = map(int, input().split())\n        size = x + y + h\n        \n        # Determine the category based on size and weight\n        if size <= 60 and w <= 2:\n            total += 600\n        elif size <= 80 and w <= 5:\n            total += 800\n        elif size <= 100 and w <= 10:\n            total += 1000\n        elif size <= 120 and w <= 15:\n            total += 1200\n        elif size <= 140 and w <= 20:\n            total += 1400\n        elif size <= 160 and w <= 25:\n            total += 1600\n        # If exceeds F size, don't add to total\n    \n    print(total)\n", "perturbed_sampled": ["while True: n =  break total =   map(int, input().split()) size = x + y + h # Determine the category based on size and  total += 600 elif  <= 5: total  and w <=  <= 160  +=  size, don't add to total print(total)"], "perturbed_original": ["size   = int(input())    > size[-1] or wt  =  = len(list(filter(lambda x: x<wt, weight))) f  %d %d\" % (x,y,h,wt,f)) total += f print(total)"], "original_ll": -1.3326005935668945, "sampled_ll": -0.7946252226829529, "all_perturbed_sampled_ll": [-4.355535984039307], "all_perturbed_original_ll": [-3.9300568103790283], "perturbed_sampled_ll": -4.355535984039307, "perturbed_original_ll": -3.9300568103790283, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "#include <stdio.h>\n#include <stdlib.h>\n\ntypedef struct\n{\n\tint c;\n\tint m[4];\n\tint s[4];\n} TEAM;\n\nint comparison(const void* a, const void* b);\n\nint main(void)\n{\n\tint n;\n\tTEAM* team;\n\t\n\twhile (scanf(\"%d\", &n) * n != 0){\n\t\tint i;\n\t\t\n\t\tteam = (TEAM*)calloc(n, sizeof(TEAM));\n\t\tfor (i = 0; i < n; i++){\n\t\t\tint j;\n\t\t\t\n\t\t\tscanf(\"%d\", &team[i].c);\n\t\t\tfor (j = 0; j < 4; j++){\n\t\t\t\tscanf(\"%d %d\", &team[i].m[j], &team[i].s[j]);\n\t\t\t}\n\t\t}\n\t\tqsort(team, n, sizeof(TEAM), comparison);\n\t\tprintf(\"%d\\n\", team[0].c);\n\t\tprintf(\"%d\\n\", team[1].c);\n\t\tprintf(\"%d\\n\", team[n - 2].c);\n\t\t\n\t\tfree(team);\n\t}\n\t\n\treturn 0;\n}\n\nint comparison(const void* a, const void* b)\n{\n\tint sum_a, sum_b;\n\tint i;\n\t\n\tsum_a = sum_b = 0;\n\tfor (i = 0; i < 4; i++){\n\t\tsum_a += ((TEAM*)a)->m[i] * 60 + ((TEAM*)a)->s[i];\n\t\tsum_b += ((TEAM*)b)->m[i] * 60 + ((TEAM*)b)->s[i];\n\t}\n\tif (sum_a > sum_b){\n\t\treturn 1;\n\t}\n\telse if (sum_a < sum_b){\n\t\treturn -1;\n\t}\n\telse {\n\t\treturn 0;\n\t}\n}", "sampled": "#include <stdio.h>\n#include <stdlib.h>\n\ntypedef struct {\n    int id;\n    int total_time;\n} Team;\n\nint compare(const void *a, const void *b) {\n    Team *ta = (Team *)a;\n    Team *tb = (Team *)b;\n    return ta->total_time - tb->total_time;\n}\n\nint main() {\n    int n;\n    \n    while (scanf(\"%d\", &n) == 1 && n != 0) {\n        Team *teams = (Team *)malloc(n * sizeof(Team));\n        \n        for (int i = 0; i < n; i++) {\n            int id, m1, s1, m2, s2, m3, s3, m4, s4;\n            scanf(\"%d %d %d %d %d %d %d %d %d\", &id, &m1, &s1, &m2, &s2, &m3, &s3, &m4, &s4);\n            \n            teams[i].id = id;\n            teams[i].total_time = (m1 * 60 + s1) + (m2 * 60 + s2) + (m3 * 60 + s3) + (m4 * 60 + s4);\n        }\n        \n        qsort(teams, n, sizeof(Team), compare);\n        \n        printf(\"%d\\n\", teams[0].id);\n        printf(\"%d\\n\", teams[1].id);\n        printf(\"%d\\n\", teams[n-2].id);\n        \n        free(teams);\n    }\n    \n    return 0;\n}\n", "perturbed_sampled": ["#include <stdio.h> #include <stdlib.h> typedef struct   *a, const void  int main() { int n; while (scanf(\"%d\", &n) == 1 && n  = (Team *)malloc(n * sizeof(Team)); for (int  s4; scanf(\"%d %d %d    + s1) + (m2  (m3 * 60 + s3) +  } qsort(teams, n,  teams[1].id); printf(\"%d\\n\", teams[n-2].id); free(teams); } return 0; }"], "perturbed_original": ["#include <stdio.h> #include <stdlib.h> typedef struct { <extra_id_2>1; }<extra_id_3>a,<extra_id_4>int i =<extra_id_5>0; i <<extra_id_6>-= ((TEAM*)a)->m[i] * 60 +<extra_id_7>sum_b){<extra_id_8>SUM(SUM(i+1), sizeof(UNIQUE), comparison()); printf(\"%d\\n\",<extra_id_9>* 3600 +<extra_id_10>sum_b+((BASE)->s   team    for (j = 0; j < 4; j++){  } qsort(team, n, sizeof(TEAM), comparison); printf(\"%d\\n\",  -  a, const  sum_b; int i; sum_a = sum_b = 0;  += ((TEAM*)a)->m[i] * 60 + ((TEAM*)a)->s[i]; sum_b += ((TEAM*)b)->m[i] * 60 +  sum_b){  (sum_a < sum_b){ return -1; }  }"], "original_ll": -0.6397964954376221, "sampled_ll": -0.38309040665626526, "all_perturbed_sampled_ll": [-2.639148473739624], "all_perturbed_original_ll": [-2.7641422748565674], "perturbed_sampled_ll": -2.639148473739624, "perturbed_original_ll": -2.7641422748565674, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import java.util.Scanner;\nclass Main\n{\n    public static void main(String args[])\n    {\n\tScanner scan=new Scanner(System.in);\n\twhile(true)\n\t    {\n\t\tint n=scan.nextInt();\n\t\tif(n==0)break;\n\t\tint num[]=new int[n];\n\t\tint sum[]=new int[n];\n\t\tfor(int i=0;i<n;i++)\n\t\t    {\n\t\t\tnum[i]=scan.nextInt();\n\t\t\tfor(int j=0;j<8;j++)\n\t\t\t    {\n\t\t\t\tif(j%2==0)sum[i]+=60*(scan.nextInt());\n\t\t\t\telse sum[i]+=scan.nextInt();\n\t\t\t    }\n\t\t    }\n\t\t\n\t\tfor(int i=0;i<n;i++)\n\t\t    {\n\t\t\tint min=sum[i],x=i;\n\t\t\tfor(int j=i;j<n;j++)\n\t\t\t    {\n\t\t\t\tif(min>sum[j])\n\t\t\t\t    {\n\t\t\t\t\tmin=sum[j];\n\t\t\t\t\tx=j;\n\t\t\t\t\t\n\t\t\t\t    }\n\t\t\t    }\n\t\t\tint tmp=num[i];\n\t\t\tnum[i]=num[x];\n\t\t\tnum[x]=tmp;\n\t\t\tint tmp2=sum[i];\n\t\t\tsum[i]=sum[x];\n\t\t\tsum[x]=tmp2;\n\t\t    }\n\t\t\n\t\tSystem.out.println(num[0]);\n\t\tSystem.out.println(num[1]);\n\t\tSystem.out.println(num[n-2]);\n\t    }\n    }\n}", "sampled": "import java.util.*;\n\npublic class Main {\n    static class Team implements Comparable<Team> {\n        int id;\n        int totalSeconds;\n        \n        Team(int id, int totalSeconds) {\n            this.id = id;\n            this.totalSeconds = totalSeconds;\n        }\n        \n        @Override\n        public int compareTo(Team other) {\n            return this.totalSeconds - other.totalSeconds;\n        }\n    }\n    \n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        \n        while (true) {\n            int n = sc.nextInt();\n            if (n == 0) break;\n            \n            Team[] teams = new Team[n];\n            \n            for (int i = 0; i < n; i++) {\n                int id = sc.nextInt();\n                int totalSeconds = 0;\n                \n                for (int j = 0; j < 4; j++) {\n                    int m = sc.nextInt();\n                    int s = sc.nextInt();\n                    totalSeconds += m * 60 + s;\n                }\n                \n                teams[i] = new Team(id, totalSeconds);\n            }\n            \n            Arrays.sort(teams);\n            \n            System.out.println(teams[0].id);\n            System.out.println(teams[1].id);\n            System.out.println(teams[n - 2].id);\n        }\n        \n        sc.close();\n    }\n}\n", "perturbed_sampled": ["import java.util.*;  class Team implements Comparable<Team> { int  int totalSeconds) { this.id = id; this.totalSeconds = totalSeconds; } @Override public int compareTo(Team   void main(String[] args) { Scanner sc = new Scanner(System.in); while (true)  if (n == 0)     new Team(id, totalSeconds); } Arrays.sort(teams); System.out.println(teams[0].id); System.out.println(teams[1].id); System.out.println(teams[n - 2].id); } sc.close(); } }"], "perturbed_original": ["import  static void main(String args[]) { Scanner scan=new Scanner(System.in); while(true)  int[n];  { min=sum[j]; x=j;  num[x]=tmp; int tmp2=sum[i]; sum[i]=sum[x]; sum[x]=tmp2; } System.out.println(num[0]); System.out.println(num[1]); System.out.println(num[n-2]); } } }"], "original_ll": -0.8493826389312744, "sampled_ll": -0.4516538083553314, "all_perturbed_sampled_ll": [-1.7769368886947632], "all_perturbed_original_ll": [-2.3731019496917725], "perturbed_sampled_ll": -1.7769368886947632, "perturbed_original_ll": -2.3731019496917725, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "while 1:\n    n=int(input())\n    if n==0:break\n    a={}\n    for _ in range(n):\n        b=list(map(int,input().split()))\n        a[b[0]]=sum(b[1:8:2])*60+sum(b[2:9:2])\n    a=sorted(a.items(),key=lambda x:x[1])\n    for i in [0,1,-2]:print(a[i][0])", "sampled": "import sys\n\ndef solve():\n    while True:\n        n = int(input())\n        if n == 0:\n            break\n        \n        teams = []\n        for _ in range(n):\n            parts = list(map(int, input().split()))\n            team_id = parts[0]\n            \n            # Calculate total time in seconds\n            total_seconds = 0\n            for i in range(1, 9, 2):\n                minutes = parts[i]\n                seconds = parts[i + 1]\n                total_seconds += minutes * 60 + seconds\n            \n            teams.append((total_seconds, team_id))\n        \n        # Sort by total time\n        teams.sort()\n        \n        # Winner: smallest time (index 0)\n        winner = teams[0][1]\n        # Runner-up: second smallest time (index 1)\n        runner_up = teams[1][1]\n        # Booby prize: second to last (index n-2)\n        booby = teams[n - 2][1]\n        \n        print(winner)\n        print(runner_up)\n        print(booby)\n\nsolve()\n", "perturbed_sampled": ["import sys def solve(): while  = list(map(int, input().split()))   = 0 for i in range(1,  seconds  += minutes * 60 + seconds teams.append((total_seconds, team_id)) # Sort by  smallest  teams[0][1] # Runner-up: second smallest time (index    print(booby) solve()"], "perturbed_original": [" a={} for _ in  for i in [0,1,-2]:print(a[i][0])"], "original_ll": -1.3816105127334595, "sampled_ll": -1.039450764656067, "all_perturbed_sampled_ll": [-3.8675317764282227], "all_perturbed_original_ll": [-3.5256564617156982], "perturbed_sampled_ll": -3.8675317764282227, "perturbed_original_ll": -3.5256564617156982, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "#include<stdio.h>\n#include<math.h>\nint dfs(int,int);\nint boad[110][110];\nint w,h,xs,ys,xg,yg,n,c,d;\n\nint main(void){\n  int x,y,i,j,a,b;\n\n  while(1){\n   \n    scanf(\"%d %d\",&w,&h);\n    if(w==0 && h==0)break;\n    scanf(\"%d %d\",&xs,&ys);\n    scanf(\"%d %d\",&xg,&yg);\n    scanf(\"%d\",&n);\n    \n    for(i=0;i<110;i++){\n      for(j=0;j<110;j++){\n\tboad[i][j]=-1;\n      }\n    }\n    int k;\n    for(k=0;k<n;k++){\n      scanf(\"%d %d %d %d\",&c,&d,&x,&y);\n      \n      if(d){a=4;b=2;}\n      else {a=2;b=4;}\n\tfor(i=y;i<y+a;i++){\n\t  for(j=x;j<x+b;j++){\n\t    boad[i][j]=c;\n\t  }\n\t}\n\n    }\n    c=boad[xs][ys];\n \n  \n    if(dfs(xs,ys))printf(\"OK\\n\");\n    else printf(\"NG\\n\");\n    /*for(i=0;i<15;i++){\n      for(j=0;j<15;j++)\nprintf(\"%2d\",boad[i][j]);\n      printf(\"\\n\");\n      }*/\n  }\n  return 0;\n}\n  \nint dfs(int x,int y){\n  int i,j,res=0;\n  if(x<=0||x>w||y<=0||y>h||boad[x][y]!=c)return 0;\n  if(x==xg && y==yg)return 1;\n  \n  boad[x][y]=-1;\n  \n  for(i=-1;i<2;i++){\n    for(j=-1;j<2;j++){\n      if(boad[x+i][y+j]==c && abs(i)+abs(j)==1 && boad[x+i][y+j]!=-1)\n\tif(dfs(x+i,y+j))return 1;\n    }\n  }\n  return 0;\n}", "sampled": "#include <stdio.h>\n#include <stdlib.h>\n\n#define MAX 1000000\n\nint hamming[100000];\nint hamming_count = 0;\n\nint compare(const void *a, const void *b) {\n    return (*(int*)a - *(int*)b);\n}\n\nvoid generate_hamming() {\n    hamming[hamming_count++] = 1;\n    \n    int i2 = 0, i3 = 0, i5 = 0;\n    int next_2 = 2, next_3 = 3, next_5 = 5;\n    \n    while (1) {\n        int next = next_2;\n        if (next_3 < next) next = next_3;\n        if (next_5 < next) next = next_5;\n        \n        if (next > MAX) break;\n        \n        hamming[hamming_count++] = next;\n        \n        if (next == next_2) {\n            i2++;\n            next_2 = hamming[i2] * 2;\n        }\n        if (next == next_3) {\n            i3++;\n            next_3 = hamming[i3] * 3;\n        }\n        if (next == next_5) {\n            i5++;\n            next_5 = hamming[i5] * 5;\n        }\n    }\n}\n\nint binary_search_lower(int val) {\n    int left = 0, right = hamming_count - 1;\n    int result = hamming_count;\n    \n    while (left <= right) {\n        int mid = (left + right) / 2;\n        if (hamming[mid] >= val) {\n            result = mid;\n            right = mid - 1;\n        } else {\n            left = mid + 1;\n        }\n    }\n    \n    return result;\n}\n\nint binary_search_upper(int val) {\n    int left = 0, right = hamming_count - 1;\n    int result = -1;\n    \n    while (left <= right) {\n        int mid = (left + right) / 2;\n        if (hamming[mid] <= val) {\n            result = mid;\n            left = mid + 1;\n        } else {\n            right = mid - 1;\n        }\n    }\n    \n    return result;\n}\n\nint main() {\n    generate_hamming();\n    \n    int m, n;\n    while (1) {\n        scanf(\"%d\", &m);\n        if (m == 0) break;\n        scanf(\"%d\", &n);\n        \n        int lower = binary_search_lower(m);\n        int upper = binary_search_upper(n);\n        \n        if (lower <= upper) {\n            printf(\"%d\\n\", upper - lower + 1);\n        } else {\n            printf(\"0\\n\");\n        }\n    }\n    \n    return 0;\n}\n", "perturbed_sampled": ["#include  1000000 int hamming[100000];  compare(const void *a, const  i5 = 0; int next_2 =  =  next = next_2; if (next_3  if (next_5 < next) next      } if  next_5 = hamming[i5] * 5; } } } int binary_search_lower(int val) { int left = 0,   (left <= right) { int mid = (left  (hamming[mid] >= val) { result = mid;  } else { left = mid  val) { int left = 0,  mid; left =   n;  if (m == 0) break; scanf(\"%d\", &n); int lower = binary_search_lower(m); int upper = binary_search_upper(n); if (lower <= upper) { printf(\"%d\\n\", upper  else { printf(\"0\\n\"); } } return 0; }"], "perturbed_original": ["#include<stdio.h> #include<math.h> int dfs(int,int); int boad[110][110]; int w,h,xs,ys,xg,yg,n,c,d; int main(void){ int  && h==0)break; scanf(\"%d  for(j=0;j<110;j++){ boad[i][j]=-1; }  /*for(i=0;i<15;i++){  i,j,res=0; if(x<=0||x>w||y<=0||y>h||boad[x][y]!=c)return 0; if(x==xg && y==yg)return 1; boad[x][y]=-1;  && boad[x+i][y+j]!=-1) if(dfs(x+i,y+j))return 1; } } return 0; }"], "original_ll": -1.0129550695419312, "sampled_ll": -0.45382261276245117, "all_perturbed_sampled_ll": [-2.450016498565674], "all_perturbed_original_ll": [-2.125328302383423], "perturbed_sampled_ll": -2.450016498565674, "perturbed_original_ll": -2.125328302383423, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import java.util.Scanner;\n\nclass Main {\n\tpublic static void main(String[] args){\n\t\tScanner scan = new Scanner(System.in);\n\t\tint m, n;\n\t\tint a;\n\t\t\n\t\tint count;\n\t\t\n\t\twhile(true){\n\t\t\tm = scan.nextInt();\n\t\t\tn = scan.nextInt();\n\t\t\tif(m == 0)break;\n\t\t\t\n\t\t\tcount = 0;\n\t\t\tfor(int i = m;i <= n; i++){\n\t\t\t\ta = i;\n\t\t\t\twhile(true){\n\t\t\t\t\tif(a == 1){\n\t\t\t\t\t\tcount++;;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tif(a % 2 != 0 && a % 3 != 0 && a % 5 != 0){\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tif(a % 2 == 0)a /= 2;\n\t\t\t\t\telse if(a % 3 == 0)a /= 3;\n\t\t\t\t\telse if(a % 5 == 0)a /= 5;\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(count);\n\t\t}\n\t}\n}", "sampled": "import java.util.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        \n        // Precompute all Hamming numbers up to 1000000\n        TreeSet<Long> hammingSet = new TreeSet<>();\n        long limit = 1000000;\n        \n        for (long i = 1; i <= limit; i *= 2) {\n            for (long j = i; j <= limit; j *= 3) {\n                for (long k = j; k <= limit; k *= 5) {\n                    hammingSet.add(k);\n                }\n            }\n        }\n        \n        List<Long> hamming = new ArrayList<>(hammingSet);\n        \n        while (true) {\n            int m = sc.nextInt();\n            if (m == 0) break;\n            int n = sc.nextInt();\n            \n            int count = 0;\n            for (long h : hamming) {\n                if (h >= m && h <= n) {\n                    count++;\n                } else if (h > n) {\n                    break;\n                }\n            }\n            \n            System.out.println(count);\n        }\n        \n        sc.close();\n    }\n}\n", "perturbed_sampled": ["import java.util.*;  static void main(String[] args) {  //  (long  limit; i *= 2) {  j <= limit; j *= 3) { for (long k =  hamming =  int  n = sc.nextInt(); int count =  hamming)  && h <= n) { count++;  } System.out.println(count); } sc.close(); } }"], "perturbed_original": [" public static void main(String[] args){ Scanner scan  n;   scan.nextInt(); if(m == 0)break; count = 0; for(int i = m;i <= n; i++){ a = i;  break; }  break; }  /= 2; else if(a  } } }"], "original_ll": -0.7110258340835571, "sampled_ll": -0.6186495423316956, "all_perturbed_sampled_ll": [-2.9641025066375732], "all_perturbed_original_ll": [-2.9042763710021973], "perturbed_sampled_ll": -2.9641025066375732, "perturbed_original_ll": -2.9042763710021973, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import math\n\nwhile True:\n    try:\n        m, n = map(int, raw_input().split())\n\n        f2 = int(math.log(n, 2)) + 1\n        f3 = int(math.log(n, 3)) + 1\n        f5 = int(math.log(n, 5)) + 1\n\n        c = 0\n        for i in range(f2):\n            for j in range(f3):\n                for k in range(f5):\n                    if m <= (2 ** i) * (3 ** j) * (5 ** k) <= n:\n                        c += 1\n        print c\n\n    except ValueError:\n        break", "sampled": "import heapq\n\ndef generate_hamming_numbers(limit):\n    hamming = set([1])\n    heap = [1]\n    \n    while heap:\n        h = heapq.heappop(heap)\n        if h > limit:\n            break\n        \n        for factor in [2, 3, 5]:\n            new_num = h * factor\n            if new_num <= limit and new_num not in hamming:\n                hamming.add(new_num)\n                heapq.heappush(heap, new_num)\n    \n    return sorted(hamming)\n\n# Pre-generate all Hamming numbers up to 1000000\nhamming_numbers = generate_hamming_numbers(1000000)\n\nwhile True:\n    line = input().strip()\n    if line == \"0\":\n        break\n    \n    m, n = map(int, line.split())\n    \n    # Binary search for the range\n    count = 0\n    for h in hamming_numbers:\n        if h < m:\n            continue\n        if h > n:\n            break\n        count += 1\n    \n    print(count)\n", "perturbed_sampled": [" [1] while  for factor in [2, 3, 5]: new_num   not in hamming: hamming.add(new_num) heapq.heappush(heap, new_num) return sorted(hamming) # Pre-generate all Hamming numbers up to 1000000 hamming_numbers = generate_hamming_numbers(1000000)  if line  =  for the range   += 1 print(count)"], "perturbed_original": ["import math  =   0 for i  range(f3): for   (3 ** j) * (5 ** k) <= n: c += 1 print c except ValueError: break"], "original_ll": -0.8032776117324829, "sampled_ll": -0.8577947616577148, "all_perturbed_sampled_ll": [-2.7305307388305664], "all_perturbed_original_ll": [-4.04844856262207], "perturbed_sampled_ll": -2.7305307388305664, "perturbed_original_ll": -4.04844856262207, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "#include<stdio.h>\nint main(){\n  const int d[8][8]={\n    {0,0,  0,  0,  0,  0,   0,  0},\n    {0,0,300,500,600,700,1350,1650},\n    {0,0,  0,350,450,600,1150,1500},\n    {0,0,  0,  0,250,400,1000,1350},\n    {0,0,  0,  0,  0,250, 850,1300},\n    {0,0,  0,  0,  0,  0, 600,1150},\n    {0,1,  0,  0,  0,  0,   0, 500},\n    {0,1,  1,  1,  1,  1,   0,   0}\n  };\n  int n,m,ih,it,oh,ot;\n  int p=0;\n  while(1){\n    scanf(\"%d\",&n);\n    if(!n)break;\n    scanf(\"%d %d %d %d %d\",&ih,&it,&m,&oh,&ot);\n    if(n>m){\n      p=n;\n      n=m;\n      m=p;\n    }\n    p=d[n][m];\n    it+=60*ih;\n    ot+=60*oh;\n    if(d[m][n]==0&&\n       ((17*60+30<=it&&it<=19*60+30)||\n\t17*60+30<=ot&&ot<=19*60+30))p/=2;\n    if(p%50)p+=25;\n    printf(\"%d\\n\",p);\n  }\n  return 0;\n}", "sampled": "#include <stdio.h>\n\nint main() {\n    int price[8][8] = {\n        {0, 0, 0, 0, 0, 0, 0, 0},\n        {0, 0, 350, 450, 600, 750, 1050, 1300},\n        {0, 350, 0, 450, 500, 650, 900, 1150},\n        {0, 450, 450, 0, 400, 500, 750, 1050},\n        {0, 600, 500, 400, 0, 350, 600, 850},\n        {0, 750, 650, 500, 350, 0, 450, 700},\n        {0, 1050, 900, 750, 600, 450, 0, 500},\n        {0, 1300, 1150, 1050, 850, 700, 500, 0}\n    };\n    \n    int distance[8][8] = {\n        {0, 0, 0, 0, 0, 0, 0, 0},\n        {0, 0, 9, 12, 19, 25, 39, 58},\n        {0, 9, 0, 12, 16, 22, 36, 55},\n        {0, 12, 12, 0, 10, 16, 30, 49},\n        {0, 19, 16, 10, 0, 10, 24, 43},\n        {0, 25, 22, 16, 10, 0, 18, 37},\n        {0, 39, 36, 30, 24, 18, 0, 19},\n        {0, 58, 55, 49, 43, 37, 19, 0}\n    };\n    \n    int d;\n    while(scanf(\"%d\", &d) == 1 && d != 0) {\n        int hd, md, a, ha, ma;\n        scanf(\"%d %d\", &hd, &md);\n        scanf(\"%d\", &a);\n        scanf(\"%d %d\", &ha, &ma);\n        \n        int start_time = hd * 60 + md;\n        int end_time = ha * 60 + ma;\n        int discount_start = 17 * 60 + 30;\n        int discount_end = 19 * 60 + 30;\n        \n        int dist = distance[d][a];\n        int cost = price[d][a];\n        \n        int is_discount = 0;\n        if ((start_time >= discount_start && start_time <= discount_end) ||\n            (end_time >= discount_start && end_time <= discount_end)) {\n            if (dist <= 40) {\n                is_discount = 1;\n            }\n        }\n        \n        if (is_discount) {\n            int half = cost / 2;\n            if (cost % 2 != 0) {\n                half++;\n            }\n            int remainder = half % 50;\n            if (remainder != 0) {\n                half = half + (50 - remainder);\n            }\n            cost = half;\n        }\n        \n        printf(\"%d\\n\", cost);\n    }\n    \n    return 0;\n}\n", "perturbed_sampled": ["#include <stdio.h> int  0, 0, 0, 0, 0}, {0, 0,  1300}, {0, 350, 0, 450, 500, 650, 900, 1150}, {0, 450, 450, 0, 400, 500,  850}, {0, 750, 650, 500, 350, 0,  750,  1300, 1150, 1050, 850, 700, 500, 0} }; int distance[8][8] =   25, 39, 58},  12, 12, 0, 10,  24, 43}, {0, 25, 22, 16,  39, 36, 30, 24,   while(scanf(\"%d\", &d) == 1 &&   scanf(\"%d %d\",  %d\", &ha, &ma); int start_time  ma; int    int cost =  if ((start_time >= discount_start && start_time <=   } }    remainder = half % 50; if  - remainder); } cost = half; }  }"], "perturbed_original": ["#include<stdio.h> int main(){ const int d[8][8]={ {0,0, 0, 0, 0, 0, 0, 0}, {0,0,300,500,600,700,1350,1650}, {0,0, 0,350,450,600,1150,1500}, {0,0, 0, 0,250,400,1000,1350}, {0,0,  1, 0, 0}  while(1){  %d  if(d[m][n]==0&&  return 0; }"], "original_ll": -1.0658456087112427, "sampled_ll": -0.5465840101242065, "all_perturbed_sampled_ll": [-1.9580013751983643], "all_perturbed_original_ll": [-1.4361400604248047], "perturbed_sampled_ll": -1.9580013751983643, "perturbed_original_ll": -1.4361400604248047, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import java.util.Scanner;\n\n\npublic class Main {\n\t\n\tpublic static int[][] money = new int[][]\n\t\t\t{\n\t\t\t\t{\t0,\t300,\t500,\t600,\t700,\t1350,\t1650},\n\t\t\t\t{\t0,\t0,\t\t350,\t450,\t600,\t1150,\t1500},\n\t\t\t\t{\t0,\t0,\t\t0,\t\t250,\t400,\t1000,\t1350},\n\t\t\t\t{\t0,\t0,\t\t0,\t\t0,\t\t250,\t850,\t1300},\n\t\t\t\t{\t0,\t0,\t\t0,\t\t0,\t\t0,\t\t600,\t1150},\n\t\t\t\t{\t0,\t0,\t\t0,\t\t0,\t\t0,\t\t0,\t\t 500},\n\t\t\t};\n\t\n\tpublic static int[][] dist = new int[][]\n\t\t\t{\n\t\t\t\t{\t0,\t6,\t13,\t18,\t23,\t43,\t58},\n\t\t\t\t{\t0,\t0,\t7,\t12,\t17,\t37,\t52},\n\t\t\t\t{\t0,\t0,\t0,\t5,\t10,\t30,\t45},\n\t\t\t\t{\t0,\t0,\t0,\t0,\t5,\t25,\t40},\n\t\t\t\t{\t0,\t0,\t0,\t0,\t0,\t20,\t35},\n\t\t\t\t{\t0,\t0,\t0,\t0,\t0,\t0,\t15},\n\t\t\t};\n\t\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\t\n\t\twhile(true){\n\t\t\tfinal int start = sc.nextInt() - 1;\n\t\t\t\n\t\t\tif(start == -1){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\n\t\t\tfinal int start_h = sc.nextInt();\n\t\t\tfinal int start_m = sc.nextInt();\n\t\t\tfinal int start_t = start_h * 60 + start_m;\n\t\t\t\n\t\t\tfinal int end = sc.nextInt() - 1;\n\t\t\tfinal int end_h = sc.nextInt();\n\t\t\tfinal int end_m = sc.nextInt();\n\t\t\tfinal int end_t = end_h * 60 + end_m;\n\t\t\t\n\t\t\tint cost = 0;\n\t\t\tif(start_t <= (17 * 60 + 30) && end_t >= (17 * 60 + 30) && end_t <= (19 * 60 + 30) || start_t >= (17 * 60 + 30) && start_t <= (19 * 60 + 30) && end_t >= (19 * 60 + 30)){\n\t\t\t\tif(dist[start][end] <= 40){\n\t\t\t\t\tcost = (int) (Math.ceil((money[start][end] / (2.0 * 50)))) * 50;\n\t\t\t\t}else{\n\t\t\t\t\tcost = money[start][end];\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\tcost = money[start][end];\n\t\t\t}\n\t\t\t\n\t\t\tSystem.out.println(cost);\n\t\t}\n\t\t\n\t}\n\n}", "sampled": "import java.util.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        \n        // Distance and price table\n        int[][] distance = new int[8][8];\n        int[][] price = new int[8][8];\n        \n        // Initialize distance table (symmetric)\n        int[][] distData = {\n            {0, 6, 12, 18, 32, 41, 58},\n            {6, 0, 6, 12, 26, 35, 52},\n            {12, 6, 0, 6, 20, 29, 46},\n            {18, 12, 6, 0, 14, 23, 40},\n            {32, 26, 20, 14, 0, 9, 26},\n            {41, 35, 29, 23, 9, 0, 17},\n            {58, 52, 46, 40, 26, 17, 0}\n        };\n        \n        int[][] priceData = {\n            {0, 350, 450, 600, 900, 1150, 1400},\n            {350, 0, 350, 450, 750, 900, 1200},\n            {450, 350, 0, 350, 600, 750, 1050},\n            {600, 450, 350, 0, 450, 600, 850},\n            {900, 750, 600, 450, 0, 350, 600},\n            {1150, 900, 750, 600, 350, 0, 350},\n            {1400, 1200, 1050, 850, 600, 350, 0}\n        };\n        \n        for (int i = 0; i < 7; i++) {\n            for (int j = 0; j < 7; j++) {\n                distance[i+1][j+1] = distData[i][j];\n                price[i+1][j+1] = priceData[i][j];\n            }\n        }\n        \n        while (true) {\n            int d = sc.nextInt();\n            if (d == 0) break;\n            \n            int hd = sc.nextInt();\n            int md = sc.nextInt();\n            int a = sc.nextInt();\n            int ha = sc.nextInt();\n            int ma = sc.nextInt();\n            \n            int dist = distance[d][a];\n            int baseFare = price[d][a];\n            \n            // Check if discount applies\n            // 17:30 - 19:30 (1050 - 1170 minutes from midnight)\n            int departTime = hd * 60 + md;\n            int arriveTime = ha * 60 + ma;\n            \n            boolean discount = false;\n            if (dist <= 40) {\n                // Check if either departure or arrival is in discount time\n                if ((departTime >= 1050 && departTime <= 1170) || \n                    (arriveTime >= 1050 && arriveTime <= 1170)) {\n                    discount = true;\n                }\n            }\n            \n            int fare;\n            if (discount) {\n                // Half price, round up to nearest 50 yen\n                int halfFare = baseFare / 2;\n                fare = ((halfFare + 49) / 50) * 50;\n            } else {\n                fare = baseFare;\n            }\n            \n            System.out.println(fare);\n        }\n        \n        sc.close();\n    }\n}\n", "perturbed_sampled": [" { public static void  int[][] distance =  new int[8][8]; // Initialize distance table (symmetric)  6, 12, 26, 35,  12, 6, 0, 14, 23, 40}, {32, 26, 20, 14, 0, 9, 26}, {41,  17}, {58, 52, 46, 40, 26, 17, 0} }; int[][]  450, 600, 900, 1150, 1400}, {350, 0, 350, 450, 750, 900, 1200}, {450, 350, 0, 350,  350, 0, 450, 600,   350}, {1400, 1200, 1050,  for (int i = 0; i < 7; i++) { for (int j = 0; j < 7; j++) { distance[i+1][j+1] = distData[i][j]; price[i+1][j+1] = priceData[i][j]; }  int ma  - 19:30 (1050 - 1170 minutes from midnight)   = ha *  = false;    1170)) { discount =  if (discount) { // Half  =  ((halfFare + 49) / 50)  }"], "perturbed_original": ["import java.util.Scanner; public class Main { public static <extra_id_7>m[end_t][end_h] + end_m<extra_id_8>end<extra_id_9>= (int)$((int)(this.m*sum()<extra_id_10>)<extra_id_11>; } static void<extra_id_12>char a[64][64],<extra_id_13>;<extra_id_14>) ) ; 1650}, { 0, 0, 350, 450, 600, 1150, 1500}, { 0, 0, 0, 250, 400,  0, 0, 250,  0, 0, 0, 600, 1150}, { 0, 0, 0, 0, 0, 0, 500}, }; public   58}, { 0, 0, 7, 12, 17, 37, 52}, { 0, 0,  { 0, 0, 0, 0, 5,  0, 0, 0, 20, 35},  0, 0, 15}, }; public static void main(String[] args) {  = sc.nextInt();  = sc.nextInt(); final int end_t = end_h * 60 + end_m;   30)  60 +   60 + 30)  60  cost = (int) (Math.ceil((money[start][end] /  } }"], "original_ll": -0.634609580039978, "sampled_ll": -0.6525737047195435, "all_perturbed_sampled_ll": [-1.869335412979126], "all_perturbed_original_ll": [-1.9909716844558716], "perturbed_sampled_ll": -1.869335412979126, "perturbed_original_ll": -1.9909716844558716, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "table=[[0,300,500,600,700,1350,1650],\n       [0,0,350,450,600,1150,1500],\n       [0,0,0,250,400,1000,1350],\n       [0,0,0,0,250,850,1300],\n       [0,0,0,0,0,600,1150],\n       [0,0,0,0,0,0,500]]\nfbd=[(1,6),(1,7),(2,7),(3,7)]\nwhile True:\n    init=input()\n    if init==0:break\n    h1,m1=map(int,raw_input().split())\n    fin=input()\n    h2,m2=map(int,raw_input().split())\n    if init>fin:\n        init,h1,m1,fin,h2,m2=fin,h2,m2,init,h1,m1\n    t1=h1*60+m1\n    t2=h2*60+m2\n    if 1050<=t1<=1170 or 1050<=t2<=1170 and (init,fin) not in fbd:\n        temp=table[init-1][fin-1]/2\n        if temp%100>0:\n            temp+=50-temp%50\n        print temp\n    else:\n        print table[init-1][fin-1]", "sampled": "import math\n\n# Distance and toll matrix\ndistance = [\n    [0, 6, 18, 25, 37, 48, 58],\n    [6, 0, 12, 19, 31, 42, 52],\n    [18, 12, 0, 7, 19, 30, 40],\n    [25, 19, 7, 0, 12, 23, 33],\n    [37, 31, 19, 12, 0, 11, 21],\n    [48, 42, 30, 23, 11, 0, 10],\n    [58, 52, 40, 33, 21, 10, 0]\n]\n\ntoll = [\n    [0, 200, 500, 650, 900, 1150, 1350],\n    [200, 0, 450, 600, 850, 1100, 1300],\n    [500, 450, 0, 250, 500, 750, 950],\n    [650, 600, 250, 0, 350, 600, 800],\n    [900, 850, 500, 350, 0, 300, 550],\n    [1150, 1100, 750, 600, 300, 0, 250],\n    [1350, 1300, 950, 800, 550, 250, 0]\n]\n\ndef in_discount_time(h, m):\n    time_minutes = h * 60 + m\n    start = 17 * 60 + 30  # 17:30\n    end = 19 * 60 + 30    # 19:30\n    return start <= time_minutes <= end\n\nwhile True:\n    d = int(input())\n    if d == 0:\n        break\n    \n    hd, md = map(int, input().split())\n    a = int(input())\n    ha, ma = map(int, input().split())\n    \n    # Convert to 0-indexed\n    d -= 1\n    a -= 1\n    \n    # Get base toll and distance\n    base_toll = toll[d][a]\n    dist = distance[d][a]\n    \n    # Check if discount applies\n    discount = False\n    if (in_discount_time(hd, md) or in_discount_time(ha, ma)) and dist <= 40:\n        discount = True\n    \n    if discount:\n        # Half price, rounded up to nearest 50\n        half_toll = base_toll / 2\n        final_toll = math.ceil(half_toll / 50) * 50\n    else:\n        final_toll = base_toll\n    \n    print(final_toll)\n", "perturbed_sampled": [" toll  6, 18, 25, 37, 48, 58], [6, 0, 12, 19, 31, 42, 52], [18, 12,  11, 21], [48,  33, 21, 10, 0] ] toll =  0, 450, 600, 850, 1100, 1300],  750, 950],  600, 800], [900,  550], [1150,    h  =  19    = int(input()) if d  = int(input())  d -= 1 a -= 1 # Get  = toll[d][a] dist = distance[d][a] # Check if discount applies  md) or in_discount_time(ha, ma)) and dist <= 40: discount =  base_toll / 2 final_toll  50 else: final_toll = base_toll print(final_toll)"], "perturbed_original": ["table=[[0,300,500,600,700,1350,1650],  fbd=[(1,6),(1,7),(2,7),(3,7)] while  fin=input() h2,m2=map(int,raw_input().split()) if  1050<=t1<=1170 or 1050<=t2<=1170 and (init,fin) not  print table[init-1][fin-1]"], "original_ll": -1.1162550449371338, "sampled_ll": -0.6413790583610535, "all_perturbed_sampled_ll": [-2.4232616424560547], "all_perturbed_original_ll": [-2.6037485599517822], "perturbed_sampled_ll": -2.4232616424560547, "perturbed_original_ll": -2.6037485599517822, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "a[];main(f,l,i,n,S){for(;scanf(S=\"%d\\n\",&i)*i;){for(l=0;i--;)scanf(S,a+l++);for(n=32;n;f=!f)n-=f?~-n%5:a[++i%l],printf(S,n*=n>0);}}", "sampled": "#include <stdio.h>\n\nint main() {\n    int n;\n    while (scanf(\"%d\", &n) == 1 && n != 0) {\n        int a[25];\n        for (int i = 0; i < n; i++) {\n            scanf(\"%d\", &a[i]);\n        }\n        \n        int remaining = 32;\n        int jiro_index = 0;\n        int turn = 0; // 0 for Ichiro, 1 for Jiro\n        \n        while (remaining > 0) {\n            if (turn == 0) {\n                // Ichiro's turn\n                int take = (remaining - 1) % 5;\n                remaining -= take;\n                printf(\"%d\\n\", remaining);\n                turn = 1;\n            } else {\n                // Jiro's turn\n                int take = a[jiro_index];\n                if (take >= remaining) {\n                    take = remaining;\n                }\n                remaining -= take;\n                printf(\"%d\\n\", remaining);\n                jiro_index = (jiro_index + 1) % n;\n                turn = 0;\n            }\n        }\n    }\n    return 0;\n}\n", "perturbed_sampled": ["#include  n;   int a[25]; for  < n; i++) { scanf(\"%d\",    > 0) { if (turn == 0) { // Ichiro's turn int take = (remaining -  take; printf(\"%d\\n\", remaining);   remaining -= take; printf(\"%d\\n\", remaining); jiro_index = (jiro_index + 1) % n;  } return 0; }"], "perturbed_original": ["a[];main(f,l,i,n,S){for(;scanf(S=\"%d\\n\",&i)*i;){for(l=0;i--;)scanf(S,a+l++);for(n=32;n;f=!f)n-=f?~-n%5:a[++i%l],printf(S,n*=n>0);}}"], "original_ll": -4.209161758422852, "sampled_ll": -0.8070781230926514, "all_perturbed_sampled_ll": [-3.2868852615356445], "all_perturbed_original_ll": [-4.209161758422852], "perturbed_sampled_ll": -3.2868852615356445, "perturbed_original_ll": -4.209161758422852, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import static java.util.Arrays.deepToString;\n\nimport java.util.Scanner;\n\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n\tvoid tr(Object... os) {\n\t\tSystem.err.println(deepToString(os));\n\t}\n\n\tScanner sc = new Scanner(System.in);\n\tpublic void run() {\n\t\tfor (;sc.hasNext();) {\n\t\t\tint n = sc.nextInt();\n\t\t\tif (n == 0) break;\n\t\t\tint[] a = new int[n];\n\t\t\tfor (int i = 0; i < n; i++) a[i] = sc.nextInt();\n\t\t\t\n\t\t\tint st = 32;\n\t\t\tfor (int time = 0; st > 0; time++) {\n\t\t\t\tst -= (st - 1) % 5;\n\t\t\t\tSystem.out.println(st);\n\t\t\t\tint g = a[time%a.length];\n\t\t\t\tst -= g;\n\t\t\t\tif (st < 0) {\n\t\t\t\t\tst = 0;\n\t\t\t\t}\n\t\t\t\tSystem.out.println(st);\n\t\t\t}\n\t\t}\n\t}\n}", "sampled": "import java.util.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        \n        while (true) {\n            int n = sc.nextInt();\n            if (n == 0) break;\n            \n            int[] a = new int[n];\n            for (int i = 0; i < n; i++) {\n                a[i] = sc.nextInt();\n            }\n            \n            int remaining = 32;\n            int jiroIndex = 0;\n            \n            while (remaining > 0) {\n                // Ichiro's turn\n                int ichiroTake = (remaining - 1) % 5;\n                remaining -= ichiroTake;\n                System.out.println(remaining);\n                \n                if (remaining == 0) break;\n                \n                // Jiro's turn\n                int jiroTake = Math.min(a[jiroIndex], remaining);\n                remaining -= jiroTake;\n                System.out.println(remaining);\n                \n                jiroIndex = (jiroIndex + 1) % n;\n                \n                if (remaining == 0) break;\n            }\n        }\n        \n        sc.close();\n    }\n}\n", "perturbed_sampled": ["import java.util.*; public class  main(String[] args) { Scanner  a = new int[n]; for (int i = 0; i < n; i++) { a[i] = sc.nextInt(); } int remaining  turn int ichiroTake =  remaining -= ichiroTake; System.out.println(remaining); if (remaining ==  remaining); remaining   } }"], "perturbed_original": [" public  void main(String[] args) { new Main().run(); } void tr(Object... os)  (;sc.hasNext();) {  (n == 0)  int[n]; for (int i = 0; i < n; i++) a[i] = sc.nextInt(); int st = 32;  st   g; if (st  } } }"], "original_ll": -1.2089089155197144, "sampled_ll": -0.8288243412971497, "all_perturbed_sampled_ll": [-2.980612277984619], "all_perturbed_original_ll": [-3.1381731033325195], "perturbed_sampled_ll": -2.980612277984619, "perturbed_original_ll": -3.1381731033325195, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "while 1:\n    n=int(input())\n    if n==0: break\n    a=list(map(int,input().split()))\n    i,s=0,32\n    while s>0:\n        s-=(s-1)%5\n        print(s)\n        s-=a[i%n]\n        i+=1\n        print(max(0,s))", "sampled": "while True:\n    n = int(input())\n    if n == 0:\n        break\n    \n    sequence = list(map(int, input().split()))\n    \n    remaining = 32\n    jiro_index = 0\n    \n    while remaining > 0:\n        # Ichiro's turn\n        to_take = (remaining - 1) % 5\n        remaining -= to_take\n        print(remaining)\n        \n        if remaining == 0:\n            break\n        \n        # Jiro's turn\n        to_take = min(sequence[jiro_index], remaining)\n        remaining -= to_take\n        print(remaining)\n        \n        jiro_index = (jiro_index + 1) % n\n        \n        if remaining == 0:\n            break\n", "perturbed_sampled": ["while True: n = int(input()) if n ==  input().split())) remaining = 32 jiro_index =   turn to_take =  print(remaining) jiro_index = (jiro_index +  == 0: break"], "perturbed_original": ["while 1: n=int(input()) if n==0:  print(max(0,s))"], "original_ll": -1.8200606107711792, "sampled_ll": -1.2150248289108276, "all_perturbed_sampled_ll": [-4.176753520965576], "all_perturbed_original_ll": [-3.3633575439453125], "perturbed_sampled_ll": -4.176753520965576, "perturbed_original_ll": -3.3633575439453125, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "#include <stdio.h>\n\n#define MAX 10000000\n\nint pp[MAX + 1];\n\nint main(){\n  int n, p, m, i, j, prime, x, res, c;\n  pp[0] = pp[1] = 1;\n  for(i = 2; i < MAX / 2 ; ++i)\n    if(pp[i] != 1)\n      for(j = i * 2; j < MAX; j += i)\n\tpp[j] = 1;\n\n  while(scanf(\"%d\", &n) && n){\n    res = 0;\n    while(n--){\n      scanf(\"%d %d\", &p, &m);\n      c = 0;\n      for(i = ((p - m) < 0 ? 0 : p - m);i < ((p + m) > MAX ? MAX : p + m); ++i)\n\tif(pp[i] == 0) c++;\n      if(c > 0) c--;\n      res += c;\n    }\n    printf(\"%d\\n\", res);\n  }\n  return 0;\n}", "sampled": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#define MP 999983\n#define MAX_PRIMES 80000\n\nint is_prime[MP + 1];\nint primes[MAX_PRIMES];\nint prime_count = 0;\n\nvoid sieve() {\n    memset(is_prime, 1, sizeof(is_prime));\n    is_prime[0] = is_prime[1] = 0;\n    \n    for (int i = 2; i * i <= MP; i++) {\n        if (is_prime[i]) {\n            for (int j = i * i; j <= MP; j += i) {\n                is_prime[j] = 0;\n            }\n        }\n    }\n    \n    for (int i = 2; i <= MP; i++) {\n        if (is_prime[i]) {\n            primes[prime_count++] = i;\n        }\n    }\n}\n\nint binary_search_lower(int val) {\n    int left = 0, right = prime_count - 1;\n    int result = prime_count;\n    \n    while (left <= right) {\n        int mid = (left + right) / 2;\n        if (primes[mid] >= val) {\n            result = mid;\n            right = mid - 1;\n        } else {\n            left = mid + 1;\n        }\n    }\n    return result;\n}\n\nint binary_search_upper(int val) {\n    int left = 0, right = prime_count - 1;\n    int result = -1;\n    \n    while (left <= right) {\n        int mid = (left + right) / 2;\n        if (primes[mid] <= val) {\n            result = mid;\n            left = mid + 1;\n        } else {\n            right = mid - 1;\n        }\n    }\n    return result;\n}\n\nint count_primes_in_range(int lower, int upper) {\n    if (lower > MP) return 0;\n    if (upper < 2) return 0;\n    \n    if (lower < 2) lower = 2;\n    if (upper > MP) upper = MP;\n    \n    int lower_idx = binary_search_lower(lower);\n    int upper_idx = binary_search_upper(upper);\n    \n    if (lower_idx > upper_idx || lower_idx >= prime_count || upper_idx < 0) {\n        return 0;\n    }\n    \n    return upper_idx - lower_idx + 1;\n}\n\nint main() {\n    sieve();\n    \n    int n;\n    while (scanf(\"%d\", &n) == 1 && n != 0) {\n        long long total = 0;\n        \n        for (int i = 0; i < n; i++) {\n            int p, m;\n            scanf(\"%d %d\", &p, &m);\n            \n            int lower = p - m;\n            int upper = p + m;\n            \n            int X = count_primes_in_range(lower, upper);\n            \n            if (X > 1) {\n                total += (X - 1);\n            } else if (X == 0) {\n                total -= 1;\n            }\n        }\n        \n        if (total < 0) total = 0;\n        \n        printf(\"%lld\\n\", total);\n    }\n    \n    return 0;\n}\n", "perturbed_sampled": ["#include <stdio.h>  MP 999983 #define MAX_PRIMES 80000 int is_prime[MP + 1]; int primes[MAX_PRIMES]; int prime_count = 0;  = 0; for (int i = 2;  i++) { if  = i *   for (int i = 2; i <= MP;   <= right) { int mid = (left + right) / 2; if (primes[mid] >=   =  return result; } int binary_search_upper(int val)  = (left + right) / 2; if (primes[mid] <= val) { result = mid; left =  - 1; } } return result; } int    return 0; if (lower <  = binary_search_upper(upper); if (lower_idx > upper_idx || lower_idx >= prime_count ||  sieve(); int n; while  0; for   p, m; scanf(\"%d %d\", &p, &m); int lower = p - m; int upper =   } else if (X == 0) { total   return 0; }"], "perturbed_original": ["#include <stdio.h> #define MAX 10000000 int pp[MAX + 1]; int main(){ int   for(i = 2; i <  if(pp[i] !=  = 1; while(scanf(\"%d\", &n) && n){ res   m) <  + m); ++i)  > 0) c--; res += c; } printf(\"%d\\n\", res); } return 0; }"], "original_ll": -1.0047686100006104, "sampled_ll": -0.4375319182872772, "all_perturbed_sampled_ll": [-2.328582286834717], "all_perturbed_original_ll": [-2.7654716968536377], "perturbed_sampled_ll": -2.328582286834717, "perturbed_original_ll": -2.7654716968536377, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import java.io.*;\nimport java.util.*;\n\npublic class Main{\n\tpublic static void main(String args[]){\n\t\ttry{\n\t\t\tnew Main();\n\t\t}catch(IOException e){\n\t\t\te.printStackTrace();\n\t\t}\n\t}\n\t\n\tlong[] m = new long[]{ 2, 7, 61 };\n\t\n\tpublic Main() throws IOException{\n\t\tBufferedReader in = new BufferedReader(new InputStreamReader(System.in));\n\t\tList<Integer> Ans = new ArrayList<Integer>();\n\t\tString line;\n\t\t\n\t\tint[] prime = new int[1000000];\n\t\t\n\t\twhile((line = in.readLine()) != null){\n\t\t\tint size = Integer.parseInt(line);\n\t\t\tif(size==0) break;\n\t\t\t\n\t\t\tint pay = 0;\n\t\t\tfor(int n=0; n<size; n++){\n\t\t\t\tline = in.readLine();\n\t\t\t\tString[] dst = line.split(\" \");\n\t\t\t\tint center = Integer.parseInt(dst[0]);\n\t\t\t\tint range = Integer.parseInt(dst[1]);\n\t\t\t\t\n\t\t\t\tint count = 0;\n\t\t\t\tfor(int i=Math.max(2, center-range); i<=Math.min(center+range, 999983); i++){\n\t\t\t\t\tif(prime[i]==0){\n\t\t\t\t\t\tif(isPrime(i)){\n\t\t\t\t\t\t\tprime[i] = 1;\n\t\t\t\t\t\t\tcount++;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse{\n\t\t\t\t\t\t\tprime[i] = 2;\n\t\t\t\t\t\t}\n\t\t\t\t\t}else{\n\t\t\t\t\t\tif(prime[i]==1){\n\t\t\t\t\t\t\tcount++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tpay += count - 1;\n\t\t\t}\n\t\t\t\n\t\t\tAns.add(Math.max(0, pay));\n\t\t}\n\t\t\n\t\tfor(int n=0; n<Ans.size(); n++){\n\t\t\tSystem.out.println(Ans.get(n));\n\t\t}\t\t\n\t}\n\t\n\tpublic boolean isPrime(long x){\n\t\tif(x==2){\n\t\t\treturn true;\n\t\t}\n\t\telse if(x%2 == 0){\n\t\t\treturn false;\n\t\t}\n\t\telse{\n\t\t\tlong s = 0;\n\t\t\tlong d = x - 1;\n\t\t\twhile(d%2 == 0){\n\t\t\t\td = d / 2;\n\t\t\t\ts++;\n\t\t\t}\n\t\t\t\n\t\t\tfor(int i=0; i<3; i++){\n\t\t\t\tlong a = m[i];\n\t\t\t\tif(a%x == 0) continue;\n\t\t\t\t\n\t\t\t\tlong pow = mod(a, d, x);\n\t\t\t\tif(pow == 1) continue;\n\t\t\t\tif(pow == x - 1) continue;\n\t\t\t\t\n\t\t\t\tboolean con2 = false;\n\t\t\t\tfor(int r=1; r<s; r++){\n\t\t\t\t\tpow = mod(pow, 2, x);\n\t\t\t\t\t//pow = mod(a, (long)(d * Math.pow(2.0, r)), x);\n\t\t\t\t\tif(pow ==  x - 1){\n\t\t\t\t\t\tcon2 = true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif(!con2){\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\treturn true;\n\t\t}\n\t}\n\t\n\tpublic long mod(long a, long d, long n){\n\t\tif(a==0 || n==0) return 0;\n\t\tif(d==0) return 1 % n;\n\t\t\n\t\tlong currentMod = a % n;\n\t\tlong currentValue = (d%2 == 1) ? currentMod : 1;\n\t\t\n\t\tfor(d>>=1; d>0; d>>=1){\n\t\t\tcurrentMod = (currentMod * currentMod) % n;\n\t\t\tif(d%2 == 1){\n\t\t\t\tcurrentValue = (currentValue * currentMod) % n;\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn currentValue;\n\t\t\n\t}\n}", "sampled": "import java.util.*;\nimport java.io.*;\n\npublic class Main {\n    static final int MP = 999983;\n    static boolean[] isPrime;\n    static int[] primeCount;\n    \n    static void sieve() {\n        isPrime = new boolean[MP + 1];\n        Arrays.fill(isPrime, true);\n        isPrime[0] = isPrime[1] = false;\n        \n        for (int i = 2; i * i <= MP; i++) {\n            if (isPrime[i]) {\n                for (int j = i * i; j <= MP; j += i) {\n                    isPrime[j] = false;\n                }\n            }\n        }\n        \n        primeCount = new int[MP + 1];\n        int count = 0;\n        for (int i = 0; i <= MP; i++) {\n            if (isPrime[i]) count++;\n            primeCount[i] = count;\n        }\n    }\n    \n    static int countPrimes(int p, int m) {\n        int left = Math.max(0, p - m);\n        int right = Math.min(MP, p + m);\n        \n        int count = primeCount[right];\n        if (left > 0) {\n            count -= primeCount[left - 1];\n        }\n        \n        return count;\n    }\n    \n    public static void main(String[] args) throws IOException {\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        PrintWriter pw = new PrintWriter(System.out);\n        \n        sieve();\n        \n        String line;\n        while ((line = br.readLine()) != null) {\n            int n = Integer.parseInt(line.trim());\n            if (n == 0) break;\n            \n            long totalRequest = 0;\n            \n            for (int i = 0; i < n; i++) {\n                String[] parts = br.readLine().trim().split(\"\\\\s+\");\n                int p = Integer.parseInt(parts[0]);\n                int m = Integer.parseInt(parts[1]);\n                \n                int x = countPrimes(p, m);\n                \n                if (x == 0) {\n                    totalRequest -= 1;\n                } else {\n                    totalRequest += (x - 1);\n                }\n            }\n            \n            totalRequest = Math.max(0, totalRequest);\n            pw.println(totalRequest);\n        }\n        \n        pw.flush();\n        pw.close();\n    }\n}\n", "perturbed_sampled": [" final  primeCount; static   = i * i; j <= MP; j  + 1]; int count = 0; for (int i = 0; i  count; } } static int countPrimes(int p, int m) { int left  int right = Math.min(MP, p + m); int count = primeCount[right]; if (left  primeCount[left - 1]; } return count; } public static void main(String[] args) throws IOException   if (n == 0) break;  (int i = 0;  String[]  = Integer.parseInt(parts[0]);  x = countPrimes(p,  { totalRequest   } } totalRequest =  pw.close(); } }"], "perturbed_original": ["import java.io.*;  } long[] m = new long[]{ 2, 7, 61 }; public Main() throws IOException{  new ArrayList<Integer>(); String line;  while((line = in.readLine()) != null){ int   n=0; n<size; n++){  = line.split(\" \"); int  = Integer.parseInt(dst[1]); int count  i<=Math.min(center+range, 999983); i++){ if(prime[i]==0){  } else{ prime[i]  count++; } } } pay += count - 1; } Ans.add(Math.max(0,  public boolean isPrime(long x){  false; }  long d  == 0){ d = d  i=0; i<3; i++){ long a = m[i]; if(a%x ==  == 1) continue; if(pow == x -  false; for(int r=1; r<s; r++){ pow = mod(pow, 2, x); //pow  = true; break;  }  public   return 0;  %   n;  }"], "original_ll": -0.9746206998825073, "sampled_ll": -0.5108595490455627, "all_perturbed_sampled_ll": [-2.84774112701416], "all_perturbed_original_ll": [-3.1873888969421387], "perturbed_sampled_ll": -2.84774112701416, "perturbed_original_ll": -3.1873888969421387, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import math\nN=1000000\nprime=[1]*(N+1)\nprime[0]=0\nprime[1]=0\nfor i in range(2,int(math.sqrt(N))):\n    if prime[i]==1:\n        j=i\n        while i*j<=N:\n            prime[i*j]=0\n            j+=1\nprime=[i for i in range(N+1) if prime[i]==1]\n\nwhile True:\n    n=input()\n    if n==0:break\n    cnt=0\n    for i in range(n):\n        p,m=map(int,raw_input().split())\n        for j in range(len(prime)):\n            if p-m<=prime[j]<=p+m:\n                cnt+=1\n            if p+m<=prime[j]:\n                break\n    print cnt-n", "sampled": "def sieve_of_eratosthenes(limit):\n    is_prime = [True] * (limit + 1)\n    is_prime[0] = is_prime[1] = False\n    \n    for i in range(2, int(limit**0.5) + 1):\n        if is_prime[i]:\n            for j in range(i*i, limit + 1, i):\n                is_prime[j] = False\n    \n    primes = [i for i in range(limit + 1) if is_prime[i]]\n    return primes, is_prime\n\nMP = 999983\nprimes, is_prime = sieve_of_eratosthenes(MP)\n\ndef binary_search_left(arr, target):\n    left, right = 0, len(arr)\n    while left < right:\n        mid = (left + right) // 2\n        if arr[mid] < target:\n            left = mid + 1\n        else:\n            right = mid\n    return left\n\ndef binary_search_right(arr, target):\n    left, right = 0, len(arr)\n    while left < right:\n        mid = (left + right) // 2\n        if arr[mid] <= target:\n            left = mid + 1\n        else:\n            right = mid\n    return left\n\ndef count_primes_in_range(low, high):\n    left_idx = binary_search_left(primes, low)\n    right_idx = binary_search_right(primes, high)\n    return right_idx - left_idx\n\nwhile True:\n    n = int(input())\n    if n == 0:\n        break\n    \n    total_cost = 0\n    for _ in range(n):\n        p, m = map(int, input().split())\n        low = max(0, p - m)\n        high = min(MP, p + m)\n        \n        X = count_primes_in_range(low, high)\n        \n        if X > 0:\n            total_cost += X - 1\n        else:\n            total_cost -= 1\n    \n    total_cost = max(0, total_cost)\n    print(total_cost)\n", "perturbed_sampled": [":<extra_id_10>int ( input ( )<extra_id_11>if<extra_id_12>p , p + m<extra_id_13>p ) =<extra_id_14>- len(\\$))*P<extra_id_15>0.5 p) print(p + 1<extra_id_16>print(p_t) print(p_t)) if<extra_id_17>is_prime[p)] = 1<extra_id_18>+<extra_id_19>+<extra_id_20>= X<extra_id_21> is_prime[0] = is_prime[1]  range(2, int(limit**0.5) + 1): if is_prime[i]: for j in    target):  mid = (left + right)  target: left   right = 0,  mid = (left   right = mid return left def count_primes_in_range(low, high): left_idx  binary_search_right(primes, high) return right_idx - left_idx while True: n = int(input()) if  = 0 for _ in  p  p + m) X = count_primes_in_range(low,  total_cost += X - 1  = max(0, total_cost) print(total_cost)"], "perturbed_original": ["import math N=1000000 prime=[1]*(N+1) prime[0]=0 prime[1]=0 for i in range(2,int(math.sqrt(N))): if prime[i]==1:  prime=[i for i   for i in  cnt-n"], "original_ll": -1.0373896360397339, "sampled_ll": -0.5129606127738953, "all_perturbed_sampled_ll": [-2.9224281311035156], "all_perturbed_original_ll": [-2.4410243034362793], "perturbed_sampled_ll": -2.9224281311035156, "perturbed_original_ll": -2.4410243034362793, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "#include <stdio.h>\nint main(void) {\n  int n, data[100], j, tmp, i, count;\n  while(scanf(\"%d\",&n),n) {\n    count = 0;\n    for(i = 0; i < n; i++ ) {\n      scanf(\"%d\",&data[i]);\n    }\n    for(i = 0; i < n - 1; i++ ) {\n      for(j = 1; j < n - i; j++ ) {\n\tif(data[j] < data[j-1]) {\n\t  tmp = data[j];\n\t  data[j] = data[j-1];\n\t  data[j-1] = tmp;\n\t  count++;\n\t}\n      }\n    }\n    printf(\"%d\\n\",count);\n  }\n  return 0;\n}", "sampled": "#include <stdio.h>\n\nint main() {\n    int n;\n    \n    while(1) {\n        scanf(\"%d\", &n);\n        if(n == 0) break;\n        \n        int arr[100];\n        for(int i = 0; i < n; i++) {\n            scanf(\"%d\", &arr[i]);\n        }\n        \n        int swaps = 0;\n        for(int i = 0; i < n - 1; i++) {\n            for(int j = 0; j < n - 1 - i; j++) {\n                if(arr[j] > arr[j + 1]) {\n                    int temp = arr[j];\n                    arr[j] = arr[j + 1];\n                    arr[j + 1] = temp;\n                    swaps++;\n                }\n            }\n        }\n        \n        printf(\"%d\\n\", swaps);\n    }\n    \n    return 0;\n}\n", "perturbed_sampled": ["#include <stdio.h> int main() { int n;   i   0;  i++) { for(int j = 0; j < n  { if(arr[j]  arr[j]  swaps++; } } } printf(\"%d\\n\", swaps); } return 0; }"], "perturbed_original": ["#include <stdio.h>  count; while(scanf(\"%d\",&n),n)   i++ ) { scanf(\"%d\",&data[i]); } for(i = 0; i < n - 1; i++  j < n -    return 0; }"], "original_ll": -0.7557990550994873, "sampled_ll": -0.3426540493965149, "all_perturbed_sampled_ll": [-2.2454614639282227], "all_perturbed_original_ll": [-2.804921865463257], "perturbed_sampled_ll": -2.2454614639282227, "perturbed_original_ll": -2.804921865463257, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import java.util.*;\n\npublic class Main{\n\tScanner sc = new Scanner(System.in);\n\t\n\tprivate void doit(){\n\t\twhile(true){\n\t\t\tint n = sc.nextInt();\n\t\t\tif(n == 0) break;\n\t\t\tint [] data = new int[n];\n\t\t\tfor(int i = 0; i  <n; i++){\n\t\t\t\tdata[i] = sc.nextInt();\n\t\t\t}\n\t\t\tint count = 0;\n\t\t\tfor(;;){\n\t\t\t\tboolean flg = false;\n\t\t\t\tfor(int j = 0; j < n-1; j++){\n\t\t\t\t\tif(data[j] > data[j + 1]){\n\t\t\t\t\t\tint temp = data[j];\n\t\t\t\t\t\tdata[j] = data[j+1];\n\t\t\t\t\t\tdata[j+1] = temp;\n\t\t\t\t\t\tcount++;\n\t\t\t\t\t\tflg = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(! flg){\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(count);\n\t\t}\n\t}\n\n\tprivate void debug(Object... o) { System.out.println(\"debug = \" + Arrays.deepToString(o)); }\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().doit();\n\t}\n}", "sampled": "import java.util.Scanner;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        \n        while (true) {\n            int n = sc.nextInt();\n            if (n == 0) break;\n            \n            int[] arr = new int[n];\n            for (int i = 0; i < n; i++) {\n                arr[i] = sc.nextInt();\n            }\n            \n            int swapCount = bubbleSort(arr, n);\n            System.out.println(swapCount);\n        }\n        \n        sc.close();\n    }\n    \n    static int bubbleSort(int[] arr, int n) {\n        int count = 0;\n        for (int i = 0; i < n - 1; i++) {\n            for (int j = 0; j < n - 1 - i; j++) {\n                if (arr[j] > arr[j + 1]) {\n                    int temp = arr[j];\n                    arr[j] = arr[j + 1];\n                    arr[j + 1] = temp;\n                    count++;\n                }\n            }\n        }\n        return count;\n    }\n}\n", "perturbed_sampled": ["import java.util.Scanner; public class Main { public static void  (true) { int n =  break;  for  <  = bubbleSort(arr, n); System.out.println(swapCount);  bubbleSort(int[] arr,  i++) { for  < n - 1 -  arr[j]; arr[j] =  1] = temp; count++; } } } return count; } }"], "perturbed_original": ["import java.util.*; public class Main{ Scanner    = new int[n];   } int count = 0; for(;;){ boolean flg  j++){ if(data[j] > data[j + 1]){ int temp =  = true; } } if(! flg){ break; } } System.out.println(count); }  { new Main().doit(); } }"], "original_ll": -0.8794525265693665, "sampled_ll": -0.28202080726623535, "all_perturbed_sampled_ll": [-2.9978344440460205], "all_perturbed_original_ll": [-3.0109703540802], "perturbed_sampled_ll": -2.9978344440460205, "perturbed_original_ll": -3.0109703540802, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "while True:\n    n = int(input())\n    if n == 0:\n        break\n    Num_lis = []\n    cou = 0\n    for i in range(n):\n        Num_lis.append(int(input()))\n    S_lis = sorted(Num_lis)\n    while Num_lis != S_lis:\n        \n        for j in range(n - 1):\n            if Num_lis[j] > Num_lis[j + 1]:\n                Num_lis[j],Num_lis[j + 1] = Num_lis[j + 1],Num_lis[j]\n                cou += 1\n    print(cou)", "sampled": "while True:\n    n = int(input())\n    if n == 0:\n        break\n    \n    arr = []\n    for _ in range(n):\n        arr.append(int(input()))\n    \n    count = 0\n    for i in range(n - 1):\n        for j in range(n - 1 - i):\n            if arr[j] > arr[j + 1]:\n                arr[j], arr[j + 1] = arr[j + 1], arr[j]\n                count += 1\n    \n    print(count)\n", "perturbed_sampled": [" for _ in range(n): arr.append(int(input())) count = 0 for i    arr[j + 1] = arr[j + 1], arr[j] count += 1 print(count)"], "perturbed_original": [" if n == 0:  = 0 for  = sorted(Num_lis)  j in  Num_lis[j + 1],Num_lis[j] cou += 1 print(cou)"], "original_ll": -0.8521052002906799, "sampled_ll": -0.4930432140827179, "all_perturbed_sampled_ll": [-2.318682909011841], "all_perturbed_original_ll": [-3.544572591781616], "perturbed_sampled_ll": -2.318682909011841, "perturbed_original_ll": -3.544572591781616, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "#include <stdio.h>\n\nint main(){\n  int n, p[31] = {}, i, res;\n  p[0] = 1;\n  p[1] = 1;\n  p[2] = 2;\n\n\n  while(scanf(\"%d\", &n) && n){\n    for(i = 3; i <= n; i++) p[i] = p[i - 1] + p[i - 2] + p[i - 3];\n    res = p[n] / 10 / 365 + 1;\n    printf(\"%d\\n\", res);\n  }\n  return 0;\n}", "sampled": "#include <stdio.h>\n\nint main() {\n    int n;\n    long long dp[31];\n    \n    // Calculate number of ways to climb stairs for each n\n    dp[0] = 1;\n    dp[1] = 1;\n    dp[2] = 2;\n    \n    for (int i = 3; i <= 30; i++) {\n        dp[i] = dp[i-1] + dp[i-2] + dp[i-3];\n    }\n    \n    while (scanf(\"%d\", &n) == 1 && n != 0) {\n        long long ways = dp[n];\n        long long days = (ways + 9) / 10;  // Round up division\n        long long years = (days + 364) / 365;  // Round up division\n        printf(\"%lld\\n\", years);\n    }\n    \n    return 0;\n}\n", "perturbed_sampled": ["#include <stdio.h> int main() { int  Calculate number of ways to  = 1; dp[2]  = dp[i-1] +  = dp[n]; long long days = (ways + 9) / 10; // Round  = (days +  } return 0; }"], "perturbed_original": ["#include <stdio.h> int main(){ int n, p[31]    3;  +  p[n] / 10 / 365 + 1; printf(\"%d\\n\", res); } return 0; }"], "original_ll": -0.9883154034614563, "sampled_ll": -0.798247218132019, "all_perturbed_sampled_ll": [-3.061678886413574], "all_perturbed_original_ll": [-2.851710081100464], "perturbed_sampled_ll": -3.061678886413574, "perturbed_original_ll": -2.851710081100464, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import java.util.*;class Main{public static void main(String[]z){Scanner s=new Scanner(System.in);for(int n,i,j,a[];(n=s.nextInt())>0;System.out.println(a[n]/3650+1))for(a=new int[n+3],a[1]=a[2]=a[3]=1,i=0;i<n;++i)for(j=4;j-->1;)a[i+j]+=a[i];}}", "sampled": "import java.util.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        \n        long[] ways = new long[31];\n        ways[0] = 1;\n        \n        for (int i = 1; i <= 30; i++) {\n            ways[i] = 0;\n            if (i >= 1) ways[i] += ways[i-1];\n            if (i >= 2) ways[i] += ways[i-2];\n            if (i >= 3) ways[i] += ways[i-3];\n        }\n        \n        while (true) {\n            int n = sc.nextInt();\n            if (n == 0) break;\n            \n            long totalWays = ways[n];\n            long days = (totalWays + 9) / 10;\n            long years = (days + 364) / 365;\n            \n            System.out.println(years);\n        }\n        \n        sc.close();\n    }\n}\n", "perturbed_sampled": ["import java.util.*; public class Main { public static void main(String[]  new Scanner(System.in); long[] ways = new  i <= 30; i++) { ways[i]  ways[i] += ways[i-2]; if (i >=  n  0) break;  364) / 365; System.out.println(years); } sc.close(); } }"], "perturbed_original": [" main(String[]z){Scanner s=new Scanner(System.in);for(int n,i,j,a[];(n=s.nextInt())>0;System.out.println(a[n]/3650+1))for(a=new int[n+3],a[1]=a[2]=a[3]=1,i=0;i<n;++i)for(j=4;j-->1;)a[i+j]+=a[i];}}"], "original_ll": -2.00246524810791, "sampled_ll": -0.5796345472335815, "all_perturbed_sampled_ll": [-2.971623420715332], "all_perturbed_original_ll": [-2.3258168697357178], "perturbed_sampled_ll": -2.971623420715332, "perturbed_original_ll": -2.3258168697357178, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "a = []\na[:4] = [0, 1, 2, 3]\ninList = []\nwhile True:\n    price = int(input())\n    if price == 0:\n        break\n    inList.append(int(input()))\nn = max(inList)\nfor i in range(4, n + 1):\n    a[i] = a[i-1] + a[i-2] + a[i-3]\nfor i in inList:\n    print((a[i] // 3650) + (a[i] % 3650 != 0))", "sampled": "import sys\n\ndef count_ways(n):\n    if n == 0:\n        return 1\n    if n < 0:\n        return 0\n    \n    dp = [0] * (n + 1)\n    dp[0] = 1\n    \n    for i in range(1, n + 1):\n        dp[i] = dp[i-1]\n        if i >= 2:\n            dp[i] += dp[i-2]\n        if i >= 3:\n            dp[i] += dp[i-3]\n    \n    return dp[n]\n\ndef calculate_years(n):\n    ways = count_ways(n)\n    days = (ways + 9) // 10\n    years = (days + 364) // 365\n    return years\n\nfor line in sys.stdin:\n    n = int(line.strip())\n    if n == 0:\n        break\n    print(calculate_years(n))\n", "perturbed_sampled": ["import sys def count_ways(n): if n == 0: return 1 if n < 0:  * (n + 1) dp[0] = 1 for   i >= 2: dp[i] +=   years for  int(line.strip())  print(calculate_years(n))"], "perturbed_original": [" inList = [] while True: price = int(input()) if price ==  max(inList) for i in range(4, n  + a[i-2]   0))"], "original_ll": -1.2358615398406982, "sampled_ll": -0.5710834264755249, "all_perturbed_sampled_ll": [-3.0175397396087646], "all_perturbed_original_ll": [-4.077245712280273], "perturbed_sampled_ll": -3.0175397396087646, "perturbed_original_ll": -4.077245712280273, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "#include<stdio.h>\n#include<stdlib.h>\n#include<string.h>\nint main(){\n  int i;\n  int c[128],m,n;\n  char s[256],*t;  \n  for(;;){\n    fgets(s,256,stdin);\n    s[strlen(s)-1]='\\0';\n    t=strtok(s,\" \");\n    c[0]=atoi(t)<10?atoi(t):10;\n    if(c[0]==0)\n      break;\n    for(n=1;(t=strtok(NULL,\" \"))!=NULL;n++)\n      c[n]=atoi(t)<10?atoi(t):10;\n    m=0;\n    for(i=0;i<n;i++)\n      m+=c[i];\n    for(i=0;i<n;i++){\n      if(m<12&&c[i]==1)\n\tm+=10;\n    }\n    if(m>21)\n      m=0;\n    printf(\"%d\\n\",m);\n  }\n  return 0;\n}", "sampled": "#include <stdio.h>\n\nint main() {\n    int card;\n    \n    while (1) {\n        scanf(\"%d\", &card);\n        if (card == 0) break;\n        \n        int sum = 0;\n        int aces = 0;\n        \n        do {\n            if (card == 1) {\n                sum += 1;\n                aces++;\n            } else if (card >= 2 && card <= 9) {\n                sum += card;\n            } else if (card >= 10 && card <= 13) {\n                sum += 10;\n            }\n            \n            int c = getchar();\n            if (c == '\\n' || c == EOF) break;\n            scanf(\"%d\", &card);\n        } while (1);\n        \n        // Try to maximize score by using 11 for aces\n        while (aces > 0 && sum + 10 <= 21) {\n            sum += 10;\n            aces--;\n        }\n        \n        if (sum > 21) {\n            sum = 0;\n        }\n        \n        printf(\"%d\\n\", sum);\n    }\n    \n    return 0;\n}\n", "perturbed_sampled": [" int card; while  else if (card >= 2 && card <=    } while (1); // Try  11 for aces while (aces > 0 && sum + 10 <= 21) { sum += 10; aces--; } if (sum > 21) { sum = 0; } printf(\"%d\\n\", sum); } return 0; }"], "perturbed_original": ["#include<stdio.h> #include<stdlib.h>   c[0]=atoi(t)<10?atoi(t):10; if(c[0]==0) break; for(n=1;(t=strtok(NULL,\" \"))!=NULL;n++) c[n]=atoi(t)<10?atoi(t):10;  printf(\"%d\\n\",m); } return 0; }"], "original_ll": -1.152605652809143, "sampled_ll": -0.7723479866981506, "all_perturbed_sampled_ll": [-2.215766668319702], "all_perturbed_original_ll": [-2.0912747383117676], "perturbed_sampled_ll": -2.215766668319702, "perturbed_original_ll": -2.0912747383117676, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import java.util.Scanner;\n\npublic class Main {\n\tstatic Scanner sc = new Scanner(System.in);\n\n\tpublic static void main(String[] args) {\n\t\twhile(sc.hasNext()) {\n\t\t\tString[] text = sc.nextLine().split(\" \");\n\t\t\tint[] cards = new int[text.length];\n\t\t\tboolean one = false; //1????????????\n\t\t\tint sum = 0; //????\u00a8??????\u00b0\n\t\t\tboolean flag = false;\n\n\t\t\tfor(int $ = 0; $ < text.length; $++) {\n\t\t\t\tcards[$] = Integer.parseInt(text[$]);\n\t\t\t\tif(cards[0] == 0) {\n\t\t\t\t\tflag = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif(cards[$] == 1) {\n\t\t\t\t\tone = true;\n\t\t\t\t\tsum++;\n\t\t\t\t} else if(cards[$] >= 10 && cards[$] <=13) {\n\t\t\t\t\tsum += 10;\n\t\t\t\t} else {\n\t\t\t\t\tsum += cards[$];\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif(flag) {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif(one) {\n\t\t\t\tif(sum + 10 <= 21) {\n\t\t\t\t\tsum += 10;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif(sum > 21) {\n\t\t\t\tsum = 0;\n\t\t\t}\n\n\t\t\tSystem.out.println(sum);\n\n\t\t}\n\n\t}\n\n}", "sampled": "import java.util.Scanner;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        \n        while (true) {\n            String line = sc.nextLine().trim();\n            if (line.equals(\"0\")) {\n                break;\n            }\n            \n            String[] tokens = line.split(\"\\\\s+\");\n            int[] cards = new int[tokens.length];\n            for (int i = 0; i < tokens.length; i++) {\n                cards[i] = Integer.parseInt(tokens[i]);\n            }\n            \n            int result = calculateScore(cards);\n            System.out.println(result);\n        }\n        \n        sc.close();\n    }\n    \n    private static int calculateScore(int[] cards) {\n        int baseSum = 0;\n        int aceCount = 0;\n        \n        for (int card : cards) {\n            if (card == 1) {\n                aceCount++;\n                baseSum += 1;\n            } else if (card >= 10) {\n                baseSum += 10;\n            } else {\n                baseSum += card;\n            }\n        }\n        \n        // Try to maximize the score by using aces as 11\n        int maxScore = baseSum;\n        for (int i = 0; i <= aceCount; i++) {\n            int score = baseSum + i * 10; // Each ace used as 11 adds 10 more (since base is 1)\n            if (score <= 21) {\n                maxScore = Math.max(maxScore, score);\n            }\n        }\n        \n        if (maxScore > 21) {\n            return 0;\n        }\n        \n        return maxScore;\n    }\n}\n", "perturbed_sampled": ["import java.util.Scanner;  {  while  (int i = 0; i < tokens.length; i++) { cards[i] = Integer.parseInt(tokens[i]); } int  int calculateScore(int[]  0; int aceCount = 0; for (int card  ==   >=  } else { baseSum += card; } } // Try  using aces as 11  (int   ace used  (since base is 1) if (score  Math.max(maxScore,  > 21) { return 0; } return maxScore; } }"], "perturbed_original": [" { static Scanner sc =  main(String[] args) { while(sc.hasNext())   = 0; //????\u00a8??????\u00b0 boolean  = 0; $ < text.length; $++) { cards[$] =  flag = true; break; }  = true; sum++; }  cards[$] <=13) {  } } if(flag) { break; } if(one) {   }"], "original_ll": -0.9448589086532593, "sampled_ll": -0.6871176362037659, "all_perturbed_sampled_ll": [-3.18815279006958], "all_perturbed_original_ll": [-3.887103796005249], "perturbed_sampled_ll": -3.18815279006958, "perturbed_original_ll": -3.887103796005249, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "while True:\n    h = map(int, raw_input().split())\n    if h[0] == 0:\n        break\n    t = 0\n    a = 0\n    for c in sorted(h, reverse=True):\n        if 2 <= c <= 9:\n            t += c\n        elif 10 <= c:\n            t += 10\n        elif c == 1:\n            a += 1\n            \n    t += a\n    if 21 < t:\n        print 0\n    else:\n        for i in range(a):\n            if 21 < t + 10:\n                print t\n                break\n            else:\n                t += 10\n        else:\n            print t", "sampled": "import sys\n\ndef calculate_hand_value(cards):\n    # Convert card values\n    converted = []\n    ace_count = 0\n    \n    for card in cards:\n        if card == 1:\n            ace_count += 1\n            converted.append(1)\n        elif card >= 10:\n            converted.append(10)\n        else:\n            converted.append(card)\n    \n    # Calculate base sum (all aces as 1)\n    base_sum = sum(converted)\n    \n    # Try to maximize by converting aces from 1 to 11\n    max_value = base_sum\n    \n    # We can convert at most one ace from 1 to 11 (adding 10 to the sum)\n    # because converting more than one would add 20+ which would likely bust\n    for i in range(ace_count + 1):\n        # i is the number of aces we treat as 11\n        current_sum = base_sum + (i * 10)\n        if current_sum <= 21:\n            max_value = max(max_value, current_sum)\n    \n    if max_value > 21:\n        return 0\n    return max_value\n\nfor line in sys.stdin:\n    line = line.strip()\n    if line == '0':\n        break\n    \n    cards = list(map(int, line.split()))\n    result = calculate_hand_value(cards)\n    print(result)\n", "perturbed_sampled": ["  for card   elif card >= 10: converted.append(10) else: converted.append(card) # Calculate  1) base_sum =  to 11 (adding 10 to the sum) # because converting more than  1): # i is the   + (i * 10) if current_sum <= 21: max_value = max(max_value, current_sum) if max_value  sys.stdin: line = line.strip() if line ==  line.split())) result = calculate_hand_value(cards) print(result)"], "perturbed_original": ["while True: h =  0 a = 0 for c in sorted(h, reverse=True): if  == 1: a +=  21 < t: print 0 else: for i in range(a): if  print t"], "original_ll": -1.105502963066101, "sampled_ll": -1.208677887916565, "all_perturbed_sampled_ll": [-3.452183246612549], "all_perturbed_original_ll": [-3.10298228263855], "perturbed_sampled_ll": -3.452183246612549, "perturbed_original_ll": -3.10298228263855, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "#include<stdio.h>\n#include<string.h>\ntypedef struct i{char f[21];int s,w;} i;\ni g[10];\nint n,t[10],f[10]={0},ans[10],max=0;\n\nvoid rec(int d)\n{\n\tint i,w=0,G=0;\n\tif(d==n)\n\t{\n\t\tfor(i=0;i<n;i++)\n\t\t{\n\t\t\tif(w>g[t[i]].s)\n\t\t\t\treturn;\n\t\t\tw+=g[t[i]].w;\n\t\t\tG+=g[t[i]].w*(i+1);\n\t\t}\n\t\tif(max<G)\n\t\t{\n\t\t\tmax=G;\n\t\t\tmemcpy(ans,t,sizeof(t));\n\t\t}\n\t}\n\telse\n\t{\n\t\tfor(i=0;i<n;i++)\n\t\t{\n\t\t\tif(!f[i])\n\t\t\t{\n\t\t\t\tf[i]=1;\n\t\t\t\tt[d]=i;\n\t\t\t\trec(d+1);\n\t\t\t\tf[i]=0;\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main()\n{\n\tint i;\n\tfor(;;)\n\t{\n\t\tscanf(\"%d\",&n);\n\t\tif(!n)\n\t\t\treturn 0;\n\t\tfor(i=0;i<n;i++)\n\t\t\tscanf(\"%s %d%d\",g[i].f,&g[i].w,&g[i].s);\n\t\trec(0);\n\t\twhile(--n>=0)\n\t\t\tputs(g[ans[n]].f);\n\t}\n\treturn 0;\n}", "sampled": "#include <stdio.h>\n#include <string.h>\n\ntypedef struct {\n    char name[25];\n    int weight;\n    int strength;\n    int index;\n} Food;\n\nint n;\nFood foods[10];\nFood current[10];\nFood best[10];\nint visited[10];\ndouble best_center;\n\nint check_valid() {\n    for (int i = 0; i < n; i++) {\n        int weight_above = 0;\n        for (int j = i + 1; j < n; j++) {\n            weight_above += current[j].weight;\n        }\n        if (current[i].strength < weight_above) {\n            return 0;\n        }\n    }\n    return 1;\n}\n\ndouble calculate_center() {\n    int numerator = 0;\n    int denominator = 0;\n    for (int i = 0; i < n; i++) {\n        numerator += (i + 1) * current[i].weight;\n        denominator += current[i].weight;\n    }\n    return (double)numerator / denominator;\n}\n\nvoid solve(int depth) {\n    if (depth == n) {\n        if (check_valid()) {\n            double center = calculate_center();\n            if (center < best_center) {\n                best_center = center;\n                for (int i = 0; i < n; i++) {\n                    best[i] = current[i];\n                }\n            }\n        }\n        return;\n    }\n    \n    for (int i = 0; i < n; i++) {\n        if (!visited[i]) {\n            visited[i] = 1;\n            current[depth] = foods[i];\n            solve(depth + 1);\n            visited[i] = 0;\n        }\n    }\n}\n\nint main() {\n    while (1) {\n        scanf(\"%d\", &n);\n        if (n == 0) break;\n        \n        for (int i = 0; i < n; i++) {\n            scanf(\"%s %d %d\", foods[i].name, &foods[i].weight, &foods[i].strength);\n            foods[i].index = i;\n        }\n        \n        best_center = 1e9;\n        memset(visited, 0, sizeof(visited));\n        \n        solve(0);\n        \n        for (int i = 0; i < n; i++) {\n            printf(\"%s\\n\", best[i].name);\n        }\n    }\n    \n    return 0;\n}\n", "perturbed_sampled": ["#include  n; Food foods[10]; Food current[10]; Food best[10]; int visited[10]; double best_center; int check_valid() { for (int i    weight_above += current[j].weight; }  return 0; } }  { int numerator =  0; i < n; i++) { numerator +=  return (double)numerator / denominator; } void solve(int depth) { if (depth   for (int i = 0; i < n; i++) { best[i] =  = 0;   solve(depth + 1);  while  (n == 0) break;  i < n; i++)  i; } best_center  = 0; i <  } } return 0; }"], "perturbed_original": ["<extra_id_1>if(n>8<extra_id_2>} }<extra_id_3>i+++(n/8)*(2),2); if(i<21)<extra_id_4>.1; s_n =<extra_id_5>int n _n; i++){<extra_id_6>i.0; } } */ if<extra_id_7>c&&t[d]>=11){<extra_id_8>[d]-&t[d];<extra_id_9>i++) f[21];int s,w;} i;   } if(max<G) { max=G; memcpy(ans,t,sizeof(t)); } } else  f[i]=1; t[d]=i; rec(d+1); f[i]=0; } }  int i; for(;;) { scanf(\"%d\",&n); if(!n)  return 0; }"], "original_ll": -1.005781888961792, "sampled_ll": -0.5256456732749939, "all_perturbed_sampled_ll": [-2.725640058517456], "all_perturbed_original_ll": [-3.283463954925537], "perturbed_sampled_ll": -2.725640058517456, "perturbed_original_ll": -3.283463954925537, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.Scanner;\n\nclass Food {\n\tString name;\n\tint w;\n\tint s;\n\n\tpublic Food(String name, int w, int s) {\n\t\tthis.name = name;\n\t\tthis.w = w;\n\t\tthis.s = s;\n\t}\n\n}\n\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n\n\tpublic void run() {\n\t\tScanner scanner = new Scanner(System.in);\n\t\twhile (true) {\n\t\t\tint n = scanner.nextInt();\n\t\t\tint max = 0;\n\t\t\tList<Food> list = new ArrayList<Food>();\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tString l = scanner.next();\n\t\t\t\tint a = scanner.nextInt();\n\t\t\t\tint b = scanner.nextInt();\n\t\t\t\tlist.add(new Food(l, a, b));\n\t\t\t\tmax += a;\n\t\t\t}\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tint l = 0;\n\t\t\t\tint k = 0;\n\t\t\t\tfor (int j = 0; j < list.size(); j++) {\n\t\t\t\t\tint m = max - list.get(j).w;\n\t\t\t\t\tint ss = list.get(j).s;\n\t\t\t\t\tif (m <= ss) {\n\t\t\t\t\t\tif (list.get(j).w > k) {\n\t\t\t\t\t\t\tk = list.get(j).w;\n\t\t\t\t\t\t\tl = j;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tmax -= list.get(l).w;\n\t\t\t\tSystem.out.println(list.get(l).name);\n\t\t\t\tlist.get(l).s = -10;\n\t\t\t\tlist.get(l).w = 0;\n\t\t\t}\n\t\t}\n\t}\n\n}", "sampled": "import java.util.*;\n\npublic class Main {\n    static class Food {\n        String name;\n        int weight;\n        int strength;\n        \n        Food(String name, int weight, int strength) {\n            this.name = name;\n            this.weight = weight;\n            this.strength = strength;\n        }\n    }\n    \n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        \n        while (true) {\n            int n = sc.nextInt();\n            if (n == 0) break;\n            \n            Food[] foods = new Food[n];\n            for (int i = 0; i < n; i++) {\n                String name = sc.next();\n                int weight = sc.nextInt();\n                int strength = sc.nextInt();\n                foods[i] = new Food(name, weight, strength);\n            }\n            \n            int[] bestPerm = null;\n            double minG = Double.MAX_VALUE;\n            \n            int[] perm = new int[n];\n            for (int i = 0; i < n; i++) {\n                perm[i] = i;\n            }\n            \n            do {\n                if (isValid(foods, perm)) {\n                    double g = calculateG(foods, perm);\n                    if (g < minG) {\n                        minG = g;\n                        bestPerm = perm.clone();\n                    }\n                }\n            } while (nextPermutation(perm));\n            \n            for (int i = 0; i < n; i++) {\n                System.out.println(foods[bestPerm[i]].name);\n            }\n        }\n        \n        sc.close();\n    }\n    \n    static boolean isValid(Food[] foods, int[] perm) {\n        int n = perm.length;\n        for (int i = 0; i < n; i++) {\n            int weightAbove = 0;\n            for (int j = i + 1; j < n; j++) {\n                weightAbove += foods[perm[j]].weight;\n            }\n            if (foods[perm[i]].strength < weightAbove) {\n                return false;\n            }\n        }\n        return true;\n    }\n    \n    static double calculateG(Food[] foods, int[] perm) {\n        int n = perm.length;\n        double numerator = 0;\n        double denominator = 0;\n        for (int i = 0; i < n; i++) {\n            numerator += (i + 1) * foods[perm[i]].weight;\n            denominator += foods[perm[i]].weight;\n        }\n        return numerator / denominator;\n    }\n    \n    static boolean nextPermutation(int[] array) {\n        int i = array.length - 2;\n        while (i >= 0 && array[i] >= array[i + 1]) {\n            i--;\n        }\n        \n        if (i < 0) {\n            return false;\n        }\n        \n        int j = array.length - 1;\n        while (array[j] <= array[i]) {\n            j--;\n        }\n        \n        swap(array, i, j);\n        reverse(array, i + 1, array.length - 1);\n        return true;\n    }\n    \n    static void swap(int[] array, int i, int j) {\n        int temp = array[i];\n        array[i] = array[j];\n        array[j] = temp;\n    }\n    \n    static void reverse(int[] array, int start, int end) {\n        while (start < end) {\n            swap(array, start, end);\n            start++;\n            end--;\n        }\n    }\n}\n", "perturbed_sampled": ["import java.util.*; public class Main { static class  weight; int  int  this.weight   main(String[]  new Scanner(System.in); while (true) { int n  = new Food[n]; for  String name = sc.next(); int  = sc.nextInt(); foods[i]   int[] perm = new int[n]; for  perm[i] =  (isValid(foods, perm)) {  { minG = g;  } while (nextPermutation(perm)); for (int i  i++) { System.out.println(foods[bestPerm[i]].name); } } sc.close(); } static boolean isValid(Food[] foods,  = perm.length; for (int i = 0; i < n; i++) {   j++) {   { int n = perm.length; double numerator =  for (int  += (i + 1) *  return numerator / denominator; } static boolean nextPermutation(int[]  array.length - 2; while (i  array[i  - 1;  j--; } swap(array, i, j); reverse(array,  1); return  array, int i,    { swap(array,  } }"], "perturbed_original": ["import java.util.ArrayList; import java.util.List; import java.util.Scanner; class Food { String  public  s)  = w; this.s = s; } } public  void run() { Scanner  = new ArrayList<Food>();  { String  = scanner.nextInt(); int b  b)); max += a; } for (int i = 0;   ss  ss)  { k = list.get(j).w; l = j;  list.get(l).w; System.out.println(list.get(l).name); list.get(l).s = -10; list.get(l).w = 0; } } } }"], "original_ll": -0.6833577156066895, "sampled_ll": -0.346086323261261, "all_perturbed_sampled_ll": [-2.8666393756866455], "all_perturbed_original_ll": [-2.764566659927368], "perturbed_sampled_ll": -2.8666393756866455, "perturbed_original_ll": -2.764566659927368, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "# -*- coding: utf-8 -*-\n\"\"\"\nhttp://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=0170\n\n\"\"\"\nimport sys\nfrom sys import stdin\ninput = stdin.readline\nfrom collections import namedtuple\nfrom itertools import permutations\n\n\ndef solve(items):\n    total_weight = 0\n    for i in items:\n        total_weight += i.w\n\n    best_ans = []\n    best_gp = float('inf')\n    # ???????????????????????????????????????????????\u00b0?????????????????\u00a7????????????\n    for perm in permutations(items):\n        ans = []\n        squashed = False\n        cw = 0\n        gp = 0\n        n = len(items)\n\n        for p in perm:\n            if p.s < cw:\n                squashed = True\n                break\n            cw += p.w\n            ans.append(p.name)\n            gp += n * p.w\n            n -= 1\n        # ????????\u00b0???????????\u00a3?????\u00b4????????????????\u00a8???????????????????????????????????????\u00a3?????????????????\u00a7????????????\n        if not squashed:\n            gp /= total_weight\n            if gp < best_gp:\n                best_gp = gp\n                best_ans = ans[:]\n    # ????????????????????????????????\u00a3??????????????\u00a7?????????????\u00b1?????????????????????????????????????????????????\n    best_ans.reverse()\n    return best_ans\n\n\nitem = namedtuple('item', ['name', 'w', 's'])\ndef main(args):\n    while True:\n        n = int(input())\n        if n == 0:\n            break\n        items = []\n        for _ in range(n):\n            name, w, s = input().split()\n            items.append(item(name, int(w), int(s)))\n\n        result = solve(items)\n        print('\\n'.join(result))\n\n\nif __name__ == '__main__':\n    main(sys.argv[1:])", "sampled": "from itertools import permutations\n\ndef is_valid(order, items):\n    # Check if the order is valid (no food is crushed)\n    # order is a list of indices\n    for i in range(len(order)):\n        weight_above = sum(items[order[j]][1] for j in range(i + 1, len(order)))\n        if items[order[i]][2] < weight_above:\n            return False\n    return True\n\ndef calculate_center_of_gravity(order, items):\n    # Calculate center of gravity\n    # Lower is better\n    numerator = sum((i + 1) * items[order[i]][1] for i in range(len(order)))\n    denominator = sum(items[order[i]][1] for i in range(len(order)))\n    return numerator / denominator\n\nwhile True:\n    n = int(input())\n    if n == 0:\n        break\n    \n    items = []\n    for _ in range(n):\n        parts = input().split()\n        name = parts[0]\n        weight = int(parts[1])\n        strength = int(parts[2])\n        items.append((name, weight, strength))\n    \n    best_order = None\n    best_cog = float('inf')\n    \n    # Try all permutations\n    for perm in permutations(range(n)):\n        if is_valid(perm, items):\n            cog = calculate_center_of_gravity(perm, items)\n            if cog < best_cog:\n                best_cog = cog\n                best_order = perm\n    \n    # Output the result\n    for idx in best_order:\n        print(items[idx][0])\n", "perturbed_sampled": ["from itertools import  is  list  range(len(order)):   def calculate_center_of_gravity(order, items):  # Lower  for i in range(len(order))) denominator =  return numerator / denominator while True:  == 0: break  input().split() name = parts[0] weight = int(parts[1])  strength)) best_order  # Try all permutations for perm  best_cog = cog best_order = perm # Output the result for idx in best_order: print(items[idx][0])"], "perturbed_original": ["# -*-  \"\"\" import sys  = stdin.readline from collections import  def solve(items): total_weight =  =  ???????????????????????????????????????????????\u00b0?????????????????\u00a7???????????? for perm in permutations(items): ans = []  0 gp =  p.s < cw: squashed =  ans.append(p.name) gp   best_gp: best_gp =  ????????????????????????????????\u00a3??????????????\u00a7?????????????\u00b1????????????????????????????????????????????????? best_ans.reverse() return best_ans item = namedtuple('item', ['name', 'w', 's'])  =  break items  int(s)))  __name__ == '__main__': main(sys.argv[1:])"], "original_ll": -1.2382045984268188, "sampled_ll": -0.9374412298202515, "all_perturbed_sampled_ll": [-3.960696220397949], "all_perturbed_original_ll": [-3.387659788131714], "perturbed_sampled_ll": -3.960696220397949, "perturbed_original_ll": -3.387659788131714, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "#include<stdio.h>\n\nint main(void)\n{\n\tchar class[20];\n\tint i, am, pm;\n\t\n\tfor(i=0;i<9;i++)\n\t{\n\t\tscanf(\"%s %d %d\",class,&am,&pm);\n\t\tprintf(\"%s %d %d\\n\",class,am+pm,(200*am)+(300*pm));\n\t}\n\treturn 0;\n}", "sampled": "#include <stdio.h>\n\nint main() {\n    char name[16];\n    int morning, afternoon;\n    \n    for (int i = 0; i < 9; i++) {\n        scanf(\"%s %d %d\", name, &morning, &afternoon);\n        int total = morning + afternoon;\n        int revenue = morning * 200 + afternoon * 300;\n        printf(\"%s %d %d\\n\", name, total, revenue);\n    }\n    \n    return 0;\n}\n", "perturbed_sampled": [" char name[16]; int morning, afternoon; for (int i = 0; i <  + afternoon; int revenue = morning  name,  }"], "perturbed_original": ["#include<stdio.h>  %d\",class,&am,&pm); printf(\"%s %d %d\\n\",class,am+pm,(200*am)+(300*pm)); } return 0; }"], "original_ll": -1.5145469903945923, "sampled_ll": -1.0503125190734863, "all_perturbed_sampled_ll": [-4.202414035797119], "all_perturbed_original_ll": [-2.920313596725464], "perturbed_sampled_ll": -4.202414035797119, "perturbed_original_ll": -2.920313596725464, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "/**\n * @author yuichirw\n *\n */\nimport java.util.*;\n\npublic class Main {\n\n\tstatic Scanner sc = new Scanner(System.in);\n\t\n\tpublic static void main(String[] args) {\n\t\tint a,b,rel,sum;\n\t\tString c;\n\n\t\tfor(int i = 0; i < 9; i++) {\n\t\t\tc = sc.next(); a = sc.nextInt(); b = sc.nextInt();\n\t\t\tsum = a + b;\n\t\t\trel = a * 200 + b * 300;\n\t\t\tSystem.out.println(c + \" \" + sum + \" \" + rel);\n\t\t}\n\t}\n}", "sampled": "import java.util.Scanner;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        \n        for (int i = 0; i < 9; i++) {\n            String name = sc.next();\n            int morning = sc.nextInt();\n            int afternoon = sc.nextInt();\n            \n            int totalVisitors = morning + afternoon;\n            int totalRevenue = morning * 200 + afternoon * 300;\n            \n            System.out.println(name + \" \" + totalVisitors + \" \" + totalRevenue);\n        }\n        \n        sc.close();\n    }\n}\n", "perturbed_sampled": ["import java.util.Scanner; public class Main { public static void  (int i = 0; i   * 300; System.out.println(name + \" \" + totalVisitors + \" \" + totalRevenue); } sc.close(); } }"], "perturbed_original": [" */ import java.util.*;  Scanner sc  int a,b,rel,sum; String  a = sc.nextInt(); b  + b; rel =  * 300; System.out.println(c + \" \" + sum + \"  }"], "original_ll": -1.304550051689148, "sampled_ll": -0.6639609932899475, "all_perturbed_sampled_ll": [-2.7954814434051514], "all_perturbed_original_ll": [-3.7331247329711914], "perturbed_sampled_ll": -2.7954814434051514, "perturbed_original_ll": -3.7331247329711914, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "for i in range(9):\n    name,a,b=list(input().split())\n    print(name,int(a)+int(b),int(a)*200+int(b)*300)\n", "sampled": "for _ in range(9):\n    line = input().split()\n    name = line[0]\n    morning = int(line[1])\n    afternoon = int(line[2])\n    total = morning + afternoon\n    revenue = morning * 200 + afternoon * 300\n    print(name, total, revenue)\n", "perturbed_sampled": ["for _ in range(9):  line[0]  + afternoon revenue = morning *  print(name, total, revenue)"], "perturbed_original": ["for i in range(9): name,a,b=list(input().split()) print(name,int(a)+int(b),int(a)*200+int(b)*300)"], "original_ll": -2.2199015617370605, "sampled_ll": -1.1376500129699707, "all_perturbed_sampled_ll": [-5.402502059936523], "all_perturbed_original_ll": [-2.5514755249023438], "perturbed_sampled_ll": -5.402502059936523, "perturbed_original_ll": -2.5514755249023438, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "main(a,b,c){for(a=b=0,getchar();(c=getchar())!='0';)if(c-'\\n')c=='A'?a++:b++;else{printf(\"%d %d\\n\",a>b?a+1:a,a<b?b+1:b),a=b=0;if(getchar()=='0')break;}exit(0);}", "sampled": "#include <stdio.h>\n#include <string.h>\n\nint main() {\n    char record[101];\n    \n    while(1) {\n        if(scanf(\"%s\", record) != 1) break;\n        if(strcmp(record, \"0\") == 0) break;\n        \n        int len = strlen(record);\n        int scoreA = 0, scoreB = 0;\n        char lastServer = record[0];\n        \n        for(int i = 0; i < len; i++) {\n            if(record[i] != lastServer) {\n                // Server changed, so the previous server lost the point\n                if(lastServer == 'A') {\n                    scoreB++;\n                } else {\n                    scoreA++;\n                }\n                lastServer = record[i];\n            } else {\n                // Server stayed same, so server won the point\n                if(lastServer == 'A') {\n                    scoreA++;\n                } else {\n                    scoreB++;\n                }\n            }\n            \n            // Check if game ended\n            if(scoreA >= 11 || scoreB >= 11) {\n                if(scoreA >= 11 && scoreB >= 11) {\n                    if(scoreA - scoreB >= 2 || scoreB - scoreA >= 2) {\n                        break;\n                    }\n                } else {\n                    break;\n                }\n            }\n        }\n        \n        printf(\"%d %d\\n\", scoreA, scoreB);\n    }\n    \n    return 0;\n}\n", "perturbed_sampled": ["     scoreB  record[0]; for(int  !=  so the previous server lost the  scoreB++; } else   Server stayed same, so server won  { scoreA++; }  // Check if game ended if(scoreA >= 11 || scoreB  11 &&  -  else { break; } } } printf(\"%d %d\\n\", scoreA, scoreB); } return 0; }"], "perturbed_original": ["main(a,b,c){for(a=b=0,getchar();(c=getchar())!='0';)if(c-'\\n')c=='A'?a++:b++;else{printf(\"%d %d\\n\",a>b?a+1:a,a<b?b+1:b),a=b=0;if(getchar()=='0')break;}exit(0);}"], "original_ll": -2.4453697204589844, "sampled_ll": -0.8700991868972778, "all_perturbed_sampled_ll": [-3.728693962097168], "all_perturbed_original_ll": [-2.4453697204589844], "perturbed_sampled_ll": -3.728693962097168, "perturbed_original_ll": -2.4453697204589844, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import java.util.Scanner;\nclass Main\n{\n    public static void main(String args[])\n    {\n\tScanner scan=new Scanner(System.in);\n\twhile(true)\n\t    {\n\t\tString str=scan.next();\n\t\tif(str.equals(\"0\"))break;\n\t\tint countA=0,countB=0;\n\t\tif(str.charAt(str.length()-1)=='A')\n\t\t    {\n\t\t\tcountA+=1;\n\t\t\t//countB-=1;\n\t\t    }\n\t\telse if(str.charAt(str.length()-1)=='B')\n\t\t    {\n\t\t    countB+=1;\n\t\t    //countA-=1;\n\t\t    }\n\t\tfor(int i=1;i<str.length();i++)\n\t\t    {\n\t\t\tif(str.charAt(i)=='A')countA+=1;\n\t\t\telse countB+=1;\n\t\t    }\n\t\tif(str.charAt(str.length()-1)=='B'&&(countB<countA))\n\t\t    {\n\t\t\tcountB-=1;\n\t\t\tcountA+=1;\n\t\t    }\n\t\telse if(str.charAt(str.length()-1)=='A'&&(countB>countA))\n\t\t    {\n\t\t\tcountA-=1;\n\t\t\tcountB+=1;\n\t\t    }\n\t\tSystem.out.println(countA+\" \"+countB);\n\t    }\n    }\n}", "sampled": "import java.util.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        \n        while (true) {\n            String line = sc.nextLine();\n            if (line.equals(\"0\")) break;\n            \n            String game1 = line;\n            String game2 = sc.nextLine();\n            String game3 = sc.nextLine();\n            \n            System.out.println(processGame(game1));\n            System.out.println(processGame(game2));\n            System.out.println(processGame(game3));\n        }\n        \n        sc.close();\n    }\n    \n    static String processGame(String record) {\n        int scoreA = 0;\n        int scoreB = 0;\n        \n        for (int i = 0; i < record.length(); i++) {\n            char server = record.charAt(i);\n            \n            // The server who is recorded is the one who won the point\n            if (server == 'A') {\n                scoreA++;\n            } else {\n                scoreB++;\n            }\n            \n            // Check if game is over\n            if (scoreA >= 11 || scoreB >= 11) {\n                if (scoreA >= 10 && scoreB >= 10) {\n                    // Deuce situation - need 2 point difference\n                    if (Math.abs(scoreA - scoreB) >= 2) {\n                        break;\n                    }\n                } else {\n                    // Normal situation - first to 11\n                    if (scoreA >= 11 || scoreB >= 11) {\n                        break;\n                    }\n                }\n            }\n        }\n        \n        return scoreA + \" \" + scoreB;\n    }\n}\n", "perturbed_sampled": ["import java.util.*; public class Main { public static void  = new Scanner(System.in); while   game1  for (int i = 0; i < record.length(); i++) { char  server who is recorded is  point if (server ==  { scoreB++; } // Check if  >= 11  if (scoreA >= 10 && scoreB >= 10) { // Deuce situation - need 2  break;  Normal situation - first to   } }"], "perturbed_original": ["import java.util.Scanner; class  scan=new Scanner(System.in); while(true)  countA=0,countB=0; if(str.charAt(str.length()-1)=='A') { countA+=1; //countB-=1; } else   countB+=1; } if(str.charAt(str.length()-1)=='B'&&(countB<countA)) { countB-=1;   } } }"], "original_ll": -0.7426262497901917, "sampled_ll": -0.9009482860565186, "all_perturbed_sampled_ll": [-3.5490469932556152], "all_perturbed_original_ll": [-2.0645253658294678], "perturbed_sampled_ll": -3.5490469932556152, "perturbed_original_ll": -2.0645253658294678, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "while True:\n    ten=input()\n    if ten=='0':\n        break\n    a=ten.count('A')\n    b=ten.count('B')\n    if ten[0]=='A':\n        a-=1\n    elif ten[0]=='B':\n        b-=1\n    if a>b:\n        a+=1\n    else:\n        b+=1\n    print(a,b)\n", "sampled": "import sys\n\ndef solve_game(record):\n    score_a = 0\n    score_b = 0\n    \n    i = 0\n    while i < len(record):\n        server = record[i]\n        \n        # Check if game is over\n        if score_a >= 11 or score_b >= 11:\n            if abs(score_a - score_b) >= 2:\n                break\n            elif score_a >= 11 and score_b >= 11:\n                if abs(score_a - score_b) >= 2:\n                    break\n        \n        # Determine who won the point\n        if i + 1 < len(record):\n            next_server = record[i + 1]\n            if next_server == server:\n                # Same server, so server won the point\n                if server == 'A':\n                    score_a += 1\n                else:\n                    score_b += 1\n            else:\n                # Different server, so server lost the point\n                if server == 'A':\n                    score_b += 1\n                else:\n                    score_a += 1\n        else:\n            # Last serve, determine winner based on current score\n            # The game must end after this serve\n            if score_a < 11 and score_b < 11:\n                # Someone needs to reach 11\n                if server == 'A':\n                    score_a += 1\n                else:\n                    score_b += 1\n            elif score_a >= 10 and score_b >= 10:\n                # In deuce, need 2 point difference\n                if server == 'A':\n                    if score_a == score_b or score_a == score_b + 1:\n                        score_a += 1\n                    else:\n                        score_b += 1\n                else:\n                    if score_b == score_a or score_b == score_a + 1:\n                        score_b += 1\n                    else:\n                        score_a += 1\n            else:\n                if server == 'A':\n                    score_a += 1\n                else:\n                    score_b += 1\n        \n        i += 1\n    \n    return score_a, score_b\n\nwhile True:\n    line = input().strip()\n    if line == \"0\":\n        break\n    \n    game1 = line\n    game2 = input().strip()\n    game3 = input().strip()\n    \n    score1 = solve_game(game1)\n    score2 = solve_game(game2)\n    score3 = solve_game(game3)\n    \n    print(f\"{score1[0]} {score1[1]}\")\n    print(f\"{score2[0]} {score2[1]}\")\n    print(f\"{score3[0]} {score3[1]}\")\n", "perturbed_sampled": ["import sys def solve_game(record):  Check if  >= 11: if abs(score_a - score_b)  >= 11: if  break # Determine who won the point   1] if next_server    lost the point if server ==  score_a += 1 else: # Last serve, determine  # The game must end after this serve if score_a  11: # Someone needs    score_b   score_a == score_b or score_a == score_b  else: score_b += 1 else: if score_b == score_a   += 1 return score_a, score_b  if line  line game2 = input().strip() game3  score2 = solve_game(game2) score3 = solve_game(game3) print(f\"{score1[0]} {score1[1]}\") print(f\"{score2[0]} {score2[1]}\") print(f\"{score3[0]} {score3[1]}\")"], "perturbed_original": ["while True: ten=input() if ten=='0': break  elif  else: b+=1 print(a,b)"], "original_ll": -1.0308562517166138, "sampled_ll": -0.7485212683677673, "all_perturbed_sampled_ll": [-2.530734062194824], "all_perturbed_original_ll": [-3.969130516052246], "perturbed_sampled_ll": -2.530734062194824, "perturbed_original_ll": -3.969130516052246, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "#include<stdio.h>\nint main(void)\n{\n\tint n,nbox[10000],temp,i,j,flg;\n\tscanf(\"%d\",&n);\n\twhile(n!=-1){\n\t\ttemp=0;\n\t\ti=0;\n\t\tflg=0;\n\t\twhile(n>=4){\n\t\t\tnbox[i]=n%4;\n\t\t\tn/=4;\n\t\t\ti++;\n\t\t}\n\t\tprintf(\"%d\",n);\n\t\tfor(j=i;j>=0;j--){\n\t\t\tif(flg==0){\n\t\t\t\tflg=1;\n\t\t\t}\n\t\t\telse if(flg==1){\n\t\t\t\tprintf(\"%d\",nbox[j]);\n\t\t\t}\n\t\t}\n\t\tprintf(\"\\n\");\n\t\tscanf(\"%d\",&n);\n\t}\n\treturn 0;\n}", "sampled": "#include <stdio.h>\n\nint main() {\n    int n;\n    \n    while(1) {\n        scanf(\"%d\", &n);\n        if(n == -1) break;\n        \n        if(n == 0) {\n            printf(\"0\\n\");\n            continue;\n        }\n        \n        char result[32];\n        int index = 0;\n        \n        while(n > 0) {\n            result[index++] = '0' + (n % 4);\n            n /= 4;\n        }\n        \n        for(int i = index - 1; i >= 0; i--) {\n            printf(\"%c\", result[i]);\n        }\n        printf(\"\\n\");\n    }\n    \n    return 0;\n}\n", "perturbed_sampled": ["#include <stdio.h> int main() { int  if(n == -1) break; if(n == 0)  { result[index++] = '0' + (n % 4);  i =    }"], "perturbed_original": ["#include<stdio.h> int main(void) { int n,nbox[10000],temp,i,j,flg; scanf(\"%d\",&n); while(n!=-1){  n/=4; i++; } printf(\"%d\",n); for(j=i;j>=0;j--){  }"], "original_ll": -0.9420862197875977, "sampled_ll": -0.5727057456970215, "all_perturbed_sampled_ll": [-2.9967644214630127], "all_perturbed_original_ll": [-2.259758710861206], "perturbed_sampled_ll": -2.9967644214630127, "perturbed_original_ll": -2.259758710861206, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import java.util.*;\n\nclass Main {\n  public static void main (String[] args) {\n    Scanner scanner = new Scanner(System.in);\n    while (scanner.hasNext()) {\n      int a = scanner.nextInt();\n      if (a < 0) {\n        break;\n      }\n      if (a == 0) {\n        System.out.println(0);\n        continue;\n      }\n      System.out.println(aaa(a));\n    }\n  }\n  public static String aaa (int a) {\n    if (a == 0) {\n      return \"\";\n    }\n    return aaa(a / 4) + a % 4;\n  }\n}", "sampled": "import java.util.Scanner;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        \n        while (true) {\n            int n = sc.nextInt();\n            if (n == -1) break;\n            \n            if (n == 0) {\n                System.out.println(0);\n            } else {\n                StringBuilder result = new StringBuilder();\n                while (n > 0) {\n                    result.append(n % 4);\n                    n /= 4;\n                }\n                System.out.println(result.reverse().toString());\n            }\n        }\n        \n        sc.close();\n    }\n}\n", "perturbed_sampled": ["import  public static void main(String[] args) { Scanner sc = new  { System.out.println(0); }  new StringBuilder(); while (n >  n /= 4; }  }"], "perturbed_original": ["import java.util.*; class Main { public static void  scanner =  (a == 0) { System.out.println(0); continue; } System.out.println(aaa(a));   (a  4) + a % 4; } }"], "original_ll": -0.7600666284561157, "sampled_ll": -0.5117871761322021, "all_perturbed_sampled_ll": [-3.538853883743286], "all_perturbed_original_ll": [-3.2512869834899902], "perturbed_sampled_ll": -3.538853883743286, "perturbed_original_ll": -3.2512869834899902, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "from operator import add\nb2q = {\"00\":\"0\",\"01\":\"1\",\"10\":\"2\",\"11\":\"3\"}\nwhile True:\n    n = input()\n    if n == -1:\n        break\n    s = format(n,\"b\")\n    if len(s) % 2 == 1:\n        s = \"0\" + s\n    print \"\".join(map(b2q.get,map(add,s[::2],s[1::2])))", "sampled": "while True:\n    n = int(input())\n    if n == -1:\n        break\n    \n    if n == 0:\n        print(0)\n    else:\n        result = \"\"\n        while n > 0:\n            result = str(n % 4) + result\n            n //= 4\n        print(result)\n", "perturbed_sampled": ["while True: n  result = \"\" while n > 0: result =  n //= 4 print(result)"], "perturbed_original": [" = {\"00\":\"0\",\"01\":\"1\",\"10\":\"2\",\"11\":\"3\"} while True:  == -1:  len(s) % 2 == 1: s  \"\".join(map(b2q.get,map(add,s[::2],s[1::2])))"], "original_ll": -1.342484951019287, "sampled_ll": -0.8362977504730225, "all_perturbed_sampled_ll": [-3.8444559574127197], "all_perturbed_original_ll": [-2.6718852519989014], "perturbed_sampled_ll": -3.8444559574127197, "perturbed_original_ll": -2.6718852519989014, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n\nint i,r,g,b,d,ans,best;\nchar col[8][15]={\"black\",\"blue\",\"lime\",\"aqua\",\"red\",\"fuchsia\",\"yellow\",\"white\"};\nchar code[24];\n\nint main(){\n\twhile(1){\n\t\tscanf(\"%s\",&code);\n\t\tif(code[0]=='0')break;\n\t\tsscanf(code,\"#%2x%2x%2x\",&r,&g,&b);\n\t\tbest=99999999;\n\t\tfor(i=0;i<8;i++){\n\t\t\td=(r-255*(i>3))*(r-255*(i>3))+(g-255*(i%4>1))*(g-255*(i%4>1))+(b-255*(i%2))*(b-255*(i%2));\n\t\t\tif(d<best){best=d;ans=i;}\n\t\t}\n\t\tprintf(\"%s\\n\",col[ans]);\n\t}\n\treturn 0;\n}", "sampled": "#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n\ntypedef struct {\n    char name[10];\n    int r, g, b;\n} Color;\n\nint main() {\n    Color colors[8] = {\n        {\"black\", 0x00, 0x00, 0x00},\n        {\"blue\", 0x00, 0x00, 0xff},\n        {\"lime\", 0x00, 0xff, 0x00},\n        {\"aqua\", 0x00, 0xff, 0xff},\n        {\"red\", 0xff, 0x00, 0x00},\n        {\"fuchsia\", 0xff, 0x00, 0xff},\n        {\"yellow\", 0xff, 0xff, 0x00},\n        {\"white\", 0xff, 0xff, 0xff}\n    };\n    \n    char input[10];\n    \n    while(1) {\n        scanf(\"%s\", input);\n        if(input[0] == '0') break;\n        \n        int r, g, b;\n        char rstr[3], gstr[3], bstr[3];\n        \n        rstr[0] = input[1];\n        rstr[1] = input[2];\n        rstr[2] = '\\0';\n        \n        gstr[0] = input[3];\n        gstr[1] = input[4];\n        gstr[2] = '\\0';\n        \n        bstr[0] = input[5];\n        bstr[1] = input[6];\n        bstr[2] = '\\0';\n        \n        r = strtol(rstr, NULL, 16);\n        g = strtol(gstr, NULL, 16);\n        b = strtol(bstr, NULL, 16);\n        \n        int minDist = -1;\n        int minIdx = 0;\n        \n        for(int i = 0; i < 8; i++) {\n            int dr = r - colors[i].r;\n            int dg = g - colors[i].g;\n            int db = b - colors[i].b;\n            int dist = dr*dr + dg*dg + db*db;\n            \n            if(minDist == -1 || dist < minDist) {\n                minDist = dist;\n                minIdx = i;\n            }\n        }\n        \n        printf(\"%s\\n\", colors[minIdx].name);\n    }\n    \n    return 0;\n}\n", "perturbed_sampled": ["#include <stdio.h> #include <string.h> #include <stdlib.h> typedef  r, g,   {\"black\", 0x00, 0x00, 0x00}, {\"blue\", 0x00,  0xff}, {\"red\", 0xff, 0x00, 0x00},  char input[10]; while(1) { scanf(\"%s\", input); if(input[0] ==   rstr[0] = input[1]; rstr[1] = input[2]; rstr[2]  gstr[1] = input[4];   = '\\0';  16);  int minDist = -1; int  = 0;  int dr  dg =  int dist = dr*dr + dg*dg +   =   0; }"], "perturbed_original": ["#include <stdio.h> #include <string.h> #include <stdlib.h> int  if(code[0]=='0')break; sscanf(code,\"#%2x%2x%2x\",&r,&g,&b);  printf(\"%s\\n\",col[ans]); } return 0; }"], "original_ll": -1.2552781105041504, "sampled_ll": -0.4099103510379791, "all_perturbed_sampled_ll": [-2.167762517929077], "all_perturbed_original_ll": [-2.4338326454162598], "perturbed_sampled_ll": -2.167762517929077, "perturbed_original_ll": -2.4338326454162598, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import java.util.Scanner;\nimport java.util.HashMap;\nimport java.util.Arrays;\nclass Main\n{\n\tpublic static void main(String args[])\n\t{\n\t\tScanner sc = new Scanner(System.in).useDelimiter(\"[\\n#]+\");\n\t\twhile (true)\n\t\t{\n\t\t\tString str = sc.next();\n\t\t\tif (str.equals(\"0\")) break;\n\t\t\tint rk = Integer.parseInt(str.substring(0, 2), 16);\n\t\t\tint gk = Integer.parseInt(str.substring(2, 4), 16);\n\t\t\tint bk = Integer.parseInt(str.substring(4, 6), 16);\n\t\t\tint d[] = new int[8];\n\t\t\tHashMap<Integer, String> map = new HashMap<Integer, String>();\n\t\t\td[0] = (0x00 - rk) * (0x00 - rk)\n\t\t\t\t\t+ (0x00 - gk) * (0x00 - gk)\n\t\t\t\t\t+ (0x00 - bk) * (0x00 - bk);\n\t\t\tmap.put(d[0], \"black\");\n\t\t\td[1] = (0x00 - rk) * (0x00 - rk)\n\t\t\t\t\t+ (0x00 - gk) * (0x00 - gk)\n\t\t\t\t\t+ (0xff - bk) * (0xff - bk);\n\t\t\tmap.put(d[1], \"blue\");\n\t\t\td[2] = (0x00 - rk) * (0x00 - rk)\n\t\t\t\t\t+ (0xff - gk) * (0xff - gk)\n\t\t\t\t\t+ (0x00 - bk) * (0x00 - bk);\n\t\t\tmap.put(d[2], \"lime\");\n\t\t\td[3] = (0x00 - rk) * (0x00 - rk)\n\t\t\t\t\t+ (0xff - gk) * (0xff - gk)\n\t\t\t\t\t+ (0xff - bk) * (0xff - bk);\n\t\t\tmap.put(d[3], \"aqua\");\n\t\t\td[4] = (0xff - rk) * (0xff - rk)\n\t\t\t\t\t+ (0x00 - gk) * (0x00 - gk)\n\t\t\t\t\t+ (0x00 - bk) * (0x00 - bk);\n\t\t\tmap.put(d[4], \"red\");\n\t\t\td[5] = (0xff - rk) * (0xff - rk)\n\t\t\t\t\t+ (0x00 - gk) * (0x00 - gk)\n\t\t\t\t\t+ (0xff - bk) * (0xff - bk);\n\t\t\tmap.put(d[5], \"fuchsia\");\n\t\t\td[6] = (0xff - rk) * (0xff - rk)\n\t\t\t\t\t+ (0xff - gk) * (0xff - gk)\n\t\t\t\t\t+ (0x00 - bk) * (0x00 - bk);\n\t\t\tmap.put(d[6], \"yellow\");\n\t\t\td[7] = (0xff - rk) * (0xff - rk)\n\t\t\t\t\t+ (0xff - gk) * (0xff - gk)\n\t\t\t\t\t+ (0xff - bk) * (0xff - bk);\n\t\t\tmap.put(d[7], \"white\");\n\t\t\tArrays.sort(d);\n\t\t\tSystem.out.println(map.get(d[0]));\n\t\t}\n\t}\n}", "sampled": "import java.util.Scanner;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        \n        String[] colorNames = {\"black\", \"blue\", \"lime\", \"aqua\", \"red\", \"fuchsia\", \"yellow\", \"white\"};\n        int[][] colorValues = {\n            {0x00, 0x00, 0x00},  // black\n            {0x00, 0x00, 0xff},  // blue\n            {0x00, 0xff, 0x00},  // lime\n            {0x00, 0xff, 0xff},  // aqua\n            {0xff, 0x00, 0x00},  // red\n            {0xff, 0x00, 0xff},  // fuchsia\n            {0xff, 0xff, 0x00},  // yellow\n            {0xff, 0xff, 0xff}   // white\n        };\n        \n        while (true) {\n            String input = sc.next();\n            if (input.equals(\"0\")) {\n                break;\n            }\n            \n            // Parse color code\n            String colorCode = input.substring(1); // Remove '#'\n            int r = Integer.parseInt(colorCode.substring(0, 2), 16);\n            int g = Integer.parseInt(colorCode.substring(2, 4), 16);\n            int b = Integer.parseInt(colorCode.substring(4, 6), 16);\n            \n            // Find closest color\n            int minDistance = Integer.MAX_VALUE;\n            String closestColor = \"\";\n            \n            for (int i = 0; i < colorNames.length; i++) {\n                int rk = colorValues[i][0];\n                int gk = colorValues[i][1];\n                int bk = colorValues[i][2];\n                \n                int distance = (r - rk) * (r - rk) + (g - gk) * (g - gk) + (b - bk) * (b - bk);\n                \n                if (distance < minDistance) {\n                    minDistance = distance;\n                    closestColor = colorNames[i];\n                }\n            }\n            \n            System.out.println(closestColor);\n        }\n        \n        sc.close();\n    }\n}\n", "perturbed_sampled": ["import java.util.Scanner; public  void  = new Scanner(System.in); String[]   {0x00, 0x00,  0xff}, // blue {0x00, 0xff, 0x00}, // lime {0x00, 0xff, 0xff}, // aqua {0xff, 0x00, 0x00}, // red  {0xff,  }; while (true) { String input = sc.next(); if (input.equals(\"0\")) {  = Integer.parseInt(colorCode.substring(2, 4),  closest color int  = \"\"; for (int i = 0; i    (r  bk) * (b - bk); if (distance  distance; closestColor = colorNames[i]; } } System.out.println(closestColor); } sc.close(); } }"], "perturbed_original": [" java.util.Arrays; class  while   16); int   new int[8]; HashMap<Integer,  - rk) *  -  + (0x00  bk); map.put(d[0],  rk) * (0x00 - rk) + (0x00 - gk) *  - bk) * (0xff  = (0x00 - rk) *  -  map.put(d[2], \"lime\"); d[3] = (0x00 - rk)  (0xff -  (0xff -  + (0x00 - gk) * (0x00 - gk) + (0x00  bk); map.put(d[4], \"red\"); d[5] = (0xff - rk) * (0xff -  *  - bk); map.put(d[5], \"fuchsia\"); d[6] = (0xff  rk)  (0xff - gk)  (0x00   (0xff  gk) * (0xff - gk)  (0xff - bk); map.put(d[7], \"white\"); Arrays.sort(d); System.out.println(map.get(d[0])); } } }"], "original_ll": -0.39717236161231995, "sampled_ll": -0.41816282272338867, "all_perturbed_sampled_ll": [-2.3135361671447754], "all_perturbed_original_ll": [-1.9852179288864136], "perturbed_sampled_ll": -2.3135361671447754, "perturbed_original_ll": -1.9852179288864136, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import math\nL=[\n(\"black\",00,00,00),\n(\"blue\",00,00,255),\n(\"lime\",00,255,00),\n(\"aqua\",00,255,255),\n(\"red\",255,00,00),\n(\"fuchsia\",255,00,255),\n(\"yellow\",255,255,00),\n(\"white\",255,255,255)]\nwhile True:\n    c=raw_input()\n    if c==\"0\":break\n    Rk,Gk,Bk=int(c[1:3],16),int(c[3:5],16),int(c[5:7],16)\n    m=10000\n    for cl,r,g,b in L:\n        t=math.sqrt(pow(r-Rk,2)+pow(g-Gk,2)+pow(b-Bk,2))\n        if t<m:\n            m=t\n            color=cl\n    print color", "sampled": "import sys\n\ncolors = [\n    (\"black\", 0x00, 0x00, 0x00),\n    (\"blue\", 0x00, 0x00, 0xff),\n    (\"lime\", 0x00, 0xff, 0x00),\n    (\"aqua\", 0x00, 0xff, 0xff),\n    (\"red\", 0xff, 0x00, 0x00),\n    (\"fuchsia\", 0xff, 0x00, 0xff),\n    (\"yellow\", 0xff, 0xff, 0x00),\n    (\"white\", 0xff, 0xff, 0xff)\n]\n\nfor line in sys.stdin:\n    line = line.strip()\n    if line == \"0\":\n        break\n    \n    # Parse color code\n    color_code = line[1:]  # Remove #\n    R = int(color_code[0:2], 16)\n    G = int(color_code[2:4], 16)\n    B = int(color_code[4:6], 16)\n    \n    # Find closest color\n    min_distance = float('inf')\n    closest_color = \"\"\n    \n    for name, Rk, Gk, Bk in colors:\n        dk = (R - Rk) ** 2 + (G - Gk) ** 2 + (B - Bk) ** 2\n        if dk < min_distance:\n            min_distance = dk\n            closest_color = name\n    \n    print(closest_color)\n", "perturbed_sampled": ["import sys colors = [ (\"black\", 0x00, 0x00, 0x00), (\"blue\", 0x00, 0x00,  (\"aqua\", 0x00, 0xff, 0xff), (\"red\",  0x00, 0xff), (\"yellow\", 0xff, 0xff, 0x00), (\"white\", 0xff, 0xff,  break #  G = int(color_code[2:4], 16) B =  closest_color = \"\" for name, Rk,  =  if dk <  = name print(closest_color)"], "perturbed_original": ["  (\"white\",255,255,255)] while True: c=raw_input()  cl,r,g,b  m=t color=cl print color"], "original_ll": -0.9571045637130737, "sampled_ll": -0.5650010108947754, "all_perturbed_sampled_ll": [-2.3213131427764893], "all_perturbed_original_ll": [-4.209817409515381], "perturbed_sampled_ll": -2.3213131427764893, "perturbed_original_ll": -4.209817409515381, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "#include <stdio.h>\n#include <math.h>\n#define PI 3.141592653589793\n#define r 6378.1\nint main(void) {\n\twhile(1){\n\t\tdouble a,b,c,d;\n\t\tscanf(\"%lf %lf %lf %lf\\n\",&a,&b,&c,&d);\n\t\tif(a==(-1)&&b==(-1)&&c==(-1)&&d==(-1)) break;\n\t\tdouble a1,b1,c1,d1;\n\t\ta1=a*PI/180.0;\n\t\tb1=b*PI/180.0;\n\t\tc1=c*PI/180.0;\n\t\td1=d*PI/180.0;\n\t\tdouble e1,f;\n\t\te1=d1-b1;\n\t\tf=r*acos((sin(a1)*sin(c1))+(cos(a1)*cos(c1)*cos(e1)));\n\t\tprintf(\"%.0f\\n\",f);\n\t}\n\treturn 0;\n}\n", "sampled": "#include <stdio.h>\n#include <math.h>\n\n#define PI 3.14159265358979323846\n#define RADIUS 6378.1\n\nint main() {\n    double a, b, c, d;\n    \n    while (1) {\n        scanf(\"%lf %lf %lf %lf\", &a, &b, &c, &d);\n        \n        if (a == -1 && b == -1 && c == -1 && d == -1) {\n            break;\n        }\n        \n        double lat1 = a * PI / 180.0;\n        double lon1 = b * PI / 180.0;\n        double lat2 = c * PI / 180.0;\n        double lon2 = d * PI / 180.0;\n        \n        double x1 = RADIUS * cos(lat1) * cos(lon1);\n        double y1 = RADIUS * cos(lat1) * sin(lon1);\n        double z1 = RADIUS * sin(lat1);\n        \n        double x2 = RADIUS * cos(lat2) * cos(lon2);\n        double y2 = RADIUS * cos(lat2) * sin(lon2);\n        double z2 = RADIUS * sin(lat2);\n        \n        double chord = sqrt((x2-x1)*(x2-x1) + (y2-y1)*(y2-y1) + (z2-z1)*(z2-z1));\n        \n        double angle = 2.0 * asin(chord / (2.0 * RADIUS));\n        \n        double distance = RADIUS * angle;\n        \n        int result = (int)(distance + 0.5);\n        \n        printf(\"%d\\n\", result);\n    }\n    \n    return 0;\n}\n", "perturbed_sampled": ["#include <stdio.h> #include <math.h> #define PI 3.14159265358979323846 #define   (a == -1 && b  -1)  =  double   d * PI / 180.0; double x1 = RADIUS *  =  * cos(lon2); double y2 = RADIUS * cos(lat2) *  * sin(lat2); double chord = sqrt((x2-x1)*(x2-x1) +  = 2.0 * asin(chord / (2.0  RADIUS * angle; int  printf(\"%d\\n\", result); } return 0; }"], "perturbed_original": ["#include <stdio.h>  #define  %lf  a1,b1,c1,d1;  e1,f; e1=d1-b1; f=r*acos((sin(a1)*sin(c1))+(cos(a1)*cos(c1)*cos(e1))); printf(\"%.0f\\n\",f); } return 0; }"], "original_ll": -0.791118323802948, "sampled_ll": -0.39860960841178894, "all_perturbed_sampled_ll": [-2.2356953620910645], "all_perturbed_original_ll": [-2.401958703994751], "perturbed_sampled_ll": -2.2356953620910645, "perturbed_original_ll": -2.401958703994751, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import java.util.*;\nimport java.lang.*;\nimport java.math.*;\n\npublic class Main {\n\tScanner sc = new Scanner(System.in);\n\tvoid run(){\n\t\tfor(;;){\n\t\t\tdouble a = sc.nextDouble();\n\t\t\tdouble b = sc.nextDouble();\n\t\t\tdouble c = sc.nextDouble();\n\t\t\tdouble d = sc.nextDouble();\n\t\t\tif((a==-1)&&(b==-1)&&(c==-1)&&(d==-1)){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\n\t\t\tdouble vz = Math.sin(Math.toRadians(a));\n\t\t\tdouble vx = Math.cos(Math.toRadians(a))*Math.cos(Math.toRadians(b));\n\t\t\tdouble vy = Math.cos(Math.toRadians(a))*Math.sin(Math.toRadians(b));\n\n\t\t\tdouble wz = Math.sin(Math.toRadians(c));\n\t\t\tdouble wx = Math.cos(Math.toRadians(c))*Math.cos(Math.toRadians(d));\n\t\t\tdouble wy = Math.cos(Math.toRadians(c))*Math.sin(Math.toRadians(d));\n\n\t\t\tdouble dot = vz*wz + vx*wx + vy * wy;\n\t\t\tdouble theta = Math.acos(dot);\n\t\t\tdouble R =6378.1;\n\t\t\tSystem.out.println((int)(R*theta+0.5));\n\t\t}\n\t\t\n\t}\n\tpublic static void main(String[] args){\n\t\tMain m = new Main();\n\t\tm.run();\n\t}\n}", "sampled": "import java.util.Scanner;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        \n        while (true) {\n            double a = sc.nextDouble();\n            double b = sc.nextDouble();\n            double c = sc.nextDouble();\n            double d = sc.nextDouble();\n            \n            if (a == -1 && b == -1 && c == -1 && d == -1) {\n                break;\n            }\n            \n            double lat1 = Math.toRadians(a);\n            double lon1 = Math.toRadians(b);\n            double lat2 = Math.toRadians(c);\n            double lon2 = Math.toRadians(d);\n            \n            double radius = 6378.1;\n            \n            double centralAngle = Math.acos(\n                Math.sin(lat1) * Math.sin(lat2) + \n                Math.cos(lat1) * Math.cos(lat2) * Math.cos(lon2 - lon1)\n            );\n            \n            double distance = radius * centralAngle;\n            \n            long result = Math.round(distance);\n            \n            System.out.println(result);\n        }\n        \n        sc.close();\n    }\n}\n", "perturbed_sampled": ["import java.util.Scanner; public class Main { public static void main(String[] args) { Scanner sc = new Scanner(System.in); while (true) {   = sc.nextDouble(); if (a == -1 &&     =  double lon2   Math.cos(lat1) *  ); double   } sc.close(); } }"], "perturbed_original": [" sc.nextDouble();   } double vz = Math.sin(Math.toRadians(a)); double  = Math.cos(Math.toRadians(a))*Math.sin(Math.toRadians(b)); double wz = Math.sin(Math.toRadians(c)); double wx  Math.cos(Math.toRadians(c))*Math.sin(Math.toRadians(d)); double dot  theta =  } } public static void main(String[] args){ Main m = new Main(); m.run(); } }"], "original_ll": -0.8860735297203064, "sampled_ll": -0.46987923979759216, "all_perturbed_sampled_ll": [-2.4870028495788574], "all_perturbed_original_ll": [-2.1262760162353516], "perturbed_sampled_ll": -2.4870028495788574, "perturbed_original_ll": -2.1262760162353516, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "from math import acos,sin,cos,radians\nwhile 1:\n    a,b,c,d=map(float,input().split())\n    if a==b==c==d==-1:break\n    a,c=radians(a),radians(c)\n    print(int(6378.1*acos(sin(a)*sin(c) + cos(a)*cos(c)*cos(radians(d)-radians(b)))+0.5))", "sampled": "import math\n\nR = 6378.1\n\nwhile True:\n    line = input().split()\n    a, b, c, d = map(float, line)\n    \n    if a == -1 and b == -1 and c == -1 and d == -1:\n        break\n    \n    # Convert degrees to radians\n    lat1 = math.radians(a)\n    lon1 = math.radians(b)\n    lat2 = math.radians(c)\n    lon2 = math.radians(d)\n    \n    # Calculate great circle distance using spherical law of cosines\n    # or using haversine formula for better numerical stability\n    \n    # Using spherical law of cosines:\n    # d = R * arccos(sin(lat1)*sin(lat2) + cos(lat1)*cos(lat2)*cos(lon2-lon1))\n    \n    cos_angle = math.sin(lat1) * math.sin(lat2) + math.cos(lat1) * math.cos(lat2) * math.cos(lon2 - lon1)\n    \n    # Clamp to [-1, 1] to avoid numerical errors\n    cos_angle = max(-1, min(1, cos_angle))\n    \n    angle = math.acos(cos_angle)\n    distance = R * angle\n    \n    print(round(distance))\n", "perturbed_sampled": ["import math R = 6378.1 while  b, c, d =   and c   to radians lat1 = math.radians(a) lon1 =  spherical law of cosines # or using haversine  # Using spherical law  R *  math.sin(lat1) *  errors cos_angle = max(-1,  distance = R * angle print(round(distance))"], "perturbed_original": ["from math import acos,sin,cos,radians while 1: a,b,c,d=map(float,input().split())  cos(a)*cos(c)*cos(radians(d)-radians(b)))+0.5))"], "original_ll": -1.657982349395752, "sampled_ll": -0.818010151386261, "all_perturbed_sampled_ll": [-3.9510765075683594], "all_perturbed_original_ll": [-2.541051149368286], "perturbed_sampled_ll": -3.9510765075683594, "perturbed_original_ll": -2.541051149368286, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "n,d,p,q,m[9999],h;main(b){for(;~scanf(\"%d\",&n),n;d&&printf(\"%d\\n\",p)){for(memset(m,d=0,39996);n--;){scanf(\"%d%d%d\",&d,&p,&q);b=(d-2?~-(1<<p):1)<<q;for(h=9998;~h&&!(m[h]&b);h--)d-2?p=1:0;for(h++;p--;m[h]-62?h++:memmove(m+h,m+h+1,9998-h))m[h]|=b;}for(p=0,h=9999;h--;)for(b=m[h];q=-b&b;b-=q)p++;}}", "sampled": "#include <stdio.h>\n#include <string.h>\n\n#define MAX_HEIGHT 10000\n#define WIDTH 5\n\nint grid[MAX_HEIGHT][WIDTH];\n\nint getHeight(int col) {\n    int h = 0;\n    for (int i = 0; i < MAX_HEIGHT; i++) {\n        if (grid[i][col] == 1) {\n            h = i + 1;\n        }\n    }\n    return h;\n}\n\nvoid dropBlock(int d, int p, int q) {\n    q--; // Convert to 0-indexed\n    \n    if (d == 1) { // Horizontal\n        // Find the highest point where the block can land\n        int maxHeight = 0;\n        for (int i = 0; i < p; i++) {\n            int h = getHeight(q + i);\n            if (h > maxHeight) {\n                maxHeight = h;\n            }\n        }\n        // Place the block\n        for (int i = 0; i < p; i++) {\n            grid[maxHeight][q + i] = 1;\n        }\n    } else { // Vertical (d == 2)\n        int h = getHeight(q);\n        // Place the block\n        for (int i = 0; i < p; i++) {\n            grid[h + i][q] = 1;\n        }\n    }\n}\n\nvoid removeFullRows() {\n    int removed = 0;\n    for (int row = 0; row < MAX_HEIGHT; row++) {\n        int full = 1;\n        for (int col = 0; col < WIDTH; col++) {\n            if (grid[row][col] == 0) {\n                full = 0;\n                break;\n            }\n        }\n        if (full) {\n            // Mark row for removal\n            for (int col = 0; col < WIDTH; col++) {\n                grid[row][col] = 0;\n            }\n            // Shift everything above down\n            for (int r = row; r < MAX_HEIGHT - 1; r++) {\n                for (int col = 0; col < WIDTH; col++) {\n                    grid[r][col] = grid[r + 1][col];\n                }\n            }\n            for (int col = 0; col < WIDTH; col++) {\n                grid[MAX_HEIGHT - 1][col] = 0;\n            }\n            row--; // Check this row again\n        }\n    }\n}\n\nint countBlocks() {\n    int count = 0;\n    for (int i = 0; i < MAX_HEIGHT; i++) {\n        for (int j = 0; j < WIDTH; j++) {\n            if (grid[i][j] == 1) {\n                count++;\n            }\n        }\n    }\n    return count;\n}\n\nint main() {\n    int n;\n    while (scanf(\"%d\", &n) == 1 && n != 0) {\n        // Clear the grid\n        memset(grid, 0, sizeof(grid));\n        \n        for (int i = 0; i < n; i++) {\n            int d, p, q;\n            scanf(\"%d %d %d\", &d, &p, &q);\n            dropBlock(d, p, q);\n            removeFullRows();\n        }\n        \n        printf(\"%d\\n\", countBlocks());\n    }\n    \n    return 0;\n}\n", "perturbed_sampled": ["#include   grid[MAX_HEIGHT][WIDTH]; int getHeight(int col) {  (int i = 0; i < MAX_HEIGHT; i++)  return h; } void  q) { q--; // Convert to 0-indexed if  highest  land int maxHeight = 0; for (int  p; i++)  + i); if   (int i = 0;  grid[maxHeight][q + i] =  2) int h  p; i++) { grid[h  } } void removeFullRows() { int  row  row++) { int full    0) { full = 0; break; } } if (full) { //  (int col =  { grid[row][col] = 0; }   col < WIDTH; col++) { grid[r][col] = grid[r + 1][col]; } } for (int col = 0;  Check  } int countBlocks() { int   j  return count; } int main() { int n; while (scanf(\"%d\",  i = 0;  int d, p, q; scanf(\"%d  dropBlock(d, p, q); removeFullRows(); }  }"], "perturbed_original": ["n,d,p,q,m[9999],h;main(b){for(;~scanf(\"%d\",&n),n;d&&printf(\"%d\\n\",p)){for(memset(m,d=0,39996);n--;){scanf(\"%d%d%d\",&d,&p,&q);b=(d-2?~-(1<<p):1)<<q;for(h=9998;~h&&!(m[h]&b);h--)d-2?p=1:0;for(h++;p--;m[h]-62?h++:memmove(m+h,m+h+1,9998-h))m[h]|=b;}for(p=0,h=9999;h--;)for(b=m[h];q=-b&b;b-=q)p++;}}"], "original_ll": -2.7408370971679688, "sampled_ll": -0.5612636804580688, "all_perturbed_sampled_ll": [-2.936614751815796], "all_perturbed_original_ll": [-2.7408370971679688], "perturbed_sampled_ll": -2.936614751815796, "perturbed_original_ll": -2.7408370971679688, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import java.util.Scanner;\n\n//TETORIS\npublic class Main {\n\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\twhile(true){\n\t\t\tint n = sc.nextInt();\n\t\t\tif(n==0)break;\n\t\t\tboolean[][] m = new boolean[5000][5];\n\t\t\twhile(n--!=0){\n\t\t\t\tint d = sc.nextInt();\n\t\t\t\tint p = sc.nextInt();\n\t\t\t\tint q = sc.nextInt()-1;\n\t\t\t\tif(d==2){\n\t\t\t\t\tint k = 4999;\n\t\t\t\t\twhile(k>=0&&!m[k][q])k--;\n\t\t\t\t\tk++;\n\t\t\t\t\tfor(int i=k;i<k+p;i++)m[i][q]=true;\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tint k = 4999;\n\t\t\t\t\twhile(true){\n\t\t\t\t\t\tboolean f = true;\n\t\t\t\t\t\tif(k>=0){\n\t\t\t\t\t\t\tfor(int j=q;j<q+p;j++){\n\t\t\t\t\t\t\t\tif(m[k][j])f = false;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(!f||k==-1){\n\t\t\t\t\t\t\tk++;\n\t\t\t\t\t\t\tfor(int j=q;j<q+p;j++)m[k][j]=true;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tk--;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tboolean con = true;\n\t\t\t\tint k = 0;\n\t\t\t\twhile(k<5000&&con){\n\t\t\t\t\tcon = false;\n\t\t\t\t\tboolean t = true;\n\t\t\t\t\tfor(int j=0;j<5;j++){\n\t\t\t\t\t\tif(m[k][j])con = true;\n\t\t\t\t\t\telse t = false;\n\t\t\t\t\t}\n\t\t\t\t\tif(t){\n\t\t\t\t\t\tboolean f = true;\n\t\t\t\t\t\tint i = k;\n\t\t\t\t\t\twhile(i<5000&&f){\n\t\t\t\t\t\t\tf = false;\n\t\t\t\t\t\t\tfor(int j=0;j<5;j++){\n\t\t\t\t\t\t\t\tif(m[i][j])f = true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif(f){\n\t\t\t\t\t\t\t\tfor(int j=0;j<5;j++){\n\t\t\t\t\t\t\t\t\tm[i][j] = m[i+1][j];\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\ti++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse k++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tint s = 0;\n\t\t\tfor(int i=0;i<5000;i++)for(int j=0;j<5;j++)s+=m[i][j]?1:0;\n\t\t\tSystem.out.println(s);\n\t\t}\n\t}\n}", "sampled": "import java.util.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        \n        while (true) {\n            int n = sc.nextInt();\n            if (n == 0) break;\n            \n            int[][] board = new int[10000][5];\n            int maxHeight = 0;\n            \n            for (int i = 0; i < n; i++) {\n                int d = sc.nextInt();\n                int p = sc.nextInt();\n                int q = sc.nextInt() - 1;\n                \n                if (d == 1) {\n                    int dropHeight = 0;\n                    for (int col = q; col < q + p; col++) {\n                        for (int row = 0; row < 10000; row++) {\n                            if (board[row][col] == 1) {\n                                dropHeight = Math.max(dropHeight, row + 1);\n                                break;\n                            }\n                        }\n                    }\n                    \n                    for (int col = q; col < q + p; col++) {\n                        board[dropHeight][col] = 1;\n                    }\n                    maxHeight = Math.max(maxHeight, dropHeight + 1);\n                } else {\n                    int dropHeight = 0;\n                    for (int row = 0; row < 10000; row++) {\n                        if (board[row][q] == 1) {\n                            dropHeight = row + 1;\n                            break;\n                        }\n                    }\n                    \n                    for (int row = dropHeight; row < dropHeight + p; row++) {\n                        board[row][q] = 1;\n                    }\n                    maxHeight = Math.max(maxHeight, dropHeight + p);\n                }\n                \n                boolean cleared = true;\n                while (cleared) {\n                    cleared = false;\n                    for (int row = 0; row < maxHeight; row++) {\n                        boolean full = true;\n                        for (int col = 0; col < 5; col++) {\n                            if (board[row][col] == 0) {\n                                full = false;\n                                break;\n                            }\n                        }\n                        \n                        if (full) {\n                            cleared = true;\n                            for (int r = row; r < maxHeight - 1; r++) {\n                                for (int col = 0; col < 5; col++) {\n                                    board[r][col] = board[r + 1][col];\n                                }\n                            }\n                            for (int col = 0; col < 5; col++) {\n                                board[maxHeight - 1][col] = 0;\n                            }\n                            maxHeight--;\n                            break;\n                        }\n                    }\n                }\n            }\n            \n            int count = 0;\n            for (int row = 0; row < maxHeight; row++) {\n                for (int col = 0; col < 5; col++) {\n                    if (board[row][col] == 1) {\n                        count++;\n                    }\n                }\n            }\n            \n            System.out.println(count);\n        }\n        \n        sc.close();\n    }\n}\n", "perturbed_sampled": [" {   Scanner(System.in); while (true) { int n = sc.nextInt();  int[][] board = new  0; i < n; i++) {  q = sc.nextInt() - 1; if (d == 1) {    dropHeight = Math.max(dropHeight, row  = q; col < q  =  else { int dropHeight =  0; row < 10000; row++) { if  = row + 1; break; } } for (int row =  p;  dropHeight + p);   (int  (board[row][col] == 0) { full  = true; for (int r  - 1; r++)  col++) { board[r][col] = board[r + 1][col]; } } for (int col =  =  } } }  (int row =  {  col < 5; col++) { if (board[row][col] ==  } System.out.println(count); } sc.close(); } }"], "perturbed_original": ["import java.util.Scanner; //TETORIS public class  = new  sc.nextInt(); int p = sc.nextInt();  int   if(k>=0){ for(int j=q;j<q+p;j++){ if(m[k][j])f = false; } } if(!f||k==-1){  con = true; int k = 0; while(k<5000&&con){ con  true;  = true; int i  false; for(int   } } else k++; } } int s = 0; for(int i=0;i<5000;i++)for(int j=0;j<5;j++)s+=m[i][j]?1:0; System.out.println(s); } } }"], "original_ll": -0.8281287550926208, "sampled_ll": -0.45888951420783997, "all_perturbed_sampled_ll": [-2.572498083114624], "all_perturbed_original_ll": [-2.5608909130096436], "perturbed_sampled_ll": -2.572498083114624, "perturbed_original_ll": -2.5608909130096436, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "#!/usr/local/bin/python\nfrom itertools import islice\n\ndef init():\n    return [[None] * 5] * 5000\n\nN = 4\n\nwhile True:\n    #N = int(input())\n    if N == 0:\n        break\n    d, l, pos = [int(n) for n in raw_input().split()]\n    lst = init()\n    flwr = 0\n    for i in xrange(N):\n        print d, l, pos\n        # if d == 1:\n        #     for i in xrange(l):\n        #         lst[flwr][pos-1 + i] = 1\n        # else:\n        #     tmp = 0\n        #     for i in xrange(l):\n        #         lst[flwr + tmp][pos-1] = 1\n        #         tmp += 1\n        #print lst[flwr]\n        #print not None in lst[flwr]\n        if not None in lst[flwr]:\n            flwr += 1\n    ret = 0\n    for i in xrange(flwr):\n        ret += len([i for i in lst[i] if not None])\n    #print ret\n    N -= 1\n    break", "sampled": "def solve():\n    while True:\n        n = int(input())\n        if n == 0:\n            break\n        \n        # Board: 5 columns, use a list to store heights at each column\n        # We'll use a grid representation where grid[row][col] tells if there's a block\n        grid = []  # Will grow as needed, grid[0] is bottom\n        \n        for _ in range(n):\n            d, p, q = map(int, input().split())\n            q -= 1  # Convert to 0-indexed\n            \n            if d == 1:  # Horizontal block\n                # Find the maximum height among columns q to q+p-1\n                max_height = 0\n                for col in range(q, q + p):\n                    # Find height of column col\n                    h = 0\n                    for row in range(len(grid)):\n                        if grid[row][col]:\n                            h = row + 1\n                    max_height = max(max_height, h)\n                \n                # Place block at row max_height\n                while len(grid) <= max_height:\n                    grid.append([False] * 5)\n                \n                for col in range(q, q + p):\n                    grid[max_height][col] = True\n                    \n            else:  # Vertical block (d == 2)\n                # Find height of column q\n                height = 0\n                for row in range(len(grid)):\n                    if grid[row][q]:\n                        height = row + 1\n                \n                # Place block from row height to height+p-1\n                while len(grid) < height + p:\n                    grid.append([False] * 5)\n                \n                for row in range(height, height + p):\n                    grid[row][q] = True\n            \n            # Check for complete rows and remove them\n            rows_to_remove = []\n            for row_idx in range(len(grid)):\n                if all(grid[row_idx]):\n                    rows_to_remove.append(row_idx)\n            \n            # Remove complete rows (from top to bottom to maintain indices)\n            for row_idx in reversed(rows_to_remove):\n                grid.pop(row_idx)\n        \n        # Count remaining blocks\n        count = 0\n        for row in grid:\n            count += sum(row)\n        \n        print(count)\n\nsolve()\n", "perturbed_sampled": ["def solve():  break #  list  a block grid = [] #  is bottom for _  -=  if  block # Find the  0 for col in range(q, q + p):  col  in range(len(grid)): if grid[row][col]: h = row + 1 max_height = max(max_height, h) # Place   5) for col in range(q, q  (d == 2) #  height  range(len(grid)):  + 1 # Place block from row  < height + p: grid.append([False]  range(height, height  #  range(len(grid)): if   # Count remaining blocks count = 0 for row in  solve()"], "perturbed_original": ["#!/usr/local/bin/python from itertools import <extra_id_1>for i<extra_id_2>i in xrange(l): # lst[flwr]<extra_id_3>#tmp<extra_id_4>i in<extra_id_5>] # print tmp[tmp][pos-1]<extra_id_6>if i < l<extra_id_7>[i ]<extra_id_8>n-p]<extra_id_9>l)<extra_id_10>else: #<extra_id_22># break # break<extra_id_23>== 0: #<extra_id_24>i in<extra_id_25>[i] N = 4 while True: #N = for p as   d == 1: # for i in xrange(l): # lst[flwr][pos-1  else: # tmp = 0 # for i in xrange(l): # lst[flwr + tmp][pos-1]  1 #print lst[flwr] #print not None in lst[flwr]  len([i  N -= 1 break"], "original_ll": -1.3601551055908203, "sampled_ll": -1.0993638038635254, "all_perturbed_sampled_ll": [-3.8225176334381104], "all_perturbed_original_ll": [-2.812086343765259], "perturbed_sampled_ll": -3.8225176334381104, "perturbed_original_ll": -2.812086343765259, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "// Aizu Vol-1 0179: Mysterious Worm\n// 2017.8.22 bal4u@uu\n\n#include <stdio.h>\n#include <string.h>\n\n#define MAX 0xaaaaa\nchar chk[MAX+10];\nint Q[MAX+10], *top, *end, *qmax = Q + MAX;\nint N, K, mask;\n\nint nxt[16] = { 0, 10, 5, 0, 10, 5, 0, 0, 5, 0, 10 };\n\nint main()\n{\n\tint s, r, g, b, step;\n\tint i, k;\n\tchar buf[15], *bp;\n\n\twhile (1) {\n\t\tscanf(\"%s\", buf); if (buf[0] == '0') break;\n\t\tmemset(chk, 0, sizeof(chk));\n\t\tfor (N = s = 0, bp = buf; *bp; bp++, N += 2) {\n\t\t\tif      (*bp == 'r') k = 0;\n\t\t\telse if (*bp == 'g') k = 1;\n\t\t\telse                 k = 2;\n\t\t\ts = (s << 2) | k;\n\t\t}\n\t\tmask = (1 << N) - 1, r = 0, g = 0x55555 & mask, b = 0xaaaaa & mask;\n\t\ttop = end = Q;\n\t\t*end++ = s, *end++ = -1, chk[s] = 1, step = 0, K = N-4;\n\t\twhile (top < end) {\n\t\t\ts = *top; if (++top >= qmax) top = Q;\n\t\t\tif (s < 0) { step++, *end = -1; if (++end >= qmax) end = Q; continue; }\n\t\t\tif (s == r || s == g || s == b) { printf(\"%d\\n\", step); break; }\n\t\t\tfor (i = 0; i <= K; i += 2) {\n\t\t\t\tint s2, k2;\n\t\t\t\tk = (s >> i) & 0xf;\n\t\t\t\tk2 = nxt[k];\n\t\t\t\tif (k2 == k) continue;\n\t\t\t\ts2 = (s & ~(0xf << i)) | (k2 << i);\n\t\t\t\tif (!chk[s2]) { chk[s2] = 1, *end = s2; if (++end >= qmax) end = Q; }\n\t\t\t}\n\t\t}\n\t\tif (top >= end) puts(\"NA\");\n\t}\n\treturn 0;\n}", "sampled": "#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n\n#define MAX_LEN 11\n#define MAX_QUEUE 100000\n\ntypedef struct {\n    char state[MAX_LEN];\n    int steps;\n} QueueItem;\n\ntypedef struct {\n    char state[MAX_LEN];\n} HashItem;\n\nHashItem visited[MAX_QUEUE];\nint visited_count;\n\nint hash_string(char* s) {\n    int h = 0;\n    for (int i = 0; s[i]; i++) {\n        h = h * 31 + s[i];\n    }\n    return abs(h) % MAX_QUEUE;\n}\n\nint is_visited(char* s) {\n    for (int i = 0; i < visited_count; i++) {\n        if (strcmp(visited[i].state, s) == 0) {\n            return 1;\n        }\n    }\n    return 0;\n}\n\nvoid add_visited(char* s) {\n    strcpy(visited[visited_count].state, s);\n    visited_count++;\n}\n\nint is_uniform(char* s) {\n    char first = s[0];\n    for (int i = 1; s[i]; i++) {\n        if (s[i] != first) return 0;\n    }\n    return 1;\n}\n\nchar get_third_color(char a, char b) {\n    if ((a == 'r' && b == 'g') || (a == 'g' && b == 'r')) return 'b';\n    if ((a == 'r' && b == 'b') || (a == 'b' && b == 'r')) return 'g';\n    if ((a == 'g' && b == 'b') || (a == 'b' && b == 'g')) return 'r';\n    return a;\n}\n\nint solve(char* initial) {\n    if (is_uniform(initial)) return 0;\n    \n    QueueItem queue[MAX_QUEUE];\n    int front = 0, rear = 0;\n    \n    visited_count = 0;\n    strcpy(queue[rear].state, initial);\n    queue[rear].steps = 0;\n    rear++;\n    add_visited(initial);\n    \n    while (front < rear) {\n        QueueItem current = queue[front++];\n        \n        int len = strlen(current.state);\n        \n        for (int i = 0; i < len - 1; i++) {\n            if (current.state[i] != current.state[i+1]) {\n                char new_state[MAX_LEN];\n                strcpy(new_state, current.state);\n                \n                char new_color = get_third_color(current.state[i], current.state[i+1]);\n                new_state[i] = new_color;\n                new_state[i+1] = new_color;\n                \n                if (is_uniform(new_state)) {\n                    return current.steps + 1;\n                }\n                \n                if (!is_visited(new_state) && rear < MAX_QUEUE) {\n                    strcpy(queue[rear].state, new_state);\n                    queue[rear].steps = current.steps + 1;\n                    rear++;\n                    add_visited(new_state);\n                }\n            }\n        }\n    }\n    \n    return -1;\n}\n\nint main() {\n    char input[MAX_LEN];\n    \n    while (1) {\n        scanf(\"%s\", input);\n        if (strcmp(input, \"0\") == 0) break;\n        \n        int result = solve(input);\n        \n        if (result == -1) {\n            printf(\"NA\\n\");\n        } else {\n            printf(\"%d\\n\", result);\n        }\n    }\n    \n    return 0;\n}\n", "perturbed_sampled": [" <stdlib.h> #define MAX_LEN 11 #define MAX_QUEUE  state[MAX_LEN]; int steps; } QueueItem; typedef struct { char state[MAX_LEN]; } HashItem; HashItem visited[MAX_QUEUE]; int visited_count; int hash_string(char*   { for (int i = 0; i <  s) ==  strcpy(visited[visited_count].state, s); visited_count++; } int is_uniform(char*  s[0]; for  char  && b == 'g')   == 'g' &&  == 'g')) return 'r'; return a; } int  return 0; QueueItem queue[MAX_QUEUE]; int front = 0, rear = 0; visited_count = 0;  rear++;  queue[front++]; int len = strlen(current.state); for (int i = 0; i < len - 1; i++) { if (current.state[i]    (!is_visited(new_state)  current.steps + 1; rear++; add_visited(new_state);  { char input[MAX_LEN]; while (1) { scanf(\"%s\", input);   if (result == -1) { printf(\"NA\\n\"); } else { printf(\"%d\\n\", result); } } return 0; }"], "perturbed_original": ["// Aizu Vol-1 0179: Mysterious Worm // 2017.8.22 bal4u@uu #include <stdio.h> #include  K, mask; int  i, k; char buf[15], *bp; while (1)  == '0') break; memset(chk, 0, sizeof(chk)); for (N = s = 0, bp = buf; *bp; bp++, N +=  'r') k = 0; else if  2; s = (s << 2)  (1 << N) - 1,  0x55555 & mask,  top =  = 0,  < end) { s = *top; if (++top >= qmax)  =   b) { printf(\"%d\\n\",   = (s >> i)  if (k2 == k) continue; s2 = (s & ~(0xf   qmax) end = Q; } } } if  return 0; }"], "original_ll": -1.4419238567352295, "sampled_ll": -0.5523600578308105, "all_perturbed_sampled_ll": [-2.506235361099243], "all_perturbed_original_ll": [-3.3307108879089355], "perturbed_sampled_ll": -2.506235361099243, "perturbed_original_ll": -3.3307108879089355, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import java.awt.geom.Point2D;\nimport java.util.*;\n\n\npublic class Main {\n\tScanner in = new Scanner(System.in);\n\tpublic static void main(String[] args) {\n\t\tnew Main();\n\t}\n\tpublic Main() {\n\n\t\tnew AOJ0179();\n\n\n\t}\n\n\tclass AOJ0179{\n\t\tpublic AOJ0179() {\n\t\t\twhile(true){\n\t\t\t\tString warm = in.next();\n\t\t\t\tif(warm.equals(\"0\"))break;\n\t\t\t\tint ans = get_warm(warm);\n\t\t\t\tSystem.out.println(ans==-1? \"NA\":ans);\n\t\t\t}\n\t\t}\n\t\t\n\t\tint get_warm(String input){\n\t\t\tQueue<String> warm = new LinkedList<String>();\n\t\t\tQueue<Integer> cnt = new LinkedList<Integer>();\n\t\t\tHashMap<String, Boolean> memo = new HashMap<String, Boolean>();\n\t\t\tmemo.put(input,true);\n\t\t\twarm.add(input);\n\t\t\tcnt.add(0);\n\t\t\twhile(warm.size()>0){\n\t\t\t\tString a = warm.remove();\n\t\t\t\tint step = cnt.remove();\n//\t\t\t\tSystem.out.println(a+\" \"+step);//deba\n\t\t\t\tboolean sw = true;\n\t\t\t\tfor(int i=0;i<a.length()-1;i++)if(a.charAt(i)!=a.charAt(i+1))sw=false;\n\t\t\t\tif(sw)return step;\n\t\t\t\t//\u3053\u3053\u304b\u3089\n\t\t\t\tfor(int i=0;i<a.length()-1;i++)if(a.charAt(i)!=a.charAt(i+1)){\n\t\t\t\t\tString b = a.substring(0,i)+getColor(a.charAt(i),a.charAt(i+1))+a.substring(i+2,a.length());\n\t\t\t\t\tif(memo.containsKey(b))continue;\n\t\t\t\t\twarm.add(b);\n\t\t\t\t\tcnt.add(step+1);\n\t\t\t\t\tmemo.put(b, true);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn -1;\n\t\t}\n\t\t\n\t\tString getColor(char a, char b){\n\t\t\tif(a=='r'&&b=='b'||a=='b'&&b=='r')return \"gg\";\n\t\t\telse if(a=='r'&&b=='g'||a=='g'&&b=='r')return \"bb\";\n\t\t\telse return \"rr\";\n\t\t}\n\t\t\n\t}\n\n}", "sampled": "import java.util.*;\n\npublic class Main {\n    static class State {\n        String config;\n        int steps;\n        \n        State(String config, int steps) {\n            this.config = config;\n            this.steps = steps;\n        }\n    }\n    \n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        \n        while (true) {\n            String input = sc.next();\n            if (input.equals(\"0\")) break;\n            \n            int result = solve(input);\n            if (result == -1) {\n                System.out.println(\"NA\");\n            } else {\n                System.out.println(result);\n            }\n        }\n        sc.close();\n    }\n    \n    static int solve(String initial) {\n        if (isUniform(initial)) {\n            return 0;\n        }\n        \n        Queue<State> queue = new LinkedList<>();\n        Set<String> visited = new HashSet<>();\n        \n        queue.offer(new State(initial, 0));\n        visited.add(initial);\n        \n        while (!queue.isEmpty()) {\n            State current = queue.poll();\n            String config = current.config;\n            int steps = current.steps;\n            \n            // Find all adjacent pairs with different colors\n            for (int i = 0; i < config.length() - 1; i++) {\n                if (config.charAt(i) != config.charAt(i + 1)) {\n                    // Change this pair to the third color\n                    char newColor = getThirdColor(config.charAt(i), config.charAt(i + 1));\n                    String newConfig = config.substring(0, i) + newColor + newColor + config.substring(i + 2);\n                    \n                    if (isUniform(newConfig)) {\n                        return steps + 1;\n                    }\n                    \n                    if (!visited.contains(newConfig)) {\n                        visited.add(newConfig);\n                        queue.offer(new State(newConfig, steps + 1));\n                    }\n                }\n            }\n        }\n        \n        return -1;\n    }\n    \n    static boolean isUniform(String s) {\n        if (s.length() == 0) return true;\n        char first = s.charAt(0);\n        for (int i = 1; i < s.length(); i++) {\n            if (s.charAt(i) != first) return false;\n        }\n        return true;\n    }\n    \n    static char getThirdColor(char c1, char c2) {\n        if ((c1 == 'r' && c2 == 'g') || (c1 == 'g' && c2 == 'r')) return 'b';\n        if ((c1 == 'r' && c2 == 'b') || (c1 == 'b' && c2 == 'r')) return 'g';\n        if ((c1 == 'g' && c2 == 'b') || (c1 == 'b' && c2 == 'g')) return 'r';\n        return c1; // Should not happen\n    }\n}\n", "perturbed_sampled": ["import java.util.*; public class Main { static  int steps; State(String config, int steps)  public  String input = sc.next(); if (input.equals(\"0\")) break; int result =     if (isUniform(initial)) { return  State(initial, 0));  steps = current.steps; // Find all adjacent pairs with different  0; i < config.length() - 1;  config.charAt(i + 1)) { // Change this pair  newColor = getThirdColor(config.charAt(i), config.charAt(i + 1)); String newConfig =   0) return true; char first = s.charAt(0); for (int i  i++)  { if  == 'g' && c2 == 'r')) return 'b'; if ((c1 == 'r' && c2 == 'b') || (c1 ==  return 'g';   == 'g')) return 'r'; return c1; // Should not happen } }"], "perturbed_original": ["import java.awt.geom.Point2D; import java.util.*; public class  new Scanner(System.in); public static void main(String[]  public Main()  AOJ0179{ public AOJ0179() { while(true){ String warm =  get_warm(warm); System.out.println(ans==-1? \"NA\":ans); } }  =  Boolean>(); memo.put(input,true); warm.add(input);  warm.remove(); int   for(int  i=0;i<a.length()-1;i++)if(a.charAt(i)!=a.charAt(i+1)){ String b  getColor(char a, char b){ if(a=='r'&&b=='b'||a=='b'&&b=='r')return  }"], "original_ll": -1.0500346422195435, "sampled_ll": -0.4743383824825287, "all_perturbed_sampled_ll": [-2.917551040649414], "all_perturbed_original_ll": [-2.924074649810791], "perturbed_sampled_ll": -2.917551040649414, "perturbed_original_ll": -2.924074649810791, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "from collections import deque\nused = [0]*(3**10)\n\n\nwhile True:\n\ts = raw_input()\n\tif s==\"0\":\n\t\tbreak\n\tn=len(s)\n\tt=0\n\tfor i in range(len(s)):\n\t\tt*=3\n\t\tif s[i]==\"r\":\n\t\t\tt+=0\n\t\tif s[i]==\"g\":\n\t\t\tt+=1\n\t\tif s[i]==\"b\":\n\t\t\tt+=2\n\tf=0\n\tfor i in range(3**n):\n\t\tused[i]=0\n\ttq=[t]\n\tq=deque(tq)\n\tused[t]=1\n\tans=-1\n\tcnt=0\n\twhile len(q)>0:\n\t\tqs=len(q)\n\t\tfor o in range(qs):\n\t\t\ttop=q.popleft()\n\t\t\tv=[0]\n\t\t\tv.pop()\n\t\t\tfor i in range(n):\n\t\t\t\tv.append(top%3)\n\t\t\t\ttop/=3\n\t\t\tok=1\n\t\t\ta=v[0]\n\t\t\tfor i in range(n):\n\t\t\t\tif v[i]!=a:\n\t\t\t\t\tok=0\n\t\t\tif ok==1:\n\t\t\t\tf=1\n\t\t\t\tans=cnt\n\t\t\t\tbreak\n\t\t\tfor i in range(n-1):\n\t\t\t\tif v[i]!=v[i+1]:\n\t\t\t\t\tt1=v[i]\n\t\t\t\t\tt2=v[i+1]\n\t\t\t\t\tv[i]=3-t1-t2\n\t\t\t\t\tv[i+1]=3-t1-t2\n\t\t\t\t\ttmp=0\n\t\t\t\t\tfor j in range(n):\n\t\t\t\t\t\ttmp*=3\n\t\t\t\t\t\ttmp+=v[j]\n\t\t\t\t\tif used[tmp]==0:\n\t\t\t\t\t\tq.append(tmp)\n\t\t\t\t\t\tused[tmp]=1\n\t\t\t\t\tv[i]=t1\n\t\t\t\t\tv[i+1]=t2\n\t\tif f==1:\n\t\t\tbreak\n\t\telse:\n\t\t\tcnt+=1\n\tif ans==-1:\n\t\tprint \"NA\"\n\telse:\n\t\tprint ans", "sampled": "from collections import deque\n\ndef get_other_color(c1, c2):\n    colors = {'r', 'g', 'b'}\n    return list(colors - {c1, c2})[0]\n\ndef get_neighbors(state):\n    neighbors = []\n    for i in range(len(state) - 1):\n        if state[i] != state[i + 1]:\n            new_state = list(state)\n            new_color = get_other_color(state[i], state[i + 1])\n            new_state[i] = new_color\n            new_state[i + 1] = new_color\n            neighbors.append(''.join(new_state))\n    return neighbors\n\ndef solve(state):\n    if len(set(state)) == 1:\n        return 0\n    \n    visited = {state}\n    queue = deque([(state, 0)])\n    \n    while queue:\n        current, steps = queue.popleft()\n        \n        for neighbor in get_neighbors(current):\n            if len(set(neighbor)) == 1:\n                return steps + 1\n            \n            if neighbor not in visited:\n                visited.add(neighbor)\n                queue.append((neighbor, steps + 1))\n    \n    return \"NA\"\n\nwhile True:\n    line = input().strip()\n    if line == \"0\":\n        break\n    print(solve(line))\n", "perturbed_sampled": ["from collections import deque def get_other_color(c1, c2): colors = {'r',  {c1, c2})[0] def   = new_color new_state[i + 1] = new_color neighbors.append(''.join(new_state)) return neighbors def  return  get_neighbors(current): if len(set(neighbor)) == 1: return steps + 1 if neighbor not in visited: visited.add(neighbor) queue.append((neighbor, steps  break print(solve(line))"], "perturbed_original": ["from collections  raw_input() if s==\"0\": break n=len(s) t=0  if s[i]==\"r\":  i  used[t]=1 ans=-1 cnt=0 while  range(qs):  in  for i in range(n): if v[i]!=a: ok=0 if ok==1:  in range(n-1): if  tmp=0 for j in range(n): tmp*=3 tmp+=v[j]  else: cnt+=1  print ans"], "original_ll": -1.0468782186508179, "sampled_ll": -0.7445476651191711, "all_perturbed_sampled_ll": [-3.1579208374023438], "all_perturbed_original_ll": [-3.1756465435028076], "perturbed_sampled_ll": -3.1579208374023438, "perturbed_original_ll": -3.1756465435028076, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "// Aizu Vol-1 0180: Demolition of Bridges\n// 2017.8.9\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#define INF 0x77777777\n#define MAX 100\n#define EMAX 500\nint n;\ntypedef struct { int b, c; } ND;\nND d[MAX + 2][MAX + 2];\nint w[MAX + 2];\nint visited[MAX];\n\nint qsize;\ntypedef struct { int a, b, c; } QUE;\nQUE que[EMAX + 1];\n\n#define PARENT(i) ((i)/2)\n#define LEFT(i)   ((i)<<1)\n#define RIGHT(i)  (((i)<<1)+1)\n\nstatic void min_heapify(int i)\n{\n\tint l, r, smallest;\n\n\tl = LEFT(i), r = RIGHT(i);\n\tif (l < qsize && que[l].c < que[i].c) smallest = l; else smallest = i;\n\tif (r < qsize && que[r].c < que[smallest].c) smallest = r;\n\tif (smallest != i) {\n\t\tQUE t;\n\t\tmemcpy(&t, que + i, sizeof(QUE)), memcpy(que + i, que + smallest, sizeof(QUE));\n\t\tmemcpy(que + smallest, &t, sizeof(QUE));\n\t\tmin_heapify(smallest);\n\t}\n}\n\nint deq(QUE *q)\n{\n\tif (qsize == 0) return -1;\n\tmemcpy(q, &que[0], sizeof(QUE));\n\tmemcpy(que, que + --qsize, sizeof(QUE));\n\tmin_heapify(0);\n\treturn 1;\n}\n\nvoid enq(QUE *q)\n{\n\tint i;\n\n\ti = qsize++;\n\tmemcpy(que + i, q, sizeof(QUE));\n\twhile (i > 0 && que[PARENT(i)].c > que[i].c) {\n\t\tQUE t;\n\t\tmemcpy(&t, que + i, sizeof(QUE)), memcpy(que + i, que + PARENT(i), sizeof(QUE));\n\t\tmemcpy(que + PARENT(i), &t, sizeof(QUE));\n\t\ti = PARENT(i);\n\t}\n}\n\n\nint main()\n{\n\tint m, a, b, c;\n\tint i, k, ans;\n\tQUE q;\n\n\twhile (1) {\n\t\tscanf(\"%d%d\", &n, &m); if (!n) return 0;\n\t\tmemset(w, 0, sizeof(w));\n\t\tfor (i = 0; i < m; i++) {\n\t\t\tscanf(\"%d%d%d\", &a, &b, &c);\n\t\t\td[a][w[a]].b = b, d[a][w[a]++].c = c;\n\t\t\td[b][w[b]].b = a, d[b][w[b]++].c = c;\n\t\t}\n\t\tmemset(visited, 0, sizeof(visited));\n\t\tans = 0, visited[0] = 1, k = 1, qsize = 0;\n\t\tfor (i = 0; i < w[0]; i++) q.a = 0, q.b = d[0][i].b, q.c = d[0][i].c, enq(&q);\n\t\twhile (k < n) {\n\t\t\tdo deq(&q);\n\t\t\twhile (visited[q.a] && visited[q.b]);\n\t\t\tk++;\n\t\t\ta = visited[q.a] ? q.b : q.a;\n\t\t\tvisited[a] = 1, ans += q.c;\n\t\t\tfor (i = 0; i < w[a]; i++) {\n\t\t\t\tb = d[a][i].b;\n\t\t\t\tif (!visited[b]) q.a = a, q.b = b, q.c = d[a][i].c, enq(&q);\n\t\t\t}\n\n\t\t}\n\t\tprintf(\"%d\\n\", ans);\n\t}\n\treturn 0;\n}", "sampled": "#include <stdio.h>\n#include <stdlib.h>\n\ntypedef struct {\n    int a, b, cost;\n} Edge;\n\nint parent[100];\n\nint find(int x) {\n    if (parent[x] == x) return x;\n    return parent[x] = find(parent[x]);\n}\n\nint unite(int x, int y) {\n    x = find(x);\n    y = find(y);\n    if (x == y) return 0;\n    parent[x] = y;\n    return 1;\n}\n\nint compare(const void *a, const void *b) {\n    Edge *ea = (Edge *)a;\n    Edge *eb = (Edge *)b;\n    return ea->cost - eb->cost;\n}\n\nint main() {\n    int n, m;\n    \n    while (1) {\n        scanf(\"%d %d\", &n, &m);\n        if (n == 0 && m == 0) break;\n        \n        Edge edges[500];\n        for (int i = 0; i < m; i++) {\n            scanf(\"%d %d %d\", &edges[i].a, &edges[i].b, &edges[i].cost);\n        }\n        \n        qsort(edges, m, sizeof(Edge), compare);\n        \n        for (int i = 0; i < n; i++) {\n            parent[i] = i;\n        }\n        \n        int total = 0;\n        int count = 0;\n        \n        for (int i = 0; i < m; i++) {\n            if (unite(edges[i].a, edges[i].b)) {\n                total += edges[i].cost;\n                count++;\n                if (count == n - 1) break;\n            }\n        }\n        \n        printf(\"%d\\n\", total);\n    }\n    \n    return 0;\n}\n", "perturbed_sampled": ["#include <stdio.h> #include <stdlib.h> typedef struct { int a, b, cost; } Edge; int parent[100]; int find(int x) { if (parent[x] == x) return    0; parent[x] =  compare(const void *a, const void *b) {  Edge *eb =     (int i = 0; i  %d %d\", &edges[i].a,  sizeof(Edge), compare); for (int i  =  for (int i = 0; i < m; i++) {  1) break;  return 0; }"], "perturbed_original": ["// Aizu Vol-1 0180: Demolition of  #include <stdlib.h>  #define MAX  n; typedef struct { int  2]; int w[MAX + 2]; int visited[MAX]; int qsize; typedef struct { int a, b, c; } QUE; QUE que[EMAX + 1]; #define PARENT(i) ((i)/2)    < qsize && que[l].c < que[i].c)  = i; if (r  que + i, sizeof(QUE)),  == 0) return -1; memcpy(q, &que[0],  } void enq(QUE *q) { int i; i = qsize++; memcpy(que + i, q, sizeof(QUE)); while (i > 0 && que[PARENT(i)].c  que +  &t, sizeof(QUE)); i =   ans;  0, sizeof(w)); for (i =  c; }  0, visited[0] = 1, k = 1, qsize = 0; for (i = 0; i < w[0]; i++) q.a  while (k < n) { do deq(&q); while (visited[q.a] && visited[q.b]); k++;  1, ans +=  q.c = d[a][i].c,  } return 0; }"], "original_ll": -0.8816484212875366, "sampled_ll": -0.351275235414505, "all_perturbed_sampled_ll": [-2.329082489013672], "all_perturbed_original_ll": [-2.6739156246185303], "perturbed_sampled_ll": -2.329082489013672, "perturbed_original_ll": -2.6739156246185303, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import java.util.HashSet;\nimport java.util.Iterator;\nimport java.util.Scanner;\n\npublic class Main {\n\tstatic Scanner sc = new Scanner(System.in);\n\n\tstatic int n, m;\n\tstatic int[][] node;\n\n\n\tpublic static void main(String[] args) {\n\t\twhile(read()){\n\t\t\tsolve();\n\t\t}\n\n\t}\n\n\tstatic boolean read(){\n\t\tn = sc.nextInt();\n\t\tm = sc.nextInt();\n\t\tif(n == 0 && m == 0)  return false;\n\n\t\tnode = new int[n][n];  //\u008b\u0097\u0097\u00a3\u008ds\u0097\u00f1\n\n\t\tfor(int i=0; i<n; i++){\n\t\t\tfor(int j=0; j<n; j++){\n\t\t\t\tif(i==j) node[i][j] = 0;\n\t\t\t\telse     node[i][j] = -1;\n\t\t\t}\n\t\t}\n\n\t\tfor(int i=0; i<m; i++){\n\t\t\tint node1 = sc.nextInt();\n\t\t\tint node2 = sc.nextInt();\n\t\t\tint cost = sc.nextInt();\n\n\t\t\tnode[node1][node2] = cost;\n\t\t\tnode[node2][node1] = cost;\n\t\t}\n\n\t\treturn true;\n\t}\n\n\n\t//\u0083v\u0083\u008a\u0083\u0080\u0096@\n\tstatic void solve(){\n\t\tint sum =0;\n\t\tHashSet<Integer> X = new HashSet<Integer>();  //\u008c\u0088\u0092\u00e8\u008d\u00cf\u0082\u00dd\u008fW\u008d\u0087\n\t\tHashSet<Integer> Y = new HashSet<Integer>();  //\u0096\u00a2\u008c\u0088\u0092\u00e8\u008fW\u008d\u0087\n\n\t\t//\u008fW\u008d\u0087\u0082\u00cc\u008f\u0089\u008a\u00fa\u0089\u00bb\n\t\tX.add(0);\n\t\tfor(int i=1; i<n; i++){\n\t\t\tY.add(i);\n\t\t}\n\n\t\t//\u0096\u00a2\u008c\u0088\u0092\u00e8\u0082\u00cc\u008fW\u008d\u0087\u0082\u00aa\u008b\u00f3\u0082\u00c9\u0082\u00c8\u0082\u00e9\u0082\u00dc\u0082\u00c5\n\t\twhile(!Y.isEmpty()){\n\n\t\t\t//\u008d\u00c5\u008f\u00ac\u0083R\u0083X\u0083g\u0082\u00cc\u0097\u00d7\u0090\u00da\u0083m\u0081[\u0083h\u0082\u00f0\u0092\u00b2\u0082\u00d7\u0082\u00e9\n\t\t\tint min = Integer.MAX_VALUE;\n\t\t\tint min_num = -1, min_num2 = -1;\n\n\t\t\tfor(Iterator<Integer> i1 = X.iterator(); i1.hasNext();){\n\t\t\t\tint n1 = i1.next();\n\t\t\t\tfor (Iterator<Integer> i2 = Y.iterator(); i2.hasNext();){\n\t\t\t\t\tint n2 = i2.next();\n\t\t\t\t\tif(node[n1][n2] == -1)  continue;\n\n\t\t\t\t\tif(min > node[n1][n2]){\n\t\t\t\t\t\tmin = node[n1][n2];\n\t\t\t\t\t\tmin_num = n1;\n\t\t\t\t\t\tmin_num2 = n2;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tsum += node[min_num][min_num2];\n\t\t\tY.remove(min_num2);\n\t\t\tX.add(min_num2);\n\t\t}\n\n\t\tSystem.out.println(sum);  //\u008fo\u0097\u00cd\n\t}\n}", "sampled": "import java.util.*;\n\npublic class Main {\n    static class Edge implements Comparable<Edge> {\n        int u, v, cost;\n        \n        Edge(int u, int v, int cost) {\n            this.u = u;\n            this.v = v;\n            this.cost = cost;\n        }\n        \n        @Override\n        public int compareTo(Edge other) {\n            return this.cost - other.cost;\n        }\n    }\n    \n    static class UnionFind {\n        int[] parent;\n        int[] rank;\n        \n        UnionFind(int n) {\n            parent = new int[n];\n            rank = new int[n];\n            for (int i = 0; i < n; i++) {\n                parent[i] = i;\n                rank[i] = 0;\n            }\n        }\n        \n        int find(int x) {\n            if (parent[x] != x) {\n                parent[x] = find(parent[x]);\n            }\n            return parent[x];\n        }\n        \n        boolean union(int x, int y) {\n            int rootX = find(x);\n            int rootY = find(y);\n            \n            if (rootX == rootY) {\n                return false;\n            }\n            \n            if (rank[rootX] < rank[rootY]) {\n                parent[rootX] = rootY;\n            } else if (rank[rootX] > rank[rootY]) {\n                parent[rootY] = rootX;\n            } else {\n                parent[rootY] = rootX;\n                rank[rootX]++;\n            }\n            \n            return true;\n        }\n    }\n    \n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        \n        while (true) {\n            int n = sc.nextInt();\n            int m = sc.nextInt();\n            \n            if (n == 0 && m == 0) {\n                break;\n            }\n            \n            List<Edge> edges = new ArrayList<>();\n            \n            for (int i = 0; i < m; i++) {\n                int a = sc.nextInt();\n                int b = sc.nextInt();\n                int cost = sc.nextInt();\n                edges.add(new Edge(a, b, cost));\n            }\n            \n            Collections.sort(edges);\n            \n            UnionFind uf = new UnionFind(n);\n            int totalCost = 0;\n            int edgeCount = 0;\n            \n            for (Edge edge : edges) {\n                if (uf.union(edge.u, edge.v)) {\n                    totalCost += edge.cost;\n                    edgeCount++;\n                    if (edgeCount == n - 1) {\n                        break;\n                    }\n                }\n            }\n            \n            System.out.println(totalCost);\n        }\n        \n        sc.close();\n    }\n}\n", "perturbed_sampled": ["import java.util.*;  cost; Edge(int u,  return this.cost  class UnionFind {  n) {  = new int[n]; for (int i = 0; i < n; i++) { parent[i]   x)  return parent[x]; } boolean union(int x, int y) { int rootX = find(x); int rootY = find(y); if (rootX == rootY)  (rank[rootX] < rank[rootY]) { parent[rootX] = rootY; } else if (rank[rootX]  rootX;   void main(String[] args)  Scanner(System.in);  = sc.nextInt(); int m = sc.nextInt(); if (n == 0 && m  List<Edge> edges  i =    Collections.sort(edges); UnionFind uf  edge  edge.cost; edgeCount++; if (edgeCount  break; } }  }"], "perturbed_original": ["import java.util.HashSet; import java.util.Iterator; import java.util.Scanner; public class Main {  m; static  main(String[] args) { while(read()){ solve(); } } static boolean read(){ n = sc.nextInt(); m  && m == 0) return false;  for(int j=0;  0;  } for(int i=0;  sc.nextInt();  = cost; node[node2][node1] = cost; }  void solve(){ int sum =0; HashSet<Integer>  HashSet<Integer>  //\u008fW\u008d\u0087\u0082\u00cc\u008f\u0089\u008a\u00fa\u0089\u00bb X.add(0); for(int i=1; i<n; i++){ Y.add(i); } //\u0096\u00a2\u008c\u0088\u0092\u00e8\u0082\u00cc\u008fW\u008d\u0087\u0082\u00aa\u008b\u00f3\u0082\u00c9\u0082\u00c8\u0082\u00e9\u0082\u00dc\u0082\u00c5 while(!Y.isEmpty()){ //\u008d\u00c5\u008f\u00ac\u0083R\u0083X\u0083g\u0082\u00cc\u0097\u00d7\u0090\u00da\u0083m\u0081[\u0083h\u0082\u00f0\u0092\u00b2\u0082\u00d7\u0082\u00e9 int  = -1, min_num2   node[min_num][min_num2];  } }"], "original_ll": -1.3004319667816162, "sampled_ll": -0.1961108148097992, "all_perturbed_sampled_ll": [-2.294685125350952], "all_perturbed_original_ll": [-2.934209108352661], "perturbed_sampled_ll": -2.294685125350952, "perturbed_original_ll": -2.934209108352661, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "def f(s, cost, route, ans):\n    route.append(s)\n    ans += cost[s]\n    del cost[s]\n    for k, c in data.items():\n        if s in k:\n            a, b = k\n            if s == a:\n                if not b in route:\n                    if not b in cost or c < cost[b]:\n                        cost[b] = c\n                        del data[(a, b)]\n            elif s == b:\n                if not a in route:\n                    if not a in cost or c < cost[a]:\n                        cost[a] = c\n                        del data[(a, b)]\n    if cost:\n        s = sorted(cost.items(), key=lambda x: x[1])[0][0]\n        return f(s, cost, route, ans)\n    return ans\n\nwhile 1:\n    n, m = map(int, raw_input().split())\n    if n == m == 0: break\n    data = {}\n    for i in range(m):\n        a, b, c = map(int, raw_input().split())\n        data[(a, b)] = c\n    print f(0, {0:0}, [], 0)", "sampled": "import sys\nfrom typing import List, Tuple\n\nclass UnionFind:\n    def __init__(self, n: int):\n        self.parent = list(range(n))\n        self.rank = [0] * n\n    \n    def find(self, x: int) -> int:\n        if self.parent[x] != x:\n            self.parent[x] = self.find(self.parent[x])\n        return self.parent[x]\n    \n    def union(self, x: int, y: int) -> bool:\n        root_x = self.find(x)\n        root_y = self.find(y)\n        \n        if root_x == root_y:\n            return False\n        \n        if self.rank[root_x] < self.rank[root_y]:\n            self.parent[root_x] = root_y\n        elif self.rank[root_x] > self.rank[root_y]:\n            self.parent[root_y] = root_x\n        else:\n            self.parent[root_y] = root_x\n            self.rank[root_x] += 1\n        \n        return True\n\ndef kruskal(n: int, edges: List[Tuple[int, int, int]]) -> int:\n    edges.sort(key=lambda x: x[2])\n    uf = UnionFind(n)\n    total_cost = 0\n    edges_added = 0\n    \n    for a, b, cost in edges:\n        if uf.union(a, b):\n            total_cost += cost\n            edges_added += 1\n            if edges_added == n - 1:\n                break\n    \n    return total_cost\n\ndef main():\n    input_lines = sys.stdin.read().strip().split('\\n')\n    i = 0\n    \n    while i < len(input_lines):\n        line = input_lines[i].strip()\n        if not line:\n            i += 1\n            continue\n        \n        parts = line.split()\n        n, m = int(parts[0]), int(parts[1])\n        \n        if n == 0 and m == 0:\n            break\n        \n        i += 1\n        edges = []\n        \n        for j in range(m):\n            line = input_lines[i].strip()\n            parts = line.split()\n            a, b, cost = int(parts[0]), int(parts[1]), int(parts[2])\n            edges.append((a, b, cost))\n            i += 1\n        \n        result = kruskal(n, edges)\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "perturbed_sampled": ["import sys  n: int): self.parent = list(range(n)) self.rank  find(self,  self.parent[x] != x: self.parent[x] = self.find(self.parent[x]) return self.parent[x]  root_y: return False if self.rank[root_x] < self.rank[root_y]: self.parent[root_x] =    UnionFind(n)  uf.union(a,  main(): input_lines = sys.stdin.read().strip().split('\\n') i = 0 while i < len(input_lines): line = input_lines[i].strip()  1 continue parts  int(parts[0]), int(parts[1]) if n == 0  = [] for j in range(m): line = input_lines[i].strip() parts = line.split() a, b, cost = int(parts[0]), int(parts[1]), int(parts[2]) edges.append((a, b, cost)) i  == \"__main__\": main()"], "perturbed_original": ["def f(s, cost, route, ans):  in data.items(): if  = k if s == a: if  not b in cost or c <  a  in cost or  if cost: s = sorted(cost.items(), key=lambda  route,  n,  0: break data  range(m): a,  data[(a, b)]  [], 0)"], "original_ll": -1.0400856733322144, "sampled_ll": -0.3186566233634949, "all_perturbed_sampled_ll": [-2.3304312229156494], "all_perturbed_original_ll": [-4.287196159362793], "perturbed_sampled_ll": -2.3304312229156494, "perturbed_original_ll": -4.287196159362793, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "#include <stdio.h>\nint main(void){\n\tint m,n,q,r,a,i,j,t[100],s;\n\tfor(;scanf(\"%d%d\",&m,&n),m;printf(\"%d\\n\",q)){\n\t\tfor(s=i=q=0;i<n;i++){\n\t\t\tscanf(\"%d\",&a);\n\t\t\tt[i]=a;\n\t\t\ts+=a;\n\t\t\tif(q<a)q=a;\n\t\t}\n\t\tr=s>1500000?1500000:s;\n\t\tfor(;q<r;){\n\t\t\tj=m;\n\t\t\ta=q+r>>1;\n\t\t\ts=0;\n\t\t\tfor(i=0;i<n;i++){\n\t\t\t\ts+=t[i];\n\t\t\t\tif(s>a){\n\t\t\t\t\tif(!--j)break;\n\t\t\t\t\ts=t[i];\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(i==n){\tr=a;\t}\n\t\t\telse{\tq=a+1;\t}\n\t\t}\n\t}\n\treturn 0;\n}", "sampled": "#include <stdio.h>\n#include <string.h>\n\nint m, n;\nint w[105];\nint dp[105][25];\n\nint max(int a, int b) {\n    return a > b ? a : b;\n}\n\nint solve(int pos, int shelves) {\n    if (pos == n) {\n        if (shelves == 0) return 0;\n        return 1e9;\n    }\n    if (shelves == 0) return 1e9;\n    \n    if (dp[pos][shelves] != -1) return dp[pos][shelves];\n    \n    int result = 1e9;\n    int sum = 0;\n    \n    for (int i = pos; i < n; i++) {\n        sum += w[i];\n        int remaining = solve(i + 1, shelves - 1);\n        if (remaining != 1e9) {\n            result = result < max(sum, remaining) ? result : max(sum, remaining);\n        }\n    }\n    \n    dp[pos][shelves] = result;\n    return result;\n}\n\nint main() {\n    while (1) {\n        scanf(\"%d %d\", &m, &n);\n        if (m == 0 && n == 0) break;\n        \n        for (int i = 0; i < n; i++) {\n            scanf(\"%d\", &w[i]);\n        }\n        \n        memset(dp, -1, sizeof(dp));\n        printf(\"%d\\n\", solve(0, m));\n    }\n    \n    return 0;\n}\n", "perturbed_sampled": [" return a > b ? a : b; } int solve(int pos, int   = 1e9; int sum =  i++) { sum += w[i]; int remaining =  1); if (remaining != 1e9) { result = result < max(sum, remaining) ?  &n); if (m == 0 && n  i = 0; i < n; i++) { scanf(\"%d\", &w[i]); }  m)); } return 0; }"], "perturbed_original": ["#include  for(;scanf(\"%d%d\",&m,&n),m;printf(\"%d\\n\",q)){ for(s=i=q=0;i<n;i++){ scanf(\"%d\",&a); t[i]=a; s+=a; if(q<a)q=a; } r=s>1500000?1500000:s; for(;q<r;){ j=m;   0; }"], "original_ll": -1.5560170412063599, "sampled_ll": -0.5480055212974548, "all_perturbed_sampled_ll": [-2.9777491092681885], "all_perturbed_original_ll": [-2.6036455631256104], "perturbed_sampled_ll": -2.9777491092681885, "perturbed_original_ll": -2.6036455631256104, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import java.util.Scanner;\n\npublic class Main {\n\tstatic int n, m;\n\tstatic int book[];\n\n\tpublic static int binarySearch(int low, int high) {\n\t\tif (high - low <= 0) {\n\t\t\treturn high;\n\t\t}\n\t\tint mid = (low + high) / 2;\n\t\tint shellId = 0;\n\t\tint sumWidth = 0;\n\t\tfor (int i = 0; i < m; i++) {\n\t\t\tif (mid < sumWidth + book[i]) {\n\t\t\t\tshellId++;\n\t\t\t\tsumWidth = book[i];\n\t\t\t} else {\n\t\t\t\tsumWidth += book[i];\n\t\t\t}\n\t\t}\n\n\t\tif (n <= shellId) {\n\t\t\treturn binarySearch(mid + 1, high);\n\t\t} else {\n\t\t\treturn binarySearch(low, mid);\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint max;\n\n\t\twhile (true) {\n\t\t\tn = sc.nextInt();//tana\n\t\t\tm = sc.nextInt();//kann\n\t\t\tif ((n | m) == 0) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbook = new int[m];\n\t\t\tmax = 0;\n\t\t\tfor (int i = 0; i < m; i++) {\n\t\t\t\tbook[i] = sc.nextInt();\n\t\t\t\tmax = Math.max(max, book[i]);\n\t\t\t}\n\n\t\t\tSystem.out.println(binarySearch(max, 1500000));\n\t\t}\n\t}\n}", "sampled": "import java.util.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        \n        while (true) {\n            int m = sc.nextInt();\n            int n = sc.nextInt();\n            \n            if (m == 0 && n == 0) break;\n            \n            int[] w = new int[n];\n            for (int i = 0; i < n; i++) {\n                w[i] = sc.nextInt();\n            }\n            \n            // Binary search on the width\n            int left = 0;\n            int right = 1500000;\n            \n            // Find the minimum of maximum widths\n            for (int i = 0; i < n; i++) {\n                left = Math.max(left, w[i]);\n            }\n            \n            while (left < right) {\n                int mid = (left + right) / 2;\n                if (canFit(w, n, m, mid)) {\n                    right = mid;\n                } else {\n                    left = mid + 1;\n                }\n            }\n            \n            System.out.println(left);\n        }\n        \n        sc.close();\n    }\n    \n    private static boolean canFit(int[] w, int n, int m, int maxWidth) {\n        int shelves = 1;\n        int currentWidth = 0;\n        \n        for (int i = 0; i < n; i++) {\n            if (currentWidth + w[i] <= maxWidth) {\n                currentWidth += w[i];\n            } else {\n                shelves++;\n                currentWidth = w[i];\n                if (shelves > m) {\n                    return false;\n                }\n            }\n        }\n        \n        return true;\n    }\n}\n", "perturbed_sampled": ["import java.util.*; public class <extra_id_4>if (currentWidth<extra_id_5>{<extra_id_6>= w[i] - maxWidth;<extra_id_7>int currentWidth; main(String[] args) { Scanner sc = new Scanner(System.in); while (true) { int } while (left<extra_id_8>|| currentWidth<extra_id_9>{ m = m; return<extra_id_10>} } return false;<extra_id_11>double<extra_id_12>d = Math.pow(n, n);<extra_id_13>int maxX =<extra_id_14>[n];<extra_id_15>m > maxWidth)<extra_id_16>currentWidth<extra_id_17>; for<extra_id_18> == 0  0; int  the minimum of maximum widths for (int i = 0;  left = Math.max(left, w[i]); } while (left <  (left  {  {  boolean  m, int maxWidth) { int shelves = 1; int  i = 0; i < n; i++) { if (currentWidth + w[i] <=  currentWidth = w[i];  } return true; } }"], "perturbed_original": ["import java.util.Scanner; <extra_id_5>return<extra_id_6>}<extra_id_7>++) {<extra_id_8>; } else if<extra_id_9>i) {<extra_id_10>;<extra_id_11>m++) {<extra_id_12>] ) ; //kann }<extra_id_13>in; } int<extra_id_14>if ( Math<extra_id_15>.<extra_id_16>( m )<extra_id_17>( int    { return high; } int  / 2; int shellId = 0;  i < m; i++) { if (mid < sumWidth  = book[i]; } else { sumWidth += book[i]; }  { return binarySearch(low,  void main(String[]  new Scanner(System.in); int  sc.nextInt();//kann if ((n | m) == 0) { break; }    sc.nextInt(); max = Math.max(max, book[i]);  }"], "original_ll": -0.88388592004776, "sampled_ll": -0.5126283764839172, "all_perturbed_sampled_ll": [-2.6199748516082764], "all_perturbed_original_ll": [-2.962111234664917], "perturbed_sampled_ll": -2.6199748516082764, "perturbed_original_ll": -2.962111234664917, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "def hondan(w,m):\n    m_sum = b_lis[0]\n    num = 0\n    if w < max(b_lis):\n        return False\n    else:\n        for i in range(len(b_lis) - 1):\n            m_sum += b_lis[i + 1]\n            if m_sum > w:\n\n                m_sum = b_lis[i + 1]\n                num += 1\n\n        if num < m:\n            return True\n        else:\n            return False\n        \ndef nibutan(f_id,e_id,m):\n    \n    \n    m_id = int((f_id + e_id) / 2)\n    m_bo = hondan(m_id,m)\n\n\n    if (f_id > e_id):\n        return m_id + 1\n    else:\n        if m_bo:\n            return(nibutan(f_id,m_id -1,m))\n        elif not m_bo:\n            return(nibutan(m_id + 1,e_id,m))\n        else:\n            return m_id + 1\n\n\n\nwhile True:\n    global w_lis\n    b_lis = []\n    w_lis = []\n    dan_num = [0]\n\n    m,n = map(int,input().split())\n    if m == n == 0:\n        break\n    for i in range(n):\n        num = int(input())\n        b_lis.append(num)\n    s_num = int(sum(b_lis) /m)\n\n    print(nibutan(s_num,1500000,m) )", "sampled": "def can_fit(books, m, max_width):\n    shelves_used = 1\n    current_width = 0\n    \n    for book in books:\n        if book > max_width:\n            return False\n        if current_width + book > max_width:\n            shelves_used += 1\n            current_width = book\n            if shelves_used > m:\n                return False\n        else:\n            current_width += book\n    \n    return True\n\ndef solve(m, n, books):\n    left = max(books)\n    right = sum(books)\n    \n    result = right\n    \n    while left <= right:\n        mid = (left + right) // 2\n        if can_fit(books, m, mid):\n            result = mid\n            right = mid - 1\n        else:\n            left = mid + 1\n    \n    return result\n\nwhile True:\n    line = input().split()\n    m, n = int(line[0]), int(line[1])\n    \n    if m == 0 and n == 0:\n        break\n    \n    books = []\n    for _ in range(n):\n        books.append(int(input()))\n    \n    print(solve(m, n, books))\n", "perturbed_sampled": ["def can_fit(books, m, max_width): shelves_used =  book in  shelves_used  if shelves_used > m: return False else: current_width += book  mid): result = mid right = mid - 1 else:  return result while True:  = int(line[0]),  and n == 0: break books = [] for _  books))"], "perturbed_original": [" num = 0 if w <  > w: m_sum = b_lis[i + 1] num += 1 if num  m_id =  m_bo = hondan(m_id,m) if (f_id > e_id): return m_id +  -1,m)) elif not m_bo: return(nibutan(m_id + 1,e_id,m)) else: return  global w_lis b_lis  dan_num = [0]   print(nibutan(s_num,1500000,m) )"], "original_ll": -1.5452972650527954, "sampled_ll": -0.6672963500022888, "all_perturbed_sampled_ll": [-3.754739284515381], "all_perturbed_original_ll": [-3.8696818351745605], "perturbed_sampled_ll": -3.754739284515381, "perturbed_original_ll": -3.8696818351745605, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "#include <stdio.h>\n#include <stdlib.h>\n\nint b[50]; // beaker status\nint d[50]; // used status\nint f[50]; // filled status\n\nint compare(const void *a, const void *b) {\n  return *(int *)b - *(int *)a;\n}\n\nint dcheck(int n) {\n  int i, r;\n  for (i = 0, r = 0; i < n; i++)\n    r += d[i];\n  if (r == n)\n    return 1;\n  else\n    return 0;\n}\n\nint beaker(int n, int m) {\n  int i, t;\n  f[m] = 0;\n  d[m] = 1;\n\n  if (n == 1) return 1;\n  for (i = m + 1, t = b[m]; i < n; i++) {\n    if (t >= b[i] && f[i] == 0) {\n      t -= b[i];\n      d[i] = f[i] = 1;\n    }\n    if (t == 0)\n      if (dcheck(n))\n        return 1;\n      else\n        beaker(n, m + 1);\n  }\n  return 0;\n}\n\nvoid init() {\n  int i;\n  for (i = 0; i < 50; i++)\n    b[i] = f[i] = d[i] = 0;\n  return;\n}\n\nint main() {\n  int i, n, m;\n\n  for (;;) {\n    scanf(\"%d\", &n);\n    if (n == 0)\n      return 0;\n    init();\n    for (i = 0; i < n; i++)\n      scanf(\"%d\", &b[i]);\n    qsort(b, n, sizeof(int), compare);\n    m = 0; // set max value posion\n    printf(\"%s\", beaker(n, m) ? \"YES\\n\" : \"NO\\n\");\n  }\n  return -1;\n}", "sampled": "#include <stdio.h>\n#include <stdlib.h>\n\nint compare(const void *a, const void *b) {\n    return (*(int*)b - *(int*)a);\n}\n\nint canFill(int *beakers, int n) {\n    int *filled = (int*)calloc(n, sizeof(int));\n    int i, j;\n    \n    filled[0] = beakers[0];\n    \n    for (i = 0; i < n; i++) {\n        if (filled[i] == 0) continue;\n        \n        int water = filled[i];\n        \n        for (j = 0; j < n && water > 0; j++) {\n            if (filled[j] == 0) {\n                int toFill = beakers[j];\n                if (water >= toFill) {\n                    filled[j] = toFill;\n                    water -= toFill;\n                }\n            }\n        }\n        \n        if (water > 0) {\n            free(filled);\n            return 0;\n        }\n    }\n    \n    for (i = 0; i < n; i++) {\n        if (filled[i] == 0) {\n            free(filled);\n            return 0;\n        }\n    }\n    \n    free(filled);\n    return 1;\n}\n\nint solve(int *beakers, int n, int index, long long water, int *used) {\n    if (water < 0) return 0;\n    \n    if (index == n) {\n        return (water == 0);\n    }\n    \n    if (used[index]) {\n        return solve(beakers, n, index + 1, water, used);\n    }\n    \n    if (water >= beakers[index]) {\n        used[index] = 1;\n        if (solve(beakers, n, 0, water - beakers[index], used)) {\n            used[index] = 0;\n            return 1;\n        }\n        used[index] = 0;\n    }\n    \n    return solve(beakers, n, index + 1, water, used);\n}\n\nint canFillRecursive(int *beakers, int n, int current, int *used) {\n    if (current == n) {\n        for (int i = 0; i < n; i++) {\n            if (!used[i]) return 0;\n        }\n        return 1;\n    }\n    \n    if (!used[current]) return 0;\n    \n    long long water = beakers[current];\n    int *newUsed = (int*)malloc(n * sizeof(int));\n    for (int i = 0; i < n; i++) newUsed[i] = used[i];\n    \n    if (solve(beakers, n, 0, water, newUsed)) {\n        if (canFillRecursive(beakers, n, current + 1, newUsed)) {\n            free(newUsed);\n            return 1;\n        }\n    }\n    \n    free(newUsed);\n    return 0;\n}\n\nint main() {\n    int n;\n    \n    while (scanf(\"%d\", &n) == 1 && n != 0) {\n        int *beakers = (int*)malloc(n * sizeof(int));\n        \n        for (int i = 0; i < n; i++) {\n            scanf(\"%d\", &beakers[i]);\n        }\n        \n        qsort(beakers, n, sizeof(int), compare);\n        \n        if (n == 1) {\n            printf(\"YES\\n\");\n            free(beakers);\n            continue;\n        }\n        \n        int *used = (int*)calloc(n, sizeof(int));\n        used[0] = 1;\n        \n        if (canFillRecursive(beakers, n, 0, used)) {\n            printf(\"YES\\n\");\n        } else {\n            printf(\"NO\\n\");\n        }\n        \n        free(used);\n        free(beakers);\n    }\n    \n    return 0;\n}\n", "perturbed_sampled": ["#include  *b) { return (*(int*)b - *(int*)a); } int  int *filled = (int*)calloc(n, sizeof(int));  i++) { if (filled[i] ==  filled[i]; for (j =  water >  filled[j] =  return 0; } } for (i =  { if (filled[i]   1; } int solve(int  <  solve(beakers, n, index + 1, water, used); } if (water >= beakers[index]) {  n, 0, water - beakers[index],  solve(beakers,  *beakers, int n, int current, int  n) { for (int i = 0; i < n; i++) { if (!used[i]) return 0; } return 1; } if  water = beakers[current]; int *newUsed = (int*)malloc(n *  0; i < n;  (solve(beakers, n,  (canFillRecursive(beakers, n, current + 1, newUsed)) {   main() { int  1 && n !=  (int*)malloc(n * sizeof(int)); for (int i = 0; i < n; i++) { scanf(\"%d\",   return 0; }"], "perturbed_original": ["#include  int f[50]; //    n) { int i, r; for (i  i  return  int m) { int i, t; f[m] = 0; d[m] = 1;  1; for (i = m + 1, t = b[m]; i < n;  b[i]  = f[i] =  0) if (dcheck(n))   = 0; i < 50; i++) b[i]   { int i,  == 0) return 0; init(); for (i = 0; i  qsort(b, n, sizeof(int), compare); m = 0; // set  }"], "original_ll": -0.9560869336128235, "sampled_ll": -0.4946739375591278, "all_perturbed_sampled_ll": [-2.563913345336914], "all_perturbed_original_ll": [-2.8173234462738037], "perturbed_sampled_ll": -2.563913345336914, "perturbed_original_ll": -2.8173234462738037, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import java.util.Arrays;\nimport java.util.Scanner;\n\n//Beaker\npublic class Main{\n\n\tint n;\n\tint[] a;\n\tboolean[] have, t;\n\t\n\tboolean dfs(int k, int rest){\n\t\tif(rest==0){\n\t\t\tfor(int i=0;i<n;i++)t[i]=have[i];\n\t\t\treturn greedy();\n\t\t}\n\t\tif(rest < a[k])return false;\n\t\thave[k] = true;\n\t\tif(dfs(k+1, rest-a[k]))return true;\n\t\thave[k] = false;\n\t\treturn dfs(k+1, rest);\n\t}\n\t\n\tboolean choice(int k, int rest){\n\t\tif(rest==0)return true;\n\t\tif(k<0)return false;\n\t\tif(!t[k])return choice(k-1, rest);\n\t\tif(a[k]<=rest){\n\t\t\tt[k] = false;\n\t\t\tif(choice(k-1, rest-a[k]))return true;\n\t\t\tt[k] = true;\n\t\t}\n\t\treturn choice(k-1, rest);\n\t}\n\t\n\tboolean greedy(){\n\t\tfor(int i=0;i<n;i++)if(!t[i]){\n\t\t\tif(!choice(i-1, a[i]))return false;\n\t\t\tt[i] = true;\n\t\t}\n\t\treturn true;\n\t}\n\t\n\tvoid run(){\n\t\tScanner sc = new Scanner(System.in);\n\t\tt = new boolean[100];\n\t\thave = new boolean[100];\n\t\tfor(;;){\n\t\t\tn = sc.nextInt();\n\t\t\tif(n==0)break;\n\t\t\ta = new int[n];\n\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\ta[i] = sc.nextInt();\n\t\t\t}\n\t\t\tArrays.sort(a);\n\t\t\tArrays.fill(have, false);\n\t\t\thave[0] = true;\n\t\t\tSystem.out.println(dfs(1, a[n-1]-a[0])?\"YES\":\"NO\");\n\t\t}\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}", "sampled": "import java.util.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        \n        while (true) {\n            int n = sc.nextInt();\n            if (n == 0) break;\n            \n            int[] beakers = new int[n];\n            for (int i = 0; i < n; i++) {\n                beakers[i] = sc.nextInt();\n            }\n            \n            if (canFillAll(beakers)) {\n                System.out.println(\"YES\");\n            } else {\n                System.out.println(\"NO\");\n            }\n        }\n        \n        sc.close();\n    }\n    \n    static boolean canFillAll(int[] beakers) {\n        int n = beakers.length;\n        if (n == 1) return true;\n        \n        Arrays.sort(beakers);\n        int maxIdx = n - 1;\n        \n        return dfs(beakers, new boolean[n], maxIdx, beakers[maxIdx]);\n    }\n    \n    static boolean dfs(int[] beakers, boolean[] used, int currentIdx, int currentWater) {\n        used[currentIdx] = true;\n        \n        if (allUsed(used)) {\n            return true;\n        }\n        \n        return tryPour(beakers, used, currentWater, 0);\n    }\n    \n    static boolean tryPour(int[] beakers, boolean[] used, int water, int startIdx) {\n        if (water == 0) {\n            for (int i = beakers.length - 1; i >= 0; i--) {\n                if (!used[i]) {\n                    boolean[] newUsed = used.clone();\n                    if (dfs(beakers, newUsed, i, beakers[i])) {\n                        return true;\n                    }\n                }\n            }\n            return false;\n        }\n        \n        for (int i = startIdx; i < beakers.length; i++) {\n            if (!used[i] && beakers[i] <= water) {\n                boolean[] newUsed = used.clone();\n                if (tryPour(beakers, newUsed, water - beakers[i], i + 1)) {\n                    return true;\n                }\n            }\n        }\n        \n        return false;\n    }\n    \n    static boolean allUsed(boolean[] used) {\n        for (boolean u : used) {\n            if (!u) return false;\n        }\n        return true;\n    }\n}\n", "perturbed_sampled": ["import java.util.*; public class Main { public static void main(String[] args) { Scanner <extra_id_5>return<extra_id_6>} } }<extra_id_7>if (1 === i)<extra_id_8>//continue; //TODO<extra_id_9>return true; }<extra_id_10>{ int<extra_id_11>//int<extra_id_12>//int i; for (int<extra_id_13>[ -1] ><extra_id_14>int i++ ){<extra_id_15>int<extra_id_16>} if (dfs(beakers,<extra_id_17><= startIdx;<extra_id_18>int<extra_id_19>;<extra_id_20>0; } } }  0) break; int[] beakers = new int[n]; for  <   System.out.println(\"NO\"); } } sc.close(); } static   ==  1; return dfs(beakers, new  used, int currentIdx, int  if  0); } static boolean tryPour(int[] beakers, boolean[]  { if  (int i = beakers.length -  if (dfs(beakers,  (int i = startIdx; i < beakers.length; i++)   newUsed, water - beakers[i], i + 1)) { return true; } } } return false; } static   }"], "perturbed_original": [" public class Main{  k, int rest){ if(rest==0){ for(int i=0;i<n;i++)t[i]=have[i]; return greedy(); } if(rest  true; if(dfs(k+1, rest-a[k]))return true;   false; if(choice(k-1, rest-a[k]))return  boolean greedy(){ for(int i=0;i<n;i++)if(!t[i]){ if(!choice(i-1, a[i]))return false; t[i] = true; } return  sc =  boolean[100]; have =  new int[n]; for(int i=0;i<n;i++){ a[i] = sc.nextInt(); } Arrays.sort(a);  public static  Main().run(); } }"], "original_ll": -0.825313925743103, "sampled_ll": -0.5352585911750793, "all_perturbed_sampled_ll": [-2.7600202560424805], "all_perturbed_original_ll": [-2.7328333854675293], "perturbed_sampled_ll": -2.7600202560424805, "perturbed_original_ll": -2.7328333854675293, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "while True:\n    n = int(input())\n    if n == 0: break\n    beakers = list(map(int, input().split()))\n    m = max(beakers)\n    beakers.remove(m)\n    beakers.sort()\n    if beakers:\n        beakersum = [beakers[0]]\n        del beakers[0]\n    else:\n        print(\"YES\")\n        continue\n\n    if sum(beakers) < m:\n        print(\"NO\")\n        continue\n    elif sum(beakers) == m:\n        print(\"YES\")\n        continue\n\n    for b in beakers:\n        tmp = [bks + b for bks in beakersum if bks + b <= m]\n        beakersum.extend(tmp)\n        if m in beakersum:\n            break\n    \n    if m in beakersum:\n        print(\"YES\")\n    else:\n        print(\"NO\")\n            \n        ", "sampled": "def can_fill_all_beakers(beakers):\n    n = len(beakers)\n    if n == 1:\n        return True\n    \n    beakers_sorted = sorted(beakers, reverse=True)\n    max_beaker = beakers_sorted[0]\n    \n    # Try DFS to see if we can fill all beakers\n    def dfs(filled, current_water):\n        if len(filled) == n:\n            return current_water == 0\n        \n        if current_water == 0:\n            return False\n        \n        # Try to fill each unfilled beaker\n        for i in range(n):\n            if i not in filled:\n                beaker_capacity = beakers_sorted[i]\n                if beaker_capacity <= current_water:\n                    # Fill this beaker\n                    new_filled = filled | {i}\n                    new_water = current_water - beaker_capacity + beaker_capacity\n                    # After filling, we pour out this beaker's water\n                    if dfs(new_filled, new_water):\n                        return True\n        \n        return False\n    \n    # Different approach: simulate the process\n    # Start with largest beaker filled\n    def solve():\n        # Use bitmask DP or backtracking\n        # State: which beakers have been filled\n        from functools import lru_cache\n        \n        @lru_cache(maxsize=None)\n        def can_fill(filled_mask, available_water):\n            if filled_mask == (1 << n) - 1:\n                return available_water == 0\n            \n            if available_water == 0:\n                return False\n            \n            # Try filling each unfilled beaker\n            for i in range(n):\n                if not (filled_mask & (1 << i)):\n                    capacity = beakers_sorted[i]\n                    if capacity <= available_water:\n                        # Fill beaker i\n                        new_mask = filled_mask | (1 << i)\n                        new_water = available_water - capacity + capacity\n                        if can_fill(new_mask, new_water):\n                            return True\n            \n            return False\n        \n        # Start with the largest beaker (index 0) filled\n        initial_mask = 1\n        initial_water = max_beaker\n        return can_fill(initial_mask, initial_water)\n    \n    return solve()\n\nwhile True:\n    n = int(input())\n    if n == 0:\n        break\n    \n    beakers = list(map(int, input().split()))\n    \n    if can_fill_all_beakers(beakers):\n        print(\"YES\")\n    else:\n        print(\"NO\")\n", "perturbed_sampled": ["def  n == 1:  dfs(filled, current_water): if len(filled) == n: return current_water ==    beaker_capacity  beaker new_filled = filled  # After filling, we pour out this beaker's water if dfs(new_filled, new_water): return True return False # Different  Start  solve(): # Use bitmask DP  beakers have been  @lru_cache(maxsize=None) def can_fill(filled_mask, available_water): if filled_mask == (1 << n) - 1: return available_water ==  return False  beaker for i in range(n): if    i)   return True return False #  (index 0) filled initial_mask = 1 initial_water = max_beaker   input().split())) if can_fill_all_beakers(beakers): print(\"YES\") else: print(\"NO\")"], "perturbed_original": ["while True:  == 0: break beakers = list(map(int, input().split()))  if beakers: beakersum = [beakers[0]] del beakers[0]   continue   m] beakersum.extend(tmp) if m in beakersum: break if  print(\"NO\")"], "original_ll": -1.185887336730957, "sampled_ll": -0.9395316243171692, "all_perturbed_sampled_ll": [-3.2506916522979736], "all_perturbed_original_ll": [-3.211015462875366], "perturbed_sampled_ll": -3.2506916522979736, "perturbed_original_ll": -3.211015462875366, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "\n\n#include<stdio.h>\nint main(){\n  char c[9],i;\n  int d[]={0,1,2,3,4,5,6,7,8,0,3,6,1,4,7,2,5,8,0,4,8,2,4,6};\n  while(scanf(\" %c\",&c[0]),c[0]-'0'){\n    for(i=1;i<9;i++){\n      scanf(\" %c\",&c[i]);\n    }\n    for(i=0;i<8;i++){\n      if(c[d[i*3+0]]==c[d[i*3+1]]&&c[d[i*3+1]]==c[d[i*3+2]]&&c[d[i*3+0]]-'+'){\n\tprintf(\"%c\\n\",c[d[i*3]]);\n\tbreak;\n      }\n    }\n      if(i==8)printf(\"NA\\n\");\n  }\n  return 0;\n}", "sampled": "#include <stdio.h>\n#include <string.h>\n\nint check_win(char board[3][4], char player) {\n    // Check rows\n    for (int i = 0; i < 3; i++) {\n        if (board[i][0] == player && board[i][1] == player && board[i][2] == player) {\n            return 1;\n        }\n    }\n    \n    // Check columns\n    for (int j = 0; j < 3; j++) {\n        if (board[0][j] == player && board[1][j] == player && board[2][j] == player) {\n            return 1;\n        }\n    }\n    \n    // Check diagonals\n    if (board[0][0] == player && board[1][1] == player && board[2][2] == player) {\n        return 1;\n    }\n    if (board[0][2] == player && board[1][1] == player && board[2][0] == player) {\n        return 1;\n    }\n    \n    return 0;\n}\n\nint main() {\n    char board[3][4];\n    \n    while (1) {\n        if (scanf(\"%s\", board[0]) != 1) break;\n        if (board[0][0] == '0') break;\n        \n        scanf(\"%s\", board[1]);\n        scanf(\"%s\", board[2]);\n        \n        if (check_win(board, 'b')) {\n            printf(\"b\\n\");\n        } else if (check_win(board, 'w')) {\n            printf(\"w\\n\");\n        } else {\n            printf(\"NA\\n\");\n        }\n    }\n    \n    return 0;\n}\n", "perturbed_sampled": [" check_win(char  Check rows for (int i  == player &&  1; } }   (board[0][j] ==  { return 1; } } // Check diagonals if (board[0][0] ==  &&  == player && board[2][0] == player) { return 1; } return 0;  if (scanf(\"%s\", board[0])  (check_win(board, 'b')) { printf(\"b\\n\"); } else if  else { printf(\"NA\\n\"); } } return 0; }"], "perturbed_original": ["#include<stdio.h> int main(){ char c[9],i; int d[]={0,1,2,3,4,5,6,7,8,0,3,6,1,4,7,2,5,8,0,4,8,2,4,6};  break; }  }"], "original_ll": -1.2036434412002563, "sampled_ll": -0.39143824577331543, "all_perturbed_sampled_ll": [-2.9145305156707764], "all_perturbed_original_ll": [-1.7003780603408813], "perturbed_sampled_ll": -2.9145305156707764, "perturbed_original_ll": -1.7003780603408813, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import java.util.*;\n\npublic class Main {\n\tstatic Scanner sc = new Scanner(System.in);\n\tstatic char[][] board = new char[3][3];\n\t\n\tstatic boolean read() {\n\t\tString line = sc.next();\n\t\tif(line.equals(\"0\")) return false;\n\t\tboard[0][0] = line.charAt(0); board[0][1] = line.charAt(1); board[0][2] = line.charAt(2);\n\t\tfor(int i = 1; i < 3; i++) {\n\t\t\tline = sc.next();\n\t\t\tfor(int j = 0; j < 3; j++) board[i][j] = line.charAt(j);\n\t\t}\n\t\treturn true;\n\t}\n\t\n\tstatic String solve() {\n\t\tchar stone;\n\t\tboolean win;\n\t\t\n\t\tfor(int i = 0; i < 3; i++) {\n\t\t\twin = true;\n\t\t\tstone = board[i][0];\n\t\t\tfor(int j = 1; j < 3; j++) {\n\t\t\t\tif(stone != board[i][j]) win = false;\n\t\t\t}\n\t\t\tif(win) return \"\" + stone;\n\t\t}\n\t\t\n\t\tfor(int j = 0; j < 3; j++) {\n\t\t\twin = true;\n\t\t\tstone = board[0][j];\n\t\t\tfor(int i = 1; i < 3; i++) {\n\t\t\t\tif(stone != board[i][j]) win = false;\n\t\t\t}\n\t\t\tif(win) return \"\" + stone;\n\t\t}\n\t\t\n\t\tif(board[0][0] == board[1][1] && board[0][0] == board[2][2]) return \"\" + board[0][0];\n\t\t\n\t\tif(board[2][0] == board[1][1]  && board[1][1] == board[0][2]) return \"\" + board[2][0];\n\t\t\n\t\treturn \"NA\";\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\twhile(read()) {\n\t\t\tSystem.out.println(solve());\n\t\t}\n\n\t}\n\n}", "sampled": "import java.util.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        \n        while (true) {\n            String line = sc.nextLine();\n            if (line.equals(\"0\")) {\n                break;\n            }\n            \n            char[][] board = new char[3][3];\n            board[0] = line.toCharArray();\n            board[1] = sc.nextLine().toCharArray();\n            board[2] = sc.nextLine().toCharArray();\n            \n            boolean bWins = checkWin(board, 'b');\n            boolean wWins = checkWin(board, 'w');\n            \n            if (bWins) {\n                System.out.println(\"b\");\n            } else if (wWins) {\n                System.out.println(\"w\");\n            } else {\n                System.out.println(\"NA\");\n            }\n        }\n        \n        sc.close();\n    }\n    \n    private static boolean checkWin(char[][] board, char player) {\n        // Check rows\n        for (int i = 0; i < 3; i++) {\n            if (board[i][0] == player && board[i][1] == player && board[i][2] == player) {\n                return true;\n            }\n        }\n        \n        // Check columns\n        for (int j = 0; j < 3; j++) {\n            if (board[0][j] == player && board[1][j] == player && board[2][j] == player) {\n                return true;\n            }\n        }\n        \n        // Check diagonals\n        if (board[0][0] == player && board[1][1] == player && board[2][2] == player) {\n            return true;\n        }\n        if (board[0][2] == player && board[1][1] == player && board[2][0] == player) {\n            return true;\n        }\n        \n        return false;\n    }\n}\n", "perturbed_sampled": ["import java.util.*; public class Main { public static void <extra_id_1>= 1; j++ ) {<extra_id_2>board[2][0] == player<extra_id_3>(board[j] == player &&<extra_id_4>== player)<extra_id_5>0; j <<extra_id_6>;<extra_id_7>)<extra_id_8>}<extra_id_9>else<extra_id_10>Board s<extra_id_11>+ j ;<extra_id_12>] ==<extra_id_13>return<extra_id_14>}<extra_id_15>( int j<extra_id_16>3; j++ ) {<extra_id_17>(board[1][j] ==<extra_id_18>} public static<extra_id_19>static int Main<extra_id_20>new Main<extra_id_21>[ ] ps  { String line = sc.nextLine(); if (line.equals(\"0\")) { break; }  board[0] =  wWins = checkWin(board,   System.out.println(\"w\"); } else  } private static boolean checkWin(char[][]   3; i++) { if (board[i][0] == player &&  == player)  // Check columns for (int j = 0; j  (board[0][j] == player && board[1][j] ==   board[1][1] == player && board[2][2] == player) {   }"], "perturbed_original": ["import   = new char[3][3]; static boolean read() { String line = sc.next(); if(line.equals(\"0\")) return false;  for(int i   for(int j = 0; j  } static String solve() { char stone; boolean   =  { if(stone != board[i][j]) win = false; } if(win)  for(int  3; j++) { win = true; stone = board[0][j];  <  } if(win) return \"\" + stone; } if(board[0][0] == board[1][1] && board[0][0] ==   + board[2][0];   }"], "original_ll": -0.47139638662338257, "sampled_ll": -0.3035241365432739, "all_perturbed_sampled_ll": [-2.3173391819000244], "all_perturbed_original_ll": [-2.624990463256836], "perturbed_sampled_ll": -2.3173391819000244, "perturbed_original_ll": -2.624990463256836, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "while True:\n    try:\n        f = [list(raw_input()) for _ in xrange(3)]\n    except EOFError:\n        break\n    g = map(lambda x:\"\".join(x),f+zip(*f))\n    print \"b\" if \"b\"*3 in g else \"w\" if \"w\"*3 in g else \"NA\"", "sampled": "import sys\n\ndef check_winner(board):\n    # Check rows\n    for i in range(3):\n        if board[i][0] == board[i][1] == board[i][2] and board[i][0] != '+':\n            return board[i][0]\n    \n    # Check columns\n    for i in range(3):\n        if board[0][i] == board[1][i] == board[2][i] and board[0][i] != '+':\n            return board[0][i]\n    \n    # Check diagonals\n    if board[0][0] == board[1][1] == board[2][2] and board[0][0] != '+':\n        return board[0][0]\n    \n    if board[0][2] == board[1][1] == board[2][0] and board[0][2] != '+':\n        return board[0][2]\n    \n    return 'NA'\n\nwhile True:\n    line = input().strip()\n    if line == '0':\n        break\n    \n    board = [line]\n    board.append(input().strip())\n    board.append(input().strip())\n    \n    result = check_winner(board)\n    print(result)\n", "perturbed_sampled": ["import sys  for i  board[i][0] != '+': return board[i][0] #   != '+': return board[0][i] # Check diagonals if  and board[0][0] != '+': return board[0][0]    if line ==  board.append(input().strip()) board.append(input().strip()) result = check_winner(board) print(result)"], "perturbed_original": ["while True: try: f = [list(raw_input()) for _ in xrange(3)] except  \"w\"  \"NA\""], "original_ll": -1.9430196285247803, "sampled_ll": -0.38173946738243103, "all_perturbed_sampled_ll": [-2.748490810394287], "all_perturbed_original_ll": [-3.824777364730835], "perturbed_sampled_ll": -2.748490810394287, "perturbed_original_ll": -3.824777364730835, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "#include<stdio.h>\nint main(){\n    int age0,age1,age2,age3,age4,age5,age6,n,i,x;\n    while(1){\n        age0=0;age1=0;age2=0;age3=0;age4=0;age5=0;age6=0;\n        scanf(\"%d\",&n);\n        if(n==0)break;\n        for(i=0;i<n;i++){\n            scanf(\"%d\",&x);\n            if(x>=60){\n                age6++;\n            }else if(x>=50){\n                age5++;\n            }else if(x>=40){\n                age4++;\n            }else if(x>=30){\n                age3++;\n            }else if(x>=20){\n                age2++;\n            }else if(x>=10){\n                age1++;\n            }else{\n                age0++;\n            }\n        }\n        printf(\"%d\\n%d\\n%d\\n%d\\n%d\\n%d\\n%d\\n\",age0,age1,age2,age3,age4,age5,age6);\n    }\n    return 0;\n}", "sampled": "#include <stdio.h>\n\nint main() {\n    int n;\n    \n    while(scanf(\"%d\", &n) == 1 && n != 0) {\n        int count[7] = {0};\n        \n        for(int i = 0; i < n; i++) {\n            int age;\n            scanf(\"%d\", &age);\n            \n            if(age < 10) {\n                count[0]++;\n            } else if(age < 20) {\n                count[1]++;\n            } else if(age < 30) {\n                count[2]++;\n            } else if(age < 40) {\n                count[3]++;\n            } else if(age < 50) {\n                count[4]++;\n            } else if(age < 60) {\n                count[5]++;\n            } else {\n                count[6]++;\n            }\n        }\n        \n        for(int i = 0; i < 7; i++) {\n            printf(\"%d\\n\", count[i]);\n        }\n    }\n    \n    return 0;\n}\n", "perturbed_sampled": ["#include <stdio.h> int main() { int n; while(scanf(\"%d\", &n)  < 10)  < 20)  } else  } else if(age < 50) { count[4]++;  { count[6]++;  0; i < 7; i++) { printf(\"%d\\n\", count[i]); } } return 0; }"], "perturbed_original": ["#include<stdio.h>  age0=0;age1=0;age2=0;age3=0;age4=0;age5=0;age6=0; scanf(\"%d\",&n); if(n==0)break; for(i=0;i<n;i++){  age5++; }else if(x>=40){ age4++; }else if(x>=30){  return 0; }"], "original_ll": -0.388095885515213, "sampled_ll": -0.3377456068992615, "all_perturbed_sampled_ll": [-2.231168031692505], "all_perturbed_original_ll": [-1.5556467771530151], "perturbed_sampled_ll": -2.231168031692505, "perturbed_original_ll": -1.5556467771530151, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import java.util.Scanner;\nclass Main\n{\n    public static void main(String args[])\n    {\n\tScanner scan=new Scanner(System.in);\n\twhile(true)\n\t    {\n\t\t\n\t\tint n=scan.nextInt();\n\t\tif(n==0)break;\n\t\tint s[]=new int[7];\n\t\tfor(int i=0;i<n;i++)\n\t\t    {\n\t\t\t\n\t\t\tint old=scan.nextInt();\n\t\t\tint x=old/10;\n\t\t\tif(x>=6)x=6;\n\t\t\ts[x]++;\n\t\t    }\n\t\tfor(int i=0;i<7;i++)\n\t\t    {\n\t\t\tSystem.out.println(s[i]);\n\t\t    }\n\t    }\n    }\n}", "sampled": "import java.util.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        \n        while (true) {\n            int n = sc.nextInt();\n            if (n == 0) break;\n            \n            int[] counts = new int[7];\n            \n            for (int i = 0; i < n; i++) {\n                int age = sc.nextInt();\n                \n                if (age < 10) {\n                    counts[0]++;\n                } else if (age < 20) {\n                    counts[1]++;\n                } else if (age < 30) {\n                    counts[2]++;\n                } else if (age < 40) {\n                    counts[3]++;\n                } else if (age < 50) {\n                    counts[4]++;\n                } else if (age < 60) {\n                    counts[5]++;\n                } else {\n                    counts[6]++;\n                }\n            }\n            \n            for (int i = 0; i < 7; i++) {\n                System.out.println(counts[i]);\n            }\n        }\n        \n        sc.close();\n    }\n}\n", "perturbed_sampled": ["import java.util.*; public class Main { public static void main(String[]  { int n = sc.nextInt(); if    if (age < 10) { counts[0]++; } else if (age  else if  < 40)    else  (int i = 0; i < 7; i++) {  }"], "perturbed_original": ["import java.util.Scanner; class Main {  { Scanner scan=new Scanner(System.in);  i=0;i<n;i++) {  s[x]++;  } } } }"], "original_ll": -1.1367543935775757, "sampled_ll": -0.2918674051761627, "all_perturbed_sampled_ll": [-2.664294958114624], "all_perturbed_original_ll": [-2.513115167617798], "perturbed_sampled_ll": -2.664294958114624, "perturbed_original_ll": -2.513115167617798, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "# -*- coding: utf-8 -*-\nimport sys\n'import math'\nwhile 1:\n    n=int(input())\n    if n==0: sys.exit()\n    arr=[0]*7\n    while n:\n        a=int(input())\n        if a>60: a=61\n        arr[int(a/10)]+=1\n        n-=1\n    for i in range(len(arr)):\n        print(arr[i])", "sampled": "while True:\n    n = int(input())\n    if n == 0:\n        break\n    \n    counts = [0] * 7\n    \n    for _ in range(n):\n        age = int(input())\n        if age < 10:\n            counts[0] += 1\n        elif age < 20:\n            counts[1] += 1\n        elif age < 30:\n            counts[2] += 1\n        elif age < 40:\n            counts[3] += 1\n        elif age < 50:\n            counts[4] += 1\n        elif age < 60:\n            counts[5] += 1\n        else:\n            counts[6] += 1\n    \n    for count in counts:\n        print(count)\n", "perturbed_sampled": ["while  n == 0: break counts = [0] * 7 for _ in range(n): age = int(input()) if  += 1 elif age < 50:  1 for count in counts: print(count)"], "perturbed_original": ["# -*- coding: utf-8 -*-  1: n=int(input()) if n==0: sys.exit()  print(arr[i])"], "original_ll": -1.4116450548171997, "sampled_ll": -0.36175739765167236, "all_perturbed_sampled_ll": [-2.714872360229492], "all_perturbed_original_ll": [-2.908381223678589], "perturbed_sampled_ll": -2.714872360229492, "perturbed_original_ll": -2.908381223678589, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "j,p[1<<20],n;\nmain(i)\n{\n\tfor(;++i<999;)\n\t\tif(!p[i])\n\t\t\tfor(j=i+i;j<1<<20;j+=i)\n\t\t\t\tp[j]=1;\n\tfor(;scanf(\"%d\",&n),j=0,n;printf(\"%d\\n\",j))\n\t\tfor(i=2;i<=n/2;i++)if(!p[i]&!p[n-i])j++;\n\treturn 0;\n}", "sampled": "#include <stdio.h>\n#include <string.h>\n#include <math.h>\n\n#define MAX 1000001\n\nint is_prime[MAX];\n\nvoid sieve() {\n    memset(is_prime, 1, sizeof(is_prime));\n    is_prime[0] = is_prime[1] = 0;\n    \n    for (int i = 2; i * i < MAX; i++) {\n        if (is_prime[i]) {\n            for (int j = i * i; j < MAX; j += i) {\n                is_prime[j] = 0;\n            }\n        }\n    }\n}\n\nint main() {\n    sieve();\n    \n    int n;\n    while (scanf(\"%d\", &n) == 1 && n != 0) {\n        int count = 0;\n        for (int p = 2; p <= n / 2; p++) {\n            if (is_prime[p] && is_prime[n - p]) {\n                count++;\n            }\n        }\n        printf(\"%d\\n\", count);\n    }\n    \n    return 0;\n}\n", "perturbed_sampled": [" <math.h> #define MAX  { memset(is_prime, 1, sizeof(is_prime)); is_prime[0] =  { for (int j   } } } } int main() { sieve(); int n; while  n != 0) { int count = 0; for  <=  if (is_prime[p]  count++; }  0; }"], "perturbed_original": ["j,p[1<<20],n; main(i) { for(;++i<999;) if(!p[i])  0; }"], "original_ll": -2.147275686264038, "sampled_ll": -0.38091033697128296, "all_perturbed_sampled_ll": [-3.050837993621826], "all_perturbed_original_ll": [-3.777523994445801], "perturbed_sampled_ll": -3.050837993621826, "perturbed_original_ll": -3.777523994445801, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import java.util.*;\npublic class Main {\n    static Scanner sc = new Scanner(System.in);\n    static boolean[] prime = new boolean[1000001];\n    static int n;\n    public static void main(String[] args) {\n        makePrime();\n        while(read()){\n            solve();\n        }\n\n    }\n\n    static void makePrime(){\n        Arrays.fill(prime, true);\n        prime[0] = false;\n        prime[1] = false;\n        for(int i = 2; i < prime.length; i++){\n            if(prime[i]){\n                for(int j = i*2; j < prime.length; j += i)prime[j] = false;\n            }\n        }\n    }\n\n    static boolean read(){\n        n = sc.nextInt();\n        if( n == 0 )return false;\n        return true;\n    }\n\n    static void solve(){\n        int res = 0;\n        for(int i = 2; i <= n/2; i++){\n            if(prime[n - i] && prime[i])res++;\n        }\n        System.out.println(res);\n    }\n\n}", "sampled": "import java.util.*;\n\npublic class Main {\n    static boolean[] sieve;\n    static int MAX = 1000001;\n    \n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        \n        // Sieve of Eratosthenes\n        sieve = new boolean[MAX];\n        Arrays.fill(sieve, true);\n        sieve[0] = sieve[1] = false;\n        \n        for (int i = 2; i * i < MAX; i++) {\n            if (sieve[i]) {\n                for (int j = i * i; j < MAX; j += i) {\n                    sieve[j] = false;\n                }\n            }\n        }\n        \n        while (true) {\n            int n = sc.nextInt();\n            if (n == 0) break;\n            \n            int count = 0;\n            for (int p = 2; p <= n / 2; p++) {\n                if (sieve[p] && sieve[n - p]) {\n                    count++;\n                }\n            }\n            \n            System.out.println(count);\n        }\n        \n        sc.close();\n    }\n}\n", "perturbed_sampled": ["import java.util.*; public class  static int MAX = 1000001; public static void main(String[] args) { Scanner sc   < MAX; i++) { if (sieve[i]) { for (int  += i) { sieve[j] = false;  sc.nextInt(); if (n == 0)  for (int  n  p]) { count++; }  }"], "perturbed_original": [")<extra_id_9>} else { //if(!primal.match(s))<extra_id_10>}<extra_id_11>//if (prime[i]) { if(!prime[i])<extra_id_12>primal.forEach(i) {  new Scanner(System.in); static boolean[] prime =  public  makePrime();   false; for(int i = 2; i <  = i*2; j < prime.length; j +=  } static boolean  false; return true; } static void solve(){ int res = 0;   System.out.println(res); } }"], "original_ll": -0.6519679427146912, "sampled_ll": -0.40889692306518555, "all_perturbed_sampled_ll": [-2.6816744804382324], "all_perturbed_original_ll": [-3.2682101726531982], "perturbed_sampled_ll": -2.6816744804382324, "perturbed_original_ll": -3.2682101726531982, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "from itertools import compress\nMAXN = 1000001\np = [True]*MAXN\np[0] = p[1] = False\nfor i in xrange(int(MAXN**0.5)+1):\n    if p[i]:\n        for j in xrange(i+i,MAXN,i):\n            p[j] = False\nwhile True:\n    n = input()\n    if n == 0:\n        break\n    print sum(1 for i in compress(xrange(n/2+1),p) if p[n-i])", "sampled": "def sieve_of_eratosthenes(limit):\n    is_prime = [True] * (limit + 1)\n    is_prime[0] = is_prime[1] = False\n    \n    for i in range(2, int(limit**0.5) + 1):\n        if is_prime[i]:\n            for j in range(i*i, limit + 1, i):\n                is_prime[j] = False\n    \n    return is_prime\n\n# Precompute primes up to 1000000\nMAX_N = 1000000\nis_prime = sieve_of_eratosthenes(MAX_N)\n\nwhile True:\n    n = int(input())\n    if n == 0:\n        break\n    \n    count = 0\n    for p in range(2, n // 2 + 1):\n        if is_prime[p]:\n            q = n - p\n            if is_prime[q]:\n                count += 1\n    \n    print(count)\n", "perturbed_sampled": ["def sieve_of_eratosthenes(limit): is_prime  1) is_prime[0]  + 1): if  limit  1000000 MAX_N = 1000000 is_prime = sieve_of_eratosthenes(MAX_N) while True: n =  break count = 0 for  is_prime[p]: q  is_prime[q]: count += 1 print(count)"], "perturbed_original": [" =  =  in xrange(int(MAXN**0.5)+1): if p[i]: for j in xrange(i+i,MAXN,i): p[j]  == 0: break print  if p[n-i])"], "original_ll": -1.1149413585662842, "sampled_ll": -0.5556136965751648, "all_perturbed_sampled_ll": [-2.298330783843994], "all_perturbed_original_ll": [-3.597306728363037], "perturbed_sampled_ll": -2.298330783843994, "perturbed_original_ll": -3.597306728363037, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "#include <stdio.h>\n\nint cross(int x1,int y1,int x2,int y2,\n\t\tint x3,int y3,int x4,int y4) {\n\tlong long b12x,b12y,b34x,b34y;\n\tlong long b24x,b24y;\n\tlong long b13x,b13y,b14x,b14y,b32x,b32y;\n\tlong long g1213,g1214,g3431,g3432;\n\tlong long n1213,n1214,n3431,n3432;\n\tlong long n2123,n2124,n4341,n4342;\n\n\tb12x=x2-x1;b12y=y2-y1;\n\tb34x=x4-x3;b34y=y4-y3;\n\tb13x=x3-x1;b13y=y3-y1;\n\tb14x=x4-x1;b14y=y4-y1;\n\tb32x=x2-x3;b32y=y2-y3;\n\tb24x=x4-x2;b24y=y4-y2;\n\n\tg1213=b12x*b13y-b13x*b12y;\n\tg1214=b12x*b14y-b14x*b12y;\n\tg3431=b34x*(-b13y)-(-b13x)*b34y;\n\tg3432=b34x*b32y-b32x*b34y;\n\n\tn1213=b12x*b13x+b12y*b13y;\n\tn1214=b12x*b14x+b12y*b14y;\n\tn3431=b34x*(-b13x)+b34y*(-b13y);\n\tn3432=b34x*b32x+b34y*b32y;\n\tn2123=(-b12x)*(-b32x)+(-b12y)*(-b32y);\n\tn2124=(-b12x)*b24x+(-b12y)*b24y;\n\tn4341=(-b34x)*(-b14x)+(-b34y)*(-b14y);\n\tn4342=(-b34x)*(-b24x)+(-b34y)*(-b24y);\n\n\tif(\n\t\t((g1213<0 && g1214>0) || (g1213>0 && g1214<0)) &&\n\t\t((g3431<0 && g3432>0) || (g3431>0 && g3432<0))\n\t) return 1;\n\tif(\n\t\t(g1213==0 && n1213>=0 && n2123>=0) ||\n\t\t(g1214==0 && n1214>=0 && n2124>=0) ||\n\t\t(g3431==0 && n3431>=0 && n4341>=0) ||\n\t\t(g3432==0 && n3432>=0 && n4342>=0)\n\t) return 1;\n\n\treturn 0;\n}\n\n/*\na1x+b1y=c1\na2x+b2y=c2\n*/\nint solve_houteisiki(double* x,double* y,\n\t\tint a1,int b1,int c1,\n\t\tint a2,int b2,int c2) {\n\tint d;\n\td=a1*b2-b1*a2;\n\tif(d==0)return 0;\n\t*x=(double)(b2*c1-b1*c2)/d;\n\t*y=(double)(-a2*c1+a1*c2)/d;\n\treturn 1;\n}\n\nint main(void) {\n\tint x[6],y[6];\n\tint no_triangle;\n\tint x1,y1,t1,x2,y2,t2,x3,y3,t3;\n\tdouble tx1,ty1,tx2,ty2,tx3,ty3;\n\tdouble s;\n\twhile(1) {\n\t\tscanf(\"%d%d%d%d\",&x[0],&y[0],&x[1],&y[1]);\n\t\tif((x[0]|y[0]|x[1]|y[1])==0)break;\n\t\tscanf(\"%d%d%d%d\",&x[2],&y[2],&x[3],&y[3]);\n\t\tscanf(\"%d%d%d%d\",&x[4],&y[4],&x[5],&y[5]);\n\t\tno_triangle=0;\n\t\tno_triangle=no_triangle ||\n\t\t\t!cross(x[0],y[0],x[1],y[1],x[2],y[2],x[3],y[3]);\n\t\tno_triangle=no_triangle ||\n\t\t\t!cross(x[2],y[2],x[3],y[3],x[4],y[4],x[5],y[5]);\n\t\tno_triangle=no_triangle ||\n\t\t\t!cross(x[4],y[4],x[5],y[5],x[0],y[0],x[1],y[1]);\n\t\tif(!no_triangle) {\n\t\t\tx1=y[1]-y[0];\n\t\t\ty1=-(x[1]-x[0]);\n\t\t\tt1=x[0]*(y[1]-y[0])-y[0]*(x[1]-x[0]);\n\t\t\tx2=y[3]-y[2];\n\t\t\ty2=-(x[3]-x[2]);\n\t\t\tt2=x[2]*(y[3]-y[2])-y[2]*(x[3]-x[2]);\n\t\t\tx3=y[5]-y[4];\n\t\t\ty3=-(x[5]-x[4]);\n\t\t\tt3=x[4]*(y[5]-y[4])-y[4]*(x[5]-x[4]);\n\t\t\tno_triangle=no_triangle ||\n\t\t\t\t!solve_houteisiki(&tx1,&ty1,\n\t\t\t\t\tx1,y1,t1,x2,y2,t2);\n\t\t\tno_triangle=no_triangle ||\n\t\t\t\t!solve_houteisiki(&tx2,&ty2,\n\t\t\t\t\tx2,y2,t2,x3,y3,t3);\n\t\t\tno_triangle=no_triangle ||\n\t\t\t\t!solve_houteisiki(&tx3,&ty3,\n\t\t\t\t\tx3,y3,t3,x1,y1,t1);\n\t\t}\n\t\tif(!no_triangle) {\n\t\t\ts=((tx2-tx1)*(ty3-ty1)-(tx3-tx1)*(ty2-ty1))/2;\n\t\t\tif(s<0)s=-s;\n\t\t\tif(s<1e-8)puts(\"kyo\");\n\t\t\telse if(s<100000+1e-8)puts(\"syo-kichi\");\n\t\t\telse if(s<1000000+1e-8)puts(\"kichi\");\n\t\t\telse if(s<1900000+1e-8)puts(\"chu-kichi\");\n\t\t\telse puts(\"dai-kichi\");\n\t\t} else puts(\"kyo\");\n\t}\n\treturn 0;\n}", "sampled": "#include <stdio.h>\n#include <math.h>\n\ntypedef struct {\n    double x, y;\n} Point;\n\ntypedef struct {\n    Point p1, p2;\n} Line;\n\nint getIntersection(Line l1, Line l2, Point *result) {\n    double x1 = l1.p1.x, y1 = l1.p1.y;\n    double x2 = l1.p2.x, y2 = l1.p2.y;\n    double x3 = l2.p1.x, y3 = l2.p1.y;\n    double x4 = l2.p2.x, y4 = l2.p2.y;\n    \n    double denom = (x1 - x2) * (y3 - y4) - (y1 - y2) * (x3 - x4);\n    \n    if (fabs(denom) < 1e-9) {\n        return 0;\n    }\n    \n    double t = ((x1 - x3) * (y3 - y4) - (y1 - y3) * (x3 - x4)) / denom;\n    \n    result->x = x1 + t * (x2 - x1);\n    result->y = y1 + t * (y2 - y1);\n    \n    return 1;\n}\n\ndouble triangleArea(Point p1, Point p2, Point p3) {\n    return fabs((p1.x * (p2.y - p3.y) + p2.x * (p3.y - p1.y) + p3.x * (p1.y - p2.y)) / 2.0);\n}\n\nint areCollinear(Point p1, Point p2, Point p3) {\n    double area = fabs((p1.x * (p2.y - p3.y) + p2.x * (p3.y - p1.y) + p3.x * (p1.y - p2.y)));\n    return area < 1e-6;\n}\n\nint main() {\n    Line lines[3];\n    \n    while (1) {\n        scanf(\"%lf %lf %lf %lf\", &lines[0].p1.x, &lines[0].p1.y, &lines[0].p2.x, &lines[0].p2.y);\n        \n        if (lines[0].p1.x == 0 && lines[0].p1.y == 0 && lines[0].p2.x == 0 && lines[0].p2.y == 0) {\n            break;\n        }\n        \n        scanf(\"%lf %lf %lf %lf\", &lines[1].p1.x, &lines[1].p1.y, &lines[1].p2.x, &lines[1].p2.y);\n        scanf(\"%lf %lf %lf %lf\", &lines[2].p1.x, &lines[2].p1.y, &lines[2].p2.x, &lines[2].p2.y);\n        \n        Point intersections[3];\n        \n        if (!getIntersection(lines[0], lines[1], &intersections[0]) ||\n            !getIntersection(lines[1], lines[2], &intersections[1]) ||\n            !getIntersection(lines[2], lines[0], &intersections[2])) {\n            printf(\"kyo\\n\");\n            continue;\n        }\n        \n        if (areCollinear(intersections[0], intersections[1], intersections[2])) {\n            printf(\"kyo\\n\");\n            continue;\n        }\n        \n        double area = triangleArea(intersections[0], intersections[1], intersections[2]);\n        \n        if (area < 1e-6) {\n            printf(\"kyo\\n\");\n        } else if (area >= 1900000) {\n            printf(\"dai-kichi\\n\");\n        } else if (area >= 1000000) {\n            printf(\"chu-kichi\\n\");\n        } else if (area >= 100000) {\n            printf(\"kichi\\n\");\n        } else {\n            printf(\"syo-kichi\\n\");\n        }\n    }\n    \n    return 0;\n}\n", "perturbed_sampled": ["#include <stdio.h> #include <math.h> typedef struct { double x, y; } Point; typedef struct { Point p1, p2; } Line; int getIntersection(Line l1, Line l2,  = l1.p1.x, y1  l1.p2.x,  = l2.p1.x, y3 = l2.p1.y; double x4 = l2.p2.x, y4    } double t = ((x1   x1 +  y1);  p1,  return fabs((p1.x * (p2.y - p3.y) + p2.x * (p3.y  p3)    + p3.x * (p1.y - p2.y))); return area < 1e-6; } int  (1) { scanf(\"%lf  ==  && lines[0].p2.y == 0) { break;  &lines[1].p1.x, &lines[1].p1.y,  %lf\", &lines[2].p1.x, &lines[2].p1.y, &lines[2].p2.x, &lines[2].p2.y); Point intersections[3]; if (!getIntersection(lines[0], lines[1], &intersections[0]) || !getIntersection(lines[1], lines[2], &intersections[1]) || !getIntersection(lines[2],  } if    } else  printf(\"kichi\\n\"); } else { printf(\"syo-kichi\\n\"); } } return 0; }"], "perturbed_original": ["#include <stdio.h> int cross(int x1,int  y3,int x4,int y4) { long long  long b13x,b13y,b14x,b14y,b32x,b32y; long long g1213,g1214,g3431,g3432; long long  g3432=b34x*b32y-b32x*b34y; n1213=b12x*b13x+b12y*b13y; n1214=b12x*b14x+b12y*b14y; n3431=b34x*(-b13x)+b34y*(-b13y);   (g1213>0 && g1214<0)) && ((g3431<0 && g3432>0) || (g3431>0 && g3432<0)) ) return 1;  n2123>=0) ||  && n4341>=0) || (g3432==0 && n3432>=0   b2,int c2)  0; *x=(double)(b2*c1-b1*c2)/d; *y=(double)(-a2*c1+a1*c2)/d; return  no_triangle=0; no_triangle=no_triangle || !cross(x[0],y[0],x[1],y[1],x[2],y[2],x[3],y[3]); no_triangle=no_triangle  t1=x[0]*(y[1]-y[0])-y[0]*(x[1]-x[0]); x2=y[3]-y[2]; y2=-(x[3]-x[2]); t2=x[2]*(y[3]-y[2])-y[2]*(x[3]-x[2]); x3=y[5]-y[4]; y3=-(x[5]-x[4]); t3=x[4]*(y[5]-y[4])-y[4]*(x[5]-x[4]); no_triangle=no_triangle  !solve_houteisiki(&tx3,&ty3, x3,y3,t3,x1,y1,t1); } if(!no_triangle) { s=((tx2-tx1)*(ty3-ty1)-(tx3-tx1)*(ty2-ty1))/2;  if(s<1000000+1e-8)puts(\"kichi\"); else if(s<1900000+1e-8)puts(\"chu-kichi\"); else  return 0; }"], "original_ll": -0.5591878294944763, "sampled_ll": -0.3571866452693939, "all_perturbed_sampled_ll": [-1.7799147367477417], "all_perturbed_original_ll": [-1.4629042148590088], "perturbed_sampled_ll": -1.7799147367477417, "perturbed_original_ll": -1.4629042148590088, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import java.util.*;\npublic class Main\n{\n\tstatic\tdouble EPS=1e-4;\n\tpublic static void main(String[] args) \n\t{\n\t\tScanner in=new Scanner(System.in);\n\t\tfor(;;)\n\t\t{\n\t\t\tPoint p1=new Point(in.nextDouble(), in.nextDouble()); \n\t\t\tPoint p2=new Point(in.nextDouble(), in.nextDouble()); \n\t\t\tif(p1.x==0&&p1.y==0&&p2.x==0&&p2.y==0)\n\t\t\t\treturn;\n\t\t\tPoint p3=new Point(in.nextDouble(), in.nextDouble()); \n\t\t\tPoint p4=new Point(in.nextDouble(), in.nextDouble()); \n\t\t\tPoint p5=new Point(in.nextDouble(), in.nextDouble()); \n\t\t\tPoint p6=new Point(in.nextDouble(), in.nextDouble());\n\t\t\tboolean judge=true;\n\t\t\tif(!lineCross(p1, p2, p3, p4))\n\t\t\t\tjudge=false;\n\t\t\tif(!lineCross(p3, p4, p5, p6))\n\t\t\t\tjudge=false;\n\t\t\tif(!lineCross(p5, p6, p1, p2))\n\t\t\t\tjudge=false;\n\n\t\t\tif(judge)\n\t\t\t{\n\t\t\t\tdouble a1=slanting(p1, p2);\n\t\t\t\tdouble a2=slanting(p3, p4);\n\t\t\t\tdouble x1=(a1*p1.x-p1.y-a2*p3.x+p3.y)/(a1-a2);\n\t\t\t\tif(a1==-1.123)\n\t\t\t\t\tx1=p1.x;\n\t\t\t\telse if(a2==-1.123)\n\t\t\t\t\tx1=p3.x;\n\t\t\t\tdouble y1=(p2.y-p1.y)/(p2.x-p1.x)*(x1-p1.x)+p1.y;\n\t\t\t\tif(a1==-1.123)\n\t\t\t\t\ty1=(p4.y-p3.y)/(p4.x-p3.x)*(x1-p3.x)+p3.y;\n\n\t\t\t\ta1=slanting(p3, p4);\n\t\t\t\ta2=slanting(p5, p6);\n\t\t\t\tdouble x2=(a1*p3.x-p3.y-a2*p5.x+p5.y)/(a1-a2);\n\t\t\t\tif(a1==-1.123)\n\t\t\t\t\tx2=p3.x;\n\t\t\t\telse if(a2==-1.123)\n\t\t\t\t\tx2=p5.x;\n\t\t\t\tdouble y2=(p4.y-p3.y)/(p4.x-p3.x)*(x2-p3.x)+p3.y;\n\t\t\t\tif(a1==-1.123)\n\t\t\t\t\ty2=(p5.y-p6.y)/(p5.x-p6.x)*(x2-p5.x)+p5.y;\n\n\t\t\t\ta1=slanting(p5, p6);\n\t\t\t\ta2=slanting(p1, p2);\n\t\t\t\tdouble x3=(a1*p5.x-p5.y-a2*p1.x+p1.y)/(a1-a2);\n\t\t\t\tif(a1==-1.123)\n\t\t\t\t\tx3=p5.x;\n\t\t\t\telse if(a2==-1.123)\n\t\t\t\t\tx3=p1.x;\n\t\t\t\tdouble y3=(p6.y-p5.y)/(p6.x-p5.x)*(x3-p5.x)+p5.y;\n\t\t\t\tif(a1==-1.123)\n\t\t\t\t\ty3=(p2.y-p1.y)/(p2.x-p1.x)*(x3-p1.x)+p1.y;\n\n\t\t\t\tdouble a=x2-x1;\n\t\t\t\tdouble b=y2-y1;\n\t\t\t\tdouble c=x3-x1;\n\t\t\t\tdouble d=y3-y1;\n\t\t\t\tdouble S=Math.abs(a*d-b*c)/2;\n\t\t\t\tif(S<EPS)\n\t\t\t\t\tSystem.out.println(\"kyo\");\n\t\t\t\telse if(S<100000)\n\t\t\t\t\tSystem.out.println(\"syo-kichi\");\n\t\t\t\telse if(S<1000000)\n\t\t\t\t\tSystem.out.println(\"kichi\");\n\t\t\t\telse if(S<1900000)\n\t\t\t\t\tSystem.out.println(\"chu-kichi\");\n\t\t\t\telse \n\t\t\t\t\tSystem.out.println(\"dai-kichi\");\t\t\t\n\t\t\t}\n\t\t\telse\n\t\t\t\tSystem.out.println(\"kyo\");\n\t\t}\n\t}\n\n\tstatic boolean lineCross(Point p1,Point p2,Point p3,Point p4)\n\t{\n\t\tdouble jc1=(p1.x-p2.x)*(p3.y-p1.y)+(p1.y-p2.y)*(p1.x-p3.x);\n\t\tdouble jd1=(p1.x-p2.x)*(p4.y-p1.y)+(p1.y-p2.y)*(p1.x-p4.x);\n\t\tdouble jc2=(p3.x-p4.x)*(p1.y-p3.y)+(p3.y-p4.y)*(p3.x-p1.x);\n\t\tdouble jd2=(p3.x-p4.x)*(p2.y-p3.y)+(p3.y-p4.y)*(p3.x-p2.x);\n\t\treturn jc1*jd1<=0 && jc2*jd2<=0;\n\t}\n\n\tstatic double slanting(Point p1,Point p2)\n\t{\n\t\tif(Math.abs(p1.x-p2.x)<EPS)\n\t\t\treturn -1.123;\n\t\telse\n\t\t\treturn (p1.y-p2.y)/(p1.x-p2.x);\n\t}\n}\nclass Point\n{\n\tdouble x;\n\tdouble y;\n\tPoint(double x,double y)\n\t{\n\t\tthis.x=x;\n\t\tthis.y=y;\n\t}\n}", "sampled": "import java.util.*;\nimport java.io.*;\n\npublic class Main {\n    static class Point {\n        double x, y;\n        Point(double x, double y) {\n            this.x = x;\n            this.y = y;\n        }\n    }\n    \n    static class Line {\n        Point p1, p2;\n        Line(Point p1, Point p2) {\n            this.p1 = p1;\n            this.p2 = p2;\n        }\n    }\n    \n    static final double EPS = 1e-9;\n    \n    static Point getIntersection(Line l1, Line l2) {\n        double x1 = l1.p1.x, y1 = l1.p1.y;\n        double x2 = l1.p2.x, y2 = l1.p2.y;\n        double x3 = l2.p1.x, y3 = l2.p1.y;\n        double x4 = l2.p2.x, y4 = l2.p2.y;\n        \n        double denom = (x1 - x2) * (y3 - y4) - (y1 - y2) * (x3 - x4);\n        \n        if (Math.abs(denom) < EPS) {\n            return null; // parallel or coincident\n        }\n        \n        double t = ((x1 - x3) * (y3 - y4) - (y1 - y3) * (x3 - x4)) / denom;\n        \n        double px = x1 + t * (x2 - x1);\n        double py = y1 + t * (y2 - y1);\n        \n        return new Point(px, py);\n    }\n    \n    static boolean isParallel(Line l1, Line l2) {\n        double dx1 = l1.p2.x - l1.p1.x;\n        double dy1 = l1.p2.y - l1.p1.y;\n        double dx2 = l2.p2.x - l2.p1.x;\n        double dy2 = l2.p2.y - l2.p1.y;\n        \n        return Math.abs(dx1 * dy2 - dy1 * dx2) < EPS;\n    }\n    \n    static double triangleArea(Point p1, Point p2, Point p3) {\n        return Math.abs((p2.x - p1.x) * (p3.y - p1.y) - (p3.x - p1.x) * (p2.y - p1.y)) / 2.0;\n    }\n    \n    static boolean areCollinear(Point p1, Point p2, Point p3) {\n        return Math.abs((p2.x - p1.x) * (p3.y - p1.y) - (p3.x - p1.x) * (p2.y - p1.y)) < EPS;\n    }\n    \n    public static void main(String[] args) throws IOException {\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        String line;\n        \n        while (true) {\n            line = br.readLine();\n            String[] parts = line.split(\" \");\n            int x1 = Integer.parseInt(parts[0]);\n            int y1 = Integer.parseInt(parts[1]);\n            int x2 = Integer.parseInt(parts[2]);\n            int y2 = Integer.parseInt(parts[3]);\n            \n            if (x1 == 0 && y1 == 0 && x2 == 0 && y2 == 0) break;\n            \n            Line l1 = new Line(new Point(x1, y1), new Point(x2, y2));\n            \n            line = br.readLine();\n            parts = line.split(\" \");\n            x1 = Integer.parseInt(parts[0]);\n            y1 = Integer.parseInt(parts[1]);\n            x2 = Integer.parseInt(parts[2]);\n            y2 = Integer.parseInt(parts[3]);\n            Line l2 = new Line(new Point(x1, y1), new Point(x2, y2));\n            \n            line = br.readLine();\n            parts = line.split(\" \");\n            x1 = Integer.parseInt(parts[0]);\n            y1 = Integer.parseInt(parts[1]);\n            x2 = Integer.parseInt(parts[2]);\n            y2 = Integer.parseInt(parts[3]);\n            Line l3 = new Line(new Point(x1, y1), new Point(x2, y2));\n            \n            Point p12 = getIntersection(l1, l2);\n            Point p13 = getIntersection(l1, l3);\n            Point p23 = getIntersection(l2, l3);\n            \n            if (p12 == null || p13 == null || p23 == null) {\n                System.out.println(\"kyo\");\n                continue;\n            }\n            \n            if (areCollinear(p12, p13, p23)) {\n                System.out.println(\"kyo\");\n                continue;\n            }\n            \n            double area = triangleArea(p12, p13, p23);\n            \n            if (area < EPS) {\n                System.out.println(\"kyo\");\n            } else if (area < 100000) {\n                System.out.println(\"syo-kichi\");\n            } else if (area < 1000000) {\n                System.out.println(\"kichi\");\n            } else if (area < 1900000) {\n                System.out.println(\"chu-kichi\");\n            } else {\n                System.out.println(\"dai-kichi\");\n            }\n        }\n    }\n}\n", "perturbed_sampled": ["import java.util.*; import java.io.*; public  y; Point(double x, double  this.y =  p2; Line(Point p1, Point p2) {  p2;  EPS = 1e-9; static Point  y1 = l1.p1.y; double x2 = l1.p2.x, y2  l2.p1.x, y3 = l2.p1.y; double x4 =  denom = (x1 - x2) * (y3 -  * (x3 - x4);  y4) - (y1 - y3)  x1  x1); double    boolean isParallel(Line l1, Line   - l2.p1.x; double dy2  Math.abs(dx1 * dy2 - dy1  static double triangleArea(Point p1,  return Math.abs((p2.x - p1.x) *   p1.y)) /   {   -   String line; while (true) {  = line.split(\" \"); int  =  && y1 == 0 && x2 == 0 && y2 ==   y1 = Integer.parseInt(parts[1]); x2 = Integer.parseInt(parts[2]);  = new Line(new Point(x1, y1), new Point(x2, y2)); line = br.readLine(); parts = line.split(\" \"); x1 = Integer.parseInt(parts[0]); y1 = Integer.parseInt(parts[1]); x2 = Integer.parseInt(parts[2]); y2 = Integer.parseInt(parts[3]); Line l3 =  = getIntersection(l1, l2); Point p13 =  continue; } if (areCollinear(p12,  } double  if (area <  if (area < 100000) { System.out.println(\"syo-kichi\"); }  { System.out.println(\"chu-kichi\"); } else  }"], "perturbed_original": ["import java.util.*; public class  public static void main(String[] args) { Scanner in=new Scanner(System.in); for(;;) { Point p1=new Point(in.nextDouble(), in.nextDouble()); Point p2=new Point(in.nextDouble(), in.nextDouble()); if(p1.x==0&&p1.y==0&&p2.x==0&&p2.y==0) return; Point p3=new Point(in.nextDouble(), in.nextDouble()); Point p4=new Point(in.nextDouble(),  Point p6=new Point(in.nextDouble(),  if(!lineCross(p5, p6, p1,  a1=slanting(p1, p2); double  x1=p1.x; else  y1=(p4.y-p3.y)/(p4.x-p3.x)*(x1-p3.x)+p3.y; a1=slanting(p3,  x2=p5.x; double y2=(p4.y-p3.y)/(p4.x-p3.x)*(x2-p3.x)+p3.y; if(a1==-1.123) y2=(p5.y-p6.y)/(p5.x-p6.x)*(x2-p5.x)+p5.y; a1=slanting(p5,  System.out.println(\"kyo\"); else if(S<100000) System.out.println(\"syo-kichi\"); else  else System.out.println(\"dai-kichi\"); } else   if(Math.abs(p1.x-p2.x)<EPS) return -1.123; else return (p1.y-p2.y)/(p1.x-p2.x); } } class Point  this.x=x; this.y=y; } }"], "original_ll": -0.5582008957862854, "sampled_ll": -0.30411916971206665, "all_perturbed_sampled_ll": [-2.1822023391723633], "all_perturbed_original_ll": [-1.5368390083312988], "perturbed_sampled_ll": -2.1822023391723633, "perturbed_original_ll": -1.5368390083312988, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "def cross3(O, A, B):\n    ox, oy = O; ax, ay = A; bx, by = B\n    return (ax - ox) * (by - oy) - (bx - ox) * (ay - oy)\ndef outer(x0, y0, x1, y1):\n    return x0*y1 - x1*y0\ndef is_intersection(P0, P1, Q0, Q1):\n    C0 = cross3(P0, P1, Q0)\n    C1 = cross3(P0, P1, Q1)\n    D0 = cross3(Q0, Q1, P0)\n    D1 = cross3(Q0, Q1, P1)\n    if C0 == C1 == 0:\n        return 0\n    return C0 * C1 <= 0 and D0 * D1 <= 0\ndef cross_point(P0, Q0, P1, Q1):\n    x0, y0 = P0; x1, y1 = Q0\n    x2, y2 = P1; x3, y3 = Q1\n    dx0 = x1 - x0\n    dy0 = y1 - y0\n    dx1 = x3 - x2\n    dy1 = y3 - y2\n\n    s = (y0-y2)*dx1 - (x0-x2)*dy1\n    sm = dx0*dy1 - dy0*dx1\n    if s < 0:\n        s = -s\n        sm = -sm\n    if s == 0:\n        x = x0\n        y = y0\n    else:\n        x = x0 + s*dx0/sm\n        y = y0 + s*dy0/sm\n    return x, y\nwhile 1:\n    x1, y1, x2, y2 = map(int, input().split())\n    if x1 == y1 == x2 == y2 == 0:\n        break\n    P1 = (x1, y1); Q1 = (x2, y2)\n    x3, y3, x4, y4 = map(int, input().split())\n    P2 = (x3, y3); Q2 = (x4, y4)\n    x5, y5, x6, y6 = map(int, input().split())\n    P3 = (x5, y5); Q3 = (x6, y6)\n    if (not is_intersection(P1, Q1, P2, Q2)\n            or not is_intersection(P2, Q2, P3, Q3)\n            or not is_intersection(P3, Q3, P1, Q1)):\n        print(\"kyo\")\n        continue\n    p1, q1 = cross_point(P1, Q1, P2, Q2)\n    p2, q2 = cross_point(P2, Q2, P3, Q3)\n    p3, q3 = cross_point(P3, Q3, P1, Q1)\n    S = abs(outer(p2-p1, q2-q1, p3-p1, q3-q1)) / 2.\n    if S < 1e-9:\n        print(\"kyo\")\n    elif S < 100000:\n        print(\"syo-kichi\")\n    elif S < 1000000:\n        print(\"kichi\")\n    elif S < 1900000:\n        print(\"chu-kichi\")\n    else:\n        print(\"dai-kichi\")\n", "sampled": "import sys\nfrom math import isclose\n\ndef line_intersection(x1, y1, x2, y2, x3, y3, x4, y4):\n    denom = (x1 - x2) * (y3 - y4) - (y1 - y2) * (x3 - x4)\n    if abs(denom) < 1e-9:\n        return None\n    \n    t = ((x1 - x3) * (y3 - y4) - (y1 - y3) * (x3 - x4)) / denom\n    u = -((x1 - x2) * (y1 - y3) - (y1 - y2) * (x1 - x3)) / denom\n    \n    px = x1 + t * (x2 - x1)\n    py = y1 + t * (y2 - y1)\n    \n    return (px, py)\n\ndef triangle_area(p1, p2, p3):\n    x1, y1 = p1\n    x2, y2 = p2\n    x3, y3 = p3\n    area = abs((x1 * (y2 - y3) + x2 * (y3 - y1) + x3 * (y1 - y2)) / 2.0)\n    return area\n\ndef are_collinear(p1, p2, p3):\n    if p1 is None or p2 is None or p3 is None:\n        return True\n    x1, y1 = p1\n    x2, y2 = p2\n    x3, y3 = p3\n    area = abs((x1 * (y2 - y3) + x2 * (y3 - y1) + x3 * (y1 - y2)))\n    return area < 1e-6\n\ndef solve(lines):\n    # Get intersection points\n    p1 = line_intersection(*lines[0], *lines[1])\n    p2 = line_intersection(*lines[0], *lines[2])\n    p3 = line_intersection(*lines[1], *lines[2])\n    \n    if p1 is None or p2 is None or p3 is None:\n        return \"kyo\"\n    \n    if are_collinear(p1, p2, p3):\n        return \"kyo\"\n    \n    area = triangle_area(p1, p2, p3)\n    \n    if area < 1e-9:\n        return \"kyo\"\n    elif area < 100000:\n        return \"syo-kichi\"\n    elif area < 1000000:\n        return \"kichi\"\n    elif area < 1900000:\n        return \"chu-kichi\"\n    else:\n        return \"dai-kichi\"\n\nwhile True:\n    line = input().split()\n    if line == ['0', '0', '0', '0']:\n        break\n    \n    lines = []\n    lines.append([int(x) for x in line])\n    for _ in range(2):\n        lines.append([int(x) for x in input().split()])\n    \n    result = solve(lines)\n    print(result)\n", "perturbed_sampled": ["import sys from math import  - y2) * (x3 - x4) if abs(denom) < 1e-9: return None t  (y3 -  * (x3 - x4)) / denom u = -((x1 - x2) * (y1 - y3)  (x1 - x3)) /  x1) py  p2, p3): x1,   * (y2 - y3) + x2  x3   is None   x1, y1  p3 area = abs((x1 * (y2  y2))) return  p1 = line_intersection(*lines[0], *lines[1]) p2 = line_intersection(*lines[0], *lines[2]) p3 = line_intersection(*lines[1], *lines[2]) if p1 is None   if are_collinear(p1, p2,   < 1e-9: return  return \"syo-kichi\" elif area < 1000000: return \"kichi\" elif area <  '0']:   _ in range(2): lines.append([int(x) for  solve(lines) print(result)"], "perturbed_original": ["def  = A;  (ax -  -   P1, Q0, Q1): C0 = cross3(P0, P1, Q0) C1 = cross3(P0, P1, Q1) D0 = cross3(Q0, Q1, P0) D1 = cross3(Q0,  C1 ==  * C1 <= 0 and  def cross_point(P0, Q0, P1, Q1): x0, y0 =  x2, y2  Q1 dx0 = x1 - x0 dy0 = y1 - y0  dy1    = -s sm = -sm if  x0  = x0 + s*dx0/sm   x1,  input().split()) if x1 ==  ==   =  P3 =  y6)   Q2) p2, q2 =  q3 = cross_point(P3, Q3, P1,  p3-p1, q3-q1)) / 2. if S <  100000: print(\"syo-kichi\") elif S <  1900000: print(\"chu-kichi\") else: print(\"dai-kichi\")"], "original_ll": -0.656896710395813, "sampled_ll": -0.5668662190437317, "all_perturbed_sampled_ll": [-2.6502037048339844], "all_perturbed_original_ll": [-2.628493070602417], "perturbed_sampled_ll": -2.6502037048339844, "perturbed_original_ll": -2.628493070602417, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "#define _CRT_SECURE_NO_WARNINGS\n//#define _USE_MATH_DEFINES\n#include<stdio.h>\n//#include<stdlib.h>\n//#include<math.h>\n//#include<string.h>\n#define P(type,x) fprintf(stdout,\"%\"#type\"\\n\",x)\nint main() {\n\tint n, l, m, r, A[100] = {}, i,key,cnt;\n\twhile (~fscanf(stdin, \"%d\", &n), n) {\n\t\tl = cnt = 0, r = n - 1;\n\t\tfor (i = 0; i < n; i++) fscanf(stdin, \"%d\", &A[i]);\n\t\tfscanf(stdin, \"%d\", &key);\n\t\twhile (l <= r) {\n\t\t\tm = (l + r) / 2;\n\t\t\tcnt++;\n\t\t\tif (A[m] > key) r = m-1;\n\t\t\telse if (A[m] < key) l = m+1;\n\t\t\telse break;\n\t\t}\n\t\tP(d, cnt);\n\t}\n\treturn 0;\n}", "sampled": "#include <stdio.h>\n\nint binarySearch(int arr[], int n, int target) {\n    int left = 0;\n    int right = n - 1;\n    int count = 0;\n    \n    while (left <= right) {\n        int mid = (left + right) / 2;\n        count++;\n        \n        if (arr[mid] == target) {\n            return count;\n        } else if (target < arr[mid]) {\n            right = mid - 1;\n        } else {\n            left = mid + 1;\n        }\n    }\n    \n    return count;\n}\n\nint main() {\n    int n;\n    \n    while (scanf(\"%d\", &n) == 1 && n != 0) {\n        int arr[100];\n        \n        for (int i = 0; i < n; i++) {\n            scanf(\"%d\", &arr[i]);\n        }\n        \n        int k;\n        scanf(\"%d\", &k);\n        \n        int result = binarySearch(arr, n, k);\n        printf(\"%d\\n\", result);\n    }\n    \n    return 0;\n}\n", "perturbed_sampled": ["#include <stdio.h>  left =   right) { int  / 2;   if (target < arr[mid]) { right =  { left =    int arr[100]; for (int i = 0; i < n; i++) { scanf(\"%d\", &arr[i]); } int k;  result); } return 0; }"], "perturbed_original": ["#define _CRT_SECURE_NO_WARNINGS //#define  #define P(type,x) fprintf(stdout,\"%\"#type\"\\n\",x) int   = cnt = 0, r = n -  i < n; i++) fscanf(stdin, \"%d\", &A[i]); fscanf(stdin, \"%d\", &key); while (l <= r)  r) /  key) l =  }"], "original_ll": -1.1881662607192993, "sampled_ll": -0.4395429790019989, "all_perturbed_sampled_ll": [-2.4880194664001465], "all_perturbed_original_ll": [-3.4535698890686035], "perturbed_sampled_ll": -2.4880194664001465, "perturbed_original_ll": -3.4535698890686035, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import java.util.*;\n\npublic class Main{\n    Main(){\n\tScanner sc = new Scanner(System.in);\n\n\twhile(sc.hasNext()){\n\t    int r = sc.nextInt(), t, cnt=1, l=0;\n\t    if(r == 0) break;\n\t    int[] ary = new int[r+1];\n\t    \n\t    for(int i = 0; i < r; i++)\n\t\tary[i] = sc.nextInt();\n\t    t = sc.nextInt();\n\t    r--;\n\n\t    while(l <= r){\n\t\tint v = (l+r)/2;\n\n\t\tif(ary[v] == t || l >= r) break;\n\t\telse if(ary[v] < t) l = v+1;\n\t\telse r = v-1;\n\n\t\tcnt++;\n\t    }\n\n\t    System.out.println(Integer.toString(cnt));\n\t}\n    }\n\n    public static void main(String[] args){\n\tnew Main();\n    }\n}", "sampled": "import java.util.Scanner;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        \n        while (true) {\n            int n = sc.nextInt();\n            if (n == 0) break;\n            \n            int[] arr = new int[n];\n            for (int i = 0; i < n; i++) {\n                arr[i] = sc.nextInt();\n            }\n            \n            int k = sc.nextInt();\n            \n            int count = 0;\n            int left = 0;\n            int right = n - 1;\n            \n            while (left <= right) {\n                int mid = (left + right) / 2;\n                count++;\n                \n                if (arr[mid] == k) {\n                    break;\n                } else if (k < arr[mid]) {\n                    right = mid - 1;\n                } else {\n                    left = mid + 1;\n                }\n            }\n            \n            System.out.println(count);\n        }\n        \n        sc.close();\n    }\n}\n", "perturbed_sampled": ["import java.util.Scanner; public class Main { public static void  = new Scanner(System.in); while (true) { int  == 0) break; int[]  (int  n; i++) {  left  (left <= right)  +   < arr[mid]) { right = mid  left = mid + 1; }  }"], "perturbed_original": ["import java.util.*; public class Main{ Main(){ Scanner  int r = sc.nextInt(), t,  break;  for(int i =  ary[i]   >= r)  l =  cnt++;  static void main(String[] args){ new Main(); } }"], "original_ll": -1.1872246265411377, "sampled_ll": -0.318664014339447, "all_perturbed_sampled_ll": [-2.894334316253662], "all_perturbed_original_ll": [-3.3948493003845215], "perturbed_sampled_ll": -2.894334316253662, "perturbed_original_ll": -3.3948493003845215, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import math\n\ndef f(check, n, L, count):\n    count += 1\n    median = int(math.floor(float(n-1)/2))\n    if len(L) == 1:\n        return count\n    elif L[median] == check:\n        return count\n    elif L[median] < check:\n        L = L[median+1:]\n    elif check < L[median]:\n        L = L[:median]\n    n = len(L)\n    return f(check, n, L, count)\n\nwhile True:\n    n = int(raw_input())\n    if n == 0: break\n    L = [int(raw_input()) for i in range(n)]\n    check = int(raw_input())\n    print f(check, n, L, 0)", "sampled": "while True:\n    n = int(input())\n    if n == 0:\n        break\n    \n    arr = []\n    for _ in range(n):\n        arr.append(int(input()))\n    \n    k = int(input())\n    \n    left = 0\n    right = n - 1\n    count = 0\n    \n    while left <= right:\n        mid = (left + right) // 2\n        count += 1\n        \n        if arr[mid] == k:\n            break\n        elif k < arr[mid]:\n            right = mid - 1\n        else:\n            left = mid + 1\n    \n    print(count)\n", "perturbed_sampled": ["while True: n = int(input()) if n ==  for _ in  left = 0 right = n - 1 count  right:   break  =  print(count)"], "perturbed_original": ["import math    return count elif L[median] == check: return count elif L[median] < check: L =   L, count) while  = int(raw_input()) print f(check, n, L, 0)"], "original_ll": -1.0441051721572876, "sampled_ll": -0.4932064116001129, "all_perturbed_sampled_ll": [-3.365736246109009], "all_perturbed_original_ll": [-3.9905953407287598], "perturbed_sampled_ll": -3.365736246109009, "perturbed_original_ll": -3.9905953407287598, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "#include <stdio.h>\n#include <math.h>\n#include <stdlib.h>\n\ntypedef struct{\n\tlong long int code;\n\tint steps;\n} puzz;\n\nint q[10000000][14],size[30000],size2[30000];\nlong long int FR,TO,SW;\npuzz* hash[30000][100],hash2[30000][100];\n\nvoid swap (int* x,int* y){\n\tint z;\n\tz=*x;\n\t*x=*y;\n\t*y=z;\n}\n\nlong long int convert(int a[]){\n\tlong long int ret=0;\n\tint i;\n\tfor(i=0;i<13;i++)ret=ret*13+a[i];\n\treturn ret;\n}\n\nvoid hashadd(long long int code,int step){\n\tint ccc=code%30000;\n\tpuzz* ppp=(puzz*)malloc(sizeof(puzz));\n\tppp->code=code;\n\tppp->steps=step;\n\tif(size[ccc]>99){fprintf(stderr,\"SIZE OVER!! (%d)\\n\",ccc);return;}\n\thash[ccc][size[ccc]]=ppp;\n\tsize[ccc]++;\n}\n\nint hashsearch(long long int code){\n\tint ccc=code%30000;\n\tint i=size[ccc];\n\tfor(i--;i>=0;i--){\n\t\tif(hash[ccc][i]->code==code)return hash[ccc][i]->steps;\n\t}\n\treturn -1;\n}\n\nvoid mark(int x,int y){\n\tint k;\n\tlong long int cd;\n\n\tswap(&q[FR][x],&q[FR][y]);\n\tcd=convert(q[FR]);\n\n\tif(SW==1 || hashsearch(cd)<0){\n\t\tfor(k=0;k<14;k++){q[TO][k]=q[FR][k];}\n\t\tq[TO][13]++;\n\t\tif(SW==0)hashadd(cd,q[TO][13]);\n\t\tTO++;\n\t}\n\n\tswap(&q[FR][x],&q[FR][y]);\n\n}\n\nvoid check(){\n\tif(q[FR][0]==0){mark(0,2);}\n\tif(q[FR][1]==0){mark(1,2);mark(1,5);}\n\tif(q[FR][2]==0){mark(2,0);mark(2,1);mark(2,3);mark(2,6);}\n\tif(q[FR][3]==0){mark(3,2);mark(3,7);}\n\tif(q[FR][4]==0){mark(4,5);}\n\tif(q[FR][5]==0){mark(5,1);mark(5,4);mark(5,6);mark(5,9);}\n\tif(q[FR][6]==0){mark(6,2);mark(6,5);mark(6,7);mark(6,10);}\n\tif(q[FR][7]==0){mark(7,3);mark(7,6);mark(7,8);mark(7,11);}\n\tif(q[FR][8]==0){mark(8,7);}\n\tif(q[FR][9]==0){mark(9,5);mark(9,10);}\n\tif(q[FR][10]==0){mark(10,6);mark(10,9);mark(10,11);mark(10,12);}\n\tif(q[FR][11]==0){mark(11,7);mark(11,10);}\n\tif(q[FR][12]==0){mark(12,10);}\n}\n\n\nint main(){\n\tint i,ans;\n\tlong long int cd;\n\n\tfor(i=1;i<12;i++)q[0][i]=i;\n\tq[0][0]=0;q[0][12]=0;q[0][13]=0;\n\n\tFR=0;TO=1;SW=0;\n\n\twhile(FR<TO && q[FR][13]<=13){\n\t\tcheck();\n\t\tFR++;\n\t}\n\n\twhile(scanf(\"%d\",&q[0][0])*q[0][0]>=0){\n\t\tfor(i=1;i<13;i++)scanf(\"%d\",&q[0][i]);\n\t\tq[0][13]=0;FR=0;TO=1;SW=1;ans=9999;\n\t\t//for(i=0;i<30000;i++)size2[i]=0;\n\n\t\twhile(FR<TO){\n\t\t\tcd=hashsearch(convert(q[FR]));\n\t\t\tif(cd>=0){\n\t\t\t\tif(FR>0 && cd!=14)fprintf(stderr,\"%d?\\n\",cd);\n\t\t\t\tans=(int)cd+q[FR][13];\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif(q[FR][13]<6)check();\n\t\t\tFR++;\n\t\t}\n\n\t\tif(ans>20 && ans<9999)fprintf(stderr,\"ans:%d?\\n\",ans);\n\t\tif(ans>20)printf(\"NA\\n\"); else printf(\"%d\\n\",ans);\n\t}\n\n\treturn 0;\n}", "sampled": "#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n\n#define MAX_DEPTH 20\n\ntypedef struct {\n    int board[13];\n    int zero1, zero2;\n} State;\n\nint goal[13] = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 0, 0};\n\nint adj[13][5] = {\n    {1, -1, -1, -1, -1},     // 0\n    {0, 2, 3, -1, -1},       // 1\n    {1, 4, -1, -1, -1},      // 2\n    {1, 4, 5, -1, -1},       // 3\n    {2, 3, 6, 8, -1},        // 4\n    {3, 6, 9, -1, -1},       // 5\n    {4, 5, 7, 10, -1},       // 6\n    {6, 8, 11, -1, -1},      // 7\n    {4, 7, 11, -1, -1},      // 8\n    {5, 10, -1, -1, -1},     // 9\n    {6, 9, 11, -1, -1},      // 10\n    {7, 8, 10, 12, -1},      // 11\n    {11, -1, -1, -1, -1}     // 12\n};\n\nint isGoal(State *s) {\n    for (int i = 0; i < 13; i++) {\n        if (s->board[i] != goal[i]) return 0;\n    }\n    return 1;\n}\n\ntypedef struct {\n    State state;\n    int depth;\n} QueueItem;\n\nQueueItem queue[10000000];\nint qfront, qback;\n\nunsigned long long hash(State *s) {\n    unsigned long long h = 0;\n    for (int i = 0; i < 13; i++) {\n        h = h * 13 + s->board[i];\n    }\n    return h;\n}\n\nint visited[1 << 24];\n\nint getVisitedIndex(unsigned long long h) {\n    return (int)(h % (1 << 24));\n}\n\nint solve(State *init) {\n    if (isGoal(init)) return 0;\n    \n    memset(visited, 0, sizeof(visited));\n    qfront = qback = 0;\n    \n    queue[qback].state = *init;\n    queue[qback].depth = 0;\n    qback++;\n    \n    unsigned long long h = hash(init);\n    visited[getVisitedIndex(h)] = 1;\n    \n    while (qfront < qback) {\n        QueueItem cur = queue[qfront++];\n        \n        if (cur.depth >= MAX_DEPTH) continue;\n        \n        int zeros[2] = {cur.state.zero1, cur.state.zero2};\n        \n        for (int zi = 0; zi < 2; zi++) {\n            int zpos = zeros[zi];\n            \n            for (int i = 0; adj[zpos][i] != -1; i++) {\n                int npos = adj[zpos][i];\n                \n                State next = cur.state;\n                next.board[zpos] = next.board[npos];\n                next.board[npos] = 0;\n                \n                if (zi == 0) {\n                    next.zero1 = npos;\n                } else {\n                    next.zero2 = npos;\n                }\n                \n                if (next.zero1 > next.zero2) {\n                    int tmp = next.zero1;\n                    next.zero1 = next.zero2;\n                    next.zero2 = tmp;\n                }\n                \n                if (isGoal(&next)) {\n                    return cur.depth + 1;\n                }\n                \n                h = hash(&next);\n                int idx = getVisitedIndex(h);\n                if (!visited[idx]) {\n                    visited[idx] = 1;\n                    queue[qback].state = next;\n                    queue[qback].depth = cur.depth + 1;\n                    qback++;\n                }\n            }\n        }\n    }\n    \n    return -1;\n}\n\nint main() {\n    int first;\n    while (scanf(\"%d\", &first) == 1 && first != -1) {\n        State init;\n        init.board[0] = first;\n        \n        for (int i = 1; i < 13; i++) {\n            scanf(\"%d\", &init.board[i]);\n        }\n        \n        init.zero1 = -1;\n        init.zero2 = -1;\n        for (int i = 0; i < 13; i++) {\n            if (init.board[i] == 0) {\n                if (init.zero1 == -1) init.zero1 = i;\n                else init.zero2 = i;\n            }\n        }\n        \n        int result = solve(&init);\n        \n        if (result == -1) {\n            printf(\"NA\\n\");\n        } else {\n            printf(\"%d\\n\", result);\n        }\n    }\n    \n    return 0;\n}\n", "perturbed_sampled": ["#include <stdio.h> #include <string.h> #include   6, 7, 8, 9, 10, 11, 0, 0}; int    -1}, // 4 {3, 6, 9, -1, -1}, // 5 {4, 5, 7, 10, -1}, // 6 {6,  7 {4, 7, 11, -1, -1}, //  9, 11, -1, -1}, //  -1}, // 11 {11, -1,  };  i <  != goal[i]) return 0; } return  State state; int   = 0; for (int  13; i++) { h = h * 13 + s->board[i]; }  << 24];  { return (int)(h   =  = hash(init); visited[getVisitedIndex(h)]  zeros[2] = {cur.state.zero1, cur.state.zero2}; for  < 2; zi++) { int  i = 0; adj[zpos][i] != -1; i++) { int npos =  =  }  } if (next.zero1 > next.zero2) { int tmp =  (isGoal(&next)) { return cur.depth + 1; } h = hash(&next);  (!visited[idx]) { visited[idx] = 1; queue[qback].state  + 1; qback++; } } } }  { int first; while (scanf(\"%d\", &first)  -1) { State  { scanf(\"%d\", &init.board[i]); } init.zero1 = -1; init.zero2 =  i++) {  if (init.zero1 == -1)   printf(\"%d\\n\", result); } } return 0; }"], "perturbed_original": [" <stdlib.h>  code; int steps; } puzz;  swap  z=*x; *x=*y; *y=z; } long long int convert(int a[]){ long long  return ret; }   ppp->code=code; ppp->steps=step;    for(i--;i>=0;i--){ if(hash[ccc][i]->code==code)return hash[ccc][i]->steps; } return  y){ int k;  for(k=0;k<14;k++){q[TO][k]=q[FR][k];} q[TO][13]++;  void check(){ if(q[FR][0]==0){mark(0,2);} if(q[FR][1]==0){mark(1,2);mark(1,5);} if(q[FR][2]==0){mark(2,0);mark(2,1);mark(2,3);mark(2,6);}  if(q[FR][12]==0){mark(12,10);}   while(FR<TO){ cd=hashsearch(convert(q[FR]));  break; } if(q[FR][13]<6)check(); FR++; } if(ans>20 && ans<9999)fprintf(stderr,\"ans:%d?\\n\",ans); if(ans>20)printf(\"NA\\n\"); else printf(\"%d\\n\",ans); } return 0; }"], "original_ll": -0.9786497354507446, "sampled_ll": -0.5188292264938354, "all_perturbed_sampled_ll": [-2.4953603744506836], "all_perturbed_original_ll": [-2.2935991287231445], "perturbed_sampled_ll": -2.4953603744506836, "perturbed_original_ll": -2.2935991287231445, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "\nimport java.util.ArrayDeque;\nimport java.util.Deque;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.Map;\nimport java.util.Scanner;\nimport java.util.Set;\n\npublic class Main {\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n\n\tprivate void run() {\n\t\tScanner scanner = new Scanner(System.in);\n\t\tint[][] adj = { { 2 }, { 2, 5 }, { 0, 1, 3, 6 }, { 2, 7 }, { 5 },\n\t\t\t\t{ 1, 4, 6, 9 }, { 2, 5, 7, 10 }, { 3, 6, 8, 11 }, { 7 },\n\t\t\t\t{ 5, 10 }, { 6, 9, 11, 12 }, { 7, 10 }, { 10 } };\n\t\tString g = \"0ABCDEFGHIJK0\";\n\t\tMap<String, Integer> m = new HashMap<String, Integer>();\n\t\tDeque<String> deque = new ArrayDeque<String>();\n\t\tint step = 1;\n\t\tdeque.offer(g);\n\t\tm.put(g, 0);\n\t\twhile (!deque.isEmpty() && step < 10) {\n\t\t\tint size = deque.size();\n\t\t\tfor (int k = 0; k < size; k++) {\n\t\t\t\tString s = deque.pop();\n\t\t\t\tchar[] c = s.toCharArray();\n\t\t\t\tfor (int i = 0; i < 13; i++) {\n\t\t\t\t\tif (c[i] == '0') {\n\t\t\t\t\t\tfor (int j = 0; j < adj[i].length; j++) {\n\t\t\t\t\t\t\tc[i] = c[adj[i][j]];\n\t\t\t\t\t\t\tc[adj[i][j]] = '0';\n\t\t\t\t\t\t\tString n = String.valueOf(c);\n\t\t\t\t\t\t\tif (!m.containsKey(n)) {\n\t\t\t\t\t\t\t\tm.put(n, step);\n\t\t\t\t\t\t\t\tdeque.offer(n);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tc[adj[i][j]] = c[i];\n\t\t\t\t\t\t\tc[i] = '0';\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tstep++;\n\t\t}\n\t\twhile (true) {\n\t\t\tint p = scanner.nextInt();\n\t\t\tif (p == -1)\n\t\t\t\tbreak;\n\t\t\tchar[] cc = new char[13];\n\t\t\tcc[0] = p == 0 ? '0' : (char) (p - 1 + 'A');\n\t\t\tfor (int i = 1; i < 13; i++) {\n\t\t\t\tp = scanner.nextInt();\n\t\t\t\tcc[i] = p == 0 ? '0' : (char) (p - 1 + 'A');\n\t\t\t}\n\t\t\tString st = String.valueOf(cc);\n\t\t\tSet<String> set = new HashSet<String>();\n\t\t\tdeque.clear();\n\t\t\tdeque.offer(st);\n\t\t\tstep = 0;\n\t\t\tboolean flag = false;\n\t\t\tString ans = \"\";\n\t\t\tloop: while (!deque.isEmpty() && step < 10) {\n\t\t\t\tint size = deque.size();\n\t\t\t\tfor (int w = 0; w < size; w++) {\n\t\t\t\t\tString s = deque.pop();\n\t\t\t\t\tif (m.containsKey(s)) {\n\t\t\t\t\t\tflag = true;\n\t\t\t\t\t\tans = s;\n\t\t\t\t\t\tbreak loop;\n\t\t\t\t\t}\n\t\t\t\t\tchar[] cs = s.toCharArray();\n\t\t\t\t\tfor (int i = 0; i < 13; i++) {\n\t\t\t\t\t\tif (cs[i] == '0') {\n\t\t\t\t\t\t\tfor (int j = 0; j < adj[i].length; j++) {\n\t\t\t\t\t\t\t\tcs[i] = cs[adj[i][j]];\n\t\t\t\t\t\t\t\tcs[adj[i][j]] = '0';\n\t\t\t\t\t\t\t\tString news = String.valueOf(cs);\n\t\t\t\t\t\t\t\tif (!set.contains(news)) {\n\t\t\t\t\t\t\t\t\tset.add(news);\n\t\t\t\t\t\t\t\t\tdeque.offer(news);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tcs[adj[i][j]] = cs[i];\n\t\t\t\t\t\t\t\tcs[i] = '0';\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t}\n\t\t\t\tstep++;\n\t\t\t}\n\t\t\tSystem.out.println(flag ? m.get(ans) : \"NA\");\n\n\t\t}\n\t}\n}", "sampled": "import java.util.*;\n\npublic class Main {\n    static final int[] GOAL = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 0, 0};\n    \n    static class State {\n        int[] board;\n        int steps;\n        \n        State(int[] board, int steps) {\n            this.board = board.clone();\n            this.steps = steps;\n        }\n        \n        String hash() {\n            return Arrays.toString(board);\n        }\n    }\n    \n    static int[] readInput(Scanner sc) {\n        int[] board = new int[13];\n        int idx = 0;\n        \n        // Row 1: 1 element\n        board[idx++] = sc.nextInt();\n        \n        // Row 2: 3 elements\n        for (int i = 0; i < 3; i++) {\n            board[idx++] = sc.nextInt();\n        }\n        \n        // Row 3: 5 elements\n        for (int i = 0; i < 5; i++) {\n            board[idx++] = sc.nextInt();\n        }\n        \n        // Row 4: 3 elements\n        for (int i = 0; i < 3; i++) {\n            board[idx++] = sc.nextInt();\n        }\n        \n        // Row 5: 1 element\n        board[idx++] = sc.nextInt();\n        \n        return board;\n    }\n    \n    static int[][] getNeighbors() {\n        int[][] neighbors = new int[13][];\n        neighbors[0] = new int[]{1};\n        neighbors[1] = new int[]{0, 2, 4};\n        neighbors[2] = new int[]{1, 3, 5};\n        neighbors[3] = new int[]{2, 6};\n        neighbors[4] = new int[]{1, 5, 7};\n        neighbors[5] = new int[]{2, 4, 6, 8};\n        neighbors[6] = new int[]{3, 5, 9};\n        neighbors[7] = new int[]{4, 8, 10};\n        neighbors[8] = new int[]{5, 7, 9, 11};\n        neighbors[9] = new int[]{6, 8, 12};\n        neighbors[10] = new int[]{7, 11};\n        neighbors[11] = new int[]{8, 10, 12};\n        neighbors[12] = new int[]{9, 11};\n        return neighbors;\n    }\n    \n    static int solve(int[] initial) {\n        if (Arrays.equals(initial, GOAL)) {\n            return 0;\n        }\n        \n        Queue<State> queue = new LinkedList<>();\n        Set<String> visited = new HashSet<>();\n        \n        State start = new State(initial, 0);\n        queue.offer(start);\n        visited.add(start.hash());\n        \n        int[][] neighbors = getNeighbors();\n        \n        while (!queue.isEmpty()) {\n            State curr = queue.poll();\n            \n            if (curr.steps >= 20) {\n                continue;\n            }\n            \n            // Find empty spaces\n            List<Integer> empties = new ArrayList<>();\n            for (int i = 0; i < 13; i++) {\n                if (curr.board[i] == 0) {\n                    empties.add(i);\n                }\n            }\n            \n            // Try moving tiles into empty spaces\n            for (int emptyPos : empties) {\n                for (int neighbor : neighbors[emptyPos]) {\n                    if (curr.board[neighbor] != 0) {\n                        int[] newBoard = curr.board.clone();\n                        newBoard[emptyPos] = newBoard[neighbor];\n                        newBoard[neighbor] = 0;\n                        \n                        if (Arrays.equals(newBoard, GOAL)) {\n                            return curr.steps + 1;\n                        }\n                        \n                        String hash = Arrays.toString(newBoard);\n                        if (!visited.contains(hash)) {\n                            visited.add(hash);\n                            queue.offer(new State(newBoard, curr.steps + 1));\n                        }\n                    }\n                }\n            }\n        }\n        \n        return -1;\n    }\n    \n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        \n        while (true) {\n            int first = sc.nextInt();\n            if (first == -1) break;\n            \n            int[] board = new int[13];\n            board[0] = first;\n            \n            for (int i = 1; i < 13; i++) {\n                board[i] = sc.nextInt();\n            }\n            \n            int result = solve(board);\n            if (result == -1) {\n                System.out.println(\"NA\");\n            } else {\n                System.out.println(result);\n            }\n        }\n        \n        sc.close();\n    }\n}\n", "perturbed_sampled": ["import java.util.*; public class Main { static final int[]  State  this.steps = steps; } String hash() { return Arrays.toString(board); } } static int[] readInput(Scanner sc) { int[]  idx = 0; // Row 1: 1   (int i = 0;  elements   // Row  i  i++) { board[idx++] = sc.nextInt(); }   } static int[][] getNeighbors() { int[][]  =  5}; neighbors[3] = new int[]{2, 6}; neighbors[4] = new int[]{1,  int[]{2, 4,  10}; neighbors[8]  11}; neighbors[9] = new    if (Arrays.equals(initial,    State start = new State(initial, 0);  getNeighbors(); while (!queue.isEmpty()) { State curr = queue.poll();  continue; } //  =  = 0; i < 13;   // Try moving tiles into empty spaces for (int emptyPos  neighbor : neighbors[emptyPos]) {  int[] newBoard = curr.board.clone(); newBoard[emptyPos] = newBoard[neighbor]; newBoard[neighbor] =  return curr.steps + 1;   }   main(String[] args)  Scanner(System.in); while (true) { int  { board[i]  = solve(board); if (result == -1) { System.out.println(\"NA\"); } else { System.out.println(result); } } sc.close(); } }"], "perturbed_original": ["import java.util.ArrayDeque; import java.util.Deque; import java.util.HashMap;    main(String[] args) { new Main().run(); } private  = new Scanner(System.in); int[][]   7 }, {  }, { 3, 6, 8, 11 }, { 7  12 }, { 7,  = new  new ArrayDeque<String>(); int step = 1; deque.offer(g); m.put(g, 0);  =  = s.toCharArray(); for (int i = 0; i < 13; i++) {  for (int j = 0;   String.valueOf(c); if (!m.containsKey(n)) { m.put(n, step); deque.offer(n); } c[adj[i][j]] = c[i]; c[i] = '0';  } while (true) { int p = scanner.nextInt();   i =  cc[i]  - 1  = new  \"\"; loop: while (!deque.isEmpty() && step < 10) { int size = deque.size(); for (int w = 0; w  break loop; } char[]  = 0; j < adj[i].length; j++)  = '0'; String news = String.valueOf(cs);  } cs[adj[i][j]] = cs[i]; cs[i] = '0'; } } } } step++; } System.out.println(flag ? m.get(ans) : \"NA\"); } } }"], "original_ll": -0.6402527689933777, "sampled_ll": -0.43421727418899536, "all_perturbed_sampled_ll": [-2.517678737640381], "all_perturbed_original_ll": [-2.2589163780212402], "perturbed_sampled_ll": -2.517678737640381, "perturbed_original_ll": -2.2589163780212402, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "from math import factorial\nfrom Queue import PriorityQueue\n\nFACTORIAL=[factorial(i) for i in xrange(13)]\nLEFT,UP,RIGHT,DOWN=0,1,2,3\nMOVE=[[0] for u in xrange(13)]\nMOVE[0] =[-1,-1,-1, 2]\nMOVE[1] =[-1,-1, 2, 5]\nMOVE[2] =[ 1, 0, 3, 6]\nMOVE[3] =[ 2,-1,-1, 7] \nMOVE[4] =[-1,-1, 5,-1]\nMOVE[5] =[ 4, 1, 6, 9]\nMOVE[6] =[ 5, 2, 7,10]\nMOVE[7] =[ 6, 3, 8,11]\nMOVE[8] =[ 7,-1,-1,-1]\nMOVE[9] =[-1, 5,10,-1]\nMOVE[10]=[ 9, 6,11,12]\nMOVE[11]=[10, 7,-1,-1]\nMOVE[12]=[-1,10,-1,-1]\n\ndef hash(cell):\n    work = cell[:]\n    hash = 0\n    for i in xrange(12):\n        hash += work[i] * FACTORIAL[13-1-i]\n        for ii in xrange(i+1,13):\n            if work[ii]>work[i]:\n                work[ii]-=1\n    return hash\n\ndef dehash(key):\n    cell=[]\n    for i in xrange(13):\n        cell.append(key/FACTORIAL[13-1-i])\n        key %= FACTORIAL[13-1-i]\n    for i in xrange(13-1,-1,-1):\n        for ii in xrange(i+1,13):\n            if cell[i]<=cell[ii]:\n                cell[ii]+=1\n    return cell\n\ndef evaluate(cell):\n    point=[[0,2],\n           [1,1],[1,2],[1,3],\n           [2,0],[2,1],[2,2],[2,3],[2,4],\n           [3,1],[3,2],[3,3],\n           [4,2]]\n    eva=0\n    for i in xrange(0,13):\n        if not (cell[i]==0 or cell[i]==12):\n            eva+=abs(point[cell[i]][0]-point[i][0])\n            eva+=abs(point[cell[i]][1]-point[i][1])\n    return eva\n\nANS_HASH=[hash([0,1,2,3,4,5,6,7,8,9,10,11,12]),hash([12,1,2,3,4,5,6,7,8,9,10,11,0])]          \n\nwhile True:\n    p=[input()]\n    if p==[-1]:\n        break\n    for u in xrange(4):\n        for pp in map(int,raw_input().split()):\n            p.append(pp)\n    p[p.index(0)]=12\n    pq = PriorityQueue()\n    pq.put([evaluate(p),hash(p),0])\n    visited={}\n    visited[hash(p)]=True\n    ans=0 if hash(p) in ANS_HASH else \"NA\"\n    #cur=[eva,hashkey,step]\n    while not pq.empty():\n        eva,cur_hash,cur_step=pq.get()\n        cur_cell=dehash(cur_hash)\n        if not (eva<=20 and ans==\"NA\"):\n            break\n        for i in xrange(13):\n            if cur_cell[i]==0 or cur_cell[i]==12:\n                for ii in [LEFT,UP,RIGHT,DOWN]:\n                    if not MOVE[i][ii]==-1:\n                        cur_cell[i],cur_cell[MOVE[i][ii]]=cur_cell[MOVE[i][ii]],cur_cell[i]\n                        hashkey=hash(cur_cell)\n                        if not hashkey in visited:\n                            if hashkey in ANS_HASH:\n                                ans=cur_step+1\n                                break\n                            pq.put([evaluate(cur_cell)+cur_step+1,hashkey,cur_step+1])\n                            visited[hashkey]=True\n                        cur_cell[i],cur_cell[MOVE[i][ii]]=cur_cell[MOVE[i][ii]],cur_cell[i]\n    print ans", "sampled": "from collections import deque\n\ndef read_puzzle():\n    line = input().strip()\n    if line == '-1':\n        return None\n    \n    puzzle = []\n    puzzle.append(list(map(int, line.split())))\n    puzzle.append(list(map(int, input().split())))\n    puzzle.append(list(map(int, input().split())))\n    puzzle.append(list(map(int, input().split())))\n    input()  # empty line\n    \n    return puzzle\n\ndef puzzle_to_tuple(puzzle):\n    result = []\n    for row in puzzle:\n        result.extend(row)\n    return tuple(result)\n\ndef tuple_to_puzzle(t):\n    puzzle = []\n    puzzle.append(list(t[0:1]))\n    puzzle.append(list(t[1:4]))\n    puzzle.append(list(t[4:9]))\n    puzzle.append(list(t[9:12]))\n    return puzzle\n\ndef get_neighbors(puzzle):\n    neighbors = []\n    \n    # Find all zeros\n    zeros = []\n    for i in range(len(puzzle)):\n        for j in range(len(puzzle[i])):\n            if puzzle[i][j] == 0:\n                zeros.append((i, j))\n    \n    # For each zero, find adjacent numbers that can move\n    for zi, zj in zeros:\n        # Check all 4 directions\n        directions = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n        for di, dj in directions:\n            ni, nj = zi + di, zj + dj\n            if 0 <= ni < len(puzzle) and 0 <= nj < len(puzzle[ni]):\n                if puzzle[ni][nj] != 0:\n                    # Make a move\n                    new_puzzle = [row[:] for row in puzzle]\n                    new_puzzle[zi][zj] = new_puzzle[ni][nj]\n                    new_puzzle[ni][nj] = 0\n                    neighbors.append(new_puzzle)\n    \n    return neighbors\n\ndef solve_puzzle(start_puzzle):\n    goal = (1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 0, 0)\n    \n    start = puzzle_to_tuple(start_puzzle)\n    \n    if start == goal:\n        return 0\n    \n    queue = deque([(start_puzzle, 0)])\n    visited = {start}\n    \n    while queue:\n        current_puzzle, steps = queue.popleft()\n        \n        if steps >= 20:\n            continue\n        \n        for neighbor in get_neighbors(current_puzzle):\n            neighbor_tuple = puzzle_to_tuple(neighbor)\n            \n            if neighbor_tuple == goal:\n                return steps + 1\n            \n            if neighbor_tuple not in visited:\n                visited.add(neighbor_tuple)\n                queue.append((neighbor, steps + 1))\n    \n    return -1\n\nwhile True:\n    puzzle = read_puzzle()\n    if puzzle is None:\n        break\n    \n    result = solve_puzzle(puzzle)\n    if result == -1:\n        print(\"NA\")\n    else:\n        print(result)\n", "perturbed_sampled": ["from collections import deque def  None puzzle = [] puzzle.append(list(map(int,   line return puzzle def puzzle_to_tuple(puzzle): result =  return puzzle def get_neighbors(puzzle): neighbors = [] # Find all zeros zeros = [] for i   each zero,  in zeros: #  = [(-1, 0), (1, 0), (0,     ni < len(puzzle) and 0 <= nj <  # Make a move new_puzzle = [row[:] for row  new_puzzle[ni][nj] = 0   = {start} while queue: current_puzzle, steps = queue.popleft()  neighbor_tuple  goal: return steps + 1 if neighbor_tuple not in visited: visited.add(neighbor_tuple) queue.append((neighbor, steps + 1)) return  -1: print(\"NA\") else: print(result)"], "perturbed_original": ["from math import factorial from Queue import  u in xrange(13)] MOVE[0]  5] MOVE[2] =[ 1, 0, 3,  MOVE[4] =[-1,-1, 5,-1] MOVE[5] =[ 4,  5, 2, 7,10]  =[-1,  7,-1,-1] MOVE[12]=[-1,10,-1,-1] def  = 0 for i in xrange(12): hash += work[i] * FACTORIAL[13-1-i]   in xrange(13-1,-1,-1): for ii in xrange(i+1,13):  [2,0],[2,1],[2,2],[2,3],[2,4], [3,1],[3,2],[3,3],  xrange(0,13): if  eva+=abs(point[cell[i]][1]-point[i][1]) return eva ANS_HASH=[hash([0,1,2,3,4,5,6,7,8,9,10,11,12]),hash([12,1,2,3,4,5,6,7,8,9,10,11,0])] while True:   hash(p) in ANS_HASH  pq.empty():  and ans==\"NA\"): break  cur_cell[i]==0 or cur_cell[i]==12: for ii in  hashkey=hash(cur_cell) if   pq.put([evaluate(cur_cell)+cur_step+1,hashkey,cur_step+1]) visited[hashkey]=True cur_cell[i],cur_cell[MOVE[i][ii]]=cur_cell[MOVE[i][ii]],cur_cell[i] print ans"], "original_ll": -1.0346330404281616, "sampled_ll": -0.6055989265441895, "all_perturbed_sampled_ll": [-2.9053921699523926], "all_perturbed_original_ll": [-2.390002489089966], "perturbed_sampled_ll": -2.9053921699523926, "perturbed_original_ll": -2.390002489089966, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "double g[100][100],G[100],H[100],a;main(n,m,i,j){for(;scanf(\"%d%d\",&n,&m),n;printf(\"%.2f\\n\",a)){for(i=n;i--;G[i]=1)for(j=n;j--;)scanf(\"%lf\",g[i]+j);for(;--m;memcpy(G,H,8*n))for(i=n;i--;)for(H[i]=0,j=n;j--;a>H[i]?H[i]=a:0)a=G[j]*g[j][i];for(a=0;n--;)G[n]>a?a=G[n]:0;}exit(0);}", "sampled": "#include <stdio.h>\n#include <string.h>\n\nint main() {\n    int n, m;\n    double g[101][101];\n    double dp[101][101];\n    \n    while (scanf(\"%d %d\", &n, &m) == 2) {\n        if (n == 0 && m == 0) break;\n        \n        for (int i = 1; i <= n; i++) {\n            for (int j = 1; j <= n; j++) {\n                scanf(\"%lf\", &g[i][j]);\n            }\n        }\n        \n        memset(dp, 0, sizeof(dp));\n        \n        for (int i = 1; i <= n; i++) {\n            dp[1][i] = 1.0;\n        }\n        \n        for (int step = 2; step <= m; step++) {\n            for (int curr = 1; curr <= n; curr++) {\n                dp[step][curr] = 0.0;\n                for (int prev = 1; prev <= n; prev++) {\n                    double val = dp[step-1][prev] * g[prev][curr];\n                    if (val > dp[step][curr]) {\n                        dp[step][curr] = val;\n                    }\n                }\n            }\n        }\n        \n        double max_size = 0.0;\n        for (int i = 1; i <= n; i++) {\n            if (dp[m][i] > max_size) {\n                max_size = dp[m][i];\n            }\n        }\n        \n        printf(\"%.2lf\\n\", max_size);\n    }\n    \n    return 0;\n}\n", "perturbed_sampled": [" main() { int n,   == 2) {   i <= n;   =  { dp[1][i] = 1.0; } for (int  m; step++) { for (int curr = 1; curr <= n; curr++) { dp[step][curr]  = 1; prev <= n; prev++) { double val = dp[step-1][prev] *   max_size =  1;  if (dp[m][i]   } return 0; }"], "perturbed_original": ["double g[100][100],G[100],H[100],a;main(n,m,i,j){for(;scanf(\"%d%d\",&n,&m),n;printf(\"%.2f\\n\",a)){for(i=n;i--;G[i]=1)for(j=n;j--;)scanf(\"%lf\",g[i]+j);for(;--m;memcpy(G,H,8*n))for(i=n;i--;)for(H[i]=0,j=n;j--;a>H[i]?H[i]=a:0)a=G[j]*g[j][i];for(a=0;n--;)G[n]>a?a=G[n]:0;}exit(0);}"], "original_ll": -2.362244129180908, "sampled_ll": -0.4183570444583893, "all_perturbed_sampled_ll": [-2.6839513778686523], "all_perturbed_original_ll": [-2.362244129180908], "perturbed_sampled_ll": -2.6839513778686523, "perturbed_original_ll": -2.362244129180908, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import java.util.*;\npublic class Main {\n    static Scanner sc = new Scanner(System.in);\n    static int n, m;\n    static double[][] dp, table;\n\n    public static void main(String[] args) {\n        while(read()){\n            solve();\n        }\n\n    }\n\n    static boolean read(){\n        if(!sc.hasNext())return false;\n        n = sc.nextInt();\n        m = sc.nextInt();\n        if(n == 0 || m == 0)return false;\n        dp = new double[m][n];\n        table = new double[m][n];\n\n        for(int i = 0; i < m; i++){\n            for(int j = 0; j < n; j++){\n                table[i][j] = sc.nextDouble();\n            }\n        }\n\n        for(int i = 0; i < 1; i++){\n            for(int j = 0; j < n; j++){\n                dp[i][j] = 1.0;\n            }\n        }\n\n        return true;\n    }\n\n    static void solve(){\n        int index = 0;\n        double value = 0.0, res = 0.0;\n        double[] array = new double[n];\n        for(int i = 0; i < m-1; i++){\n            for(int j = 0; j < n; j++){\n                for(int k = 0; k < n; k++){\n                    array[k] = table[j][k];\n                }\n                for(int k = 0; k < n; k++){\n                    if(value < array[k]){\n                        index = k;\n                        value = array[k];\n                    }\n                }\n                dp[i+1][index] = Math.max(dp[i+1][index], value*dp[i][j]);\n            }\n        }\n\n        for(int j = 0; j < n; j++){\n            res = Math.max(res, dp[m-1][j]);\n        }\n        System.out.printf(\"%.2f\\n\", res);\n    }\n}", "sampled": "import java.util.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        \n        while (true) {\n            int n = sc.nextInt();\n            int m = sc.nextInt();\n            \n            if (n == 0 && m == 0) break;\n            \n            double[][] g = new double[n][n];\n            for (int i = 0; i < n; i++) {\n                for (int j = 0; j < n; j++) {\n                    g[i][j] = sc.nextDouble();\n                }\n            }\n            \n            if (m == 1) {\n                System.out.println(\"1.00\");\n                continue;\n            }\n            \n            // dp[step][lastFertilizer] = maximum size after 'step' applications with last fertilizer being 'lastFertilizer'\n            double[][] dp = new double[m + 1][n];\n            \n            // Initialize: after 1 application, size is 1.0 for any fertilizer\n            for (int i = 0; i < n; i++) {\n                dp[1][i] = 1.0;\n            }\n            \n            // Fill DP table\n            for (int step = 2; step <= m; step++) {\n                for (int curr = 0; curr < n; curr++) {\n                    dp[step][curr] = 0.0;\n                    for (int prev = 0; prev < n; prev++) {\n                        if (dp[step - 1][prev] > 0) {\n                            dp[step][curr] = Math.max(dp[step][curr], dp[step - 1][prev] * g[prev][curr]);\n                        }\n                    }\n                }\n            }\n            \n            // Find maximum size after m applications\n            double maxSize = 0.0;\n            for (int i = 0; i < n; i++) {\n                maxSize = Math.max(maxSize, dp[m][i]);\n            }\n            \n            System.out.printf(\"%.2f\\n\", maxSize);\n        }\n        \n        sc.close();\n    }\n}\n", "perturbed_sampled": ["import  public static   i++) {  { g[i][j] = sc.nextDouble(); } } if (m == 1) { System.out.println(\"1.00\"); continue; }   after 1 application, size is 1.0 for any  0; i < n; i++) { dp[1][i] = 1.0; }   for (int curr = 0;  dp[step][curr] = 0.0; for (int prev = 0; prev < n; prev++)  > 0) { dp[step][curr] = Math.max(dp[step][curr],  }  maximum size after  0.0; for (int i  Math.max(maxSize, dp[m][i]); } System.out.printf(\"%.2f\\n\", maxSize); } sc.close(); } }"], "perturbed_original": ["import java.util.*; public class Main {  Scanner(System.in); static int n, m; static double[][] dp, table;  { while(read()){ solve(); } } static boolean read(){ if(!sc.hasNext())return  0)return false;  =  0; i < m; i++){  < n; j++){  for(int i  0; j    index = 0; double value = 0.0, res = 0.0; double[] array = new double[n]; for(int i   j < n;  array[k] = table[j][k]; } for(int  n;  0; j   } }"], "original_ll": -0.5806625485420227, "sampled_ll": -0.5914410352706909, "all_perturbed_sampled_ll": [-2.485461950302124], "all_perturbed_original_ll": [-2.783444881439209], "perturbed_sampled_ll": -2.485461950302124, "perturbed_original_ll": -2.783444881439209, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "while 1:\n    n, m = map(int, raw_input().split())\n    if n==0:\n        exit(0)\n    mat = [map(float, raw_input().split()) for i in xrange(n)]\n    dp = [1.0] * n\n    for t in xrange(m-1):\n        dp2 = [-1.0] * n\n        for i in xrange(n):\n            mat_i = mat[i]; dp_i = dp[i]\n            for j in xrange(n):\n                dp2[j] = max(dp2[j], dp_i * mat_i[j])\n        dp = dp2\n    print \"%.02f\" % round(max(dp), 2)", "sampled": "import sys\n\ndef solve(n, m, growth):\n    if m == 1:\n        return 1.0\n    \n    # dp[step][fertilizer] = maximum growth after 'step' applications, ending with 'fertilizer'\n    dp = [[-1.0] * n for _ in range(m + 1)]\n    \n    # After first application, size is 1.0 for any fertilizer\n    for i in range(n):\n        dp[1][i] = 1.0\n    \n    # For each subsequent application\n    for step in range(2, m + 1):\n        for curr in range(n):\n            # Try all possible previous fertilizers\n            for prev in range(n):\n                if dp[step - 1][prev] > 0:\n                    # Apply fertilizer 'curr' after fertilizer 'prev'\n                    new_size = dp[step - 1][prev] * growth[prev][curr]\n                    dp[step][curr] = max(dp[step][curr], new_size)\n    \n    # Find maximum size after m applications\n    max_size = max(dp[m])\n    return max_size\n\nwhile True:\n    line = sys.stdin.readline().strip()\n    if not line:\n        break\n    \n    parts = line.split()\n    n, m = int(parts[0]), int(parts[1])\n    \n    if n == 0 and m == 0:\n        break\n    \n    growth = []\n    for i in range(n):\n        row = list(map(float, sys.stdin.readline().split()))\n        growth.append(row)\n    \n    result = solve(n, m, growth)\n    print(f\"{result:.2f}\")\n", "perturbed_sampled": ["import sys def solve(n, m,  =  + 1)] # After  for any fertilizer for i in  for step in  curr in range(n): # Try all possible previous fertilizers for prev in range(n): if dp[step - 1][prev] > 0: #  - 1][prev] * growth[prev][curr] dp[step][curr] =  size after m  max_size  if not line:  break  in range(n): row = list(map(float, sys.stdin.readline().split()))  growth) print(f\"{result:.2f}\")"], "perturbed_original": ["while 1:  if  raw_input().split()) for i  i in xrange(n): mat_i = mat[i]; dp_i  dp_i * mat_i[j]) dp = dp2 print \"%.02f\" % round(max(dp), 2)"], "original_ll": -1.1147741079330444, "sampled_ll": -0.9602656960487366, "all_perturbed_sampled_ll": [-3.391206741333008], "all_perturbed_original_ll": [-3.7916781902313232], "perturbed_sampled_ll": -3.391206741333008, "perturbed_original_ll": -3.7916781902313232, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "n,T,C[10][2],c,d,O[10][2],t,s,u,v,h,*p;D(h){p=C[s]+h;*p&&T>=O[s][h]?*p=!printf(\"%d%c\",*p,d<n|--c?32:10):0;}main(m){for(;~scanf(\"%d%d\",&m,&n);)for(memset(C,T=c=d=0,80);d<n|c;T++){for(s=m;s--;C[s][1]||D(0))D(1);for(;T>=d*10&d<n&c<m*2;C[s=~u?u:v][h]=++d,O[s][h]=T+t,c++)for(h=scanf(\"%d\",&t),u=v=-1,s=m;h&&s--;)*C[s]?C[s][1]||(*O[s]<T+t?!~v||*O[s]>*O[v]?v=s:0:!~u||*O[s]<*O[u]?u=s:0):(u=s,h=0);}}", "sampled": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#define MAX_SPACES 10\n#define MAX_CARS 100\n\ntypedef struct {\n    int id;\n    int parking_time;\n    int arrival_time;\n    int exit_time;\n} Car;\n\ntypedef struct {\n    int lower_car;\n    int upper_car;\n} Space;\n\ntypedef struct {\n    int car_id;\n    int arrival_time;\n} WaitingCar;\n\nint main() {\n    int m, n;\n    \n    while (1) {\n        scanf(\"%d %d\", &m, &n);\n        if (m == 0 && n == 0) break;\n        \n        Car cars[MAX_CARS];\n        Space spaces[MAX_SPACES];\n        WaitingCar waiting[MAX_CARS];\n        int waiting_count = 0;\n        int output[MAX_CARS];\n        int output_count = 0;\n        \n        for (int i = 0; i < n; i++) {\n            scanf(\"%d\", &cars[i].parking_time);\n            cars[i].id = i + 1;\n            cars[i].arrival_time = i * 10;\n            cars[i].exit_time = -1;\n        }\n        \n        for (int i = 0; i < m; i++) {\n            spaces[i].lower_car = -1;\n            spaces[i].upper_car = -1;\n        }\n        \n        int current_car = 0;\n        int time = 0;\n        \n        while (output_count < n) {\n            // Process exits\n            for (int s = 0; s < m; s++) {\n                if (spaces[s].lower_car != -1) {\n                    int lower_id = spaces[s].lower_car;\n                    if (cars[lower_id].exit_time == time) {\n                        output[output_count++] = cars[lower_id].id;\n                        spaces[s].lower_car = -1;\n                        \n                        if (spaces[s].upper_car != -1) {\n                            int upper_id = spaces[s].upper_car;\n                            output[output_count++] = cars[upper_id].id;\n                            spaces[s].upper_car = -1;\n                        }\n                    }\n                }\n            }\n            \n            // Add arriving cars to waiting list\n            while (current_car < n && cars[current_car].arrival_time == time) {\n                waiting[waiting_count].car_id = current_car;\n                waiting[waiting_count].arrival_time = time;\n                waiting_count++;\n                current_car++;\n            }\n            \n            // Park waiting cars\n            int parked_any = 1;\n            while (waiting_count > 0 && parked_any) {\n                parked_any = 0;\n                int car_id = waiting[0].car_id;\n                int park_time = cars[car_id].parking_time;\n                \n                int best_space = -1;\n                int best_type = -1; // 0: empty, 1: one car\n                int best_diff = 999999;\n                \n                for (int s = 0; s < m; s++) {\n                    if (spaces[s].lower_car == -1) {\n                        if (best_type == -1 || best_type > 0) {\n                            best_space = s;\n                            best_type = 0;\n                        }\n                    } else if (spaces[s].upper_car == -1) {\n                        int remaining = cars[spaces[s].lower_car].exit_time - time;\n                        int diff;\n                        if (remaining >= park_time) {\n                            diff = remaining - park_time;\n                            if (best_type == -1 || best_type > 1 || (best_type == 1 && diff < best_diff)) {\n                                best_space = s;\n                                best_type = 1;\n                                best_diff = diff;\n                            }\n                        } else {\n                            diff = park_time - remaining;\n                            if (best_type == -1 || (best_type == 2 && diff < best_diff)) {\n                                best_space = s;\n                                best_type = 2;\n                                best_diff = diff;\n                            }\n                        }\n                    }\n                }\n                \n                if (best_space != -1) {\n                    if (spaces[best_space].lower_car == -1) {\n                        spaces[best_space].lower_car = car_id;\n                    } else {\n                        spaces[best_space].upper_car = car_id;\n                    }\n                    cars[car_id].exit_time = time + park_time;\n                    \n                    for (int i = 0; i < waiting_count - 1; i++) {\n                        waiting[i] = waiting[i + 1];\n                    }\n                    waiting_count--;\n                    parked_any = 1;\n                } else {\n                    break;\n                }\n            }\n            \n            time++;\n        }\n        \n        for (int i = 0; i < output_count; i++) {\n            if (i > 0) printf(\" \");\n            printf(\"%d\", output[i]);\n        }\n        printf(\"\\n\");\n    }\n    \n    return 0;\n}\n", "perturbed_sampled": ["#include <stdio.h> #include <stdlib.h> #include <string.h> #define MAX_SPACES   struct { int lower_car; int upper_car; } Space; typedef struct { int car_id;  n; while (1)  && n  Space  = 0; int output[MAX_CARS]; int output_count = 0; for (int i = 0; i < n;  10;  (int i = 0; i  = -1; spaces[i].upper_car  = 0; while   m; s++) {  int lower_id = spaces[s].lower_car; if  = cars[lower_id].id; spaces[s].lower_car = -1; if (spaces[s].upper_car != -1) { int  cars[upper_id].id; spaces[s].upper_car = -1; }  current_car; waiting[waiting_count].arrival_time =  Park  1;  parked_any) {  = waiting[0].car_id; int  = -1; int best_type = -1; // 0: empty, 1:  999999;  -1) {  best_type > 0) { best_space = s; best_type  if (spaces[s].upper_car == -1) { int   = 1;  else {  if  == 2 && diff < best_diff)) { best_space = s;  diff; }  != -1) { if  } cars[car_id].exit_time = time + park_time; for  < waiting_count - 1; i++) { waiting[i]   (int i = 0; i < output_count;  output[i]); } printf(\"\\n\"); } return 0; }"], "perturbed_original": ["n,T,C[10][2],c,d,O[10][2],t,s,u,v,h,*p;D(h){p=C[s]+h;*p&&T>=O[s][h]?*p=!printf(\"%d%c\",*p,d<n|--c?32:10):0;}main(m){for(;~scanf(\"%d%d\",&m,&n);)for(memset(C,T=c=d=0,80);d<n|c;T++){for(s=m;s--;C[s][1]||D(0))D(1);for(;T>=d*10&d<n&c<m*2;C[s=~u?u:v][h]=++d,O[s][h]=T+t,c++)for(h=scanf(\"%d\",&t),u=v=-1,s=m;h&&s--;)*C[s]?C[s][1]||(*O[s]<T+t?!~v||*O[s]>*O[v]?v=s:0:!~u||*O[s]<*O[u]?u=s:0):(u=s,h=0);}}"], "original_ll": -3.212848424911499, "sampled_ll": -0.578671932220459, "all_perturbed_sampled_ll": [-2.4960930347442627], "all_perturbed_original_ll": [-3.212848424911499], "perturbed_sampled_ll": -2.4960930347442627, "perturbed_original_ll": -3.212848424911499, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import java.util.Arrays;\nimport java.util.LinkedList;\nimport java.util.Scanner;\n\npublic class Main {\n\t\n\tpublic static final int MAX_SIZE = 10;\n\tpublic static final int MAX_CAR = 100;\n\t\n\tpublic static final int M_INF = Integer.MIN_VALUE / 2 + 1;\n\t\n\tpublic static boolean try_fst(int[][] spaces, int[][] numbers, final int m, final int remain_time, final int car_number){\n\t\tfor(int i = 0; i < m; i++){\n\t\t\tif(spaces[i][0] <= M_INF){\n\t\t\t\tspaces[i][0] = remain_time;\n\t\t\t\tnumbers[i][0] = car_number;\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn false;\n\t}\n\t\n\tpublic static void add_time(int[][] spaces, final int m, final int time){\n\t\tfor(int i = 0; i < m; i++){\n\t\t\tif(spaces[i][0] <= M_INF){\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t\n\t\t\tspaces[i][0] -= time;\n\t\t\tspaces[i][1] -= time;\n\t\t}\n\t}\n\t\n\tpublic static boolean is_finish(int[][] spaces, final int m){\n\t\tfor(int i = 0; i < m; i++){\n\t\t\tif(spaces[i][0] > M_INF){\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn true;\n\t}\n\t\n\tpublic static boolean can_upper(int[][] spaces, int[][] numbers, final int m, final int remain_time, final int car_number){\n\t\tfor(int i = 0; i < m; i++){\n\t\t\tif(spaces[i][0] >= remain_time && spaces[i][1] <= M_INF){\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn false;\n\t}\n\t\n\tpublic static boolean try_snd(int[][] spaces, int[][] numbers, final int m, final int remain_time, final int car_number){\n\t\tfinal boolean can_upper = can_upper(spaces, numbers, m, remain_time, car_number);\n\t\t\n\t\tint pos = -1;\n\t\tint attr = can_upper ? Integer.MAX_VALUE : Integer.MIN_VALUE;\n\t\tfor(int i = 0; i < m; i++){\n\t\t\t//System.out.println(can_upper + \" \" + (spaces[i][0]<= M_INF) + \" \" + (attr < spaces[i][0]));\n\t\t\t\n\t\t\tif(can_upper && spaces[i][1] <= M_INF && spaces[i][0] >= remain_time && attr > spaces[i][0]){\n\t\t\t\tattr = spaces[i][0];\n\t\t\t\tpos = i;\n\t\t\t}else if(!can_upper && spaces[i][1] <= M_INF && attr < spaces[i][0]){\n\t\t\t\tattr = spaces[i][0];\n\t\t\t\tpos = i;\n\t\t\t}\n\t\t}\n\t\t\n\t\t//System.out.println(attr  + \" \" + pos + \" \" + can_upper);\n\t\t\n\t\tif(pos < 0){\n\t\t\treturn false;\n\t\t}\n\t\t\n\t\tspaces[pos][1] = Math.max(spaces[pos][0], remain_time);\n\t\tnumbers[pos][1] = numbers[pos][0];\n\t\tspaces[pos][0] = remain_time;\n\t\tnumbers[pos][0] = car_number;\n\t\t\n\t\treturn true;\n\t}\n\t\n\tpublic static void print(int[][] spaces, int[][] numbers, final int m){\n\t\tSystem.out.println(\"-----------------------------------\");\n\t\tfor(int i = 0; i < m; i++){\n\t\t\tSystem.out.print(spaces[i][0] + \" \");\n\t\t}\n\t\tSystem.out.println();\n\t\tfor(int i = 0; i < m; i++){\n\t\t\tSystem.out.print(spaces[i][1] + \" \");\n\t\t}\n\t\tSystem.out.println();\n\t\tfor(int i = 0; i < m; i++){\n\t\t\tSystem.out.print(numbers[i][0] + \" \");\n\t\t}\n\t\tSystem.out.println();\n\t\tfor(int i = 0; i < m; i++){\n\t\t\tSystem.out.print(numbers[i][1] + \" \");\n\t\t}\n\t\tSystem.out.println();\n\t\tSystem.out.println(\"-----------------------------------\");\n\t\t\n\t}\n\t\t\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\t\n\t\tint[][] spaces = new int[MAX_SIZE][2];\n\t\tint[][] numbers = new int[MAX_SIZE][2];\n\t\t\n\t\twhile(true){\n\t\t\tfinal int m = sc.nextInt();\n\t\t\tfinal int n = sc.nextInt();\n\t\t\t\n\t\t\tif(m == 0 && n == 0){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\n\t\t\tfor(int i = 0; i < m; i++){\n\t\t\t\tspaces[i][0] = spaces[i][1] = M_INF;\n\t\t\t\tnumbers[i][0] = numbers[i][1] = -1;\n\t\t\t}\n\t\t\t\n\t\t\tLinkedList<Integer> remain_queue = new LinkedList<Integer>();\n\t\t\tLinkedList<Integer> number_queue = new LinkedList<Integer>();\n\t\t\t//int time = 0;\n\t\t\t\n\t\t\tLinkedList<Integer> out_numbers = new LinkedList<Integer>();\n\t\t\tfor(int car = 0; ; car++){\n\t\t\t\t//\n\t\t\t\tif(car < n){\n\t\t\t\t\tremain_queue.add(sc.nextInt());\n\t\t\t\t\tnumber_queue.add(car + 1);\n\t\t\t\t}else if(remain_queue.isEmpty() && is_finish(spaces, m)){\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tadd_time(spaces, m, 10);\n\t\t\t\t//print(spaces, numbers, m);\n\t\t\t\t\n\t\t\t\twhile(true){\n\t\t\t\t\tint min = 1;\n\t\t\t\t\tint min_pos = -1;\n\t\t\t\t\tint min_car = -1;\n\t\t\t\t\t\n\t\t\t\t\tfor(int i = 0; i < m; i++){\n\t\t\t\t\t\tif(spaces[i][0] <= M_INF){\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}else if(spaces[i][0] < min){\n\t\t\t\t\t\t\tmin = spaces[i][0];\n\t\t\t\t\t\t\tmin_car = numbers[i][0];\n\t\t\t\t\t\t\tmin_pos = i;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tif(min_car == -1){\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tspaces[min_pos][0] = spaces[min_pos][1];\n\t\t\t\t\tnumbers[min_pos][0] = numbers[min_pos][1];\n\t\t\t\t\tspaces[min_pos][1] = M_INF;\n\t\t\t\t\tnumbers[min_pos][1] = M_INF;\n\t\t\t\t\tout_numbers.add(min_car);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\twhile(!remain_queue.isEmpty()){\n\t\t\t\t\tfinal int remain_time = remain_queue.poll();\n\t\t\t\t\tfinal int car_number  = number_queue.poll();\n\t\t\t\t\t\n\t\t\t\t\tif(try_fst(spaces, numbers, m, remain_time, car_number)){\n\t\t\t\t\t\t//ok\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}else if(try_snd(spaces, numbers, m, remain_time, car_number)){\n\t\t\t\t\t\t//ok\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}else{\n\t\t\t\t\t\t//System.out.println(\"fail \" + car_number);\n\t\t\t\t\t\tremain_queue.addFirst(remain_time);\n\t\t\t\t\t\tnumber_queue.addFirst(car_number);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tboolean first = true;\n\t\t\tfor(int i : out_numbers){\n\t\t\t\tif(first){\n\t\t\t\t\tfirst = false;\n\t\t\t\t\tSystem.out.print(i);\n\t\t\t\t}else{\n\t\t\t\t\tSystem.out.print(\" \" + i);\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println();\n\t\t\t\n\t\t\t//System.out.println(out_numbers);\n\t\t}\n\n\t}\n\n}", "sampled": "import java.util.*;\n\npublic class Main {\n    static class Car {\n        int id;\n        int arrivalTime;\n        int parkingDuration;\n        int departureTime;\n        \n        Car(int id, int arrivalTime, int parkingDuration) {\n            this.id = id;\n            this.arrivalTime = arrivalTime;\n            this.parkingDuration = parkingDuration;\n            this.departureTime = arrivalTime + parkingDuration;\n        }\n    }\n    \n    static class Space {\n        Car lower;\n        Car upper;\n        \n        boolean isEmpty() {\n            return lower == null && upper == null;\n        }\n        \n        boolean hasSpace() {\n            return lower == null || upper == null;\n        }\n        \n        int getRemainingTime(int currentTime) {\n            if (lower != null) {\n                return Math.max(0, lower.departureTime - currentTime);\n            }\n            return 0;\n        }\n    }\n    \n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        \n        while (true) {\n            int m = sc.nextInt();\n            int n = sc.nextInt();\n            \n            if (m == 0 && n == 0) break;\n            \n            List<Car> cars = new ArrayList<>();\n            for (int i = 0; i < n; i++) {\n                int duration = sc.nextInt();\n                cars.add(new Car(i + 1, i * 10, duration));\n            }\n            \n            Space[] spaces = new Space[m];\n            for (int i = 0; i < m; i++) {\n                spaces[i] = new Space();\n            }\n            \n            Queue<Car> waitingQueue = new LinkedList<>();\n            List<Integer> exitOrder = new ArrayList<>();\n            int carIndex = 0;\n            int currentTime = 0;\n            \n            while (exitOrder.size() < n) {\n                // Process departures\n                List<Car> departing = new ArrayList<>();\n                for (int i = 0; i < m; i++) {\n                    Space space = spaces[i];\n                    if (space.lower != null && space.lower.departureTime <= currentTime) {\n                        departing.add(space.lower);\n                        if (space.upper != null && space.upper.departureTime <= currentTime) {\n                            departing.add(space.upper);\n                        }\n                    }\n                }\n                \n                Collections.sort(departing, (a, b) -> {\n                    for (int i = 0; i < m; i++) {\n                        if (spaces[i].lower == a) return -1;\n                        if (spaces[i].lower == b) return 1;\n                    }\n                    return 0;\n                });\n                \n                for (Car car : departing) {\n                    exitOrder.add(car.id);\n                    for (int i = 0; i < m; i++) {\n                        if (spaces[i].lower == car) {\n                            spaces[i].lower = spaces[i].upper;\n                            spaces[i].upper = null;\n                            break;\n                        }\n                    }\n                }\n                \n                // Add arriving cars to queue\n                while (carIndex < n && cars.get(carIndex).arrivalTime <= currentTime) {\n                    waitingQueue.add(cars.get(carIndex));\n                    carIndex++;\n                }\n                \n                // Process parking\n                while (!waitingQueue.isEmpty()) {\n                    Car car = waitingQueue.peek();\n                    int bestSpace = findBestSpace(spaces, car, currentTime);\n                    \n                    if (bestSpace == -1) break;\n                    \n                    waitingQueue.poll();\n                    if (spaces[bestSpace].isEmpty()) {\n                        spaces[bestSpace].lower = car;\n                    } else {\n                        spaces[bestSpace].upper = car;\n                    }\n                }\n                \n                currentTime++;\n            }\n            \n            for (int i = 0; i < exitOrder.size(); i++) {\n                if (i > 0) System.out.print(\" \");\n                System.out.print(exitOrder.get(i));\n            }\n            System.out.println();\n        }\n    }\n    \n    static int findBestSpace(Space[] spaces, Car car, int currentTime) {\n        int bestSpace = -1;\n        int bestDiff = Integer.MAX_VALUE;\n        boolean foundEmpty = false;\n        \n        // First check for empty spaces\n        for (int i = 0; i < spaces.length; i++) {\n            if (spaces[i].isEmpty()) {\n                return i;\n            }\n        }\n        \n        // Check for spaces with one car\n        for (int i = 0; i < spaces.length; i++) {\n            if (spaces[i].hasSpace() && !spaces[i].isEmpty()) {\n                int remaining = spaces[i].getRemainingTime(currentTime);\n                int diff = Math.abs(remaining - car.parkingDuration);\n                \n                if (remaining >= car.parkingDuration) {\n                    if (bestSpace == -1 || diff < bestDiff || \n                        (diff == bestDiff && remaining >= car.parkingDuration)) {\n                        bestSpace = i;\n                        bestDiff = diff;\n                    }\n                } else {\n                    if (bestSpace == -1 || spaces[bestSpace].getRemainingTime(currentTime) >= car.parkingDuration || diff < bestDiff) {\n                        bestSpace = i;\n                        bestDiff = diff;\n                    }\n                }\n            }\n        }\n        \n        return bestSpace;\n    }\n}\n", "perturbed_sampled": ["import java.util.*; public class Main  int id; int arrivalTime; int parkingDuration; int departureTime;  id;  + parkingDuration; }  Car lower; Car upper; boolean  null &&  hasSpace()  (true) { int m = sc.nextInt();  (m  sc.nextInt(); cars.add(new Car(i + 1, i * 10, duration)); } Space[]  (int i  i++) { spaces[i] = new  currentTime = 0; while (exitOrder.size() < n) { // Process   = spaces[i]; if (space.lower  currentTime) { departing.add(space.lower); if (space.upper != null && space.upper.departureTime <=   { for (int i = 0; i < m; i++) {  -1; if (spaces[i].lower  return  : departing)  = 0; i < m;   spaces[i].upper = null; break; } } } //  while (carIndex < n &&  int bestSpace = findBestSpace(spaces, car, currentTime); if (bestSpace == -1) break; waitingQueue.poll(); if (spaces[bestSpace].isEmpty()) { spaces[bestSpace].lower = car; } else  }  (i > 0) System.out.print(\" \"); System.out.print(exitOrder.get(i));   bestSpace  false; // First check for empty spaces for (int  spaces.length; i++)  i; } } //   0; i  (spaces[i].hasSpace() && !spaces[i].isEmpty()) { int remaining = spaces[i].getRemainingTime(currentTime); int diff = Math.abs(remaining - car.parkingDuration); if (remaining >= car.parkingDuration) { if (bestSpace  bestDiff && remaining >=  } else { if (bestSpace ==   bestSpace  }  } }"], "perturbed_original": ["import   static  MAX_CAR = 100; public static final int M_INF = Integer.MIN_VALUE /  numbers,  remain_time, final  spaces[i][0] = remain_time; numbers[i][0] = car_number; return  add_time(int[][] spaces, final int m, final int time){ for(int  m; i++){ if(spaces[i][0] <= M_INF){ continue;  public static boolean is_finish(int[][] spaces, final int  if(spaces[i][0] > M_INF){ return  int remain_time,  = 0; i   static boolean try_snd(int[][] spaces, int[][] numbers, final int  pos =  for(int i =    + (attr < spaces[i][0])); if(can_upper &&  > spaces[i][0]){ attr = spaces[i][0]; pos = i; }else  = i;  \" + pos + \" \" + can_upper); if(pos < 0){ return false;  numbers[pos][1] =  = car_number; return  for(int i = 0;  0; i < m; i++){ System.out.print(spaces[i][1] + \" \"); }  System.out.print(numbers[i][0] + \" \");  0; i < m;   static void main(String[] args) {  int[][] spaces = new int[MAX_SIZE][2];  while(true){ final int m = sc.nextInt(); final int n = sc.nextInt(); if(m ==  m; i++){ spaces[i][0] = spaces[i][1] = M_INF; numbers[i][0] = numbers[i][1] =   new LinkedList<Integer>(); //int time = 0; LinkedList<Integer> out_numbers = new LinkedList<Integer>(); for(int car =  <  m, 10); //print(spaces, numbers, m); while(true){ int min = 1; int min_pos = -1;    numbers[min_pos][0]  numbers[min_pos][1] = M_INF;  remain_time = remain_queue.poll(); final  numbers, m, remain_time, car_number)){ //ok continue;  car_number)){ //ok continue; }else{ //System.out.println(\"fail  break;   false; System.out.print(i);  } } System.out.println(); //System.out.println(out_numbers); } } }"], "original_ll": -0.6510891914367676, "sampled_ll": -0.5915046334266663, "all_perturbed_sampled_ll": [-2.7390341758728027], "all_perturbed_original_ll": [-2.549537420272827], "perturbed_sampled_ll": -2.7390341758728027, "perturbed_original_ll": -2.549537420272827, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "from collections import deque\n\ndef out(time, parking):\n  x = len(parking)\n  outs = []\n  for i in range(x):\n    for j in range(2):\n      if parking[i][j] != None:\n        parking[i][j][0] -= time\n  \n  for i in range(x):\n    c1 = parking[i][0]\n    c2 = parking[i][1]\n    if c1 != None and c2 != None:\n      if c1[0] <= 0 and c2[0] <= 0:\n        outs.append([c2[1], c1[1]])\n        parking[i][0] = None\n        parking[i][1] = None\n      elif c2[0] <= 0:\n        outs.append([c2[1]])\n        parking[i][1] = None\n    elif c1 != None:\n      if c1[0] <= 0:\n        outs.append([c1[1]])\n        parking[i][0] = None\n    elif c2 != None:\n      if c2[0] <= 0:\n        outs.append([c2[1]])\n        parking[i][1] = None\n  outs.sort()\n  lst = []\n  for l in outs:\n    lst += l\n  return lst\n\ndef into(num, time, parking):\n  x = len(parking)\n  times = []\n  for i in range(x):\n    if parking[i] == [None, None]:\n      parking[i][0] = [time, num]\n      return\n    if parking[i][0] == None:\n      times.append((parking[i][1][0], i))\n    elif parking[i][1] == None:\n      times.append((parking[i][0][0], i))\n  times.sort()\n  \n  for t, ind in times:\n    if t >= time:\n      if parking[ind][0] == None:\n        parking[ind][0] = [time, num]\n      else:\n        parking[ind][1] = [time, num]\n      return\n  else:\n    max_t = t\n\n  for t, ind in times:\n    if t == max_t:\n      if parking[ind][0] == None:\n        parking[ind][0] = [time, num]\n      else:\n        parking[ind][1] = [time, num]\n      return\n \nwhile True:\n  m, n = map(int, input().split())\n  if m == 0:\n    break\n  \n  parking = [[None] * 2 for _ in range(m)]\n  wait = deque()\n  space = m * 2\n  ans = []\n  \n  for t in range(120 * n):\n    o = out(1, parking)\n    if o:\n      space += len(o)\n      ans += o\n\n    if t % 10 == 0 and t <= 10 * (n - 1):\n      time = int(input())\n      wait.append((t // 10 + 1, time))\n\n    for i in range(min(space, len(wait))):\n      num, time = wait.popleft()\n      into(num, time, parking)\n      space -= 1\n  print(*ans)\n", "sampled": "import heapq\nfrom collections import deque\n\ndef solve(m, n, parking_times):\n    # spaces[i] = [lower_car, upper_car] where car = (car_id, end_time)\n    spaces = [[None, None] for _ in range(m)]\n    waiting_queue = deque()\n    events = []  # (time, event_type, data)\n    exit_order = []\n    \n    current_time = 0\n    \n    for car_id in range(1, n + 1):\n        arrival_time = (car_id - 1) * 10\n        parking_time = parking_times[car_id - 1]\n        heapq.heappush(events, (arrival_time, 0, car_id, parking_time))  # 0 = arrival\n    \n    while events or waiting_queue:\n        if not events:\n            break\n            \n        current_time, event_type, *data = heapq.heappop(events)\n        \n        if event_type == 0:  # arrival\n            car_id, parking_time = data\n            end_time = current_time + parking_time\n            \n            # Process all exits at current time first\n            exits_now = []\n            temp_events = []\n            while events and events[0][0] == current_time and events[0][1] == 1:\n                temp_events.append(heapq.heappop(events))\n            \n            for ev in temp_events:\n                exits_now.append(ev)\n            \n            # Process exits\n            for exit_event in sorted(exits_now, key=lambda x: x[2]):\n                space_id = x[2]\n                process_exit(spaces, space_id, exit_order)\n            \n            # Put events back\n            for ev in temp_events:\n                if ev not in exits_now:\n                    heapq.heappush(events, ev)\n            \n            # Try to park cars from waiting queue\n            while waiting_queue:\n                w_car_id, w_parking_time, w_arrival = waiting_queue[0]\n                w_end_time = w_arrival + w_parking_time\n                space_idx = find_space(spaces, w_parking_time, current_time)\n                if space_idx == -1:\n                    break\n                waiting_queue.popleft()\n                park_car(spaces, space_idx, w_car_id, w_end_time, current_time, events)\n            \n            # Try to park current car\n            space_idx = find_space(spaces, parking_time, current_time)\n            if space_idx == -1:\n                waiting_queue.append((car_id, parking_time, current_time))\n            else:\n                park_car(spaces, space_idx, car_id, end_time, current_time, events)\n                \n        elif event_type == 1:  # exit\n            space_id = data[0]\n            process_exit(spaces, space_id, exit_order)\n            \n            # Try to park cars from waiting queue\n            while waiting_queue:\n                w_car_id, w_parking_time, w_arrival = waiting_queue[0]\n                w_end_time = current_time + w_parking_time\n                space_idx = find_space(spaces, w_parking_time, current_time)\n                if space_idx == -1:\n                    break\n                waiting_queue.popleft()\n                park_car(spaces, space_idx, w_car_id, w_end_time, current_time, events)\n    \n    return exit_order\n\ndef find_space(spaces, parking_time, current_time):\n    empty_spaces = []\n    one_car_spaces = []\n    \n    for i, space in enumerate(spaces):\n        if space[0] is None:\n            empty_spaces.append(i)\n        elif space[1] is None:\n            remaining_time = space[0][1] - current_time\n            one_car_spaces.append((i, remaining_time))\n    \n    if empty_spaces:\n        return min(empty_spaces)\n    \n    if not one_car_spaces:\n        return -1\n    \n    # Find best space\n    ge_spaces = [(i, rt) for i, rt in one_car_spaces if rt >= parking_time]\n    lt_spaces = [(i, rt) for i, rt in one_car_spaces if rt < parking_time]\n    \n    if ge_spaces:\n        best = min(ge_spaces, key=lambda x: (x[1] - parking_time, x[0]))\n        return best[0]\n    else:\n        best = min(lt_spaces, key=lambda x: (parking_time - x[1], x[0]))\n        return best[0]\n\ndef park_car(spaces, space_idx, car_id, end_time, current_time, events):\n    if spaces[space_idx][0] is None:\n        spaces[space_idx][0] = (car_id, end_time)\n        heapq.heappush(events, (end_time, 1, space_idx))\n    else:\n        spaces[space_idx][1] = (car_id, end_time)\n\ndef process_exit(spaces, space_id, exit_order):\n    if spaces[space_id][1] is not None:\n        exit_order.append(spaces[space_id][0][0])\n        exit_order.append(spaces[space_id][1][0])\n        spaces[space_id][0] = None\n        spaces[space_id][1] = None\n    elif spaces[space_id][0] is not None:\n        exit_order.append(spaces[space_id][0][0])\n        spaces[space_id][0] = None\n\nwhile True:\n    line = input().split()\n    m, n = int(line[0]), int(line[1])\n    if m == 0 and n == 0:\n        break\n    \n    parking_times = []\n    for _ in range(n):\n        parking_times.append(int(input()))\n    \n    result = solve(m, n, parking_times)\n    print(' '.join(map(str, result)))\n", "perturbed_sampled": ["import heapq from collections import  upper_car] where car = (car_id, end_time) spaces = [[None, None] for  # (time, event_type,  = 0 for car_id in range(1,   = arrival while events or waiting_queue: if not events: break current_time, event_type, *data =  #  end_time  current  1: temp_events.append(heapq.heappop(events)) for ev in temp_events: exits_now.append(ev) #  sorted(exits_now, key=lambda   in temp_events: if  park cars from waiting queue  = waiting_queue[0] w_end_time =  find_space(spaces, w_parking_time,  break waiting_queue.popleft() park_car(spaces,   car  if  current_time))  current_time,  # exit space_id   = waiting_queue[0] w_end_time  =  current_time, events) return exit_order def find_space(spaces, parking_time, current_time): empty_spaces = [] one_car_spaces = []  empty_spaces.append(i) elif space[1] is None: remaining_time = space[0][1] -  Find best space   rt >= parking_time] lt_spaces = [(i, rt) for i, rt in one_car_spaces if    min(lt_spaces, key=lambda x: (parking_time - x[1], x[0])) return best[0]  current_time,  spaces[space_idx][0] = (car_id, end_time) heapq.heappush(events, (end_time, 1, space_idx)) else: spaces[space_idx][1] =  = None elif   line = input().split() m, n = int(line[0]), int(line[1]) if m == 0 and n == 0: break parking_times =  result)))"], "perturbed_original": ["from collections import  [] for i in range(x): for j in range(2): if parking[i][j] != None: parking[i][j][0]  range(x): c1 = parking[i][0] c2 = parking[i][1] if c1 != None and c2 != None: if   None elif c2[0] <= 0: outs.append([c2[1]]) parking[i][1] = None elif c1  None elif c2  None outs.sort() lst = [] for  l    for t, ind in times: if t  num]  return else: max_t = t for t, ind  max_t:  = [time, num] else:  m == 0: break parking =  deque() space = m  *  if o:  10 == 0 and t <=  time = int(input()) wait.append((t // 10 +  =  -= 1 print(*ans)"], "original_ll": -0.8700494170188904, "sampled_ll": -0.7929011583328247, "all_perturbed_sampled_ll": [-2.973994016647339], "all_perturbed_original_ll": [-3.2002477645874023], "perturbed_sampled_ll": -2.973994016647339, "perturbed_original_ll": -3.2002477645874023, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "// Aizu Vol-1 0193: Convenience Store\n// 2017.8.25 bal4u@uu\n\n#include <stdio.h>\n#include <string.h>\n\n#define abs(a) ((a)>=0?(a):(-(a)))\n//#define min(a,b) ((a)<=(b)?(a):(b))\n\ntypedef struct { int r, c, f; } T;\nT shop[25]; int n, S, N;\nint R, C;\n\nint hexDistance(int r1, int c1, int r2, int c2)\n{\n\tint dr, dc, c;\n\tdr = abs(r2 - r1), dc = abs(c2 - c1);\n\tif (r2 == r1) return dc;\n\tif (c2 == c1) return dr;\n\tif (r2 < r1) c = r2, r2 = r1, r1 = c, c = c2, c2 = c1, c1 = c;\n\tif (c2 >= c1) {\n\t\tc = c1 + (dr+1-(r1&1))/2;\n\t\tif (c2 >= c) dr += abs(c-c2);\n\t} else {\n\t\tc = c1 - (dr+(r1&1))/2;\n\t\tif (c2 <= c) dr += abs(c-c2);\n\t}\n\treturn dr;\n}\n\nint belong(int r, int c)\n{\n\tint i, d, k, min;\n\tfor (min = -1, d = -2, k = 0, i = 1; i <= n; i++) {\n\t\td = hexDistance(shop[i].r, shop[i].c, r, c);\n\t\tif (min < 0 || d < min) min = d, k = i;\n\t\telse if (d == min) k = 0;\n\t}\n\treturn k;\n}\n\nint main()\n{\n\tint i, r, c;\n\tint ans;\n\n\twhile (scanf(\"%d%d\", &C, &R) && C) {\n\t\tscanf(\"%d\", &S);\n\t\tfor (n = 1, i = 0; i < S; i++) {\n\t\t\tscanf(\"%d%d\", &shop[n].c, &shop[n].r), shop[n++].f = 0;\n\t\t}\n\t\tscanf(\"%d\", &N);\n\t\tfor (i = 0; i < N; i++) {\n\t\t\tscanf(\"%d%d\", &shop[n].c, &shop[n].r), shop[n++].f = 0;\n\t\t}\n\t\tn--;\n\t\tfor (r = 1; r <= R; r++) for (c = 1; c <= C; c++)\n\t\t\tif ((i = belong(r, c)) > 0) shop[i].f++;\n\t\tfor (ans = -1, i = S+1; i <= n; i++) if (shop[i].f > ans) ans = shop[i].f;\n\t\tprintf(\"%d\\n\", ans);\n\t}\n\treturn 0;\n}", "sampled": "#include <stdio.h>\n#include <stdlib.h>\n\ntypedef struct {\n    int x, y;\n} Point;\n\nint dx_odd[6] = {0, 1, 1, 0, -1, -1};\nint dy_odd[6] = {-1, -1, 0, 1, 0, -1};\nint dx_even[6] = {-1, 0, 1, 1, 1, 0};\nint dy_even[6] = {-1, -1, 0, 1, 0, -1};\n\ntypedef struct {\n    int x, y, dist;\n} Node;\n\nint dist[101][101];\nint queue[20000][2];\nint qfront, qrear;\n\nvoid bfs(int sx, int sy, int m, int n) {\n    int visited[101][101] = {0};\n    qfront = qrear = 0;\n    queue[qrear][0] = sx;\n    queue[qrear][1] = sy;\n    qrear++;\n    visited[sx][sy] = 1;\n    dist[sx][sy] = 0;\n    \n    while (qfront < qrear) {\n        int cx = queue[qfront][0];\n        int cy = queue[qfront][1];\n        qfront++;\n        \n        int *dx = (cy % 2 == 1) ? dx_odd : dx_even;\n        int *dy = (cy % 2 == 1) ? dy_odd : dy_even;\n        \n        for (int i = 0; i < 6; i++) {\n            int nx = cx + dx[i];\n            int ny = cy + dy[i];\n            \n            if (nx >= 1 && nx <= m && ny >= 1 && ny <= n && !visited[nx][ny]) {\n                visited[nx][ny] = 1;\n                dist[nx][ny] = dist[cx][cy] + 1;\n                queue[qrear][0] = nx;\n                queue[qrear][1] = ny;\n                qrear++;\n            }\n        }\n    }\n}\n\nint main() {\n    int m, n;\n    \n    while (scanf(\"%d %d\", &m, &n) == 2) {\n        if (m == 0 && n == 0) break;\n        \n        int s;\n        scanf(\"%d\", &s);\n        Point stores[11];\n        for (int i = 0; i < s; i++) {\n            scanf(\"%d %d\", &stores[i].x, &stores[i].y);\n        }\n        \n        int t;\n        scanf(\"%d\", &t);\n        Point candidates[11];\n        for (int i = 0; i < t; i++) {\n            scanf(\"%d %d\", &candidates[i].x, &candidates[i].y);\n        }\n        \n        int max_coverage = 0;\n        \n        for (int cand = 0; cand < t; cand++) {\n            int coverage = 0;\n            \n            for (int x = 1; x <= m; x++) {\n                for (int y = 1; y <= n; y++) {\n                    int min_dist_cand = 1000000;\n                    int min_dist_store = 1000000;\n                    int count_min_store = 0;\n                    \n                    bfs(candidates[cand].x, candidates[cand].y, m, n);\n                    min_dist_cand = dist[x][y];\n                    \n                    for (int i = 0; i < s; i++) {\n                        bfs(stores[i].x, stores[i].y, m, n);\n                        int d = dist[x][y];\n                        if (d < min_dist_store) {\n                            min_dist_store = d;\n                            count_min_store = 1;\n                        } else if (d == min_dist_store) {\n                            count_min_store++;\n                        }\n                    }\n                    \n                    if (min_dist_cand < min_dist_store) {\n                        coverage++;\n                    } else if (min_dist_cand == min_dist_store && count_min_store == 0) {\n                        coverage++;\n                    }\n                }\n            }\n            \n            if (coverage > max_coverage) {\n                max_coverage = coverage;\n            }\n        }\n        \n        printf(\"%d\\n\", max_coverage);\n    }\n    \n    return 0;\n}\n", "perturbed_sampled": ["#include <stdio.h> #include <stdlib.h> typedef struct { int x, y; }  -1};  0,  = {-1, 0,  0,  {  Node;  qfront, qrear;  int m, int n)   queue[qrear][0] = sx; queue[qrear][1] = sy; qrear++;  qrear)  int cy = queue[qfront][1]; qfront++;  2 ==  int *dy = (cy % 2 == 1) ?  <  = cx +  { visited[nx][ny]  + 1; queue[qrear][0] = nx; queue[qrear][1] = ny; qrear++; } } } }   &n) == 2) { if (m == 0 && n == 0)  < s;  &stores[i].y); } int t; scanf(\"%d\", &t); Point candidates[11]; for (int i = 0;   0; cand  (int x =  { for (int y  y++) {    for (int i =   if (d < min_dist_store) { min_dist_store  } else  count_min_store++; }  { coverage++; } else if (min_dist_cand == min_dist_store && count_min_store  } } if (coverage > max_coverage) { max_coverage  }"], "perturbed_original": ["// Aizu  2017.8.25 bal4u@uu #include <stdio.h> #include <string.h>  ((a)<=(b)?(a):(b))  c, f; } T; T shop[25]; int n, S, N; int R, C; int hexDistance(int  int c2) { int  = abs(c2 -   c1) return dr;   c1,  >= c1)  (dr+1-(r1&1))/2; if (c2 >=   abs(c-c2); } return dr; } int belong(int r, int c) { int i, d,  -1, d = -2, k = 0, i = 1; i  =  (min < 0  = d, k = i;    int i, r, c;  scanf(\"%d\", &S);  = 0;   1;   C; c++) if  0) shop[i].f++; for (ans  i <= n; i++) if (shop[i].f >  ans); } return 0; }"], "original_ll": -1.0939298868179321, "sampled_ll": -0.48738744854927063, "all_perturbed_sampled_ll": [-2.6925430297851562], "all_perturbed_original_ll": [-3.2437398433685303], "perturbed_sampled_ll": -2.6925430297851562, "perturbed_original_ll": -3.2437398433685303, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import java.util.*;\n\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tScanner s=new Scanner(System.in);\n\t\tfor(int m,n,x,a[][];(m=s.nextInt())>0;){\n\t\t\tn=s.nextInt();\n\t\t\tx=s.nextInt();\n\t\t\ta=new int[n][m];\n\t\t\tDeque<int[]>q=new ArrayDeque<int[]>();\n\t\t\tfor(int i=0;i<x;++i){\n\t\t\t\tint v=s.nextInt()-1,u=s.nextInt()-1;\n\t\t\t\ta[u][v]=1;\n\t\t\t\tq.add(new int[]{u,v,1});\n\t\t\t}\n\t\t\tint[][]dm={{-1,-1,-1,0,0,1},{-1,0,0,1,1,1}};\n\t\t\tint[][]dn={{-1,0,1,-1,1,0},{0,-1,1,-1,0,1}};\n\t\t\twhile(!q.isEmpty()){\n\t\t\t\tint[]t=q.poll();\n\t\t\t\tfor(int i=0;i<6;++i){\n\t\t\t\t\tint u=t[0]+dn[t[0]%2][i],v=t[1]+dm[t[0]%2][i];\n\t\t\t\t\tif(0<=u&&u<n&&0<=v&&v<m&&a[u][v]<1){\n\t\t\t\t\t\tq.add(new int[]{u,v,a[u][v]=t[2]+1});\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tint r=0;\n\t\t\tfor(x=s.nextInt();x-->0;){\n\t\t\t\tint v=s.nextInt()-1,u=s.nextInt()-1;\n\t\t\t\tif(a[u][v]>1){\n\t\t\t\t\tint[][] tmp = new int[n][];\n\t\t\t\t\tfor(int i=0;i<n;++i)\n\t\t\t\t\t\ttmp[i]=Arrays.copyOf(a[i],m);\n\t\t\t\tq.add(new int[]{u,v,1});\n\t\t\t\tint c=1;\n\t\t\t\twhile(!q.isEmpty()){\n\t\t\t\t\tint[]t=q.poll();\n\t\t\t\t\tfor(int i=0;i<6;++i){\n\t\t\t\t\t\tint u1=t[0]+dn[t[0]%2][i],v1=t[1]+dm[t[0]%2][i];\n\t\t\t\t\t\tif(0<=u1&&u1<n&&0<=v1&&v1<m&&tmp[u1][v1]>t[2]+1){\n\t\t\t\t\t\t\t++c;\n\t\t\t\t\t\t\tq.add(new int[]{u1,v1,tmp[u1][v1]=t[2]+1});\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tr=r>c?r:c;\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(r);\n\t\t}\n\t}\n}", "sampled": "import java.util.*;\n\npublic class Main {\n    static int m, n;\n    static int[][] dirs = {{1, 0}, {-1, 0}, {0, 1}, {0, -1}, {1, -1}, {-1, 1}};\n    \n    static int[][] getNeighbors(int x, int y) {\n        int[][] neighbors = new int[6][2];\n        if (y % 2 == 1) {\n            neighbors[0] = new int[]{x + 1, y};\n            neighbors[1] = new int[]{x - 1, y};\n            neighbors[2] = new int[]{x, y + 1};\n            neighbors[3] = new int[]{x, y - 1};\n            neighbors[4] = new int[]{x - 1, y + 1};\n            neighbors[5] = new int[]{x - 1, y - 1};\n        } else {\n            neighbors[0] = new int[]{x + 1, y};\n            neighbors[1] = new int[]{x - 1, y};\n            neighbors[2] = new int[]{x + 1, y + 1};\n            neighbors[3] = new int[]{x + 1, y - 1};\n            neighbors[4] = new int[]{x, y + 1};\n            neighbors[5] = new int[]{x, y - 1};\n        }\n        return neighbors;\n    }\n    \n    static int[][] computeDistances(int sx, int sy) {\n        int[][] dist = new int[m + 1][n + 1];\n        for (int i = 0; i <= m; i++) {\n            Arrays.fill(dist[i], -1);\n        }\n        \n        Queue<int[]> queue = new LinkedList<>();\n        queue.offer(new int[]{sx, sy, 0});\n        dist[sx][sy] = 0;\n        \n        while (!queue.isEmpty()) {\n            int[] curr = queue.poll();\n            int x = curr[0];\n            int y = curr[1];\n            int d = curr[2];\n            \n            int[][] neighbors = getNeighbors(x, y);\n            for (int[] neighbor : neighbors) {\n                int nx = neighbor[0];\n                int ny = neighbor[1];\n                if (nx >= 1 && nx <= m && ny >= 1 && ny <= n && dist[nx][ny] == -1) {\n                    dist[nx][ny] = d + 1;\n                    queue.offer(new int[]{nx, ny, d + 1});\n                }\n            }\n        }\n        \n        return dist;\n    }\n    \n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        \n        while (true) {\n            m = sc.nextInt();\n            n = sc.nextInt();\n            if (m == 0 && n == 0) break;\n            \n            int s = sc.nextInt();\n            int[][] existing = new int[s][2];\n            for (int i = 0; i < s; i++) {\n                existing[i][0] = sc.nextInt();\n                existing[i][1] = sc.nextInt();\n            }\n            \n            int t = sc.nextInt();\n            int[][] candidates = new int[t][2];\n            for (int i = 0; i < t; i++) {\n                candidates[i][0] = sc.nextInt();\n                candidates[i][1] = sc.nextInt();\n            }\n            \n            int[][][] existingDist = new int[s][][];\n            for (int i = 0; i < s; i++) {\n                existingDist[i] = computeDistances(existing[i][0], existing[i][1]);\n            }\n            \n            int maxCoverage = 0;\n            \n            for (int c = 0; c < t; c++) {\n                int[][] newDist = computeDistances(candidates[c][0], candidates[c][1]);\n                int coverage = 0;\n                \n                for (int x = 1; x <= m; x++) {\n                    for (int y = 1; y <= n; y++) {\n                        boolean isExisting = false;\n                        for (int i = 0; i < s; i++) {\n                            if (existing[i][0] == x && existing[i][1] == y) {\n                                isExisting = true;\n                                break;\n                            }\n                        }\n                        if (isExisting) continue;\n                        \n                        if (candidates[c][0] == x && candidates[c][1] == y) continue;\n                        \n                        int minDist = newDist[x][y];\n                        if (minDist == -1) continue;\n                        \n                        boolean uniqueMin = true;\n                        for (int i = 0; i < s; i++) {\n                            int d = existingDist[i][x][y];\n                            if (d == -1) continue;\n                            if (d < minDist) {\n                                uniqueMin = false;\n                                break;\n                            } else if (d == minDist) {\n                                uniqueMin = false;\n                                break;\n                            }\n                        }\n                        \n                        if (uniqueMin) {\n                            coverage++;\n                        }\n                    }\n                }\n                \n                maxCoverage = Math.max(maxCoverage, coverage);\n            }\n            \n            System.out.println(maxCoverage);\n        }\n        \n        sc.close();\n    }\n}\n", "perturbed_sampled": [" { static   0}, {0, 1}, {0, -1}, {1,   int[][] neighbors  = new int[]{x, y + 1}; neighbors[3] = new int[]{x, y - 1};  1, y + 1}; neighbors[5] = new int[]{x - 1, y - 1};   neighbors[1]  y};  1,  new int[]{x + 1, y - 1}; neighbors[4]  1}; neighbors[5]  } static int[][] computeDistances(int sx, int sy)  int[m +    sy,  = queue.poll(); int x = curr[0]; int y  curr[2]; int[][] neighbors = getNeighbors(x, y);  { int nx = neighbor[0]; int ny = neighbor[1]; if (nx >= 1 && nx <=  &&  = d + 1; queue.offer(new int[]{nx, ny,   static void main(String[] args)   0  int s  new int[s][2]; for (int i = 0; i < s; i++) { existing[i][0] = sc.nextInt(); existing[i][1] = sc.nextInt();  (int  s; i++) { existingDist[i] = computeDistances(existing[i][0],  0; for (int c = 0; c <  coverage  = 1; x <= m; x++) {  y <= n; y++) { boolean isExisting = false; for  && existing[i][1] == y) {  continue;  (minDist == -1) continue; boolean uniqueMin = true; for (int i = 0; i   == minDist) { uniqueMin  } } } maxCoverage = Math.max(maxCoverage,  } }"], "perturbed_original": ["import java.util.*; public class Main e=0;break}<extra_id_11>{ args) { Scanner s=new Scanner(System.in); for(int m,n,x,a[][];(m=s.nextInt())>0;){ n=s.nextInt(); x=s.nextInt(); a=new int[n][m];   q.add(new int[]{u,v,1}); int c=1; while(!q.isEmpty()){ int[]t=q.poll(); for(int i=0;i<6;++i){ int  } } } r=r>c?r:c; } } System.out.println(r); } } }"], "original_ll": -0.8560478687286377, "sampled_ll": -0.35556843876838684, "all_perturbed_sampled_ll": [-2.190486431121826], "all_perturbed_original_ll": [-2.7176995277404785], "perturbed_sampled_ll": -2.190486431121826, "perturbed_original_ll": -2.7176995277404785, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "#Deven-Eleven:\nimport re\nD = (((-1, -1), (0, -1), (1, 0), (0, 1), (-1, 1), (-1, 0)),\n     ((0, -1), (1, -1), (1, 0), (1, 1), (0, 1), (-1, 0)))\ndef func(y, x):\n    q = [(y, x, 0)]\n    cover = [[-1] * m for _ in xrange(n)]\n    while len(q) != 0:\n        y, x, step = q.pop(0)\n        if cover[y][x] >= 0:\n            continue\n        cover[y][x] = step\n        for dx, dy in D[y % 2]:           \n            ny, nx = y + dy, x + dx\n            if 0 <= ny < n and 0 <= nx < m:\n                q.append((ny, nx, step + 1))\n    return cover\n \ndef solve():\n    scover = [func(pos[1] - 1, pos[0] - 1) for pos in spos]\n    min_cover = [[min(sc[y][x] for sc in scover) for x in xrange(m)] for y in xrange(n)]\n    def count(cover):\n        ret = 0\n        for y in xrange(n):\n            for x in xrange(m):\n                if cover[y][x] < min_cover[y][x]:\n                    ret += 1\n        return ret\n    return max(count(func(pos[1] - 1, pos[0] - 1)) for pos in tpos)\n\nwhile True:\n    data = raw_input().sprit()\n    if data == \"0 0\":\n        break\n    m, n = map(int, data.split())\n    s = input()\n    spos = [map(int, raw_input().split()) for _ in xrange(s)]\n    t = input()\n    tpos = [map(int, raw_input().split()) for _ in xrange(t)]\n    print solve()", "sampled": "from collections import deque\n\ndef get_neighbors(x, y, m, n):\n    neighbors = []\n    if y % 2 == 1:  # odd row\n        # neighbors for odd row\n        candidates = [\n            (x-1, y-1), (x, y-1),    # upper left, upper right\n            (x-1, y), (x+1, y),       # left, right\n            (x-1, y+1), (x, y+1)      # lower left, lower right\n        ]\n    else:  # even row\n        # neighbors for even row\n        candidates = [\n            (x, y-1), (x+1, y-1),     # upper left, upper right\n            (x-1, y), (x+1, y),       # left, right\n            (x, y+1), (x+1, y+1)      # lower left, lower right\n        ]\n    \n    for nx, ny in candidates:\n        if 1 <= nx <= m and 1 <= ny <= n:\n            neighbors.append((nx, ny))\n    \n    return neighbors\n\ndef bfs_distances(start_x, start_y, m, n):\n    distances = {}\n    queue = deque([(start_x, start_y, 0)])\n    distances[(start_x, start_y)] = 0\n    \n    while queue:\n        x, y, dist = queue.popleft()\n        \n        for nx, ny in get_neighbors(x, y, m, n):\n            if (nx, ny) not in distances:\n                distances[(nx, ny)] = dist + 1\n                queue.append((nx, ny, dist + 1))\n    \n    return distances\n\ndef count_covered_blocks(stores, m, n):\n    # For each block, find the minimum distance to any store\n    min_distances = {}\n    \n    for i, (sx, sy) in enumerate(stores):\n        distances = bfs_distances(sx, sy, m, n)\n        for (x, y), dist in distances.items():\n            if (x, y) not in min_distances:\n                min_distances[(x, y)] = []\n            min_distances[(x, y)].append((dist, i))\n    \n    # Count blocks covered by each store\n    coverage = [0] * len(stores)\n    \n    for (x, y), dists in min_distances.items():\n        dists.sort()\n        if len(dists) > 0:\n            min_dist = dists[0][0]\n            stores_at_min_dist = [store_idx for dist, store_idx in dists if dist == min_dist]\n            \n            # Only count if exactly one store is closest\n            if len(stores_at_min_dist) == 1:\n                coverage[stores_at_min_dist[0]] += 1\n    \n    return coverage\n\nwhile True:\n    m, n = map(int, input().split())\n    if m == 0 and n == 0:\n        break\n    \n    s = int(input())\n    existing_stores = []\n    for _ in range(s):\n        x, y = map(int, input().split())\n        existing_stores.append((x, y))\n    \n    t = int(input())\n    candidates = []\n    for _ in range(t):\n        p, q = map(int, input().split())\n        candidates.append((p, q))\n    \n    max_coverage = 0\n    \n    for candidate in candidates:\n        # Create a list of all stores including the new one\n        all_stores = existing_stores + [candidate]\n        \n        # Count coverage for all stores\n        coverage = count_covered_blocks(all_stores, m, n)\n        \n        # The last store in the list is the new one\n        new_store_coverage = coverage[-1]\n        \n        max_coverage = max(max_coverage, new_store_coverage)\n    \n    print(max_coverage)\n", "perturbed_sampled": ["from collections import deque def get_neighbors(x, y, m, n): neighbors =   (x-1, y-1), (x, y-1), # upper left, upper right (x-1,  right (x-1, y+1),  lower right ] else:  (x+1, y-1),  # left, right (x, y+1), (x+1,   <= nx <= m  n: neighbors.append((nx,  start_y, m, n): distances = {} queue =  = 0  ny  queue.append((nx,  n): # For each block, find  for  distances = bfs_distances(sx, sy, m, n) for (x, y), dist in distances.items(): if  min_distances[(x,  i)) # Count blocks covered by each store coverage =  dists.sort() if  dists[0][0] stores_at_min_dist = [store_idx for  dist ==   n  == 0 and n == 0: break s =  _ in range(s): x, y =  = int(input()) candidates  range(t): p, q = map(int,  list of   [candidate] # Count coverage for all  n)   max_coverage = max(max_coverage, new_store_coverage) print(max_coverage)"], "perturbed_original": ["#Deven-Eleven:   (-1, 0)), ((0, -1), (1,  (0, 1), (-1, 0))) def func(y, x): q  y, x, step = q.pop(0) if cover[y][x] >= 0: continue cover[y][x]   dy,  <= ny < n and 0  nx, step + 1)) return cover   y   xrange(n): for x in xrange(m): if cover[y][x] < min_cover[y][x]: ret += 1 return ret  - 1)) for pos in tpos) while True:  == \"0 0\": break m,  input()  _ in xrange(t)] print solve()"], "original_ll": -1.0495473146438599, "sampled_ll": -0.6586393713951111, "all_perturbed_sampled_ll": [-3.1510121822357178], "all_perturbed_original_ll": [-3.3969719409942627], "perturbed_sampled_ll": -3.1510121822357178, "perturbed_original_ll": -3.3969719409942627, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "M,N,D;P[101][4][21][21];S[21][21];C[4][21][21];J[4][21][21];h1,h2;i,n,v1,v2,k;xs,ys,xg,yg,T;d,x,y,d1,t1,x1,y1;vx[]={1,0,-1,0},vy[]={0,1,0,-1};void set_road(int A[][21][21],int h1,int v1,int h2,int v2,int d){if(v1==v2){A[h1<h2?1:3][v1][h1-96]=d;A[h1<h2?3:1][v2][h2-96]=d;}else{A[v1<v2?0:2][v1][h1-96]=d;A[v1<v2?2:0][v2][h2-96]=d;}}main(){for(;scanf(\"%d%d%d%d\",&M,&N,&D,&n),M;){memset(P,0,sizeof(P));memset(S,0,sizeof(S));memset(C,0,sizeof(C));memset(J,0,sizeof(J));for(i=0;i<n;i++){scanf(\"\\n%c-%d%d\",&h1,&v1,&k);S[v1][h1-96]=k;}scanf(\"%d\",&n);for(i=0;i<n;i++){scanf(\"\\n%c-%d %c-%d\",&h1,&v1,&h2,&v2);set_road(C,h1,v1,h2,v2,1);}scanf(\"%d\",&n);for(i=0;i<n;i++){scanf(\"\\n%c-%d %c-%d%d\",&h1,&v1,&h2,&v2,&k);set_road(J,h1,v1,h2,v2,k);}scanf(\"\\n%c-%d %c-%d\",&h1,&v1,&h2,&v2);xs=v1;ys=h1-96;xg=v2;yg=h2-96;P[0][0][xs][ys]=1;for(T=0;;T++)for(d=0;d<4;d++){if(P[T][d][xg][yg]){printf(\"%d\\n\",T);goto E;}for(x=1;x<=N;x++)for(y=1;y<=M;y++)if(P[T][d][x][y]&&(!S[x][y]||T/S[x][y]%2!=d%2))for(d1=0;d1<4;d1++){t1=T+D+J[d1][x][y];x1=x+vx[d1];y1=y+vy[d1];if(d1!=(d^2)&&!C[d1][x][y]&&t1<=100&&x1>=1&&x1<=N&&y1>=1&&y1<=M)P[t1][d1][x1][y1]=1;}}E:;}return 0;}", "sampled": "#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n\n#define MAX_N 20\n#define INF 1000000\n\ntypedef struct {\n    int r, c, time, dir;\n} State;\n\nint M, N, D;\nint signal[MAX_N][MAX_N];\nint period[MAX_N][MAX_N];\nint construction[MAX_N][MAX_N][MAX_N][MAX_N];\nint traffic[MAX_N][MAX_N][MAX_N][MAX_N];\nint visited[MAX_N][MAX_N][101][4];\n\nState queue[1000000];\nint head, tail;\n\nint dr[] = {0, 0, -1, 1};\nint dc[] = {-1, 1, 0, 0};\n\nvoid parseIntersection(char *s, int *r, int *c) {\n    char h[10];\n    int v;\n    sscanf(s, \"%[^-]-%d\", h, &v);\n    *r = h[0] - 'a';\n    *c = v - 1;\n}\n\nint canPass(int r, int c, int time, int from_dir, int to_dir) {\n    if (signal[r][c] == 0) return 1;\n    \n    int k = period[r][c];\n    int cycle = time % (2 * k);\n    int is_ns_green = (cycle < k);\n    \n    if (to_dir == 2 || to_dir == 3) {\n        return is_ns_green;\n    } else {\n        return !is_ns_green;\n    }\n}\n\nint solve(int sr, int sc, int er, int ec) {\n    memset(visited, 0, sizeof(visited));\n    \n    head = tail = 0;\n    queue[tail].r = sr;\n    queue[tail].c = sc;\n    queue[tail].time = 0;\n    queue[tail].dir = 1;\n    tail++;\n    visited[sr][sc][0][1] = 1;\n    \n    while (head < tail) {\n        State cur = queue[head++];\n        \n        if (cur.r == er && cur.c == ec) {\n            return cur.time;\n        }\n        \n        if (cur.time >= 100) continue;\n        \n        for (int d = 0; d < 4; d++) {\n            if (d == (cur.dir ^ 1)) continue;\n            \n            int nr = cur.r + dr[d];\n            int nc = cur.c + dc[d];\n            \n            if (nr < 0 || nr >= M || nc < 0 || nc >= N) continue;\n            if (construction[cur.r][cur.c][nr][nc]) continue;\n            \n            if (!canPass(cur.r, cur.c, cur.time, cur.dir, d)) continue;\n            \n            int next_time = cur.time + D + traffic[cur.r][cur.c][nr][nc];\n            \n            if (next_time > 100) continue;\n            if (visited[nr][nc][next_time][d]) continue;\n            \n            visited[nr][nc][next_time][d] = 1;\n            queue[tail].r = nr;\n            queue[tail].c = nc;\n            queue[tail].time = next_time;\n            queue[tail].dir = d;\n            tail++;\n        }\n    }\n    \n    return -1;\n}\n\nint main() {\n    while (1) {\n        scanf(\"%d %d\", &M, &N);\n        if (M == 0 && N == 0) break;\n        \n        scanf(\"%d\", &D);\n        \n        memset(signal, 0, sizeof(signal));\n        memset(period, 0, sizeof(period));\n        memset(construction, 0, sizeof(construction));\n        memset(traffic, 0, sizeof(traffic));\n        \n        int ns;\n        scanf(\"%d\", &ns);\n        for (int i = 0; i < ns; i++) {\n            char s[20];\n            int k, r, c;\n            scanf(\"%s %d\", s, &k);\n            parseIntersection(s, &r, &c);\n            signal[r][c] = 1;\n            period[r][c] = k;\n        }\n        \n        int nc;\n        scanf(\"%d\", &nc);\n        for (int i = 0; i < nc; i++) {\n            char s1[20], s2[20];\n            int r1, c1, r2, c2;\n            scanf(\"%s %s\", s1, s2);\n            parseIntersection(s1, &r1, &c1);\n            parseIntersection(s2, &r2, &c2);\n            construction[r1][c1][r2][c2] = 1;\n            construction[r2][c2][r1][c1] = 1;\n        }\n        \n        int nj;\n        scanf(\"%d\", &nj);\n        for (int i = 0; i < nj; i++) {\n            char s1[20], s2[20];\n            int r1, c1, r2, c2, d;\n            scanf(\"%s %s %d\", s1, s2, &d);\n            parseIntersection(s1, &r1, &c1);\n            parseIntersection(s2, &r2, &c2);\n            traffic[r1][c1][r2][c2] = d;\n            traffic[r2][c2][r1][c1] = d;\n        }\n        \n        char start[20], end[20];\n        int sr, sc, er, ec;\n        scanf(\"%s %s\", start, end);\n        parseIntersection(start, &sr, &sc);\n        parseIntersection(end, &er, &ec);\n        \n        int result = solve(sr, sc, er, ec);\n        printf(\"%d\\n\", result);\n    }\n    \n    return 0;\n}\n", "perturbed_sampled": ["#include  #define  typedef struct  dir; } State; int M, N, D; int signal[MAX_N][MAX_N];  traffic[MAX_N][MAX_N][MAX_N][MAX_N]; int visited[MAX_N][MAX_N][101][4]; State queue[1000000]; int head, tail; int dr[] = {0,   *r =  v - 1; } int canPass(int r, int c, int time,  if (signal[r][c] == 0) return 1; int k = period[r][c]; int cycle =  is_ns_green; }  } int solve(int sr, int sc, int er, int  head = tail = 0;  sc;  1; tail++; visited[sr][sc][0][1]  tail) {  cur.c  } if  (int  4;  (cur.dir ^  cur.r + dr[d]; int  ||  cur.time + D + traffic[cur.r][cur.c][nr][nc]; if (next_time > 100) continue; if (visited[nr][nc][next_time][d]) continue; visited[nr][nc][next_time][d] = 1; queue[tail].r = nr; queue[tail].c = nc; queue[tail].time = next_time; queue[tail].dir =  -1; } int  scanf(\"%d %d\", &M, &N); if (M == 0  scanf(\"%d\", &D); memset(signal, 0, sizeof(signal)); memset(period, 0,  scanf(\"%d\",  i++) { char s[20]; int   =  &nc);   char   parseIntersection(s2, &r2, &c2); construction[r1][c1][r2][c2] = 1; construction[r2][c2][r1][c1]  char s1[20], s2[20];  s1, s2, &d); parseIntersection(s1, &r1, &c1); parseIntersection(s2, &r2, &c2); traffic[r1][c1][r2][c2] = d; traffic[r2][c2][r1][c1] = d; }  sc, er, ec; scanf(\"%s  }"], "perturbed_original": ["M,N,D;P[101][4][21][21];S[21][21];C[4][21][21];J[4][21][21];h1,h2;i,n,v1,v2,k;xs,ys,xg,yg,T;d,x,y,d1,t1,x1,y1;vx[]={1,0,-1,0},vy[]={0,1,0,-1};void set_road(int A[][21][21],int h1,int v1,int h2,int  E;}for(x=1;x<=N;x++)for(y=1;y<=M;y++)if(P[T][d][x][y]&&(!S[x][y]||T/S[x][y]%2!=d%2))for(d1=0;d1<4;d1++){t1=T+D+J[d1][x][y];x1=x+vx[d1];y1=y+vy[d1];if(d1!=(d^2)&&!C[d1][x][y]&&t1<=100&&x1>=1&&x1<=N&&y1>=1&&y1<=M)P[t1][d1][x1][y1]=1;}}E:;}return 0;}"], "original_ll": -1.225968360900879, "sampled_ll": -0.5271077156066895, "all_perturbed_sampled_ll": [-2.167174816131592], "all_perturbed_original_ll": [-1.9472973346710205], "perturbed_sampled_ll": -2.167174816131592, "perturbed_original_ll": -1.9472973346710205, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import java.util.*;\nimport java.awt.Point;\n\npublic class Main{\n\tpublic static void main(String[] args){\n\t\tScanner sc = new Scanner(System.in);\n\t\tint dx[] = {0,1,0,-1};\n\t\tint dy[] = {-1,0,1,0};\n\t\tboolean pass[] = {true,false,true,false};\n\n\t\twhile(true){\n\t\t\tint h = sc.nextInt();\n\t\t\tint w = sc.nextInt();\n\t\t\tif(w == 0 && h == 0) break;\n\t\t\tint d = sc.nextInt();\n\n\t\t\tHashMap<Point,Integer> node = new HashMap<Point,Integer>();\n\t\t\tint ns = sc.nextInt();\n\t\t\tfor(int i=0;i<ns;i++){\n\t\t\t\tnode.put(toPoint(sc.next()),sc.nextInt());\n\t\t\t}\n\n\t\t\tHashMap<Point,HashMap<Point,Integer>> edge = new HashMap<Point,HashMap<Point,Integer>>();\n\t\t\tint nc = sc.nextInt();\n\t\t\tfor(int i=0;i<nc;i++){\n\t\t\t\tPoint a = toPoint(sc.next());\n\t\t\t\tPoint b = toPoint(sc.next());\n\t\t\t\tif(edge.get(a) == null) edge.put(a,new HashMap<Point,Integer>());\n\t\t\t\tif(edge.get(b) == null) edge.put(b,new HashMap<Point,Integer>());\n\t\t\t\tedge.get(a).put(b,-1);\n\t\t\t\tedge.get(b).put(a,-1);\n\t\t\t}\n\n\t\t\tint nj = sc.nextInt();\n\t\t\tfor(int i=0;i<nj;i++){\n\t\t\t\tPoint a = toPoint(sc.next());\n\t\t\t\tPoint b = toPoint(sc.next());\n\t\t\t\tint cost = sc.nextInt();\n\t\t\t\tif(edge.get(a) == null) edge.put(a,new HashMap<Point,Integer>());\n\t\t\t\tif(edge.get(b) == null) edge.put(b,new HashMap<Point,Integer>());\n\t\t\t\tedge.get(a).put(b,cost);\n\t\t\t\tedge.get(b).put(a,cost);\n\t\t\t}\n\n\t\t\tPoint start = toPoint(sc.next());\n\t\t\tPoint goal = toPoint(sc.next());\n\n\t\t\tPriorityQueue<State> open = new PriorityQueue<State>();\n\t\t\tHashSet<State> closed = new HashSet<State>();\n\t\t\topen.add(new State(start,1,0));\n\t\t\t//closed.add(new State(start,1,0));\n\t\t\tState ans = null;\n\n\t\t\twhile(!open.isEmpty()){\n\t\t\t\tState st = open.poll();\n\n\t\t\t\tif(closed.contains(st)) continue;\n\t\t\t\tclosed.add(st);\n\n\t\t\t\tif(st.p.equals(goal)){\n\t\t\t\t\tans = st;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tfor(int i=0;i<4;i++){\n\t\t\t\t\t//U\u0083^\u0081[\u0083\u0093\u0082\u00b5\u0082\u00c4\u0082\u00cd\u0082\u00a2\u0082\u00af\u0082\u00c8\u0082\u00a2\n\t\t\t\t\tif((st.d + 2) % 4 == i) continue;\n\n\t\t\t\t\tPoint np = new Point(st.p.x + dx[i], st.p.y + dy[i]);\n\n\t\t\t\t\tif(np.x>=0 && np.x<w && np.y>=0 && np.y<h){\n\t\t\t\t\t\tint val = 0;\n\t\t\t\t\t\t//st.p\u0082\u00a9\u0082\u00e7np\u0082\u00d6\u0082\u00cc\u0093\u00b9\u008f\u00ee\u0095\u00f1\u0082\u00f0\u008e\u00e6\u0082\u00e8\u008fo\u0082\u00b7\n\t\t\t\t\t\tif(edge.containsKey(st.p) &&\n\t\t\t\t\t\t\t edge.get(st.p).containsKey(np)) val = edge.get(st.p).get(np);\n\t\t\t\t\t\t//\u008dH\u008e\u0096\u0092\u0086\u0082\u00c8\u0082\u00e7\u0092\u00ca\u0082\u00ea\u0082\u00c8\u0082\u00a2\n\t\t\t\t\t\tif(val == -1) continue;\n\n\t\t\t\t\t\tint ncost = st.cost + d + val;\n\n\t\t\t\t\t\t//\u0090M\u008d\u0086\u0082\u00aa\u0082\u00a0\u0082\u00e9\u008f\u00ea\u008d\u0087\u0082\u00cc\u008f\u0088\u0097\u009d\n\t\t\t\t\t\tif(node.containsKey(np)){\n\t\t\t\t\t\t\tint k = node.get(np);\n\t\t\t\t\t\t\tboolean flg = pass[i]; //true:\u0090N\u0093\u00fc\u0089\u00c2\u0094\\\u0082\u00c5\u0082\u00a0\u0082\u00e9\n\t\t\t\t\t\t\tint div = ncost / k;\n\t\t\t\t\t\t\tif(div % 2 == 1) flg = !flg;\n\t\t\t\t\t\t\tif(!flg) continue;\n\t\t\t\t\t\t\t//if(!flg) ncost += k - ncost % k;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\topen.add(new State(np,i,ncost));\n\t\t\t\t\t\tState nst = new State(np,i,ncost);\n\t\t\t\t\t\t//if(closed.contains(nst)) continue;\n\t\t\t\t\t\t//closed.add(nst);\n\t\t\t\t\t\t//open.add(nst);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tSystem.out.println(ans.cost);\n\t\t}\n\t}\n\n\tprivate static Point toPoint(String s){\n\t\tString[] tmp = s.split(\"-\");\n\t\tint x = Integer.parseInt(tmp[1]) - 1;\n\t\tint y = tmp[0].charAt(0) - 'a';\n\t\treturn new Point(x,y);\n\t}\n}\n\nclass State implements Comparable<State>{\n\tPoint p;\n\tint d,cost;\n\n\tState(Point p,int d,int cost){\n\t\tthis.p = new Point(p.x,p.y);\n\t\tthis.d = d;\n\t\tthis.cost = cost;\n\t}\n\n\tpublic int compareTo(State st){\n\t\treturn this.cost - st.cost;\n\t}\n\n\tpublic boolean equals(Object o){\n\t\tState st = (State)o;\n\t\treturn p.equals(st.p) && d == st.d;\n\t}\n\n\tpublic int hashCode(){\n\t\treturn p.x + p.y * 100 + d * 10000;\n\t}\n\n\tpublic String toString(){\n\t\treturn String.format(\"[(%d,%d),%d,%d]\",p.x,p.y,d,cost);\n\t}\n}", "sampled": "import java.util.*;\nimport java.io.*;\n\npublic class Main {\n    static class State implements Comparable<State> {\n        int row, col, time, dir;\n        \n        public State(int row, int col, int time, int dir) {\n            this.row = row;\n            this.col = col;\n            this.time = time;\n            this.dir = dir;\n        }\n        \n        public int compareTo(State other) {\n            return this.time - other.time;\n        }\n    }\n    \n    static final int EAST = 0, WEST = 1, SOUTH = 2, NORTH = 3;\n    static final int[] DR = {0, 0, 1, -1};\n    static final int[] DC = {1, -1, 0, 0};\n    \n    public static void main(String[] args) throws IOException {\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        String line;\n        \n        while ((line = br.readLine()) != null) {\n            String[] tokens = line.trim().split(\"\\\\s+\");\n            int M = Integer.parseInt(tokens[0]);\n            int N = Integer.parseInt(tokens[1]);\n            \n            if (M == 0 && N == 0) break;\n            \n            int D = Integer.parseInt(br.readLine().trim());\n            \n            int[][] signal = new int[M][N];\n            for (int i = 0; i < M; i++) {\n                Arrays.fill(signal[i], -1);\n            }\n            \n            int ns = Integer.parseInt(br.readLine().trim());\n            for (int i = 0; i < ns; i++) {\n                tokens = br.readLine().trim().split(\"\\\\s+\");\n                String[] pos = tokens[0].split(\"-\");\n                int row = pos[0].charAt(0) - 'a';\n                int col = Integer.parseInt(pos[1]) - 1;\n                int k = Integer.parseInt(tokens[1]);\n                signal[row][col] = k;\n            }\n            \n            boolean[][][] blocked = new boolean[M][N][4];\n            int nc = Integer.parseInt(br.readLine().trim());\n            for (int i = 0; i < nc; i++) {\n                tokens = br.readLine().trim().split(\"\\\\s+\");\n                String[] pos1 = tokens[0].split(\"-\");\n                String[] pos2 = tokens[1].split(\"-\");\n                int r1 = pos1[0].charAt(0) - 'a';\n                int c1 = Integer.parseInt(pos1[1]) - 1;\n                int r2 = pos2[0].charAt(0) - 'a';\n                int c2 = Integer.parseInt(pos2[1]) - 1;\n                \n                for (int d = 0; d < 4; d++) {\n                    if (r1 + DR[d] == r2 && c1 + DC[d] == c2) {\n                        blocked[r1][c1][d] = true;\n                        blocked[r2][c2][d ^ 1] = true;\n                    }\n                }\n            }\n            \n            int[][] congestion = new int[M][N];\n            for (int i = 0; i < M; i++) {\n                for (int j = 0; j < N; j++) {\n                    congestion[i][j] = D;\n                }\n            }\n            \n            int nj = Integer.parseInt(br.readLine().trim());\n            for (int i = 0; i < nj; i++) {\n                tokens = br.readLine().trim().split(\"\\\\s+\");\n                String[] pos1 = tokens[0].split(\"-\");\n                String[] pos2 = tokens[1].split(\"-\");\n                int r1 = pos1[0].charAt(0) - 'a';\n                int c1 = Integer.parseInt(pos1[1]) - 1;\n                int r2 = pos2[0].charAt(0) - 'a';\n                int c2 = Integer.parseInt(pos2[1]) - 1;\n                int d = Integer.parseInt(tokens[2]);\n                \n                congestion[r1][c1] = Math.max(congestion[r1][c1], D + d);\n            }\n            \n            tokens = br.readLine().trim().split(\"\\\\s+\");\n            String[] start = tokens[0].split(\"-\");\n            String[] end = tokens[1].split(\"-\");\n            int sr = start[0].charAt(0) - 'a';\n            int sc = Integer.parseInt(start[1]) - 1;\n            int er = end[0].charAt(0) - 'a';\n            int ec = Integer.parseInt(end[1]) - 1;\n            \n            int result = dijkstra(M, N, sr, sc, er, ec, signal, blocked, congestion);\n            System.out.println(result);\n        }\n    }\n    \n    static int dijkstra(int M, int N, int sr, int sc, int er, int ec, \n                        int[][] signal, boolean[][][] blocked, int[][] congestion) {\n        int[][][] dist = new int[M][N][4];\n        for (int i = 0; i < M; i++) {\n            for (int j = 0; j < N; j++) {\n                Arrays.fill(dist[i][j], Integer.MAX_VALUE);\n            }\n        }\n        \n        PriorityQueue<State> pq = new PriorityQueue<>();\n        pq.offer(new State(sr, sc, 0, EAST));\n        dist[sr][sc][EAST] = 0;\n        \n        while (!pq.isEmpty()) {\n            State curr = pq.poll();\n            \n            if (curr.row == er && curr.col == ec) {\n                return curr.time;\n            }\n            \n            if (curr.time > dist[curr.row][curr.col][curr.dir]) continue;\n            \n            for (int d = 0; d < 4; d++) {\n                if (d == (curr.dir ^ 1)) continue;\n                \n                if (blocked[curr.row][curr.col][d]) continue;\n                \n                if (signal[curr.row][curr.col] != -1) {\n                    int k = signal[curr.row][curr.col];\n                    int cycle = curr.time / k;\n                    boolean isNSGreen = (cycle % 2 == 0);\n                    boolean isEWGreen = !isNSGreen;\n                    \n                    if ((d == EAST || d == WEST) && !isEWGreen) continue;\n                    if ((d == NORTH || d == SOUTH) && !isNSGreen) continue;\n                }\n                \n                int nr = curr.row + DR[d];\n                int nc = curr.col + DC[d];\n                \n                if (nr < 0 || nr >= M || nc < 0 || nc >= N) continue;\n                \n                int travelTime = congestion[curr.row][curr.col];\n                int newTime = curr.time + travelTime;\n                \n                if (newTime < dist[nr][nc][d]) {\n                    dist[nr][nc][d] = newTime;\n                    pq.offer(new State(nr, nc, newTime, d));\n                }\n            }\n        }\n        \n        return -1;\n    }\n}\n", "perturbed_sampled": ["import java.util.*; import java.io.*; public  dir; public State(int row, int  {  col; this.time  } public  this.time -  = 2, NORTH = 3;  {0, 0, 1, -1}; static final  0, 0};  br = new BufferedReader(new InputStreamReader(System.in)); String   =  int N =  break; int D = Integer.parseInt(br.readLine().trim()); int[][] signal = new int[M][N]; for  < M; i++) { Arrays.fill(signal[i], -1); } int  row  1; int k = Integer.parseInt(tokens[1]);  blocked  i = 0; i  = pos1[0].charAt(0) - 'a'; int  - 'a'; int  0; d   &&    =  = 0; i < M; i++)   { congestion[i][j] =  = Integer.parseInt(br.readLine().trim()); for (int i = 0; i < nj; i++)  pos2 = tokens[1].split(\"-\"); int  = pos2[0].charAt(0) - 'a'; int c2 = Integer.parseInt(pos2[1])   + d); } tokens = br.readLine().trim().split(\"\\\\s+\"); String[] start = tokens[0].split(\"-\"); String[]  = start[0].charAt(0) - 'a'; int sc = Integer.parseInt(start[1]) - 1; int   1; int result = dijkstra(M, N, sr, sc, er, ec, signal, blocked, congestion); System.out.println(result); } } static int  sr, int   i < M; i++) { for  Arrays.fill(dist[i][j], Integer.MAX_VALUE); } } PriorityQueue<State> pq = new  EAST)); dist[sr][sc][EAST] = 0; while  er && curr.col ==   0;  if (d ==  (blocked[curr.row][curr.col][d]) continue; if (signal[curr.row][curr.col] != -1)  int cycle = curr.time / k; boolean  == WEST) && !isEWGreen) continue; if ((d ==  &&  = curr.row + DR[d]; int nc =  >= M  int travelTime = congestion[curr.row][curr.col]; int  if (newTime <  d));  } }"], "perturbed_original": ["import  Main{ public static void main(String[] args){ Scanner sc = new Scanner(System.in); int dx[] = {0,1,0,-1}; int dy[] =  while(true){  w =  h  ns =  HashMap<Point,HashMap<Point,Integer>>   if(edge.get(a) ==  edge.get(b).put(a,-1); }  toPoint(sc.next()); Point b = toPoint(sc.next()); int cost = sc.nextInt(); if(edge.get(a) == null)  edge.put(b,new HashMap<Point,Integer>()); edge.get(a).put(b,cost); edge.get(b).put(a,cost); }  HashSet<State> closed = new HashSet<State>(); open.add(new  = null; while(!open.isEmpty()){  continue; closed.add(st); if(st.p.equals(goal)){ ans  i=0;i<4;i++){  +  np.y>=0 && np.y<h){ int  -1)  + d + val; //\u0090M\u008d\u0086\u0082\u00aa\u0082  node.get(np); boolean flg  k; if(div % 2 ==  continue; //if(!flg) ncost  State(np,i,ncost); //if(closed.contains(nst))  private static Point toPoint(String s){ String[] tmp =  return  p; int  this.p = new  =  st.cost; } public boolean equals(Object o){ State st = (State)o; return p.equals(st.p) && d  hashCode(){ return p.x + p.y * 100 + d * 10000; } public String toString(){ return String.format(\"[(%d,%d),%d,%d]\",p.x,p.y,d,cost); } }"], "original_ll": -1.0800551176071167, "sampled_ll": -0.42935001850128174, "all_perturbed_sampled_ll": [-2.7775564193725586], "all_perturbed_original_ll": [-2.7587168216705322], "perturbed_sampled_ll": -2.7775564193725586, "perturbed_original_ll": -2.7587168216705322, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "#Byakko Delivery Company\nfrom heapq import heappop, heappush\nfrom string import ascii_lowercase as al\ndic = dict([(c,i) for i, c in enumerate(al)])\nf = lambda (h, v):(dic[h], int(v) - 1)\ng = lambda s:f(s.split(\"-\"))\n\ndef solve():\n    hq = [(0, start[0], start[1])]\n    while len(hq) != 0:\n        cost, cy, cx = heappop(hq)\n        #print \"cost = {}, pos = ({}, {})\".format(cost, cy, cx)\n        if (cy, cx) == goal:\n            return cost\n        for dy, dx in ((0, 1), (0, -1), (1, 0), (-1, 0)):\n            ny, nx = cy + dy, cx + dx\n            if 0 <= ny < M and 0 <= nx < N:\n                #print ny, nx, condition[ny][nx][cy][cx]\n                nc = condition[ny][nx][cy][cx] + D + cost\n                if field[ny][nx] == 0:\n                    heappush(hq, (nc, ny, nx))\n                else:\n                    if dy == 0:\n                        if (nc / field[ny][nx]) % 2 == 1:\n                            heappush(hq, (nc, ny, nx))\n                    else:\n                        if (nc / field[ny][nx]) % 2 == 0:\n                            heappush(hq, (nc, ny, nx))\nwhile True:\n    M, N = map(int, raw_input().split())\n    if M | N == 0:\n        break\n    D = input()\n    field = [[0] * N for _ in xrange(M)]\n    condition = [[[[0] * N for _ in xrange(M)] for _ in xrange(N)] for _ in xrange(M)]\n    for _ in xrange(input()):\n        p, k = raw_input().split()\n        h, v = g(p)\n        field[h][v] = int(k)\n\n    for _ in xrange(input()):    \n        (h1, v1), (h2, v2) = map(g, raw_input().split())\n        condition[h1][v1][h2][v2] = condition[h2][v2][h1][v1] = 1 << 30\n\n    for _ in xrange(input()):\n        p1, p2, d = raw_input().split()\n        h1, v1 = g(p1)\n        h2, v2 = g(p2)\n        condition[h1][v1][h2][v2] = condition[h2][v2][h1][v1] = int(d)\n\n    start, goal = map(g, raw_input().split())\n    print solve()", "sampled": "import heapq\nfrom collections import defaultdict\n\ndef parse_intersection(s):\n    parts = s.split('-')\n    h = ord(parts[0]) - ord('a')\n    v = int(parts[1]) - 1\n    return (h, v)\n\ndef solve():\n    while True:\n        line = input().split()\n        M, N = int(line[0]), int(line[1])\n        if M == 0 and N == 0:\n            break\n        \n        D = int(input())\n        \n        ns = int(input())\n        signals = {}\n        for _ in range(ns):\n            parts = input().split()\n            pos = parse_intersection(parts[0])\n            k = int(parts[1])\n            signals[pos] = k\n        \n        nc = int(input())\n        blocked = set()\n        for _ in range(nc):\n            parts = input().split()\n            pos1 = parse_intersection(parts[0])\n            pos2 = parse_intersection(parts[1])\n            blocked.add((min(pos1, pos2), max(pos1, pos2)))\n        \n        nj = int(input())\n        jams = {}\n        for _ in range(nj):\n            parts = input().split()\n            pos1 = parse_intersection(parts[0])\n            pos2 = parse_intersection(parts[1])\n            d = int(parts[2])\n            key = (min(pos1, pos2), max(pos1, pos2))\n            jams[key] = d\n        \n        parts = input().split()\n        start = parse_intersection(parts[0])\n        end = parse_intersection(parts[1])\n        \n        # Dijkstra with state (time, pos, direction)\n        # direction: 0=E, 1=W, 2=S, 3=N\n        pq = [(0, start, 0)]\n        visited = set()\n        \n        # Direction vectors: E, W, S, N\n        dirs = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n        # EW: 0,1  NS: 2,3\n        \n        while pq:\n            time, pos, prev_dir = heapq.heappop(pq)\n            \n            if pos == end:\n                print(time)\n                break\n            \n            state = (pos, prev_dir)\n            if state in visited:\n                continue\n            visited.add(state)\n            \n            h, v = pos\n            \n            for d in range(4):\n                # No U-turn\n                if prev_dir == 0 and d == 1:\n                    continue\n                if prev_dir == 1 and d == 0:\n                    continue\n                if prev_dir == 2 and d == 3:\n                    continue\n                if prev_dir == 3 and d == 2:\n                    continue\n                \n                dh, dv = dirs[d]\n                nh, nv = h + dh, v + dv\n                \n                if nh < 0 or nh >= M or nv < 0 or nv >= N:\n                    continue\n                \n                new_pos = (nh, nv)\n                edge = (min(pos, new_pos), max(pos, new_pos))\n                \n                if edge in blocked:\n                    continue\n                \n                # Check signal at current position\n                if pos in signals:\n                    k = signals[pos]\n                    cycle_time = time % (2 * k)\n                    # At time 0, NS is green (d=2,3)\n                    # 0 to k-1: NS green (EW red)\n                    # k to 2k-1: EW green (NS red)\n                    \n                    if d in [0, 1]:  # EW direction\n                        if cycle_time < k:  # NS is green, EW is red\n                            continue\n                    else:  # NS direction\n                        if cycle_time >= k:  # EW is green, NS is red\n                            continue\n                \n                travel_time = D\n                if edge in jams:\n                    travel_time += jams[edge]\n                \n                new_time = time + travel_time\n                \n                if new_time <= 100:\n                    heapq.heappush(pq, (new_time, new_pos, d))\n\nsolve()\n", "perturbed_sampled": ["import heapq from  parts =  -   input().split()  if    k = int(parts[1]) signals[pos] = k nc  for _  pos1 = parse_intersection(parts[0])  max(pos1, pos2))) nj = int(input())  in range(nj): parts = input().split() pos1  d   d parts = input().split() start = parse_intersection(parts[0]) end = parse_intersection(parts[1]) # Dijkstra with state (time, pos, direction) #   visited = set()  (1,  0,1  if  state  for d in range(4): # No U-turn if prev_dir ==   continue if prev_dir == 2 and d == 3: continue if prev_dir  = dirs[d] nh,   < 0 or nh  N:  max(pos, new_pos)) if edge in blocked:  current position if pos in signals: k =  (2 * k) # At time 0,  0  2k-1:  # EW direction  NS is  else: # NS direction if cycle_time >= k: # EW is green, NS is    <= 100: heapq.heappush(pq, (new_time, new_pos, d)) solve()"], "perturbed_original": ["  f = lambda (h, v):(dic[h], int(v) -   \"cost = {}, pos = ({}, {})\".format(cost, cy, cx) if  in ((0, 1),  0)): ny, nx = cy +  0 <= ny < M and 0 <= nx < N: #print  cost if field[ny][nx]  nx)) else: if dy == 0: if (nc / field[ny][nx])   (nc / field[ny][nx]) % 2  N = map(int, raw_input().split()) if M | N ==  field = [[0] * N   k = raw_input().split()   v2)  condition[h2][v2][h1][v1]  _  = raw_input().split() h1, v1 = g(p1) h2, v2 = g(p2) condition[h1][v1][h2][v2] =  = map(g, raw_input().split()) print solve()"], "original_ll": -0.9956142902374268, "sampled_ll": -0.9774958491325378, "all_perturbed_sampled_ll": [-3.5874130725860596], "all_perturbed_original_ll": [-3.05706787109375], "perturbed_sampled_ll": -3.5874130725860596, "perturbed_original_ll": -3.05706787109375, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "#include<stdio.h>\n\nint main(void){\n\t\n\tint i,sum,a,b,c;\n\tint top,topn;\n\t\n\ttop = 0;\n\t\n\twhile(1){\n\t\t\n\t\tscanf(\" %d %d\",&a,&b);\n\t\t\n\t\tif(a == 0 && b == 0){\n\t\t\tbreak;\n\t\t}\n\t\t\n\t\tc = a + b;\n\t\t\n\t\tif(top > c){\n\t\t\ttop = c;\n\t\t\ttopn = i;\n\t\t}\n\t\t\n\t\ti++;\n\t\t\n\t\tif(i==5){\n\t\t\tswitch(topn){\n\t\t\t\tcase 1:\n\t\t\t\t\tprintf(\"A \");\n\t\t\t\t\tbreak;\n\t\t\t\tcase 2:\n\t\t\t\t\tprintf(\"B \");\n\t\t\t\t\tbreak;\n\t\t\t\tcase 3:\n\t\t\t\t\tprintf(\"C \");\n\t\t\t\t\tbreak;\n\t\t\t\tcase 4:\n\t\t\t\t\tprintf(\"D \");\n\t\t\t\t\tbreak;\n\t\t\t\tcase 5:\n\t\t\t\t\tprintf(\"E \");\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\n\t\t\t\n\t\t\tprintf(\" %d\",top);\n\t\t}\n\t}\n\t\n\treturn(0);\n\t\n}", "sampled": "#include <stdio.h>\n\nint main() {\n    int s1, s2;\n    char stores[] = {'A', 'B', 'C', 'D', 'E'};\n    int totals[5];\n    \n    while(1) {\n        scanf(\"%d %d\", &s1, &s2);\n        if(s1 == 0 && s2 == 0) break;\n        \n        totals[0] = s1 + s2;\n        \n        for(int i = 1; i < 5; i++) {\n            scanf(\"%d %d\", &s1, &s2);\n            totals[i] = s1 + s2;\n        }\n        \n        int maxIndex = 0;\n        int maxTotal = totals[0];\n        \n        for(int i = 1; i < 5; i++) {\n            if(totals[i] > maxTotal) {\n                maxTotal = totals[i];\n                maxIndex = i;\n            }\n        }\n        \n        printf(\"%c %d\\n\", stores[maxIndex], maxTotal);\n    }\n    \n    return 0;\n}\n", "perturbed_sampled": ["#include <stdio.h> int main() { int s1, s2; char stores[] =  s2 == 0) break; totals[0] = s1 + s2; for(int i = 1; i < 5; i++) {  =  maxIndex = 0; int   0; }"], "perturbed_original": ["#include<stdio.h> int main(void){  = 0; while(1){ scanf(\" %d %d\",&a,&b);  ==  > c){ top   1:  printf(\"B \"); break; case  4: printf(\"D  %d\",top); } } return(0); }"], "original_ll": -0.9154200553894043, "sampled_ll": -0.5907330513000488, "all_perturbed_sampled_ll": [-2.811798334121704], "all_perturbed_original_ll": [-2.9991676807403564], "perturbed_sampled_ll": -2.811798334121704, "perturbed_original_ll": -2.9991676807403564, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import java.util.ArrayList;\nimport java.util.Scanner;\npublic class Main {\n\t\n\tpublic static void main(String[] args) {\n\t\tScanner stdIn = new Scanner(System.in);\n\t\tString[] k = new String[]{\"A\",\"B\",\"C\",\"D\",\"E\"};\n\t\twhile(true) {\n\t\t\tint number = 0;\n\t\t\tint max = 0;\n\t\t\tfor(int i = 0; i < 5; i++) {\n\t\t\t\tint tmp = stdIn.nextInt();\n\t\t\t\ttmp += stdIn.nextInt();\n\t\t\t\tif(tmp == 0) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif(tmp > max) {\n\t\t\t\t\tmax = tmp;\n\t\t\t\t\tnumber = i;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tSystem.out.println(k[number] + \" \" + max);\n\t\t}\n\t}\n}", "sampled": "import java.util.Scanner;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        \n        while (true) {\n            int s1A = sc.nextInt();\n            int s2A = sc.nextInt();\n            \n            if (s1A == 0 && s2A == 0) {\n                break;\n            }\n            \n            int s1B = sc.nextInt();\n            int s2B = sc.nextInt();\n            int s1C = sc.nextInt();\n            int s2C = sc.nextInt();\n            int s1D = sc.nextInt();\n            int s2D = sc.nextInt();\n            int s1E = sc.nextInt();\n            int s2E = sc.nextInt();\n            \n            int totalA = s1A + s2A;\n            int totalB = s1B + s2B;\n            int totalC = s1C + s2C;\n            int totalD = s1D + s2D;\n            int totalE = s1E + s2E;\n            \n            int max = totalA;\n            String store = \"A\";\n            \n            if (totalB > max) {\n                max = totalB;\n                store = \"B\";\n            }\n            if (totalC > max) {\n                max = totalC;\n                store = \"C\";\n            }\n            if (totalD > max) {\n                max = totalD;\n                store = \"D\";\n            }\n            if (totalE > max) {\n                max = totalE;\n                store = \"E\";\n            }\n            \n            System.out.println(store + \" \" + max);\n        }\n        \n        sc.close();\n    }\n}\n", "perturbed_sampled": ["import java.util.Scanner; public class Main { public static   (true) { int s1A = sc.nextInt();  (s1A  0) { break; } int s1B = sc.nextInt(); int s2B  s1A +  + s2B;   = s1E + s2E; int  > max) { max =  if (totalC > max) {    if (totalE > max) { max = totalE; store =  \" + max); } sc.close(); } }"], "perturbed_original": ["import java.util.ArrayList;  {  new Scanner(System.in); String[] k = new String[]{\"A\",\"B\",\"C\",\"D\",\"E\"}; while(true) { int number =  for(int i = 0; i < 5; i++)  == 0) {  number =   } }"], "original_ll": -0.8375464677810669, "sampled_ll": -0.298247367143631, "all_perturbed_sampled_ll": [-2.739671468734741], "all_perturbed_original_ll": [-2.1571195125579834], "perturbed_sampled_ll": -2.739671468734741, "perturbed_original_ll": -2.1571195125579834, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "# Aizu Problem 0195: What is the Most Popular Shop in Tokaichi?\n#\nimport sys, math, os\n\n# read input:\nPYDEV = os.environ.get('PYDEV')\nif PYDEV==\"True\":\n    sys.stdin = open(\"sample-input.txt\", \"rt\")\n\n\nwhile True:\n    most = 0\n    shop = 'A'\n    a, b = [int(_) for _ in input().split()]\n    if a == b == 0:\n        break\n    most = a + b\n    for s in range(4):\n        a = sum([int(_) for _ in input().split()])\n        if a > most:\n            most = a\n            shop = chr(66 + s)\n    print(shop, most)\n            ", "sampled": "import sys\n\nfor line in sys.stdin:\n    s1_A, s2_A = map(int, line.split())\n    if s1_A == 0 and s2_A == 0:\n        break\n    \n    stores = []\n    stores.append(('A', s1_A + s2_A))\n    \n    for store_name in ['B', 'C', 'D', 'E']:\n        s1, s2 = map(int, input().split())\n        stores.append((store_name, s1 + s2))\n    \n    max_store = max(stores, key=lambda x: x[1])\n    print(max_store[0], max_store[1])\n", "perturbed_sampled": ["import sys for line  == 0:  s1_A + s2_A)) for  'E']:  stores.append((store_name, s1 + s2)) max_store  print(max_store[0], max_store[1])"], "perturbed_original": ["# Aizu Problem  Popular  sys, math, os #  open(\"sample-input.txt\",   b = [int(_) for _ in input().split()] if a == b  a + b  in  = chr(66 + s) print(shop, most)"], "original_ll": -1.9836997985839844, "sampled_ll": -0.9668151140213013, "all_perturbed_sampled_ll": [-4.029899597167969], "all_perturbed_original_ll": [-5.168816089630127], "perturbed_sampled_ll": -4.029899597167969, "perturbed_original_ll": -5.168816089630127, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "// Aizu Vol-1 0196: Baseball Championship\n// 2017.8.3\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <ctype.h>\n\nchar *gets(char *);\nchar buf[500], *p;\n\nint getInt(void)\n{\n\tint n = 0;\n\twhile (isspace(*p)) p++;\n\treturn *p++ - '0';\n}\n\nchar getStr(void)\n{\n\twhile (isspace(*p)) p++;\n\treturn *p++;\n}\n\ntypedef struct { char a; int k, w, l; } T;\nT t[15];\n\nint main()\n{\n\tint i, j, k, n;\n\tT tmp, *tp, *tt;\n\n\twhile (1) {\n\t\tgets(buf);\n\t\tif (!(n = atoi(buf))) break;\n\t\tfor (i = 0, tp = t; i < n; i++, tp++) {\n\t\t\tgets(p = buf);\n\t\t\ttp->a = getStr(), tp->k = i, tp->w = tp->l = 0;\n\t\t\tfor (j = 1; j < n; j++) {\n\t\t\t\tk = getInt();\n\t\t\t\tif (k == 0) tp->w++;\n\t\t\t\telse if (k == 1) tp->l++;\n\t\t\t}\n\t\t}\n\t\tfor (i = 0; i < n; i++) {\n\t\t\ttp = t + i;\n\t\t\tfor (j = i+1, tt = tp+1; j < n; j++, tt++) {\n\t\t\t\tif (tt->w > tp->w) tp = tt;\n\t\t\t\telse if (tt->w == tp->w) {\n\t\t\t\t\tif (tt->l < tp->l) tp = tt;\n\t\t\t\t\telse if (tt->l == tp->l && tt->k < tp->k) tp = tt;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (tp != t + i) {\n\t\t\t\tmemcpy(&tmp, t+i, sizeof(tmp));\n\t\t\t\tmemcpy(t+i, tp, sizeof(tmp));\n\t\t\t\tmemcpy(tp, &tmp, sizeof(tmp));\n\t\t\t}\n\t\t}\n\t\tfor (i = 0; i < n; i++) putchar(t[i].a), putchar('\\n');\n\t}\n\treturn 0;\n}", "sampled": "#include <stdio.h>\n#include <string.h>\n\ntypedef struct {\n    char name;\n    int wins;\n    int losses;\n    int order;\n} Team;\n\nint compare(const void *a, const void *b) {\n    Team *ta = (Team *)a;\n    Team *tb = (Team *)b;\n    \n    if (ta->wins != tb->wins) {\n        return tb->wins - ta->wins;\n    }\n    if (ta->losses != tb->losses) {\n        return ta->losses - tb->losses;\n    }\n    return ta->order - tb->order;\n}\n\nint main() {\n    int n;\n    \n    while (scanf(\"%d\", &n) == 1 && n != 0) {\n        Team teams[10];\n        \n        for (int i = 0; i < n; i++) {\n            char name;\n            scanf(\" %c\", &name);\n            \n            teams[i].name = name;\n            teams[i].wins = 0;\n            teams[i].losses = 0;\n            teams[i].order = i;\n            \n            for (int j = 0; j < n - 1; j++) {\n                int result;\n                scanf(\"%d\", &result);\n                \n                if (result == 0) {\n                    teams[i].wins++;\n                } else if (result == 1) {\n                    teams[i].losses++;\n                }\n            }\n        }\n        \n        qsort(teams, n, sizeof(Team), compare);\n        \n        for (int i = 0; i < n; i++) {\n            printf(\"%c\\n\", teams[i].name);\n        }\n    }\n    \n    return 0;\n}\n", "perturbed_sampled": ["#include <stdio.h>    *)a; Team *tb = (Team *)b; if   (ta->losses != tb->losses)   int n; while  n  for (int i = 0; i < n; i++) { char  = name; teams[i].wins = 0; teams[i].losses = 0; teams[i].order = i; for (int j = 0; j < n - 1; j++)  {   sizeof(Team),  } } return 0; }"], "perturbed_original": [" Championship //  #include   p++; return *p++ - '0'; }   } T; T t[15]; int main() { int  tmp, *tp, *tt; while (1) {  break;   getStr(), tp->k = i, tp->w = tp->l = 0; for (j = 1;   == 0) tp->w++; else  } } for   (j = i+1,   (tt->w > tp->w) tp = tt;    (tt->l == tp->l &&  tt; } } if (tp != t  sizeof(tmp)); memcpy(t+i, tp, sizeof(tmp)); memcpy(tp, &tmp, sizeof(tmp)); } } for   return 0; }"], "original_ll": -0.9839844703674316, "sampled_ll": -0.42950037121772766, "all_perturbed_sampled_ll": [-2.487051486968994], "all_perturbed_original_ll": [-2.8894710540771484], "perturbed_sampled_ll": -2.487051486968994, "perturbed_original_ll": -2.8894710540771484, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "\nimport java.io.*;\nimport java.util.*;\n\n\n// 2011/10/23\n\n// 0196 \u0096\u00ec\u008b\u0085\u0091\u00e5\u0089\u00ef\npublic class Main {\n\t\n\t\n\tclass Team implements Comparable<Team> {\n\t\tString name;\n\t\tint win;\n\t\tint lose;\n\t\tpublic Team(String name, int win, int lose) {\n\t\t\tthis.name = name;\n\t\t\tthis.win = win;\n\t\t\tthis.lose = lose;\n\t\t}\n\t\t@Override\n\t\tpublic int compareTo(Team o) {\n\t\t\tif (win != o.win) {\n\t\t\t\treturn -(win - o.win);\n\t\t\t}\n\t\t\telse\n\t\t\t\treturn (lose - o.lose);\n\t\t}\n\t\t\n\t}\n\t\n\n\t// \u0083\u0081\u0083C\u0083\u0093 return false\u0082\u00c5\u0082\u00a8\u0082\u00b5\u0082\u00dc\u0082\u00a2\n\tboolean main() throws IOException {\n\n\t\tint n = readIntArray()[0];\n\t\tif (n == 0)\n\t\t\treturn false;\n\t\t\n\t\tList<Team> list = new ArrayList<Team>();\n\t\tfor(int i = 0; i < n; i++) {\n\t\t\tString s = reader.readLine();\n\t\t\tString[] sp = s.split(\" \");\n\t\t\t\n\t\t\tint win = 0;\n\t\t\tint lose = 0;\n\t\t\tfor(int j = 0; j < n - 1; j++) {\n\t\t\t\tString r = sp[j + 1];\n\t\t\t\tif (r.equals(\"0\")) {\n\t\t\t\t\twin++;\n\t\t\t\t}\n\t\t\t\telse if (r.equals(\"1\")) {\n\t\t\t\t\tlose++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tlist.add(new Team(sp[0], win, lose));\n\t\t}\t\n\t\t\n\t\tCollections.sort(list);\n\t\t\n\t\tfor(Team t: list) {\n\t\t\tSystem.out.printf(\"%s\\n\", t.name);\n\t\t}\n\t\t\n//\t\tSystem.out.printf(\"%d\\n\", sum / size);\n\t\t\n\t\treturn true; // \u0090\u00b3\u008f\u00ed\u008fI\u0097\u00b9 \u008e\u009f\u0082\u00d6\n\t}\n\t\n\n//\tprivate final static boolean DEBUG = true;  // debug\n\tprivate final static boolean DEBUG = false; // release\n\n\tpublic static void main(String[] args) throws IOException {\n\n\t\tif (DEBUG) {\n\t\t\tlog = System.out;\n\t\t\t\n\t\t\tString inputStr = \"1:15:\";\n\n\t\t\tinputStr = inputStr.replace(\":\", \"\\n\");\n\n\t\t\treader = new BufferedReader(new StringReader(inputStr)); \n\n\t\t}\n\t\telse {\n\t\t\tlog = new PrintStream(new OutputStream() { public void write(int b) {} } ); // \u008f\u0091\u0082\u00ab\u008e\u00cc\u0082\u00c4\n\t\t\treader = new BufferedReader(new InputStreamReader(System.in)); // \u0083R\u0083\u0093\u0083\\\u0081[\u0083\u008b\u0082\u00a9\u0082\u00e7\n\t\t}\n\t\t\n\t\tint N = Integer.MAX_VALUE;\n\t\t//int N = readIntArray()[0];\n\n\t\tfor(int i = 0; i < N; i++) {\n\t\t\tboolean b = new Main().main();\n\t\t\tif (!b)\n\t\t\t\tbreak;\n\t\t}\t\t\n\t\t\n\t\treader.close();\n\t}\n\n\t\n\tstatic PrintStream log;\n\tstatic BufferedReader reader;\n\t\n\n\t// \u0095W\u008f\u0080\u0093\u00fc\u0097\u00cd\u0082\u00e6\u0082\u00e81\u008ds\u0095\u00aa\u0082\u00cc\u008b\u00e6\u0090\u00d8\u0082\u00e8\u0095\u00b6\u008e\u009a\u008b\u00e6\u0090\u00d8\u0082\u00e8\u0082\u00c5\u0082\u00cc\u0090\u00ae\u0090\u0094\u0092l\u0082\u00f0\u0093\u00c7\u0082\u00de\n\t// EOF\u0082\u00cc\u008f\u00ea\u008d\u0087\u0082\u00cdnull\u0082\u00f0\u0095\u00d4\u0082\u00b7\n\tprivate static int[] readIntArray() throws IOException {\n\n\t\tString s = null;\n\t\tfor(;;) {\n\t\t\ts = reader.readLine();\n//\t\t\tlog.printf(\"%s\\n\", s);\n\t\t\tif (s == null)\n\t\t\t\treturn null;\n\t\t\ts = s.trim();\n\t\t\tif (s.length() != 0) // \u0081\u00a6\u0081\u00a6\u0081\u00a6\u0081@\u0082\u00c7\u0082\u00a4\u0082\u00e0\u0093\u00cb\u0091R\u008b\u00f3\u008ds\u0082\u00f0\u0093\u00c7\u0082\u00de\u0082\u00b1\u0082\u00c6\u0082\u00aa\u0082\u00a0\u0082\u00e9\u0081B\u0093\u00c7\u0082\u00dd\u0094\u00f2\u0082\u00ce\u0082\u00b7\u0082\u00c6\u0082\u00a4\u0082\u00dc\u0082\u00ad\u0082\u00a2\u0082\u00ad\u0082\u00e7\u0082\u00b5\u0082\u00a2\u0081B\u0081B\u0081B\u0081B\n\t\t\t\tbreak;\n\t\t}\n\t\t\n\t\tString[] sp = s.split(\"[ ,]\"); // \u008b\u00e6\u0090\u00d8\u0082\u00e8\u0095\u00b6\u008e\u009a\u0082\u00cd\u0083X\u0083y\u0081[\u0083X\u0082\u00a9\u0083J\u0083\u0093\u0083}\n\t\tint[] a = new int[sp.length];\n\t\tfor(int i = 0; i < sp.length; i++) {\n\t\t\ta[i] = Integer.parseInt(sp[i]);\n\t\t}\n\t\treturn a;\n\t}\n\t\t\n}", "sampled": "import java.util.*;\n\npublic class Main {\n    static class Team {\n        String name;\n        int wins;\n        int losses;\n        int order;\n        \n        Team(String name, int wins, int losses, int order) {\n            this.name = name;\n            this.wins = wins;\n            this.losses = losses;\n            this.order = order;\n        }\n    }\n    \n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        \n        while (true) {\n            int n = sc.nextInt();\n            if (n == 0) break;\n            \n            List<Team> teams = new ArrayList<>();\n            \n            for (int i = 0; i < n; i++) {\n                String teamName = sc.next();\n                int wins = 0;\n                int losses = 0;\n                \n                for (int j = 0; j < n - 1; j++) {\n                    int result = sc.nextInt();\n                    if (result == 0) {\n                        wins++;\n                    } else if (result == 1) {\n                        losses++;\n                    }\n                }\n                \n                teams.add(new Team(teamName, wins, losses, i));\n            }\n            \n            Collections.sort(teams, new Comparator<Team>() {\n                @Override\n                public int compare(Team t1, Team t2) {\n                    if (t1.wins != t2.wins) {\n                        return t2.wins - t1.wins;\n                    }\n                    if (t1.losses != t2.losses) {\n                        return t1.losses - t2.losses;\n                    }\n                    return t1.order - t2.order;\n                }\n            });\n            \n            for (Team team : teams) {\n                System.out.println(team.name);\n            }\n        }\n        \n        sc.close();\n    }\n}\n", "perturbed_sampled": ["import java.util.*; public class Main { static class Team { String name; int  = losses; this.order =  Scanner sc = new Scanner(System.in); while (true) { int n = sc.nextInt(); if (n == 0) break; List<Team> teams = new  0;  String teamName    result  0) { wins++; }  t2) {  return t2.wins  t1.losses - t2.losses; } return t1.order - t2.order; } }); for (Team team : teams) {  }"], "perturbed_original": ["import java.io.*; import java.util.*; // 2011/10/23 // 0196  {  String name; int win; int  win,  @Override public int  \u0083\u0081\u0083C\u0083\u0093 return false\u0082\u00c5\u0082\u00a8\u0082\u00b5\u0082\u00dc\u0082\u00a2 boolean main() throws IOException { int  List<Team> list = new ArrayList<Team>();  < n; i++)  String[] sp  =  j <  { win++; } else if   //  true; //  final static boolean DEBUG =  throws IOException { if  String inputStr = \"1:15:\"; inputStr = inputStr.replace(\":\",  StringReader(inputStr)); } else { log = new PrintStream(new OutputStream() { public void  // \u008f\u0091\u0082\u00ab\u008e\u00cc\u0082\u00c4 reader = new BufferedReader(new InputStreamReader(System.in)); // \u0083R\u0083\u0093\u0083\\\u0081[\u0083\u008b\u0082\u00a9\u0082\u00e7 } int N = Integer.MAX_VALUE; //int N = readIntArray()[0]; for(int i =  new Main().main(); if (!b) break; }  IOException  for(;;) {  s); if  String[] sp  int[] a  = 0; i < sp.length; i++) { a[i] = Integer.parseInt(sp[i]); } return a; } }"], "original_ll": -1.6692527532577515, "sampled_ll": -0.32606762647628784, "all_perturbed_sampled_ll": [-2.6672468185424805], "all_perturbed_original_ll": [-3.190633535385132], "perturbed_sampled_ll": -2.6672468185424805, "perturbed_original_ll": -3.190633535385132, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "while True:\n    n = int(raw_input())\n    if n == 0: break\n    ans = [[0]*4 for i in range(n)]\n    for i in range(n):\n        line = raw_input().split()\n        ans[i][2] = -i\n        ans[i][3] = line[0]\n        for c in line[1:]:\n            if c == '0':\n                ans[i][0] += 1\n            elif c == '1':\n                ans[i][1] -= 1\n    for a in sorted(ans, key=lambda x: (x[0], x[1], x[2]), reverse=True):\n        print a[3]", "sampled": "while True:\n    n = int(input())\n    if n == 0:\n        break\n    \n    teams = []\n    for i in range(n):\n        line = input().split()\n        name = line[0]\n        results = list(map(int, line[1:]))\n        \n        wins = results.count(0)\n        losses = results.count(1)\n        \n        teams.append((name, wins, losses, i))\n    \n    # Sort by wins (descending), then losses (ascending), then input order (ascending)\n    teams.sort(key=lambda x: (-x[1], x[2], x[3]))\n    \n    for team in teams:\n        print(team[0])\n", "perturbed_sampled": ["while True:   = list(map(int, line[1:])) wins = results.count(0) losses  i))  input order (ascending) teams.sort(key=lambda x: (-x[1], x[2], x[3])) for team in teams: print(team[0])"], "perturbed_original": ["while True: n =  break ans = [[0]*4  =   '0': ans[i][0] += 1 elif c   x: (x[0], x[1], x[2]), reverse=True): print a[3]"], "original_ll": -0.9418922662734985, "sampled_ll": -0.876808762550354, "all_perturbed_sampled_ll": [-3.3022403717041016], "all_perturbed_original_ll": [-4.055049419403076], "perturbed_sampled_ll": -3.3022403717041016, "perturbed_original_ll": -4.055049419403076, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "#include <stdio.h>\nint main(void)\n{    \n    int a, b, r;\n    int count = 1;\n        \n    while(scanf(\"%d %d\", &a, &b) != EOF)\n    {     \n        if(a == 0 && b == 0)\n        {        \n            break;\n        }\n        \n        r = a % b;        \n        while(r!=0){            \n            a = b;            \n            b = r;            \n            r = a % b;            \n            count++;  \n            \n            \n        }\n        printf(\"%d %d\\n\",b,count);\n    }        \n      \n    return(0);\n    \n}\n", "sampled": "#include <stdio.h>\n\nint main() {\n    long long a, b;\n    \n    while (1) {\n        scanf(\"%lld %lld\", &a, &b);\n        \n        if (a == 0 && b == 0) {\n            break;\n        }\n        \n        long long x = a;\n        long long y = b;\n        int steps = 0;\n        long long temp;\n        \n        while (y != 0) {\n            temp = x % y;\n            x = y;\n            y = temp;\n            steps++;\n        }\n        \n        printf(\"%lld %d\\n\", x, steps);\n    }\n    \n    return 0;\n}\n", "perturbed_sampled": [" long long a, b; while (1) { scanf(\"%lld %lld\", &a,  && b == 0) { break; } long long x =  b;  != 0) {  } return 0; }"], "perturbed_original": ["#include <stdio.h>   1; while(scanf(\"%d %d\", &a, &b) != EOF) { if(a == 0 && b == 0)  a  b;  return(0); }"], "original_ll": -1.2448683977127075, "sampled_ll": -0.5486181974411011, "all_perturbed_sampled_ll": [-2.638939619064331], "all_perturbed_original_ll": [-2.295257091522217], "perturbed_sampled_ll": -2.638939619064331, "perturbed_original_ll": -2.295257091522217, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import java.util.*;\npublic class Main {\n \n         \n        public static void main(String[] args) throws java.io.IOException{\n            Scanner scan = new Scanner(System.in);\n            while(true){\n                int a =scan.nextInt();\n                int b = scan.nextInt();\n                if((a|b)==0)break;\n                if(b>a){\n                    a=a^b;\n                    b=a^b;\n                    a=a^b;\n                }\n                int c=0;\n                while(b!=0){\n                    a=a%b;\n                    a=a^b;\n                    b=a^b;\n                    a=a^b;\n                    c++;\n                }\n                System.out.println(a+\" \"+c);\n            }\n  \n        }\n   \n}", "sampled": "import java.util.Scanner;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        \n        while (true) {\n            long a = sc.nextLong();\n            long b = sc.nextLong();\n            \n            if (a == 0 && b == 0) {\n                break;\n            }\n            \n            long x = a;\n            long y = b;\n            int steps = 0;\n            \n            while (y != 0) {\n                long temp = x % y;\n                x = y;\n                y = temp;\n                steps++;\n            }\n            \n            System.out.println(x + \" \" + steps);\n        }\n        \n        sc.close();\n    }\n}\n", "perturbed_sampled": ["import java.util.Scanner;   Scanner(System.in); while  sc.nextLong(); long  == 0  break; } long x =  int steps = 0;  long temp  = y; y = temp; steps++;   }"], "perturbed_original": ["import java.util.*;  throws java.io.IOException{  a=a^b; } int c=0; while(b!=0){ a=a%b; a=a^b; b=a^b; a=a^b; c++; } System.out.println(a+\" \"+c); } } }"], "original_ll": -1.0985480546951294, "sampled_ll": -0.4532148838043213, "all_perturbed_sampled_ll": [-3.4506313800811768], "all_perturbed_original_ll": [-1.8515437841415405], "perturbed_sampled_ll": -3.4506313800811768, "perturbed_original_ll": -1.8515437841415405, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import sys\ndef f(d,x,y):\n    t = x % y\n    x = y\n    y = t\n    if y != 0:\n        return f(d+1,x,y)\n    else:\n        return (x,d+1)\n\nwhile 1:\n    y,x = sorted(list(map(int, input().split())))\n    if x == 0: break\n    ans = f(0,x,y)\n    print(ans[0],ans[1])\n\n\n", "sampled": "while True:\n    a, b = map(int, input().split())\n    if a == 0 and b == 0:\n        break\n    \n    x, y = a, b\n    steps = 0\n    \n    while y != 0:\n        remainder = x % y\n        x = remainder\n        x, y = y, x\n        steps += 1\n    \n    print(x, steps)\n", "perturbed_sampled": ["while True: a, b  == 0  x, y = a, b steps = 0  y  1 print(x, steps)"], "perturbed_original": ["import sys def  y x = y  else: return (x,d+1) while 1: y,x  = f(0,x,y) print(ans[0],ans[1])"], "original_ll": -1.4383140802383423, "sampled_ll": -0.9032934904098511, "all_perturbed_sampled_ll": [-3.456641435623169], "all_perturbed_original_ll": [-3.494447708129883], "perturbed_sampled_ll": -3.456641435623169, "perturbed_original_ll": -3.494447708129883, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "#include<stdio.h>\nint main(void)\n{\n\tint n,i,j,z;\n\tchar c1[1001],c2[1001],c3[1001],c4[1001],c5[1001],c6[1001];\n\twhile(n!=0){\n\tscanf(\"%d\",&n);\n\tfor(i=0;i<n;i++){\n\t\tscanf(\"%s %s %s %s %s %s\",&c1[i],&c2[i],&c3[i],&c4[i],&c5[i],&c6[i]);\n\t}\n\tfor(i=0;i<n;i++){\n\t\tz=0;\n\t\tfor(j=0;j<n;j++){\n\t\tif(c1[i]==c1[j] && c2[i]==c2[j] && c3[i]==c3[j] && c4[i]==c4[j] && c5[i]==c5[j] && c6[i]==c6[j]){\n\t\t\tz=z+1;\n\t\t}\n\t\telse if(c4[i]==c4[j] && c1[i]==c1[j] && c3[i]==c3[j] && c6[i]==c6[j]){\n\t\t\tif(c5[i]==c5[j] && c2[i]==c2[j]){\n\t\t\t\tz=z+1;\n\t\t\t}\n\t\t}\n\t\telse if(c4[i]==c6[j] && c1[i]==c3[j] && c3[i]==c1[j] && c6[i]==c4[j]){\n\t\t\tif(c5[i]==c2[j] && c2[i]==c5[j]){\n\t\t\t\tz=z+1;\n\t\t\t}\n\t\t}\n\t\telse if(c6[i]==c6[j] && c3[i]==c3[j] && c1[i]==c1[j] && c4[i]==c4[j]){\n\t\t\tif(c5[i]==c5[j] && c2[i]==c2[j]){\n\t\t\t\tz=z+1;\n\t\t\t}\n\t\t}\n\t\telse if(c6[i]==c4[j] && c3[i]==c1[j] && c1[i]==c3[j] && c4[i]==c6[j]){\n\t\t\tif(c2[i]==c5[j] && c5[i]==c2[j]){\n\t\t\t\tz=z+1;\n\t\t\t}\n\t\t}\n\t\telse if(c2[i]==c2[j] && c1[i]==c1[j] && c5[i]==c5[j] && c6[i]==c6[j]){\n\t\t\tif(c4[i]==c4[j] && c3[i]==c3[j]){\n\t\t\t\tz=z+1;\n\t\t\t}\n\t\t}\n\t\telse if(c2[i]==c6[j] && c1[i]==c5[j] && c5[i]==c1[j] && c6[i]==c2[j]){\n\t\t\tif(c4[i]==c3[j] && c3[i]==c4[j]){\n\t\t\t\tz=z+1;\n\t\t\t}\n\t\t}\n\t\telse if(c6[i]==c6[j] && c5[i]==c5[j] && c1[i]==c1[j] && c2[i]==c2[j]){\n\t\t\tif(c3[i]==c3[j] && c4[i]==c4[j]){\n\t\t\t\tz=z+1;\n\t\t\t}\n\t\t}\n\t\telse if(c6[i]==c2[j] && c5[i]==c1[j] && c1[i]==c5[j] && c2[i]==c6[j]){\n\t\t\tif(c3[i]==c4[j] && c4[i]==c3[j]){\n\t\t\t\tz=z+1;\n\t\t\t}\n\t\t}\n\t\t}\n\t}\n\tprintf(\"%d\\n\",n);\n\tscanf(\"%d\",&n);\n\t}\n\treturn 0;\n}", "sampled": "#include <stdio.h>\n#include <string.h>\n\ntypedef struct {\n    char faces[6][10];\n} Cube;\n\nvoid rotateCube(Cube *c, Cube *result, int rotation) {\n    // 24 rotations of a cube\n    int rotations[24][6] = {\n        {0,1,2,3,4,5}, {0,2,4,1,3,5}, {0,3,1,4,2,5}, {0,4,3,2,1,5},\n        {1,0,3,2,5,4}, {1,2,0,5,3,4}, {1,3,5,0,2,4}, {1,5,2,3,0,4},\n        {2,0,1,4,5,3}, {2,1,5,0,4,3}, {2,4,0,5,1,3}, {2,5,4,1,0,3},\n        {3,0,4,1,5,2}, {3,1,0,5,4,2}, {3,4,5,0,1,2}, {3,5,1,4,0,2},\n        {4,0,2,3,5,1}, {4,2,5,0,3,1}, {4,3,0,5,2,1}, {4,5,3,2,0,1},\n        {5,1,3,2,4,0}, {5,2,1,4,3,0}, {5,3,4,1,2,0}, {5,4,2,3,1,0}\n    };\n    \n    for (int i = 0; i < 6; i++) {\n        strcpy(result->faces[i], c->faces[rotations[rotation][i]]);\n    }\n}\n\nint compareCubes(Cube *c1, Cube *c2) {\n    for (int i = 0; i < 6; i++) {\n        int cmp = strcmp(c1->faces[i], c2->faces[i]);\n        if (cmp != 0) return cmp;\n    }\n    return 0;\n}\n\nint areSameCube(Cube *c1, Cube *c2) {\n    Cube rotated;\n    for (int r = 0; r < 24; r++) {\n        rotateCube(c1, &rotated, r);\n        if (compareCubes(&rotated, c2) == 0) {\n            return 1;\n        }\n    }\n    return 0;\n}\n\nint main() {\n    int n;\n    while (scanf(\"%d\", &n) == 1 && n != 0) {\n        Cube cubes[30];\n        \n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < 6; j++) {\n                scanf(\"%s\", cubes[i].faces[j]);\n            }\n        }\n        \n        int unique[30];\n        int uniqueCount = 0;\n        \n        for (int i = 0; i < n; i++) {\n            int isUnique = 1;\n            for (int j = 0; j < uniqueCount; j++) {\n                if (areSameCube(&cubes[i], &cubes[unique[j]])) {\n                    isUnique = 0;\n                    break;\n                }\n            }\n            if (isUnique) {\n                unique[uniqueCount++] = i;\n            }\n        }\n        \n        printf(\"%d\\n\", n - uniqueCount);\n    }\n    \n    return 0;\n}\n", "perturbed_sampled": ["#include    {2,5,4,1,0,3}, {3,0,4,1,5,2}, {3,1,0,5,4,2},  {5,4,2,3,1,0} }; for (int i = 0; i  c->faces[rotations[rotation][i]]); } } int  for (int i = 0; i <  = strcmp(c1->faces[i], c2->faces[i]); if (cmp != 0) return   { rotateCube(c1, &rotated, r);  } return  int n; while (scanf(\"%d\", &n) == 1 && n != 0)  i =  = 0; j < 6;   = 0; for (int  n; i++) { int isUnique = 1; for (int  (areSameCube(&cubes[i], &cubes[unique[j]]))  } }  i; } } printf(\"%d\\n\", n - uniqueCount); } return 0; }"], "perturbed_original": ["#include<stdio.h> int main(void) { int n,i,j,z;  scanf(\"%s %s %s %s %s %s\",&c1[i],&c2[i],&c3[i],&c4[i],&c5[i],&c6[i]); } for(i=0;i<n;i++){ z=0; for(j=0;j<n;j++){ if(c1[i]==c1[j] && c2[i]==c2[j] && c3[i]==c3[j] && c4[i]==c4[j]  c1[i]==c1[j] && c3[i]==c3[j] && c6[i]==c6[j]){    c1[i]==c1[j] && c5[i]==c5[j] && c6[i]==c6[j]){   if(c4[i]==c3[j] && c3[i]==c4[j]){ z=z+1; } } else if(c6[i]==c6[j]  c2[i]==c2[j]){ if(c3[i]==c3[j] && c4[i]==c4[j]){ z=z+1; } } else if(c6[i]==c2[j] && c5[i]==c1[j] && c1[i]==c5[j] && c2[i]==c6[j]){  }  return 0; }"], "original_ll": -0.386676549911499, "sampled_ll": -0.5065474510192871, "all_perturbed_sampled_ll": [-2.325082302093506], "all_perturbed_original_ll": [-0.9715247750282288], "perturbed_sampled_ll": -2.325082302093506, "perturbed_original_ll": -0.9715247750282288, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import java.util.*;\n\npublic class Main{\n\n    ArrayList<char[]> color,list;\n    ArrayList<String> clist;\n\n    void solve(){\n        Scanner sc = new Scanner(System.in);\n\n        clist = new ArrayList<String>();\n        clist.add(\"Red\");\n        clist.add(\"Yellow\");\n        clist.add(\"Blue\");\n        clist.add(\"Magenta\");\n        clist.add(\"Green\");\n        clist.add(\"Cyan\");\n\n        while(true){\n            int n = sc.nextInt();\n            if(n==0) break;\n\n            color = new ArrayList<char[]>();\n            int cnt = 0;\n            for(int i=0; i<n; i++){\n                char[] c = new char[6];\n                for(int j=0; j<6; j++) c[j] = (char)clist.indexOf(sc.next());\n                if(same(c)) cnt++;\n                else color.add(c);\n            }\n\n            System.out.println(cnt);\n        }\n    }\n\n    int[][] rotate = {{1,2,4,3},{0,4,5,1},{0,2,5,3}};\n\n    boolean same(char[] dice){\n        list = new ArrayList<char[]>();\n        for(int i=0; i<4; i++){\n            dice = rotate(dice,0);\n            for(int j=0; j<4; j++){\n                dice = rotate(dice,1);\n                for(int l=0; l<4; l++){\n                    dice = rotate(dice,2);\n                    list.add(dice);\n                }\n            }\n        }\n\n        for(int i=0; i<list.size(); i++){\n            char[] s1 = list.get(i);\n            for(int j=0; j<color.size(); j++){\n                boolean boo = false;\n                char[] s2 = color.get(j);\n                for(int k=0; k<6; k++){\n                    if(s1[k]!=s2[k]){\n                        boo = false;\n                        break;\n                    }\n                    boo = true;\n                }\n                if(boo) return true;\n            }\n        }\n        return false;\n    }\n\n    char[] rotate(char[] dice, int idx){\n        char[] res = new char[6];\n        for(int i=0; i<6; i++) res[i] = dice[i];\n\n        char tmp = res[rotate[idx][3]];\n        for(int i=3; i>0; i--) res[rotate[idx][i]] = res[rotate[idx][i-1]];\n        res[rotate[idx][0]] = tmp;\n        return res;\n    }\n\n    public static void main(String[] args){\n        new Main().solve();\n    }\n}", "sampled": "import java.util.*;\n\npublic class Main {\n    static class Cube {\n        String[] faces = new String[6];\n        \n        Cube(String[] f) {\n            faces = f.clone();\n        }\n        \n        // Generate all 24 rotations of the cube\n        List<String> getAllRotations() {\n            Set<String> rotations = new HashSet<>();\n            \n            // All 24 orientations of a cube\n            int[][] orientations = {\n                {0,1,2,3,4,5}, {0,2,4,1,3,5}, {0,3,1,4,2,5}, {0,4,3,2,1,5},\n                {1,0,3,2,5,4}, {1,2,0,5,3,4}, {1,3,5,0,2,4}, {1,5,2,3,0,4},\n                {2,0,1,4,5,3}, {2,1,5,0,4,3}, {2,4,0,5,1,3}, {2,5,4,1,0,3},\n                {3,0,4,1,5,2}, {3,1,0,5,4,2}, {3,4,5,0,1,2}, {3,5,1,4,0,2},\n                {4,0,2,3,5,1}, {4,2,5,0,3,1}, {4,3,0,5,2,1}, {4,5,3,2,0,1},\n                {5,1,3,2,4,0}, {5,2,1,4,3,0}, {5,3,4,1,2,0}, {5,4,2,3,1,0}\n            };\n            \n            for (int[] orient : orientations) {\n                StringBuilder sb = new StringBuilder();\n                for (int i = 0; i < 6; i++) {\n                    if (i > 0) sb.append(\" \");\n                    sb.append(faces[orient[i]]);\n                }\n                rotations.add(sb.toString());\n            }\n            \n            return new ArrayList<>(rotations);\n        }\n        \n        String getCanonical() {\n            List<String> rotations = getAllRotations();\n            Collections.sort(rotations);\n            return rotations.get(0);\n        }\n    }\n    \n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        \n        while (true) {\n            int n = sc.nextInt();\n            if (n == 0) break;\n            sc.nextLine();\n            \n            Set<String> uniqueCubes = new HashSet<>();\n            \n            for (int i = 0; i < n; i++) {\n                String[] colors = sc.nextLine().split(\" \");\n                Cube cube = new Cube(colors);\n                String canonical = cube.getCanonical();\n                uniqueCubes.add(canonical);\n            }\n            \n            int needed = n - uniqueCubes.size();\n            System.out.println(needed);\n        }\n        \n        sc.close();\n    }\n}\n", "perturbed_sampled": ["import java.util.*;   all 24  getAllRotations() { Set<String> rotations  24 orientations of  { {0,1,2,3,4,5}, {0,2,4,1,3,5}, {0,3,1,4,2,5}, {0,4,3,2,1,5},   {4,3,0,5,2,1},  };  { StringBuilder sb = new StringBuilder(); for (int i = 0; i  (i > 0) sb.append(\" \"); sb.append(faces[orient[i]]); } rotations.add(sb.toString()); } return  { List<String> rotations = getAllRotations(); Collections.sort(rotations);  static void  = new Scanner(System.in); while (true) { int   i++)  \"); Cube cube  =  =  sc.close(); } }"], "perturbed_original": ["import java.util.*; public class Main{ ArrayList<char[]> color,list; ArrayList<String> clist; void solve(){ Scanner sc = new   j++) c[j] = (char)clist.indexOf(sc.next()); if(same(c)) cnt++; else color.add(c); } System.out.println(cnt);  {{1,2,4,3},{0,4,5,1},{0,2,5,3}}; boolean same(char[] dice){ list = new ArrayList<char[]>();  =  l=0; l<4; l++){ dice = rotate(dice,2); list.add(dice); } } } for(int  j<color.size(); j++){ boolean boo = false; char[] s2 = color.get(j); for(int k=0; k<6; k++){ if(s1[k]!=s2[k]){ boo = false; break; }   dice, int idx){    Main().solve(); } }"], "original_ll": -0.8817908763885498, "sampled_ll": -0.5371676087379456, "all_perturbed_sampled_ll": [-2.166029691696167], "all_perturbed_original_ll": [-2.7991480827331543], "perturbed_sampled_ll": -2.166029691696167, "perturbed_original_ll": -2.7991480827331543, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "def equal(B):\n    temp=B[:]\n    S=set()\n    for i in range(4):\n        for j in range(4):\n            for k in range(4):\n                roll(0,2,5,3,temp)\n                S.add(tuple(temp))\n            roll(0,1,5,4,temp)\n        roll(1,2,4,3,temp)\n    return S\n\ndef roll(i,j,k,l,temp):\n    t=temp[i]\n    temp[i]=temp[j]\n    temp[j]=temp[k]\n    temp[k]=temp[l]\n    temp[l]=t\n\nwhile True:\n    n=input()\n    if n==0:break\n    L=[raw_input().split() for i in range(n)]\n    cnt=0\n    for i in range(n-1):\n        for j in range(i+1,n):\n            S=equal(L[j])\n            if tuple(L[i]) in S:\n                cnt+=1\n    print cnt", "sampled": "def normalize_cube(colors):\n    # Colors: [top, front, right, left, back, bottom]\n    # Indices:  0     1      2     3     4      5\n    \n    # Generate all 24 orientations of the cube\n    orientations = []\n    \n    # Original orientation\n    c = colors\n    \n    # All 24 rotations of a cube\n    # 4 rotations with each of the 6 faces as top\n    \n    def rotate_x(cube):\n        # Rotate around x-axis (right face axis) by 90 degrees\n        return [cube[1], cube[5], cube[2], cube[3], cube[0], cube[4]]\n    \n    def rotate_y(cube):\n        # Rotate around y-axis (top face axis) by 90 degrees\n        return [cube[0], cube[2], cube[4], cube[1], cube[3], cube[5]]\n    \n    def rotate_z(cube):\n        # Rotate around z-axis (front face axis) by 90 degrees\n        return [cube[3], cube[1], cube[0], cube[5], cube[4], cube[2]]\n    \n    # Generate all 24 orientations\n    current = colors[:]\n    \n    for _ in range(4):\n        orientations.append(tuple(current))\n        for _ in range(3):\n            current = rotate_z(current)\n            orientations.append(tuple(current))\n        current = rotate_y(current)\n    \n    current = rotate_x(colors[:])\n    for _ in range(3):\n        current = rotate_z(current)\n        orientations.append(tuple(current))\n    \n    current = rotate_x(rotate_x(rotate_x(colors[:])))\n    for _ in range(3):\n        current = rotate_z(current)\n        orientations.append(tuple(current))\n    \n    # Return the lexicographically smallest orientation\n    return min(orientations)\n\ndef get_all_orientations(colors):\n    orientations = set()\n    \n    def rotate_x(cube):\n        return [cube[1], cube[5], cube[2], cube[3], cube[0], cube[4]]\n    \n    def rotate_y(cube):\n        return [cube[0], cube[2], cube[4], cube[1], cube[3], cube[5]]\n    \n    def rotate_z(cube):\n        return [cube[3], cube[1], cube[0], cube[5], cube[4], cube[2]]\n    \n    current = colors[:]\n    for _ in range(4):\n        orientations.add(tuple(current))\n        for _ in range(3):\n            current = rotate_z(current)\n            orientations.add(tuple(current))\n        current = rotate_y(current)\n    \n    current = rotate_x(colors[:])\n    for _ in range(3):\n        current = rotate_z(current)\n        orientations.add(tuple(current))\n    \n    current = rotate_x(rotate_x(rotate_x(colors[:])))\n    for _ in range(3):\n        current = rotate_z(current)\n        orientations.add(tuple(current))\n    \n    return orientations\n\nwhile True:\n    n = int(input())\n    if n == 0:\n        break\n    \n    cubes = []\n    for _ in range(n):\n        colors = input().split()\n        cubes.append(colors)\n    \n    unique_cubes = set()\n    \n    for cube in cubes:\n        canonical = normalize_cube(cube)\n        unique_cubes.add(canonical)\n    \n    needed = n - len(unique_cubes)\n    print(needed)\n", "perturbed_sampled": ["def normalize_cube(colors): #  back, bottom] #  the cube orientations = [] # Original  All  # 4  6  (right face  [cube[1],  around y-axis (top face axis) by   by 90   = colors[:] for _ in range(4):  current = rotate_z(current) orientations.append(tuple(current))  range(3): current =  for _ in range(3): current = rotate_z(current) orientations.append(tuple(current)) # Return   set() def rotate_x(cube): return  cube[4]] def rotate_y(cube): return  cube[5]]   = colors[:]  for _ in range(3): current = rotate_z(current) orientations.add(tuple(current)) current = rotate_y(current) current = rotate_x(colors[:]) for _ in range(3): current  break cubes = [] for _ in range(n): colors  set() for  normalize_cube(cube) unique_cubes.add(canonical) needed = n - len(unique_cubes) print(needed)"], "perturbed_original": ["def equal(B): temp=B[:]  for k in range(4): roll(0,2,5,3,temp) S.add(tuple(temp)) roll(0,1,5,4,temp) roll(1,2,4,3,temp) return S def roll(i,j,k,l,temp):    cnt=0 for  in range(i+1,n):  cnt+=1 print cnt"], "original_ll": -1.2207125425338745, "sampled_ll": -0.7497959733009338, "all_perturbed_sampled_ll": [-3.2396678924560547], "all_perturbed_original_ll": [-2.6837477684020996], "perturbed_sampled_ll": -3.2396678924560547, "perturbed_original_ll": -2.6837477684020996, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "n,m,p;\nchar s[2],c[101];\nA(){\n\tfor(p=0;c[p]!='#';p++);\n}\nB(){\n\tfor(p=n-1;p>=0;p--)\n\t\tif(c[p]=='#'&&(p+1==n||c[p+1]!='A')&&(p-1<0||c[p-1]!='A'))\n\t\t\treturn;\n\tA();\n}\nC(){\n\tfor(p=0;p<n;p++){\n\t\tif(c[p]!='#'){\n\t\t\tif(p+1!=n&&c[p+1]=='#'){\n\t\t\t\tp++;\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif(p-1>=0&&c[p-1]=='#'){\n\t\t\t\tp--;\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t}\n\tp=n/2;\n}\nD(){\n\tint D[100],d=n,q;\n\tfor(p=-1;++p<n;){\n\t\td++;\n\t\tif(c[p]!='#')\n\t\t\td=0;\n\t\tD[p]=d;\n\t}\n\tfor(d=0;--p>=0;){\n\t\td++;\n\t\tif(c[p]!='#')\n\t\t\td=0;\n\t\tif(d<D[p])\n\t\t\tD[p]=d;\n\t}\n\tfor(p=q=0;q<n;q++)\n\t\tif(D[q]>D[p])\n\t\t\tp=q;\n}\nmain(){\n\tfor(;scanf(\"%d%d\",&n,&m),n;){\n\t\tmemset(c,'#',100);\n\t\tc[n]=0;\n\t\tfor(;m--;){\n\t\t\tscanf(\"%s\",s);\n\t\t\tif(s[0]=='A')\n\t\t\t\tA();\n\t\t\tif(s[0]=='B')\n\t\t\t\tB();\n\t\t\tif(s[0]=='C')\n\t\t\t\tC();\n\t\t\tif(s[0]=='D')\n\t\t\t\tD();\n\t\t\tc[p]=s[0];\n\t\t}\n\t\tputs(c);\n\t}\n\texit(0);\n}", "sampled": "#include <stdio.h>\n#include <string.h>\n\nint main() {\n    int n, m;\n    \n    while(1) {\n        scanf(\"%d %d\", &n, &m);\n        if(n == 0 && m == 0) break;\n        \n        char seats[101];\n        for(int i = 0; i < n; i++) {\n            seats[i] = '#';\n        }\n        \n        for(int i = 0; i < m; i++) {\n            char type;\n            scanf(\" %c\", &type);\n            \n            if(type == 'A') {\n                // Left to right, first empty seat\n                for(int j = 0; j < n; j++) {\n                    if(seats[j] == '#') {\n                        seats[j] = 'A';\n                        break;\n                    }\n                }\n            }\n            else if(type == 'B') {\n                // Right to left, not next to A\n                int pos = -1;\n                for(int j = n-1; j >= 0; j--) {\n                    if(seats[j] == '#') {\n                        int nextToA = 0;\n                        if(j > 0 && seats[j-1] == 'A') nextToA = 1;\n                        if(j < n-1 && seats[j+1] == 'A') nextToA = 1;\n                        if(!nextToA) {\n                            pos = j;\n                            break;\n                        }\n                    }\n                }\n                if(pos == -1) {\n                    // All empty seats are next to A, take leftmost empty\n                    for(int j = 0; j < n; j++) {\n                        if(seats[j] == '#') {\n                            pos = j;\n                            break;\n                        }\n                    }\n                }\n                seats[pos] = 'B';\n            }\n            else if(type == 'C') {\n                // Next to someone, prefer right then left of leftmost person\n                int hasAnyone = 0;\n                for(int j = 0; j < n; j++) {\n                    if(seats[j] != '#') {\n                        hasAnyone = 1;\n                        break;\n                    }\n                }\n                \n                if(!hasAnyone) {\n                    // Sit in middle\n                    int mid = (n % 2 == 1) ? (n+1)/2 - 1 : n/2;\n                    seats[mid] = 'C';\n                } else {\n                    int pos = -1;\n                    for(int j = 0; j < n; j++) {\n                        if(seats[j] != '#') {\n                            if(j+1 < n && seats[j+1] == '#') {\n                                pos = j+1;\n                                break;\n                            } else if(j-1 >= 0 && seats[j-1] == '#') {\n                                pos = j-1;\n                                break;\n                            }\n                        }\n                    }\n                    seats[pos] = 'C';\n                }\n            }\n            else if(type == 'D') {\n                // Maximize minimum distance to nearest person\n                int hasAnyone = 0;\n                for(int j = 0; j < n; j++) {\n                    if(seats[j] != '#') {\n                        hasAnyone = 1;\n                        break;\n                    }\n                }\n                \n                if(!hasAnyone) {\n                    seats[0] = 'D';\n                } else {\n                    int bestPos = -1;\n                    int maxMinDist = -1;\n                    \n                    for(int j = 0; j < n; j++) {\n                        if(seats[j] == '#') {\n                            int minDist = n+1;\n                            for(int k = 0; k < n; k++) {\n                                if(seats[k] != '#') {\n                                    int dist = (j > k) ? (j - k) : (k - j);\n                                    if(dist < minDist) minDist = dist;\n                                }\n                            }\n                            if(minDist > maxMinDist) {\n                                maxMinDist = minDist;\n                                bestPos = j;\n                            }\n                        }\n                    }\n                    seats[bestPos] = 'D';\n                }\n            }\n        }\n        \n        for(int i = 0; i < n; i++) {\n            printf(\"%c\", seats[i]);\n        }\n        printf(\"\\n\");\n    }\n    \n    return 0;\n}\n", "perturbed_sampled": ["#include <stdio.h> #include <string.h> int main()  { scanf(\"%d %d\", &n,  m == 0)  n; i++) { seats[i] =  0; i < m; i++) { char type; scanf(\"  right, first empty seat for(int j = 0; j < n; j++) { if(seats[j] == '#') { seats[j]  } else if(type == 'B') { // Right  -1;  >= 0; j--)    seats[j+1] ==   All empty seats are next to A, take leftmost empty  if(seats[j] == '#') { pos =  else  Next  left  = 0; j <  '#') { hasAnyone = 1; break; } } if(!hasAnyone) {  mid =  ? (n+1)/2 - 1 : n/2; seats[mid] = 'C'; }  j++) { if(seats[j] != '#')   else if(j-1  '#') { pos = j-1; break; } }     = 0; j < n; j++)  = -1; for(int  n; j++)  for(int  n; k++) {  k)  (k  minDist  =  }  } } for(int i = 0; i < n; i++) { printf(\"%c\", seats[i]); } printf(\"\\n\"); } return 0; }"], "perturbed_original": ["n,m,p; char  if(p+1!=n&&c[p+1]=='#'){ p++; return; } if(p-1>=0&&c[p-1]=='#'){  d++; if(c[p]!='#') d=0; if(d<D[p]) D[p]=d; } for(p=q=0;q<n;q++) if(D[q]>D[p]) p=q; } main(){ for(;scanf(\"%d%d\",&n,&m),n;){ memset(c,'#',100);  if(s[0]=='D') D(); c[p]=s[0]; } puts(c); } exit(0); }"], "original_ll": -1.2072032690048218, "sampled_ll": -0.5393253564834595, "all_perturbed_sampled_ll": [-2.573535442352295], "all_perturbed_original_ll": [-2.600090742111206], "perturbed_sampled_ll": -2.573535442352295, "perturbed_original_ll": -2.600090742111206, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import java.util.*;\n\npublic class Main {\n\t\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\t\n\t\twhile(true){\n\t\t\tint n = sc.nextInt();\n\t\t\tint m = sc.nextInt();\n\t\t\tif(n==0 && m==0) break;\n\t\t\t\n\t\t\tchar[] a = new char[n+2];\n\t\t\tArrays.fill(a,'#');\n\t\t\ta[0] = 'X';\n\t\t\ta[n+1] = 'X';\n\t\t\tfor(int i=0;i<m;i++){\n\t\t\t\tchar c = sc.next().charAt(0);\n\t\t\t\tif(c=='A'){\n\t\t\t\t\tfor(int j=1;j<=n;j++){\n\t\t\t\t\t\tif(a[j]=='#'){\n\t\t\t\t\t\t\ta[j] = c;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}else if(c=='B'){\n\t\t\t\t\tboolean flag = true;\n\t\t\t\t\tfor(int j=n;j>0;j--){\n\t\t\t\t\t\tif(a[j]=='#' && a[j-1]!='A' && a[j+1]!='A'){\n\t\t\t\t\t\t\ta[j] = c;\n\t\t\t\t\t\t\tflag = false;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(flag==true){\n\t\t\t\t\t\tfor(int j=1;j<=n;j++){\n\t\t\t\t\t\t\tif(a[j]=='#'){\n\t\t\t\t\t\t\t\ta[j] = c;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}else if(c=='C'){\n\t\t\t\t\tif(i==0){\n\t\t\t\t\t\tif(n%2==0) a[(n+1)/2] = c;\n\t\t\t\t\t\telse a[n/2+1] = c;\n\t\t\t\t\t}else{\n\t\t\t\t\t\tfor(int j=1;j<=n;j++){\n\t\t\t\t\t\t\tif(a[j]!='#'){\n\t\t\t\t\t\t\t\tif(a[j+1]=='#'){\n\t\t\t\t\t\t\t\t\ta[j+1] = c;\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif(a[j-1]=='#'){\n\t\t\t\t\t\t\t\t\ta[j-1] = c;\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}else if(c=='D'){\n\t\t\t\t\tif(i==0){\n\t\t\t\t\t\ta[1] = c;\n\t\t\t\t\t}else{\n\t\t\t\t\t\tint max = -1;\n\t\t\t\t\t\tint p = -1;\n\t\t\t\t\t\tfor(int j=1;j<=n;j++){\n\t\t\t\t\t\t\tif(a[j]=='#'){\n\t\t\t\t\t\t\t\tint min = Integer.MAX_VALUE;\n\t\t\t\t\t\t\t\tfor(int k=j-1;k>=0;k--){\n\t\t\t\t\t\t\t\t\tif(k==0) break;\n\t\t\t\t\t\t\t\t\tif(a[k]!='#'){\n\t\t\t\t\t\t\t\t\t\tmin = Math.min(min, j-k+1);\n\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tfor(int k=j+1;k<=n+1;k++){\n\t\t\t\t\t\t\t\t\tif(k==n+1) break;\n\t\t\t\t\t\t\t\t\tif(a[k]!='#'){\n\t\t\t\t\t\t\t\t\t\tmin = Math.min(min, k-j+1);\n\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif(min>max){\n\t\t\t\t\t\t\t\t\tmax = min;\n\t\t\t\t\t\t\t\t\tp = j;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\ta[p] = c;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(int i=1;i<=n;i++) System.out.print(a[i]);\n\t\t\tSystem.out.println();\n\t\t}\n\t}\n}", "sampled": "import java.util.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        \n        while (true) {\n            int n = sc.nextInt();\n            int m = sc.nextInt();\n            \n            if (n == 0 && m == 0) break;\n            \n            char[] chairs = new char[n];\n            Arrays.fill(chairs, '#');\n            \n            for (int i = 0; i < m; i++) {\n                String nationality = sc.next();\n                char person = nationality.charAt(0);\n                \n                if (person == 'A') {\n                    // Left to right, first empty chair\n                    for (int j = 0; j < n; j++) {\n                        if (chairs[j] == '#') {\n                            chairs[j] = 'A';\n                            break;\n                        }\n                    }\n                } else if (person == 'B') {\n                    // Right to left, not next to A\n                    boolean found = false;\n                    for (int j = n - 1; j >= 0; j--) {\n                        if (chairs[j] == '#') {\n                            boolean nextToA = false;\n                            if (j > 0 && chairs[j - 1] == 'A') nextToA = true;\n                            if (j < n - 1 && chairs[j + 1] == 'A') nextToA = true;\n                            \n                            if (!nextToA) {\n                                chairs[j] = 'B';\n                                found = true;\n                                break;\n                            }\n                        }\n                    }\n                    \n                    if (!found) {\n                        // Must sit next to A, left to right\n                        for (int j = 0; j < n; j++) {\n                            if (chairs[j] == '#') {\n                                chairs[j] = 'B';\n                                break;\n                            }\n                        }\n                    }\n                } else if (person == 'C') {\n                    // Next to someone, prefer right then left\n                    boolean found = false;\n                    \n                    // Check if anyone is sitting\n                    boolean anyoneSeated = false;\n                    for (int j = 0; j < n; j++) {\n                        if (chairs[j] != '#') {\n                            anyoneSeated = true;\n                            break;\n                        }\n                    }\n                    \n                    if (!anyoneSeated) {\n                        // Sit in middle\n                        int middle = (n % 2 == 1) ? n / 2 : n / 2;\n                        chairs[middle] = 'C';\n                    } else {\n                        // Find leftmost person and try right, then left\n                        for (int j = 0; j < n; j++) {\n                            if (chairs[j] != '#') {\n                                // Try right\n                                if (j + 1 < n && chairs[j + 1] == '#') {\n                                    chairs[j + 1] = 'C';\n                                    found = true;\n                                    break;\n                                }\n                                // Try left\n                                if (j - 1 >= 0 && chairs[j - 1] == '#') {\n                                    chairs[j - 1] = 'C';\n                                    found = true;\n                                    break;\n                                }\n                            }\n                        }\n                    }\n                } else if (person == 'D') {\n                    // Maximize minimum distance\n                    boolean anyoneSeated = false;\n                    for (int j = 0; j < n; j++) {\n                        if (chairs[j] != '#') {\n                            anyoneSeated = true;\n                            break;\n                        }\n                    }\n                    \n                    if (!anyoneSeated) {\n                        chairs[0] = 'D';\n                    } else {\n                        int bestPos = -1;\n                        int maxMinDist = -1;\n                        \n                        for (int j = 0; j < n; j++) {\n                            if (chairs[j] == '#') {\n                                int minDist = Integer.MAX_VALUE;\n                                \n                                for (int k = 0; k < n; k++) {\n                                    if (chairs[k] != '#') {\n                                        minDist = Math.min(minDist, Math.abs(j - k));\n                                    }\n                                }\n                                \n                                if (minDist > maxMinDist) {\n                                    maxMinDist = minDist;\n                                    bestPos = j;\n                                }\n                            }\n                        }\n                        \n                        chairs[bestPos] = 'D';\n                    }\n                }\n            }\n            \n            System.out.println(new String(chairs));\n        }\n        \n        sc.close();\n    }\n}\n", "perturbed_sampled": [" {  new Scanner(System.in); while  sc.nextInt(); if (n == 0  char[] chairs = new char[n]; Arrays.fill(chairs, '#');  { String nationality =  right, first empty chair for (int j = 0; j  chairs[j] = 'A'; break;  (person == 'B') { //  = false;  - 1; j >= 0; j--) {  if  - 1] ==  (j < n -    if (!found) { // Must sit next to A, left to right for (int  (chairs[j] == '#') { chairs[j] = 'B'; break;  { // Next to  boolean found = false; //  boolean anyoneSeated = false;   break; } } if (!anyoneSeated) {  n / 2 : n / 2; chairs[middle]  // Find leftmost person and try right, then  0;   (j +  + 1] == '#') { chairs[j + 1] = 'C'; found =  left if (j - 1 >= 0  1]  break;  else if    n; j++)   } else { int  < n; j++) {  int minDist = Integer.MAX_VALUE; for (int k = 0; k < n; k++)  { minDist =   } } chairs[bestPos] = 'D'; } }  } }"], "perturbed_original": ["import java.util.*; public <extra_id_6>(i=0;i<m;i++){<extra_id_7>case '<extra_id_8>' : case '<extra_id_9>if(flag!=true){ int min<extra_id_10>break; int<extra_id_11>} //if(flag==true){ Scanner sc = new Scanner(System.in); <extra_id_12>if(flag!=true){ int m = sc.nextInt(); if(n==0 int min<extra_id_13>a [ n<extra_id_8>= 'X'; = new char[n+2]; Arrays.fill(a,'#'); a[0] = 'X'; a[n+1] = 'X'; for(int i=0;i<m;i++){ char c = sc.next().charAt(0); if(c=='A'){ for(int  &&  c; flag  if(flag==true){  c; break;  if(a[j]!='#'){ if(a[j+1]=='#'){ a[j+1] = c; break; }  } }   j=1;j<=n;j++){ if(a[j]=='#'){ int min =  j-k+1); break; } } for(int k=j+1;k<=n+1;k++){ if(k==n+1) break; if(a[k]!='#'){ min  } if(min>max){  } } for(int i=1;i<=n;i++) System.out.print(a[i]); System.out.println(); } } }"], "original_ll": -0.5161633491516113, "sampled_ll": -0.5180969834327698, "all_perturbed_sampled_ll": [-2.8697614669799805], "all_perturbed_original_ll": [-2.1958847045898438], "perturbed_sampled_ll": -2.8697614669799805, "perturbed_original_ll": -2.1958847045898438, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "INF = 10 ** 20\n\nwhile True:\n  n, m = map(int, input().split())\n  if not n:\n    break\n\n  chairs = list(\"#\" * n)\n\n  def sit(s):\n    if s == \"A\":\n      chairs[chairs.index(\"#\")] = \"A\"\n    elif s == \"B\":\n      for i in range(n - 1, -1, -1):\n        if chairs[i] == \"#\" and (i == 0 or chairs[i - 1] != \"A\") and (i == n - 1 or chairs[i + 1] != \"A\"):\n          chairs[i] = \"B\"\n          break\n      else:\n        chairs[chairs.index(\"#\")] = \"B\"\n\n    elif s == \"C\":\n      for i in range(1, n):\n        if chairs[i] == \"#\" and chairs[i - 1] != \"#\":\n          chairs[i] = \"C\"\n          break\n\n    else:\n      score = [INF for _ in range(n)]\n      dist = INF\n      for i in range(n):\n        if chairs[i] == \"#\":\n          dist += 1\n        else:\n          dist = 0\n        score[i] = dist\n\n      dist = INF\n      for i in range(n - 1, -1, -1):\n        if chairs[i] == \"#\":\n          dist += 1\n        else:\n          dist = 0\n        score[i] = min(score[i], dist)\n      high_score = max(score)\n      chairs[score.index(high_score)] = \"D\"\n  \n  first = input()\n  if first in [\"A\", \"D\"]:\n    chairs[0] = first\n  elif first == \"B\":\n    chairs[-1] = \"B\"\n  else:\n    chairs[n // 2] = \"C\"\n  for _ in range(m - 1):\n    sit(input())\n\n  print(\"\".join(chairs))\n\n", "sampled": "import sys\n\ndef solve(n, m, passengers):\n    seats = ['#'] * n  # 0-indexed\n    \n    for passenger in passengers:\n        if passenger == 'A':\n            # Left to right, first empty\n            for i in range(n):\n                if seats[i] == '#':\n                    seats[i] = 'A'\n                    break\n                    \n        elif passenger == 'B':\n            # Avoid A, right to left\n            # First try to find seat not adjacent to A\n            found = False\n            for i in range(n-1, -1, -1):\n                if seats[i] == '#':\n                    # Check if adjacent to A\n                    adjacent_to_a = False\n                    if i > 0 and seats[i-1] == 'A':\n                        adjacent_to_a = True\n                    if i < n-1 and seats[i+1] == 'A':\n                        adjacent_to_a = True\n                    \n                    if not adjacent_to_a:\n                        seats[i] = 'B'\n                        found = True\n                        break\n            \n            # If not found, sit left to right (adjacent to A is ok)\n            if not found:\n                for i in range(n):\n                    if seats[i] == '#':\n                        seats[i] = 'B'\n                        break\n                        \n        elif passenger == 'C':\n            # Sit next to someone\n            # Find leftmost person, try right then left\n            found = False\n            \n            # Check if anyone is seated\n            someone_seated = any(s != '#' for s in seats)\n            \n            if someone_seated:\n                for i in range(n):\n                    if seats[i] != '#':\n                        # Try right\n                        if i < n-1 and seats[i+1] == '#':\n                            seats[i+1] = 'C'\n                            found = True\n                            break\n                        # Try left\n                        elif i > 0 and seats[i-1] == '#':\n                            seats[i-1] = 'C'\n                            found = True\n                            break\n            \n            if not found:\n                # Sit in middle\n                if n % 2 == 1:\n                    mid = n // 2\n                else:\n                    mid = n // 2\n                seats[mid] = 'C'\n                \n        elif passenger == 'D':\n            # Maximize minimum distance\n            # If no one seated, sit at left end\n            someone_seated = any(s != '#' for s in seats)\n            \n            if not someone_seated:\n                seats[0] = 'D'\n            else:\n                # Find empty seat with max min distance\n                best_seat = -1\n                best_min_dist = -1\n                \n                for i in range(n):\n                    if seats[i] == '#':\n                        # Calculate min distance to any occupied seat\n                        min_dist = float('inf')\n                        for j in range(n):\n                            if seats[j] != '#':\n                                min_dist = min(min_dist, abs(i - j))\n                        \n                        if min_dist > best_min_dist:\n                            best_min_dist = min_dist\n                            best_seat = i\n                \n                seats[best_seat] = 'D'\n    \n    return ''.join(seats)\n\n# Read input\nlines = []\nfor line in sys.stdin:\n    lines.append(line.strip())\n\ni = 0\nwhile i < len(lines):\n    parts = lines[i].split()\n    n, m = int(parts[0]), int(parts[1])\n    \n    if n == 0 and m == 0:\n        break\n    \n    i += 1\n    passengers = []\n    for j in range(m):\n        passengers.append(lines[i])\n        i += 1\n    \n    result = solve(n, m, passengers)\n    print(result)\n", "perturbed_sampled": ["import  seats  0-indexed for passenger in passengers:  Left to right,  '#': seats[i] = 'A'  # Avoid A, right to left # First try to  A found = False for i in range(n-1, -1,  # Check if adjacent  if i > 0 and seats[i-1] == 'A': adjacent_to_a = True  seats[i+1] == 'A': adjacent_to_a = True if not adjacent_to_a: seats[i] = 'B' found =  right (adjacent to A is ok) if not found: for i in range(n): if seats[i] == '#':  Sit next to someone   anyone is seated someone_seated   i <  seats[i+1] = 'C' found = True break #   = True break if not  2 seats[mid] = 'C' elif passenger == 'D': # Maximize minimum distance # If no one seated, sit at  in seats)  'D' else: #   best_min_dist = -1 for  min distance  =   in sys.stdin: lines.append(line.strip()) i = 0 while i <  m  == 0 and m  passengers) print(result)"], "perturbed_original": ["INF =  n, m = map(int,  == \"B\": for i in   (i == 0 or chairs[i - 1] != \"A\") and  = \"B\" elif s == \"C\":  and chairs[i - 1] != \"#\": chairs[i]  = [INF for _ in range(n)] dist = INF for  ==  dist = 0 score[i] = dist dist  range(n - 1,     = first elif first  else: chairs[n // 2] = \"C\" for _ in range(m - 1): sit(input()) print(\"\".join(chairs))"], "original_ll": -0.9353145956993103, "sampled_ll": -0.7778886556625366, "all_perturbed_sampled_ll": [-3.201148271560669], "all_perturbed_original_ll": [-3.3834965229034424], "perturbed_sampled_ll": -3.201148271560669, "perturbed_original_ll": -3.3834965229034424, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "#include<stdio.h>\nint main(){\n  int i,j,k,l,n,m;\n  int d[2][100][100]={0};\n  while(scanf(\"%d %d\",&m,&n),n||m){\n    for(i=0;i<100;i++){\n      for(j=0;j<100;j++)d[0][i][j]=d[1][i][j]=100000000;\n      d[0][i][i]=d[1][i][i]=0;\n    }\n    while(m--){\n      scanf(\"%d %d %d %d\",&i,&j,&k,&l);\n      d[0][i-1][j-1]=d[0][j-1][i-1]=k;\n      d[1][i-1][j-1]=d[1][j-1][i-1]=l;\n    }\n    for(l=0;l<n;l++){\n      //for(i=0;i<2;i++){\n      for(j=0;j<n;j++){\n\tfor(k=0;k<n;k++){\n\t  //for(l=0;l<n;l++){\n\t  for(i=0;i<2;i++){\n\t    if(d[i][j][k]>d[i][j][l]+d[i][l][k]){\n\t       d[i][j][k]=d[i][j][l]+d[i][l][k];\n\t    }\n\t  }\n\t}\n      }\n    }\n    scanf(\"%d\",&l);\n    while(l--){\n      scanf(\"%d %d %d\",&i,&j,&k);\n      printf(\"%d\\n\",d[k][i-1][j-1]);\n    }\n  }\n  return 0;\n}\n      ", "sampled": "#include <stdio.h>\n#include <string.h>\n#include <limits.h>\n\n#define MAX_M 105\n#define INF 1000000000\n\nint n, m, k;\nint cost_graph[MAX_M][MAX_M];\nint time_graph[MAX_M][MAX_M];\n\nint dijkstra(int graph[MAX_M][MAX_M], int start, int end) {\n    int dist[MAX_M];\n    int visited[MAX_M];\n    int i, j;\n    \n    for (i = 1; i <= m; i++) {\n        dist[i] = INF;\n        visited[i] = 0;\n    }\n    \n    dist[start] = 0;\n    \n    for (i = 0; i < m; i++) {\n        int min_dist = INF;\n        int u = -1;\n        \n        for (j = 1; j <= m; j++) {\n            if (!visited[j] && dist[j] < min_dist) {\n                min_dist = dist[j];\n                u = j;\n            }\n        }\n        \n        if (u == -1) break;\n        \n        visited[u] = 1;\n        \n        for (j = 1; j <= m; j++) {\n            if (!visited[j] && graph[u][j] != INF) {\n                if (dist[u] + graph[u][j] < dist[j]) {\n                    dist[j] = dist[u] + graph[u][j];\n                }\n            }\n        }\n    }\n    \n    return dist[end];\n}\n\nint main() {\n    while (1) {\n        scanf(\"%d %d\", &n, &m);\n        if (n == 0 && m == 0) break;\n        \n        int i, j;\n        \n        for (i = 1; i <= m; i++) {\n            for (j = 1; j <= m; j++) {\n                if (i == j) {\n                    cost_graph[i][j] = 0;\n                    time_graph[i][j] = 0;\n                } else {\n                    cost_graph[i][j] = INF;\n                    time_graph[i][j] = INF;\n                }\n            }\n        }\n        \n        for (i = 0; i < n; i++) {\n            int a, b, cost, time;\n            scanf(\"%d %d %d %d\", &a, &b, &cost, &time);\n            \n            if (cost < cost_graph[a][b]) {\n                cost_graph[a][b] = cost;\n                cost_graph[b][a] = cost;\n            }\n            \n            if (time < time_graph[a][b]) {\n                time_graph[a][b] = time;\n                time_graph[b][a] = time;\n            }\n        }\n        \n        scanf(\"%d\", &k);\n        \n        for (i = 0; i < k; i++) {\n            int p, q, r;\n            scanf(\"%d %d %d\", &p, &q, &r);\n            \n            if (r == 0) {\n                printf(\"%d\\n\", dijkstra(cost_graph, p, q));\n            } else {\n                printf(\"%d\\n\", dijkstra(time_graph, p, q));\n            }\n        }\n    }\n    \n    return 0;\n}\n", "perturbed_sampled": ["#include <stdio.h> #include   dijkstra(int graph[MAX_M][MAX_M], int  dist[MAX_M];    0; } dist[start]  0;  int min_dist = INF; int  = 1; j <= m; j++) { if (!visited[j] && dist[j] < min_dist) { min_dist = dist[j]; u = j;  -1) break; visited[u] = 1; for (j = 1;  != INF)    } }  {  &n, &m); if (n ==   (i = 1; i  (j = 1; j <= m; j++)  { cost_graph[i][j] = 0; time_graph[i][j] = 0; } else  0; i <    } if (time < time_graph[a][b]) { time_graph[a][b] = time;  scanf(\"%d\", &k); for (i  if (r ==  q)); } else  } } } return 0; }"], "perturbed_original": ["#include<stdio.h> int main(){  %d\",&m,&n),n||m){ for(i=0;i<100;i++){ for(j=0;j<100;j++)d[0][i][j]=d[1][i][j]=100000000;  }   } } }  printf(\"%d\\n\",d[k][i-1][j-1]); } } return 0; }"], "original_ll": -0.6904141902923584, "sampled_ll": -0.33233898878097534, "all_perturbed_sampled_ll": [-2.325984477996826], "all_perturbed_original_ll": [-1.88897705078125], "perturbed_sampled_ll": -2.325984477996826, "perturbed_original_ll": -1.88897705078125, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import java.util.Arrays;\nimport java.util.Scanner;\n\npublic class Main {\n\tstatic final int INF = 1000000000;\n\tpublic static void main(String[] args) {\n\t\t// TODO Auto-generated method stub\n\t\tScanner sc = new Scanner(System.in);\n\t\t\n\t\twhile(true){\n\t\t\tint n = sc.nextInt();\n\t\t\tint m = sc.nextInt();\n\t\t\tif(n == 0 && m == 0){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\n\t\t\tint[][] cost = new int[m][m];\n\t\t\tint[][] time = new int[m][m];\n\t\t\tfor(int i = 0; i < m; i++){\n\t\t\t\tfor(int j = 0; j < m; j++){\n\t\t\t\t\tcost[i][j] = INF;\n\t\t\t\t\ttime[i][j] = INF;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(int i = 0; i < n; i++){\n\t\t\t\tint a = sc.nextInt() - 1;\n\t\t\t\tint b = sc.nextInt() - 1;\n\t\t\t\tcost[a][b] = sc.nextInt();\n\t\t\t\tcost[b][a] = cost[a][b];\n\t\t\t\ttime[a][b] = sc.nextInt();\n\t\t\t\ttime[b][a] = time[a][b];\n\t\t\t}\n\t\t\tfor(int k = 0; k < m; k++){\n\t\t\t\tfor(int i = 0; i < m; i++){\n\t\t\t\t\tfor(int j = i; j < m; j++){\n\t\t\t\t\t\tcost[i][j] = Math.min(cost[i][j], cost[i][k] + cost[k][j]);\n\t\t\t\t\t\tcost[j][i] = cost[i][j];\n\t\t\t\t\t\ttime[i][j] = Math.min(time[i][j], time[i][k] + time[k][j]);\n\t\t\t\t\t\ttime[j][i] = time[i][j];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tint k = sc.nextInt();\n\t\t\tfor(int i = 0; i < k; i++){\n\t\t\t\tint p = sc.nextInt() - 1;\n\t\t\t\tint q = sc.nextInt() - 1;\n\t\t\t\tint r = sc.nextInt();\n\t\t\t\tif(r == 0){\n\t\t\t\t\tSystem.out.println(cost[p][q]);\n\t\t\t\t}else if(r == 1){\n\t\t\t\t\tSystem.out.println(time[p][q]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tsc.close();\n\t}\n\n}", "sampled": "import java.util.*;\n\npublic class Main {\n    static class Edge {\n        int to, cost, time;\n        Edge(int to, int cost, int time) {\n            this.to = to;\n            this.cost = cost;\n            this.time = time;\n        }\n    }\n    \n    static class State implements Comparable<State> {\n        int node, value;\n        State(int node, int value) {\n            this.node = node;\n            this.value = value;\n        }\n        public int compareTo(State other) {\n            return this.value - other.value;\n        }\n    }\n    \n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        \n        while (true) {\n            int n = sc.nextInt();\n            int m = sc.nextInt();\n            \n            if (n == 0 && m == 0) break;\n            \n            List<Edge>[] graph = new ArrayList[m + 1];\n            for (int i = 0; i <= m; i++) {\n                graph[i] = new ArrayList<>();\n            }\n            \n            for (int i = 0; i < n; i++) {\n                int a = sc.nextInt();\n                int b = sc.nextInt();\n                int cost = sc.nextInt();\n                int time = sc.nextInt();\n                graph[a].add(new Edge(b, cost, time));\n                graph[b].add(new Edge(a, cost, time));\n            }\n            \n            int k = sc.nextInt();\n            for (int i = 0; i < k; i++) {\n                int p = sc.nextInt();\n                int q = sc.nextInt();\n                int r = sc.nextInt();\n                \n                if (r == 0) {\n                    System.out.println(dijkstra(graph, m, p, q, true));\n                } else {\n                    System.out.println(dijkstra(graph, m, p, q, false));\n                }\n            }\n        }\n        sc.close();\n    }\n    \n    static int dijkstra(List<Edge>[] graph, int m, int start, int end, boolean useCost) {\n        int[] dist = new int[m + 1];\n        Arrays.fill(dist, Integer.MAX_VALUE);\n        dist[start] = 0;\n        \n        PriorityQueue<State> pq = new PriorityQueue<>();\n        pq.offer(new State(start, 0));\n        \n        while (!pq.isEmpty()) {\n            State current = pq.poll();\n            int u = current.node;\n            int d = current.value;\n            \n            if (d > dist[u]) continue;\n            \n            for (Edge edge : graph[u]) {\n                int v = edge.to;\n                int weight = useCost ? edge.cost : edge.time;\n                \n                if (dist[u] + weight < dist[v]) {\n                    dist[v] = dist[u] + weight;\n                    pq.offer(new State(v, dist[v]));\n                }\n            }\n        }\n        \n        return dist[end];\n    }\n}\n", "perturbed_sampled": ["import java.util.*; public    } } static class State  value;  int compareTo(State other) { return this.value - other.value;  main(String[] args) { Scanner sc = new Scanner(System.in); while (true) { int n = sc.nextInt(); int m = sc.nextInt(); if (n == 0 && m  = new ArrayList[m + 1];  i  for (int i = 0;  int b = sc.nextInt(); int cost = sc.nextInt();  int  <   p, q, false)); }  m, int start,  int[m + 1]; Arrays.fill(dist, Integer.MAX_VALUE); dist[start] = 0; PriorityQueue<State> pq = new PriorityQueue<>(); pq.offer(new State(start, 0)); while (!pq.isEmpty()) { State current = pq.poll(); int  = current.value; if  (Edge edge   useCost ?  + weight < dist[v]) {   }"], "perturbed_original": ["import java.util.Arrays; import java.util.Scanner; public class Main { static final int INF = 1000000000; public static void main(String[] args)  stub Scanner sc = new Scanner(System.in); while(true){ int n  sc.nextInt(); if(n == 0  } int[][] cost =   0; j   }  sc.nextInt() - 1; cost[a][b] = sc.nextInt(); cost[b][a] = cost[a][b]; time[a][b] = sc.nextInt(); time[b][a] = time[a][b]; } for(int k = 0; k < m;   cost[k][j]); cost[j][i]  = time[i][j]; }   if(r == 0){ System.out.println(cost[p][q]); }else if(r == 1){ System.out.println(time[p][q]);  }"], "original_ll": -0.37354564666748047, "sampled_ll": -0.3793591260910034, "all_perturbed_sampled_ll": [-2.4665071964263916], "all_perturbed_original_ll": [-1.6863282918930054], "perturbed_sampled_ll": -2.4665071964263916, "perturbed_original_ll": -1.6863282918930054, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "\nfrom copy import deepcopy\nINF = 1000000000\ndef dj(s, e, r):\n  d = [INF] * 100\n  done = [0] * 100\n  d[s] = 0\n  while True:\n    v = -1\n    for i in VL:\n      if not done[i] and (v == -1 or d[i] < d[v]):\n        v = i\n    if v == e:\n      return d[e]\n    done[v] = True\n    for i in VL:\n      d[i] = min(d[i], d[v] + cost[v][i][r])\n\nL100 = range(100)\ncostPre = [[[INF for k in range(2)] for j in L100] for i in L100]\nwhile True:\n  E, V = map(int, raw_input().split())\n  cost = deepcopy(costPre)\n  VL = range(V)\n  if not E:\n    break\n  for i in range(E):\n    a, b, c, d = map(int, raw_input().split())\n    a -= 1\n    b -= 1\n    cost[a][b][0] = cost[b][a][0] = c\n    cost[a][b][1] = cost[b][a][1] = d\n  k = input()\n  for i in range(k):\n    p, q, r = map(int, raw_input().split())\n    p -= 1\n    q -= 1\n    print dj(p, q, r)", "sampled": "import heapq\nfrom collections import defaultdict\nimport sys\n\ndef dijkstra(graph, start, end, mode):\n    # mode: 0 for cost, 1 for time\n    pq = [(0, start)]\n    visited = set()\n    dist = defaultdict(lambda: float('inf'))\n    dist[start] = 0\n    \n    while pq:\n        current_dist, node = heapq.heappop(pq)\n        \n        if node in visited:\n            continue\n            \n        visited.add(node)\n        \n        if node == end:\n            return current_dist\n        \n        for neighbor, cost, time in graph[node]:\n            weight = cost if mode == 0 else time\n            new_dist = current_dist + weight\n            \n            if new_dist < dist[neighbor]:\n                dist[neighbor] = new_dist\n                heapq.heappush(pq, (new_dist, neighbor))\n    \n    return dist[end]\n\nwhile True:\n    line = sys.stdin.readline().strip()\n    if not line:\n        break\n    n = int(line)\n    m = int(sys.stdin.readline().strip())\n    \n    if n == 0 and m == 0:\n        break\n    \n    graph = defaultdict(list)\n    \n    for _ in range(n):\n        parts = list(map(int, sys.stdin.readline().strip().split()))\n        a, b, cost, time = parts[0], parts[1], parts[2], parts[3]\n        graph[a].append((b, cost, time))\n        graph[b].append((a, cost, time))\n    \n    k = int(sys.stdin.readline().strip())\n    \n    for _ in range(k):\n        parts = list(map(int, sys.stdin.readline().strip().split()))\n        p, q, r = parts[0], parts[1], parts[2]\n        result = dijkstra(graph, p, q, r)\n        print(result)\n", "perturbed_sampled": ["import heapq  sys def  mode: 0 for cost, 1 for time pq = [(0,    if node == end: return current_dist for neighbor, cost, time  if mode == 0 else  heapq.heappush(pq,   not line: break n = int(line) m = int(sys.stdin.readline().strip()) if  == 0: break graph =   graph[a].append((b, cost, time))  sys.stdin.readline().strip().split())) p,  parts[2] result = dijkstra(graph, p, q, r) print(result)"], "perturbed_original": ["from copy import deepcopy  e, r): d = [INF] *  or  i if v  = True for i   range(100) costPre = [[[INF   in L100] while True:  E: break for i in range(E): a, b,   1 cost[a][b][0] = cost[b][a][0]  input() for i in range(k): p, q, r = map(int,  -= 1 print dj(p, q, r)"], "original_ll": -0.9250554442405701, "sampled_ll": -0.546992838382721, "all_perturbed_sampled_ll": [-3.6090517044067383], "all_perturbed_original_ll": [-3.8537302017211914], "perturbed_sampled_ll": -3.6090517044067383, "perturbed_original_ll": -3.8537302017211914, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "// Aizu Vol-2 0201: Wrought Gold Master\n// 2017.8.17 bal4u@uu\n// ??\u00a2?????????????????????????????\\????????????????????\u00a3?????????\n\n#include <stdio.h>\n#include <string.h>\n\n#define HSIZ 499\ntypedef struct { char *w; int k; } HASH;\nHASH hash[HSIZ + 5];\n\nint lookup(char *w)\n{\n\tint i, l;\n\tHASH *tp;\n\ti = (101 * *w + 103 * *(w + (l = strlen(w)) - 1) + 107 * l) % HSIZ;\n\ttp = hash + i;\n\tif (tp->w != NULL) {\n\t\tint inc = *w + (*(w + 1) << 1);\n\t\twhile (1) {\n\t\t\tif (!strcmp(tp->w, w)) return tp->k;\n\t\t\ti += inc; if (i >= HSIZ) i -= HSIZ;\n\t\t\ttp = hash + i;\n\t\t\tif (tp->w == NULL) break;\n\t\t}\n\t}\n\treturn -1;\n}\n\nint insert(char *w, int k)\n{\n\tint i, l;\n\tHASH *tp;\n\ti = (101 * *w + 103 * *(w + (l = strlen(w)) - 1) + 107 * l) % HSIZ;\n\ttp = hash + i;\n\tif (tp->w != NULL) {\n\t\tint inc = *w + (*(w + 1) << 1);\n\t\twhile (1) {\n\t\t\tif (!strcmp(tp->w, w)) return -1;\n\t\t\ti += inc; if (i >= HSIZ) i -= HSIZ;\n\t\t\ttp = hash + i;\n\t\t\tif (tp->w == NULL) break;\n\t\t}\n\t}\n\ttp->w = w, tp->k = k;\n\treturn 0;\n}\n\ntypedef struct { char a[102]; int m, k, i[102]; } MONO;\nMONO mono[205]; int no;\n\nint combi(int a)\n{\n\tint i, k, c = -1;\n\tk = mono[a].k;\n\tif (k > 0) for (c = i = 0; i < k; i++) c += combi(mono[a].i[i]);\n\tif (c < 0 || (mono[a].m >= 0 && mono[a].m < c)) c = mono[a].m;\n\treturn c;\n}\n\nint main()\n{\n\tint i, j, k, N, M;\n\tchar b[102];\n\n\twhile (scanf(\"%d\", &N) == 1 && N) {\n\t\tmemset(hash, 0, sizeof(hash)), no = 0;\n\t\twhile (N-- > 0) {\n\t\t\tscanf(\"%s%d\", mono[no].a, &(mono[no].m));\n\t\t\tmono[no].k = 0; insert(mono[no].a, no);\n\t\t\tno++;\n\t\t}\n\t\tscanf(\"%d\", &M);\n\t\twhile (M--) {\n\t\t\tscanf(\"%s%d\", mono[no].a, &k);\n\t\t\tif ((i = lookup(mono[no].a)) < 0) insert(mono[no].a, no), mono[no].m = -1, i = no++;\n\t\t\tmono[i].k = k;\n\t\t\tfor (j = 0; j < mono[i].k; j++) scanf(\"%s\", b), mono[i].i[j] = lookup(b);\n\t\t}\n\t\tscanf(\"%s\", b);\n\t\tprintf(\"%d\\n\", combi(lookup(b)));\n\t}\n\treturn 0;\n}", "sampled": "#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n\n#define MAX_ITEMS 100\n#define MAX_NAME 101\n\ntypedef struct {\n    char name[MAX_NAME];\n    int price;\n    int has_recipe;\n    int num_ingredients;\n    int ingredients[MAX_ITEMS];\n} Item;\n\nItem items[MAX_ITEMS];\nint n, m;\nint memo[MAX_ITEMS];\nint computed[MAX_ITEMS];\n\nint find_item(char *name) {\n    for (int i = 0; i < n; i++) {\n        if (strcmp(items[i].name, name) == 0) {\n            return i;\n        }\n    }\n    return -1;\n}\n\nint min_cost(int idx) {\n    if (computed[idx]) {\n        return memo[idx];\n    }\n    \n    computed[idx] = 1;\n    int buy_cost = items[idx].price;\n    \n    if (!items[idx].has_recipe) {\n        memo[idx] = buy_cost;\n        return buy_cost;\n    }\n    \n    int craft_cost = 0;\n    for (int i = 0; i < items[idx].num_ingredients; i++) {\n        craft_cost += min_cost(items[idx].ingredients[i]);\n    }\n    \n    memo[idx] = (buy_cost < craft_cost) ? buy_cost : craft_cost;\n    return memo[idx];\n}\n\nint main() {\n    while (1) {\n        scanf(\"%d\", &n);\n        if (n == 0) break;\n        \n        for (int i = 0; i < n; i++) {\n            scanf(\"%s %d\", items[i].name, &items[i].price);\n            items[i].has_recipe = 0;\n            items[i].num_ingredients = 0;\n            computed[i] = 0;\n        }\n        \n        scanf(\"%d\", &m);\n        for (int i = 0; i < m; i++) {\n            char output[MAX_NAME];\n            int k;\n            scanf(\"%s %d\", output, &k);\n            \n            int out_idx = find_item(output);\n            items[out_idx].has_recipe = 1;\n            items[out_idx].num_ingredients = k;\n            \n            for (int j = 0; j < k; j++) {\n                char ingredient[MAX_NAME];\n                scanf(\"%s\", ingredient);\n                int ing_idx = find_item(ingredient);\n                items[out_idx].ingredients[j] = ing_idx;\n            }\n        }\n        \n        char target[MAX_NAME];\n        scanf(\"%s\", target);\n        int target_idx = find_item(target);\n        \n        printf(\"%d\\n\", min_cost(target_idx));\n    }\n    \n    return 0;\n}\n", "perturbed_sampled": ["#include <stdio.h> #include   struct { char name[MAX_NAME]; int price; int has_recipe; int num_ingredients; int ingredients[MAX_ITEMS]; }  m; int  *name) { for (int i = 0; i < n; i++) { if (strcmp(items[i].name, name) ==    int   items[idx].num_ingredients; i++) { craft_cost += min_cost(items[idx].ingredients[i]); } memo[idx] = (buy_cost < craft_cost) ?  }  {  0) break;  = 0; i < m; i++) { char output[MAX_NAME]; int   = 1; items[out_idx].num_ingredients =  scanf(\"%s\", ingredient);  = ing_idx; } } char target[MAX_NAME]; scanf(\"%s\", target); int  } return 0; }"], "perturbed_original": ["// Aizu Vol-2 0201: Wrought  //  #define HSIZ   HASH hash[HSIZ + 5]; int lookup(char *w) {   - 1) + 107 * l) % HSIZ; tp = hash +  { int inc = *w  1); while  return  } } return  i, l; HASH *tp; i = (101 *  - 1)  HSIZ; tp  int inc = *w + (*(w  (1) { if (!strcmp(tp->w, w)) return -1;  HSIZ; tp = hash + i; if (tp->w == NULL) break; }    } MONO; MONO  (c = i = 0; i  combi(mono[a].i[i]); if (c < 0 || (mono[a].m >= 0 && mono[a].m < c)) c = mono[a].m; return c; } int main() { int i, j, k,  && N) { memset(hash,   scanf(\"%s%d\", mono[no].a, &(mono[no].m)); mono[no].k = 0; insert(mono[no].a, no); no++; } scanf(\"%d\", &M); while (M--) { scanf(\"%s%d\", mono[no].a,  return 0; }"], "original_ll": -1.1127487421035767, "sampled_ll": -0.5903927087783813, "all_perturbed_sampled_ll": [-2.93276047706604], "all_perturbed_original_ll": [-3.0163819789886475], "perturbed_sampled_ll": -2.93276047706604, "perturbed_original_ll": -3.0163819789886475, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import java.util.*;\n\npublic class Main{\n\tpublic static void main(String[] args){\n\t\tScanner sc = new Scanner(System.in);\n\n\t\twhile(true){\n\t\t\tint n = sc.nextInt();\n\t\t\tif(n == 0) break;\n\n\t\t\tprice = new HashMap<String,Integer>();\n\t\t\twhile(n-- > 0){\n\t\t\t\tprice.put(sc.next(),sc.nextInt());\n\t\t\t}\n\n\t\t\tn = sc.nextInt();\n\t\t\tmap = new HashMap<String,ArrayList<String>>();\n\t\t\twhile(n-- > 0){\n\t\t\t\tString s = sc.next();\n\t\t\t\tint m = sc.nextInt();\n\t\t\t\tmap.put(s,new ArrayList<String>());\n\t\t\t\twhile(m-- > 0){\n\t\t\t\t\tmap.get(s).add(sc.next());\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tdp = new HashMap<String,Integer>();\n\t\t\tSystem.out.println(minCost(sc.next()));\n\t\t}\n\t}\n\n\tprivate static HashMap<String,Integer> price;\n\tprivate static HashMap<String,ArrayList<String>> map;\n\tprivate static HashMap<String,Integer> dp;\n\n\tprivate static int minCost(String s){\n\t\tif(map.get(s) == null) return price.get(s);\n\t\tif(dp.get(s) != null) return dp.get(s);\n\n\t\tint sum = 0;\n\n\t\tfor(String tmp : map.get(s)){\n\t\t\tsum += minCost(tmp);\n\t\t}\n\n\t\tdp.put(s, price.get(s) == null ? sum : Math.min(sum,price.get(s)));\n\n\t\treturn dp.get(s);\n\t}\n}", "sampled": "import java.util.*;\n\npublic class Main {\n    static Map<String, Integer> itemPrice;\n    static Map<String, List<String>> recipes;\n    static Map<String, Integer> memo;\n    \n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        \n        while (true) {\n            int n = sc.nextInt();\n            if (n == 0) break;\n            \n            itemPrice = new HashMap<>();\n            recipes = new HashMap<>();\n            memo = new HashMap<>();\n            \n            for (int i = 0; i < n; i++) {\n                String name = sc.next();\n                int price = sc.nextInt();\n                itemPrice.put(name, price);\n            }\n            \n            int m = sc.nextInt();\n            for (int i = 0; i < m; i++) {\n                String output = sc.next();\n                int k = sc.nextInt();\n                List<String> inputs = new ArrayList<>();\n                for (int j = 0; j < k; j++) {\n                    inputs.add(sc.next());\n                }\n                recipes.put(output, inputs);\n            }\n            \n            String target = sc.next();\n            System.out.println(getMinCost(target));\n        }\n        \n        sc.close();\n    }\n    \n    static int getMinCost(String item) {\n        if (memo.containsKey(item)) {\n            return memo.get(item);\n        }\n        \n        int buyPrice = itemPrice.get(item);\n        int minCost = buyPrice;\n        \n        if (recipes.containsKey(item)) {\n            List<String> ingredients = recipes.get(item);\n            int craftCost = 0;\n            for (String ingredient : ingredients) {\n                craftCost += getMinCost(ingredient);\n            }\n            minCost = Math.min(minCost, craftCost);\n        }\n        \n        memo.put(item, minCost);\n        return minCost;\n    }\n}\n", "perturbed_sampled": ["import java.util.*; public  List<String>> recipes; static  void main(String[] args) { Scanner  =    { String name = sc.next(); int price =  (int i = 0; i < m; i++) { String output =  List<String> inputs = new   inputs); } String target = sc.next(); System.out.println(getMinCost(target)); } sc.close();  (recipes.containsKey(item)) { List<String> ingredients = recipes.get(item); int craftCost = 0; for (String ingredient  getMinCost(ingredient); } minCost = Math.min(minCost, craftCost); }  }"], "perturbed_original": ["import java.util.*; public class Main{ public static void main(String[] args){ Scanner sc = new Scanner(System.in); while(true){ int n = sc.nextInt(); if(n == 0) break; price = new HashMap<String,Integer>(); while(n--  =  s =    null)  return dp.get(s); int  :  dp.put(s, price.get(s) ==  return dp.get(s); } }"], "original_ll": -0.7359888553619385, "sampled_ll": -0.5192212462425232, "all_perturbed_sampled_ll": [-2.802579641342163], "all_perturbed_original_ll": [-2.2937512397766113], "perturbed_sampled_ll": -2.802579641342163, "perturbed_original_ll": -2.2937512397766113, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "while True:\n  count = int(input())\n  if count == 0: break \n  thing,money=[],[]\n  for i in range(count):\n    hoge = map(str,raw_input().split())\n    t = int(hoge[1])\n    thing.append(hoge[0])\n    money.append(t)\n  count = int(input())\n  if count == 0:\n    hoge = raw_input()\n    if hoge not in thing:\n      print 0\n      continue\n    t = thing.index(hoge)\n    print money[t]\n  else:\n    for i in range(count):\n      hoge = map(str,raw_input().split())\n      if hoge[0] not in thing:\n        print 0\n      t = int(hoge[1])\n      x,y = 2,0\n      for j in range(t):\n        r = thing.index(hoge[x])\n        y += money[r]\n        x+=1\n      e = thing.index(hoge[0])\n      money[e]= y\n    g = raw_input()\n    ans = thing.index(g)\n    print money[ans]", "sampled": "import sys\nfrom collections import defaultdict\n\ndef solve():\n    while True:\n        n = int(input())\n        if n == 0:\n            break\n        \n        # Read items and their prices\n        prices = {}\n        for _ in range(n):\n            line = input().split()\n            item_name = line[0]\n            price = int(line[1])\n            prices[item_name] = price\n        \n        # Read recipes\n        m = int(input())\n        recipes = {}\n        for _ in range(m):\n            line = input().split()\n            output_item = line[0]\n            k = int(line[1])\n            ingredients = line[2:2+k]\n            recipes[output_item] = ingredients\n        \n        # Read target item\n        target = input().strip()\n        \n        # Memoization for minimum cost\n        memo = {}\n        \n        def min_cost(item):\n            if item in memo:\n                return memo[item]\n            \n            # Option 1: Buy directly\n            buy_cost = prices[item]\n            \n            # Option 2: Craft using recipe (if available)\n            if item in recipes:\n                craft_cost = 0\n                for ingredient in recipes[item]:\n                    craft_cost += min_cost(ingredient)\n                result = min(buy_cost, craft_cost)\n            else:\n                result = buy_cost\n            \n            memo[item] = result\n            return result\n        \n        print(min_cost(target))\n\nsolve()\n", "perturbed_sampled": ["import  def  0: break # Read items  {}  = input().split() item_name = line[0]  m = int(input())  in range(m): line = input().split() output_item  target item target   in memo: return memo[item] # Option  prices[item] # Option 2: Craft using recipe (if available) if item in recipes: craft_cost = 0  =  result print(min_cost(target)) solve()"], "perturbed_original": ["while True: count = 0<extra_id_5>j<extra_id_6>= 1 if hoge[1] ==<extra_id_7>0:noge[0] = 1,0<extra_id_8>= 2<extra_id_9>g<extra_id_10>= 0<extra_id_11>x,y = 1,0<extra_id_12>o = 1<extra_id_13>1<extra_id_14>=<extra_id_15>.<extra_id_16> break thing,money=[],[] for  map(str,raw_input().split()) t = int(hoge[1]) thing.append(hoge[0]) money.append(t) count =  hoge  i in range(count): hoge = map(str,raw_input().split()) if  x,y = 2,0 for j  y += money[r]  y g =  money[ans]"], "original_ll": -1.3456403017044067, "sampled_ll": -0.8778930902481079, "all_perturbed_sampled_ll": [-4.381080150604248], "all_perturbed_original_ll": [-2.6970460414886475], "perturbed_sampled_ll": -4.381080150604248, "perturbed_original_ll": -2.6970460414886475, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "#include <stdio.h>\n#include <string.h>\n\n#define MAX_PRIME\t(1000000)\n#define IS_PRIME(n)\t(prime[j]==0?1:0)\n\nint prime[MAX_PRIME + 1];\nint fare[MAX_PRIME + 1];\nint fare_next[MAX_PRIME + 1];\n\n\nvoid make_prime(void)\n{\n    int i;\n    int j;\n    int n;\n    int c;\n    \n    for (i = 2; i * i <= MAX_PRIME; i++){\n        if (prime[i] == 0){\n            for (j = i * 2; j <= MAX_PRIME; j += i){\n\t\t\t\tprime[j] = 1;\n            }\n        }\n    }\n}\n\n\nint main(void)\n{\n\tint n, x;\n\tint price[30];\n\tint i, j, k;\n\t\n\tmake_prime();\n\t\n\twhile (1){\n\t\tscanf(\"%d%d\", &n, &x);\n\t\tif (n == 0 && x == 0){\n\t\t\tbreak;\n\t\t}\n\t\t\n\t\tfor (i = 0; i < n; i++){\n\t\t\tscanf(\"%d\", &price[i]);\n\t\t}\n\t\t\n\t\tmemset(fare_next, 0, sizeof(fare_next));\n\t\tfare_next[0] = 1;\n\t\tfor (i = 0; i < n; i++){\n\n\t\t\tmemcpy(fare, fare_next, sizeof(fare_next));\n\t\t\tfor (j = price[i]; j <= x; j += price[i]){\n\t\t\t\tfor (k = 0; k <= x; k++){\n\t\t\t\t\tif (fare[k] != 0){\n\t\t\t\t\t\tif (k + j <= x){\n\t\t\t\t\t\t\tfare_next[k + j] = 1;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tmemcpy(fare, fare_next, sizeof(fare_next));\n\t\t\n//for (i = 1; i <= x; i++){\n//\tprintf(\"[%d=%d]\", i, fare[i]);\n//}\n\n\t\tfor (i = x; i >= 1; i--){\n\t\t\tif (fare[i] != 0 && prime[i] == 0){\n\t\t\t\tprintf(\"%d\\n\", i);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (i == 0){\n\t\t\tprintf(\"NA\\n\");\n\t\t}\n\t}\n\treturn (0);\n}", "sampled": "#include <stdio.h>\n#include <string.h>\n#include <stdbool.h>\n\nint gcd(int a, int b) {\n    while (b != 0) {\n        int temp = b;\n        b = a % b;\n        a = temp;\n    }\n    return a;\n}\n\nbool isNotDivisibleByAny(int num) {\n    if (num <= 1) return false;\n    for (int i = 2; i * i <= num; i++) {\n        if (num % i == 0) return false;\n    }\n    return true;\n}\n\nint main() {\n    int n, x;\n    \n    while (scanf(\"%d %d\", &n, &x) == 2) {\n        if (n == 0 && x == 0) break;\n        \n        int v[30];\n        for (int i = 0; i < n; i++) {\n            scanf(\"%d\", &v[i]);\n        }\n        \n        bool *possible = (bool *)calloc(x + 1, sizeof(bool));\n        possible[0] = true;\n        \n        for (int i = 0; i < n; i++) {\n            for (int j = v[i]; j <= x; j++) {\n                if (possible[j - v[i]]) {\n                    possible[j] = true;\n                }\n            }\n        }\n        \n        int result = -1;\n        for (int i = x; i >= 1; i--) {\n            if (possible[i]) {\n                bool divisible = false;\n                for (int d = 2; d <= i; d++) {\n                    if (i % d == 0) {\n                        divisible = true;\n                        break;\n                    }\n                }\n                if (!divisible && i > 1) {\n                    result = i;\n                    break;\n                }\n            }\n        }\n        \n        if (result == -1) {\n            printf(\"NA\\n\");\n        } else {\n            printf(\"%d\\n\", result);\n        }\n        \n        free(possible);\n    }\n    \n    return 0;\n}\n", "perturbed_sampled": ["#include <stdio.h> #include <string.h> #include  = a % b; a = temp; } return a; } bool isNotDivisibleByAny(int num) { if (num  i * i <=  % i == 0)  int n, x; while   0 && x == 0) break; int  i++)  = true; for (int i = 0; i < n; i++) { for (int j  = true; } } } int  d <= i; d++) { if  { divisible  if (!divisible && i >  { printf(\"%d\\n\", result); } free(possible); } return 0; }"], "perturbed_original": ["#include <stdio.h>  prime[MAX_PRIME + 1]; int fare[MAX_PRIME + 1]; int fare_next[MAX_PRIME + 1]; void make_prime(void) { int i; int  i * i <= MAX_PRIME; i++){ if (prime[i] ==  * 2; j <= MAX_PRIME;  1; }  { int n,  j,  == 0 && x == 0){  0; i < n; i++){ scanf(\"%d\",  x; j += price[i]){ for (k = 0;  (fare[k] !=  <= x){  } } }  // printf(\"[%d=%d]\", i, fare[i]);  && prime[i]   0){ printf(\"NA\\n\"); } } return (0); }"], "original_ll": -0.8922199010848999, "sampled_ll": -0.48573121428489685, "all_perturbed_sampled_ll": [-2.952051877975464], "all_perturbed_original_ll": [-2.8517770767211914], "perturbed_sampled_ll": -2.952051877975464, "perturbed_original_ll": -2.8517770767211914, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "\nimport java.io.IOException;\nimport java.util.Arrays;\nimport java.util.Scanner;\n\npublic class Main {\n\n\tpublic static void main(String[] args) throws IOException {\n\t\tnew Main().run();\n\t}\n\n\tprivate void run() throws IOException {\n\t\tScanner scanner = new Scanner(System.in);\n\t\tint MAX = 1000000;\n\t\tboolean[] prime = new boolean[MAX + 1];\n\t\tfor (int i = 4; i <= MAX; i += 2) {\n\t\t\tprime[i] = true;\n\t\t}\n\t\tfor (int i = 3; i <= Math.sqrt(MAX); i += 2) {\n\t\t\tif (!prime[i]) {\n\t\t\t\tfor (int j = i * 3; j <= MAX; j += i * 2) {\n\t\t\t\t\tprime[j] = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\twhile (true) {\n\t\t\tint n = scanner.nextInt();\n\t\t\tint m = scanner.nextInt();\n\t\t\tif ((n | m) == 0)\n\t\t\t\tbreak;\n\t\t\tint[] a = new int[n];\n\t\t\tint min = Integer.MAX_VALUE;\n\t\t\tboolean[] f = new boolean[m + 1];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tint s = scanner.nextInt();\n\t\t\t\tmin = Math.min(s, min);\n\t\t\t\ta[i] = s;\n\t\t\t\tfor (int j = s; j <= m; j += s) {\n\t\t\t\t\tf[j] = true;\n\t\t\t\t}\n\t\t\t}\n\t\t\tArrays.sort(a);\n\t\t\tint max = 0;\n\t\t\tfor (int i = min; i <= m; i++) {\n\t\t\t\tif (!f[i])\n\t\t\t\t\tfor (int j = 0; j < n; j++) {\n\t\t\t\t\t\tif (i - a[j] >= 0 && f[i - a[j]]) {\n\t\t\t\t\t\t\tf[i] = true;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\tif (f[i] && !prime[i])\n\t\t\t\t\tmax = i;\n\t\t\t}\n\t\t\tSystem.out.println(max == 0 ? \"NA\" : max);\n\n\t\t}\n\n\t}\n}", "sampled": "import java.util.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        \n        while (true) {\n            int n = sc.nextInt();\n            int x = sc.nextInt();\n            \n            if (n == 0 && x == 0) break;\n            \n            int[] prices = new int[n];\n            for (int i = 0; i < n; i++) {\n                prices[i] = sc.nextInt();\n            }\n            \n            // Find all possible sums up to budget x\n            boolean[] possible = new boolean[x + 1];\n            possible[0] = true;\n            \n            for (int i = 0; i < n; i++) {\n                for (int j = prices[i]; j <= x; j++) {\n                    if (possible[j - prices[i]]) {\n                        possible[j] = true;\n                    }\n                }\n            }\n            \n            // Find the maximum sum that is not divisible by any number from 2 to itself-1\n            int result = -1;\n            for (int sum = x; sum >= 2; sum--) {\n                if (possible[sum] && isPrime(sum)) {\n                    result = sum;\n                    break;\n                }\n            }\n            \n            if (result == -1) {\n                System.out.println(\"NA\");\n            } else {\n                System.out.println(result);\n            }\n        }\n        \n        sc.close();\n    }\n    \n    private static boolean isPrime(int num) {\n        if (num < 2) return false;\n        if (num == 2) return true;\n        if (num % 2 == 0) return false;\n        \n        for (int i = 3; i * i <= num; i += 2) {\n            if (num % i == 0) return false;\n        }\n        return true;\n    }\n}\n", "perturbed_sampled": ["import  args)  break; int[] prices = new  0; i <  all possible sums up to budget x boolean[] possible = new boolean[x + 1]; possible[0] =  Find the maximum sum that is not divisible by any number from 2 to  for (int  (possible[sum] &&  break; } }  System.out.println(\"NA\"); } else { System.out.println(result); }  boolean isPrime(int num) { if (num <  ==  %  for (int i =  num; i += 2) { if (num % i == 0) return false; } return true; } }"], "perturbed_original": [" java.util.Scanner; public class Main { public static void main(String[]  run() throws IOException { Scanner scanner = new Scanner(System.in);  + 1]; for (int i = 4; i <= MAX; i += 2) { prime[i]  i = 3; i  { if (!prime[i]) { for (int   prime[j] = true; } } }  = scanner.nextInt();  f  for  < n; i++)  min = Math.min(s,  (int j = s;  s)    0;  if (i - a[j] >= 0 && f[i - a[j]]) { f[i] = true; break;    }"], "original_ll": -0.6422756314277649, "sampled_ll": -0.48780956864356995, "all_perturbed_sampled_ll": [-2.7863714694976807], "all_perturbed_original_ll": [-2.732485055923462], "perturbed_sampled_ll": -2.7863714694976807, "perturbed_original_ll": -2.732485055923462, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "from array import array\nPRIME_MAX = 1000001\nisPrime = array('b', [1] * PRIME_MAX)\nisPrime[0] = 0\nisPrime[1] = 0\nfor i in xrange(2, PRIME_MAX):\n\tif not isPrime[i]: continue\n\tfor j in xrange(i << 1, PRIME_MAX, i):\n\t\tisPrime[j] = 0\nwhile True:\n\tn, x = map(int, raw_input().split())\n\tif n == x == 0: break\n\tmenu = [input() for i in xrange(n)]\n\tresult = 0\n\texists = set()\n\texists.add(0)\n\tfor i in xrange(x + 1):\n\t\tif i in exists:\n\t\t\texists.remove(i)\n\t\t\tfor v in menu:\n\t\t\t\texists.add(i + v)\n\t\t\tif isPrime[i]:\n\t\t\t\tresult = i\n\tif result:\n\t\tprint result\n\telse:\n\t\tprint \"NA\"", "sampled": "import math\nfrom functools import reduce\n\ndef gcd(a, b):\n    while b:\n        a, b = b, a % b\n    return a\n\ndef solve(n, budget, prices):\n    # Dynamic programming to find all possible sums\n    possible = [False] * (budget + 1)\n    possible[0] = True\n    \n    for price in prices:\n        for total in range(budget, price - 1, -1):\n            if possible[total - price]:\n                possible[total] = True\n    \n    # Find the largest sum that is not divisible by all numbers from 2 to sum\n    for total in range(budget, 0, -1):\n        if not possible[total]:\n            continue\n        \n        # Check if total is not divisible by any number from 2 to total-1\n        is_prime_like = True\n        for divisor in range(2, int(math.sqrt(total)) + 1):\n            if total % divisor == 0:\n                is_prime_like = False\n                break\n        \n        if is_prime_like and total > 1:\n            return total\n    \n    return \"NA\"\n\ndef is_not_divisible_by_any(num):\n    # A number is not divisible by any number except 1 and itself if it's prime\n    if num <= 1:\n        return False\n    if num == 2:\n        return True\n    if num % 2 == 0:\n        return False\n    for i in range(3, int(math.sqrt(num)) + 1, 2):\n        if num % i == 0:\n            return False\n    return True\n\ndef solve2(n, budget, prices):\n    # Dynamic programming to find all possible sums\n    possible = set([0])\n    \n    for price in prices:\n        new_possible = set()\n        for p in possible:\n            amount = p\n            while amount + price <= budget:\n                amount += price\n                new_possible.add(amount)\n        possible.update(new_possible)\n    \n    # Find the largest sum that is prime\n    for total in range(budget, 1, -1):\n        if total in possible and is_not_divisible_by_any(total):\n            return total\n    \n    return \"NA\"\n\nwhile True:\n    line = input().split()\n    n, x = int(line[0]), int(line[1])\n    \n    if n == 0 and x == 0:\n        break\n    \n    prices = []\n    for _ in range(n):\n        prices.append(int(input()))\n    \n    print(solve2(n, x, prices))\n", "perturbed_sampled": ["import  for price in  price - 1, -1): if possible[total -  Find the largest sum that is not divisible by all numbers from 2 to sum for total in  possible[total]: continue  not divisible by any number   False break  \"NA\" def is_not_divisible_by_any(num): # A  and itself if it's prime   return True if num % 2 == 0: return False  num % i  True def solve2(n,  sums possible = set([0]) for price  for p in   amount +=  the largest sum  in range(budget, 1, -1): if total in possible and is_not_divisible_by_any(total): return total return \"NA\" while True: line = input().split() n, x = int(line[0]), int(line[1]) if n  prices))"], "perturbed_original": ["from array import array PRIME_MAX = 1000001 isPrime = array('b', [1] * PRIME_MAX) isPrime[0] = 0   PRIME_MAX, i):  n, x =  x ==  result =  for i in  v in menu:  result = i if  \"NA\""], "original_ll": -1.0645134449005127, "sampled_ll": -0.7628482580184937, "all_perturbed_sampled_ll": [-3.316451072692871], "all_perturbed_original_ll": [-3.1834557056427], "perturbed_sampled_ll": -3.316451072692871, "perturbed_original_ll": -3.1834557056427, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "#include<stdio.h>\n\tint w,h,xd[]={1,0,-1},p,u[20][20];\n\tvoid ret(int x,int y){\n\t\tint i,s=x;\n\t\tif(h-1<=y)\n\t\t\tp++;\n\t\telse if(u[y][x]==2)\n\t\t\tret(x,y+2);\n\t\telse if(u[y][x]==0){\n\t\t\ty++;\n\t\t\tfor(i=0;i<3;i++){\n\t\t\t\tx=s+xd[i];\n\t\t\t\tif(x>=0&&x<=w-1){\n\t\t\t\t\tif(u[y][x]==2&&i==1)\n\t\t\t\t\t\tret(x,y+2);\n\t\t\t\t\telse if(u[y][x]==0)\n\t\t\t\t\t\tret(x,y);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tint main(){\n\t\tint i,j,x,y;\n\t\twhile(scanf(\"%d %d\",&w,&h),w||h){\n\t\t\tp=0;\n\t\t\tfor(i=0;i<h;i++){\n\t\t\t\tfor(j=0;j<w-1;j++)\n\t\t\t\tscanf(\"%d \",&u[i][j]);\n\t\t\t\tscanf(\"%d\",&u[i][w-1]);\n\t\t\t}\n\t\t\tfor(i=0;i<w;i++){\n\t\t\t\tif(u[0][i]==0){\n\t\t\t\t\tx=i;\n\t\t\t\t\ty=0;\n\t\t\t\t\tret(x,y);\n\t\t\t\t}\n\t\t\t\telse if(u[0][i]==2){\n\t\t\t\t\tx=i;\n\t\t\t\t\ty=2;\n\t\t\t\t\tret(x,y);\n\t\t\t\t}\n\t\t\t}\n\t\t\tprintf(\"%d\\n\",p);\n\t\t}\n\t\treturn 0;\n\t}", "sampled": "#include <stdio.h>\n#include <string.h>\n\nint X, Y;\nint course[16][16];\nlong long dp[16][16];\n\nlong long countPaths() {\n    memset(dp, 0, sizeof(dp));\n    \n    // Initialize first row (y=1)\n    for (int x = 1; x <= X; x++) {\n        if (course[x][1] != 1) {  // Not an obstacle\n            dp[x][1] = 1;\n        }\n    }\n    \n    // Fill the dp table\n    for (int y = 1; y < Y; y++) {\n        for (int x = 1; x <= X; x++) {\n            if (dp[x][y] == 0) continue;\n            \n            if (course[x][y] == 2) {  // Jump platform\n                // Jump to (x, y+2)\n                if (y + 2 <= Y) {\n                    if (course[x][y+2] != 1) {\n                        dp[x][y+2] += dp[x][y];\n                    }\n                } else {\n                    // Jump goes beyond Y, count as reaching goal\n                    dp[x][Y] += dp[x][y];\n                }\n            } else {  // Normal cell (0)\n                // Move to (x-1, y+1), (x, y+1), (x+1, y+1)\n                for (int dx = -1; dx <= 1; dx++) {\n                    int nx = x + dx;\n                    int ny = y + 1;\n                    \n                    if (nx < 1 || nx > X) continue;\n                    \n                    if (ny > Y) {\n                        // Reached goal\n                        dp[x][Y] += dp[x][y];\n                    } else {\n                        if (course[nx][ny] == 1) {  // Obstacle\n                            continue;\n                        }\n                        if (course[nx][ny] == 2) {  // Jump platform\n                            // Can only enter jump platform from directly above (dx == 0)\n                            if (dx == 0) {\n                                dp[nx][ny] += dp[x][y];\n                            }\n                        } else {  // Normal cell\n                            dp[nx][ny] += dp[x][y];\n                        }\n                    }\n                }\n            }\n        }\n    }\n    \n    // Sum all paths that reached Y\n    long long total = 0;\n    for (int x = 1; x <= X; x++) {\n        total += dp[x][Y];\n    }\n    \n    return total;\n}\n\nint main() {\n    while (1) {\n        scanf(\"%d %d\", &X, &Y);\n        if (X == 0 && Y == 0) break;\n        \n        for (int y = 1; y <= Y; y++) {\n            for (int x = 1; x <= X; x++) {\n                scanf(\"%d\", &course[x][y]);\n            }\n        }\n        \n        printf(\"%lld\\n\", countPaths());\n    }\n    \n    return 0;\n}\n", "perturbed_sampled": ["#include <stdio.h> #include  course[16][16]; long long dp[16][16]; long long countPaths() { memset(dp,    != 1) {  // Fill the dp    == 0) continue; if (course[x][y] ==  // Jump to (x, y+2) if (y + 2 <= Y)  { dp[x][y+2] += dp[x][y]; } }  beyond  Move to   -1; dx <= 1; dx++)   dp[x][Y] += dp[x][y]; }  1)   Can only enter jump platform from directly  (dx == 0) { dp[nx][ny] +=   } }  long total = 0; for (int x = 1; x <= X; x++) { total  } int  scanf(\"%d %d\", &X, &Y); if (X == 0 && Y  y = 1; y <=  x = 1; x  &course[x][y]); } }  }"], "perturbed_original": ["#include<stdio.h> int w,h,xd[]={1,0,-1},p,u[20][20]; void ret(int  p++;  y++; for(i=0;i<3;i++){ x=s+xd[i]; if(x>=0&&x<=w-1){ if(u[y][x]==2&&i==1) ret(x,y+2); else  }   }  } } printf(\"%d\\n\",p); } return 0; }"], "original_ll": -1.0239510536193848, "sampled_ll": -0.7244669198989868, "all_perturbed_sampled_ll": [-2.677536725997925], "all_perturbed_original_ll": [-2.681955099105835], "perturbed_sampled_ll": -2.677536725997925, "perturbed_original_ll": -2.681955099105835, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import java.util.Scanner;\n\npublic class Main {\n\n\tstatic int H,W;\n\tstatic int[][] field;\n\tstatic int[][] dp;\n\tpublic static void main(String[] args) {\n\t\tScanner cin = new Scanner(System.in);\n\t\tfor(;;){\n\t\t\tW=cin.nextInt();\n\t\t\tH=cin.nextInt();\n\t\t\tif(W+H==0)break;\n\t\t\tfield=new int[H+2][W];\n\t\t\tdp=new int[H+2][W];\n\t\t\tfor(int i=0;i<H;i++){\n\t\t\t\tfor(int j=0;j<W;j++){\n\t\t\t\t\tfield[i][j]=cin.nextInt();\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(int i=0;i<W;i++){\n\t\t\t\tif(field[0][i]==0)dp[0][i]=1;\n\t\t\t}\n\t\t\tfor(int i=0;i<H;i++){\n\t\t\t\tfor(int j=0;j<W;j++){\n\t\t\t\t\tif(field[i][j]==0){\n\t\t\t\t\t\tif(i!=H-1){\n\t\t\t\t\t\t\tfor(int k=-1;k<=1;k++){\n\t\t\t\t\t\t\t\tif(j+k<0||j+k>=W)continue;\n\t\t\t\t\t\t\t\tif(field[i+1][j+k]==1)continue;\n\t\t\t\t\t\t\t\tif(k!=0&&field[i+1][j+k]==2)continue;\n\t\t\t\t\t\t\t\tdp[i+1][j+k]+=dp[i][j];\n\t\t\t\t\t\t\t}\t\t\t\t\t\t\t\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse{\n\t\t\t\t\t\t\tdp[i+1][j]+=dp[i][j];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse if(field[i][j]==2){\n\t\t\t\t\t\tdp[i+2][j]+=dp[i][j];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tint ans=0;\n\t\t\tfor(int i=H;i<H+2;i++){\n\t\t\t\tfor(int j=0;j<W;j++){\n\t\t\t\t\tans+=dp[i][j];\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(ans);\n\t\t\t\n\t\t}\n\t}\n\n}", "sampled": "import java.util.*;\n\npublic class Main {\n    static int X, Y;\n    static int[][] course;\n    static long[][] memo;\n    \n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        \n        while (true) {\n            X = sc.nextInt();\n            Y = sc.nextInt();\n            \n            if (X == 0 && Y == 0) break;\n            \n            course = new int[X + 1][Y + 1];\n            memo = new long[X + 1][Y + 1];\n            \n            for (int y = 1; y <= Y; y++) {\n                for (int x = 1; x <= X; x++) {\n                    course[x][y] = sc.nextInt();\n                    memo[x][y] = -1;\n                }\n            }\n            \n            long total = 0;\n            for (int x = 1; x <= X; x++) {\n                if (course[x][1] != 1) {\n                    total += dfs(x, 1);\n                }\n            }\n            \n            System.out.println(total);\n        }\n        \n        sc.close();\n    }\n    \n    static long dfs(int x, int y) {\n        if (y >= Y) {\n            return 1;\n        }\n        \n        if (memo[x][y] != -1) {\n            return memo[x][y];\n        }\n        \n        long count = 0;\n        \n        if (course[x][y] == 2) {\n            // Jump platform - skip to y+2\n            int nextY = y + 2;\n            if (nextY >= Y) {\n                count = 1;\n            } else if (course[x][nextY] != 1) {\n                if (course[x][nextY] == 2) {\n                    count = dfs(x, nextY);\n                } else {\n                    count = dfs(x, nextY);\n                }\n            }\n        } else {\n            // Normal movement to y+1\n            int nextY = y + 1;\n            \n            // Move to (x-1, y+1)\n            if (x - 1 >= 1 && course[x - 1][nextY] != 1) {\n                if (course[x - 1][nextY] == 2) {\n                    // Can't enter jump platform from diagonal\n                } else {\n                    count += dfs(x - 1, nextY);\n                }\n            }\n            \n            // Move to (x, y+1)\n            if (course[x][nextY] != 1) {\n                count += dfs(x, nextY);\n            }\n            \n            // Move to (x+1, y+1)\n            if (x + 1 <= X && course[x + 1][nextY] != 1) {\n                if (course[x + 1][nextY] == 2) {\n                    // Can't enter jump platform from diagonal\n                } else {\n                    count += dfs(x + 1, nextY);\n                }\n            }\n        }\n        \n        memo[x][y] = count;\n        return count;\n    }\n}\n", "perturbed_sampled": ["  static int[][] course; static long[][]  args) { Scanner sc  Y == 0) break; course =  1]; memo = new  for (int y = 1;  for   total = 0;  x <= X;  dfs(x, 1); } } System.out.println(total); }  x, int y)   (memo[x][y] != -1) {  == 2) {  to y+2 int nextY = y + 2; if (nextY >= Y) { count = 1; } else if (course[x][nextY] != 1) { if (course[x][nextY] ==  count  int nextY = y +  y+1) if (x  course[x  == 2)  platform from diagonal } else { count += dfs(x - 1, nextY); } } //  count   X &&  //  count += dfs(x + 1, nextY); }  return count; } }"], "perturbed_original": ["import java.util.Scanner; public class Main { static int H,W; static int[][] field; static <extra_id_4>)<extra_id_5>f<extra_id_6>D .<extra_id_7>) D ; D.X cin = new Scanner(System.in);   } for(int i=0;i<W;i++){ if(field[0][i]==0)dp[0][i]=1; } for(int   if(field[i][j]==2){ dp[i+2][j]+=dp[i][j];  for(int i=H;i<H+2;i++){ for(int  } } }"], "original_ll": -0.6558745503425598, "sampled_ll": -0.4935590624809265, "all_perturbed_sampled_ll": [-2.7665061950683594], "all_perturbed_original_ll": [-2.6992928981781006], "perturbed_sampled_ll": -2.7665061950683594, "perturbed_original_ll": -2.6992928981781006, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "while 1:\n\tX,Y = map(int,raw_input().split())\n\tif X == 0: break\n\tA = [[0]+map(int,raw_input().split())+[0] for i in range(Y)]\n\tS = [[0]*(X+2) for i in range(Y)]\n\tfor x in range(1,X+1): S[0][x] = 1 if A[0][x] != 1 else 0\n\tfor y in range(1,Y):\n\t\tfor x in range(1,X+1):\n\t\t\tif A[y][x] == 0:\n\t\t\t\tfor i in range(-1,2):\n\t\t\t\t\tS[y][x] += (S[y-1][x-i] if A[y-1][x-i] == 0 else 0)\n\t\t\tif A[y][x] == 2:\n\t\t\t\tS[y][x] += S[y-1][x-1]\n\t\t\t\tif y+2 < Y and A[y+2][x] != 1:\n\t\t\t\t\tS[y+2][x] = S[y][x]\n\tans = 0\n\tfor x in range(1,X+1):\n\t\tans += S[Y-1][x] + (S[Y-2][x] if A[Y-2][x] == 2 else 0)\n\tprint ans", "sampled": "import sys\n\ndef solve(X, Y, grid):\n    # dp[y][x] = number of ways to reach position (x, y)\n    dp = [[0] * X for _ in range(Y + 1)]\n    \n    # Initialize starting positions at y=0 (0-indexed, which is y=1 in problem)\n    for x in range(X):\n        if grid[0][x] != 1:  # not an obstacle\n            dp[0][x] = 1\n    \n    # Process each row\n    for y in range(Y):\n        for x in range(X):\n            if dp[y][x] == 0:\n                continue\n            \n            # Check if current position has a jump platform\n            if grid[y][x] == 2:\n                # Jump to (x, y+2)\n                target_y = y + 2\n                if target_y < Y:\n                    if grid[target_y][x] != 1:  # not an obstacle\n                        dp[target_y][x] += dp[y][x]\n                else:\n                    # Reached beyond Y, count as completion\n                    # We need to track completions separately\n                    pass\n            else:\n                # Normal movement to (x-1, y+1), (x, y+1), (x+1, y+1)\n                target_y = y + 1\n                if target_y < Y:\n                    # Move to (x-1, y+1)\n                    if x - 1 >= 0:\n                        if grid[target_y][x-1] == 2:\n                            # Can't enter jump platform from diagonal\n                            pass\n                        elif grid[target_y][x-1] != 1:\n                            dp[target_y][x-1] += dp[y][x]\n                    \n                    # Move to (x, y+1)\n                    if grid[target_y][x] != 1:\n                        dp[target_y][x] += dp[y][x]\n                    \n                    # Move to (x+1, y+1)\n                    if x + 1 < X:\n                        if grid[target_y][x+1] == 2:\n                            # Can't enter jump platform from diagonal\n                            pass\n                        elif grid[target_y][x+1] != 1:\n                            dp[target_y][x+1] += dp[y][x]\n    \n    # Count paths that reach y >= Y\n    total = 0\n    \n    # Add paths from y = Y-1\n    for x in range(X):\n        if dp[Y-1][x] > 0:\n            if grid[Y-1][x] == 2:\n                # Jump from Y-1 goes to Y+1, which is >= Y\n                total += dp[Y-1][x]\n            else:\n                # Normal movement from Y-1 goes to Y, which is >= Y\n                total += dp[Y-1][x]\n    \n    # Add paths from y = Y-2 that jump\n    if Y >= 2:\n        for x in range(X):\n            if dp[Y-2][x] > 0 and grid[Y-2][x] == 2:\n                # Jump from Y-2 goes to Y, which is >= Y\n                # But we need to check if this was already counted\n                # Actually, when we process Y-2, we add to dp[Y][x] if Y < Y, which is false\n                # So we need to handle this separately\n                pass\n    \n    return total\n\n# Read input\nwhile True:\n    line = input().split()\n    X, Y = int(line[0]), int(line[1])\n    \n    if X == 0 and Y == 0:\n        break\n    \n    grid = []\n    for y in range(Y):\n        row = list(map(int, input().split()))\n        grid.append(row)\n    \n    # Re-implement with better logic\n    dp = [[0] * X for _ in range(Y + 2)]\n    \n    # Initialize\n    for x in range(X):\n        if grid[0][x] != 1:\n            dp[0][x] = 1\n    \n    for y in range(Y + 1):\n        for x in range(X):\n            if dp[y][x] == 0:\n                continue\n            \n            if y >= Y:\n                continue\n            \n            if grid[y][x] == 2:\n                # Jump\n                target_y = y + 2\n                if target_y <= Y:\n                    dp[target_y][x] += dp[y][x]\n            else:\n                # Normal move\n                target_y = y + 1\n                if target_y <= Y:\n                    for dx in [-1, 0, 1]:\n                        nx = x + dx\n                        if 0 <= nx < X:\n                            if target_y < Y:\n                                if grid[target_y][nx] == 2 and dx != 0:\n                                    continue\n                                if grid[target_y][nx] != 1:\n                                    dp[target_y][nx] += dp[y][x]\n                            else:\n                                dp[target_y][nx] += dp[y][x]\n    \n    result = sum(dp[Y])\n    print(result)\n", "perturbed_sampled": ["import sys def solve(X, Y, grid): # dp[y][x] = number of ways   for  # Initialize starting positions at y=0 (0-indexed, which is y=1 in problem) for x  1: #  1  dp[y][x] == 0:  platform  Jump  y  obstacle dp[target_y][x]  to  # Normal movement to  y+1) target_y = y + 1 if target_y < Y: # Move to (x-1, y+1) if   Can't enter jump platform from diagonal pass elif grid[target_y][x-1] != 1: dp[target_y][x-1] += dp[y][x] # Move to (x, y+1) if grid[target_y][x]   enter jump platform from diagonal pass  += dp[y][x]  paths from y = Y-1 for x  Y-1 goes to Y+1, which is >= Y  is >= Y total  from  if Y >= 2:  dp[Y-2][x]  2: # Jump from Y-2 goes to Y, which is   Y, which is false # So we need to handle this separately pass  while True: line = input().split() X,  grid = [] for  Re-implement  [[0] *  for x in range(X): if  1 for y in  y  == 2:  <= Y: dp[target_y][x]  move target_y  target_y  [-1, 0, 1]:  if 0 <= nx  2 and dx != 0: continue   dp[y][x] result = sum(dp[Y]) print(result)"], "perturbed_original": ["while 1: X,Y = map(int,raw_input().split()) if X ==  for i in range(Y)]   else 0 for y in   ==  == 2: S[y][x] += S[y-1][x-1] if  for x in range(1,X+1): ans += S[Y-1][x] + (S[Y-2][x]  0) print ans"], "original_ll": -0.9001911878585815, "sampled_ll": -0.80415940284729, "all_perturbed_sampled_ll": [-2.937408685684204], "all_perturbed_original_ll": [-2.5689022541046143], "perturbed_sampled_ll": -2.937408685684204, "perturbed_original_ll": -2.5689022541046143, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "#include <stdio.h>\n#include <math.h>\n\n#define EPS (1e-8)\n\ntypedef struct {\n\tdouble x,y;\n\tdouble angle;\n\tint r;\n\tint v;\n\tint arrive;\n} ufo_t;\n\nint N;\nufo_t ufo[100];\nint R;\n\ndouble get_dist(double mx,double my,double x,double y) {\n\treturn fabs(my*x-mx*y)/sqrt(my*my+mx*mx);\n}\n\nint main(void) {\n\tint i;\n\tint target;\n\tdouble target_dist;\n\tint count;\n\twhile(1) {\n\t\tscanf(\"%d%d\",&R,&N);\n\t\tif(R==0 && N==0)break;\n\t\tfor(i=0;i<N;i++) {\n\t\t\tscanf(\"%lf%lf%d%d\",\n\t\t\t\t&ufo[i].x,&ufo[i].y,&ufo[i].r,&ufo[i].v);\n\t\t\tufo[i].arrive=1;\n\t\t\tufo[i].angle=atan2(ufo[i].y,ufo[i].x);\n\t\t}\n\t\ttarget=0;\n\t\twhile(target>=0) {\n\t\t\tfor(i=0;i<N;i++) {\n\t\t\t\tif(R+EPS<sqrt(ufo[i].x*ufo[i].x+ufo[i].y*ufo[i].y)) {\n\t\t\t\t\tdouble prev_x,prev_y;\n\t\t\t\t\tprev_x=ufo[i].x;\n\t\t\t\t\tprev_y=ufo[i].y;\n\t\t\t\t\tufo[i].x-=ufo[i].v*cos(ufo[i].angle);\n\t\t\t\t\tufo[i].y-=ufo[i].v*sin(ufo[i].angle);\n\t\t\t\t\tif(prev_x*ufo[i].x<0)ufo[i].x=0;\n\t\t\t\t\tif(prev_y*ufo[i].y<0)ufo[i].y=0;\n\t\t\t\t}\n\t\t\t}\n\t\t\ttarget=-1;\n\t\t\ttarget_dist=1000*1000;\n\t\t\tfor(i=0;i<N;i++) {\n\t\t\t\tdouble dist;\n\t\t\t\tif(!ufo[i].arrive)continue;\n\t\t\t\tdist=sqrt(ufo[i].x*ufo[i].x+ufo[i].y*ufo[i].y);\n\t\t\t\tif(dist<target_dist+EPS && R+EPS<dist) {\n\t\t\t\t\ttarget_dist=dist;\n\t\t\t\t\ttarget=i;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(target<0)break;\n\t\t\tfor(i=0;i<N;i++) {\n\t\t\t\tif(sqrt(ufo[i].x*ufo[i].x+\n\t\t\t\t\tufo[i].y*ufo[i].y)<R+EPS)continue;\n\t\t\t\tif(get_dist(ufo[target].x,ufo[target].y,\n\t\t\t\t\t\tufo[i].x,ufo[i].y)<ufo[i].r+EPS &&\n\t\t\t\t\t\tufo[target].x*ufo[i].x>=0 &&\n\t\t\t\t\t\tufo[target].y*ufo[i].y>=0) {\n\t\t\t\t\tufo[i].arrive=0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcount=0;\n\t\tfor(i=0;i<N;i++) {\n\t\t\tif(ufo[i].arrive)count++;\n\t\t}\n\t\tprintf(\"%d\\n\",count);\n\t}\n\treturn 0;\n}", "sampled": "#include <stdio.h>\n#include <math.h>\n#include <stdbool.h>\n\n#define MAX_N 100\n#define INF 1e9\n\ntypedef struct {\n    double x, y;\n    double r;\n    double v;\n    bool destroyed;\n    bool entered;\n} UFO;\n\ndouble distance(double x, double y) {\n    return sqrt(x * x + y * y);\n}\n\ndouble distancePointToLine(double px, double py, double lx, double ly) {\n    if (lx == 0 && ly == 0) return INF;\n    double dot = px * lx + py * ly;\n    if (dot < 0) return INF;\n    double len = sqrt(lx * lx + ly * ly);\n    return fabs(px * ly - py * lx) / len;\n}\n\nint main() {\n    int R, N;\n    \n    while (scanf(\"%d %d\", &R, &N) == 2) {\n        if (R == 0 && N == 0) break;\n        \n        UFO ufos[MAX_N];\n        for (int i = 0; i < N; i++) {\n            scanf(\"%lf %lf %lf %lf\", &ufos[i].x, &ufos[i].y, &ufos[i].r, &ufos[i].v);\n            ufos[i].destroyed = false;\n            ufos[i].entered = false;\n        }\n        \n        int time = 1;\n        while (true) {\n            bool any_outside = false;\n            for (int i = 0; i < N; i++) {\n                if (ufos[i].destroyed || ufos[i].entered) continue;\n                \n                double dx = -ufos[i].x;\n                double dy = -ufos[i].y;\n                double len = sqrt(dx * dx + dy * dy);\n                dx /= len;\n                dy /= len;\n                \n                double curr_x = ufos[i].x + dx * ufos[i].v * time;\n                double curr_y = ufos[i].y + dy * ufos[i].v * time;\n                double dist = distance(curr_x, curr_y);\n                \n                if (dist > R) {\n                    any_outside = true;\n                    break;\n                }\n            }\n            \n            if (!any_outside) break;\n            \n            int target = -1;\n            double min_dist = INF;\n            \n            for (int i = 0; i < N; i++) {\n                if (ufos[i].destroyed || ufos[i].entered) continue;\n                \n                double dx = -ufos[i].x;\n                double dy = -ufos[i].y;\n                double len = sqrt(dx * dx + dy * dy);\n                dx /= len;\n                dy /= len;\n                \n                double curr_x = ufos[i].x + dx * ufos[i].v * time;\n                double curr_y = ufos[i].y + dy * ufos[i].v * time;\n                double dist = distance(curr_x, curr_y);\n                \n                if (dist > R && dist < min_dist) {\n                    min_dist = dist;\n                    target = i;\n                }\n            }\n            \n            if (target != -1) {\n                double dx = -ufos[target].x;\n                double dy = -ufos[target].y;\n                double len = sqrt(dx * dx + dy * dy);\n                dx /= len;\n                dy /= len;\n                \n                double target_x = ufos[target].x + dx * ufos[target].v * time;\n                double target_y = ufos[target].y + dy * ufos[target].v * time;\n                \n                for (int i = 0; i < N; i++) {\n                    if (ufos[i].destroyed || ufos[i].entered) continue;\n                    \n                    double dx2 = -ufos[i].x;\n                    double dy2 = -ufos[i].y;\n                    double len2 = sqrt(dx2 * dx2 + dy2 * dy2);\n                    dx2 /= len2;\n                    dy2 /= len2;\n                    \n                    double curr_x = ufos[i].x + dx2 * ufos[i].v * time;\n                    double curr_y = ufos[i].y + dy2 * ufos[i].v * time;\n                    \n                    double dist_to_laser = distancePointToLine(curr_x, curr_y, target_x, target_y);\n                    \n                    if (dist_to_laser <= ufos[i].r) {\n                        ufos[i].destroyed = true;\n                    }\n                }\n            }\n            \n            for (int i = 0; i < N; i++) {\n                if (ufos[i].destroyed || ufos[i].entered) continue;\n                \n                double dx = -ufos[i].x;\n                double dy = -ufos[i].y;\n                double len = sqrt(dx * dx + dy * dy);\n                dx /= len;\n                dy /= len;\n                \n                double curr_x = ufos[i].x + dx * ufos[i].v * time;\n                double curr_y = ufos[i].y + dy * ufos[i].v * time;\n                double dist = distance(curr_x, curr_y);\n                \n                if (dist <= R) {\n                    ufos[i].entered = true;\n                }\n            }\n            \n            time++;\n        }\n        \n        int count = 0;\n        for (int i = 0; i < N; i++) {\n            if (ufos[i].entered) count++;\n        }\n        \n        printf(\"%d\\n\", count);\n    }\n    \n    return 0;\n}\n", "perturbed_sampled": ["#include <stdio.h> #include <math.h> #include <stdbool.h> #define MAX_N  entered;  sqrt(x * x + y * y); } double distancePointToLine(double px,  == 0) return  * lx + py * ly; if (dot < 0) return INF;   - py * lx)  { int  &R, &N)  == 0 && N == 0) break; UFO ufos[MAX_N]; for (int   %lf  ufos[i].destroyed =  while (true) { bool  i = 0; i < N;  =  len; dy /= len;  ufos[i].y +  curr_y); if (dist > R) { any_outside =  = -1; double min_dist = INF; for (int  (ufos[i].destroyed || ufos[i].entered) continue; double   /=  dx * ufos[i].v * time; double curr_y = ufos[i].y +  double dist  >  { min_dist  }  -ufos[target].x; double  = sqrt(dx *   ufos[target].x + dx *  for (int i  i++) { if (ufos[i].destroyed  = -ufos[i].y; double len2 = sqrt(dx2 * dx2   * time; double curr_y = ufos[i].y + dy2 * ufos[i].v *  (dist_to_laser <= ufos[i].r) { ufos[i].destroyed  for (int i = 0; i < N; i++) { if (ufos[i].destroyed || ufos[i].entered) continue; double dx = -ufos[i].x; double dy =  len; dy /= len; double curr_x = ufos[i].x + dx  curr_y  ufos[i].v * time;  0; i < N; i++) { if (ufos[i].entered) count++; } printf(\"%d\\n\", count); } return 0; }"], "perturbed_original": ["   arrive;  ufo[100]; int R; double get_dist(double mx,double my,double x,double y)  int target; double target_dist; int  && N==0)break; for(i=0;i<N;i++) { scanf(\"%lf%lf%d%d\", &ufo[i].x,&ufo[i].y,&ufo[i].r,&ufo[i].v);  prev_y=ufo[i].y; ufo[i].x-=ufo[i].v*cos(ufo[i].angle); ufo[i].y-=ufo[i].v*sin(ufo[i].angle); if(prev_x*ufo[i].x<0)ufo[i].x=0; if(prev_y*ufo[i].y<0)ufo[i].y=0;  { double dist; if(!ufo[i].arrive)continue; dist=sqrt(ufo[i].x*ufo[i].x+ufo[i].y*ufo[i].y); if(dist<target_dist+EPS && R+EPS<dist) { target_dist=dist;  ufo[i].x,ufo[i].y)<ufo[i].r+EPS  ufo[i].arrive=0; } } }  printf(\"%d\\n\",count); } return 0; }"], "original_ll": -0.7960120439529419, "sampled_ll": -0.34076812863349915, "all_perturbed_sampled_ll": [-2.381490468978882], "all_perturbed_original_ll": [-1.7006639242172241], "perturbed_sampled_ll": -2.381490468978882, "perturbed_original_ll": -1.7006639242172241, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import java.util.Scanner;\n\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tScanner s = new Scanner(System.in);\n\t\tint r, n;\n\t\twhile ((r = s.nextInt()) != 0 && (n = s.nextInt()) != 0) {\n\t\t\tdouble[][] ufo = new double[n][6];  // x, y, r, v(, dis, fin_step)\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tfor (int j = 0; j < 4; j++)\n\t\t\t\t\tufo[i][j] = s.nextInt();\n\t\t\t\tufo[i][4] = Math.hypot(ufo[i][0], ufo[i][1]); // \u008b\u0097\u0097\u00a3\n\t\t\t\tufo[i][5] = Math.floor((Math.abs(ufo[i][4]) - r) / ufo[i][3]); // \u0090N\u0093\u00fc\u008e\u009e\u008a\u00d4\n\t\t\t}\n\n\t\t\tint[] st = new int[n];\n\t\t\tfor (int i = 0; i < n; i++)\tst[i] = 0;\n\t\t\t\n\t\t\tfor (int i = 0; i < n; i++) { // step\t\t\t\t\n\t\t\t\t // \u008d\u00c5\u0082\u00e0\u008b\u00df\u0082\u00a2UFO\u0082\u00f0\u0092T\u0082\u00b5\u0081A\u0093\u00af\u008e\u009e\u0082\u00c9\u0090N\u0093\u00fc\u0082\u00b5\u0082\u00bdUFO\u0082\u00c9\u0083}\u0081[\u0083N\n\t\t\t\tint near = -1;\n\t\t\t\tfor (int j = 0; j < n; j++) {\n\t\t\t\t\tif (st[j] != 0) continue; // \u008a\u00f9\u0082\u00c9\u0090N\u0093\u00fcor\u008c\u0082\u0092\u00c4\n\t\t\t\t\tif (ufo[j][5] < i) st[j] = 1;  // \u0090N\u0093\u00fc\u0082\u00b5\u0082\u00bd\n\t\t\t\t\telse if (near == -1 || ufo[near][4] > ufo[j][4])\n\t\t\t\t\t\tnear = j; // \u008d\u00c5\u0082\u00e0\u008b\u00df\u0082\u00a2UFO\n\t\t\t\t}\n\t\t\t\tif (near == -1) break;\n\t\t\t\tdouble x0 = ufo[near][0]; // \u008d\u00c5\u0082\u00e0\u008b\u00df\u0082\u00a2UFO\n\t\t\t\tdouble y0 = ufo[near][1];\n\n\t\t\t\t// UFO\u0082\u00f0\u008c\u0082\u0092\u00c4\n\t\t\t\tfor (int j = 0; j < n; j++) {\n\t\t\t\t\tif (st[j] != 0) continue; // \u008a\u00f9\u0082\u00c9\u0090N\u0093\u00fc\u0082\u00a9\u008c\u0082\u0092\u00c4\u008f\u00f3\u0091\u00d4\u0082\u00c8\u0082\u00e7\u0083X\u0083\u008b\u0081[\n\t\t\t\t\tdouble x1 = ufo[j][0];\n\t\t\t\t\tdouble y1 = ufo[j][1];\n\t\t\t\t\t\n\t\t\t\t\tif (y0 == 0) {\n\t\t\t\t\t\tif ((x0 >= 0 && x1 >= 0) || (x0 < 0 && x1 < 0)) // \u0093\u00af\u0082\u00b6\u008c\u00fc\u0082\u00ab\n\t\t\t\t\t\t\tif (Math.abs(y1) <= r) st[j] = 2; // \u008c\u0082\u0092\u00c4\n\t\t\t\t\t} else if (x0 == 0) {\n\t\t\t\t\t\tif ((y0 >= 0 && y1 >= 0) || (y0 < 0 && y1 < 0)) // \u0093\u00af\u0082\u00b6\u008c\u00fc\u0082\u00ab\n\t\t\t\t\t\t\tif (Math.abs(x1) <= r) st[j] = 2; // \u008c\u0082\u0092\u00c4\n\t\t\t\t\t} else {\n\t\t\t\t\t\tdouble a = y0 / x0; // \u008cX\u0082\u00ab\n\t\t\t\t\t\tif ((x0 >= 0 && x1 >= 0) || (x0 < 0 && x1 < 0)) // \u0093\u00af\u0082\u00b6\u008c\u00fc\u0082\u00ab\n\t\t\t\t\t\t\tif ((y0 >= 0 && y1 >= 0) || (y0 < 0 && y1 < 0))\n\t\t\t\t\t\t\t\tif (Math.abs(y1 - a * x1) <= r) st[j] = 2; // \u008c\u0082\u0092\u00c4\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tfor (int j = 0; j < n; j++) { // UFO\u0088\u00da\u0093\u00ae\n\t\t\t\t\tif (st[j] != 0) continue; // \u008a\u00f9\u0082\u00c9\u0090N\u0093\u00fc\u0082\u00a9\u008c\u0082\u0092\u00c4\u008f\u00f3\u0091\u00d4\u0082\u00c8\u0082\u00e7\u0083X\u0083\u008b\u0081[\n\t\t\t\t\tufo[j][4] -= ufo[j][3];\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tint sum = 0;\n\t\t\tfor (int j = 0; j < n; j++)\n\t\t\t\tif (st[j] == 1) sum++;\n\t\t\tSystem.out.println(sum);\n\t\t}\n\t}\n}", "sampled": "import java.util.*;\nimport java.io.*;\n\npublic class Main {\n    static class UFO {\n        double x, y;\n        double r;\n        double v;\n        boolean destroyed;\n        int id;\n        \n        UFO(double x, double y, double r, double v, int id) {\n            this.x = x;\n            this.y = y;\n            this.r = r;\n            this.v = v;\n            this.destroyed = false;\n            this.id = id;\n        }\n        \n        double distanceFromOrigin() {\n            return Math.sqrt(x * x + y * y);\n        }\n        \n        void moveTowardsOrigin(double time) {\n            if (destroyed) return;\n            double dist = distanceFromOrigin();\n            if (dist == 0) return;\n            double moveAmount = v * time;\n            if (moveAmount >= dist) {\n                x = 0;\n                y = 0;\n            } else {\n                double ratio = moveAmount / dist;\n                x -= x * ratio;\n                y -= y * ratio;\n            }\n        }\n    }\n    \n    public static void main(String[] args) throws IOException {\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        String line;\n        \n        while ((line = br.readLine()) != null) {\n            String[] parts = line.trim().split(\"\\\\s+\");\n            int R = Integer.parseInt(parts[0]);\n            int N = Integer.parseInt(parts[1]);\n            \n            if (R == 0 && N == 0) break;\n            \n            List<UFO> ufos = new ArrayList<>();\n            for (int i = 0; i < N; i++) {\n                line = br.readLine();\n                parts = line.trim().split(\"\\\\s+\");\n                double x0 = Double.parseDouble(parts[0]);\n                double y0 = Double.parseDouble(parts[1]);\n                double r = Double.parseDouble(parts[2]);\n                double v = Double.parseDouble(parts[3]);\n                ufos.add(new UFO(x0, y0, r, v, i));\n            }\n            \n            int time = 1;\n            while (true) {\n                // Move all UFOs\n                for (UFO ufo : ufos) {\n                    ufo.moveTowardsOrigin(1);\n                }\n                \n                // Find closest UFO outside R\n                UFO target = null;\n                double minDist = Double.MAX_VALUE;\n                \n                for (UFO ufo : ufos) {\n                    if (!ufo.destroyed && ufo.distanceFromOrigin() > R) {\n                        double dist = ufo.distanceFromOrigin();\n                        if (dist < minDist) {\n                            minDist = dist;\n                            target = ufo;\n                        }\n                    }\n                }\n                \n                if (target == null) break;\n                \n                // Shoot laser through target\n                double tx = target.x;\n                double ty = target.y;\n                \n                for (UFO ufo : ufos) {\n                    if (!ufo.destroyed && ufo.distanceFromOrigin() > R) {\n                        if (laserHits(tx, ty, ufo)) {\n                            ufo.destroyed = true;\n                        }\n                    }\n                }\n                \n                time++;\n                if (time > 10000) break;\n            }\n            \n            int count = 0;\n            for (UFO ufo : ufos) {\n                if (!ufo.destroyed) {\n                    count++;\n                }\n            }\n            \n            System.out.println(count);\n        }\n    }\n    \n    static boolean laserHits(double lx, double ly, UFO ufo) {\n        // Laser goes from origin through (lx, ly)\n        // Check if it intersects circle at (ufo.x, ufo.y) with radius ufo.r\n        \n        double laserLen = Math.sqrt(lx * lx + ly * ly);\n        if (laserLen == 0) return false;\n        \n        // Normalize laser direction\n        double ldx = lx / laserLen;\n        double ldy = ly / laserLen;\n        \n        // Distance from ufo center to laser line\n        double dist = Math.abs(ldy * ufo.x - ldx * ufo.y);\n        \n        if (dist > ufo.r) return false;\n        \n        // Check if UFO is in the direction of the laser\n        double dot = ufo.x * ldx + ufo.y * ldy;\n        return dot > 0;\n    }\n}\n", "perturbed_sampled": ["  y;   { this.x =  = r; this.v =  = id; } double distanceFromOrigin() { return Math.sqrt(x * x + y *  { if (destroyed)  if (dist == 0) return; double moveAmount = v * time; if (moveAmount >= dist) { x = 0; y = 0;  = moveAmount / dist;  y -= y *   IOException  != null) { String[] parts = line.trim().split(\"\\\\s+\"); int R  0  List<UFO> ufos =  = 0; i <   y0 = Double.parseDouble(parts[1]); double r = Double.parseDouble(parts[2]); double v = Double.parseDouble(parts[3]); ufos.add(new UFO(x0, y0, r, v, i)); } int time = 1; while (true) { // Move all UFOs for (UFO ufo : ufos) { ufo.moveTowardsOrigin(1); } // Find closest  = null; double minDist =   double  = dist;  }  : ufos) { if  ufo)) { ufo.destroyed = true; } } } time++; if (time >   static boolean  (lx, ly) // Check  ly * ly); if  double ldx  ldy = ly / laserLen; //  - ldx *  if UFO is in the direction  } }"], "perturbed_original": ["import  public  Scanner  = s.nextInt()) != 0 && (n = s.nextInt()) != 0) { double[][] ufo = new double[n][6]; //  fin_step) for (int i = 0; i  (int  }  for  <  for (int  step  -1; for (int j = 0;  continue; // \u008a\u00f9\u0082\u00c9\u0090N\u0093\u00fcor\u008c\u0082\u0092\u00c4 if (ufo[j][5] < i)  else if (near == -1 || ufo[near][4] > ufo[j][4])  } if (near == -1) break; double x0 = ufo[near][0]; //   = 0; j < n; j++) { if (st[j]  double y1  >= 0   < 0))  r) st[j] = 2; // \u008c\u0082\u0092\u00c4 } else if (x0 == 0)   y1 <  <=  \u008c\u0082\u0092\u00c4 } else  / x0;  0  (x0 < 0 && x1 < 0)) // \u0093\u00af\u0082\u00b6\u008c\u00fc\u0082\u00ab if ((y0 >= 0 &&  <    UFO\u0088\u00da\u0093\u00ae  ufo[j][3]; }  0; j <  1) sum++; System.out.println(sum); } } }"], "original_ll": -1.1060551404953003, "sampled_ll": -0.6230924129486084, "all_perturbed_sampled_ll": [-2.8136277198791504], "all_perturbed_original_ll": [-3.132628917694092], "perturbed_sampled_ll": -2.8136277198791504, "perturbed_original_ll": -3.132628917694092, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "from math import sqrt\nwhile 1:\n    R, N = map(int, raw_input().split())\n    if R == N == 0:\n        break\n    P = []\n    for i in xrange(N):\n        x, y, r, v = map(int, raw_input().split())\n        P.append((sqrt(x**2+y**2), x**2+y**2, x, y, r, v, i))\n    kill = [0]*N\n    ans = 0\n    for t in xrange(1, N+1):\n        j = None; mi = 10**9\n        for l, ll, x, y, r, v, i in P:\n            if kill[i]:\n                continue\n            if ll < (R + t*v)**2:\n                kill[i] = 1\n                ans += 1\n\n            if not kill[i] and l - t*v < mi:\n                mi = l - t*v\n                j = i\n        if j is None:\n            break\n        l0, ll0, x0, y0, r0, v0, j = P[j]\n        for l, ll, x, y, r, v, i in P:\n            if kill[i]:\n                continue\n            if (l - t*v)*abs(x0*y - x*y0) < r*l*l0 + 1e-8:\n                kill[i] = 1\n    print ans", "sampled": "import math\n\ndef distance(x, y):\n    return math.sqrt(x*x + y*y)\n\ndef line_circle_intersection(x0, y0, r, px, py):\n    # Check if line from origin through (px, py) intersects circle at (x0, y0) with radius r\n    # Line can be parameterized as (t*px, t*py) for t >= 0\n    # Circle: (x-x0)^2 + (y-y0)^2 = r^2\n    # Substitute: (t*px - x0)^2 + (t*py - y0)^2 = r^2\n    \n    if px == 0 and py == 0:\n        return distance(x0, y0) <= r\n    \n    # Line direction vector (px, py)\n    # Distance from point (x0, y0) to line through origin with direction (px, py)\n    # d = |x0*py - y0*px| / sqrt(px^2 + py^2)\n    \n    d = abs(x0 * py - y0 * px) / math.sqrt(px*px + py*py)\n    \n    return d <= r\n\nwhile True:\n    line = input().split()\n    R = int(line[0])\n    N = int(line[1])\n    \n    if R == 0 and N == 0:\n        break\n    \n    ufos = []\n    for i in range(N):\n        parts = list(map(int, input().split()))\n        x0, y0, r, v = parts[0], parts[1], parts[2], parts[3]\n        ufos.append([x0, y0, r, v, True])  # True means not destroyed\n    \n    time = 1\n    invaded = 0\n    \n    while True:\n        # Move all UFOs\n        for i in range(N):\n            if ufos[i][4]:  # If not destroyed\n                x0, y0, r, v = ufos[i][0], ufos[i][1], ufos[i][2], ufos[i][3]\n                dist = distance(x0, y0)\n                if dist > 0:\n                    # Move towards origin\n                    dx = -x0 / dist\n                    dy = -y0 / dist\n                    ufos[i][0] += dx * v * time\n                    ufos[i][1] += dy * v * time\n        \n        # Check for invaded UFOs\n        for i in range(N):\n            if ufos[i][4]:\n                dist = distance(ufos[i][0], ufos[i][1])\n                if dist <= R:\n                    invaded += 1\n                    ufos[i][4] = False\n        \n        # Find closest UFO outside R\n        min_dist = float('inf')\n        target_idx = -1\n        for i in range(N):\n            if ufos[i][4]:\n                dist = distance(ufos[i][0], ufos[i][1])\n                if dist > R and dist < min_dist:\n                    min_dist = dist\n                    target_idx = i\n        \n        if target_idx == -1:\n            break\n        \n        # Fire laser at target\n        tx, ty = ufos[target_idx][0], ufos[target_idx][1]\n        \n        # Destroy all UFOs that intersect with this laser line\n        for i in range(N):\n            if ufos[i][4]:\n                dist = distance(ufos[i][0], ufos[i][1])\n                if dist > R:\n                    if line_circle_intersection(ufos[i][0], ufos[i][1], ufos[i][2], tx, ty):\n                        ufos[i][4] = False\n        \n        time = 1\n    \n    print(invaded)\n", "perturbed_sampled": [" return math.sqrt(x*x + y*y) def line_circle_intersection(x0,  intersects circle at (x0,  as (t*px, t*py) for t >= 0 # Circle:   + (t*py - y0)^2 =  and py  <=  (px, py) # Distance from point (x0,  with direction (px, py) # d =  d <= r while True:  and N == 0: break  in range(N):   parts[1], parts[2], parts[3] ufos.append([x0, y0, r, v, True])  time = 1 invaded = 0 while True:   ufos[i][3] dist =   time ufos[i][1] += dy * v * time # Check for invaded UFOs  ufos[i][1]) if dist <= R:  = float('inf') target_idx = -1 for i  = distance(ufos[i][0],  and dist   ==  at target tx, ty = ufos[target_idx][0], ufos[target_idx][1] # Destroy all UFOs   if ufos[i][4]: dist = distance(ufos[i][0], ufos[i][1]) if dist > R: if line_circle_intersection(ufos[i][0],   print(invaded)"], "perturbed_original": ["from math  if R  P = [] for i in xrange(N): x, y, r, v = map(int, raw_input().split())  [0]*N ans  xrange(1,  =  y, r, v, i in P: if kill[i]: continue  mi = l - t*v  is None: break  y, r, v, i  if  < r*l*l0 + 1e-8: kill[i] = 1 print ans"], "original_ll": -1.1521791219711304, "sampled_ll": -0.8005489110946655, "all_perturbed_sampled_ll": [-2.9900155067443848], "all_perturbed_original_ll": [-3.548069477081299], "perturbed_sampled_ll": -2.9900155067443848, "perturbed_original_ll": -3.548069477081299, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "#include<stdio.h>\nint main(void){\n        int point[10][10]={0};\n        int person=0,endFlag=0,result=0,count,repeat,versusCount,myGTP,theyGTP;\n        printf(\"\u5165\u529b\\n\");\n        for(count=0; endFlag==0; count++){\n                for(person=0; person<5 && endFlag==0; person++){\n                        scanf(\"%d\",&point[count][person]);\n                        if(point[count][person]<0||point[count][person]>3){\n                        printf(\"\u30a8\u30e9\u30fc\u3001\u7d42\u4e86\u3057\u307e\u3059\u3002\");\n                        exit(1);\n                                }\n                        if(point[count][person]==0){\n                                endFlag=1;\n                                }\n                        }\n                }\n        repeat=count;\n        printf(\"\\n\u51fa\u529b\\n\");\n        for(count=0; count<repeat; count++){\n                for(person=0; point[count][person]!=0; person++){\n                        for(versusCount=0; point[count][versusCount]!=0; versusCount++){\n                        myGTP=point[count][person];\n                        theyGTP=point[count][versusCount];\n                        if(person!=versusCount){\n                        if(((myGTP+1==theyGTP)||(myGTP-2==theyGTP))&&(result!=1)&&(result!=3)){\n                                result+=1;\n                                }\n                        if(((myGTP+2==theyGTP)||(myGTP-1==theyGTP))&&(result!=2)&&(result!=3)){\n                                result+=2;\n                                }\n                        }\n                        }\n                if(result==0){\n                        result=3;\n                        }\n                                printf(\"\\n%d\",result);\n                                result=0;\n                                }\n                        }\n        return 0;\n}", "sampled": "#include <stdio.h>\n\nint main() {\n    int h[5];\n    \n    while(1) {\n        scanf(\"%d\", &h[0]);\n        if(h[0] == 0) break;\n        \n        for(int i = 1; i < 5; i++) {\n            scanf(\"%d\", &h[i]);\n        }\n        \n        int count[4] = {0};\n        for(int i = 0; i < 5; i++) {\n            count[h[i]]++;\n        }\n        \n        int types = 0;\n        for(int i = 1; i <= 3; i++) {\n            if(count[i] > 0) types++;\n        }\n        \n        if(types == 1 || types == 3) {\n            for(int i = 0; i < 5; i++) {\n                printf(\"3\\n\");\n            }\n        } else {\n            int winning_hand;\n            if(count[1] > 0 && count[2] > 0) {\n                winning_hand = 1;\n            } else if(count[2] > 0 && count[3] > 0) {\n                winning_hand = 2;\n            } else {\n                winning_hand = 3;\n            }\n            \n            for(int i = 0; i < 5; i++) {\n                if(h[i] == winning_hand) {\n                    printf(\"1\\n\");\n                } else {\n                    printf(\"2\\n\");\n                }\n            }\n        }\n    }\n    \n    return 0;\n}\n", "perturbed_sampled": ["#include <stdio.h> int main() { int h[5]; while(1) {  break; for(int  5; i++) {  =   > 0) types++; } if(types  int winning_hand; if(count[1] > 0 && count[2] > 0) { winning_hand  > 0 && count[3] >  } else { winning_hand = 3; } for(int i =  { if(h[i] == winning_hand) {   0; }"], "perturbed_original": ["#include<stdio.h>  person=0,endFlag=0,result=0,count,repeat,versusCount,myGTP,theyGTP; printf(\"\u5165\u529b\\n\"); for(count=0; endFlag==0; count++){ for(person=0; person<5  repeat=count; printf(\"\\n\u51fa\u529b\\n\");   theyGTP=point[count][versusCount]; if(person!=versusCount){ if(((myGTP+1==theyGTP)||(myGTP-2==theyGTP))&&(result!=1)&&(result!=3)){ result+=1; } if(((myGTP+2==theyGTP)||(myGTP-1==theyGTP))&&(result!=2)&&(result!=3)){ result+=2;  } return 0; }"], "original_ll": -1.2796039581298828, "sampled_ll": -0.561272144317627, "all_perturbed_sampled_ll": [-2.7186336517333984], "all_perturbed_original_ll": [-2.2335448265075684], "perturbed_sampled_ll": -2.7186336517333984, "perturbed_original_ll": -2.2335448265075684, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "//Volume2-0205\nimport java.util.Scanner;\n\nclass Main {\n\n\tprivate static int[] cnt,\n             \t\t     player,\n\t\t                 result;\n\n\tpublic static void main(String[] args){\n\t\tint   victory,loss;\n\n\t\tScanner sc = new Scanner(System.in);\n\n\t\twhile(true){\n\t\t\tcnt    = new int[4];\n\t\t\tplayer = new int[5];\n\t\t\tresult = new int[5];\n\t\t\tplayer[0] = sc.nextInt();\n\t\t\tif(player[0] == 0){break;}\n\t\t\tcnt[player[0]]++;\n\t\t\tfor(int i=1;i<5;i++){\n\t\t\t\tplayer[i] = sc.nextInt();\n\t\t\t\tcnt[player[i]]++;\n\t\t\t}\n\t\t\tscape : {\n\t\t\t\tif(cnt[1] == 5 || cnt[2] == 5 || cnt[3] == 5 ||\n\t\t\t\t  (cnt[1] != 0 && cnt[2] != 0 && cnt[3] != 0    )){\n\t\t\t\t\tfor(int j=0;j<5;j++){result[j] = 3;}\n\t\t\t\t\tbreak scape;\n\t\t\t\t}\n\t\t\t\tvictory = 0; loss = 0;\n\t\t\t\tif       (cnt[1] != 0 && cnt[2] != 0){\n\t\t\t\t\tvictory = 1;\n\t\t\t\t\tloss    = 2;\n\t\t\t\t} else if(cnt[2] != 0 && cnt[3] != 0){\n\t\t\t\t\tvictory = 2;\n\t\t\t\t\tloss    = 3;\n\t\t\t\t} else if(cnt[1] != 0 && cnt[3] != 0){\n\t\t\t\t\tvictory = 3;\n\t\t\t\t\tloss    = 1;\n\t\t\t\t}\n\t\t\t\tfor(int j=0;j<5;j++){\n\t\t\t\t\tif        (player[j] == victory){\n\t\t\t\t\t\tresult[j] = 1;\n\t\t\t\t\t} else if (player[j] == loss){\n\t\t\t\t\t\tresult[j] = 2;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(int i:result){System.out.println(i);}\n\t\t}\n\t}\n}", "sampled": "import java.util.Scanner;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        \n        while (true) {\n            int h1 = sc.nextInt();\n            if (h1 == 0) break;\n            \n            int h2 = sc.nextInt();\n            int h3 = sc.nextInt();\n            int h4 = sc.nextInt();\n            int h5 = sc.nextInt();\n            \n            int[] hands = {h1, h2, h3, h4, h5};\n            \n            boolean hasRock = false;\n            boolean hasScissors = false;\n            boolean hasPaper = false;\n            \n            for (int hand : hands) {\n                if (hand == 1) hasRock = true;\n                else if (hand == 2) hasScissors = true;\n                else if (hand == 3) hasPaper = true;\n            }\n            \n            int distinctCount = 0;\n            if (hasRock) distinctCount++;\n            if (hasScissors) distinctCount++;\n            if (hasPaper) distinctCount++;\n            \n            if (distinctCount == 1 || distinctCount == 3) {\n                for (int i = 0; i < 5; i++) {\n                    System.out.println(3);\n                }\n            } else {\n                int winningHand;\n                if (hasRock && hasScissors) {\n                    winningHand = 1;\n                } else if (hasScissors && hasPaper) {\n                    winningHand = 2;\n                } else {\n                    winningHand = 3;\n                }\n                \n                for (int hand : hands) {\n                    if (hand == winningHand) {\n                        System.out.println(1);\n                    } else {\n                        System.out.println(2);\n                    }\n                }\n            }\n        }\n        \n        sc.close();\n    }\n}\n", "perturbed_sampled": ["import java.util.Scanner; public class Main { public static void main(String[]  new  (h1   sc.nextInt(); int h5 = sc.nextInt();  h3, h4, h5}; boolean hasRock = false;   hasRock =    = true; } int distinctCount = 0;  { for  < 5; i++) {  int  {  if (hasScissors &&  } else { winningHand = 3; }  { if (hand == winningHand) {  } } } } sc.close(); } }"], "perturbed_original": ["//Volume2-0205 import  static int[] cnt, player, result; public static void main(String[] args){ int  new int[4]; player = new int[5]; result = new int[5]; player[0] = sc.nextInt(); if(player[0]  }  5  break scape; } victory = 0; loss  0  = 1; loss =  0 && cnt[3] != 0){ victory =   cnt[3] != 0){ victory  } for(int j=0;j<5;j++){ if (player[j] == victory){  } } }"], "original_ll": -1.0414963960647583, "sampled_ll": -0.4549848735332489, "all_perturbed_sampled_ll": [-2.982175827026367], "all_perturbed_original_ll": [-2.8831918239593506], "perturbed_sampled_ll": -2.982175827026367, "perturbed_original_ll": -2.8831918239593506, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "#5\u500b\u306e\u3046\u30611\u756a\u76ee\u306e\u5165\u529b\u304c0\u306a\u3089\u51e6\u7406\u3092\u7d42\u308f\u308b\u3002\nwhile True:\n    line = []\n    line.append(int(input()))\n    if line[0] == 0:break\n\n    #\u6a19\u6e96\u5165\u529b\u3092\u3057\u30ea\u30b9\u30c8\u3092\u30bb\u30c3\u30c8\u306b\u3057\u305f\u3082\u306e\u3092\u4f5c\u308b\u3002\n    for _ in range(4):line.append(int(input()))\n    se = set(line)\n    \n    #\u5168\u54e1\u304c\u540c\u3058\u6570\u3092\u51fa\u3059\u304b3\u7a2e\u985e\u306e\u624b\u304c\u51fa\u305f\u30895\u3053\"3\"\u3092\u51fa\u529b\u3059\u308b\u3002\n    if len(se) == 1 or len(se) == 3:\n        for _ in range(5):print(\"3\")\n        \"\"\n    #\u3058\u3083\u3093\u3051\u3093\u306e\u52dd\u6557\u306b\u57fa\u3065\u304d\u52dd\u3061\u3060\u3063\u305f\u3089\"1\"\u8ca0\u3051\u3060\u3063\u305f\u3089\"2\"\u3092\u51fa\u529b\u3059\u308b\n    else:\n        if sum(se) == 3:\n            for i in line:\n                if i == 1:print(\"1\")\n                else:print(\"2\")\n        if sum(se) == 4:\n            for i in line:\n                if i == 3:print(\"1\")\n                else:print(\"2\")\n        if sum(se) == 5:\n            for i in line:\n                if i == 2:print(\"1\")\n                else:print(\"2\")\n", "sampled": "while True:\n    h1 = int(input())\n    if h1 == 0:\n        break\n    \n    hands = [h1]\n    for _ in range(4):\n        hands.append(int(input()))\n    \n    unique_hands = set(hands)\n    \n    # Check if it's a draw (all same or all three types)\n    if len(unique_hands) == 1 or len(unique_hands) == 3:\n        for _ in range(5):\n            print(3)\n    else:\n        # Two types of hands - determine winner\n        hand_list = list(unique_hands)\n        h_a, h_b = hand_list[0], hand_list[1]\n        \n        # Determine which hand wins\n        # 1 (rock) beats 2 (scissors)\n        # 2 (scissors) beats 3 (paper)\n        # 3 (paper) beats 1 (rock)\n        if (h_a == 1 and h_b == 2) or (h_a == 2 and h_b == 1):\n            winning_hand = 1\n        elif (h_a == 2 and h_b == 3) or (h_a == 3 and h_b == 2):\n            winning_hand = 2\n        else:  # (h_a == 3 and h_b == 1) or (h_a == 1 and h_b == 3)\n            winning_hand = 3\n        \n        for hand in hands:\n            if hand == winning_hand:\n                print(1)\n            else:\n                print(2)\n", "perturbed_sampled": ["while  h1 ==  for _ in range(4): hands.append(int(input())) unique_hands  it's a draw (all same or  == 1  _  Two types of hands - determine winner hand_list   3 (paper) # 3 (paper)  == 1 and h_b == 2) or    (h_a  else: # (h_a == 3  (h_a == 1 and h_b == 3) winning_hand = 3 for  print(2)"], "perturbed_original": ["#5\u500b\u306e\u3046\u30611\u756a\u76ee\u306e\u5165\u529b\u304c0\u306a\u3089\u51e6\u7406\u3092\u7d42\u308f\u308b\u3002 while True: line = [] line.append(int(input())) if line[0] == 0:break #\u6a19\u6e96\u5165\u529b\u3092\u3057\u30ea\u30b9\u30c8\u3092\u30bb\u30c3\u30c8\u306b\u3057\u305f\u3082\u306e\u3092\u4f5c\u308b\u3002 for _ : if _<extra_id_6>if _ for i in  4:  i == 3:print(\"1\") else:print(\"2\") if sum(se) == 5: for i  2:print(\"1\") else:print(\"2\")"], "original_ll": -1.6594135761260986, "sampled_ll": -0.8514084219932556, "all_perturbed_sampled_ll": [-3.994616985321045], "all_perturbed_original_ll": [-3.432609796524048], "perturbed_sampled_ll": -3.994616985321045, "perturbed_original_ll": -3.432609796524048, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "#include<stdio.h>\nint main(){\n\tint i=0,l,n,m,a[12],b;\n\twhile(1){\n\t\tb=0;\n\t\tscanf(\"%d\",&l);\n\t\tif(l==0){\n\t\t\tbreak;\n\t\t}\n\t\tfor(i=0;i<12;i++){\n\t\t\tscanf(\"%d%d\",&m,&n);\n\t\t\ta[i]=m-n;\n\t\t}\n\t\tfor(i=0;i<12;i++){\n\t\t\tb=b+a[i];\n\t\t\tif(b>=l){\n\t\t\t\tprintf(\"%d\\n\",i+1);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif(b<l){\n\t\t\tprintf(\"NA\\n\");\n\t\t}\n\t}\n}", "sampled": "#include <stdio.h>\n\nint main() {\n    int L;\n    \n    while (scanf(\"%d\", &L) == 1 && L != 0) {\n        int savings = 0;\n        int month = 0;\n        int found = 0;\n        \n        for (int i = 1; i <= 12; i++) {\n            int M, N;\n            scanf(\"%d %d\", &M, &N);\n            \n            if (!found) {\n                savings += (M - N);\n                if (savings >= L) {\n                    month = i;\n                    found = 1;\n                }\n            }\n        }\n        \n        if (found) {\n            printf(\"%d\\n\", month);\n        } else {\n            printf(\"NA\\n\");\n        }\n    }\n    \n    return 0;\n}\n", "perturbed_sampled": ["#include <extra_id_3>if(found) {<extra_id_4>; } else<extra_id_5>else { printf(\"%d\\n\",<extra_id_6>}<extra_id_7>else {<extra_id_8>*/<extra_id_9><s> int i ; int<extra_id_10>( int<extra_id_11>= 0<extra_id_12>i < L<extra_id_13>{ } if<extra_id_14>if<extra_id_15>&&<extra_id_16>>=<extra_id_17>Savings ; #include SUBSTRINGs<extra_id_18>1<extra_id_19>: }<extra_id_20>{ {<extra_id_21>{ if<extra_id_22>}<extra_id_23>} printf(\"< != 0)  for (int i   scanf(\"%d %d\", &M,  if (savings >= L) { month = i; found = 1; } } } if (found) { printf(\"%d\\n\", month); } else {  }"], "perturbed_original": ["#include<stdio.h> int main(){ int  break; } for(i=0;i<12;i++){  if(b>=l){ printf(\"%d\\n\",i+1); break;  } }"], "original_ll": -0.886232316493988, "sampled_ll": -0.8190506100654602, "all_perturbed_sampled_ll": [-2.5239949226379395], "all_perturbed_original_ll": [-2.4257471561431885], "perturbed_sampled_ll": -2.5239949226379395, "perturbed_original_ll": -2.4257471561431885, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import java.util.Scanner;\nclass Main{\n\tstatic Scanner sc;\n\tstatic int L,M,N,T,mth;\n\t\n\tpublic static void main(String[]args){\n\t\tsc=new Scanner(System.in);\n\t\t\n\t\twhile(sc.hasNext()){\n\t\t\tL=sc.nextInt();\n\t\t\tmth=0;\n\t\t\tT=0;M=0;N=0;\n\t\t\tfor(int i=0;i<12;i++){\n\t\t\t\tM=sc.nextInt();\n\t\t\t\tN=sc.nextInt();\n\t\t\t\tT=T+M-N;\n\t\t\t\tif(T>=L && mth==0){\n\t\t\t\t\tmth=i+1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(mth==0){System.out.println(\"NA\");}\n\t\t\telse{System.out.println(mth);}\n\t\t}\n\t}\n}", "sampled": "import java.util.Scanner;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        \n        while (true) {\n            int L = sc.nextInt();\n            if (L == 0) break;\n            \n            int savings = 0;\n            int month = 0;\n            boolean found = false;\n            \n            for (int i = 1; i <= 12; i++) {\n                int M = sc.nextInt();\n                int N = sc.nextInt();\n                savings += (M - N);\n                \n                if (!found && savings >= L) {\n                    month = i;\n                    found = true;\n                }\n            }\n            \n            if (found) {\n                System.out.println(month);\n            } else {\n                System.out.println(\"NA\");\n            }\n        }\n        \n        sc.close();\n    }\n}\n", "perturbed_sampled": ["import  public static   (true) {  int savings = 0; int month =  1; i <= 12; i++) { int M = sc.nextInt(); int N = sc.nextInt(); savings +=   month  {  } } sc.close(); } }"], "perturbed_original": ["import java.util.Scanner; class Main{ static  public static void  && mth==0){  } } }"], "original_ll": -1.127163052558899, "sampled_ll": -0.718788743019104, "all_perturbed_sampled_ll": [-3.409977674484253], "all_perturbed_original_ll": [-4.247581958770752], "perturbed_sampled_ll": -3.409977674484253, "perturbed_original_ll": -4.247581958770752, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "while True:\n    L = int(input())\n    if L == 0:\n        break\n    \n    flag = True\n    ans = -1\n    d = 0\n    for i in range(12):\n        M,N = [int(i) for i in input().split()]\n        d = d + M - N\n        if d >= L and flag:\n            ans = i+1\n            flag = False\n    \n    if ans >= 0:\n        print(ans)\n    else:\n        print(\"NA\")\n\n", "sampled": "while True:\n    L = int(input())\n    if L == 0:\n        break\n    \n    savings = 0\n    months = 0\n    found = False\n    \n    for month in range(1, 13):\n        M, N = map(int, input().split())\n        savings += (M - N)\n        if savings >= L and not found:\n            months = month\n            found = True\n    \n    if found:\n        print(months)\n    else:\n        print(\"NA\")\n", "perturbed_sampled": ["while True: L = int(input()) <extra_id_2>print(L, month,<extra_id_3>, found)<extra_id_4>1)<extra_id_5>20) break<extra_id_6>found,<extra_id_7>else: print(\"NA\")<extra_id_8>E ( \u30d1\u306e\u4e86\u53c3\u306e\uff1a\")<extra_id_9>N<extra_id_10>D) print(\"N\")<extra_id_11>, month), M<extra_id_12>1)<extra_id_13>D) if<extra_id_14>%f\", K,<extra_id_15>M) if<extra_id_16>M.length):<extra_id_17>1)<extra_id_18>20 = 0 found = False for month in range(1, 13): M, N   found  else: print(\"NA\")"], "perturbed_original": ["while True: L = int(input()) if  = True ans = -1 d = 0  d + M -  and flag: ans   else: print(\"NA\")"], "original_ll": -1.2572733163833618, "sampled_ll": -1.1660139560699463, "all_perturbed_sampled_ll": [-2.827918529510498], "all_perturbed_original_ll": [-4.324816703796387], "perturbed_sampled_ll": -2.827918529510498, "perturbed_original_ll": -4.324816703796387, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "/*\nAizuOnline A0207\nTitle Block\n*/\n#include <stdio.h>\n// Select Below\n//#include <stdlib.h>\n//#include <string.h>\n//#include <float.h>\n//#include <math.h>\n//#include <limits.h>\n#include <setjmp.h>\n//Global data section\nint w,h;\nint xs,ys;\nint xg,yg;\nint n;\nint c[100];\nint d[100];\nint x[100],y[100];\nint bd[100][100];\njmp_buf env;\n\n//\nvoid init()\n{\n  int i,j;\n  for(i=0;i<h;i++)\n    for(j=0;j<w;j++)\n      bd[i][j]=0;\n  for(i=0;i<100;i++)\n    {\n      x[i]=y[i]=d[i]=c[i]=0;\n    }\n}\nint get_block(int px,int py)\n{\n  int i;\n  // printf(\"GB%d,%d\\n\",px,py);\n  for(i=0;i<n;i++)\n    if(d[i]==0)         // yokonaga\n\t{\n\t  if(px-x[i] >=0 && px-x[i] <=3 && \n\t     py-y[i] >=0 && py-y[i] <= 1)\n\t    return(i);\n\t}\n    else if(d[i]==1)         // tatenaga\n      {\n\tif(px-x[i] >=0 && px-x[i] <=1 && \n\t   py-y[i] >=0 && py-y[i] <=3)\n\t  return(i);\n      }\n  return(-1);\n}\nint show()\n{\n  int i,j;\n  for(i=1;i<=h;i++)\n    {\n      for(j=1;j<=w;j++)\n\tprintf(\"%d\",bd[i][j]);\n      printf(\"\\n\");\n    }\n  printf(\"\\n\");\n}\nvoid paint0(int px,int py,int col,int ww,int hh)\n{\n  int i,j;\n  //printf(\"P0 %d %d\\n\",px,py);\n\n    for(i=0;i<hh;i++)\n      for(j=0;j<ww;j++)\n\tbd[py+i][px+j]=col;\n}\nint paint(int px,int py,int col)\n{\n  int cc,blk,dir,bx,by,w0,h0,i,j;\n  //printf(\"xyc=%d %d %d\\n\",px,py,col);\n\n  if(px < 1 ||py < 1) //out of bound\n    return(0);\n  if(bd[py][px])  // already painted\n    return(0);\n  blk=get_block(px,py);  // get block no of this place\n  //printf(\"blk=%d\\n\",blk);\n  if(blk<0)\n    return(0);\n  cc=c[blk];\n  dir=d[blk];\n  if(cc != col)\n    return(0);             // different color\n\n  bx=x[blk];\n  by=y[blk];\n   if(dir==0)         // yokonaga\n     { w0=4;h0=2;}\n   else\n     { w0=2;h0=4;}\n\n  paint0(bx,by,col,w0,h0); // paint this block\n\n  if(xg >= bx && xg <= bx+w0 && \n     yg >= by && yg <= by+h0 )     // reach the goal\n    {\n      longjmp(env,1);\n    }\n\n   for(i=-1;i<w0+1;i++)\n     if(i==-1||i==w0)\n       for(j=0;j<h0;j++)\n\t paint(bx+i,by+j,col);\n     else\n       for(j=-1;j<h0+1;j++)\n\t paint(bx+i,by+j,col);\n\n   return(0);\n}\nmain()\n{\n  int i,bl,col,dir,ret;\n  while(EOF != scanf(\"%d %d\",&w,&h) && (w || h))\n    {\n      init();\n      scanf(\"%d %d\",&xs,&ys);\n      scanf(\"%d %d\",&xg,&yg);\n      scanf(\"%d\",&n);\n      for(i=0;i<n;i++)\n\tscanf(\"%d %d %d %d\",&(c[i]),&(d[i]),&(x[i]),&(y[i]));\n      \n      bl = get_block(xs,ys);\n      col=c[bl];\n      if(setjmp(env)==0)\n\t{\n\t  ret = paint(xs,ys,col);\n\t}\n      else\n\tret=-1;\n      \n      paint(1,1,2);\n      show();\n      printf(\"%s\\n\",ret?\"OK\":\"NG\");\n    }\nreturn(0);\n}", "sampled": "#include <stdio.h>\n#include <string.h>\n\nint w, h, xs, ys, xg, yg, n;\nint board[105][105];\nint visited[105][105];\n\nint dx[] = {0, 0, 1, -1};\nint dy[] = {1, -1, 0, 0};\n\nint dfs(int x, int y, int color) {\n    if (x == xg && y == yg) {\n        return 1;\n    }\n    \n    visited[y][x] = 1;\n    \n    for (int i = 0; i < 4; i++) {\n        int nx = x + dx[i];\n        int ny = y + dy[i];\n        \n        if (nx >= 1 && nx <= w && ny >= 1 && ny <= h) {\n            if (!visited[ny][nx] && board[ny][nx] == color) {\n                if (dfs(nx, ny, color)) {\n                    return 1;\n                }\n            }\n        }\n    }\n    \n    return 0;\n}\n\nint main() {\n    while (1) {\n        scanf(\"%d %d\", &w, &h);\n        if (w == 0 && h == 0) break;\n        \n        scanf(\"%d %d\", &xs, &ys);\n        scanf(\"%d %d\", &xg, &yg);\n        scanf(\"%d\", &n);\n        \n        memset(board, 0, sizeof(board));\n        memset(visited, 0, sizeof(visited));\n        \n        for (int i = 0; i < n; i++) {\n            int c, d, x, y;\n            scanf(\"%d %d %d %d\", &c, &d, &x, &y);\n            \n            if (d == 0) {\n                // horizontal: 4 wide, 2 tall\n                for (int py = y; py < y + 2 && py <= h; py++) {\n                    for (int px = x; px < x + 4 && px <= w; px++) {\n                        board[py][px] = c;\n                    }\n                }\n            } else {\n                // vertical: 2 wide, 4 tall\n                for (int py = y; py < y + 4 && py <= h; py++) {\n                    for (int px = x; px < x + 2 && px <= w; px++) {\n                        board[py][px] = c;\n                    }\n                }\n            }\n        }\n        \n        int startColor = board[ys][xs];\n        \n        if (startColor == 0 || board[yg][xg] != startColor) {\n            printf(\"NG\\n\");\n        } else {\n            if (dfs(xs, ys, startColor)) {\n                printf(\"OK\\n\");\n            } else {\n                printf(\"NG\\n\");\n            }\n        }\n    }\n    \n    return 0;\n}\n", "perturbed_sampled": ["#include <stdio.h> #include <string.h>   int visited[105][105]; int dx[]  -1, 0, 0}; int dfs(int x, int  return 1; } visited[y][x] = 1;  i  nx = x + dx[i]; int ny = y + dy[i]; if (nx   &&  color)  { return 1; } }  int main() { while (1) { scanf(\"%d  ==  n; i++) { int c,  == 0) { // horizontal: 4 wide, 2 tall for  < y + 2 &&  for (int px = x;  px++) { board[py][px]  <= h; py++) { for (int px = x; px < x +  px++)  } } } int  (dfs(xs, ys, startColor)) { printf(\"OK\\n\"); } else { printf(\"NG\\n\"); } } } return 0; }"], "perturbed_original": ["/* AizuOnline  <stdio.h> // Select Below //#include <stdlib.h> //#include <string.h>  <limits.h>  int w,h; int xs,ys; int xg,yg; int  jmp_buf  int i,j; for(i=0;i<h;i++) for(j=0;j<w;j++) bd[i][j]=0; for(i=0;i<100;i++) { x[i]=y[i]=d[i]=c[i]=0;  py) { int i; // printf(\"GB%d,%d\\n\",px,py); for(i=0;i<n;i++) if(d[i]==0)   if(d[i]==1) // tatenaga {   for(j=1;j<=w;j++)  void paint0(int  {  for(i=0;i<hh;i++)  px,int py,int col) { int cc,blk,dir,bx,by,w0,h0,i,j; //printf(\"xyc=%d %d %d\\n\",px,py,col); if(px   blk=get_block(px,py); // get block no of  cc=c[blk]; dir=d[blk]; if(cc != col) return(0); // different color bx=x[blk];  block if(xg >= bx && xg <= bx+w0 && yg >=   { longjmp(env,1); } for(i=-1;i<w0+1;i++)  paint(bx+i,by+j,col);  i,bl,col,dir,ret; while(EOF != scanf(\"%d %d\",&w,&h) && (w   paint(xs,ys,col);  printf(\"%s\\n\",ret?\"OK\":\"NG\"); } return(0); }"], "original_ll": -1.230553150177002, "sampled_ll": -0.45623278617858887, "all_perturbed_sampled_ll": [-2.7746422290802], "all_perturbed_original_ll": [-2.7823309898376465], "perturbed_sampled_ll": -2.7746422290802, "perturbed_original_ll": -2.7823309898376465, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import java.util.*;\npublic class Main{\n    public static void main(String[] args){\n\tnew Main().run();\n    }\n    Scanner sc = new Scanner(System.in);\n\n    int w, h, xs, ys, xg, yg, n;\n    int c, d, x, y;\n\n    int[][] block;\n    boolean[][] route;\n    int[] dirX = {1, 0, -1, 0};\n    int[] dirY = {0, 1, 0, -1};\n\n    void run(){\n\twhile(sc.hasNext()){\n\t    w = sc.nextInt()+1;\n\t    h = sc.nextInt()+1;\n\t    if(w==1 && h==1) break;\n\t    put();\n\t    makeRoute();\n\t    //show();\n\n\t    if(!route[ys][xs] || !route[yg][xg]){\n\t\tSystem.out.println(\"NG\");\n\t\tcontinue;\n\t    }\n\t    else System.out.println(search(xs, ys) ? \"OK\":\"NG\");\n\t}\n    }\n\n    /*\n      \u30de\u30f3\u30cf\u30c3\u30bf\u30f3\u8ddd\u96e2\u304c\u8fd1\u304f\u306a\u308b\u3088\u3046\u306b\u9053\u3092\u9078\u3076\n      (\u30de\u30f3\u30cf\u30c3\u30bf\u30f3\u77ed\u7e2e\u3092\u898b\u3064\u3051\u3089\u308c\u306a\u3051\u308c\u3070)\u884c\u3051\u308b\u6240\u306b\u884c\u304f\n      \u3069\u3053\u306b\u3082\u884c\u3051\u306a\u3051\u308c\u3070\u307b\u3052\u3002\n    */\n    boolean search(int x, int y){\n\tint d = getD(x, y);\n\tboolean[] goodRoute = new boolean[4];\n\tboolean[] canRoute = new boolean[4];\n\tint gc = 0;\n\tint cc = 0;\n\tif(d==0) return true;\n\n\tfor(int i=0; i<dirX.length; i++){\n\t    int a = x+dirX[i];\n\t    int b = y+dirY[i];\n\t    if(a>0 && a<w && b>0 && b<h && route[b][a]){\n\t\tcanRoute[i] = true;\n\t\tcc++;\n\t\tif(getD(a, b)<d){\n\t\t    goodRoute[i] = true;\n\t\t    gc++;\n\t\t}\n\t    }\n\t}\n\t\n\tif(gc!=0){\n\t    for(int i=0; i<4; i++)\n\t\tif(goodRoute[i]) \n\t\t    if(search(x+dirX[i], y+dirY[i])) return true;\n\t}\n\telse if(cc!=0){\n\t    for(int i=0; i<4; i++)\n\t\tif(canRoute[i]) \n\t\t    if(search(x+dirX[i], y+dirY[i])) return true;\n\t}\n\t\t    \n\treturn false;\n    }\n\n    int getD(int x, int y){ return Math.abs(xg-x) + Math.abs(yg-y); }\n\n    void show(){\n\tfor(int i=1; i<w; i++){\n\t    for(int k=1; k<h; k++)\n\t\tSystem.out.print(route[i][k] ? \"\u25a1\":\"\u25a0\");\n\t    System.out.println();\n\t}\n\tSystem.out.println(\"----------------\");\n    }\n\n    void put(){\n\txs = sc.nextInt();\n\tys = sc.nextInt();\n\txg = sc.nextInt();\n\tyg = sc.nextInt();\n\tn = sc.nextInt();\n\n\tblock = new int[h][w];\n\troute = new boolean[h][w];\n\n\tfor(int i=0; i<n; i++){\n\t    c = sc.nextInt();\n\t    d = sc.nextInt();\n\t    x = sc.nextInt();\n\t    y = sc.nextInt();\n\t    if(d==0)\n\t\tfor(int a=x; a<x+4; a++)\n\t\t    for(int b=y; b<y+2; b++)\n\t\t\tblock[b][a] = c;    \n\t    else\n\t\tfor(int a=x; a<x+2; a++)\n\t\t    for(int b=y; b<y+4; b++)\n\t\t\tblock[b][a] = c;\n\t}\n    }\n\n    void makeRoute(){\n\tint tcolor = block[ys][xs];\n\tfor(int i=0; i<w; i++)\n\t    for(int k=0; k<h; k++)\n\t\tif(block[k][i]==tcolor) route[k][i] = true;\n    }\n}", "sampled": "import java.util.*;\n\npublic class Main {\n    static class Block {\n        int color;\n        int dir;\n        int x;\n        int y;\n        \n        Block(int color, int dir, int x, int y) {\n            this.color = color;\n            this.dir = dir;\n            this.x = x;\n            this.y = y;\n        }\n    }\n    \n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        \n        while (true) {\n            int w = sc.nextInt();\n            int h = sc.nextInt();\n            \n            if (w == 0 && h == 0) break;\n            \n            int xs = sc.nextInt();\n            int ys = sc.nextInt();\n            int xg = sc.nextInt();\n            int yg = sc.nextInt();\n            int n = sc.nextInt();\n            \n            int[][] board = new int[h + 1][w + 1];\n            \n            for (int i = 0; i < n; i++) {\n                int c = sc.nextInt();\n                int d = sc.nextInt();\n                int x = sc.nextInt();\n                int y = sc.nextInt();\n                \n                if (d == 0) { // horizontal (2 high, 4 wide)\n                    for (int dy = 0; dy < 2; dy++) {\n                        for (int dx = 0; dx < 4; dx++) {\n                            if (y + dy <= h && x + dx <= w) {\n                                board[y + dy][x + dx] = c;\n                            }\n                        }\n                    }\n                } else { // vertical (4 high, 2 wide)\n                    for (int dy = 0; dy < 4; dy++) {\n                        for (int dx = 0; dx < 2; dx++) {\n                            if (y + dy <= h && x + dx <= w) {\n                                board[y + dy][x + dx] = c;\n                            }\n                        }\n                    }\n                }\n            }\n            \n            int startColor = board[ys][xs];\n            int goalColor = board[yg][xg];\n            \n            if (startColor == 0 || goalColor == 0 || startColor != goalColor) {\n                System.out.println(\"NG\");\n                continue;\n            }\n            \n            boolean[][] visited = new boolean[h + 1][w + 1];\n            Queue<int[]> queue = new LinkedList<>();\n            queue.offer(new int[]{xs, ys});\n            visited[ys][xs] = true;\n            \n            boolean found = false;\n            int[] dx = {0, 0, 1, -1};\n            int[] dy = {1, -1, 0, 0};\n            \n            while (!queue.isEmpty()) {\n                int[] curr = queue.poll();\n                int cx = curr[0];\n                int cy = curr[1];\n                \n                if (cx == xg && cy == yg) {\n                    found = true;\n                    break;\n                }\n                \n                for (int dir = 0; dir < 4; dir++) {\n                    int nx = cx + dx[dir];\n                    int ny = cy + dy[dir];\n                    \n                    if (nx >= 1 && nx <= w && ny >= 1 && ny <= h \n                        && !visited[ny][nx] \n                        && board[ny][nx] == startColor) {\n                        visited[ny][nx] = true;\n                        queue.offer(new int[]{nx, ny});\n                    }\n                }\n            }\n            \n            System.out.println(found ? \"OK\" : \"NG\");\n        }\n        \n        sc.close();\n    }\n}\n", "perturbed_sampled": ["import java.util.*; public class Main { static class Block { int color; int dir; int  int  =  main(String[] args) { Scanner  = sc.nextInt(); int h  = sc.nextInt(); int xg = sc.nextInt(); int yg  sc.nextInt(); int[][] board = new int[h  i <  = sc.nextInt(); int x = sc.nextInt(); int y = sc.nextInt(); if (d == 0) { // horizontal (2 high, 4 wide)  { for (int dx = 0; dx < 4; dx++) { if (y   + dx]  }  high, 2 wide) for (int dy =  {  { if (y + dy <=   dy][x + dx] = c; } } } }  if (startColor ==  boolean[][] visited  int[]{xs, ys}); visited[ys][xs] = true; boolean found = false;   {1, -1, 0, 0};  =  && cy == yg)  } for (int dir = 0;  int nx =  = cy  board[ny][nx] == startColor)    } sc.close(); } }"], "perturbed_original": ["import java.util.*;  Main().run(); } Scanner sc =  xs, ys, xg, yg,  y; int[][] block;  {1, 0, -1, 0}; int[]  -1}; void run(){  = sc.nextInt()+1; if(w==1 && h==1) break; put(); makeRoute(); //show();  } else System.out.println(search(xs, ys)  boolean search(int x, int y){  boolean[4]; boolean[] canRoute = new boolean[4]; int gc = 0; int cc  for(int i=0; i<dirX.length;  int  = true; cc++;  gc++; } } } if(gc!=0){   y+dirY[i])) return true; }  Math.abs(xg-x) + Math.abs(yg-y); } void show(){ for(int i=1; i<w; i++){ for(int k=1; k<h; k++) System.out.print(route[i][k] ?  void put(){  sc.nextInt(); xg    i++){   a=x; a<x+2; a++) for(int b=y; b<y+4;  } void makeRoute(){   = true; } }"], "original_ll": -1.0710303783416748, "sampled_ll": -0.4206470251083374, "all_perturbed_sampled_ll": [-2.751096248626709], "all_perturbed_original_ll": [-2.8863539695739746], "perturbed_sampled_ll": -2.751096248626709, "perturbed_original_ll": -2.8863539695739746, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "sys.setrecursionlimit(10000) \n\ndef tansaku(cl,nc,ok,goal): #currentlocation,nonchecked,ok,goal\n    [clx,cly]=cl\n    for i in range(clx-1,clx+2):\n        for j in range(cly-1,cly+2):\n            if [i,j] in nc:\n                nc.remove([i,j])\n                ok.append([i,j])\n                tansaku([i,j],nc,ok,goal)\n\n\nwhile(1):\n    [boardw,boardh]=[int(x) for x in raw_input().split()]\n    if boardw==0 and boardh==0:\n        break\n    else:\n        [startx,starty]=[int(x) for x in raw_input().split()]\n        [goalx,goaly]=[int(x) for x in raw_input().split()]\n        blockn=int(raw_input())\n        blist={1:[],2:[],3:[],4:[],5:[]}\n        startc=-1\n        goalc=-1\n        #mark location of block\n        for i in range(blockn):\n            [c,d,x,y]=[int(x) for x in raw_input().split()]\n            if d: #d=1,tatenaga\n                for xx in range(x,x+2):\n                    for yy in range(y,y+4):\n                        blist[c].append([xx,yy])\n                        if [xx,yy]==[startx,starty]:\n                            startc=c\n                        if [xx,yy]==[goalx,goaly]:\n                            goalc=c\n            else:\n                for xx in range(x,x+4):\n                    for yy in range(y,y+2):\n                        blist[c].append([xx,yy])\n                        if [xx,yy]==[startx,starty]:\n                            startc=c\n                        if [xx,yy]==[goalx,goaly]:\n                            goalc=c\n        if startc==-1 or goalc==-1:\n            print \"NG\"\n        elif startc != goalc:\n            print \"NG\"\n        else:\n            #check if connected\n            cl=[startx,starty]\n            nc=blist[c]\n            nc.remove(cl)\n            ok=[cl]\n            goal=[goalx,goaly]\n            tansaku(cl,nc,ok,goal)\n            if goal in ok:\n                print \"OK\"\n            else:\n                print \"NG\"", "sampled": "from collections import deque\n\ndef solve():\n    while True:\n        w, h = map(int, input().split())\n        if w == 0 and h == 0:\n            break\n        \n        xs, ys = map(int, input().split())\n        xg, yg = map(int, input().split())\n        n = int(input())\n        \n        # Create board to store color at each position\n        board = [[0] * (w + 1) for _ in range(h + 1)]\n        \n        for _ in range(n):\n            c, d, x, y = map(int, input().split())\n            if d == 0:  # horizontal (2 height, 4 width)\n                for dy in range(2):\n                    for dx in range(4):\n                        if 1 <= y + dy <= h and 1 <= x + dx <= w:\n                            board[y + dy][x + dx] = c\n            else:  # vertical (4 height, 2 width)\n                for dy in range(4):\n                    for dx in range(2):\n                        if 1 <= y + dy <= h and 1 <= x + dx <= w:\n                            board[y + dy][x + dx] = c\n        \n        # BFS from start to goal\n        start_color = board[ys][xs]\n        if start_color == 0 or board[yg][xg] != start_color:\n            print(\"NG\")\n            continue\n        \n        visited = [[False] * (w + 1) for _ in range(h + 1)]\n        queue = deque([(xs, ys)])\n        visited[ys][xs] = True\n        found = False\n        \n        while queue:\n            x, y = queue.popleft()\n            if x == xg and y == yg:\n                found = True\n                break\n            \n            # Check 4 adjacent cells\n            for dx, dy in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                nx, ny = x + dx, y + dy\n                if 1 <= nx <= w and 1 <= ny <= h:\n                    if not visited[ny][nx] and board[ny][nx] == start_color:\n                        visited[ny][nx] = True\n                        queue.append((nx, ny))\n        \n        print(\"OK\" if found else \"NG\")\n\nsolve()\n", "perturbed_sampled": ["from collections  True: w, h = map(int, input().split())  h == 0: break xs, ys   1)  y = map(int, input().split()) if d ==   y + dy <= h  dx <= w: board[y + dy][x  # vertical (4 height, 2 width)  1 <= y + dy  w: board[y +   goal start_color = board[ys][xs]  board[yg][xg] != start_color: print(\"NG\")  _ in range(h + 1)] queue  True  x, y = queue.popleft() if x == xg and y == yg: found = True break #   (-1, 0)]: nx, ny = x + dx, y  h: if   ny)) print(\"OK\" if found else \"NG\") solve()"], "perturbed_original": ["sys.setrecursionlimit(10000) def tansaku(cl,nc,ok,goal): #currentlocation,nonchecked,ok,goal [clx,cly]=cl for i in range(clx-1,clx+2): for j in range(cly-1,cly+2): if [i,j] in nc: nc.remove([i,j]) ok.append([i,j]) tansaku([i,j],nc,ok,goal) while(1): [boardw,boardh]=[int(x) for x in <extra_id_4>[xx,yy] in [startx,starty]<extra_id_5>[xx,yy]==[startx,starty]:<extra_id_6>for x in range(x,x+3):<extra_id_7>= 0.05 x=-1,<extra_id_8>xx+3]===[startx,starty] : x  in  #mark location of  raw_input().split()] if d: #d=1,tatenaga for xx in range(x,x+2): for  in range(x,x+4): for  [xx,yy]==[startx,starty]: startc=c     print \"NG\""], "original_ll": -1.0870022773742676, "sampled_ll": -0.6240677833557129, "all_perturbed_sampled_ll": [-3.238525629043579], "all_perturbed_original_ll": [-2.789487361907959], "perturbed_sampled_ll": -3.238525629043579, "perturbed_original_ll": -2.789487361907959, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "long long table[8]={0,1,2,3,5,7,8,9},r;main(n,i){for(;scanf(\"%d\",&n),n;printf(\"%lld\\n\",r))for(r=0,i=1;n;n/=8,i*=10)r+=table[n&7]*i;exit(0);}", "sampled": "#include <stdio.h>\n\nlong long convert(long long n) {\n    long long result = 0;\n    long long base = 1;\n    \n    while (n > 0) {\n        long long digit = n % 10;\n        n /= 10;\n        \n        if (digit >= 4) digit++;\n        if (digit >= 6) digit++;\n        \n        result = digit * base + result;\n        base *= 10;\n    }\n    \n    return result;\n}\n\nlong long solve(long long n) {\n    long long left = 1, right = 10000000000LL;\n    long long answer = 1;\n    \n    while (left <= right) {\n        long long mid = left + (right - left) / 2;\n        long long converted = convert(mid);\n        \n        if (converted == n) {\n            return n;\n        } else if (converted < n) {\n            answer = converted;\n            left = mid + 1;\n        } else {\n            right = mid - 1;\n        }\n    }\n    \n    return answer;\n}\n\nlong long count_valid(long long n) {\n    if (n == 0) return 0;\n    \n    long long result = 0;\n    long long power = 1;\n    long long temp = n;\n    int digits = 0;\n    \n    while (temp > 0) {\n        digits++;\n        temp /= 10;\n    }\n    \n    for (int d = 1; d < digits; d++) {\n        long long count = 1;\n        for (int i = 0; i < d; i++) {\n            count *= 8;\n        }\n        result += count;\n    }\n    \n    temp = n;\n    long long prefix = 0;\n    for (int pos = digits; pos >= 1; pos--) {\n        long long divisor = 1;\n        for (int i = 1; i < pos; i++) {\n            divisor *= 10;\n        }\n        \n        long long digit = temp / divisor;\n        temp %= divisor;\n        \n        long long count_before = digit;\n        if (digit > 4) count_before--;\n        if (digit > 6) count_before--;\n        \n        long long suffix_count = 1;\n        for (int i = 1; i < pos; i++) {\n            suffix_count *= 8;\n        }\n        \n        result += count_before * suffix_count;\n        \n        if (digit == 4 || digit == 6) {\n            return result;\n        }\n    }\n    \n    result++;\n    return result;\n}\n\nlong long find_nth(long long n) {\n    long long left = 1, right = 10000000000LL;\n    long long answer = 1;\n    \n    while (left <= right) {\n        long long mid = left + (right - left) / 2;\n        long long count = count_valid(mid);\n        \n        if (count == n) {\n            while (mid % 10 == 4 || mid % 10 == 6) {\n                mid--;\n            }\n            long long temp = mid;\n            int has_4_or_6 = 0;\n            while (temp > 0) {\n                int d = temp % 10;\n                if (d == 4 || d == 6) {\n                    has_4_or_6 = 1;\n                    break;\n                }\n                temp /= 10;\n            }\n            if (!has_4_or_6) {\n                return mid;\n            }\n            right = mid - 1;\n        } else if (count < n) {\n            left = mid + 1;\n        } else {\n            answer = mid;\n            right = mid - 1;\n        }\n    }\n    \n    while (left <= 10000000000LL) {\n        long long count = count_valid(left);\n        if (count == n) {\n            long long temp = left;\n            int has_4_or_6 = 0;\n            while (temp > 0) {\n                int d = temp % 10;\n                if (d == 4 || d == 6) {\n                    has_4_or_6 = 1;\n                    break;\n                }\n                temp /= 10;\n            }\n            if (!has_4_or_6) {\n                return left;\n            }\n        }\n        left++;\n    }\n    \n    return answer;\n}\n\nint main() {\n    long long n;\n    while (scanf(\"%lld\", &n) == 1 && n != 0) {\n        printf(\"%lld\\n\", find_nth(n));\n    }\n    return 0;\n}\n", "perturbed_sampled": ["#include  result = 0; long long   digit = n % 10; n  4) digit++; if  = digit  *= 10; } return  right = 10000000000LL; long long  <=  n) {  long n) { if (n ==    digits; d++)   8;  long prefix  = digits; pos >= 1; pos--)  1; for (int i = 1; i  *= 10; }  / divisor; temp  = digit; if  (digit > 6)  1; for (int i = 1; i < pos; i++) {  += count_before * suffix_count; if (digit == 4 || digit == 6) { return result; } } result++;    = 10000000000LL;  while (left <= right) { long long  long  long temp = mid; int has_4_or_6 = 0; while (temp > 0) { int d = temp % 10; if (d == 4 ||  temp  right = mid - 1; } else if (count < n) { left = mid +  mid - 1; } } while  long count = count_valid(left); if (count == n) { long long temp = left; int  > 0)  == 6) { has_4_or_6 = 1; break; } temp /= 10;  left; } } left++;  main() { long long n; while (scanf(\"%lld\",  find_nth(n)); } return 0; }"], "perturbed_original": ["long long table[8]={0,1,2,3,5,7,8,9},r;main(n,i){for(;scanf(\"%d\",&n),n;printf(\"%lld\\n\",r))for(r=0,i=1;n;n/=8,i*=10)r+=table[n&7]*i;exit(0);}"], "original_ll": -2.177025079727173, "sampled_ll": -0.5175026655197144, "all_perturbed_sampled_ll": [-2.397477149963379], "all_perturbed_original_ll": [-2.177025079727173], "perturbed_sampled_ll": -2.397477149963379, "perturbed_original_ll": -2.177025079727173, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import java.util.Scanner;\nimport java.util.regex.Pattern;\n\nclass Main{\n\tpublic static void main(String[] args){\n\t\tScanner stdIn = new Scanner(System.in);\n\t\tPattern pattern = Pattern.compile(\"^4|^6\");\n\t\tPattern pattern2 = Pattern.compile(\".*4.*|.*6.*\");\n\n\t\twhile(true){\n\t\t\tlong oldNumber = stdIn.nextLong();\n\t\t\tlong newNumber = 0;\n\n\t\t\tif(oldNumber == 0){break;}\n\n\t\t\tint count = 0;\n\t\t\twhile(count < oldNumber){\n\t\t\t\tnewNumber++;\n\t\t\t\tString stringNewNumber = Long.toString(newNumber);\n\t\t\t\tif(pattern.matcher(stringNewNumber).find()){\n\t\t\t\t\tnewNumber += Math.pow(10, stringNewNumber.length()-1);\n\t\t\t\t}else if(pattern2.matcher(stringNewNumber).find()){\n\t\t\t\t\twhile(pattern2.matcher(Long.toString(newNumber)).find()){\n\t\t\t\t\t\tnewNumber++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcount++;\n\t\t\t}\n\t\t\tSystem.out.println(newNumber);\n\t\t}\n\t}\n}", "sampled": "import java.util.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        \n        while (true) {\n            long n = sc.nextLong();\n            if (n == 0) break;\n            \n            System.out.println(convertToNewRoomNumber(n));\n        }\n        \n        sc.close();\n    }\n    \n    static long convertToNewRoomNumber(long oldNumber) {\n        long result = 0;\n        long multiplier = 1;\n        long remaining = oldNumber;\n        \n        while (remaining > 0) {\n            long digit = remaining % 10;\n            remaining /= 10;\n            \n            // Map digit to new system (base 8 excluding 4 and 6)\n            // 0->0, 1->1, 2->2, 3->3, 4->5, 5->7, 6->8, 7->9\n            long mappedDigit;\n            if (digit <= 3) {\n                mappedDigit = digit;\n            } else if (digit == 4) {\n                mappedDigit = 5;\n            } else if (digit == 5) {\n                mappedDigit = 7;\n            } else if (digit == 6) {\n                mappedDigit = 8;\n            } else {\n                mappedDigit = 9;\n            }\n            \n            result += mappedDigit * multiplier;\n            multiplier *= 10;\n        }\n        \n        return result;\n    }\n}\n", "perturbed_sampled": ["import  public static void  =  = 0;  remaining = oldNumber; while (remaining > 0)  % 10; remaining /= 10;  system (base 8 excluding 4 and 6) // 0->0, 1->1, 2->2, 3->3, 4->5, 5->7, 6->8, 7->9 long mappedDigit; if (digit <= 3) {      } else  multiplier; multiplier *= 10; } return result; } }"], "perturbed_original": ["import  public static void main(String[] args){  Pattern pattern = Pattern.compile(\"^4|^6\"); Pattern pattern2 = Pattern.compile(\".*4.*|.*6.*\"); while(true){  newNumber = 0; if(oldNumber == 0){break;}   +=  }"], "original_ll": -0.9945505261421204, "sampled_ll": -0.6980358362197876, "all_perturbed_sampled_ll": [-2.647249698638916], "all_perturbed_original_ll": [-3.1539647579193115], "perturbed_sampled_ll": -2.647249698638916, "perturbed_original_ll": -3.1539647579193115, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "def testcase_ends():\n    n = int(input())\n    if n == 0:\n        return 1\n\n    n = oct(n)[2:]\n    n = n.replace('7', '9')\n    n = n.replace('6', '8')\n    n = n.replace('5', '7')\n    n = n.replace('4', '5')\n    print(n)\n    return 0\n\ndef main():\n    while not testcase_ends():\n        pass\n\nif __name__ == '__main__':\n    main()\n\n", "sampled": "def convert_to_new_room(n):\n    # Convert n to base-8 representation, treating digits 0-7 as valid\n    # Then map: 0->1, 1->2, 2->3, 3->5, 4->7, 5->8, 6->9, 7->10\n    # This is essentially converting to a number system without 4 and 6\n    \n    # First, convert n to base 8\n    if n == 0:\n        return 0\n    \n    result = 0\n    multiplier = 1\n    temp_n = n\n    \n    while temp_n > 0:\n        digit = temp_n % 8\n        temp_n //= 8\n        \n        # Map the digit (0-7 in base 8 concept) to actual digit without 4 and 6\n        # digit 0 -> 1, 1 -> 2, 2 -> 3, 3 -> 5, 4 -> 7, 5 -> 8, 6 -> 9, 7 -> 10\n        if digit == 0:\n            mapped = 1\n        elif digit == 1:\n            mapped = 2\n        elif digit == 2:\n            mapped = 3\n        elif digit == 3:\n            mapped = 5\n        elif digit == 4:\n            mapped = 7\n        elif digit == 5:\n            mapped = 8\n        elif digit == 6:\n            mapped = 9\n        else:  # digit == 7\n            mapped = 10\n        \n        result += mapped * multiplier\n        multiplier *= 10\n    \n    return result\n\nwhile True:\n    n = int(input())\n    if n == 0:\n        break\n    print(convert_to_new_room(n))\n", "perturbed_sampled": ["def convert_to_new_room(n): # Convert n   map:  to a number system without 4 and 6 # First, convert n   while temp_n > 0: digit = temp_n % 8 temp_n //= 8  in base 8  digit 0 -> 1, 1 -> 2, 2 -> 3, 3 -> 5,  8, 6 -> 9, 7 -> 10 if  elif digit  elif digit ==   5: mapped = 8 elif digit    while True:  == 0: break print(convert_to_new_room(n))"], "perturbed_original": ["def testcase_ends(): n = int(input()) if n == 0: return 1 n =     testcase_ends():  main()"], "original_ll": -1.3329813480377197, "sampled_ll": -0.8546311259269714, "all_perturbed_sampled_ll": [-3.0072720050811768], "all_perturbed_original_ll": [-4.2271857261657715], "perturbed_sampled_ll": -3.0072720050811768, "perturbed_original_ll": -4.2271857261657715, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "#include<stdio.h>\n\n\ntypedef struct{\n  int x;\n  int y;\n  int ny;\n  int nx;\n  char dir;\n  int movable;\n}man;\ntypedef struct{\n  int x;\n  int y;\n}d;\n\nchar map[30][31];\nint w,h;\nman ms[900];\nint msize;\nd dir[4]={{1,0},{0,-1},{-1,0},{0,1}};\n//memo 0:east 1:north 2:west 3:south\nchar n2d(int d){\n  return d==0?'E':d==1?'N':d==2?'W':'S';\n}\nint d2n(char d){\n  return d=='E'?0:d=='N'?1:d=='W'?2:d=='S'?3:-1;\n}\nint main(){\n  int i,j,l,k,nx,ny;\n  do{\n    scanf(\"%d %d\",&w,&h);\n    if(w==0&&h==0) break;\n    msize=0;\n    for(i=0;i<h;i++){      \n      scanf(\"%s\",map+i);\n      for(j=0;j<w;j++){\n\tif(map[i][j]!='#'&&map[i][j]!='.'&&map[i][j]!='X'){\n\t  ms[msize].x=j;\n\t  ms[msize].y=i;\n\t  ms[msize].dir=d2n(map[i][j]);\n\t  msize++;\n\t}\n      }\n    }\n    for(i=1;i<181;i++){\n      /*            for(j=0;j<h;j++)\n\tprintf(\"%s\\n\",map+j);\n\tprintf(\"\\n\");*/\n      for(j=0;j<msize;j++){\n\tms[j].movable=0;\n\tfor(k=-1;k<3;k++){\n\t  ms[j].nx=ms[j].x+dir[(4+ms[j].dir+k)%4].x;\n\t  ms[j].ny=ms[j].y+dir[(4+ms[j].dir+k)%4].y;\n\t  if(map[ms[j].ny][ms[j].nx]=='X'){\n\t    ms[j].movable=1;\n\t    break;\t    \n\t  }else if(map[ms[j].ny][ms[j].nx]=='.'){\n\t    ms[j].dir=(4+ms[j].dir+k)%4;\n\t    ms[j].movable=1;\n\t    break;\n\t  }\t  \n\t}\n      }\n      for(j=0;j<msize;j++){\n\tif(map[ms[j].ny][ms[j].nx]!='X'&&ms[j].movable)\n\t  for(k=0;k<4;k++){\n\t    nx=ms[j].nx+dir[k].x;\n\t    ny=ms[j].ny+dir[k].y;\n\t    //\t    printf(\"(%d %d %c) \",ny,nx,map[ny][nx]);\n\t    if(isalpha(map[ny][nx])\n\t       &&map[ny][nx]!='X'\n\t       &&((d2n(map[ny][nx])+2)%4)==k){\n//\t      printf(\"%d %d %c\\n\",ny,nx,map[ny][nx]);\n\t      if(ms[j].x!=nx||ms[j].y!=ny){\n\t\tms[j].movable=0;\t\t\n\t      }\n\t      break;\n\t    }else if(ms[j].x==nx&&ms[j].y==ny){\n\t      map[ms[j].y][ms[j].x]=n2d(ms[j].dir);\n\t      break;\n\t    }\n\t  }\n\t//\tprintf(\"\\n\");\n      }\n      for(j=0;j<msize;j++){\n\tif(map[ms[j].ny][ms[j].nx]=='X'){\n\t  map[ms[j].y][ms[j].x]='.';\n\t  for(l=j;l<msize;l++){\n\t    ms[l]=ms[l+1];\n\t  }\t    \n\t  j--;\n\t  msize--;\n\t}else if(ms[j].movable){\n\t  map[ms[j].y][ms[j].x]='.';\n\t  map[ms[j].ny][ms[j].nx]=n2d(ms[j].dir);\n\t  ms[j].x=ms[j].nx;\n\t  ms[j].y=ms[j].ny;\n\t}\n      }\n      if(msize==0){\n\tprintf(\"%d\\n\",i);\n\tbreak;\n      }\n    }\n    if(i==181)\n      printf(\"NA\\n\");\n  }while(1);\n  return 0;\n}", "sampled": "#include <stdio.h>\n#include <string.h>\n\n#define MAX 30\n\ntypedef struct {\n    int x, y;\n    char dir;\n} Person;\n\nchar grid[MAX][MAX];\nint W, H;\nPerson people[MAX*MAX];\nint num_people;\n\nint dx[] = {1, 0, -1, 0}; // E, N, W, S\nint dy[] = {0, -1, 0, 1};\nchar dirs[] = \"ENWS\";\n\nint get_dir_idx(char d) {\n    for(int i = 0; i < 4; i++) {\n        if(dirs[i] == d) return i;\n    }\n    return 0;\n}\n\nint is_passable(int x, int y) {\n    if(x < 0 || x >= W || y < 0 || y >= H) return 0;\n    return grid[y][x] == '.' || grid[y][x] == 'X';\n}\n\nvoid simulate() {\n    int time = 0;\n    \n    while(num_people > 0 && time <= 180) {\n        time++;\n        \n        // Step 1: Change direction\n        for(int i = 0; i < num_people; i++) {\n            int dir_idx = get_dir_idx(people[i].dir);\n            int found = 0;\n            \n            // Check right, front, left, back\n            int order[] = {(dir_idx + 3) % 4, dir_idx, (dir_idx + 1) % 4, (dir_idx + 2) % 4};\n            \n            for(int j = 0; j < 4; j++) {\n                int d = order[j];\n                int nx = people[i].x + dx[d];\n                int ny = people[i].y + dy[d];\n                \n                if(is_passable(nx, ny)) {\n                    people[i].dir = dirs[d];\n                    found = 1;\n                    break;\n                }\n            }\n        }\n        \n        // Step 2: Move\n        int target_count[MAX][MAX];\n        int target_who[MAX][MAX][4];\n        memset(target_count, 0, sizeof(target_count));\n        \n        for(int i = 0; i < num_people; i++) {\n            int dir_idx = get_dir_idx(people[i].dir);\n            int nx = people[i].x + dx[dir_idx];\n            int ny = people[i].y + dy[dir_idx];\n            \n            if(is_passable(nx, ny)) {\n                target_who[ny][nx][target_count[ny][nx]++] = i;\n            }\n        }\n        \n        int moved[MAX*MAX];\n        memset(moved, 0, sizeof(moved));\n        \n        for(int y = 0; y < H; y++) {\n            for(int x = 0; x < W; x++) {\n                if(target_count[y][x] > 1) {\n                    // Multiple people want this spot\n                    // Priority: E, N, W, S of the target\n                    int priority_order[] = {0, 1, 2, 3}; // E, N, W, S\n                    int selected = -1;\n                    \n                    for(int p = 0; p < 4; p++) {\n                        int check_x = x - dx[priority_order[p]];\n                        int check_y = y - dy[priority_order[p]];\n                        \n                        for(int k = 0; k < target_count[y][x]; k++) {\n                            int who = target_who[y][x][k];\n                            if(people[who].x == check_x && people[who].y == check_y) {\n                                selected = who;\n                                break;\n                            }\n                        }\n                        if(selected != -1) break;\n                    }\n                    \n                    if(selected != -1) {\n                        moved[selected] = 1;\n                    }\n                } else if(target_count[y][x] == 1) {\n                    moved[target_who[y][x][0]] = 1;\n                }\n            }\n        }\n        \n        // Apply moves\n        for(int i = 0; i < num_people; i++) {\n            if(moved[i]) {\n                int dir_idx = get_dir_idx(people[i].dir);\n                people[i].x += dx[dir_idx];\n                people[i].y += dy[dir_idx];\n            }\n        }\n        \n        // Remove people at exits\n        int new_num = 0;\n        for(int i = 0; i < num_people; i++) {\n            if(grid[people[i].y][people[i].x] != 'X') {\n                people[new_num++] = people[i];\n            }\n        }\n        num_people = new_num;\n    }\n    \n    if(num_people == 0) {\n        printf(\"%d\\n\", time);\n    } else {\n        printf(\"NA\\n\");\n    }\n}\n\nint main() {\n    while(1) {\n        scanf(\"%d %d\", &W, &H);\n        if(W == 0 && H == 0) break;\n        \n        num_people = 0;\n        for(int i = 0; i < H; i++) {\n            scanf(\"%s\", grid[i]);\n            for(int j = 0; j < W; j++) {\n                if(grid[i][j] == 'E' || grid[i][j] == 'N' || \n                   grid[i][j] == 'W' || grid[i][j] == 'S') {\n                    people[num_people].x = j;\n                    people[num_people].y = i;\n                    people[num_people].dir = grid[i][j];\n                    num_people++;\n                    grid[i][j] = '.';\n                }\n            }\n        }\n        \n        simulate();\n    }\n    \n    return 0;\n}\n", "perturbed_sampled": ["#include <stdio.h> #include <string.h> #define MAX 30 typedef struct { int x,  char grid[MAX][MAX]; int W, H; Person people[MAX*MAX]; int  0, -1, 0}; // E, N, W, S int dy[] = {0, -1,  \"ENWS\"; int get_dir_idx(char d) {  < 4; i++) { if(dirs[i]  {  >= W || y    0; while(num_people  180) { time++; // Step   right, front, left, back int order[]  4, dir_idx, (dir_idx + 1) % 4, (dir_idx + 2)  j++) { int d =  = people[i].y + dy[d]; if(is_passable(nx, ny)) { people[i].dir = dirs[d]; found = 1; break; } } } // Step 2: Move int target_count[MAX][MAX]; int target_who[MAX][MAX][4];   = get_dir_idx(people[i].dir); int nx  ny  i; } }  people  2, 3}; // E, N, W,  for(int p = 0; p <  = x -   = target_who[y][x][k]; if(people[who].x == check_x && people[who].y == check_y) { selected = who; break; }  }  else if(target_count[y][x]  // Apply moves for(int i = 0; i  get_dir_idx(people[i].dir); people[i].x  }  exits int  int  == 0) break; num_people = 0; for(int i = 0; i < H; i++) { scanf(\"%s\", grid[i]); for(int j =  || grid[i][j] == 'N' || grid[i][j] == 'W'  people[num_people].x  people[num_people].dir = grid[i][j]; num_people++; grid[i][j] = '.'; } }  }"], "perturbed_original": ["#include<stdio.h> typedef struct{ int x; int y; int ny; int nx;  int y; }d; char  int msize;  2:west 3:south char n2d(int d){ return d==0?'E':d==1?'N':d==2?'W':'S'; } int d2n(char  msize++; } } }  for(j=0;j<msize;j++){ ms[j].movable=0; for(k=-1;k<3;k++){ ms[j].nx=ms[j].x+dir[(4+ms[j].dir+k)%4].x; ms[j].ny=ms[j].y+dir[(4+ms[j].dir+k)%4].y; if(map[ms[j].ny][ms[j].nx]=='X'){   for(j=0;j<msize;j++){ if(map[ms[j].ny][ms[j].nx]!='X'&&ms[j].movable)  } break;  }  map[ms[j].y][ms[j].x]='.';  }else if(ms[j].movable){ map[ms[j].y][ms[j].x]='.'; map[ms[j].ny][ms[j].nx]=n2d(ms[j].dir);  printf(\"%d\\n\",i); break; } } if(i==181) printf(\"NA\\n\"); }while(1); return 0; }"], "original_ll": -0.9181114435195923, "sampled_ll": -0.5872248411178589, "all_perturbed_sampled_ll": [-2.453368663787842], "all_perturbed_original_ll": [-1.7570537328720093], "perturbed_sampled_ll": -2.453368663787842, "perturbed_original_ll": -1.7570537328720093, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import java.util.*;\npublic class Main {\n\tint [] vx = {1,0,-1,0};\n\tint [] vy = {0,-1,0,1};\n\tboolean [] isgoal;\n\t\n\tclass C{\n\t\tint x,y,dir;\n\t\tpublic C(int x, int y, int dir) {\n\t\t\tthis.x = x;this.y = y;\n\t\t\tif(dir == 'E')\n\t\t\t\tdir = 0;\n\t\t\telse if(dir == 'N')\n\t\t\t\tdir = 1;\n\t\t\telse if(dir == 'S')\n\t\t\t\tdir = 3;\n\t\t\telse if(dir == 'W')\n\t\t\t\tdir = 2;\n\t\t\telse{\n\t\t\t\t\n\t\t\t}\n\t\t\tthis.dir = dir;\n\t\t}\n\t\tpublic String toString() {\n\t\t\treturn \"C [x=\" + x + \", y=\" + y + \", dir=\" + dir + \"]\";\n\t\t}\n\t\t\n\t}\n\n\tprivate void doit(){\n\t\tScanner sc=new Scanner(System.in);\n\t\twhile(true){\n\t\t\tint w = sc.nextInt(), h = sc.nextInt();\n\t\t\tif((w|h) == 0) break;\n\t\t\tchar [][] map = new char[h][w];\n\t\t\tArrayList<C> humlist = new ArrayList<C>();\n\t\t\tfor(int i=0; i < h;i++){\n\t\t\t\tString line = sc.next();\n\t\t\t\tfor(int j=0; j < w;j++){\n\t\t\t\t\tchar c = line.charAt(j);\n\t\t\t\t\tif(c == 'E' || c == 'N' || c == 'W' || c == 'S'){\n\t\t\t\t\t\thumlist.add(new C(j,i,(int)c));\n\t\t\t\t\t\tmap[i][j] = '.';\n\t\t\t\t\t}\n\t\t\t\t\telse{\n\t\t\t\t\t\tmap[i][j] = c;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n//\t\t\t//debug\n//\t\t\tfor(int i=0; i < h; i++){\n//\t\t\t\tfor(int j = 0; j < w; j++){\n//\t\t\t\t\tSystem.out.print(map[i][j]);\n//\t\t\t\t}\n//\t\t\t\tSystem.out.println();\n//\t\t\t}\n//\t\t\tSystem.out.println();\n//\t\t\tSystem.out.println(\"list= \" + humlist.toString());\n\t\t\tint step = 0;\n\t\t\tLinkedList<Integer> open = new LinkedList<Integer>();\n\t\t\topen.add(step);\n\t\t\tint len = humlist.size();\n\t\t\tisgoal = new boolean[len];\n\t\t\tboolean isachieve = true;\n\t\t\twhile(! open.isEmpty()){\n\t\t\t\tstep = open.removeFirst();\n\t\t\t\t//debug\n\t\t\t\t//System.out.println(humlist.toString());\n\t\t\t\t//change dir\n\t\t\t\tfor(int i = 0; i < len;i++){\n\t\t\t\t\tif(isgoal[i])continue;\n\t\t\t\t\tC nowhum = humlist.get(i);\n\t\t\t\t\tint nowdir = nowhum.dir;\n\t\t\t\t\tfor(int j = 0; j < 4; j++){\n\t\t\t\t\t\tnowdir = (j + 4 + nowhum.dir - 1) % 4;\n\t\t\t\t\t\tint xx = nowhum.x + vx[nowdir];\n\t\t\t\t\t\tint yy = nowhum.y + vy[nowdir];\n\t\t\t\t\t\tif(map[yy][xx] == '#') continue;\n\t\t\t\t\t\tif((map[yy][xx] == 'X' || map[yy][xx] == '.') && ! isin(xx,yy,humlist)){\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tnowhum.dir = nowdir;\n\t\t\t\t\thumlist.set(i, nowhum);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t//move\n\t\t\t\tArrayList<C> humlistrecord = valueC(humlist);\n\t\t\t\tfor(int i=0; i < len; i++){\n\t\t\t\t\tif(isgoal[i]) continue;\n\t\t\t\t\tC nowhum = humlist.get(i);\n\t\t\t\t\tint xx = nowhum.x + vx[nowhum.dir];\n\t\t\t\t\tint yy = nowhum.y + vy[nowhum.dir];\n\t\t\t\t\tif(map[yy][xx] == '#' || isin(xx,yy,humlist)) continue;\n\t\t\t\t\tint movehum = getmove(xx,yy,humlistrecord);\n\t\t\t\t\tif(movehum == i){\n\t\t\t\t\t\tnowhum.x = xx;\n\t\t\t\t\t\tnowhum.y = yy;\n\t\t\t\t\t\thumlist.set(i, nowhum);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t//escape\n\t\t\t\tfor(int i = 0; i < len;i++){\n\t\t\t\t\tC nowhum = humlist.get(i);\n\t\t\t\t\tint humx = nowhum.x,humy = nowhum.y;\n\t\t\t\t\tif(map[humy][humx] == 'X'){\n\t\t\t\t\t\tisgoal[i] = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t//fin\n\t\t\t\tif(isAllGoal()){\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif(step + 1 > 180){\n\t\t\t\t\tisachieve = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\topen.add(step + 1);\n\t\t\t}\n\t\t\tif(isachieve){\n\t\t\t\tif(humlist.size() == 0){\n\t\t\t\t\tSystem.out.println(0);\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tSystem.out.println(step + 1);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t}\n\t\t\telse{\n\t\t\t\tSystem.out.println(\"NA\");\n\t\t\t}\n\t\t}\n\t}\n\t\n\tprivate boolean isAllGoal(){\n\t\tfor(int i=0; i < isgoal.length;i++){\n\t\t\tif(! isgoal[i]) return false;\n\t\t}\n\t\treturn true;\n\t}\n\t\n\tprivate int getmove(int x, int y, ArrayList<C> list){\n\t\tfor(int i=0; i < 4;i++){\n\t\t\tint xx = x + vx[i];\n\t\t\tint yy = y + vy[i];\n\t\t\tfor(int j=0; j < list.size(); j++){\n\t\t\t\tif(isgoal[j])continue;\n\t\t\t\tC now = list.get(j);\n\t\t\t\tboolean cond1 = (xx == now.x && yy == now.y);\n\t\t\t\tboolean cond2 = ((now.x + vx[now.dir]) == x && (now.y + vy[now.dir]) == y);\n\t\t\t\tif(cond1 && cond2){\n\t\t\t\t\treturn j;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn -1;\n\t}\n\tprivate ArrayList<C> valueC(ArrayList<C> list){\n\t\tArrayList<C> res =  new ArrayList<C>();\n\t\tfor(int i = 0; i < list.size(); i++){\n\t\t\tC now = list.get(i);\n\t\t\tres.add(new C(now.x, now.y, now.dir));\n\t\t}\n\t\treturn res;\n\t}\n\t\n\tprivate boolean isin(int x, int y,ArrayList<C> list){\n\t\tfor(int i=0; i < list.size();i++){\n\t\t\tif(isgoal[i])continue;\n\t\t\tC now = list.get(i);\n\t\t\tif(now.x == x && now.y == y){\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\n\n\tpublic static void main(String[] args) {\n\t\tMain obj = new Main();\n\t\tobj.doit();\n\t}\n}", "sampled": "import java.util.*;\nimport java.io.*;\n\npublic class Main {\n    static class Person {\n        int x, y;\n        char dir;\n        \n        Person(int x, int y, char dir) {\n            this.x = x;\n            this.y = y;\n            this.dir = dir;\n        }\n    }\n    \n    static int[] dx = {1, 0, -1, 0}; // E, N, W, S\n    static int[] dy = {0, -1, 0, 1};\n    static Map<Character, Integer> dirMap = new HashMap<>();\n    \n    static {\n        dirMap.put('E', 0);\n        dirMap.put('N', 1);\n        dirMap.put('W', 2);\n        dirMap.put('S', 3);\n    }\n    \n    public static void main(String[] args) throws IOException {\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        String line;\n        \n        while ((line = br.readLine()) != null) {\n            String[] parts = line.trim().split(\" \");\n            int W = Integer.parseInt(parts[0]);\n            int H = Integer.parseInt(parts[1]);\n            \n            if (W == 0 && H == 0) break;\n            \n            char[][] grid = new char[H][W];\n            List<Person> people = new ArrayList<>();\n            \n            for (int i = 0; i < H; i++) {\n                String str = br.readLine();\n                for (int j = 0; j < W; j++) {\n                    grid[i][j] = str.charAt(j);\n                    if (dirMap.containsKey(grid[i][j])) {\n                        people.add(new Person(j, i, grid[i][j]));\n                        grid[i][j] = '.';\n                    }\n                }\n            }\n            \n            int result = simulate(grid, people, W, H);\n            if (result > 180) {\n                System.out.println(\"NA\");\n            } else {\n                System.out.println(result);\n            }\n        }\n    }\n    \n    static int simulate(char[][] grid, List<Person> people, int W, int H) {\n        int time = 0;\n        \n        while (!people.isEmpty() && time <= 180) {\n            time++;\n            \n            // Step 1: Update directions\n            for (Person p : people) {\n                int currentDir = dirMap.get(p.dir);\n                int[] checkOrder = {(currentDir + 3) % 4, currentDir, (currentDir + 1) % 4, (currentDir + 2) % 4};\n                \n                for (int d : checkOrder) {\n                    int nx = p.x + dx[d];\n                    int ny = p.y + dy[d];\n                    \n                    if (nx >= 0 && nx < W && ny >= 0 && ny < H && \n                        (grid[ny][nx] == '.' || grid[ny][nx] == 'X')) {\n                        p.dir = getDir(d);\n                        break;\n                    }\n                }\n            }\n            \n            // Step 2: Determine moves\n            Map<String, List<Person>> targetMap = new HashMap<>();\n            \n            for (Person p : people) {\n                int d = dirMap.get(p.dir);\n                int nx = p.x + dx[d];\n                int ny = p.y + dy[d];\n                \n                if (nx >= 0 && nx < W && ny >= 0 && ny < H && \n                    (grid[ny][nx] == '.' || grid[ny][nx] == 'X')) {\n                    String key = nx + \",\" + ny;\n                    targetMap.putIfAbsent(key, new ArrayList<>());\n                    targetMap.get(key).add(p);\n                }\n            }\n            \n            // Step 3: Move people\n            Set<Person> toRemove = new HashSet<>();\n            \n            for (String key : targetMap.keySet()) {\n                List<Person> candidates = targetMap.get(key);\n                \n                if (candidates.size() == 1) {\n                    Person p = candidates.get(0);\n                    String[] coords = key.split(\",\");\n                    p.x = Integer.parseInt(coords[0]);\n                    p.y = Integer.parseInt(coords[1]);\n                    \n                    if (grid[p.y][p.x] == 'X') {\n                        toRemove.add(p);\n                    }\n                } else {\n                    // Priority: E, N, W, S (by position of source)\n                    Person selected = null;\n                    int[] priority = {0, 1, 2, 3}; // E, N, W, S\n                    \n                    for (int pri : priority) {\n                        for (Person p : candidates) {\n                            int d = dirMap.get(p.dir);\n                            if (d == pri) {\n                                selected = p;\n                                break;\n                            }\n                        }\n                        if (selected != null) break;\n                    }\n                    \n                    if (selected != null) {\n                        String[] coords = key.split(\",\");\n                        selected.x = Integer.parseInt(coords[0]);\n                        selected.y = Integer.parseInt(coords[1]);\n                        \n                        if (grid[selected.y][selected.x] == 'X') {\n                            toRemove.add(selected);\n                        }\n                    }\n                }\n            }\n            \n            people.removeAll(toRemove);\n        }\n        \n        return time;\n    }\n    \n    static char getDir(int d) {\n        switch (d) {\n            case 0: return 'E';\n            case 1: return 'N';\n            case 2: return 'W';\n            case 3: return 'S';\n        }\n        return 'E';\n    }\n}\n", "perturbed_sampled": ["import java.util.*;  char dir; Person(int  this.y  dx = {1, 0, -1, 0}; // E,  dy = {0, -1, 0,  { dirMap.put('E', 0); dirMap.put('N', 1); dirMap.put('W', 2); dirMap.put('S', 3); } public static void  BufferedReader br = new  H  0) break; char[][] grid  (int i  j = 0; j <  grid[i][j] = '.'; }  if (result > 180) { System.out.println(\"NA\"); } else { System.out.println(result); } } } static int simulate(char[][]  Step 1: Update directions for (Person p :  dirMap.get(p.dir); int[] checkOrder = {(currentDir + 3)  1) %  4}; for (int d : checkOrder) {  dx[d]; int ny = p.y + dy[d]; if   0 && ny < H && (grid[ny][nx]  getDir(d); break; } }  =   int ny = p.y + dy[d]; if (nx >= 0 && nx < W  ny < H && (grid[ny][nx] == '.' ||  key = nx + \",\" + ny; targetMap.putIfAbsent(key, new ArrayList<>());  3:  List<Person> candidates  1) { Person p  key.split(\",\"); p.x  { toRemove.add(p);  null; int[] priority = {0, 1, 2, 3}; // E, N,  : priority) { for (Person  d = dirMap.get(p.dir); if (d  p; break; } }  { toRemove.add(selected);  } return time; } static char getDir(int d) {  return 'E';  3: return 'S'; } return 'E'; } }"], "perturbed_original": [" [] isgoal; class C{ int x,y,dir; public C(int  {  if(dir == 'E') dir =   == 'S') dir = 3; else if(dir == 'W') dir = 2; else{ } this.dir = dir; } public String toString() {   dir + \"]\"; } } private void doit(){  w = sc.nextInt(), h =  char [][]  h;i++){ String line = sc.next(); for(int j=0; j  line.charAt(j); if(c == 'E' || c == 'N' || c ==  '.'; } else{ map[i][j] = c; } } } // //debug // for(int i=0; i <  =   System.out.println(); // System.out.println(\"list=  isgoal = new  while(! open.isEmpty()){ step = open.removeFirst();  nowhum = humlist.get(i); int nowdir = nowhum.dir;  + nowhum.dir - 1) %  = nowhum.y + vy[nowdir]; if(map[yy][xx] == '#') continue; if((map[yy][xx] == 'X' || map[yy][xx] == '.')  humlist.set(i, nowhum); } //move ArrayList<C> humlistrecord = valueC(humlist); for(int   humlist.get(i); int xx =  if(map[yy][xx] == '#' || isin(xx,yy,humlist))  if(movehum ==  =  0; i < len;i++){ C nowhum = humlist.get(i); int  if(map[humy][humx]  break; }  0){ System.out.println(0);  isgoal[i]) return false; } return true; } private int getmove(int  4;i++){ int  int yy  j=0; j < list.size(); j++){ if(isgoal[j])continue; C    j; }  private ArrayList<C> valueC(ArrayList<C> list){ ArrayList<C>  < list.size(); i++){ C now = list.get(i); res.add(new   = list.get(i); if(now.x == x && now.y ==  static void  = new Main(); obj.doit(); } }"], "original_ll": -0.7980371117591858, "sampled_ll": -0.49809587001800537, "all_perturbed_sampled_ll": [-2.625694751739502], "all_perturbed_original_ll": [-2.8141398429870605], "perturbed_sampled_ll": -2.625694751739502, "perturbed_original_ll": -2.8141398429870605, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import sys\n\ndirection = {'N' : 0, 'E' : 1, 'S' : 2, 'W' : 3}\nstep = [( -1, 0 ), ( 0, 1 ), ( 1, 0 ), ( 0, -1 )]\nvv = []\n\nwhile True:\n    W, H = map( int, sys.stdin.readline().rstrip().split() )\n    if W == 0 and H == 0: break\n    m = [ list( sys.stdin.readline().strip() ) for i in xrange( H ) ]\n    people = [ ( i, j, direction[ m[i][j] ] ) for i in xrange( H ) for j in range( W )\n               if m[i][j] in \"NESW\" ]\n    time = 0\n    while any( people ):\n        time += 1\n        if time > 180:\n            time = -1\n            break\n        sched = []\n        for n in xrange( len( people ) ):\n            if people[n] is None: continue\n            x, y, d = people[n]\n            for i in range(1, -3, -1):\n                    dx, dy = step[(d + i) % 4]\n                    if 0 <= x+dx < H and 0 <= y+dy < W and m[x+dx][y+dy] in \"X.\":\n                        people[n][2] = (d + i) % 4\n                        beat = True\n                        for k in range( len( sched ) ):\n                            xx, yy, dd = sched[k][1:]\n                            if ( x+dx, y+dy ) == ( xx, yy ):\n                                if dd < (d + i) % 4:\n                                    sched[k] = ( n, x+dx, y+dy, (d + i) % 4 )\n                                    beat = False\n                                    break\n                                else:\n                                    beat = False\n                                    break\n                        if beat:\n                            sched.append( ( n, x+dx, y+dy, (d + i) % 4 ) )\n\t\t\tbreak\n        for ( k, x, y, d ) in sched:\n            m[ people[k][0] ][ people[k][1] ] = '.'\n            if m[x][y] == 'X':\n                people[k] = None\n            else:\n                m[x][y] = 'H'\n                people[k] = x, y, d\n    if time >= 0:\n        vv.append(time)\n    else:\n        vv.append('NA')\n\nfor v in vv:\n    print v", "sampled": "from collections import deque\n\ndef solve():\n    while True:\n        W, H = map(int, input().split())\n        if W == 0 and H == 0:\n            break\n        \n        grid = []\n        people = []\n        \n        for i in range(H):\n            row = input().strip()\n            grid.append(list(row))\n            for j in range(len(row)):\n                if row[j] in 'ENSW':\n                    people.append([i, j, row[j]])\n                    grid[i][j] = '.'\n        \n        # Direction mappings\n        dir_map = {\n            'E': (0, 1),\n            'W': (0, -1),\n            'N': (-1, 0),\n            'S': (1, 0)\n        }\n        \n        dir_names = ['E', 'W', 'N', 'S']\n        \n        # Right, front, left, back relative to current direction\n        turn_order = {\n            'E': ['S', 'E', 'N', 'W'],\n            'W': ['N', 'W', 'S', 'E'],\n            'N': ['E', 'N', 'W', 'S'],\n            'S': ['W', 'S', 'E', 'N']\n        }\n        \n        time = 0\n        \n        while people and time <= 180:\n            # Step 1: Update directions\n            new_people = []\n            for person in people:\n                r, c, facing = person\n                \n                # Check right, front, left, back\n                found_dir = None\n                for check_dir in turn_order[facing]:\n                    dr, dc = dir_map[check_dir]\n                    nr, nc = r + dr, c + dc\n                    \n                    if 0 <= nr < H and 0 <= nc < W:\n                        cell = grid[nr][nc]\n                        if cell == '.' or cell == 'X':\n                            # Check if occupied by another person\n                            occupied = False\n                            for other in people:\n                                if other[0] == nr and other[1] == nc:\n                                    occupied = True\n                                    break\n                            \n                            if not occupied:\n                                found_dir = check_dir\n                                break\n                \n                if found_dir:\n                    new_people.append([r, c, found_dir])\n                else:\n                    new_people.append([r, c, facing])\n            \n            people = new_people\n            \n            # Step 2: Move people\n            # Calculate target positions for each person\n            targets = {}\n            for idx, person in enumerate(people):\n                r, c, facing = person\n                dr, dc = dir_map[facing]\n                nr, nc = r + dr, c + dc\n                \n                if 0 <= nr < H and 0 <= nc < W:\n                    cell = grid[nr][nc]\n                    if cell == '.' or cell == 'X':\n                        if (nr, nc) not in targets:\n                            targets[(nr, nc)] = []\n                        targets[(nr, nc)].append((idx, r, c))\n            \n            # Resolve conflicts\n            moved = set()\n            new_people = []\n            \n            for target, candidates in targets.items():\n                if len(candidates) == 1:\n                    idx, r, c = candidates[0]\n                    moved.add(idx)\n                else:\n                    # Priority: E, N, W, S\n                    priority_order = [(0, 1), (-1, 0), (0, -1), (1, 0)]\n                    tr, tc = target\n                    \n                    selected = None\n                    for dr, dc in priority_order:\n                        sr, sc = tr - dr, tc - dc\n                        for idx, r, c in candidates:\n                            if r == sr and c == sc:\n                                selected = idx\n                                break\n                        if selected is not None:\n                            break\n                    \n                    if selected is not None:\n                        moved.add(selected)\n            \n            # Update people positions\n            final_people = []\n            for idx, person in enumerate(people):\n                r, c, facing = person\n                if idx in moved:\n                    dr, dc = dir_map[facing]\n                    nr, nc = r + dr, c + dc\n                    \n                    # Check if it's an exit\n                    if grid[nr][nc] == 'X':\n                        # Person escapes\n                        continue\n                    else:\n                        final_people.append([nr, nc, facing])\n                else:\n                    final_people.append([r, c, facing])\n            \n            people = final_people\n            time += 1\n        \n        if people:\n            print(\"NA\")\n        else:\n            print(time)\n\nsolve()\n", "perturbed_sampled": ["from collections import  W, H = map(int, input().split()) if  == 0: break grid  for i   if row[j] in 'ENSW':  '.' # Direction mappings dir_map = { 'E': (0, 1), 'W': (0,  (1,   to  'E': ['S',   while people and  1: Update directions new_people = [] for person  = person # Check right, front, left, back found_dir = None for check_dir in turn_order[facing]: dr, dc = dir_map[check_dir] nr,  0 <= nr < H and 0 <= nc  if  if occupied by another  other in    c, facing]) people = new_people # Step 2: Move  dr, dc =  nr  nc < W: cell  nc)] =  #   len(candidates)  = candidates[0] moved.add(idx) else: # Priority: E, N,  -1),  target selected =  - dc for idx, r,  == sr  = idx break  break if selected is not None: moved.add(selected) # Update people positions final_people = []  person if idx  dir_map[facing] nr, nc = r + dr, c + dc # Check if  == 'X': #  nc, facing]) else:  final_people time += 1  solve()"], "perturbed_original": ["import sys direction =  1, 'S' : 2, 'W' : 3}  ), ( 0,  while True: W, H = map(  xrange( H  ( i, j, direction[ m[i][j] ] ) for i in xrange( H )  ) if m[i][j] in \"NESW\"  > 180: time =  len( people ) ): if people[n] is None: continue x, y, d = people[n] for i    x+dx  = (d + i)  for k in range( len(  ): if    (d + i) % 4 ) ) break for  ) in sched: m[ people[k][0] ][ people[k][1] ] =  people[k] = None else:  x, y, d  else: vv.append('NA') for v in vv: print v"], "original_ll": -1.0252050161361694, "sampled_ll": -0.7398157715797424, "all_perturbed_sampled_ll": [-3.7572782039642334], "all_perturbed_original_ll": [-3.217268705368042], "perturbed_sampled_ll": -3.7572782039642334, "perturbed_original_ll": -3.217268705368042, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "#include<stdio.h>\n#define N 10\ntypedef unsigned long long int INT;\nINT GCD(INT a, INT b){\n\tif( b == 0 ) return a;\n\telse return GCD(b,a%b);\n}\nINT LCM(INT a, INT b){\n\treturn (a/GCD(a,b))*b;\n}\nint main(){\n\twhile(1){\n\t\tint i,n;\n\t\tINT d[N];\n\t\tINT v[N];\n\t\tINT Rates[N];\n\t\tINT lcmV = 1;\n\t\tINT gcdRates = 1;\n\t\tINT lcmRates = 1;\n\n\t\tscanf(\"%d\",&n);\n\t\tif(0==n)break;\n\n\t\tfor(i = 0; i < n; ++i){\n\t\t\tint td, tv;\n\t\t\tint gcd;\n\t\t\tscanf(\"%d%d\",&td,&tv);\n\t\t\tgcd = GCD(td,tv);\n\t\t\td[i] = (INT)td/gcd;\n\t\t\tv[i] = (INT)tv/gcd;\n\t\t}\n\t\t\n\t\tlcmV = LCM( v[0], v[1] );\n\t\tfor(i = 2; i < n; ++i){\n\t\t\tlcmV = LCM( lcmV, v[i] );\n\t\t}\n\t\tfor(i = 0; i < n; ++i){\n\t\t\tRates[i] = (lcmV / v[i])*d[i];\n\t\t}\n\t\tgcdRates = GCD( Rates[0], Rates[1] );\n\t\tfor(i = 2; i < n; ++i){\n\t\t\tgcdRates = GCD( gcdRates, Rates[i] );\n\t\t}\n\t\tfor(i = 0; i < n; ++i){\n\t\t\tRates[i] /= gcdRates;\n\t\t}\n\t\tlcmRates = LCM( Rates[0], Rates[1] );\n\t\tfor(i = 2; i < n; ++i){\n\t\t\tlcmRates = LCM( lcmRates, Rates[i] );\n\t\t}\n\t\tfor(i = 0; i < n; ++i){\n\t\t\tprintf(\"%u\\n\", (unsigned int)(lcmRates / Rates[i]));\n\t\t}\n\t}\n\treturn 0;\n}", "sampled": "#include <stdio.h>\n\nlong long gcd(long long a, long long b) {\n    while (b != 0) {\n        long long temp = b;\n        b = a % b;\n        a = temp;\n    }\n    return a;\n}\n\nlong long lcm(long long a, long long b) {\n    return (a / gcd(a, b)) * b;\n}\n\nint main() {\n    int n;\n    while (scanf(\"%d\", &n) == 1 && n != 0) {\n        long long times[10];\n        long long d, v;\n        \n        for (int i = 0; i < n; i++) {\n            scanf(\"%lld %lld\", &d, &v);\n            long long g = gcd(d, v);\n            d /= g;\n            v /= g;\n            times[i] = d;\n        }\n        \n        long long lcm_time = times[0];\n        for (int i = 1; i < n; i++) {\n            lcm_time = lcm(lcm_time, times[i]);\n        }\n        \n        for (int i = 0; i < n; i++) {\n            printf(\"%lld\\n\", lcm_time / times[i]);\n        }\n    }\n    \n    return 0;\n}\n", "perturbed_sampled": [" != 0) { long  return a; } long  long b) { return (a /  n; while (scanf(\"%d\", &n) == 1 && n != 0) { long long times[10]; long long d, v;  i < n; i++) { scanf(\"%lld %lld\", &d,  gcd(d, v); d /= g;  d;  = 1;  lcm_time  times[i]); } } return 0; }"], "perturbed_original": ["#include<stdio.h> #define <extra_id_10>( n > 3 )<extra_id_11>; switch (<extra_id_12>; case<extra_id_13>3<extra_id_14>case 32 :<extra_id_15>case<extra_id_16>(<extra_id_17>; case 48<extra_id_18>}<extra_id_19>1 )<extra_id_20>(<extra_id_21>return<extra_id_22>n<extra_id_23>n < 3 ;<extra_id_24>, 1 )<extra_id_25>int return - 1 ;  a, INT   GCD(b,a%b);  i,n; INT d[N]; INT v[N]; INT Rates[N]; INT lcmV =  INT lcmRates  n; ++i){ int td, tv; int gcd; scanf(\"%d%d\",&td,&tv); gcd = GCD(td,tv); d[i] = (INT)td/gcd; v[i] =  v[0], v[1]  < n; ++i){ lcmV   < n; ++i){ Rates[i] = (lcmV / v[i])*d[i];  Rates[1] ); for(i = 2; i  } for(i = 0; i < n;  lcmRates =  i <  return 0; }"], "original_ll": -0.8198227286338806, "sampled_ll": -0.49272772669792175, "all_perturbed_sampled_ll": [-3.0168092250823975], "all_perturbed_original_ll": [-2.58082914352417], "perturbed_sampled_ll": -3.0168092250823975, "perturbed_original_ll": -2.58082914352417, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import java.io.*;\nimport java.util.Scanner;\nimport java.math.BigInteger;\n\npublic class Main\n{\t\n\tpublic static void main(String[] args)\n\t{\n\t\tScanner cin = new Scanner(System.in);\n\t\t\n\t\tint n;\n\t\twhile(true)\n\t\t{\n\t\t\tn = cin.nextInt();\n\t\t\tif(n==0) break;\n\t\n\t\t\tBigInteger   p = new BigInteger(\"1\"); \n\t\t\tBigInteger[] s = new BigInteger[10];\n\t\t\tBigInteger[] t = new BigInteger[10];\n\n\t\t\tfor(int i=0; i<n; i++)\n\t\t\t{\n\t\t\t\ts[i] = new BigInteger(cin.next());\n\t\t\t\tt[i] = new BigInteger(cin.next());\n\t\t\t\t\n\t\t\t\tp = t[i].multiply( p.divide( p.gcd(t[i]) ));\n\t\t\t}\n\n\t\t\tfor(int i=0; i<n; i++)\n\t\t\t{\n\t\t\t\ts[i] = s[i].multiply( p.divide(t[i]) );\n\t\t\t}\n\t\t\t\n\t\t\tp = new BigInteger(\"1\");\n\t\t\tfor(int i=0; i<n; i++)\n\t\t\t{\n\t\t\t\tp = s[i].multiply( p.divide( p.gcd(s[i]) ));\n\t\t\t}\t\t\t\n\t\t\t\n\t\t\tfor(int i=0; i<n; i++)\n\t\t\t{\n\t\t\t\tSystem.out.println(p.divide(s[i]));\n\t\t\t}\n\t\t}\n\t}\n}", "sampled": "import java.util.*;\nimport java.io.*;\n\npublic class Main {\n    public static void main(String[] args) throws IOException {\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        String line;\n        \n        while ((line = br.readLine()) != null) {\n            int n = Integer.parseInt(line.trim());\n            if (n == 0) break;\n            \n            long[] d = new long[n];\n            long[] v = new long[n];\n            \n            for (int i = 0; i < n; i++) {\n                String[] parts = br.readLine().trim().split(\"\\\\s+\");\n                d[i] = Long.parseLong(parts[0]);\n                v[i] = Long.parseLong(parts[1]);\n            }\n            \n            // Calculate time for each student to complete one lap\n            // time = distance / speed = d / v\n            // We need to find LCM of all times\n            // time_i = d_i / v_i\n            // To avoid floating point, we work with fractions\n            \n            // Reduce each fraction d_i / v_i\n            long[] numerators = new long[n];\n            long[] denominators = new long[n];\n            \n            for (int i = 0; i < n; i++) {\n                long g = gcd(d[i], v[i]);\n                numerators[i] = d[i] / g;\n                denominators[i] = v[i] / g;\n            }\n            \n            // Find LCM of fractions: LCM(a/b, c/d) = LCM(a,c) / GCD(b,d)\n            long lcmNum = numerators[0];\n            long lcmDen = denominators[0];\n            \n            for (int i = 1; i < n; i++) {\n                lcmNum = lcm(lcmNum, numerators[i]);\n                lcmDen = gcd(lcmDen, denominators[i]);\n            }\n            \n            // The total time when all meet is lcmNum / lcmDen\n            // Number of laps for student i = (lcmNum / lcmDen) / (numerators[i] / denominators[i])\n            //                               = (lcmNum / lcmDen) * (denominators[i] / numerators[i])\n            //                               = (lcmNum * denominators[i]) / (lcmDen * numerators[i])\n            \n            for (int i = 0; i < n; i++) {\n                long laps = (lcmNum * denominators[i]) / (lcmDen * numerators[i]);\n                System.out.println(laps);\n            }\n        }\n    }\n    \n    static long gcd(long a, long b) {\n        while (b != 0) {\n            long temp = b;\n            b = a % b;\n            a = temp;\n        }\n        return a;\n    }\n    \n    static long lcm(long a, long b) {\n        return a / gcd(a, b) * b;\n    }\n}\n", "perturbed_sampled": ["import java.util.*; import java.io.*;  static void main(String[]  br = new BufferedReader(new InputStreamReader(System.in));  int  = 0; i < n; i++)  d[i] = Long.parseLong(parts[0]); v[i] =   = distance / speed = d / v // We need  times // time_i = d_i / v_i  //  = new long[n]; for (int i = 0; i < n; i++) {   c/d) = LCM(a,c) /  for (int i  i++) { lcmNum = lcm(lcmNum,   when all meet is lcmNum / lcmDen   lcmDen) /  (lcmNum / lcmDen) * (denominators[i] / numerators[i]) // = (lcmNum * denominators[i])  (int i = 0; i <  = (lcmNum *    0) { long temp =  static  { return  b; } }"], "perturbed_original": ["import java.io.*; import java.util.Scanner; import java.math.BigInteger; public class Main { public static  cin =  { n  BigInteger[10]; BigInteger[]  i=0;  new BigInteger(cin.next()); p = t[i].multiply( p.divide( p.gcd(t[i])  i++) {  BigInteger(\"1\"); for(int i=0;  s[i].multiply( p.divide( p.gcd(s[i])   } }"], "original_ll": -0.8160963654518127, "sampled_ll": -0.7031213641166687, "all_perturbed_sampled_ll": [-3.0871284008026123], "all_perturbed_original_ll": [-2.998117685317993], "perturbed_sampled_ll": -3.0871284008026123, "perturbed_original_ll": -2.998117685317993, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "\"\"\" Created by Jieyi on 10/4/16. \"\"\"\nimport io\nimport sys\n\nif len(sys.argv) > 1:\n    filename = sys.argv[1]\n    inp = ''.join(open(filename, \"r\").readlines())\n    sys.stdin = io.StringIO(inp)\n\n\ndef gcd(x, y):\n    while y:\n        x, y = y, x % y\n\n    return x\n\n\ndef lcm(x, y):\n    l_lcm = (x * y) // gcd(x, y)\n    return l_lcm\n\n\ndef mul_lcm(array):\n    l = lcm(array[0], array[1])\n    if len(array) > 3:\n        for i in range(2, len(array)):\n            l = lcm(array[i], l)\n    return l\n\n\ndef algorithm(students):\n    denominator_lcm = mul_lcm([y for _, y in students])\n    for i in range(len(students)):\n        students[i][0] *= int(denominator_lcm / students[i][1])\n    molecular_lcm = mul_lcm([x for x, _ in students])\n\n    return [int(molecular_lcm / students[i][0]) for i in range(len(students))]\n\n\ndef input_sample():\n    while True:\n        n = int(input())\n        if n == 0:\n            break\n\n        students = []\n        for _ in range(n):\n            students.append(list(map(int, input().split())))\n        answer_list = algorithm(students)\n        for ans in answer_list:\n            print(ans)\n\n\ndef main():\n    input_sample()\n\n\nif __name__ == '__main__':\n    main()", "sampled": "from math import gcd\nfrom fractions import Fraction\n\ndef lcm(a, b):\n    return a * b // gcd(a, b)\n\ndef lcm_multiple(numbers):\n    result = numbers[0]\n    for num in numbers[1:]:\n        result = lcm(result, num)\n    return result\n\nwhile True:\n    n = int(input())\n    if n == 0:\n        break\n    \n    students = []\n    for _ in range(n):\n        d, v = map(int, input().split())\n        students.append((d, v))\n    \n    # Calculate time for one lap for each student as a fraction\n    times = []\n    for d, v in students:\n        times.append(Fraction(d, v))\n    \n    # Find LCM of all times\n    # LCM of fractions a/b and c/d is LCM(a,c)/GCD(b,d)\n    numerators = [t.numerator for t in times]\n    denominators = [t.denominator for t in times]\n    \n    lcm_num = lcm_multiple(numerators)\n    gcd_den = denominators[0]\n    for den in denominators[1:]:\n        gcd_den = gcd(gcd_den, den)\n    \n    meeting_time = Fraction(lcm_num, gcd_den)\n    \n    # Calculate laps for each student\n    for time in times:\n        laps = meeting_time / time\n        print(int(laps))\n", "perturbed_sampled": ["from math import gcd from fractions import Fraction def  num) return   for _   Calculate time for  as a fraction  of all  a/b and c/d is LCM(a,c)/GCD(b,d) numerators = [t.numerator for t in times] denominators = [t.denominator  = lcm_multiple(numerators) gcd_den = denominators[0] for den  den) meeting_time = Fraction(lcm_num, gcd_den) #  for time  / time print(int(laps))"], "perturbed_original": ["\"\"\"  1: filename = sys.argv[1] inp = ''.join(open(filename, \"r\").readlines()) sys.stdin =  y: x, y = y, x  lcm(x, y): l_lcm  in   _, y  range(len(students)): students[i][0] *=   range(len(students))] def input_sample(): while True: n  0: break students = [] for _ in range(n): students.append(list(map(int, input().split()))) answer_list = algorithm(students) for ans  input_sample() if __name__ == '__main__': main()"], "original_ll": -1.0426514148712158, "sampled_ll": -0.9305617809295654, "all_perturbed_sampled_ll": [-3.8346681594848633], "all_perturbed_original_ll": [-3.0610342025756836], "perturbed_sampled_ll": -3.8346681594848633, "perturbed_original_ll": -3.0610342025756836, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "#include <stdio.h>\n\n#define INF 100000000\n\nstruct NODE {\n    int distance;\n    int state;\n} vertex[11][101];\n\nint W[101][101];\nint c, V, n, s, d;\n\nint min(int a, int b) {\n    return (a > b ? b : a);\n}\n\nvoid dijkstra(int start) {\n    int i, x, p, step;\n    for (i = 0; i <= c; i++) {\n\tfor (x = 1; x <= n; x++) {\n\t    vertex[i][x].distance = INF; vertex[i][x].state = 0;\n\t}\n\tvertex[i][start].distance = 0; \n    }\n    for (i = 0; i <= c; i++) {\n\tfor (step = 1; step <= n; step++) {\n\t    int minimum = INF;\n\t    for (x = 1; x <= n; x++)\n\t\tif (vertex[i][x].state == 0 && vertex[i][x].distance < minimum) {\n\t\t    p = x; minimum = vertex[i][x].distance;\n\t\t}\n\t    vertex[i][p].state = 1;\n\t    for (x = 1 ; x <= n; x++)\n\t\tif (vertex[i][x].state == 0) {\n\t\t    if (i == 0)\n\t\t\tvertex[i][x].distance = min(vertex[i][x].distance, \n\t\t\t\t\t\t    vertex[i][p].distance+W[p][x]);\n\t\t    else\n\t\t\tvertex[i][x].distance = min(vertex[i][x].distance, \n\t\t\t\t\t\t    min(vertex[i][p].distance+W[p][x],\n\t\t\t\t\t\t\tvertex[i-1][p].distance+W[p][x]/2));\n\t\t}\n\t}\n    }\n}\n\nint main(void) {\n    int i, j;\n    int from, to, m;\n     \n    while (1) {\n\tscanf(\"%d%d%d%d%d\", &c, &V, &n, &s, &d);\n        if (c + V + n + s + d == 0) break;\n         \n        for (i = 0; i <= V; i++)\n            for (j = 0; j <= V; j++)\n                W[i][j] = INF;\n         \n\tfor (i = 0; i < n; i++) {\n            scanf(\"%d%d%d\", &from, &to, &m);\n            W[from][to] = m;\n\t    W[to][from] = m;\n        }\n         \n        dijkstra(s);\n\tprintf(\"%d\\n\", vertex[c][d].distance);\n    }\n    return 0;\n}", "sampled": "#include <stdio.h>\n#include <string.h>\n#include <limits.h>\n\n#define MAX_N 101\n#define MAX_M 501\n#define INF INT_MAX\n\ntypedef struct {\n    int to;\n    int cost;\n} Edge;\n\nEdge edges[MAX_M * 2];\nint head[MAX_N];\nint next_edge[MAX_M * 2];\nint edge_count;\n\nvoid add_edge(int from, int to, int cost) {\n    edges[edge_count].to = to;\n    edges[edge_count].cost = cost;\n    next_edge[edge_count] = head[from];\n    head[from] = edge_count;\n    edge_count++;\n}\n\ntypedef struct {\n    int node;\n    int tickets_used;\n    int cost;\n} State;\n\nState queue[MAX_N * 12];\nint queue_start, queue_end;\n\nvoid enqueue(int node, int tickets, int cost) {\n    queue[queue_end].node = node;\n    queue[queue_end].tickets_used = tickets;\n    queue[queue_end].cost = cost;\n    queue_end++;\n}\n\nState dequeue() {\n    return queue[queue_start++];\n}\n\nint min_cost[MAX_N][12];\n\nint dijkstra(int n, int s, int d, int c) {\n    for (int i = 0; i <= n; i++) {\n        for (int j = 0; j <= c; j++) {\n            min_cost[i][j] = INF;\n        }\n    }\n    \n    queue_start = 0;\n    queue_end = 0;\n    enqueue(s, 0, 0);\n    min_cost[s][0] = 0;\n    \n    while (queue_start < queue_end) {\n        State current = dequeue();\n        int u = current.node;\n        int tickets = current.tickets_used;\n        int curr_cost = current.cost;\n        \n        if (curr_cost > min_cost[u][tickets]) {\n            continue;\n        }\n        \n        for (int e = head[u]; e != -1; e = next_edge[e]) {\n            int v = edges[e].to;\n            int edge_cost = edges[e].cost;\n            \n            // Without using discount\n            int new_cost = curr_cost + edge_cost;\n            if (new_cost < min_cost[v][tickets]) {\n                min_cost[v][tickets] = new_cost;\n                enqueue(v, tickets, new_cost);\n            }\n            \n            // With discount\n            if (tickets < c) {\n                int discounted_cost = curr_cost + edge_cost / 2;\n                if (discounted_cost < min_cost[v][tickets + 1]) {\n                    min_cost[v][tickets + 1] = discounted_cost;\n                    enqueue(v, tickets + 1, discounted_cost);\n                }\n            }\n        }\n    }\n    \n    int result = INF;\n    for (int i = 0; i <= c; i++) {\n        if (min_cost[d][i] < result) {\n            result = min_cost[d][i];\n        }\n    }\n    return result;\n}\n\nint main() {\n    int c, n, m, s, d;\n    \n    while (1) {\n        scanf(\"%d %d %d %d %d\", &c, &n, &m, &s, &d);\n        if (c == 0 && n == 0 && m == 0 && s == 0 && d == 0) {\n            break;\n        }\n        \n        edge_count = 0;\n        for (int i = 0; i <= n; i++) {\n            head[i] = -1;\n        }\n        \n        for (int i = 0; i < m; i++) {\n            int a, b, f;\n            scanf(\"%d %d %d\", &a, &b, &f);\n            add_edge(a, b, f);\n            add_edge(b, a, f);\n        }\n        \n        int result = dijkstra(n, s, d, c);\n        printf(\"%d\\n\", result);\n    }\n    \n    return 0;\n}\n", "perturbed_sampled": ["#include <stdio.h> #include <string.h> #include  MAX_M  int cost; } Edge; Edge edges[MAX_M * 2];  add_edge(int from, int  = to;  head[from];  cost; } State; State queue[MAX_N *   cost)  = tickets; queue[queue_end].cost  dijkstra(int n,  c) { for (int i = 0; i <= n; i++) { for (int j = 0; j <= c; j++) {  = 0;  queue_end) { State current = dequeue();  tickets = current.tickets_used; int curr_cost = current.cost; if (curr_cost > min_cost[u][tickets]) { continue; } for  != -1; e = next_edge[e])  int edge_cost  discount int new_cost  edge_cost / 2; if   discounted_cost; enqueue(v, tickets +  INF; for (int i    %d %d\",  if (c ==  && s == 0 && d == 0) { break; } edge_count = 0; for (int i = 0; i <= n;  } for  < m; i++)  scanf(\"%d %d  b,  s,  return 0; }"], "perturbed_original": ["#include <stdio.h>  n, s,   start) { int i,  = 0; i  (x = 1; x <= n; x++) { vertex[i][x].distance = INF;  = 0; } for (i =  { for (step = 1; step <=  = 1; x <= n; x++) if  < minimum)  = vertex[i][x].distance; } vertex[i][p].state = 1; for (x = 1 ; x <=   vertex[i][p].distance+W[p][x]); else  int main(void)  if  + s + d  =   <= V; j++) W[i][j] = INF;   &from,  W[to][from] = m; } dijkstra(s); printf(\"%d\\n\", vertex[c][d].distance); } return 0; }"], "original_ll": -0.7991953492164612, "sampled_ll": -0.4713601768016815, "all_perturbed_sampled_ll": [-2.953927755355835], "all_perturbed_original_ll": [-2.9300575256347656], "perturbed_sampled_ll": -2.953927755355835, "perturbed_original_ll": -2.9300575256347656, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import java.util.Arrays;\nimport java.util.Scanner;\npublic class Main\n{\n\tpublic static void main(String arg[])\n\t{\n\t\tScanner in=new Scanner(System.in);\n\t\tint M=1000001;\n\t\tfor(;;)\n\t\t{\n\t\t\tint c=in.nextInt();//\u30c1\u30b1\u30c3\u30c8\u306e\u6570\n\t\t\tint n=in.nextInt(),m=in.nextInt();//\u30d0\u30b9\u505c\u306e\u6570,\u9053\u306e\u6570\n\t\t\tint s=in.nextInt(),d=in.nextInt();//\u30b9\u30bf\u30fc\u30c8&\u30b4\u30fc\u30eb\n\t\t\tif((c|n|m|s|d)==0)\n\t\t\t\treturn;\n\t\t\tint cost[][]=new int[n+1][n+1];\n\t\t\tfor(int i=0;i<=n;i++)\n\t\t\t\tArrays.fill(cost[i], M);\n\t\t\tfor(int q[]: cost) {\n\t\t\t\tArrays.fill(q, M);\n\t\t\t}\n\t\t\tfor(int i=0;i<=n;i++)\n\t\t\t\tcost[i][i]=0;\n\t\t\tfor(int i=0;i<m;i++)\n\t\t\t{\n\t\t\t\tint a=in.nextInt();\n\t\t\t\tint b=in.nextInt();\n\t\t\t\tint f=in.nextInt();\n\t\t\t\tcost[a][b]=f;\n\t\t\t\tcost[b][a]=f;\n\t\t\t}\n\t\t\tint p=0,w=0;\n\t\t\tint v[][] = new int[n+1][c+1];// decision flag\n\t\t\tint leng[][]=new int[n+1][c+1];// minimum distance\n\t\t\tfor(int i=0;i<=n;i++)\n\t\t\t\tfor(int k=0;k<=c;k++)\n\t\t\t\t{\n\t\t\t\t\tleng[i][k]=M;\n\t\t\t\t\tv[i][k]=0;\n\t\t\t\t}\n\t\t\tleng[s][c]=0;\n\t\t\tfor(;;)\n\t\t\t{\n\t\t\t\tint min=M;//\u6700\u5c0f\u306e\u7bc0\u70b9\u3092\u63a2\u3059\n\t\t\t\tfor(int l=1;l<=n;l++)\n\t\t\t\t\tfor(int k=1;k<=c;k++)\n\t\t\t\t\t{\n\t\t\t\t\t\tif(v[l][k]==0&&leng[l][k]<min)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tp=l;\n\t\t\t\t\t\t\tw=k;\n\t\t\t\t\t\t\tmin=leng[l][k];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\tif(min==M)\n\t\t\t\t\tbreak;\n\t\t\t\tv[p][w]=1;//\u78ba\u5b9a\u30d5\u30e9\u30b0\n\t\t\t\tfor(int l=1;l<=n;l++) //p\u3092\u7d4c\u7531\u3057\u3066l\u306b\u81f3\u308b\u9577\u3055\u304c\u305d\u308c\u307e\u3067\u306e\u6700\u77ed\u7d4c\u8def\u3088\u308a\u5c0f\u3055\u3051\u308c\u3070\u66f4\u65b0\n\t\t\t\t{\n\t\t\t\t\tleng[l][w]=Math.min(leng[l][w], leng[p][w]+cost[p][l]);\n\t\t\t\t\tif (w>0)\n\t\t\t\t\t\tleng[l][w-1]=Math.min(leng[l][w-1], leng[p][w]+cost[p][l]/2);\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(leng[d][0]);\n\t\t}\n\t}\n}", "sampled": "import java.util.*;\n\npublic class Main {\n    static class Edge {\n        int to, cost;\n        Edge(int to, int cost) {\n            this.to = to;\n            this.cost = cost;\n        }\n    }\n    \n    static class State implements Comparable<State> {\n        int node, couponsUsed, cost;\n        \n        State(int node, int couponsUsed, int cost) {\n            this.node = node;\n            this.couponsUsed = couponsUsed;\n            this.cost = cost;\n        }\n        \n        @Override\n        public int compareTo(State other) {\n            return Integer.compare(this.cost, other.cost);\n        }\n    }\n    \n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        \n        while (true) {\n            int c = sc.nextInt();\n            int n = sc.nextInt();\n            int m = sc.nextInt();\n            int s = sc.nextInt();\n            int d = sc.nextInt();\n            \n            if (c == 0 && n == 0 && m == 0 && s == 0 && d == 0) {\n                break;\n            }\n            \n            List<List<Edge>> graph = new ArrayList<>();\n            for (int i = 0; i <= n; i++) {\n                graph.add(new ArrayList<>());\n            }\n            \n            for (int i = 0; i < m; i++) {\n                int a = sc.nextInt();\n                int b = sc.nextInt();\n                int f = sc.nextInt();\n                graph.get(a).add(new Edge(b, f));\n                graph.get(b).add(new Edge(a, f));\n            }\n            \n            int result = dijkstra(graph, n, c, s, d);\n            System.out.println(result);\n        }\n        \n        sc.close();\n    }\n    \n    static int dijkstra(List<List<Edge>> graph, int n, int c, int s, int d) {\n        int[][] dist = new int[n + 1][c + 1];\n        for (int i = 0; i <= n; i++) {\n            Arrays.fill(dist[i], Integer.MAX_VALUE);\n        }\n        \n        PriorityQueue<State> pq = new PriorityQueue<>();\n        pq.offer(new State(s, 0, 0));\n        dist[s][0] = 0;\n        \n        while (!pq.isEmpty()) {\n            State current = pq.poll();\n            \n            if (current.node == d) {\n                return current.cost;\n            }\n            \n            if (current.cost > dist[current.node][current.couponsUsed]) {\n                continue;\n            }\n            \n            for (Edge edge : graph.get(current.node)) {\n                // Without using coupon\n                int newCost = current.cost + edge.cost;\n                if (newCost < dist[edge.to][current.couponsUsed]) {\n                    dist[edge.to][current.couponsUsed] = newCost;\n                    pq.offer(new State(edge.to, current.couponsUsed, newCost));\n                }\n                \n                // With using coupon\n                if (current.couponsUsed < c) {\n                    int discountedCost = current.cost + edge.cost / 2;\n                    if (discountedCost < dist[edge.to][current.couponsUsed + 1]) {\n                        dist[edge.to][current.couponsUsed + 1] = discountedCost;\n                        pq.offer(new State(edge.to, current.couponsUsed + 1, discountedCost));\n                    }\n                }\n            }\n        }\n        \n        int minCost = Integer.MAX_VALUE;\n        for (int i = 0; i <= c; i++) {\n            minCost = Math.min(minCost, dist[d][i]);\n        }\n        \n        return minCost;\n    }\n}\n", "perturbed_sampled": ["import java.util.*; public class Main  int  cost)  = cost;  implements Comparable<State> { int node, couponsUsed, cost;   } } public static void  = new Scanner(System.in); while  sc.nextInt(); int n = sc.nextInt(); int m =  if (c == 0 && n ==  && s == 0 && d == 0) { break;   0;    b = sc.nextInt(); int  f)); graph.get(b).add(new Edge(a, f)); }  } sc.close();  int n, int c, int s, int d) { int[][] dist  + 1]; for (int i  } PriorityQueue<State> pq = new     edge : graph.get(current.node))  int newCost = current.cost + edge.cost; if (newCost < dist[edge.to][current.couponsUsed]) { dist[edge.to][current.couponsUsed] = newCost; pq.offer(new State(edge.to,  discountedCost = current.cost + edge.cost / 2; if (discountedCost < dist[edge.to][current.couponsUsed + 1]) { dist[edge.to][current.couponsUsed + 1] = discountedCost; pq.offer(new State(edge.to,  } }"], "perturbed_original": ["import {<extra_id_4>e=(int)i*)n+' '<extra_id_5>w+cost[w]+(c/100.)++; } }<extra_id_6>i=0;i<n;i++) //<extra_id_7>i<extra_id_8>//end-of-data if<extra_id_9>; return; Main { public  Scanner in=new Scanner(System.in); int M=1000001; for(;;) { int c=in.nextInt();//\u30c1\u30b1\u30c3\u30c8\u306e\u6570  return; int cost[][]=new int[n+1][n+1]; for(int i=0;i<=n;i++) Arrays.fill(cost[i], M); for(int q[]:  for(int i=0;i<=n;i++) cost[i][i]=0; for(int i=0;i<m;i++)  decision flag int   if(v[l][k]==0&&leng[l][k]<min) { p=l; w=k; min=leng[l][k]; } } if(min==M)  {  leng[p][w]+cost[p][l]/2);  }"], "original_ll": -1.0878812074661255, "sampled_ll": -0.34633150696754456, "all_perturbed_sampled_ll": [-2.2760822772979736], "all_perturbed_original_ll": [-2.979008436203003], "perturbed_sampled_ll": -2.2760822772979736, "perturbed_original_ll": -2.979008436203003, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "from sys import stdin\nreadline = stdin.readline\n\n\n\nfrom collections import namedtuple\nRunner = namedtuple('Runner', 'd v')\n\ndef main():\n    while True:\n        ticket, vertex, edge, start, destination = map(int, readline().split())\n        if ticket == 0:\n            break\n\n        start -= 1\n        destination -= 1\n        g = defaultdict(list)\n        for i in range(edge):\n            s, t, length = map(int, readline().split())\n            s -= 1\n            t -= 1\n            g[s].append((length, t))\n            g[t].append((length, s))\n        \n        d = ex_dijkstra(g, vertex, start, ticket)\n        print(min(d[destination]))\n\n\n\nfrom heapq import heappush, heappop\nfrom collections import defaultdict\ndef ex_dijkstra(g, size, start, ticket):\n    d = [[float('inf')] * (ticket + 1) for i in range(size)]\n    d[start][ticket] = 0\n    heap = [(d[start][ticket], start, ticket)]\n    while heap:\n        du, u, ticket = heappop(heap)\n        for length, v in g[u]:\n            if d[v][ticket] > du + length:\n                d[v][ticket] = du + length\n                heappush(heap,(d[v][ticket], v, ticket))\n            if ticket and d[v][ticket - 1] > du + length // 2:\n                d[v][ticket - 1] = du + length // 2\n                heappush(heap,(d[v][ticket - 1], v, ticket - 1))\n\n    return d\n\nmain()", "sampled": "import heapq\nfrom sys import stdin\n\ndef solve(c, n, m, s, d, edges):\n    # Build adjacency list\n    graph = [[] for _ in range(n + 1)]\n    for a, b, f in edges:\n        graph[a].append((b, f))\n        graph[b].append((a, f))\n    \n    # Dijkstra with state (cost, node, discounts_used)\n    # We need to track how many discounts we've used\n    dist = {}  # (node, discounts_used) -> min_cost\n    pq = [(0, s, 0)]  # (cost, node, discounts_used)\n    dist[(s, 0)] = 0\n    \n    while pq:\n        cost, node, discounts_used = heapq.heappop(pq)\n        \n        if node == d:\n            continue\n        \n        if (node, discounts_used) in dist and dist[(node, discounts_used)] < cost:\n            continue\n        \n        for next_node, fare in graph[node]:\n            # Option 1: Don't use discount\n            new_cost = cost + fare\n            if (next_node, discounts_used) not in dist or dist[(next_node, discounts_used)] > new_cost:\n                dist[(next_node, discounts_used)] = new_cost\n                heapq.heappush(pq, (new_cost, next_node, discounts_used))\n            \n            # Option 2: Use discount if available\n            if discounts_used < c:\n                new_cost = cost + fare // 2\n                if (next_node, discounts_used + 1) not in dist or dist[(next_node, discounts_used + 1)] > new_cost:\n                    dist[(next_node, discounts_used + 1)] = new_cost\n                    heapq.heappush(pq, (new_cost, next_node, discounts_used + 1))\n    \n    # Find minimum cost to reach destination with any number of discounts used\n    min_cost = float('inf')\n    for i in range(c + 1):\n        if (d, i) in dist:\n            min_cost = min(min_cost, dist[(d, i)])\n    \n    return min_cost\n\n# Read input\nlines = []\nfor line in stdin:\n    lines.append(line.strip())\n\ni = 0\nwhile i < len(lines):\n    parts = lines[i].split()\n    c, n, m, s, d = map(int, parts)\n    if c == 0 and n == 0 and m == 0 and s == 0 and d == 0:\n        break\n    \n    edges = []\n    for j in range(m):\n        i += 1\n        a, b, f = map(int, lines[i].split())\n        edges.append((a, b, f))\n    \n    result = solve(c, n, m, s, d, edges)\n    print(result)\n    \n    i += 1\n", "perturbed_sampled": ["import  def  for _ in range(n + 1)] for a, b, f in edges:  node, discounts_used) # We  discounts we've used  discounts_used) -> min_cost pq = [(0, s, 0)]  0)] = 0 while pq: cost,  if (node, discounts_used) in dist and dist[(node, discounts_used)] < cost:  graph[node]: #  new_cost = cost + fare if (next_node,  dist[(next_node, discounts_used)]  discounts_used)) # Option 2: Use  cost + fare  dist or  new_cost: dist[(next_node, discounts_used + 1)]  reach  float('inf') for i in   min(min_cost, dist[(d, i)]) return  = 0 while i <  n, m,  if c ==  and m  [] for j in  b,  b, f)) result = solve(c, n, m, s,  1"], "perturbed_original": [" namedtuple('Runner', 'd v') def main(): while True: ticket, vertex, edge, start, destination =  0: break start -=  = defaultdict(list) for  length = map(int, readline().split()) s  g[s].append((length, t)) g[t].append((length, s)) d = ex_dijkstra(g, vertex, start, ticket) print(min(d[destination])) from heapq   heap = [(d[start][ticket],  u, ticket = heappop(heap) for length, v  du + length:  1] >  du + length  return d main()"], "original_ll": -0.8965162038803101, "sampled_ll": -0.6120855808258057, "all_perturbed_sampled_ll": [-3.295992374420166], "all_perturbed_original_ll": [-3.8593876361846924], "perturbed_sampled_ll": -3.295992374420166, "perturbed_original_ll": -3.8593876361846924, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "// Aizu 0213: Subdivide The Land\n// 2017.9.24 bal4u@uu\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\ntypedef struct { int id, x, y, k; } T;\nT tbl[16]; \nint X, Y, n;\nchar map[10][10];\nchar ans[10][10], cnt;\nint pair[101][13][2], plen[101];\n\nint cmp(T *a, T *b) { if (a->y - b->y) return a->y - b->y; return a->x - b->x; }\n\nvoid mark(int c, int x, int y, int w, int h)\n{\n\tint yy;\n\tfor (yy = 0; yy < h; yy++) memset(map[y+yy]+x, c, w);\n}\n\nint check(int c, int x, int y, int w, int h)\n{\n\tint xx, yy;\n\tfor (yy = 0; yy < h; yy++) for (xx = 0; xx < w; xx++) \n\t\tif (map[y+yy][x+xx] > 0 && map[y+yy][x+xx] != c) return 0;\n\treturn 1;\n}\n\nint combi(int i)\n{\n\tint x, y, x0, y0, id, x1, y1, h, w, j, k;\n\n\tif (i == n+1) {\n\t\tif (cnt) return 0;\n\t\tcnt = 1, memcpy(ans, map, sizeof(map));\n\t\treturn 1;\n\t}\n\tk = tbl[i].k;\n\tif (k == 1) return combi(i+1);\n\tx0 = tbl[i].x, y0 = tbl[i].y, id = tbl[i].id;\n\n\tfor (j = 0; j < plen[k]; j++) {\n\t\tw = pair[k][j][0], h = pair[k][j][1];\n\t\tx1 = x0 - w + 1, y1 = y0 - h + 1;\n\t\tif (x1 < 0) x1 = 0; if (y1 < 0) y1 = 0;\n\t\tfor (y = y1; y <= y0; y++) for (x = x1; x <= x0; x++) {\n\t\t\tif (x + w > X || y + h > Y) goto Next;\n\t\t\tif (!check(id, x, y, w, h)) continue;\n\t\t\tmark(id, x, y, w, h);\n\t\t\tif (!combi(i+1)) return 0;\n\t\t\tmark(0, x, y, w, h);\n\t\t}\nNext:;\n\t}\n\treturn 1;\n}\n\nint main()\n{\n    int i, b, t, s, x, y;\n\n\tfor (x = 1; x <= 100; x++) for (y = 1; y <= 100; y++)\n\t\tif ((t = x * y) <= 100) pair[t][plen[t]][0] = x, pair[t][plen[t]++][1] = y;\n\n\twhile (scanf(\"%d%d%d\", &X, &Y, &n) && n > 0) {\n\t\tfor (s = i = 0; i < n; i++) {\n\t\t\tscanf(\"%d%d\", &b, &t);\n\t\t\ttbl[b].k = t, tbl[b].id = b;\n\t\t\ts += t;\n\t\t}\n\t\tfor (y = 0; y < Y; y++) for (x = 0; x < X; x++) {\n\t\t\tscanf(\"%d\", &b), map[y][x] = b;\n\t\t\tif (b > 0) tbl[b].x = x, tbl[b].y = y;\n\t\t}\n\t\tif (s != X*Y) { puts(\"NA\"); continue; }\n\t\tqsort(tbl+1, n, sizeof(T), cmp);\n\n\t\tcnt = 0;\n\t\tif (!combi(1)) puts(\"NA\");\n\t\telse for (y = 0; y < Y; y++) {\n\t\t\tprintf(\"%d\", ans[y][0]);\n\t\t\tfor (x = 1; x < X; x++) printf(\" %d\", ans[y][x]);\n\t\t\tprintf(\"\\n\");\n\t\t}\n\t}\n\treturn 0;\n}", "sampled": "#include <stdio.h>\n#include <string.h>\n\nint X, Y, n;\nint b[16], k[16];\nint s[11][11];\nint grid[11][11];\nint solutions;\n\nint isValidRectangle(int buyer, int x1, int y1, int x2, int y2) {\n    int count = 0;\n    int hasSign = 0;\n    \n    for (int i = x1; i <= x2; i++) {\n        for (int j = y1; j <= y2; j++) {\n            if (grid[i][j] != 0) return 0;\n            count++;\n            if (s[i][j] == buyer) hasSign = 1;\n        }\n    }\n    \n    if (count != k[buyer] || !hasSign) return 0;\n    return 1;\n}\n\nvoid fillRectangle(int x1, int y1, int x2, int y2, int buyer) {\n    for (int i = x1; i <= x2; i++) {\n        for (int j = y1; j <= y2; j++) {\n            grid[i][j] = buyer;\n        }\n    }\n}\n\nvoid clearRectangle(int x1, int y1, int x2, int y2) {\n    for (int i = x1; i <= x2; i++) {\n        for (int j = y1; j <= y2; j++) {\n            grid[i][j] = 0;\n        }\n    }\n}\n\nvoid solve(int buyer) {\n    if (solutions > 1) return;\n    \n    if (buyer > n) {\n        solutions++;\n        return;\n    }\n    \n    for (int x1 = 1; x1 <= X; x1++) {\n        for (int y1 = 1; y1 <= Y; y1++) {\n            for (int x2 = x1; x2 <= X; x2++) {\n                for (int y2 = y1; y2 <= Y; y2++) {\n                    if (isValidRectangle(buyer, x1, y1, x2, y2)) {\n                        fillRectangle(x1, y1, x2, y2, buyer);\n                        solve(buyer + 1);\n                        if (solutions > 1) {\n                            clearRectangle(x1, y1, x2, y2);\n                            return;\n                        }\n                        clearRectangle(x1, y1, x2, y2);\n                    }\n                }\n            }\n        }\n    }\n}\n\nint main() {\n    while (1) {\n        scanf(\"%d %d %d\", &X, &Y, &n);\n        if (X == 0 && Y == 0 && n == 0) break;\n        \n        for (int i = 1; i <= n; i++) {\n            scanf(\"%d %d\", &b[i], &k[i]);\n        }\n        \n        for (int j = 1; j <= Y; j++) {\n            for (int i = 1; i <= X; i++) {\n                scanf(\"%d\", &s[i][j]);\n            }\n        }\n        \n        memset(grid, 0, sizeof(grid));\n        solutions = 0;\n        solve(1);\n        \n        if (solutions == 1) {\n            for (int j = 1; j <= Y; j++) {\n                for (int i = 1; i <= X; i++) {\n                    if (i > 1) printf(\" \");\n                    printf(\"%d\", grid[i][j]);\n                }\n                printf(\"\\n\");\n            }\n        } else {\n            printf(\"NA\\n\");\n        }\n    }\n    \n    return 0;\n}\n", "perturbed_sampled": ["#include  k[16]; int s[11][11]; int  buyer, int x1,  i = x1; i <= x2;  y2; j++) { if (grid[i][j]  k[buyer] || !hasSign) return 0; return 1; } void fillRectangle(int  int y2, int buyer) {  y2; j++) {  int  = x1; i <= x2; i++) { for  grid[i][j] = 0; } }  if (solutions > 1)  { solutions++; return; }  x1 <= X; x1++) { for (int y1 = 1; y1 <= Y; y1++) { for (int x2 =   x1, y1, x2, y2)) { fillRectangle(x1, y1,  1); if (solutions  x2,  x2, y2);  0 && Y == 0 && n ==  = 1; i <= n;  &k[i]); } for  <= Y; j++)  i++)  = 0; solve(1); if (solutions ==  (int i = 1; i <= X; i++) { if (i > 1) printf(\" \"); printf(\"%d\", grid[i][j]);  {  }"], "perturbed_original": ["// Aizu 0213: Subdivide The  <stdio.h> #include <stdlib.h> #include <string.h> typedef struct { int     int w, int h) {  h; yy++)  map[y+yy][x+xx] != c) return  combi(int  x0,   (cnt) return 0; cnt = 1, memcpy(ans, map, sizeof(map)); return 1; } k = tbl[i].k; if   tbl[i].y,  = 0; j < plen[k]; j++) { w = pair[k][j][0], h = pair[k][j][1]; x1  1, y1 = y0 - h + 1; if (x1 < 0) x1 = 0;  = 0; for (y = y1; y <= y0; y++) for (x  + w > X || y  Next; if (!check(id, x, y, w, h)) continue;  if (!combi(i+1)) return 0; mark(0,  } int main() { int  x++) for (y =  if ((t = x * y) <=  = y; while (scanf(\"%d%d%d\", &X, &Y,  { for (s = i = 0; i  t, tbl[b].id =  for (y  map[y][x] = b; if (b > 0) tbl[b].x  } if (s  } qsort(tbl+1, n,   < Y; y++)  ans[y][x]); printf(\"\\n\"); } } return 0; }"], "original_ll": -0.9753254652023315, "sampled_ll": -0.47214704751968384, "all_perturbed_sampled_ll": [-2.563420057296753], "all_perturbed_original_ll": [-2.8448851108551025], "perturbed_sampled_ll": -2.563420057296753, "perturbed_original_ll": -2.8448851108551025, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "\nimport java.io.IOException;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.List;\nimport java.util.PriorityQueue;\nimport java.util.Scanner;\n\nimport scala.languageFeature.postfixOps;\nimport sun.tools.jar.resources.jar;\nimport lombok.Data;\n\npublic class Main {\n\n\tpublic static void main(String[] args) throws IOException {\n\t\tnew Main().run();\n\t}\n\n\tprivate void run() throws IOException {\n\t\tScanner scanner = new Scanner(System.in);\n\t\twhile (true) {\n\t\t\tw = scanner.nextInt();\n\t\t\th = scanner.nextInt();\n\t\t\tn = scanner.nextInt();\n\t\t\tif ((w | h | n) == 0)\n\t\t\t\tbreak;\n\t\t\tsize = new int[n + 1];\n\t\t\tpos = new int[n + 1][2];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tint b = scanner.nextInt();\n\t\t\t\tint k = scanner.nextInt();\n\t\t\t\tsize[b] = k;\n\t\t\t}\n\t\t\tm = new int[h][w];\n\t\t\t\n\t\t\tfor (int[] a : m)\n\t\t\t\tArrays.fill(a, -1);\n\t\t\tfor (int i = 0; i < h; i++) {\n\t\t\t\tfor (int j = 0; j < w; j++) {\n\t\t\t\t\tint x = scanner.nextInt();\n\t\t\t\t\tm[i][j] = x;\n\t\t\t\t\tif (x > 0) {\n\t\t\t\t\t\tpos[x][0] = i;\n\t\t\t\t\t\tpos[x][1] = j;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tassign = new int[n + 1][4];\n\t\t\tc = 0;\n\t\t\tans = new int[h][w];\n\t\t\tf(1);\n\t\t\tif (c == 1) {\n\t\t\t\tfor (int i = 0; i < h; i++) {\n\t\t\t\t\tfor (int j = 0; j < w; j++) {\n\t\t\t\t\t\tif (j > 0)\n\t\t\t\t\t\t\tSystem.out.print(\" \");\n\t\t\t\t\t\tSystem.out.print(ans[i][j]);\n\t\t\t\t\t}\n\t\t\t\t\tSystem.out.println();\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tSystem.out.println(\"NA\");\n\t\t\t}\n\n\t\t}\n\t}\n\n\tprivate void f(int k) {\n\t\tif (k == n + 1) {\n\t\t\tc++;\n\t\t\tif (c == 2)\n\t\t\t\treturn;\n\t\t\tfor (int i = 0; i < h; i++) {\n\t\t\t\tfor (int j = 0; j < w; j++) {\n\t\t\t\t\tint a = m[i][j];\n\t\t\t\t\tans[i][j] = a >= 100 ? a / 100 : a;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t\tint s = size[k];\n\t\tfor (int x = 1; x <= s; x++) {\n\t\t\tif (s % x != 0)\n\t\t\t\tcontinue;\n\t\t\tfor (int lj = pos[k][1] + 1 - x; lj <= pos[k][1]; lj++) {\n\t\t\t\tif (lj < 0 || lj > w)\n\t\t\t\t\tcontinue;\n\t\t\t\tloop: for (int li = pos[k][0] + 1 - s / x; li <= pos[k][0]; li++) {\n\t\t\t\t\tif (li < 0 || li > h)\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tint rj = lj + x;\n\t\t\t\t\tint ri = li + s / x;\n\t\t\t\t\tif (rj > w)\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tif (ri > h)\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tfor (int i = li; i < ri; i++) {\n\t\t\t\t\t\tfor (int j = lj; j < rj; j++) {\n\t\t\t\t\t\t\tif (m[i][j] != 0 && m[i][j] != k)\n\t\t\t\t\t\t\t\tcontinue loop;\n\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tfor (int i = li; i < ri; i++) {\n\t\t\t\t\t\tfor (int j = lj; j < rj; j++) {\n\t\t\t\t\t\t\tif (m[i][j] != k)\n\t\t\t\t\t\t\t\tm[i][j] = k * 100;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tf(k + 1);\n\t\t\t\t\tif (c == 2)\n\t\t\t\t\t\treturn;\n\t\t\t\t\tfor (int i = li; i < ri; i++) {\n\t\t\t\t\t\tfor (int j = lj; j < rj; j++) {\n\t\t\t\t\t\t\tif (m[i][j] != k)\n\t\t\t\t\t\t\t\tm[i][j] = 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\tint[][] m;\n\tint[] size;\n\tint[][] pos;\n\tint[][] assign;\n\tint w, h, n, c;\n\tint[][] ans;\n}", "sampled": "import java.util.*;\n\npublic class Main {\n    static int X, Y, n;\n    static int[] buyers;\n    static int[] counts;\n    static int[][] signs;\n    static List<int[][]> validSolutions;\n    \n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        \n        while (true) {\n            X = sc.nextInt();\n            Y = sc.nextInt();\n            n = sc.nextInt();\n            \n            if (X == 0 && Y == 0 && n == 0) break;\n            \n            buyers = new int[n];\n            counts = new int[n];\n            \n            for (int i = 0; i < n; i++) {\n                buyers[i] = sc.nextInt();\n                counts[i] = sc.nextInt();\n            }\n            \n            signs = new int[Y][X];\n            for (int i = 0; i < Y; i++) {\n                for (int j = 0; j < X; j++) {\n                    signs[i][j] = sc.nextInt();\n                }\n            }\n            \n            validSolutions = new ArrayList<>();\n            int[][] grid = new int[Y][X];\n            boolean[] used = new boolean[n];\n            \n            backtrack(grid, used, 0);\n            \n            if (validSolutions.size() == 0) {\n                System.out.println(\"NA\");\n            } else if (validSolutions.size() > 1) {\n                System.out.println(\"NA\");\n            } else {\n                int[][] sol = validSolutions.get(0);\n                for (int i = 0; i < Y; i++) {\n                    for (int j = 0; j < X; j++) {\n                        if (j > 0) System.out.print(\" \");\n                        System.out.print(sol[i][j]);\n                    }\n                    System.out.println();\n                }\n            }\n        }\n    }\n    \n    static void backtrack(int[][] grid, boolean[] used, int buyerIdx) {\n        if (buyerIdx == n) {\n            if (isValidComplete(grid)) {\n                int[][] copy = new int[Y][X];\n                for (int i = 0; i < Y; i++) {\n                    for (int j = 0; j < X; j++) {\n                        copy[i][j] = grid[i][j];\n                    }\n                }\n                validSolutions.add(copy);\n            }\n            return;\n        }\n        \n        if (validSolutions.size() > 1) return;\n        \n        int buyer = -1;\n        for (int i = 0; i < n; i++) {\n            if (!used[i]) {\n                buyer = i;\n                break;\n            }\n        }\n        \n        if (buyer == -1) return;\n        \n        int buyerNum = buyers[buyer];\n        int count = counts[buyer];\n        \n        for (int y1 = 0; y1 < Y; y1++) {\n            for (int x1 = 0; x1 < X; x1++) {\n                for (int y2 = y1; y2 < Y; y2++) {\n                    for (int x2 = x1; x2 < X; x2++) {\n                        int w = x2 - x1 + 1;\n                        int h = y2 - y1 + 1;\n                        if (w * h != count) continue;\n                        \n                        if (canPlace(grid, x1, y1, x2, y2, buyerNum)) {\n                            place(grid, x1, y1, x2, y2, buyerNum);\n                            used[buyer] = true;\n                            backtrack(grid, used, buyerIdx + 1);\n                            used[buyer] = false;\n                            place(grid, x1, y1, x2, y2, 0);\n                            \n                            if (validSolutions.size() > 1) return;\n                        }\n                    }\n                }\n            }\n        }\n    }\n    \n    static boolean canPlace(int[][] grid, int x1, int y1, int x2, int y2, int buyerNum) {\n        boolean hasSign = false;\n        for (int y = y1; y <= y2; y++) {\n            for (int x = x1; x <= x2; x++) {\n                if (grid[y][x] != 0) return false;\n                if (signs[y][x] != 0) {\n                    if (signs[y][x] != buyerNum) return false;\n                    hasSign = true;\n                }\n            }\n        }\n        return hasSign;\n    }\n    \n    static void place(int[][] grid, int x1, int y1, int x2, int y2, int buyerNum) {\n        for (int y = y1; y <= y2; y++) {\n            for (int x = x1; x <= x2; x++) {\n                grid[y][x] = buyerNum;\n            }\n        }\n    }\n    \n    static boolean isValidComplete(int[][] grid) {\n        for (int i = 0; i < Y; i++) {\n            for (int j = 0; j < X; j++) {\n                if (grid[i][j] == 0) return false;\n            }\n        }\n        return true;\n    }\n}\n", "perturbed_sampled": ["import java.util.*; public  int[] buyers; static int[] counts; static int[][] signs; static List<int[][]> validSolutions; public  Scanner(System.in); while (true) { X = sc.nextInt();  sc.nextInt(); if (X == 0  n == 0) break; buyers = new  for (int i  } signs = new  j = 0; j  int[][]  backtrack(grid, used, 0); if (validSolutions.size()  else if (validSolutions.size()  else  0; i < Y; i++)    } static void backtrack(int[][] grid, boolean[] used, int buyerIdx) { if (buyerIdx == n) { if (isValidComplete(grid)) { int[][]   0; j <  grid[i][j]; } } validSolutions.add(copy); } return; } if (validSolutions.size() >  = 0; i < n; i++) { if   == -1) return; int buyerNum     x1++) {  y2 < Y; y2++) { for (int x2  + 1; int h  1;  count) continue;  x1, y1, x2,  backtrack(grid, used, buyerIdx + 1); used[buyer] = false; place(grid, x1, y1,  >  } } } static boolean canPlace(int[][] grid, int x1, int y1, int  { boolean  y = y1; y  (int x =  0)  0) { if (signs[y][x] !=   int y2,  x++) { grid[y][x] =   i < Y; i++) { for  if (grid[i][j] == 0) return false; } } return true; } }"], "perturbed_original": ["import java.io.IOException; import java.util.ArrayList;  java.util.PriorityQueue; import java.util.Scanner; import scala.languageFeature.postfixOps;  static void main(String[] args) throws IOException  void run() throws IOException { Scanner scanner = new Scanner(System.in);  n = scanner.nextInt(); if ((w | h | n) ==  int[n  int[n + 1][2]; for (int i = 0; i <   } m   pos[x][0] = i; pos[x][1] = j; } } } assign = new  int[h][w]; f(1);  for (int i = 0; i < h; i++)  > 0) System.out.print(\" \");  else { System.out.println(\"NA\");  f(int  n + 1) { c++; if (c == 2)  0; i <  j = 0; j < w;  m[i][j];  x = 1; x <= s;   { if (lj   li = pos[k][0] + 1 - s  li++) { if (li < 0 ||  rj = lj + x; int ri = li + s / x; if  (ri > h) continue; for (int i = li; i < ri; i++) { for (int j = lj;  li;    (int i = li; i < ri;   j++)  m[i][j] = 0; } } } } } } int[][] m; int[] size; int[][]  ans; }"], "original_ll": -0.7249079942703247, "sampled_ll": -0.4022025465965271, "all_perturbed_sampled_ll": [-2.478459358215332], "all_perturbed_original_ll": [-2.4884567260742188], "perturbed_sampled_ll": -2.478459358215332, "perturbed_original_ll": -2.4884567260742188, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import copy\n\ndef main(land, b):\n    for h in range(H):\n        for w in range(W):\n            if land[h][w] == b:\n                if f1(land, h, w, b, data[land[h][w]]):\n                    return\n            \ndef f1(land, h, w, b, k):\n    for q in range(1, k+1):\n        if k%q == 0:\n            if f2(land, h, w, q, k/q, b):\n                return True\n    else:\n        return\n        \ndef f2(land, h, w, r, c, b):\n    for _h in range(r):\n        for _w in range(c):\n            if 0 <= h-_h and 0 <= w-_w:\n                if f3(land, h-_h, w-_w, r, c, b):\n                    return True\n    else:\n        return\n                \ndef f3(land, h, w, r, c, b):\n    _land = copy.deepcopy(land)\n    for _h in range(r):\n        for _w in range(c):\n            if 0 <= h+_h <= H-1 and 0 <= w+_w <= W-1:\n                if _land[h+_h][w+_w] == 0 or _land[h+_h][w+_w] == b:\n                    _land[h+_h][w+_w] = b\n                else:\n                    return\n            else:\n                return\n    else:\n        if b < n:\n            return main(_land, b+1)\n        else:\n            for line in _land:\n                print ' '.join(map(str, line))\n            return True\n\nwhile True:\n    W, H, n = map(int, raw_input().split())\n    if H == W == n == 0: break\n    data = {}\n    for i in range(n):\n        b, k = map(int, raw_input().split())\n        data[b] = k\n    land = [map(int, raw_input().split()) for i in range(H)]\n    main(land, 1)", "sampled": "import sys\nfrom itertools import product\n\ndef read_input():\n    datasets = []\n    lines = sys.stdin.read().strip().split('\\n')\n    i = 0\n    while i < len(lines):\n        parts = lines[i].split()\n        X, Y, n = int(parts[0]), int(parts[1]), int(parts[2])\n        if X == 0 and Y == 0 and n == 0:\n            break\n        \n        i += 1\n        memo = []\n        for _ in range(n):\n            b, k = map(int, lines[i].split())\n            memo.append((b, k))\n            i += 1\n        \n        signs = []\n        for _ in range(Y):\n            row = list(map(int, lines[i].split()))\n            signs.append(row)\n            i += 1\n        \n        datasets.append((X, Y, n, memo, signs))\n    \n    return datasets\n\ndef get_all_rectangles(X, Y):\n    rectangles = []\n    for x1 in range(X):\n        for y1 in range(Y):\n            for x2 in range(x1, X):\n                for y2 in range(y1, Y):\n                    rectangles.append((x1, y1, x2, y2))\n    return rectangles\n\ndef solve(X, Y, n, memo, signs):\n    rectangles = get_all_rectangles(X, Y)\n    \n    # Group rectangles by size\n    size_to_rects = {}\n    for rect in rectangles:\n        x1, y1, x2, y2 = rect\n        size = (x2 - x1 + 1) * (y2 - y1 + 1)\n        if size not in size_to_rects:\n            size_to_rects[size] = []\n        size_to_rects[size].append(rect)\n    \n    # For each buyer, get possible rectangles\n    buyer_rects = {}\n    for b, k in memo:\n        if k in size_to_rects:\n            buyer_rects[b] = size_to_rects[k]\n        else:\n            return \"NA\"\n    \n    # Try all combinations\n    def check_assignment(assignment):\n        grid = [[0] * Y for _ in range(X)]\n        \n        for buyer, rect in assignment.items():\n            x1, y1, x2, y2 = rect\n            for x in range(x1, x2 + 1):\n                for y in range(y1, y2 + 1):\n                    if grid[x][y] != 0:\n                        return None\n                    grid[x][y] = buyer\n        \n        # Check if signs match\n        for x in range(X):\n            for y in range(Y):\n                if signs[y][x] != 0:\n                    if grid[x][y] != signs[y][x]:\n                        return None\n        \n        return grid\n    \n    valid_grids = []\n    \n    def backtrack(buyers, assignment):\n        if not buyers:\n            grid = check_assignment(assignment)\n            if grid:\n                valid_grids.append(grid)\n            return\n        \n        buyer = buyers[0]\n        for rect in buyer_rects[buyer]:\n            assignment[buyer] = rect\n            backtrack(buyers[1:], assignment)\n            del assignment[buyer]\n    \n    buyers = [b for b, k in memo]\n    backtrack(buyers, {})\n    \n    if len(valid_grids) == 0:\n        return \"NA\"\n    elif len(valid_grids) == 1:\n        grid = valid_grids[0]\n        result = []\n        for y in range(Y):\n            row = []\n            for x in range(X):\n                row.append(str(grid[x][y]))\n            result.append(' '.join(row))\n        return '\\n'.join(result)\n    else:\n        return \"NA\"\n\ndatasets = read_input()\nfor X, Y, n, memo, signs in datasets:\n    result = solve(X, Y, n, memo, signs)\n    print(result)\n", "perturbed_sampled": ["import sys from itertools   i < len(lines): parts = lines[i].split() X,  0  = []  k = map(int, lines[i].split()) memo.append((b, k)) i += 1 signs = [] for _ in range(Y): row = list(map(int, lines[i].split())) signs.append(row) i  in  for x2 in range(x1,  Y): rectangles.append((x1, y1, x2, y2)) return rectangles def solve(X, Y, n,  Y) # Group rectangles by  - x1 + 1)  [] size_to_rects[size].append(rect) #  rectangles buyer_rects = {} for  = size_to_rects[k] else: return  [[0]  range(X)] for buyer, rect  y2  range(x1, x2 + 1):  + 1): if grid[x][y] != 0: return None grid[x][y] = buyer # Check if signs match  y  0: if grid[x][y] != signs[y][x]: return None   buyers: grid = check_assignment(assignment) if grid: valid_grids.append(grid) return buyer = buyers[0] for rect in buyer_rects[buyer]: assignment[buyer] = rect backtrack(buyers[1:],  [b for  []  = [] for  print(result)"], "perturbed_original": ["import copy def main(land, b): for h    for q in  return True else: return def f2(land, h, w, r, c, b):  0  w-_w:   w, r,  for _h in range(r): for _w  h+_h <= H-1  0 or _land[h+_h][w+_w] == b: _land[h+_h][w+_w] = b  return main(_land,  _land: print ' '.join(map(str, line)) return True  = map(int, raw_input().split()) if H == W ==  =  raw_input().split()) data[b] = k  i in range(H)] main(land, 1)"], "original_ll": -0.9159784317016602, "sampled_ll": -0.6988242268562317, "all_perturbed_sampled_ll": [-3.112957000732422], "all_perturbed_original_ll": [-3.083897113800049], "perturbed_sampled_ll": -3.112957000732422, "perturbed_original_ll": -3.083897113800049, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "#include <stdio.h>\n\nlong z(long a,long b,long c,long d,long e,long f){\n    return (c-a)*(f-b)-(e-a)*(d-b);\n}\nint x(int (*a)[8],int (*b)[8]){\n    int i,j;\n    for(i=0;i<4;i++){\n        for(j=0;j<4;j++){\n            if(z((*a)[j*2],(*a)[j*2+1],(*a)[(j*2+2)%8],(*a)[(j*2+2)%8+1],(*b)[i*2],(*b)[i*2+1])>0)break;\n        }\n        if(j==4)return 1;\n    }\n    return 0;\n}\n\nint main(){\n    int n,m;\n    int a[100],l[100][8],b[100];\n    int i,j,k;\n    int min,ii,jj,kk;\n    while(scanf(\"%d\",&n)&&n){\n        while(n--){\n            scanf(\"%d\",&m);\n            for(i=0;i<m;i++){\n                a[i]=i;\n                for(j=0;j<8;j++)scanf(\"%d\",&l[i][j]);\n            }\n            for(i=0;i<m;i++){\n                for(j=i+1;j<m;j++){\n                    if(x(&l[i],&l[j])){\n                        k=0;\n                        ii=i;\n                        while((b[k++]=ii),a[ii]!=ii)ii=a[ii];\n                        jj=j;\n                        while((b[k++]=jj),a[jj]!=jj)jj=a[jj];\n                        min=ii<jj?ii:jj;\n                        for(kk=0;kk<k;kk++)a[b[kk]]=min;\n                    }\n                }\n            }\n            for(i=0;i<m;i++){\n                j=i;\n                while(a[j]!=j)j=a[j];\n                a[i]=j;\n            }\n            k=0;\n            for(i=0;i<m;i++){\n                for(j=0;j<i;j++){\n                    if(a[i]==a[j])break;\n                }\n                if(j==i)k++;\n            }\n            printf(\"%d\\n\",k);\n        }\n    }\n    return 0;\n}", "sampled": "#include <stdio.h>\n#include <stdlib.h>\n#include <stdbool.h>\n\ntypedef struct {\n    int x, y;\n} Point;\n\ntypedef struct {\n    Point vertices[4];\n} Rectangle;\n\nbool segmentsIntersect(Point p1, Point q1, Point p2, Point q2) {\n    int d1 = (q1.x - p1.x) * (p2.y - p1.y) - (q1.y - p1.y) * (p2.x - p1.x);\n    int d2 = (q1.x - p1.x) * (q2.y - p1.y) - (q1.y - p1.y) * (q2.x - p1.x);\n    int d3 = (q2.x - p2.x) * (p1.y - p2.y) - (q2.y - p2.y) * (p1.x - p2.x);\n    int d4 = (q2.x - p2.x) * (q1.y - p2.y) - (q2.y - p2.y) * (q1.x - p2.x);\n    \n    if (((d1 > 0 && d2 < 0) || (d1 < 0 && d2 > 0)) &&\n        ((d3 > 0 && d4 < 0) || (d3 < 0 && d4 > 0))) {\n        return true;\n    }\n    \n    return false;\n}\n\nbool pointOnSegment(Point p, Point q, Point r) {\n    if (q.x <= (p.x > r.x ? p.x : r.x) && q.x >= (p.x < r.x ? p.x : r.x) &&\n        q.y <= (p.y > r.y ? p.y : r.y) && q.y >= (p.y < r.y ? p.y : r.y))\n        return true;\n    return false;\n}\n\nbool segmentsTouchOrIntersect(Point p1, Point q1, Point p2, Point q2) {\n    long long d1 = (long long)(q1.x - p1.x) * (p2.y - p1.y) - (long long)(q1.y - p1.y) * (p2.x - p1.x);\n    long long d2 = (long long)(q1.x - p1.x) * (q2.y - p1.y) - (long long)(q1.y - p1.y) * (q2.x - p1.x);\n    long long d3 = (long long)(q2.x - p2.x) * (p1.y - p2.y) - (long long)(q2.y - p2.y) * (p1.x - p2.x);\n    long long d4 = (long long)(q2.x - p2.x) * (q1.y - p2.y) - (long long)(q2.y - p2.y) * (q1.x - p2.x);\n    \n    if (((d1 > 0 && d2 < 0) || (d1 < 0 && d2 > 0)) &&\n        ((d3 > 0 && d4 < 0) || (d3 < 0 && d4 > 0))) {\n        return true;\n    }\n    \n    if (d1 == 0 && pointOnSegment(p1, p2, q1)) return true;\n    if (d2 == 0 && pointOnSegment(p1, q2, q1)) return true;\n    if (d3 == 0 && pointOnSegment(p2, p1, q2)) return true;\n    if (d4 == 0 && pointOnSegment(p2, q1, q2)) return true;\n    \n    return false;\n}\n\nbool pointInRectangle(Point p, Rectangle r) {\n    int crossings = 0;\n    for (int i = 0; i < 4; i++) {\n        Point p1 = r.vertices[i];\n        Point p2 = r.vertices[(i + 1) % 4];\n        \n        if ((p1.y <= p.y && p2.y > p.y) || (p1.y > p.y && p2.y <= p.y)) {\n            double vt = (double)(p.y - p1.y) / (p2.y - p1.y);\n            if (p.x < p1.x + vt * (p2.x - p1.x)) {\n                crossings++;\n            }\n        }\n    }\n    return (crossings % 2) == 1;\n}\n\nbool rectanglesTouchOrOverlap(Rectangle r1, Rectangle r2) {\n    for (int i = 0; i < 4; i++) {\n        if (pointInRectangle(r1.vertices[i], r2)) return true;\n        if (pointInRectangle(r2.vertices[i], r1)) return true;\n    }\n    \n    for (int i = 0; i < 4; i++) {\n        for (int j = 0; j < 4; j++) {\n            if (segmentsTouchOrIntersect(r1.vertices[i], r1.vertices[(i+1)%4],\n                                        r2.vertices[j], r2.vertices[(j+1)%4])) {\n                return true;\n            }\n        }\n    }\n    \n    return false;\n}\n\nint find(int parent[], int i) {\n    if (parent[i] != i)\n        parent[i] = find(parent, parent[i]);\n    return parent[i];\n}\n\nvoid unionSet(int parent[], int rank[], int x, int y) {\n    int xroot = find(parent, x);\n    int yroot = find(parent, y);\n    \n    if (rank[xroot] < rank[yroot])\n        parent[xroot] = yroot;\n    else if (rank[xroot] > rank[yroot])\n        parent[yroot] = xroot;\n    else {\n        parent[yroot] = xroot;\n        rank[xroot]++;\n    }\n}\n\nint main() {\n    int N;\n    \n    while (scanf(\"%d\", &N) && N != 0) {\n        for (int i = 0; i < N; i++) {\n            int M;\n            scanf(\"%d\", &M);\n            \n            Rectangle rectangles[100];\n            for (int j = 0; j < M; j++) {\n                for (int k = 0; k < 4; k++) {\n                    scanf(\"%d %d\", &rectangles[j].vertices[k].x, &rectangles[j].vertices[k].y);\n                }\n            }\n            \n            int parent[100], rank[100];\n            for (int j = 0; j < M; j++) {\n                parent[j] = j;\n                rank[j] = 0;\n            }\n            \n            for (int j = 0; j < M; j++) {\n                for (int k = j + 1; k < M; k++) {\n                    if (rectanglesTouchOrOverlap(rectangles[j], rectangles[k])) {\n                        unionSet(parent, rank, j, k);\n                    }\n                }\n            }\n            \n            int count = 0;\n            for (int j = 0; j < M; j++) {\n                if (find(parent, j) == j) {\n                    count++;\n                }\n            }\n            \n            printf(\"%d\\n\", count);\n        }\n    }\n    \n    return 0;\n}\n", "perturbed_sampled": [" int x, y; } Point; typedef  Rectangle; bool segmentsIntersect(Point p1, Point q1, Point p2, Point q2)    int d2  (q2.x - p1.x); int d3 = (q2.x -  * (p1.x - p2.x); int d4 = (q2.x - p2.x) *  - p2.x); if (((d1  0) || (d1 < 0 && d2 >   false; } bool pointOnSegment(Point  q.x >= (p.x <   r.y ? p.y : r.y)  r.y  true; return  long)(q1.x - p1.x) * (p2.y - p1.y) -  long d2 = (long long)(q1.x  - p1.y) *   p2.x) * (p1.y - p2.y) - (long long)(q2.y   (long  long)(q2.y - p2.y) *  <  &&   0)  return true; } if (d1  q1)) return true; if  q2, q1)) return  && pointOnSegment(p2, p1, q2)) return  return  pointInRectangle(Point p,  = 0; for (int  4; i++) { Point p1  r.vertices[(i + 1) % 4]; if ((p1.y  p.y   p1.y) / (p2.y - p1.y); if (p.x < p1.x  } } return  } bool rectanglesTouchOrOverlap(Rectangle r1, Rectangle  = 0; i < 4;  return true; if  for (int i = 0; i <  j =  return false; } int find(int parent[],   parent[i]); return parent[i]; } void unionSet(int parent[], int rank[], int x, int y) { int xroot = find(parent,  rank[yroot]) parent[xroot] = yroot; else if (rank[xroot] > rank[yroot]) parent[yroot] = xroot; else { parent[yroot] = xroot; rank[xroot]++; } } int main()  &N)  for (int i = 0; i     j < M; j++) { parent[j] = j;  j  (int k = j + 1; k   } int count =  0; j <  j)  } printf(\"%d\\n\",  }"], "perturbed_original": ["#include -1; }  (*a)[8],int (*b)[8]){ int i,j; for(i=0;i<4;i++){ for(j=0;j<4;j++){ if(z((*a)[j*2],(*a)[j*2+1],(*a)[(j*2+2)%8],(*a)[(j*2+2)%8+1],(*b)[i*2],(*b)[i*2+1])>0)break;  0; } int  int i,j,k; int min,ii,jj,kk; while(scanf(\"%d\",&n)&&n){ while(n--){  for(i=0;i<m;i++){ for(j=i+1;j<m;j++){ if(x(&l[i],&l[j])){ k=0;    if(j==i)k++; } printf(\"%d\\n\",k); } } return 0; }"], "original_ll": -0.9146959781646729, "sampled_ll": -0.33945316076278687, "all_perturbed_sampled_ll": [-2.2501628398895264], "all_perturbed_original_ll": [-1.8558189868927002], "perturbed_sampled_ll": -2.2501628398895264, "perturbed_original_ll": -1.8558189868927002, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import java.util.Arrays;\nimport java.util.Scanner;\n\n//Autumnal Illumination\npublic class Main{\n\n\tint n;\n\tint[][][] p;\n\t\n\tint cross(int[] s, int[] t, int[] r){\n\t\tint x1 = t[0]-s[0], y1 = t[1]-s[1], x2 = r[0]-s[0], y2 = r[1]-s[1];\n\t\treturn x1*y2-x2*y1;\n\t}\n\tboolean online(int[] s, int[] t, int[] r){\n\t\tif(cross(s, t, r)!=0)return false;\n\t\tint minx = Math.min(s[0], t[0]), maxx = Math.max(s[0], t[0]);\n\t\tint miny = Math.min(s[1], t[1]), maxy = Math.max(s[1], t[1]);\n\t\treturn minx<=r[0]&&r[0]<=maxx&&miny<=r[1]&&r[1]<=maxy;\n\t}\n\tboolean isCross(int[] a, int[] b, int[] s, int[] t){\n\t\tif(cross(a, b, s)*cross(a, b, t)>=0)return false;\n\t\treturn cross(b, a, s)*cross(b, a, t)<0;\n\t}\n\t\n\tboolean col(int a, int b){\n\t\tfor(int i=0;i<4;i++)for(int j=0;j<4;j++){\n\t\t\tif(online(p[a][i], p[a][(i+1)%4], p[b][j]))return true;\n\t\t\tif(online(p[b][i], p[b][(i+1)%4], p[a][j]))return true;\n\t\t\tif(isCross(p[a][i], p[a][(i+1)%4], p[b][j], p[b][(j+1)%4]))return true;\n\t\t}\n\t\tfor(int j=0;j<4;j++){\n\t\t\tboolean in = true;\n\t\t\tfor(int i=0;i<4;i++)if(cross(p[a][i], p[a][(i+1)%4], p[b][j])>=0)in = false;\n\t\t\tif(in)return true;\n\t\t}\n\t\treturn false;\n\t}\n\t\n\tvoid run(){\n\t\tScanner sc = new Scanner(System.in);\n\t\tfor(;;){\n\t\t\tint m = sc.nextInt();\n\t\t\tif(m==0)break;\n\t\t\twhile(m--!=0){\n\t\t\t\tn = sc.nextInt();\n\t\t\t\tp = new int[n][4][2];\n\t\t\t\tfor(int i=0;i<n;i++)for(int j=0;j<4;j++)for(int k=0;k<2;k++)p[i][j][k]=sc.nextInt();\n\t\t\t\tUnionFind u = new UnionFind(n);\n\t\t\t\tfor(int i=0;i<n;i++)for(int j=0;j<n;j++){\n\t\t\t\t\tif(u.find(i, j))continue;\n\t\t\t\t\tif(col(i, j))u.union(i, j);\n\t\t\t\t}\n\t\t\t\tSystem.out.println(u.num);\n\t\t\t}\n\t\t}\n\t}\n\t\n\tclass UnionFind {\n\t\tfinal int[] tree;\n\t\tint num;\n\t\tpublic UnionFind(int n) {\n\t\t\tthis.tree = new int[n];\n\t\t\tArrays.fill(tree, -1);\n\t\t\tnum=n;\n\t\t}\n\t\tvoid union(int x, int y) {\n\t\t\tx = root(x);\n\t\t\ty = root(y);\n\t\t\tif(x != y) {\n\t\t\t\tif(tree[x] < tree[y]) {\n\t\t\t\t\tx ^= y; y ^= x; x^= y;\n\t\t\t\t}\n\t\t\t\ttree[x] += tree[y];\n\t\t\t\ttree[y] = x;\n\t\t\t\tnum--;\n\t\t\t}\n\t\t}\n\t\tboolean find(int x, int y) {\n\t\t\treturn root(x) == root(y);\n\t\t}\n\t\tint root(int x) {\n\t\t\treturn tree[x] < 0 ? x : (tree[x] = root(tree[x]));\n\t\t}\n\t\tint size(int x) {\n\t\t\treturn -tree[root(x)];\n\t\t}\n\t\tint getNum() {\n\t\t\treturn num;\n\t\t}\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}", "sampled": "import java.util.*;\nimport java.io.*;\n\npublic class Main {\n    static class Point {\n        double x, y;\n        Point(double x, double y) {\n            this.x = x;\n            this.y = y;\n        }\n    }\n    \n    static class Quad {\n        Point[] points;\n        Quad(Point[] points) {\n            this.points = points;\n        }\n    }\n    \n    public static void main(String[] args) throws IOException {\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        String line;\n        \n        while ((line = br.readLine()) != null) {\n            int n = Integer.parseInt(line.trim());\n            if (n == 0) break;\n            \n            for (int i = 0; i < n; i++) {\n                int m = Integer.parseInt(br.readLine().trim());\n                Quad[] quads = new Quad[m];\n                \n                for (int j = 0; j < m; j++) {\n                    String[] tokens = br.readLine().trim().split(\"\\\\s+\");\n                    Point[] points = new Point[4];\n                    for (int k = 0; k < 4; k++) {\n                        points[k] = new Point(\n                            Double.parseDouble(tokens[k * 2]),\n                            Double.parseDouble(tokens[k * 2 + 1])\n                        );\n                    }\n                    quads[j] = new Quad(points);\n                }\n                \n                int components = countComponents(quads);\n                System.out.println(components);\n            }\n        }\n    }\n    \n    static int countComponents(Quad[] quads) {\n        int n = quads.length;\n        boolean[] visited = new boolean[n];\n        int count = 0;\n        \n        for (int i = 0; i < n; i++) {\n            if (!visited[i]) {\n                dfs(i, quads, visited);\n                count++;\n            }\n        }\n        \n        return count;\n    }\n    \n    static void dfs(int idx, Quad[] quads, boolean[] visited) {\n        visited[idx] = true;\n        \n        for (int i = 0; i < quads.length; i++) {\n            if (!visited[i] && intersectsOrTouches(quads[idx], quads[i])) {\n                dfs(i, quads, visited);\n            }\n        }\n    }\n    \n    static boolean intersectsOrTouches(Quad q1, Quad q2) {\n        // Check if q1 and q2 overlap or touch\n        if (polygonsIntersect(q1.points, q2.points)) return true;\n        if (polygonContainsPolygon(q1.points, q2.points)) return true;\n        if (polygonContainsPolygon(q2.points, q1.points)) return true;\n        return false;\n    }\n    \n    static boolean polygonsIntersect(Point[] p1, Point[] p2) {\n        // Check edge intersections or touching\n        for (int i = 0; i < 4; i++) {\n            for (int j = 0; j < 4; j++) {\n                if (segmentsIntersectOrTouch(p1[i], p1[(i+1)%4], p2[j], p2[(j+1)%4])) {\n                    return true;\n                }\n            }\n        }\n        \n        // Check if any vertex of one is inside the other\n        for (int i = 0; i < 4; i++) {\n            if (pointInOrOnPolygon(p1[i], p2)) return true;\n            if (pointInOrOnPolygon(p2[i], p1)) return true;\n        }\n        \n        return false;\n    }\n    \n    static boolean polygonContainsPolygon(Point[] p1, Point[] p2) {\n        for (int i = 0; i < 4; i++) {\n            if (pointInPolygon(p2[i], p1)) return true;\n        }\n        return false;\n    }\n    \n    static boolean segmentsIntersectOrTouch(Point p1, Point p2, Point p3, Point p4) {\n        double d1 = direction(p3, p4, p1);\n        double d2 = direction(p3, p4, p2);\n        double d3 = direction(p1, p2, p3);\n        double d4 = direction(p1, p2, p4);\n        \n        if (((d1 > 0 && d2 < 0) || (d1 < 0 && d2 > 0)) &&\n            ((d3 > 0 && d4 < 0) || (d3 < 0 && d4 > 0))) {\n            return true;\n        }\n        \n        if (Math.abs(d1) < 1e-9 && onSegment(p3, p4, p1)) return true;\n        if (Math.abs(d2) < 1e-9 && onSegment(p3, p4, p2)) return true;\n        if (Math.abs(d3) < 1e-9 && onSegment(p1, p2, p3)) return true;\n        if (Math.abs(d4) < 1e-9 && onSegment(p1, p2, p4)) return true;\n        \n        return false;\n    }\n    \n    static double direction(Point p1, Point p2, Point p3) {\n        return (p3.x - p1.x) * (p2.y - p1.y) - (p2.x - p1.x) * (p3.y - p1.y);\n    }\n    \n    static boolean onSegment(Point p1, Point p2, Point p) {\n        return Math.min(p1.x, p2.x) <= p.x + 1e-9 && p.x <= Math.max(p1.x, p2.x) + 1e-9 &&\n               Math.min(p1.y, p2.y) <= p.y + 1e-9 && p.y <= Math.max(p1.y, p2.y) + 1e-9;\n    }\n    \n    static boolean pointInOrOnPolygon(Point p, Point[] poly) {\n        return pointInPolygon(p, poly) || pointOnPolygonBoundary(p, poly);\n    }\n    \n    static boolean pointInPolygon(Point p, Point[] poly) {\n        int n = poly.length;\n        boolean inside = false;\n        for (int i = 0, j = n - 1; i < n; j = i++) {\n            if ((poly[i].y > p.y) != (poly[j].y > p.y) &&\n                p.x < (poly[j].x - poly[i].x) * (p.y - poly[i].y) / (poly[j].y - poly[i].y) + poly[i].x) {\n                inside = !inside;\n            }\n        }\n        return inside;\n    }\n    \n    static boolean pointOnPolygonBoundary(Point p, Point[] poly) {\n        int n = poly.length;\n        for (int i = 0; i < n; i++) {\n            if (Math.abs(direction(poly[i], poly[(i+1)%n], p)) < 1e-9 &&\n                onSegment(poly[i], poly[(i+1)%n], p)) {\n                return true;\n            }\n        }\n        return false;\n    }\n}\n", "perturbed_sampled": [" class Main { static  y; Point(double x, double y) { this.x = x;  { this.points = points;  new BufferedReader(new InputStreamReader(System.in)); String line; while ((line = br.readLine()) != null)  if (n == 0) break; for (int i = 0; i < n; i++) { int m  new Quad[m]; for  String[]  = new Point[4]; for (int k = 0; k < 4; k++) { points[k]  2]),  new Quad(points); } int components =  static int countComponents(Quad[]  new  dfs(int idx, Quad[] quads, boolean[] visited)  i < quads.length; i++)  quads[i])) { dfs(i, quads, visited); } } } static boolean intersectsOrTouches(Quad q1,  if  p2) {  (int j = 0; j < 4; j++)  p2[(j+1)%4])) { return    i++) { if (pointInOrOnPolygon(p1[i], p2)) return true; if (pointInOrOnPolygon(p2[i], p1)) return true; } return  p1, Point[] p2) { for (int i  p1)) return true; } return false; } static boolean segmentsIntersectOrTouch(Point p1,  p4) { double   d4 = direction(p1, p2, p4); if (((d1 >  && ((d3 > 0 &&  < 1e-9 && onSegment(p3,  (Math.abs(d2)   if (Math.abs(d4) < 1e-9 && onSegment(p1,  direction(Point p1, Point p2, Point p3) { return (p3.x  p1.x) * (p3.y - p1.y); } static   1e-9 && p.x <= Math.max(p1.x,  Math.max(p1.y, p2.y) + 1e-9; } static boolean  pointOnPolygonBoundary(p, poly);  Point[] poly) { int  = false;  j = n - 1; i < n; j = i++) { if ((poly[i].y  p.y) && p.x < (poly[j].x -    }   n; i++) { if (Math.abs(direction(poly[i], poly[(i+1)%n], p)) < 1e-9 && onSegment(poly[i], poly[(i+1)%n], p)) { return true;  }"], "perturbed_original": ["import java.util.Arrays;  class Main{ int  t[0]-s[0], y1 = t[1]-s[1], x2 = r[0]-s[0],  } boolean online(int[] s, int[] t,  Math.min(s[0], t[0]), maxx = Math.max(s[0], t[0]); int miny = Math.min(s[1], t[1]), maxy = Math.max(s[1], t[1]); return minx<=r[0]&&r[0]<=maxx&&miny<=r[1]&&r[1]<=maxy; } boolean isCross(int[] a, int[]   s)*cross(b, a, t)<0;  if(isCross(p[a][i], p[a][(i+1)%4],  p[b][j])>=0)in = false; if(in)return true; } return false; } void run(){ Scanner sc  m = sc.nextInt(); if(m==0)break; while(m--!=0){  new  UnionFind  if(col(i, j))u.union(i, j); } System.out.println(u.num); } } } class UnionFind { final int[] tree; int num; public UnionFind(int  int[n];  union(int  = root(x);  x^= y; } tree[x] += tree[y]; tree[y]  == root(y); } int  : (tree[x]  x)  new Main().run(); } }"], "original_ll": -0.6681732535362244, "sampled_ll": -0.38209161162376404, "all_perturbed_sampled_ll": [-2.1221632957458496], "all_perturbed_original_ll": [-2.3057315349578857], "perturbed_sampled_ll": -2.1221632957458496, "perturbed_original_ll": -2.3057315349578857, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "from sys import stdin\nfrom itertools import product\n\ndef chk_in_rect(xy1,xy2):\n    chk = True\n    for i in range(4):\n        for j in range(4):\n            a = (xy1[(2*i+2)&7]-xy1[(2*i  )&7]) * (xy2[(2*j+1)&7]-xy1[(2*i+1)&7])\n            b = (xy1[(2*i+3)&7]-xy1[(2*i+1)&7]) * (xy2[(2*j  )&7]-xy1[(2*i  )&7])\n            if a > b: chk = False; break\n    if chk: return True\n    else: return False\n\ndef chk_intersect(xy1,xy2):\n    for i,j in product(range(4),repeat=2):\n        a = (xy1[(2*i  )&7]-xy1[(2*i+2)&7]) * (xy2[(2*j+1)&7]-xy1[(2*i+3)&7])\n        a+= (xy1[(2*i+1)&7]-xy1[(2*i+3)&7]) * (xy2[(2*i  )&7]-xy1[(2*j  )&7])\n        b = (xy1[(2*i  )&7]-xy1[(2*i+2)&7]) * (xy2[(2*j+3)&7]-xy1[(2*i+3)&7])\n        b+= (xy1[(2*i+1)&7]-xy1[(2*i+3)&7]) * (xy2[(2*i  )&7]-xy1[(2*j+2)&7])\n        if a*b < 0 : return True\n    else:\n        return False\n\nwhile(True):\n    try:\n        n = int(stdin.readline())\n        if not n: break\n    except:\n        break\n    for _ in range(n):\n        m = int(stdin.readline())\n        p = list(range(m))\n        xys = [ list(map(int, stdin.readline().split())) for i in range(m) ]\n        # print(n,m,xys)\n        for i in range(m):\n            if len(set(p)) == 1: print(1); break\n            for j in range(i+1,m):\n                if p[i] == p[j]:\n                    continue\n                if chk_in_rect(xys[i],xys[j]):\n                    # print(\"in_rect\")\n                    p = [i if e==j else e for e in p]\n                    continue\n                if chk_intersect(xys[i],xys[j]):\n                    # print(\"intersect\")\n                    p = [i if e==j else e for e in p]\n                    continue\n        else: print(len(set(p)))\n\n\n\n\n", "sampled": "def rectangles_overlap_or_touch(rect1, rect2):\n    # Check if two rectangles overlap or touch (including edges)\n    # rect is list of 4 points [(x1,y1), (x2,y2), (x3,y3), (x4,y4)]\n    \n    # Check if rectangles are separated (no overlap or touch)\n    # Use Separating Axis Theorem (SAT)\n    \n    def get_edges(rect):\n        edges = []\n        for i in range(4):\n            p1 = rect[i]\n            p2 = rect[(i+1)%4]\n            edges.append((p2[0]-p1[0], p2[1]-p1[1]))\n        return edges\n    \n    def get_normals(edges):\n        normals = []\n        for edge in edges:\n            normals.append((-edge[1], edge[0]))\n        return normals\n    \n    def project(rect, axis):\n        dots = []\n        for point in rect:\n            dots.append(point[0]*axis[0] + point[1]*axis[1])\n        return min(dots), max(dots)\n    \n    def overlap(proj1, proj2):\n        return proj1[1] >= proj2[0] and proj2[1] >= proj1[0]\n    \n    edges1 = get_edges(rect1)\n    edges2 = get_edges(rect2)\n    normals = get_normals(edges1) + get_normals(edges2)\n    \n    for normal in normals:\n        proj1 = project(rect1, normal)\n        proj2 = project(rect2, normal)\n        if not overlap(proj1, proj2):\n            return False\n    \n    return True\n\ndef find_connected_components(rectangles):\n    n = len(rectangles)\n    if n == 0:\n        return 0\n    \n    # Build adjacency list\n    adj = [[] for _ in range(n)]\n    for i in range(n):\n        for j in range(i+1, n):\n            if rectangles_overlap_or_touch(rectangles[i], rectangles[j]):\n                adj[i].append(j)\n                adj[j].append(i)\n    \n    # DFS to count connected components\n    visited = [False] * n\n    components = 0\n    \n    def dfs(node):\n        visited[node] = True\n        for neighbor in adj[node]:\n            if not visited[neighbor]:\n                dfs(neighbor)\n    \n    for i in range(n):\n        if not visited[i]:\n            dfs(i)\n            components += 1\n    \n    return components\n\nwhile True:\n    n = int(input())\n    if n == 0:\n        break\n    \n    for _ in range(n):\n        m = int(input())\n        rectangles = []\n        for _ in range(m):\n            coords = list(map(int, input().split()))\n            rect = [(coords[i], coords[i+1]) for i in range(0, 8, 2)]\n            rectangles.append(rect)\n        \n        result = find_connected_components(rectangles)\n        print(result)\n", "perturbed_sampled": ["def rectangles_overlap_or_touch(rect1, rect2): # Check if  (including edges)  4  or touch) # Use Separating Axis Theorem (SAT) def get_edges(rect): edges  range(4): p1  edges.append((p2[0]-p1[0], p2[1]-p1[1]))  = [] for edge in edges: normals.append((-edge[1], edge[0])) return normals def project(rect, axis): dots = [] for  def  proj1[0]    proj2 = project(rect2, normal) if not  True def find_connected_components(rectangles): n = len(rectangles) if n ==   to count connected components visited = [False] * n components = 0 def dfs(node): visited[node]  dfs(neighbor) for i  for _ in range(n): m = int(input())  in range(m): coords  [(coords[i], coords[i+1]) for i in  = find_connected_components(rectangles) print(result)"], "perturbed_original": ["from sys import stdin from itertools else if<extra_id_5>_s<extra_id_6>(xys: [ [ ] ]]):<extra_id_7>t,d]) f, l , d<extra_id_8>d=0 l<extra_id_9>n=set(p):<extra_id_10> = True for i in range(4): for j  )&7]) *  = False;  else: return  a+= (xy1[(2*i+1)&7]-xy1[(2*i+3)&7]) * (xy2[(2*i )&7]-xy1[(2*j )&7]) b = (xy1[(2*i  * (xy2[(2*i  return False while(True):  break for _  p = list(range(m)) xys = [ list(map(int, stdin.readline().split())) for i in    if chk_in_rect(xys[i],xys[j]): # print(\"in_rect\") p  e for e in   e==j else e for  print(len(set(p)))"], "original_ll": -0.8006585836410522, "sampled_ll": -0.6944035291671753, "all_perturbed_sampled_ll": [-2.9110453128814697], "all_perturbed_original_ll": [-3.435755729675293], "perturbed_sampled_ll": -2.9110453128814697, "perturbed_original_ll": -3.435755729675293, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "mx,my;pn[7];px[7][1000],py[7][1000];M[5][7][1000];a0;Calc(a1,a2){int n1,n2,m,mm;for(n2=0;n2<pn[a2];n2++){mm=1e9;for(n1=0;n1<pn[a1];n1++){m=M[a0][a1][n1]+abs(px[a1][n1]-px[a2][n2])+abs(py[a1][n1]-py[a2][n2]);if(m<mm)mm=m;}M[a0][a2][n2]=mm;}}main(){int x,y,c,a,am;for(;scanf(\"%d%d\\n\",&mx,&my),mx;){memset(pn,0,sizeof(pn));for(y=0;y<my;y++){for(x=0;x<=mx;x++){c=getchar();if(c>='1'){if(c<='5')a=c-'0';else if(c=='S')a=0;else if(c=='G')a=6;px[a][pn[a]]=x;py[a][pn[a]++]=y;}}}am=0;for(a0=0;a0<5;a0++){M[a0][0][0]=0;Calc(0,1+(a0+1)%5);for(a=0;a<3;a++)Calc(1+(a0+a+1)%5,1+(a0+a+2)%5);Calc(1+(a0+4)%5,6);if(M[a0][6][0]<M[am][6][0])am=a0;}printf(M[am][6][0]!=1e9?\"%d %d\\n\":\"NA\\n\",1+am,M[am][6][0]);}{int n;for(n=1000000;n--;)getchar();}exit(0);}", "sampled": "#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n\n#define MAX 1000\n#define INF 1000000000\n\ntypedef struct {\n    int x, y, mask;\n} State;\n\ntypedef struct {\n    int x, y;\n} Point;\n\nchar map[MAX][MAX];\nint W, H;\nPoint start, goal;\nPoint creatures[5][MAX];\nint creature_count[5];\n\nint dx[] = {0, 0, 1, -1};\nint dy[] = {1, -1, 0, 0};\n\ntypedef struct {\n    State data[MAX * MAX * 32];\n    int front, rear;\n} Queue;\n\nvoid init_queue(Queue *q) {\n    q->front = 0;\n    q->rear = 0;\n}\n\nvoid enqueue(Queue *q, State s) {\n    q->data[q->rear++] = s;\n}\n\nState dequeue(Queue *q) {\n    return q->data[q->front++];\n}\n\nint is_empty(Queue *q) {\n    return q->front == q->rear;\n}\n\nint bfs(int start_attr) {\n    int dist[MAX][MAX][32];\n    int i, j, k;\n    \n    for (i = 0; i < H; i++) {\n        for (j = 0; j < W; j++) {\n            for (k = 0; k < 32; k++) {\n                dist[i][j][k] = INF;\n            }\n        }\n    }\n    \n    Queue q;\n    init_queue(&q);\n    \n    State s;\n    s.x = start.x;\n    s.y = start.y;\n    s.mask = (1 << start_attr);\n    dist[s.x][s.y][s.mask] = 0;\n    enqueue(&q, s);\n    \n    while (!is_empty(&q)) {\n        State cur = dequeue(&q);\n        int cx = cur.x;\n        int cy = cur.y;\n        int cmask = cur.mask;\n        \n        if (cx == goal.x && cy == goal.y && cmask == 31) {\n            return dist[cx][cy][cmask];\n        }\n        \n        for (i = 0; i < 4; i++) {\n            int nx = cx + dx[i];\n            int ny = cy + dy[i];\n            \n            if (nx < 0 || nx >= H || ny < 0 || ny >= W) continue;\n            \n            int nmask = cmask;\n            \n            if (map[nx][ny] >= '1' && map[nx][ny] <= '5') {\n                int attr = map[nx][ny] - '1';\n                int can_catch = 0;\n                \n                for (j = 0; j < 5; j++) {\n                    if (cmask & (1 << j)) {\n                        int catchable = (j + 1) % 5;\n                        if (catchable == attr) {\n                            can_catch = 1;\n                            break;\n                        }\n                    }\n                }\n                \n                if (can_catch) {\n                    nmask |= (1 << attr);\n                }\n            }\n            \n            if (dist[nx][ny][nmask] > dist[cx][cy][cmask] + 1) {\n                dist[nx][ny][nmask] = dist[cx][cy][cmask] + 1;\n                State ns;\n                ns.x = nx;\n                ns.y = ny;\n                ns.mask = nmask;\n                enqueue(&q, ns);\n            }\n        }\n    }\n    \n    return INF;\n}\n\nint main() {\n    while (1) {\n        scanf(\"%d %d\", &W, &H);\n        if (W == 0 && H == 0) break;\n        \n        int i, j;\n        for (i = 0; i < 5; i++) {\n            creature_count[i] = 0;\n        }\n        \n        for (i = 0; i < H; i++) {\n            scanf(\"%s\", map[i]);\n            for (j = 0; j < W; j++) {\n                if (map[i][j] == 'S') {\n                    start.x = i;\n                    start.y = j;\n                } else if (map[i][j] == 'G') {\n                    goal.x = i;\n                    goal.y = j;\n                } else if (map[i][j] >= '1' && map[i][j] <= '5') {\n                    int attr = map[i][j] - '1';\n                    creatures[attr][creature_count[attr]].x = i;\n                    creatures[attr][creature_count[attr]].y = j;\n                    creature_count[attr]++;\n                }\n            }\n        }\n        \n        int min_dist = INF;\n        int best_attr = -1;\n        \n        for (i = 0; i < 5; i++) {\n            int d = bfs(i);\n            if (d < min_dist) {\n                min_dist = d;\n                best_attr = i;\n            }\n        }\n        \n        if (min_dist == INF) {\n            printf(\"NA\\n\");\n        } else {\n            printf(\"%d %d\\n\", best_attr + 1, min_dist);\n        }\n    }\n    \n    return 0;\n}\n", "perturbed_sampled": ["#include <stdio.h> #include <string.h> #include <stdlib.h> #define MAX 1000 #define     map[MAX][MAX]; int W, H;  int  0, 1,  struct {    = 0; } void  is_empty(Queue *q) {  int dist[MAX][MAX][32]; int i, j, k; for (i =  32;  s.x = start.x;  while (!is_empty(&q)) { State cur = dequeue(&q); int cx = cur.x; int   } for (i = 0;  int nx = cx + dx[i]; int ny = cy + dy[i]; if (nx <   int  <= '5')  -  for (j = 0; j <   + 1) % 5; if (catchable == attr) { can_catch = 1; break; } }  |= (1 <<  > dist[cx][cy][cmask] + 1) {  return INF; }  { scanf(\"%d %d\", &W, &H); if (W ==  break; int i, j; for (i  i++)  for (i = 0; i < H; i++) {  j++) { if (map[i][j] == 'S') { start.x  == 'G') { goal.x = i; goal.y = j; }  && map[i][j] <= '5') {   } } int min_dist = INF; int   < min_dist) { min_dist = d; best_attr = i; } } if (min_dist   + 1, min_dist); } } return 0; }"], "perturbed_original": ["mx,my;pn[7];px[7][1000],py[7][1000];M[5][7][1000];a0;Calc(a1,a2){int n1,n2,m,mm;for(n2=0;n2<pn[a2];n2++){mm=1e9;for(n1=0;n1<pn[a1];n1++){m=M[a0][a1][n1]+abs(px[a1][n1]-px[a2][n2])+abs(py[a1][n1]-py[a2][n2]);if(m<mm)mm=m;}M[a0][a2][n2]=mm;}}main(){int x,y,c,a,am;for(;scanf(\"%d%d\\n\",&mx,&my),mx;){memset(pn,0,sizeof(pn));for(y=0;y<my;y++){for(x=0;x<=mx;x++){c=getchar();if(c>='1'){if(c<='5')a=c-'0';else if(c=='S')a=0;else if(c=='G')a=6;px[a][pn[a]]=x;py[a][pn[a]++]=y;}}}am=0;for(a0=0;a0<5;a0++){M[a0][0][0]=0;Calc(0,1+(a0+1)%5);for(a=0;a<3;a++)Calc(1+(a0+a+1)%5,1+(a0+a+2)%5);Calc(1+(a0+4)%5,6);if(M[a0][6][0]<M[am][6][0])am=a0;}printf(M[am][6][0]!=1e9?\"%d %d\\n\":\"NA\\n\",1+am,M[am][6][0]);}{int n;for(n=1000000;n--;)getchar();}exit(0);}"], "original_ll": -1.6285407543182373, "sampled_ll": -0.46010008454322815, "all_perturbed_sampled_ll": [-2.483398199081421], "all_perturbed_original_ll": [-1.6285407543182373], "perturbed_sampled_ll": -2.483398199081421, "perturbed_original_ll": -1.6285407543182373, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import java.awt.Point;\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic class Main {\n\n\t/** ????\u00a7??????? */\n\tstatic final String WHITE_SPACE = \" \";\n\n\t/** ??????????????????_X */\n\tstatic int mapSizeX = 0;\n\n\t/** ??????????????????_Y */\n\tstatic int mapSizeY = 0;\n\n\t/** ??????????????\u00b0 */\n\tstatic int maxNode = 0;\n\n\t/** ????????\u00a2??????????????? */\n\tstatic List<Point> pachimonList = new ArrayList<Point>();\n\n\t/** ?????????????\u00a8??????????????????????????\u00b4??????? */\n\tstatic boolean[] visited = new boolean[5003];\n\n\t/** ??????????????????????????? */\n\tstatic int[] cost = new int[5003];\n\n\t/** ?????????????????? */\n\tstatic int startIdx = 0;\n\n\t/** ??\u00b4???????????? */\n\tstatic int goalIdx = 0;\n\n\t/**\n\t * @param args\n\t * @throws IOException\n\t */\n\tpublic static void main(String[] args) throws IOException {\n\t\tInputStreamReader is = new InputStreamReader(System.in);\n\t\tBufferedReader br = new BufferedReader(is);\n\t\tString[] mapSizeLine = new String[2];\n\t\tPoint output = createPos(0, Integer.MAX_VALUE);\n\t\twhile (true) {\n\t\t\tmapSizeLine = br.readLine().split(WHITE_SPACE);\n\t\t\tmapSizeX = Integer.parseInt(mapSizeLine[0]);\n\t\t\tmapSizeY = Integer.parseInt(mapSizeLine[1]);\n\t\t\tif (mapSizeX == 0 && mapSizeY == 0)\n\t\t\t\tbreak;\n\n\t\t\treadMap(br);\n\t\t\toutput.x = 0;\n\t\t\toutput.y = Integer.MAX_VALUE;\n\t\t\tif (maxNode > 5) {\n\t\t\t\tfor (int type = 1; type <= 5; type++) {\n\t\t\t\t\t// ??????????????????????????\u00a2??????????????????????????????????????????????\u00b4\u00a2\n\t\t\t\t\tint cost = searchRoute(type);\n\t\t\t\t\tif (cost < output.y && cost > 0) {\n\t\t\t\t\t\toutput.x = type;\n\t\t\t\t\t\toutput.y = cost;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// ???????????????\n\t\t\tif (output.y == Integer.MAX_VALUE) {\n\t\t\t\tSystem.out.println(\"NA\");\n\t\t\t} else {\n\t\t\t\tSystem.out.println(output.x + WHITE_SPACE + output.y);\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * ?????????????????????????????????\n\t * @param scanner ????????\u00a3??????\n\t * @throws IOException\n\t */\n\tprivate static void readMap(BufferedReader br) throws IOException {\n\t\t// ??????????????\u00b1????????????\n\t\tpachimonList.removeAll(pachimonList);\n\t\tmaxNode = 0;\n\t\tstartIdx = 0;\n\n\t\tfor (int i = 0; i < mapSizeY; i++) {\n\t\t\tfor (int j = 0; j < mapSizeX; j++) {\n\t\t\t\tint val = convertInt(br.read());\n\t\t\t\tif (val < 9) {\n\t\t\t\t\t// ???????????\u00a2????????\u00b0????\u00a8????\n\t\t\t\t\tif (val == 0)\n\t\t\t\t\t\tstartIdx = pachimonList.size();\n\t\t\t\t\tif (val == 6)\n\t\t\t\t\t\tgoalIdx = pachimonList.size();\n\t\t\t\t\tpachimonList.add(createPos(val, calcIndex(j, i)));\n\t\t\t\t}\n\t\t\t}\n\t\t\t// ????????????????\u00a3???\u00b0???\n\t\t\tbr.readLine();\n\t\t}\n\t\tmaxNode = pachimonList.size();\n\t}\n\n\t/**\n\t * ??\u00a2????????????????????????int??????????????????\n\t * @param target ????\u00b1??????????\n\t * @return ???????????????\n\t */\n\tprivate static int convertInt(int target) {\n\t\tif (target == 83)\n\t\t\treturn 0;\n\t\tif (target == 71)\n\t\t\treturn 6;\n\t\tif (target >= 49 && target <= 53)\n\t\t\treturn target - 48;\n\t\treturn 9;\n\t}\n\n\t/**\n\t * X????????????????????\u00b4?????????????????\u00a2???????\u00b1???\u00a7????\u00a8????<br>\n\t * ????????????:0?????\u00b4??????:6???????????\u00a2???????\u00b1???\u00a7:1???5<br>\n\t * Y????????????????????????????????????????\u00b4?\n\t * @param type ?????????????????\u00b4?????????????????\u00a2???????\u00b1???\u00a7\n\t * @param index ??????????????????????????????\n\t * @return\n\t */\n\tprivate static Point createPos(int type, int index) {\n\t\treturn new Point(type, index);\n\t}\n\n\t/**\n\t * ?????\u00a8????????\u00a2???????????????????????????????????????????????\u00a2???????\u00b1???\u00a7?????????\n\t * @param currentType ??????????????????????????\u00a2???????\u00b1???\u00a7\n\t * @return ?????????????????????????????\u00a2???????\u00b1???\u00a7\n\t */\n\tprivate static int getNextType(int currentType) {\n\t\tif (currentType == 5)\n\t\t\treturn 1;\n\t\treturn currentType + 1;\n\t}\n\n\t/**\n\t * ??????????????????????????\u00a2?????????????????????????????????????????\u00a2???????\u00b1???\u00a7?????????\n\t * @param firstType ??????????????????????????\u00a2???????\u00b1???\u00a7\n\t * @return ?????????????????????????????\u00a2???????\u00b1???\u00a7\n\t */\n\tprivate static int getEndType(int firstType) {\n\t\tif (firstType == 1)\n\t\t\treturn 5;\n\t\treturn firstType - 1;\n\t}\n\n\t/**\n\t * ??\u00a3??\\??????????\u00a8?????????????????????????????????\u00b4???????????\u00a7???<br>\n\t * ????????????????????????????\u00b1???????\n\t * @param adjacent ??\u00a3??\\??????\n\t * @return ????????????????????????\n\t */\n\tprivate static int searchRoute(int firstType) {\n\n\t\tfor (int i = 0; i < maxNode; i++) {\n\t\t\tcost[i] = Integer.MAX_VALUE;\n\t\t\tvisited[i] = false;\n\t\t}\n\n\t\t// ??????????????\u00b0????????\u00a7???????????????0\n\t\tcost[startIdx] = 0;\n\n\t\twhile (true) {\n\t\t\t// ?\u00a8?????????????????????????????????\u00a7?????????????????????????\u00b1???????\n\t\t\tint node = minIndex(cost, visited);\n\t\t\tif (node < 0) {\n\t\t\t\treturn cost[goalIdx];\n\t\t\t}\n\t\t\t// ??\u00a2?\u00b4\u00a2???????????????????????????????????\u00b0????????????\n\t\t\tvisited[node] = true;\n\t\t\tfor (int j = 0; j < maxNode; j++) {\n\t\t\t\tif (isLinked(node, j, firstType) && !visited[j]) {\n\t\t\t\t\tint nextNodeCost = cost[node] + clucCost(pachimonList.get(node), pachimonList.get(j));\n\t\t\t\t\t// ????????\u00a7????????\u00a2??????????\u00b0????????????\u00b0???????????\u00a2??\u00a8???????\u00a8???\u00b6\n\t\t\t\t\tif (nextNodeCost < cost[j]) {\n\t\t\t\t\t\tcost[j] = nextNodeCost;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * ?????\u00a8??????????????\u00a8????\u00b1??????????????????\\?\u00b6?????????????????????????????????\\\n\t * @param node ?????\u00a8????????????\n\t * @param target ????\u00b1?????????????\n\t * @return ?????\\??????\n\t */\n\tprivate static boolean isLinked(int node, int target, int firstType) {\n\t\tint currentType = pachimonList.get(node).x;\n\t\tint targetType = pachimonList.get(target).x;\n\t\t// ??????????????\u00a2?????\u00a8???????\u00b1???\u00a7?????????????????????????????????????????\\?\u00b6????????????????\n\t\tif (currentType == firstType)\n\t\t\treturn false;\n\t\t// ????\u00b1??????????????????\u00a2?????\u00a8???????\u00b1???\u00a7?????\u00b4????????\\?\u00b6????????????????\n\t\tif (targetType == firstType)\n\t\t\treturn false;\n\t\t// ??????????????\u00b4???????????\u00b4????????\\?\u00b6??????????????????????????????????\n\t\tif (currentType == maxNode)\n\t\t\treturn false;\n\n\t\t// ????????????????????????(\"0\")?????\u00b4??????????\u00b1???????????????????????????\u00a2???????\u00b1???\u00a7????\u00ac?????????\\?\u00b6????????????????\n\t\tif (currentType == 0)\n\t\t\treturn targetType == getNextType(firstType);\n\n\t\t// ?????\u00a8????????????????\u00b1???\u00a7????????????????????????????????\u00a2????????\u00b4????????\u00b4??????????????\\?\u00b6?\n\t\tif (currentType == getEndType(firstType))\n\t\t\treturn targetType == 6;\n\n\t\treturn getNextType(currentType) == targetType;\n\t}\n\n\t/**\n\t * ?\u00a8???????????????????????????????????????????????????????????????????????????????????\u00b1???????\n\t * @param cost ???????????????????????????\n\t * @param visited ?????????????\u00a8??????????????????????????\u00b4???????\n\t * @return ??????????????????\n\t */\n\tprivate static int minIndex(int[] cost, boolean[] visited) {\n\t\tint index = 0;\n\t\tfor (; index < maxNode; index++) {\n\t\t\tif (!visited[index])\n\t\t\t\tbreak;\n\t\t}\n\t\tif (index == maxNode)\n\t\t\treturn -1;\n\t\tfor (int i = index + 1; i < maxNode; i++) {\n\t\t\tif (!visited[i] && cost[i] < cost[index])\n\t\t\t\tindex = i;\n\t\t}\n\t\treturn index;\n\t}\n\n\t/**\n\t * ????????????????????????????????\u00b4???????????\u00a7????????????????\u00a8?????????????\n\t * @param sx ???????????????X??\u00a7?\u00a8?\n\t * @param sy ???????????????Y??\u00a7?\u00a8?\n\t * @param gx ??\u00b4?????????X??\u00a7?\u00a8?\n\t * @param gy ??\u00b4?????????Y??\u00a7?\u00a8?\n\t * @param nextType ?\u00ac????????????????????????\u00a2????\u00b1???\u00a7\n\t */\n\tprivate static int clucCost(Point from, Point to) {\n\t\tint fx = from.y / mapSizeY;\n\t\tint fy = from.y % mapSizeY;\n\t\tint tx = to.y / mapSizeY;\n\t\tint ty = to.y % mapSizeY;\n\t\treturn Math.abs(tx - fx) + Math.abs(ty - fy);\n\t}\n\n\t/**\n\t * X??\u00a7?\u00a8???\u00a8Y??\u00a7?\u00a8???????????????\u00a3?????????????????????????????????????????\u00b4?????????\n\t *\n\t * @param x X??\u00a7?\u00a8?\n\t * @param y Y??\u00a7?\u00a8?\n\t * @return\n\t */\n\tprivate static int calcIndex(int x, int y) {\n\t\treturn x * mapSizeY + y;\n\t}\n}", "sampled": "import java.util.*;\nimport java.io.*;\n\npublic class Main {\n    static int[] dx = {0, 0, 1, -1};\n    static int[] dy = {1, -1, 0, 0};\n    \n    public static void main(String[] args) throws IOException {\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        String line;\n        \n        while ((line = br.readLine()) != null) {\n            String[] tokens = line.trim().split(\"\\\\s+\");\n            int W = Integer.parseInt(tokens[0]);\n            int H = Integer.parseInt(tokens[1]);\n            \n            if (W == 0 && H == 0) break;\n            \n            char[][] map = new char[H][W];\n            int sx = -1, sy = -1, gx = -1, gy = -1;\n            \n            for (int i = 0; i < H; i++) {\n                String row = br.readLine();\n                for (int j = 0; j < W; j++) {\n                    map[i][j] = row.charAt(j);\n                    if (map[i][j] == 'S') {\n                        sx = i;\n                        sy = j;\n                    } else if (map[i][j] == 'G') {\n                        gx = i;\n                        gy = j;\n                    }\n                }\n            }\n            \n            int minDist = Integer.MAX_VALUE;\n            int bestAttr = -1;\n            \n            for (int startAttr = 1; startAttr <= 5; startAttr++) {\n                int dist = solve(map, H, W, sx, sy, gx, gy, startAttr);\n                if (dist != -1 && dist < minDist) {\n                    minDist = dist;\n                    bestAttr = startAttr;\n                }\n            }\n            \n            if (bestAttr == -1) {\n                System.out.println(\"NA\");\n            } else {\n                System.out.println(bestAttr + \" \" + minDist);\n            }\n        }\n    }\n    \n    static int solve(char[][] map, int H, int W, int sx, int sy, int gx, int gy, int startAttr) {\n        int targetMask = 0;\n        for (int i = 1; i <= 5; i++) {\n            if (i != startAttr) {\n                targetMask |= (1 << i);\n            }\n        }\n        \n        Queue<State> queue = new LinkedList<>();\n        Map<String, Integer> visited = new HashMap<>();\n        \n        int initialMask = (1 << startAttr);\n        State start = new State(sx, sy, initialMask, 0);\n        queue.offer(start);\n        visited.put(sx + \",\" + sy + \",\" + initialMask, 0);\n        \n        while (!queue.isEmpty()) {\n            State curr = queue.poll();\n            \n            if (curr.x == gx && curr.y == gy && (curr.mask & targetMask) == targetMask) {\n                return curr.dist;\n            }\n            \n            for (int d = 0; d < 4; d++) {\n                int nx = curr.x + dx[d];\n                int ny = curr.y + dy[d];\n                \n                if (nx < 0 || nx >= H || ny < 0 || ny >= W) continue;\n                \n                int newMask = curr.mask;\n                char cell = map[nx][ny];\n                \n                if (cell >= '1' && cell <= '5') {\n                    int attr = cell - '0';\n                    if (canCatch(curr.mask, attr)) {\n                        newMask |= (1 << attr);\n                    }\n                }\n                \n                String key = nx + \",\" + ny + \",\" + newMask;\n                if (!visited.containsKey(key) || visited.get(key) > curr.dist + 1) {\n                    visited.put(key, curr.dist + 1);\n                    queue.offer(new State(nx, ny, newMask, curr.dist + 1));\n                }\n            }\n        }\n        \n        return -1;\n    }\n    \n    static boolean canCatch(int mask, int target) {\n        int[] catchMap = {0, 2, 3, 4, 5, 1}; // 1->2, 2->3, 3->4, 4->5, 5->1\n        for (int i = 1; i <= 5; i++) {\n            if ((mask & (1 << i)) != 0 && catchMap[i] == target) {\n                return true;\n            }\n        }\n        return false;\n    }\n    \n    static class State {\n        int x, y, mask, dist;\n        \n        State(int x, int y, int mask, int dist) {\n            this.x = x;\n            this.y = y;\n            this.mask = mask;\n            this.dist = dist;\n        }\n    }\n}\n", "perturbed_sampled": [" class Main { static int[] dx = {0, 0, 1, -1}; static int[]  main(String[] args) throws IOException { BufferedReader br = new BufferedReader(new   int W   new char[H][W];  = -1, gx  0; i < H;  br.readLine(); for (int j = 0; j < W;  if (map[i][j] ==  sy = j; }  { gx = i;  } int minDist =  for (int   startAttr); if (dist  minDist) { minDist = dist; bestAttr  (bestAttr == -1) { System.out.println(\"NA\");  H, int W,   i);  + \",\" + sy +  (!queue.isEmpty()) { State  & targetMask) == targetMask) { return  = 0; d < 4; d++)  + dx[d]; int   nx >= H || ny  W) continue; int  = map[nx][ny]; if (cell >= '1' &&  attr = cell  { newMask  } String key = nx  \",\" + newMask; if (!visited.containsKey(key) || visited.get(key) >   1)); } } } return -1; }  target) { int[] catchMap = {0,  // 1->2, 2->3, 3->4, 4->5, 5->1  {  i)) !=  { return true; } } return false; } static class State { int x, y, mask,  int mask, int dist) {  this.dist = dist; } } }"], "perturbed_original": ["import java.awt.Point; import java.io.BufferedReader; import java.io.IOException; import java.io.InputStreamReader; <extra_id_8>= clucCost(i,<extra_id_9>; if (inArray )<extra_id_10>length; ????\u00a7??????? */ static final String WHITE_SPACE = \"  int  = 0; /** ??????????????\u00b0 */ static int  = new ArrayList<Point>();  visited  = new int[5003]; /** ??????????????????  0; /** ??\u00b4???????????? */ static int goalIdx =  * @throws  main(String[]  BufferedReader  mapSizeLine = new String[2];  = br.readLine().split(WHITE_SPACE);  Integer.parseInt(mapSizeLine[1]); if   <= 5; type++) { // ??????????????????????????\u00a2??????????????????????????????????????????????\u00b4\u00a2 int   0) { output.x   if (output.y  else { System.out.println(output.x  } } /** * ????????????????????????????????? * @param scanner   throws IOException { // ??????????????\u00b1???????????? pachimonList.removeAll(pachimonList); maxNode  for (int  mapSizeY; i++)  0; j < mapSizeX; j++) { int val = convertInt(br.read()); if (val <   pachimonList.size(); if (val ==  calcIndex(j, i))); } } // ????????????????\u00a3???\u00b0??? br.readLine(); } maxNode = pachimonList.size(); } /** * ??\u00a2????????????????????????int?????????????????? * @param target ????\u00b1?????????? * @return ??????????????? */  (target == 71)  53) return target -  * Y????????????????????????????????????????\u00b4? * @param type ?????????????????\u00b4?????????????????\u00a2???????\u00b1???\u00a7  @return */  5) return 1; return currentType + 1; } /**  ??????????????????????????\u00a2???????\u00b1???\u00a7  1)  ??\u00a3??\\??????????\u00a8?????????????????????????????????\u00b4???????????\u00a7???<br>   i =  {  false; } // ??????????????\u00b0????????\u00a7???????????????0 cost[startIdx]  // ?\u00a8?????????????????????????????????\u00a7?????????????????????????\u00b1??????? int node = minIndex(cost, visited); if (node <  // ??\u00a2?\u00b4\u00a2???????????????????????????????????\u00b0????????????  if (isLinked(node, j, firstType) && !visited[j]) {  if (nextNodeCost < cost[j]) { cost[j] = nextNodeCost; } } } }  @param node ?????\u00a8???????????? *  ?????\\?????? */ private static boolean isLinked(int node,  int currentType = pachimonList.get(node).x; int  if (currentType == firstType)  (targetType == firstType) return false; // ??????????????\u00b4???????????\u00b4????????\\?\u00b6?????????????????????????????????? if (currentType == maxNode)  targetType  (currentType == getEndType(firstType)) return targetType == 6; return    -1; for (int i =  (!visited[i]  = i; } return   @param sy  * @param gy ??\u00b4?????????Y??\u00a7?\u00a8? * @param nextType ?\u00ac????????????????????????\u00a2????\u00b1???\u00a7 */ private static int clucCost(Point from, Point   = to.y % mapSizeY; return Math.abs(tx - fx) +   x X??\u00a7?\u00a8? * @param y Y??\u00a7?\u00a8? *  { return x  }"], "original_ll": -1.0931262969970703, "sampled_ll": -0.43971604108810425, "all_perturbed_sampled_ll": [-3.080535650253296], "all_perturbed_original_ll": [-3.0642004013061523], "perturbed_sampled_ll": -3.080535650253296, "perturbed_original_ll": -3.0642004013061523, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "from itertools import product\n# from line_profiler import LineProfiler\ndef main():\n    while(True):\n        W, H = map(int,input().split())\n        if not W: break\n        # ma = [[-1]*(W+2) for _ in range(H+2)]\n        ps = [[] for _ in range(5)]\n        ans = 10**10\n        for i in range(H):\n            for j,a in enumerate(input()):\n                if a == \"S\": ss = [[i,j]]\n                elif a == \"G\": gg = [[i,j]]\n                elif a != \".\": ps[int(a)-1].append([i,j])\n        # if [1 for i in range(5) if len(ps[i])==0]:\n        #     print(\"NA\"); continue\n        # print(ps)\n        B = float(\"inf\")\n        Bi = -1\n        for mon1 in range(5):\n            dp = [[float(\"inf\")]*1000 for _ in range(5)]\n            cand = [[0,ss[0][0],ss[0][1]]]\n            for mon2 in range(5):\n                dpCacheNow = dp[mon2]\n                dpCacheNxt = dp[(mon1+mon2+1)%5]\n                dpCacheNow[0] = 0\n                nxt = ps[(mon1+mon2+1)%5] if mon2<4 else gg\n                # print(nxt)\n                # print(cand)\n                tmp = []\n                for i,[ty,tx] in enumerate(nxt):\n                    # if dpCacheNow[i] >= B:\n                    #     continue\n                    tc = float(\"inf\")\n                    # for cc,cy,cx in cand:\n                    for cc,cy,cx in cand:\n                        if cc > B:\n                            # print(\"a\",end=\"\")\n                            tc = float(\"inf\")\n                            break\n                        else:\n                            tc = min(tc,abs(ty-cy)+abs(tx-cx)+cc)\n                    tmp.append([tc,ty,tx])\n                    dpCacheNxt[i] = min(dpCacheNxt[i],tc)\n                cand = tmp\n            if cand[0][0] < B:\n                B = cand[0][0]\n                Bi = mon1\n        if(Bi == -1):\n            print(\"NA\")\n        else:\n            print(\"%d %d\"%(Bi+1,B))\n        # for mon1 in range(5):\n        #     mon2 = (mon1+1)%5\n        #     dp = [[10**10]*1000 for _ in range(5)]\n        #     for i,yx in enumerate(ps[mon2]):\n        #         dp[mon2][i] = abs(ss[0]-yx[0])+abs(ss[1]-yx[1])\n        #     mon3 = mon2\n        #     for mon3 in range(mon2,mon2+3):\n        #         mon3 = mon3%5\n        #         mon4 = (mon3+1)%5\n        #         for [i,yx],[j,nyx] in product(enumerate(ps[mon3]),enumerate(ps[mon4])):\n        #             dp[mon4][j] = min(dp[mon4][j],dp[mon3][i]+abs(yx[0]-nyx[0])+abs(yx[1]-nyx[1]))\n        #     mon5 = (mon1-1)%5\n        #     for i,yx in enumerate(ps[mon5]):\n        #         d = dp[mon5][i] + abs(gg[0]-yx[0])+abs(gg[1]-yx[1])\n        #         if ans > d:\n        #             ans,ansi = d,mon1\n        # print(ansi+1,ans)\n\nif __name__ == \"__main__\":\n    # prf = LineProfiler()\n    # prf.add_function(main)\n    # prf.runcall(main)\n    # prf.print_stats()\n    main()\n", "sampled": "from collections import deque\nimport sys\n\ndef bfs(grid, start, H, W):\n    \"\"\"BFS to find shortest distances from start to all positions\"\"\"\n    dist = [[-1] * W for _ in range(H)]\n    queue = deque([start])\n    dist[start[0]][start[1]] = 0\n    \n    while queue:\n        r, c = queue.popleft()\n        for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            nr, nc = r + dr, c + dc\n            if 0 <= nr < H and 0 <= nc < W and dist[nr][nc] == -1:\n                dist[nr][nc] = dist[r][c] + 1\n                queue.append((nr, nc))\n    \n    return dist\n\ndef solve(W, H, grid):\n    # Find S and G positions\n    start = goal = None\n    creatures = {1: [], 2: [], 3: [], 4: [], 5: []}\n    \n    for i in range(H):\n        for j in range(W):\n            if grid[i][j] == 'S':\n                start = (i, j)\n            elif grid[i][j] == 'G':\n                goal = (i, j)\n            elif grid[i][j] in '12345':\n                creatures[int(grid[i][j])].append((i, j))\n    \n    # can_catch[attr] gives which attribute attr can catch\n    can_catch = {1: 2, 2: 3, 3: 4, 4: 5, 5: 1}\n    \n    # Compute distances from start and goal\n    dist_from_start = bfs(grid, start, H, W)\n    dist_from_goal = bfs(grid, goal, H, W)\n    \n    # For each creature position, compute distance from start and to goal\n    creature_dists = {}\n    for attr in range(1, 6):\n        creature_dists[attr] = []\n        for pos in creatures[attr]:\n            ds = dist_from_start[pos[0]][pos[1]]\n            dg = dist_from_goal[pos[0]][pos[1]]\n            if ds != -1 and dg != -1:\n                creature_dists[attr].append((ds, dg, pos))\n    \n    best_attr = None\n    best_dist = float('inf')\n    \n    # Try each starting attribute\n    for start_attr in range(1, 6):\n        # Need to catch the other 4 attributes\n        to_catch = [attr for attr in range(1, 6) if attr != start_attr]\n        \n        # Check if we can catch all required attributes\n        can_solve = True\n        for attr in to_catch:\n            if not creature_dists[attr]:\n                can_solve = False\n                break\n        \n        if not can_solve:\n            continue\n        \n        # State: (current_attr, caught_set) where caught_set is a frozenset of caught attributes\n        # We want to find minimum distance to reach goal with all attributes caught\n        \n        # Use Dijkstra-like approach with states\n        from heapq import heappush, heappop\n        \n        initial_state = (start_attr, frozenset([start_attr]))\n        # dist_state[(attr, caught)] = minimum distance to have attr and caught set\n        dist_state = {}\n        dist_state[initial_state] = 0\n        pq = [(0, start_attr, frozenset([start_attr]))]\n        \n        min_dist_to_goal = float('inf')\n        \n        while pq:\n            d, curr_attr, caught = heappop(pq)\n            \n            if d > dist_state.get((curr_attr, caught), float('inf')):\n                continue\n            \n            # Check if we have all attributes and can go to goal\n            if len(caught) == 5:\n                min_dist_to_goal = min(min_dist_to_goal, d + dist_from_goal[start[0]][start[1]])\n                continue\n            \n            # Try to catch next creature\n            next_attr = can_catch[curr_attr]\n            if next_attr not in caught and creature_dists[next_attr]:\n                # Find closest creature of next_attr from current position\n                # We need to track position too...\n                \n                for ds, dg, pos in creature_dists[next_attr]:\n                    new_caught = caught | {next_attr}\n                    new_dist = ds  # Distance from start to this creature\n                    new_state = (next_attr, new_caught)\n                    \n                    if new_dist < dist_state.get(new_state, float('inf')):\n                        dist_state[new_state] = new_dist\n                        heappush(pq, (new_dist, next_attr, new_caught))\n        \n        # This approach is getting complex. Let me try simpler state space.\n        # State: frozenset of caught attributes\n        # For each state, track minimum distance and where we are\n        \n        # Actually, let's use different approach\n        # Try all permutations of catching order and compute minimum\n        \n        from itertools import permutations\n        \n        for order in permutations(to_catch):\n            # Check if this order is valid (can catch in sequence)\n            current_attr = start_attr\n            valid = True\n            for attr in order:\n                if can_catch[current_attr] != attr:\n                    valid = False\n                    break\n                current_attr = attr\n            \n            if not valid:\n                continue\n            \n            # Compute minimum distance for this order\n            total_dist = 0\n            prev_pos = start\n            valid_path = True\n            \n            for attr in order:\n                # Find closest creature of this attribute from prev_pos\n                min_d = float('inf')\n                next_pos = None\n                \n                for pos in creatures[attr]:\n                    # BFS from prev_pos to pos\n                    d = dist_from_start[pos[0]][pos[1]]  # This is wrong, need distance from prev_pos\n                    \n                # This is getting complicated. Need to precompute all distances\n                \n        # Let me use a simpler DP approach with memoization\n        \n    # Simpler approach: try all orderings using DP\n    # Actually the constraints make this feasible\n    \n    # For each starting attribute, do BFS on state space\n    for start_attr in range(1, 6):\n        # BFS on (position, caught_set)\n        initial = (start, frozenset([start_attr]), start_attr)\n        queue = deque([initial])\n        visited = {(start, frozenset([start_attr]), start_attr): 0}\n        \n        while queue:\n            pos, caught, curr_attr = queue.popleft()\n            dist = visited[(pos, caught, curr_attr)]\n            \n            # If we have all 5 attributes and at goal\n            if len(caught) == 5 and pos == goal:\n                if dist < best_dist or (dist == best_dist and start_attr < best_attr):\n                    best_dist = dist\n                    best_attr = start_attr\n                continue\n            \n            # Try moving to adjacent cells\n            for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                nr, nc = pos[0] + dr, pos[1] + dc\n                if 0 <= nr < H and 0 <= nc < W:\n                    new_pos = (nr, nc)\n                    new_caught = caught\n                    new_attr = curr_attr\n                    \n                    # Check if we catch a creature here\n                    cell = grid[nr][nc]\n                    if cell in '12345':\n                        creature_attr = int(cell)\n                        if can_catch[curr_attr] == creature_attr:\n                            new_caught = caught | {creature_attr}\n                            new_attr = creature_attr\n                    \n                    new_state = (new_pos, new_caught, new_attr)\n                    if new_state not in visited or visited[new_state] > dist + 1:\n                        visited[new_state] = dist + 1\n                        queue.append(new_state)\n    \n    if best_attr is None:\n        return \"NA\"\n    else:\n        return f\"{best_attr} {best_dist}\"\n\nwhile True:\n    line = input().split()\n    W, H = int(line[0]), int(line[1])\n    if W == 0 and H == 0:\n        break\n    \n    grid = []\n    for _ in range(H):\n        grid.append(input().strip())\n    \n    print(solve(W, H, grid))\n", "perturbed_sampled": [" sys def bfs(grid,  find shortest    for dr, dc in [(0, 1), (0, -1), (1, 0),  and  and dist[nr][nc] ==  dist def solve(W, H, grid): # Find S and G positions  creatures =  [], 4: [],   if grid[i][j] ==  goal = (i, j) elif grid[i][j] in  gives which attribute attr can catch can_catch =  4, 4:  distances from start   bfs(grid,  distance from  in  ds = dist_from_start[pos[0]][pos[1]] dg = dist_from_goal[pos[0]][pos[1]] if ds != -1 and dg  best_attr = None best_dist = float('inf') # Try each starting attribute for start_attr in  catch the  != start_attr] # Check if we can catch all required attributes  in to_catch: if  continue  caught_set is   goal with all attributes  import heappush, heappop initial_state = (start_attr, frozenset([start_attr])) # dist_state[(attr, caught)] = minimum distance to have attr and caught set dist_state = {}   float('inf')   if len(caught) == 5: min_dist_to_goal = min(min_dist_to_goal, d + dist_from_goal[start[0]][start[1]]) continue # Try to catch next creature next_attr = can_catch[curr_attr] if next_attr  of next_attr from  in creature_dists[next_attr]: new_caught = caught  to this creature new_state = (next_attr, new_caught) if new_dist < dist_state.get(new_state, float('inf')): dist_state[new_state] = new_dist  complex. Let me try  frozenset of caught attributes # For each state,  # Try all  import   in sequence) current_attr  if can_catch[current_attr]  # Compute  creature of this attribute  BFS from  dist_from_start[pos[0]][pos[1]] # This is  #    # Actually the constraints make this feasible # For each starting attribute,  for start_attr in range(1, 6): # BFS on (position, caught_set) initial =   pos,  at goal if len(caught) == 5 and pos ==  and start_attr < best_attr): best_dist = dist best_attr = start_attr continue # Try moving to adjacent cells for dr, dc in  0), (-1, 0)]: nr, nc = pos[0] + dr, pos[1] + dc if 0 <= nr < H and 0  = (nr,  =  = int(cell) if can_catch[curr_attr]   new_state = (new_pos, new_caught, new_attr) if new_state not in visited  1: visited[new_state] = dist + 1 queue.append(new_state) if best_attr   for  H, grid))"], "perturbed_original": ["from  line_profiler import  H  break # ma = [[-1]*(W+2) for _ in range(H+2)] ps = [[] for _ in range(5)] ans =  for j,a in enumerate(input()): if a == \"S\": ss = [[i,j]]  in range(5) if len(ps[i])==0]: # print(\"NA\"); continue # print(ps) B = float(\"inf\") Bi = -1  = [[float(\"inf\")]*1000 for _ in range(5)] cand = [[0,ss[0][0],ss[0][1]]]  = dp[mon2]  # continue tc  in cand:  cc > B:  break else: tc = min(tc,abs(ty-cy)+abs(tx-cx)+cc)  if(Bi == -1):  # mon2  in enumerate(ps[mon2]):    dp[mon4][j] = min(dp[mon4][j],dp[mon3][i]+abs(yx[0]-nyx[0])+abs(yx[1]-nyx[1])) # mon5 =  enumerate(ps[mon5]):  > d: # ans,ansi = d,mon1  \"__main__\": # prf = LineProfiler() # prf.add_function(main) # prf.runcall(main) # prf.print_stats() main()"], "original_ll": -1.1454944610595703, "sampled_ll": -0.9636845588684082, "all_perturbed_sampled_ll": [-2.987633228302002], "all_perturbed_original_ll": [-2.8290181159973145], "perturbed_sampled_ll": -2.987633228302002, "perturbed_original_ll": -2.8290181159973145, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "#include<stdio.h>\nint main(void)\n{\n\t\tint n,t,i,k,j,g,s,r,a,w,z,o;\n\twhile(1)\t{\n\t\tscanf(\"%d\",&t);\n\t\tif(t==-1)\tbreak;\n\t\tif(10>=t){\n\t\t\tprintf(\"3130\\n\");\n\t\t\t}\n\t\tif(t>10&&t<20){\n\t\t\tn=t-10;\n\t\t\ti=4280-(n*125+1150);\n\t\t\tprintf(\"%d\\n\",i);\n\t\t\t}\n\t\tif(t>20&&t<30){\n\t\t\tk=t-20;\n\t\t\tj=4280-((k*140)+2400);\n\t\t\tprintf(\"%d\\n\",j);\n\t\t}\n\t\tif(t>30){\n\t\t\ts=t-30;\n\t\t\tg=4280-((s*160)+3800);\n\t\t\tprintf(\"%d\\n\",g);\n\t\t}\t\n\t}\n\treturn 0;\n}", "sampled": "#include <stdio.h>\n\nint calculate_bill(int w) {\n    int bill = 1150; // base charge\n    \n    if (w <= 10) {\n        return bill;\n    }\n    \n    if (w <= 20) {\n        bill += (w - 10) * 125;\n        return bill;\n    }\n    \n    bill += 10 * 125;\n    \n    if (w <= 30) {\n        bill += (w - 20) * 140;\n        return bill;\n    }\n    \n    bill += 10 * 140;\n    bill += (w - 30) * 160;\n    \n    return bill;\n}\n\nint main() {\n    int w;\n    int last_month = 4280;\n    \n    while (1) {\n        scanf(\"%d\", &w);\n        if (w == -1) break;\n        \n        int current_bill = calculate_bill(w);\n        int savings = last_month - current_bill;\n        \n        printf(\"%d\\n\", savings);\n    }\n    \n    return 0;\n}\n", "perturbed_sampled": ["#include  int bill =  (w <=  if (w <=  - 10) * 125; return bill; } bill += 10  (w  bill; } bill  += (w - 30) * 160; return bill;  w;  break;  savings = last_month - current_bill;  }"], "perturbed_original": ["#include<stdio.h> int  { scanf(\"%d\",&t); if(t==-1) break; if(10>=t){  printf(\"%d\\n\",i);  printf(\"%d\\n\",g); } } return 0; }"], "original_ll": -1.2676897048950195, "sampled_ll": -0.8720086216926575, "all_perturbed_sampled_ll": [-3.34555721282959], "all_perturbed_original_ll": [-2.315281391143799], "perturbed_sampled_ll": -3.34555721282959, "perturbed_original_ll": -2.315281391143799, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import java.util.*;\npublic class Main {\n    static Scanner kbd = new Scanner(System.in);\n    public static void main(String[] args){\n\twhile(kbd.hasNext()) {\n\t    int w = kbd.nextInt();\n\t    if(w!=-1){\n\t\tSystem.out.println(4280-solve(w));\n\t    }\n\t}\n    }\n\n    static int solve(int w) {\n\tint r = 0;\n\tint bill = 0;\n\twhile(w>=0){\n\t    bill += cost(w, r);\n\t    w -= 10;\n\t    r ++;\n\t    //System.out.println(\"p\");\n\t}\n\treturn bill;\n    }\n\n    static int cost(int w, int r){\n\tif(r==0){ return 1150; }\n\telse if(r==1){ \n\t    if(w>=10) return 125*10;\n\t    else return 125*w;\n\t}\n\telse if(r==2){\n\t    if(w>=10) return 140*10;\n\t    else return 140*w;\n\t}\n\telse if(r>2){\n\t    if(w>=10) return 160*10;\n\t    else return 160*w;\n\t}\n\telse return 0;\n    }\n}", "sampled": "import java.util.Scanner;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        \n        while (true) {\n            int w = sc.nextInt();\n            if (w == -1) break;\n            \n            int currentBill = calculateBill(w);\n            int difference = 4280 - currentBill;\n            System.out.println(difference);\n        }\n        \n        sc.close();\n    }\n    \n    static int calculateBill(int w) {\n        int bill = 1150; // Base charge\n        \n        if (w <= 10) {\n            return bill;\n        }\n        \n        // Second tier: 10 < w <= 20\n        if (w <= 20) {\n            bill += (w - 10) * 125;\n            return bill;\n        }\n        \n        bill += 10 * 125; // Full second tier\n        \n        // Third tier: 20 < w <= 30\n        if (w <= 30) {\n            bill += (w - 20) * 140;\n            return bill;\n        }\n        \n        bill += 10 * 140; // Full third tier\n        \n        // Fourth tier: w > 30\n        bill += (w - 30) * 160;\n        \n        return bill;\n    }\n}\n", "perturbed_sampled": ["import java.util.Scanner; public class Main { public static void main(String[] args) { Scanner   -1)  - currentBill; System.out.println(difference); } sc.close(); } static  <=    tier: 20 < w <= 30 if (w <= 30) { bill += (w - 20) * 140;  10 * 140; // Full third tier // Fourth tier:  (w  bill; } }"], "perturbed_original": ["import java.util.*;  Scanner   bill = 0; while(w>=0){ bill += cost(w, r); w -= 10; r  } static  if(r==0){ return   } else if(r==2){ if(w>=10) return 140*10; else  if(w>=10) return 160*10; else return 160*w; } else return 0; } }"], "original_ll": -1.0966719388961792, "sampled_ll": -0.7214460968971252, "all_perturbed_sampled_ll": [-3.0955910682678223], "all_perturbed_original_ll": [-2.4004297256469727], "perturbed_sampled_ll": -3.0955910682678223, "perturbed_original_ll": -2.4004297256469727, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "def fee(w):\n    if w>30:\n        return (w-30)*160+10*140+10*125+1150\n    if w>20:\n        return (w-20)*140+10*125+1150\n    if w>10:\n        return (w-10)*125+1150\n    return 1150\n\nprev_m=4280\nwhile True:\n    W=int(input())\n    if W==-1:\n        break\n    print(prev_m-fee(W))\n    # prev_m=fee(W)\n\n", "sampled": "def calculate_water_bill(w):\n    if w <= 10:\n        return 1150\n    elif w <= 20:\n        return 1150 + (w - 10) * 125\n    elif w <= 30:\n        return 1150 + 10 * 125 + (w - 20) * 140\n    else:\n        return 1150 + 10 * 125 + 10 * 140 + (w - 30) * 160\n\nlast_month_bill = 4280\n\nwhile True:\n    w = int(input())\n    if w == -1:\n        break\n    \n    current_bill = calculate_water_bill(w)\n    savings = last_month_bill - current_bill\n    print(savings)\n", "perturbed_sampled": ["def calculate_water_bill(w): if w <= 10: return   return 1150 + 10 * 125 + 10 *  * 160  w =  break current_bill = calculate_water_bill(w) savings = last_month_bill - current_bill print(savings)"], "perturbed_original": ["def fee(w):   return (w-10)*125+1150  W=int(input()) if W==-1: break print(prev_m-fee(W)) # prev_m=fee(W)"], "original_ll": -1.2482658624649048, "sampled_ll": -0.8674608469009399, "all_perturbed_sampled_ll": [-2.6803579330444336], "all_perturbed_original_ll": [-3.314685583114624], "perturbed_sampled_ll": -2.6803579330444336, "perturbed_original_ll": -3.314685583114624, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "#include<stdio.h>\nint main()\n{\n\tint i,a,b,c,d,max=0,s=0;\n\tscanf(\"%d\",&a);\n\twhile(a!=0){\n\t\ts=0;\nmax=0;\n\tfor(i=0;i<a;i++){\n\t\tscanf(\"%d %d %d\",&b,&c,&d);\n\t\tc=c+d;\n\t\tif(max<c){\n\t\t\tmax=c;\n\t\t\ts=b;\n\t\t}\n\t}\n\t\n\tprintf(\"%d %d\\n\",s,max);\n\tscanf(\"%d\",&a);\n\t}\n\treturn 0;\n}", "sampled": "#include <stdio.h>\n\nint main() {\n    int n;\n    \n    while(1) {\n        scanf(\"%d\", &n);\n        if(n == 0) break;\n        \n        int max_id = 0;\n        int max_distance = -1;\n        \n        for(int i = 0; i < n; i++) {\n            int p, d1, d2;\n            scanf(\"%d %d %d\", &p, &d1, &d2);\n            int total = d1 + d2;\n            \n            if(total > max_distance) {\n                max_distance = total;\n                max_id = p;\n            }\n        }\n        \n        printf(\"%d %d\\n\", max_id, max_distance);\n    }\n    \n    return 0;\n}\n", "perturbed_sampled": ["#include <stdio.h> int main() { int  for(int i = 0; i  p, d1,  &d1, &d2);   max_distance = total;  printf(\"%d %d\\n\", max_id, max_distance); } return 0; }"], "perturbed_original": ["#include<stdio.h> int  while(a!=0){ s=0; max=0; for(i=0;i<a;i++){ scanf(\"%d %d %d\",&b,&c,&d);  } return 0; }"], "original_ll": -1.0832152366638184, "sampled_ll": -0.6275161504745483, "all_perturbed_sampled_ll": [-2.7119405269622803], "all_perturbed_original_ll": [-2.4660072326660156], "perturbed_sampled_ll": -2.7119405269622803, "perturbed_original_ll": -2.4660072326660156, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.Iterator;\n\n\npublic class Main {\n\n\tprivate BufferedReader reader = new BufferedReader(new InputStreamReader(System.in), 1);\n\n\tprivate String inputData = null;\n\n\tpublic String[] data = null;\n\n\tpublic int num = 0;\n\n\tpublic int count = 0;\n\n\tpublic HashMap<Integer, Integer> humanData = new HashMap<Integer, Integer>();\n\n\tpublic ArrayList<Integer> topId = new ArrayList<Integer>();\n\n\tpublic ArrayList<Integer> topLength = new ArrayList<Integer>();\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().start();\n\t\tSystem.exit(0);\n\t}\n\n\tpublic void start() {\n\t\twhile (true) {\n\t\t\ttry {\n\t\t\t\tthis.inputData = reader.readLine();\n\t\t\t} catch (IOException e) {\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\n\t\t\tthis.data = this.inputData.split(\" \");\n\n\t\t\tif (this.data.length == 1) {\n\t\t\t\tif (this.data[0].equals(\"0\")) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tthis.num = Integer.parseInt(this.data[0]);\n\t\t\t}\n\n\t\t\tthis.humanData.clear();\n\n\t\t\tfor (int i = 0; i < this.num; i++) {\n\t\t\t\ttry {\n\t\t\t\t\tthis.inputData = reader.readLine();\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\te.printStackTrace();\n\t\t\t\t}\n\t\t\t\tthis.data = this.inputData.split(\" \");\n\n\t\t\t\tthis.humanData.put(Integer.parseInt(data[0]),\n\t\t\t\t\t\tInteger.parseInt(data[1]) + Integer.parseInt(data[2]));\n\n\t\t\t}\n\n\t\t\tIterator<Integer> itId = this.humanData.keySet().iterator();\n\t\t\tint numCount = 0;\n\t\t\twhile (itId.hasNext()) {\n\t\t\t\tint id = itId.next();\n\t\t\t\tif (numCount == 0) {\n\t\t\t\t\tthis.topId.add(id);\n\t\t\t\t\tthis.topLength.add(this.humanData.get(id));\n\t\t\t\t} else {\n\t\t\t\t\tif (this.topLength.get(count) <= this.humanData.get(id)) {\n\t\t\t\t\t\tthis.topId.set(this.count, id);\n\t\t\t\t\t\tthis.topLength.set(this.count, this.humanData.get(id));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tnumCount++;\n\t\t\t}\n\n\t\t\tthis.count++;\n\n\t\t}\n\n\t\tfor (int i = 0; i < this.topId.size(); i++) {\n\t\t\tSystem.out.println(this.topId.get(i) + \" \" + this.topLength.get(i));\n\t\t}\n\n\t}\n\n}", "sampled": "import java.util.Scanner;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        \n        while (true) {\n            int n = sc.nextInt();\n            if (n == 0) break;\n            \n            int maxPatient = 0;\n            int maxDistance = 0;\n            \n            for (int i = 0; i < n; i++) {\n                int p = sc.nextInt();\n                int d1 = sc.nextInt();\n                int d2 = sc.nextInt();\n                int total = d1 + d2;\n                \n                if (total > maxDistance) {\n                    maxDistance = total;\n                    maxPatient = p;\n                }\n            }\n            \n            System.out.println(maxPatient + \" \" + maxDistance);\n        }\n        \n        sc.close();\n    }\n}\n", "perturbed_sampled": [" {    int  = 0; for (int i = 0; i  p = sc.nextInt(); int d1 = sc.nextInt(); int d2 =  = total; maxPatient = p; } } System.out.println(maxPatient  } sc.close(); } }"], "perturbed_original": ["import java.io.BufferedReader; import java.io.IOException; import java.io.InputStreamReader; + this.humanData[i]; }<extra_id_4>0) { i =<extra_id_5>i++.value; } return this.humanData[i][0]; }<extra_id_6>itId.hasNext()) { numCount++; }<extra_id_7>== 99) { numCount++)<extra_id_8>. currentLine ( ) ;<extra_id_9>}<extra_id_10>if ((null == java.util.Iterator; public class  = new BufferedReader(new  =  null; public  public HashMap<Integer, Integer> humanData  ArrayList<Integer> topId = new ArrayList<Integer>();    reader.readLine(); } catch (IOException  = this.inputData.split(\" \"); if (this.data.length ==  break;  this.humanData.clear(); for (int i   (IOException e) { e.printStackTrace(); }  Integer.parseInt(data[1]) + Integer.parseInt(data[2])); } Iterator<Integer> itId = this.humanData.keySet().iterator(); int numCount = 0; while (itId.hasNext()) { int  == 0) {  { this.topId.set(this.count, id); this.topLength.set(this.count,  + this.topLength.get(i)); } } }"], "original_ll": -0.6698124408721924, "sampled_ll": -0.5245659947395325, "all_perturbed_sampled_ll": [-3.06538462638855], "all_perturbed_original_ll": [-2.842935800552368], "perturbed_sampled_ll": -3.06538462638855, "perturbed_original_ll": -2.842935800552368, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "while True:\n    n = int(input())\n    if n == 0:\n        break\n\n    patients = []\n    for _ in range(n):\n        p, d1, d2 = map(int, input().split())\n        patients.append((p, d1+d2))\n    print(*max(patients, key=lambda x: x[1]))", "sampled": "while True:\n    n = int(input())\n    if n == 0:\n        break\n    \n    max_distance = -1\n    max_patient = -1\n    \n    for _ in range(n):\n        data = list(map(int, input().split()))\n        patient_id = data[0]\n        d1 = data[1]\n        d2 = data[2]\n        total_distance = d1 + d2\n        \n        if total_distance > max_distance:\n            max_distance = total_distance\n            max_patient = patient_id\n    \n    print(max_patient, max_distance)\n", "perturbed_sampled": ["while True: n = int(input()) if n == 0: break  d1 + d2  = total_distance max_patient = patient_id print(max_patient, max_distance)"], "perturbed_original": ["while  d1, d2 = map(int, input().split()) patients.append((p, d1+d2)) print(*max(patients, key=lambda x: x[1]))"], "original_ll": -1.1281121969223022, "sampled_ll": -0.8109328746795654, "all_perturbed_sampled_ll": [-3.309577465057373], "all_perturbed_original_ll": [-2.6311604976654053], "perturbed_sampled_ll": -3.309577465057373, "perturbed_original_ll": -2.6311604976654053, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "m,e,j,s;main(n){for(;scanf(\"%d\",&n)*n;)for(;n--;puts(m>99|e>99|j>99|m+e>179|s>239?\"A\":s>209||s>149&&m>79|e>79?\"B\":\"C\"))scanf(\"%d%d%d\",&m,&e,&j),s=m+e+j;}", "sampled": "#include <stdio.h>\n\nint main() {\n    int n;\n    \n    while(1) {\n        scanf(\"%d\", &n);\n        if(n == 0) break;\n        \n        for(int i = 0; i < n; i++) {\n            int pm, pe, pj;\n            scanf(\"%d %d %d\", &pm, &pe, &pj);\n            \n            char cls = 'C';\n            \n            // Check conditions for A class\n            if(pm == 100 || pe == 100 || pj == 100) {\n                cls = 'A';\n            }\n            else if((pm + pe) / 2.0 >= 90) {\n                cls = 'A';\n            }\n            else if((pm + pe + pj) / 3.0 >= 80) {\n                cls = 'A';\n            }\n            // Check conditions for B class\n            else if((pm + pe + pj) / 3.0 >= 70) {\n                cls = 'B';\n            }\n            else if((pm + pe + pj) / 3.0 >= 50 && (pm >= 80 || pe >= 80)) {\n                cls = 'B';\n            }\n            \n            printf(\"%c\\n\", cls);\n        }\n    }\n    \n    return 0;\n}\n", "perturbed_sampled": ["#include  n;  <  pe, pj;  'C'; // Check conditions for A class if(pm == 100 || pe  'A'; } else  = 'A';  >= 80)  // Check conditions  +  >= 70)  else if((pm + pe + pj) / 3.0 >=  { cls = 'B'; } printf(\"%c\\n\", cls); } } return 0; }"], "perturbed_original": ["m,e,j,s;main(n){for(;scanf(\"%d\",&n)*n;)for(;n--;puts(m>99|e>99|j>99|m+e>179|s>239?\"A\":s>209||s>149&&m>79|e>79?\"B\":\"C\"))scanf(\"%d%d%d\",&m,&e,&j),s=m+e+j;}"], "original_ll": -2.6041934490203857, "sampled_ll": -0.7207226157188416, "all_perturbed_sampled_ll": [-3.723554849624634], "all_perturbed_original_ll": [-2.6041934490203857], "perturbed_sampled_ll": -3.723554849624634, "perturbed_original_ll": -2.6041934490203857, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import java.util.*;\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tScanner sc=new Scanner(System.in);\n\t\twhile(true){\n\t\t\tint n=sc.nextInt();\n\t\t\tif(n==0)break;\n\t\t\tchar c[]=new char[n];\n\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\tint pm=sc.nextInt();\n\t\t\t\tint pe=sc.nextInt();\n\t\t\t\tint pj=sc.nextInt();\n\t\t\t\tif(pm==100||pe==100||pj==100)c[i]='A';\n\t\t\t\telse if((pm+pe)/2>=90)c[i]='A';\n\t\t\t\telse if((pm+pe+pj)/3>=80)c[i]='A';\n\t\t\t\telse if((pm+pe+pj)/3>=70)c[i]='B';\n\t\t\t\telse if((pm+pe+pj)/3>=50&&(pm>=80||pe>=80))c[i]='B';\n\t\t\t\telse c[i]='C';\n\t\t\t\tSystem.out.println(c[i]);\n\t\t\t}\n\t\t}\n\t}\n}", "sampled": "import java.util.Scanner;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        \n        while (true) {\n            int n = sc.nextInt();\n            if (n == 0) break;\n            \n            for (int i = 0; i < n; i++) {\n                int pm = sc.nextInt();\n                int pe = sc.nextInt();\n                int pj = sc.nextInt();\n                \n                String cls = getClass(pm, pe, pj);\n                System.out.println(cls);\n            }\n        }\n        \n        sc.close();\n    }\n    \n    static String getClass(int pm, int pe, int pj) {\n        // Check for class A conditions\n        if (pm == 100 || pe == 100 || pj == 100) {\n            return \"A\";\n        }\n        \n        double mathEngAvg = (pm + pe) / 2.0;\n        if (mathEngAvg >= 90) {\n            return \"A\";\n        }\n        \n        double threeAvg = (pm + pe + pj) / 3.0;\n        if (threeAvg >= 80) {\n            return \"A\";\n        }\n        \n        // Check for class B conditions\n        if (threeAvg >= 70) {\n            return \"B\";\n        }\n        \n        if (threeAvg >= 50 && (pm >= 80 || pe >= 80)) {\n            return \"B\";\n        }\n        \n        // Otherwise class C\n        return \"C\";\n    }\n}\n", "perturbed_sampled": ["import java.util.Scanner; public class Main   0)  0; i < n; i++)  int   }  getClass(int pm,  A conditions if (pm == 100 || pe == 100 || pj  } double mathEngAvg = (pm + pe)   + pe + pj) / 3.0; if (threeAvg  (threeAvg >= 70)  (threeAvg >= 50  pe >= 80)) { return \"B\"; } //  } }"], "perturbed_original": ["import java.util.*; public  void main(String[] args) { Scanner sc=new Scanner(System.in);   pm=sc.nextInt(); int pe=sc.nextInt();  else if((pm+pe+pj)/3>=50&&(pm>=80||pe>=80))c[i]='B'; else  }"], "original_ll": -0.8382114768028259, "sampled_ll": -0.7714477181434631, "all_perturbed_sampled_ll": [-3.3074281215667725], "all_perturbed_original_ll": [-2.8665943145751953], "perturbed_sampled_ll": -3.3074281215667725, "perturbed_original_ll": -2.8665943145751953, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "while 1:\n    n = int(input())\n    if n == 0: break\n    i = 0\n    while True:\n        if i == n: break\n        m, e, j = map(int, input().split())\n        sum = m + e + j\n        if m==100 or e==100 or j==100:\n            print(\"A\")\n        elif (m+e)/2 >= 90:\n            print(\"A\")\n        elif sum/3 >= 80:\n            print(\"A\")\n        elif sum/3 >= 70:\n            print(\"B\")\n        elif sum/3 >= 50 and m >= 80 or e >= 80:\n            print(\"B\")\n        else:\n            print(\"C\")\n        i += 1\n    \n", "sampled": "while True:\n    n = int(input())\n    if n == 0:\n        break\n    \n    for _ in range(n):\n        pm, pe, pj = map(int, input().split())\n        \n        # Check conditions for class A\n        if pm == 100 or pe == 100 or pj == 100:\n            print(\"A\")\n            continue\n        \n        if (pm + pe) / 2 >= 90:\n            print(\"A\")\n            continue\n        \n        if (pm + pe + pj) / 3 >= 80:\n            print(\"A\")\n            continue\n        \n        # Check conditions for class B\n        if (pm + pe + pj) / 3 >= 70:\n            print(\"B\")\n            continue\n        \n        if (pm + pe + pj) / 3 >= 50 and (pm >= 80 or pe >= 80):\n            print(\"B\")\n            continue\n        \n        # Otherwise class C\n        print(\"C\")\n", "perturbed_sampled": ["while True:  pe, pj  if pm == 100 or pe == 100 or pj == 100: print(\"A\")  / 2  pj)  continue  continue if (pm + pe + pj) / 3 >= 50 and (pm >= 80 or  # Otherwise class C print(\"C\")"], "perturbed_original": ["while <extra_id_12>}<extra_id_13>3 { switch ( t<extra_id_14>{ case 99 : throw<extra_id_15>else<extra_id_16>\"Unknown type\" :<extra_id_17>= 1: break i: break<extra_id_18>.<extra_id_19>( )<extra_id_20><=<extra_id_21>n<extra_id_22>] .<extra_id_23>n + 1 ] =<extra_id_24>( m ) ;<extra_id_25>while ( n == 0: break i = 0  n: break m, e, j  m + e + j if m==100  elif  elif  sum/3 >= 50  1"], "original_ll": -1.0176674127578735, "sampled_ll": -0.8166347742080688, "all_perturbed_sampled_ll": [-2.7686991691589355], "all_perturbed_original_ll": [-2.9876320362091064], "perturbed_sampled_ll": -2.7686991691589355, "perturbed_original_ll": -2.9876320362091064, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "#include <stdio.h>\n\nint main()\n{\n    int n;\n    int c;\n\n    while (scanf(\"%d\", &n), n != 0) {\n        int cnt[10] = {};\n\n        for (int i = 0; i < n; i++) {\n            scanf(\"%d\", &c);\n\n            cnt[c]++;\n        }\n\n        for (int i = 0; i < 10; i++) {\n            if (cnt[i] == 0) {\n                putchar('-');\n            }\n            else {\n                for (int j = 0; j < cnt[i]; j++) {\n                    putchar('*');\n                }\n            }\n\n            putchar('\\n');\n        }\n    }\n\n    return 0;\n}\n\n", "sampled": "#include <stdio.h>\n\nint main() {\n    int n;\n    \n    while(scanf(\"%d\", &n) == 1 && n != 0) {\n        int count[10] = {0};\n        \n        for(int i = 0; i < n; i++) {\n            int c;\n            scanf(\"%d\", &c);\n            count[c]++;\n        }\n        \n        for(int i = 0; i < 10; i++) {\n            if(count[i] == 0) {\n                printf(\"-\\n\");\n            } else {\n                for(int j = 0; j < count[i]; j++) {\n                    printf(\"*\");\n                }\n                printf(\"\\n\");\n            }\n        }\n    }\n    \n    return 0;\n}\n", "perturbed_sampled": [" == 1 && n != 0) { int count[10] = {0};   c; scanf(\"%d\", &c); count[c]++;  { printf(\"-\\n\");  = 0; j < count[i];  } } } return 0; }"], "perturbed_original": [" int n; int c; while (scanf(\"%d\", &n), n != 0) { int cnt[10] = {}; for (int i = 0;   0) {    } return 0; }"], "original_ll": -0.6518388986587524, "sampled_ll": -0.4910286068916321, "all_perturbed_sampled_ll": [-2.644564628601074], "all_perturbed_original_ll": [-2.0350592136383057], "perturbed_sampled_ll": -2.644564628601074, "perturbed_original_ll": -2.0350592136383057, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "\nimport java.io.IOException;\nimport java.util.Arrays;\nimport java.util.Scanner;\n\npublic class Main {\n\n\tpublic static void main(String[] args) throws IOException {\n\t\tnew Main().run();\n\t}\n\n\tprivate void run() throws IOException {\n\t\tScanner scanner = new Scanner(System.in);\n\t\twhile (true) {\n\t\t\tint n = scanner.nextInt();\n\t\t\tif (n == 0)\n\t\t\t\tbreak;\n\t\t\tint[] num = new int[10];\n\t\t\twhile(n-->0){\n\t\t\t\tnum[scanner.nextInt()]++;\n\t\t\t}\n\t\t\tfor(int a:num){\n\t\t\t\tif(a==0)\n\t\t\t\t\tSystem.out.println('-');\n\t\t\t\telse{\n\t\t\t\t\tchar[] c = new char[a];\n\t\t\t\t\tArrays.fill(c, '*');\n\t\t\t\t\tSystem.out.println(c);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}", "sampled": "import java.util.Scanner;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        \n        while (true) {\n            int n = sc.nextInt();\n            if (n == 0) break;\n            \n            int[] count = new int[10];\n            \n            for (int i = 0; i < n; i++) {\n                int c = sc.nextInt();\n                count[c]++;\n            }\n            \n            for (int i = 0; i < 10; i++) {\n                if (count[i] == 0) {\n                    System.out.println(\"-\");\n                } else {\n                    for (int j = 0; j < count[i]; j++) {\n                        System.out.print(\"*\");\n                    }\n                    System.out.println();\n                }\n            }\n        }\n        \n        sc.close();\n    }\n}\n", "perturbed_sampled": ["import  public  Scanner sc =  if (n ==  new int[10];  i < n;  sc.nextInt();  10;  0) { System.out.println(\"-\");  < count[i]; j++) { System.out.print(\"*\"); } System.out.println(); } } } sc.close(); } }"], "perturbed_original": [" main(String[]  run() throws IOException { Scanner scanner = new Scanner(System.in); while (true)   int[] num = new int[10]; while(n-->0){ num[scanner.nextInt()]++; } for(int  c = new char[a]; Arrays.fill(c, '*');  }"], "original_ll": -0.8657097816467285, "sampled_ll": -0.3890190124511719, "all_perturbed_sampled_ll": [-3.214872121810913], "all_perturbed_original_ll": [-3.2020812034606934], "perturbed_sampled_ll": -3.214872121810913, "perturbed_original_ll": -3.2020812034606934, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "while True:\n    q={}\n    a=input()\n    if a==0:break\n    for i in range(10): q[i]=0\n    for i in range(a): q[input()]+=1\n    for i in range(10):  print \"*\"*q[i] if q[i] != 0 else \"-\"", "sampled": "while True:\n    n = int(input())\n    if n == 0:\n        break\n    \n    count = [0] * 10\n    for _ in range(n):\n        c = int(input())\n        count[c] += 1\n    \n    for i in range(10):\n        if count[i] == 0:\n            print('-')\n        else:\n            print('*' * count[i])\n", "perturbed_sampled": ["while True:   [0] *  c =  count[i] == 0: print('-') else: print('*' * count[i])"], "perturbed_original": ["while True: q={} a=input() if  range(a): q[input()]+=1 for i in  != 0 else \"-\""], "original_ll": -1.4989075660705566, "sampled_ll": -0.729781448841095, "all_perturbed_sampled_ll": [-3.6544251441955566], "all_perturbed_original_ll": [-4.952922344207764], "perturbed_sampled_ll": -3.6544251441955566, "perturbed_original_ll": -4.952922344207764, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "#include<stdio.h>\nint main(){\n  double n;\n  char a[12];\n  int m,i;\n  while(1){\n    scanf(\"%lf\",&n);\n    if(n<0)break;\n    n*=16;\n    m=n;\n    if(m-n){\n      printf(\"NA\\n\");\n      continue;\n    }\n    for(i=12;i;i--){\n      a[i-1]=m%2+'0';\n      m/=2;\n    }\n    if(m){\n      printf(\"NA\\n\");\n      continue;\n    }\n    for(i=0;i<12;i++){\n      if(i==8)printf(\".\");\n      printf(\"%c\",a[i]);\n    }\n    printf(\"\\n\");\n  }\n  return 0;\n}", "sampled": "#include <stdio.h>\n#include <string.h>\n#include <math.h>\n\nint main() {\n    double n;\n    \n    while (scanf(\"%lf\", &n) == 1) {\n        if (n < 0) break;\n        \n        // Extract integer and fractional parts\n        int int_part = (int)n;\n        double frac_part = n - int_part;\n        \n        // Check if integer part fits in 8 bits\n        if (int_part > 255) {\n            printf(\"NA\\n\");\n            continue;\n        }\n        \n        // Convert integer part to binary (8 bits)\n        char int_binary[9];\n        for (int i = 7; i >= 0; i--) {\n            int_binary[i] = (int_part % 2) + '0';\n            int_part /= 2;\n        }\n        int_binary[8] = '\\0';\n        \n        // Convert fractional part to binary (4 bits)\n        char frac_binary[5];\n        int valid = 1;\n        double temp_frac = frac_part;\n        \n        for (int i = 0; i < 4; i++) {\n            temp_frac *= 2;\n            if (temp_frac >= 1) {\n                frac_binary[i] = '1';\n                temp_frac -= 1;\n            } else {\n                frac_binary[i] = '0';\n            }\n        }\n        frac_binary[4] = '\\0';\n        \n        // Check if there's remaining fractional part\n        temp_frac *= 2;\n        if (temp_frac > 0.0001) {  // Allow small floating point error\n            valid = 0;\n        }\n        \n        // Alternative check: reconstruct the number and compare\n        double reconstructed = 0;\n        int int_val = 0;\n        for (int i = 0; i < 8; i++) {\n            int_val = int_val * 2 + (int_binary[i] - '0');\n        }\n        reconstructed = int_val;\n        \n        double frac_val = 0;\n        for (int i = 0; i < 4; i++) {\n            frac_val = frac_val + (frac_binary[i] - '0') * pow(0.5, i + 1);\n        }\n        reconstructed += frac_val;\n        \n        if (fabs(reconstructed - n) > 0.0001) {\n            valid = 0;\n        }\n        \n        if (valid) {\n            printf(\"%s.%s\\n\", int_binary, frac_binary);\n        } else {\n            printf(\"NA\\n\");\n        }\n    }\n    \n    return 0;\n}\n", "perturbed_sampled": ["#include <stdio.h> #include <string.h>  double n; while (scanf(\"%lf\", &n) == 1) { if (n < 0) break; //  int int_part = (int)n;  integer   printf(\"NA\\n\"); continue; }  int_binary[9]; for (int i = 7; i >= 0;  int_part /= 2;  frac_part; for  < 4; i++) { temp_frac *= 2; if (temp_frac >= 1) { frac_binary[i] = '1'; temp_frac -= 1; } else { frac_binary[i]   there's remaining fractional part temp_frac *= 2; if (temp_frac  small floating point  // Alternative check:     for (int   +=  > 0.0001) { valid  { printf(\"%s.%s\\n\", int_binary, frac_binary); } else { printf(\"NA\\n\"); } } return 0; }"], "perturbed_original": ["#include<stdio.h> int main(){ double n; char a[12];  n*=16; m=n; if(m-n){ printf(\"NA\\n\"); continue; }  printf(\"NA\\n\");  0; }"], "original_ll": -1.1134214401245117, "sampled_ll": -0.6523396372795105, "all_perturbed_sampled_ll": [-2.562866449356079], "all_perturbed_original_ll": [-2.943164348602295], "perturbed_sampled_ll": -2.562866449356079, "perturbed_original_ll": -2.943164348602295, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "/**\n * Problem E: Binary Digit A Doctor Loved\n */\n\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\n\npublic class Main {\n\n\tpublic static void main(String[] args) throws IOException {\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\tString line = \"\";\n\n\t\twhile ((line = br.readLine()) != null && !line.isEmpty()) {\n\n\t\t\tif (line.charAt(0) == '-') {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tint ni;\n\t\t\tdouble nd;\n\t\t\tni = Integer.parseInt(line.substring(0, line.indexOf('.')));\n\t\t\tif (line.indexOf('.') != -1) {\n\t\t\t\tnd = Double.parseDouble(\"0\"\n\t\t\t\t\t\t+ (line.substring(line.indexOf('.')))) * 16;\n\t\t\t} else {\n\t\t\t\tnd = 0.0;\n\t\t\t}\n\t\t\tif (ni > 255 || nd % 1.0 > 0.0) {\n\t\t\t\tSystem.out.println(\"NA\");\n\t\t\t} else {\n\t\t\t\tchar[] si, sd;\n\t\t\t\tsi = new char[8];\n\t\t\t\tsd = new char[4];\n\n\t\t\t\tfor (int i = 7; i >= 0; i--) {\n\t\t\t\t\tif ((ni & (int) (Math.pow(2, i))) != 0) {\n\t\t\t\t\t\tsi[7 - i] = '1';\n\t\t\t\t\t} else {\n\t\t\t\t\t\tsi[7 - i] = '0';\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tfor (int i = 3; i >= 0; i--) {\n\t\t\t\t\tif (((int) nd & (int) (Math.pow(2, i))) != 0) {\n\t\t\t\t\t\tsd[3 - i] = '1';\n\t\t\t\t\t} else {\n\t\t\t\t\t\tsd[3 - i] = '0';\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tSystem.out.println(new String(si) + \".\" + new String(sd));\n\t\t\t}\n\t\t}\n\n\t}\n}", "sampled": "import java.util.Scanner;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        \n        while (sc.hasNext()) {\n            double n = sc.nextDouble();\n            if (n < 0) break;\n            \n            // Split into integer and fractional parts\n            int intPart = (int) n;\n            double fracPart = n - intPart;\n            \n            // Check if integer part fits in 8 bits\n            if (intPart > 255) {\n                System.out.println(\"NA\");\n                continue;\n            }\n            \n            // Convert integer part to binary (8 digits)\n            String intBinary = String.format(\"%8s\", Integer.toBinaryString(intPart)).replace(' ', '0');\n            \n            // Convert fractional part to binary (4 digits)\n            StringBuilder fracBinary = new StringBuilder();\n            boolean valid = true;\n            double temp = fracPart;\n            \n            for (int i = 0; i < 4; i++) {\n                temp *= 2;\n                if (temp >= 1) {\n                    fracBinary.append('1');\n                    temp -= 1;\n                } else {\n                    fracBinary.append('0');\n                }\n            }\n            \n            // Check if there's remaining fractional part\n            if (temp > 1e-9) {\n                valid = false;\n            }\n            \n            if (valid) {\n                System.out.println(intBinary + \".\" + fracBinary.toString());\n            } else {\n                System.out.println(\"NA\");\n            }\n        }\n        \n        sc.close();\n    }\n}\n", "perturbed_sampled": ["import java.util.Scanner;  { Scanner sc = new Scanner(System.in); while (sc.hasNext()) { double n  0) break; // Split into integer  = (int) n; double fracPart  Check   String.format(\"%8s\",  fractional part to  = new StringBuilder(); boolean   = 0; i <  2; if (temp >=  1; } else { fracBinary.append('0'); } } // Check if there's  > 1e-9)  } } sc.close(); } }"], "perturbed_original": ["/** * Problem E: = 0<extra_id_3>; if ((int) java.io.IOException; import <extra_id_4>) { //var i<extra_id_5>= i > -1;)<extra_id_6>|| ip = ip[i]<extra_id_7>(ip) || (ip)<extra_id_8>ip = ip;<extra_id_9>; i < 3; i--)<extra_id_10>if (((int) ip[4-i]|(int)ip[5-i>>2)]<extra_id_11>if (((int) ip[ BufferedReader br =  = br.readLine()) != null && !line.isEmpty()) { if (line.charAt(0) == '-')  = Double.parseDouble(\"0\"   1.0 >  for (int i = 7;  if ((ni & (int) (Math.pow(2, i))) != 0) {  } else { si[7 - i] =  i = 3; i >= 0; i--) { if (((int)  - i] =  } } System.out.println(new String(si) + \".\" + new String(sd)); } } } }"], "original_ll": -0.915639340877533, "sampled_ll": -0.6806674599647522, "all_perturbed_sampled_ll": [-3.470289707183838], "all_perturbed_original_ll": [-3.0218889713287354], "perturbed_sampled_ll": -3.470289707183838, "perturbed_original_ll": -3.0218889713287354, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "# Aizu Problem 0220: Binary Digit A Doctor Loved\n\nimport sys, math, os, struct\n\n# read input:\nPYDEV = os.environ.get('PYDEV')\nif PYDEV==\"True\":\n    sys.stdin = open(\"sample-input.txt\", \"rt\")\n\n\n\nwhile True:\n    n = float(input())\n    if n < 0:\n        break\n    pre = int(n)\n    post = n - int(n)\n    res = bin(pre)[2:].zfill(8) + '.'\n    for k in range(4):\n        post *= 2\n        res += str(int(post))\n        post -= int(post)\n    if pre > 255 or post > 0:\n        print(\"NA\")\n    else:\n        print(res)\n    #m = int(n * 16)\n    #if n == m / 16. and m < 4096:\n    #    res = \"\"\n    #    for k in range(12):\n    #        res += str(m % 2)\n    #        m //= 2\n    #        if k == 7:\n    #            res += '.'\n    #    print(res)\n    #else:\n    #    print(\"NA\")", "sampled": "import sys\n\ndef decimal_to_binary(n):\n    if n < 0:\n        return None\n    \n    # Split into integer and fractional parts\n    integer_part = int(n)\n    fractional_part = n - integer_part\n    \n    # Check if integer part fits in 8 bits\n    if integer_part >= 256:  # 2^8\n        return \"NA\"\n    \n    # Convert integer part to binary\n    int_binary = bin(integer_part)[2:].zfill(8)\n    \n    # Convert fractional part to binary (up to 4 digits)\n    frac_binary = \"\"\n    for _ in range(4):\n        fractional_part *= 2\n        bit = int(fractional_part)\n        frac_binary += str(bit)\n        fractional_part -= bit\n    \n    # Check if there's remaining fractional part (can't be represented exactly)\n    if fractional_part > 1e-9:  # small epsilon for floating point errors\n        return \"NA\"\n    \n    return int_binary + \".\" + frac_binary\n\nfor line in sys.stdin:\n    n = float(line.strip())\n    if n < 0:\n        break\n    result = decimal_to_binary(n)\n    print(result)\n", "perturbed_sampled": ["import sys def decimal_to_binary(n): if n (may<extra_id_6>to binary) -<extra_id_7># Create a<extra_id_8>convert<extra_id_9>int_binary<extra_id_10>= int_binary %<extra_id_11>(<extra_id_12>#<extra_id_13>integer_part % 10<extra_id_14>print_decimal_int_binary(integer_binary)<extra_id_15>#<extra_id_16>to binary  integer_part # Check if  bits if integer_part >= 256: #  int_binary = bin(integer_part)[2:].zfill(8) # Convert fractional part to binary   += str(bit) fractional_part -= bit  fractional part (can't be represented exactly) if fractional_part >  floating   n = float(line.strip())  result = decimal_to_binary(n) print(result)"], "perturbed_original": ["#  sys, math,  < 0: break pre =  + '.' for k in range(4): post *= 2  int(post) if pre >  print(\"NA\") else: print(res) #m = int(n * 16)  4096:  for  +=  //= 2 # if k == 7: # res += '.' # print(res) #else: # print(\"NA\")"], "original_ll": -1.6585206985473633, "sampled_ll": -0.9749753475189209, "all_perturbed_sampled_ll": [-3.0356404781341553], "all_perturbed_original_ll": [-3.7583508491516113], "perturbed_sampled_ll": -3.0356404781341553, "perturbed_original_ll": -3.7583508491516113, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "#include<stdio.h>\n#include<string.h>\nint main(){\n  int n,m,t;\n  int i,c;\n  char s[12];\n  while(1){\n    scanf(\"%d %d\",&n,&m);\n    if(n==0&&m==0)break;\n    scanf(\"\\n\");\n    t=1;\n    c=n;\n    int p[1001]={0};\n    p[n+1]=-1;\n    for(i=1;i<=m;i++){\n      if(t==c+1)t=1;\n      for(;p[t]==-1;t++);\n      if(t==c+1)t=1;\n      for(;p[t]==-1;t++);\n      fgets(s,10,stdin);\n      if(n!=1){\n\tif(i%3==0){\n\t  if(i%5==0){\n\t    if(strcmp(s,\"FizzBuzz\\n\\0\")!=0)p[t]=-1;\n\t  }\n\t  else{\n\t    if(strcmp(s,\"Fizz\\n\\0\")!=0)p[t]=-1;\n\t  }\n\t}\n\telse{\n\t  if(i%5==0){\n\t    if(strcmp(s,\"Buzz\\n\\0\")!=0)p[t]=-1;\n\t  }\n\t  else{\n\t    if(!(s[0]==i+'0'&&s[1]==10))p[t]=-1;\n\t  }\n\t}\n\tif(p[t]==-1)n--;\n      }\n      t++;\n    }\n    n=0;\n    for(i=1;i<=c;i++){\n      if(p[i]==0){\n\tif(n==1)printf(\" \");\n\tprintf(\"%d\",i);\n\tn=1;\n      }\n    }\n    printf(\"\\n\");\n  }\n  return 0;\n}", "sampled": "#include <stdio.h>\n#include <string.h>\n\nint main() {\n    int m, n;\n    \n    while(1) {\n        scanf(\"%d %d\", &m, &n);\n        if(m == 0 && n == 0) break;\n        \n        int active[1001];\n        for(int i = 1; i <= m; i++) {\n            active[i] = 1;\n        }\n        \n        int current_player = 1;\n        int current_number = 1;\n        int remaining_players = m;\n        \n        for(int i = 0; i < n; i++) {\n            char statement[10];\n            scanf(\"%s\", statement);\n            \n            if(remaining_players == 1) {\n                continue;\n            }\n            \n            // Find next active player\n            while(active[current_player] == 0) {\n                current_player++;\n                if(current_player > m) current_player = 1;\n            }\n            \n            // Check if statement is correct\n            int correct = 0;\n            \n            if(current_number % 15 == 0) {\n                if(strcmp(statement, \"FizzBuzz\") == 0) correct = 1;\n            }\n            else if(current_number % 3 == 0) {\n                if(strcmp(statement, \"Fizz\") == 0) correct = 1;\n            }\n            else if(current_number % 5 == 0) {\n                if(strcmp(statement, \"Buzz\") == 0) correct = 1;\n            }\n            else {\n                int num;\n                if(sscanf(statement, \"%d\", &num) == 1 && num == current_number) {\n                    correct = 1;\n                }\n            }\n            \n            if(!correct) {\n                active[current_player] = 0;\n                remaining_players--;\n            }\n            \n            current_number++;\n            \n            // Move to next player\n            current_player++;\n            if(current_player > m) current_player = 1;\n        }\n        \n        int first = 1;\n        for(int i = 1; i <= m; i++) {\n            if(active[i]) {\n                if(!first) printf(\" \");\n                printf(\"%d\", i);\n                first = 0;\n            }\n        }\n        printf(\"\\n\");\n    }\n    \n    return 0;\n}\n", "perturbed_sampled": ["  0) break; int active[1001]; for(int i = 1; i <=  1; } int current_player = 1; int current_number = 1; int  =  { char statement[10]; scanf(\"%s\",  next active  current_player++; if(current_player > m) current_player  if statement is correct int correct  ==    % 5 == 0) {  = 1;  1  correct = 1;  = 0; remaining_players--; } current_number++; // Move to next player current_player++;  = 1; for(int  m; i++)  = 0; } } printf(\"\\n\"); } return 0; }"], "perturbed_original": ["#include<stdio.h> #include<string.h>  i,c; char s[12]; while(1){ scanf(\"%d  int p[1001]={0}; p[n+1]=-1; for(i=1;i<=m;i++){ if(t==c+1)t=1;   if(strcmp(s,\"Fizz\\n\\0\")!=0)p[t]=-1; } } else{ if(i%5==0){ if(strcmp(s,\"Buzz\\n\\0\")!=0)p[t]=-1; } else{ if(!(s[0]==i+'0'&&s[1]==10))p[t]=-1;  if(n==1)printf(\"  }"], "original_ll": -1.0801706314086914, "sampled_ll": -0.6141173243522644, "all_perturbed_sampled_ll": [-3.0268683433532715], "all_perturbed_original_ll": [-2.471742630004883], "perturbed_sampled_ll": -3.0268683433532715, "perturbed_original_ll": -2.471742630004883, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import java.util.*;\n\nclass Main {\n\tpublic static void main (String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint m,n;\n\t\tFizzBuzz fb;\n\t\tfor(;;) {\n\t\t\tm = sc.nextInt();\n\t\t\tn = sc.nextInt();\n\t\t\tif(m==0 && n==0) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\n\t\t\tfb = new FizzBuzz(m);\n\t\t\tfor(int i=0; i<n; i++) {\n\t\t\t\tif(!fb.sayNextStatement(sc.next())) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tfb.showPlayer();\n\t\t}\n\t}\n}\n\nclass FizzBuzz {\n\tprivate int current,currentPlayer;\n\tprivate int m;\n\tprivate int[] player;\n\t\n\tpublic FizzBuzz(int m) {\n\t\tcurrent = 0;\n\t\tcurrentPlayer = 0;\n\t\tthis.m = m;\n\t\tplayer = new int[m];\n\t\tfor(int i=0; i<m; i++) {\n\t\t\tplayer[i] = i+1;\n\t\t}\n\t}\n\t\n\tpublic void showPlayer() {\n\t\tfor(int pl:player){\n\t\t\tif(pl != -1){\n\t\t\t\tSystem.out.println(pl);\n\t\t\t}\n\t\t}\n\t}\n\t\n\tpublic boolean sayNextStatement(String statement) {\n\t\ttry {\n\t\t\tint num = Integer.valueOf(statement);\n\t\t\tif(!checkFizzBuzz(num)) {\n\t\t\t\tplayer[currentPlayer] = -1;\n\t\t\t}\n\t\t} catch(NumberFormatException e) {\n\t\t\tif(!checkFizzBuzz(statement)) {\n\t\t\t\tplayer[currentPlayer] = -1;\n\t\t\t}\n\t\t}\n\t\t\n\t\tif(!setCurrentPlayer()) {\n\t\t\treturn false;\n\t\t}\n\t\t\n\t\treturn true;\n\t}\n\t\n\tprivate boolean setCurrentPlayer() {\n\t\tint prev = currentPlayer;\n\t\t\n\t\tif(currentPlayer+1 == m) {\n\t\t\tcurrentPlayer = 0;\n\t\t} else {\n\t\t\tcurrentPlayer ++;\n\t\t}\n\t\t\n\t\twhile(player[currentPlayer] == -1) {\n\t\t\tif(currentPlayer+1 == m) {\n\t\t\t\tcurrentPlayer = 0;\n\t\t\t} else {\n\t\t\t\tcurrentPlayer ++;\n\t\t\t}\n\t\t\t\n\t\t\tif(prev == currentPlayer) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn true;\n\t}\n\t\n\tprivate boolean checkFizzBuzz(int statement) {\n\t\tcurrent ++;\n\t\t\n\t\tif((current % 3 == 0) || (current % 5 == 0)) {\n\t\t\treturn false;\n\t\t} else {\n\t\t\tif(current == statement) {\n\t\t\t\treturn true;\n\t\t\t} else {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tprivate boolean checkFizzBuzz(String statement) {\n\t\tcurrent ++;\n\t\tif((current % 3 == 0) && (current % 5 == 0)) {\n\t\t\tif(statement.equals(\"FizzBuzz\")) {\n\t\t\t\treturn true;\n\t\t\t} else {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t} else if(current % 3 == 0) {\n\t\t\tif(statement.equals(\"Fizz\")) {\n\t\t\t\treturn true;\n\t\t\t} else {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t} else if(current % 5 == 0) {\n\t\t\tif(statement.equals(\"Buzz\")) {\n\t\t\t\treturn true;\n\t\t\t} else {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t} else {\n\t\t\treturn false;\n\t\t}\n\t}\n}", "sampled": "import java.util.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        \n        while (true) {\n            int m = sc.nextInt();\n            int n = sc.nextInt();\n            \n            if (m == 0 && n == 0) break;\n            \n            boolean[] active = new boolean[m + 1];\n            for (int i = 1; i <= m; i++) {\n                active[i] = true;\n            }\n            \n            int currentNumber = 1;\n            int currentPlayer = 1;\n            int activePlayers = m;\n            \n            for (int i = 0; i < n; i++) {\n                String statement = sc.next();\n                \n                if (activePlayers == 1) {\n                    continue;\n                }\n                \n                while (!active[currentPlayer]) {\n                    currentPlayer++;\n                    if (currentPlayer > m) currentPlayer = 1;\n                }\n                \n                String correct = getCorrectStatement(currentNumber);\n                \n                if (!statement.equals(correct)) {\n                    active[currentPlayer] = false;\n                    activePlayers--;\n                } else {\n                    currentNumber++;\n                }\n                \n                if (activePlayers > 1) {\n                    currentPlayer++;\n                    if (currentPlayer > m) currentPlayer = 1;\n                }\n            }\n            \n            List<Integer> result = new ArrayList<>();\n            for (int i = 1; i <= m; i++) {\n                if (active[i]) {\n                    result.add(i);\n                }\n            }\n            \n            for (int i = 0; i < result.size(); i++) {\n                if (i > 0) System.out.print(\" \");\n                System.out.print(result.get(i));\n            }\n            System.out.println();\n        }\n        \n        sc.close();\n    }\n    \n    static String getCorrectStatement(int num) {\n        if (num % 15 == 0) {\n            return \"FizzBuzz\";\n        } else if (num % 3 == 0) {\n            return \"Fizz\";\n        } else if (num % 5 == 0) {\n            return \"Buzz\";\n        } else {\n            return String.valueOf(num);\n        }\n    }\n}\n", "perturbed_sampled": ["import java.util.*; public class Main { public static void main(String[]  new Scanner(System.in); while (true)    active   {   i =   if (activePlayers  currentPlayer = 1;  if (!statement.equals(correct)) {   (activePlayers > 1) { currentPlayer++; if (currentPlayer  } } List<Integer> result = new ArrayList<>(); for (int i   i < result.size(); i++)  System.out.print(\" \"); System.out.print(result.get(i)); } System.out.println(); } sc.close(); }  if (num % 15 == 0) { return \"FizzBuzz\"; } else if (num  return \"Fizz\"; }  ==  else { return String.valueOf(num); } } }"], "perturbed_original": ["  = new Scanner(System.in);  FizzBuzz(m); for(int i=0; i<n; i++) { if(!fb.sayNextStatement(sc.next()))  } } } class FizzBuzz {  public FizzBuzz(int m) { current = 0; currentPlayer = 0; this.m = m; player   pl:player){ if(pl != -1){ System.out.println(pl); } } } public boolean sayNextStatement(String statement)   catch(NumberFormatException  = -1; } } if(!setCurrentPlayer()) { return false; } return true; } private boolean setCurrentPlayer() { int prev = currentPlayer;  = 0; } else { currentPlayer  { currentPlayer = 0;  } if(prev == currentPlayer)  boolean  if((current % 3 ==  == 0)) { return false;  statement) { return  false;  ++;  } }  {  if(current % 5 == 0) {  else { return false; } } else  }"], "original_ll": -0.6554927825927734, "sampled_ll": -0.535376787185669, "all_perturbed_sampled_ll": [-2.702625036239624], "all_perturbed_original_ll": [-2.8276007175445557], "perturbed_sampled_ll": -2.702625036239624, "perturbed_original_ll": -2.8276007175445557, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "# Aizu Problem 0221: Fizz Buzz\n\nimport sys, math, os, struct\n\n# read input:\nPYDEV = os.environ.get('PYDEV')\nif PYDEV==\"True\":\n    sys.stdin = open(\"sample-input.txt\", \"rt\")\n\n\ndef valid(k, a):\n    if k % 3 == 0 and k % 5 == 0:\n        return a == \"FizzBuzz\"\n    elif k % 3 == 0:\n        return a == \"Fizz\"\n    elif k % 5 == 0:\n        return a == \"Buzz\"\n    else:\n        return int(a) == k\n\n    \ndef fizz_buzz(m, n, A):\n    players = list(range(1, m + 1))\n    p = 0\n    k = 0\n    while len(A) > 0:\n        k += 1\n        a = A.pop(0)\n        if valid(k, a):\n            p = (p + 1) % m\n        else:\n            if len(players) == 0:\n                print()\n                return\n            players.pop(p)\n            if len(players) == 1:\n                break\n            m -= 1\n            if p == m:\n                p = 0\n    print(' '.join([str(p) for p in players]))\n    \n    \nwhile True:\n    m, n = [int(_) for _ in input().split()]\n    if m == 0:\n        break\n    A = [input().strip() for _ in range(n)]\n    fizz_buzz(m, n, A)", "sampled": "def get_expected(num):\n    if num % 15 == 0:\n        return \"FizzBuzz\"\n    elif num % 3 == 0:\n        return \"Fizz\"\n    elif num % 5 == 0:\n        return \"Buzz\"\n    else:\n        return str(num)\n\nwhile True:\n    line = input().split()\n    m, n = int(line[0]), int(line[1])\n    \n    if m == 0 and n == 0:\n        break\n    \n    players = set(range(1, m + 1))\n    current_num = 1\n    current_player = 1\n    \n    for _ in range(n):\n        statement = input().strip()\n        \n        if len(players) == 1:\n            continue\n        \n        while current_player not in players:\n            current_player += 1\n            if current_player > m:\n                current_player = 1\n        \n        expected = get_expected(current_num)\n        \n        if statement != expected:\n            players.discard(current_player)\n        \n        current_num += 1\n        current_player += 1\n        if current_player > m:\n            current_player = 1\n    \n    result = sorted(list(players))\n    print(' '.join(map(str, result)))\n", "perturbed_sampled": ["def get_expected(num):  0: return  == 0: return \"Buzz\" else: return str(num) while  n = int(line[0]), int(line[1]) if m ==  break players = set(range(1, m + 1)) current_num  while current_player not in players:  > m: current_player  current_player +=  current_player = 1 result = sorted(list(players)) print(' '.join(map(str, result)))"], "perturbed_original": ["# Aizu  #  open(\"sample-input.txt\", \"rt\") def  k % 5 == 0: return  return a  a == \"Buzz\"  def  = 0 while len(A) > 0: k += 1 a = A.pop(0) if valid(k, a): p = (p +  len(players) == 0: print()  1: break  0  players])) while True: m, n = [int(_)  m == 0: break A = [input().strip()  n, A)"], "original_ll": -1.1929103136062622, "sampled_ll": -0.9095302224159241, "all_perturbed_sampled_ll": [-3.006711959838867], "all_perturbed_original_ll": [-3.47977876663208], "perturbed_sampled_ll": -3.006711959838867, "perturbed_original_ll": -3.47977876663208, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "c[1<<23],*p,n=1e7;main(a,b){for(;a+=2,a<n;)for(b=a/2;(b+=a)<n;)c[b]=1;for(;scanf(\"%d\",&n)*n;printf(\"%d\\n\",n))for(;p=c+n/2-4,~n&1|p[4]|p[3]|p[1]|*p;n--);}", "sampled": "#include <stdio.h>\n#include <stdbool.h>\n#include <string.h>\n\n#define MAX 10000010\n\nbool is_prime[MAX];\nint quadruplets[MAX];\n\nvoid sieve() {\n    memset(is_prime, true, sizeof(is_prime));\n    is_prime[0] = is_prime[1] = false;\n    \n    for (int i = 2; i * i < MAX; i++) {\n        if (is_prime[i]) {\n            for (int j = i * i; j < MAX; j += i) {\n                is_prime[j] = false;\n            }\n        }\n    }\n}\n\nvoid find_quadruplets() {\n    memset(quadruplets, 0, sizeof(quadruplets));\n    \n    for (int a = 2; a + 8 < MAX; a++) {\n        if (is_prime[a] && is_prime[a+2] && is_prime[a+6] && is_prime[a+8]) {\n            int size = a + 8;\n            quadruplets[size] = size;\n        }\n    }\n    \n    int max_so_far = 0;\n    for (int i = 0; i < MAX; i++) {\n        if (quadruplets[i] > 0) {\n            max_so_far = quadruplets[i];\n        }\n        quadruplets[i] = max_so_far;\n    }\n}\n\nint main() {\n    sieve();\n    find_quadruplets();\n    \n    int n;\n    while (scanf(\"%d\", &n) == 1 && n != 0) {\n        printf(\"%d\\n\", quadruplets[n]);\n    }\n    \n    return 0;\n}\n", "perturbed_sampled": ["  sieve() { memset(is_prime, true, sizeof(is_prime)); is_prime[0]   = i  } } }    MAX;  is_prime[a+2] && is_prime[a+6] && is_prime[a+8]) {  8; quadruplets[size] = size; } } int max_so_far = 0; for (int i = 0; i  (quadruplets[i] > 0)  quadruplets[i] = max_so_far; } } int main() { sieve(); find_quadruplets(); int  0) { printf(\"%d\\n\", quadruplets[n]); } return 0; }"], "perturbed_original": ["c[1<<23],*p,n=1e7;main(a,b){for(;a+=2,a<n;)for(b=a/2;(b+=a)<n;)c[b]=1;for(;scanf(\"%d\",&n)*n;printf(\"%d\\n\",n))for(;p=c+n/2-4,~n&1|p[4]|p[3]|p[1]|*p;n--);}"], "original_ll": -3.0333800315856934, "sampled_ll": -0.5400764346122742, "all_perturbed_sampled_ll": [-2.261704444885254], "all_perturbed_original_ll": [-3.0333800315856934], "perturbed_sampled_ll": -2.261704444885254, "perturbed_original_ll": -3.0333800315856934, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "\n\nimport java.util.Arrays;\nimport java.util.Scanner;\n\npublic class Main {\n\n\tfinal int MAX = 10000000;\n\n\tboolean[] prime = new boolean[MAX + 10];\n\n\tvoid run() {\n\t\tScanner sc = new Scanner(System.in);\n\n\t\tArrays.fill(prime, true);\n\n\t\t//\u30a8\u30e9\u30c8\u30b9\u30c6\u30cd\u30b9\u306e\u7be9\n\t\tprime[0] = prime[1] = false;\n\t\tfor (int i = 2; i * i < MAX + 10; i++) {\n\t\t\tif (prime[i]) {\n\t\t\t\tfor (int j = i + i; j < MAX + 10; j += i) {\n\t\t\t\t\tprime[j] = false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\twhile (true) {\n\t\t\tint n = sc.nextInt();\n\t\t\tint max = 0;\n\n\t\t\tif (n == 0) {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tfor (int i = n; i >= 8; i--) {\n\t\t\t\tif (prime[i] && prime[i - 2] && prime[i - 6] && prime[i - 8]) {\n\t\t\t\t\tmax = i;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(max);\n\n\t\t}\n\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n\n}", "sampled": "import java.util.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        \n        int MAX = 10000000;\n        boolean[] isPrime = new boolean[MAX + 10];\n        Arrays.fill(isPrime, true);\n        isPrime[0] = isPrime[1] = false;\n        \n        for (int i = 2; i * i <= MAX + 8; i++) {\n            if (isPrime[i]) {\n                for (int j = i * i; j <= MAX + 8; j += i) {\n                    isPrime[j] = false;\n                }\n            }\n        }\n        \n        List<Integer> quadPrimes = new ArrayList<>();\n        for (int a = 2; a <= MAX; a++) {\n            if (isPrime[a] && isPrime[a + 2] && isPrime[a + 6] && isPrime[a + 8]) {\n                quadPrimes.add(a + 8);\n            }\n        }\n        \n        while (true) {\n            int n = sc.nextInt();\n            if (n == 0) break;\n            \n            int result = 0;\n            for (int size : quadPrimes) {\n                if (size <= n) {\n                    result = size;\n                } else {\n                    break;\n                }\n            }\n            \n            System.out.println(result);\n        }\n        \n        sc.close();\n    }\n}\n", "perturbed_sampled": [" { public static void main(String[]  new Scanner(System.in); int MAX = 10000000; boolean[] isPrime = new boolean[MAX  for (int i =   (int j = i * i; j <= MAX +  isPrime[j]  2] && isPrime[a + 6] && isPrime[a + 8]) {  (n == 0) break; int result = 0; for    System.out.println(result); } sc.close(); } }"], "perturbed_original": ["import java.util.Arrays; import java.util.Scanner; public class Main { final    sc =   for (int i = 2; i *  i++) {   j < MAX + 10; j += i) { prime[j] = false; } } } while (true) {  max = 0; if (n ==  } public  new Main().run(); } }"], "original_ll": -0.7576233148574829, "sampled_ll": -0.5165873169898987, "all_perturbed_sampled_ll": [-2.6182684898376465], "all_perturbed_original_ll": [-3.040048599243164], "perturbed_sampled_ll": -2.6182684898376465, "perturbed_original_ll": -3.040048599243164, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "def get_quad(n, p):\n    for ni in range(n,0,-1):\n        if p[ni] and p[ni - 2] and p[ni - 6] and p[ni - 8]:\n            return ni\n        \ndef sieve():\n    n = 10000001\n    p = [1] * n\n    p[0] = p[1] = 0\n    \n    for i in range(int(n ** 0.5)):\n        if p[i]:\n            for j in range(2 * i, len(p), i):\n                p[j] = 0\n    return p\nimport sys\nf = sys.stdin\n\nprime = sieve()\nwhile True:\n    n = f.readline()\n    if not n.isnumeric():\n        continue\n    n = int(n)\n    if n == 0:\n        break\n    print(get_quad(ni, prime))", "sampled": "def sieve_of_eratosthenes(limit):\n    is_prime = [True] * (limit + 1)\n    is_prime[0] = is_prime[1] = False\n    \n    for i in range(2, int(limit**0.5) + 1):\n        if is_prime[i]:\n            for j in range(i*i, limit + 1, i):\n                is_prime[j] = False\n    \n    return is_prime\n\ndef find_quadruplet_primes(limit):\n    is_prime = sieve_of_eratosthenes(limit)\n    quadruplets = []\n    \n    for a in range(2, limit - 7):\n        if is_prime[a] and is_prime[a+2] and is_prime[a+6] and is_prime[a+8]:\n            quadruplets.append(a + 8)\n    \n    return quadruplets\n\n# Precompute all quadruplet primes up to 10,000,000\nMAX_LIMIT = 10000000\nquadruplet_sizes = find_quadruplet_primes(MAX_LIMIT)\n\nwhile True:\n    n = int(input())\n    if n == 0:\n        break\n    \n    # Binary search for the largest quadruplet size <= n\n    result = 0\n    for size in quadruplet_sizes:\n        if size <= n:\n            result = size\n        else:\n            break\n    \n    print(result)\n", "perturbed_sampled": ["def sieve_of_eratosthenes(limit): is_prime = [True] * (limit + 1) is_prime[0]  + 1): if is_prime[i]: for j in range(i*i,  def find_quadruplet_primes(limit): is_prime = sieve_of_eratosthenes(limit) quadruplets = [] for a in range(2,  and is_prime[a+2] and    for the   <= n: result = size else: break print(result)"], "perturbed_original": [" in range(n,0,-1): if p[ni] and p[ni - 2]  p[ni - 8]: return ni def  = [1] * n p[0] = p[1] = 0 for i in range(int(n  j in range(2  break print(get_quad(ni, prime))"], "original_ll": -1.2205712795257568, "sampled_ll": -0.6833537817001343, "all_perturbed_sampled_ll": [-2.484440803527832], "all_perturbed_original_ll": [-3.234367847442627], "perturbed_sampled_ll": -2.484440803527832, "perturbed_original_ll": -3.234367847442627, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "#include<stdio.h>\n#include<string.h>\n#include<stdbool.h>\n\n#define MIN(x,y) (((x)<(y))?(x):(y))\n#define INFTY (1<<21)\n\n\nint m, n, k, d, C[7], G[110][110], N, D[110][64];\n\nint getID(char *str);\nint isC(int x);\nint bellman(void);\n\nint main(void){\n  char source[16], target[16];\n  int cost,s,t;\n  int i,j;\n  while(scanf(\"%d%*c%d%*c%d%*c%d%*c\",&m,&n,&k,&d) && m ){\n    N = 2 + n + m;\n    for(i=1;i<m+1;i++) scanf(\"%d%*c\",&C[i]);\n    for(i=0;i<N;i++) for(j=0;j<N;j++) G[i][j] = INFTY;\n    for(i=0;i<d;i++){\n      scanf(\"%s%*c%s%*c%d%*c\",source,target,&cost);\n      s = getID(source);\n      t = getID(target);\n      G[t][s] = G[s][t] = MIN(G[s][t], cost * k);\n    }\n    printf(\"%d\\n\",bellman());\n  }\n  return 0;\n}\n\nint getID(char *str){\n  char num[16];\n  if ( str[0] == 'H' ) return 0;\n  if ( str[0] == 'D' ) return N - 1;\n  strcpy(num,str+1);\n  if ( str[0] == 'C' ) return atoi(num);\n  return atoi(num) + m;\n}\n\nint isC(int x){\n  return 1 <= x && x <= m;\n}\nint bellman(void){\n  bool change=0;\n  int minv;\n  int i,o,u,v,b,j;\n\n  for(i=0;i<N;i++) for(j=0;j<(1<<m);j++) D[i][j] = INFTY;\n  D[0][0] = 0;\n  for(o=0;o<N*(1<<m);o++){\n    for(u=0;u<N;u++){\n      for(v=0;v<N;v++){\n\tif ( u == v || G[u][v] == INFTY ) continue;\n\tfor(b=0;b<(1<<m);b++){\n\t  if (isC(v) && (b&(1<<(v-1))) != 0 ) continue;\n\t  if ( isC(v) ) {\n\t    if ( D[u][b] + G[u][v] - C[v] < D[v][b|(1<<(v-1))] ) {\n\t      D[v][b|(1<<(v-1))] = D[u][b] + G[u][v] - C[v];\n\t      change = true;\n\t    }\n\t  } else {\n\t    if ( D[u][b] + G[u][v] < D[v][b] ){\n\t      D[v][b] = D[u][b] + G[u][v];\n\t      change = true;\n\t    }\n\t  }\n\t}\n      }\n    }\n    if ( !change ) break;\n  }\n  minv = INFTY;\n  for(i=0;i<(1<<m);i++) minv = MIN(minv, D[N-1][i]);\n  return minv;\n}", "sampled": "#include <stdio.h>\n#include <string.h>\n#include <limits.h>\n\n#define INF 1000000000\n#define MAX_NODES 110\n\nint m, n, k, d;\nint calories[10];\nint dist[MAX_NODES][MAX_NODES];\nint H_idx, D_idx;\nint C_idx[10];\nint L_idx[110];\n\nint parse_node(char *s) {\n    if (s[0] == 'H') return H_idx;\n    if (s[0] == 'D') return D_idx;\n    if (s[0] == 'C') {\n        int num;\n        sscanf(s + 1, \"%d\", &num);\n        return C_idx[num - 1];\n    }\n    if (s[0] == 'L') {\n        int num;\n        sscanf(s + 1, \"%d\", &num);\n        return L_idx[num - 1];\n    }\n    return -1;\n}\n\nint min(int a, int b) {\n    return a < b ? a : b;\n}\n\nvoid floyd_warshall(int nodes) {\n    for (int k = 0; k < nodes; k++) {\n        for (int i = 0; i < nodes; i++) {\n            for (int j = 0; j < nodes; j++) {\n                if (dist[i][k] != INF && dist[k][j] != INF) {\n                    dist[i][j] = min(dist[i][j], dist[i][k] + dist[k][j]);\n                }\n            }\n        }\n    }\n}\n\nint main() {\n    while (1) {\n        scanf(\"%d %d %d %d\", &m, &n, &k, &d);\n        if (m == 0 && n == 0 && k == 0 && d == 0) break;\n\n        for (int i = 0; i < m; i++) {\n            scanf(\"%d\", &calories[i]);\n        }\n\n        int nodes = 2 + m + n;\n        H_idx = 0;\n        D_idx = 1;\n        for (int i = 0; i < m; i++) C_idx[i] = 2 + i;\n        for (int i = 0; i < n; i++) L_idx[i] = 2 + m + i;\n\n        for (int i = 0; i < nodes; i++) {\n            for (int j = 0; j < nodes; j++) {\n                if (i == j) dist[i][j] = 0;\n                else dist[i][j] = INF;\n            }\n        }\n\n        for (int i = 0; i < d; i++) {\n            char s[10], t[10];\n            int e;\n            scanf(\"%s %s %d\", s, t, &e);\n            int u = parse_node(s);\n            int v = parse_node(t);\n            dist[u][v] = min(dist[u][v], e);\n            dist[v][u] = min(dist[v][u], e);\n        }\n\n        floyd_warshall(nodes);\n\n        int min_cost = INF;\n        for (int mask = 0; mask < (1 << m); mask++) {\n            int perm[10];\n            int cnt = 0;\n            for (int i = 0; i < m; i++) {\n                if (mask & (1 << i)) {\n                    perm[cnt++] = i;\n                }\n            }\n\n            if (cnt == 0) {\n                int total_dist = dist[H_idx][D_idx];\n                int cost = total_dist * k;\n                min_cost = min(min_cost, cost);\n            } else {\n                int fact = 1;\n                for (int i = 1; i <= cnt; i++) fact *= i;\n                \n                for (int p = 0; p < fact; p++) {\n                    int temp_perm[10];\n                    for (int i = 0; i < cnt; i++) temp_perm[i] = perm[i];\n                    \n                    int temp = p;\n                    for (int i = 0; i < cnt; i++) {\n                        int j = i + temp % (cnt - i);\n                        temp /= (cnt - i);\n                        int t = temp_perm[i];\n                        temp_perm[i] = temp_perm[j];\n                        temp_perm[j] = t;\n                    }\n\n                    int total_dist = dist[H_idx][C_idx[temp_perm[0]]];\n                    int total_cal = calories[temp_perm[0]];\n                    for (int i = 1; i < cnt; i++) {\n                        total_dist += dist[C_idx[temp_perm[i - 1]]][C_idx[temp_perm[i]]];\n                        total_cal += calories[temp_perm[i]];\n                    }\n                    total_dist += dist[C_idx[temp_perm[cnt - 1]]][D_idx];\n\n                    int cost = total_dist * k - total_cal;\n                    min_cost = min(min_cost, cost);\n                }\n            }\n        }\n\n        printf(\"%d\\n\", min_cost);\n    }\n    return 0;\n}\n", "perturbed_sampled": [" <limits.h> #define INF 1000000000 #define MAX_NODES 110 int m,   int parse_node(char  'H') return H_idx;  D_idx; if (s[0] ==  return C_idx[num - 1]; } if (s[0] == 'L') { int num; sscanf(s + 1, \"%d\", &num); return L_idx[num - 1]; }  return a < b ? a : b; } void floyd_warshall(int nodes) { for  < nodes; k++) { for (int   < nodes; j++) { if (dist[i][k]  INF) { dist[i][j]  } } } } } int main() { while (1) { scanf(\"%d %d %d %d\", &m, &n, &k, &d); if (m  0  0; i < m; i++)   0; i < m;  i; for    dist[i][j] = 0; else dist[i][j] = INF; } }   e; scanf(\"%s %s %d\",  = parse_node(s); int v = parse_node(t); dist[u][v] = min(dist[u][v], e); dist[v][u] = min(dist[v][u], e);  {  0; for (int i = 0;  if (mask  perm[cnt++] = i;  = total_dist *  } else  1; i <= cnt; i++)  i =  temp_perm[i] =   i < cnt; i++) { int j = i  - i);  = temp_perm[j]; temp_perm[j] = t; } int total_dist =  for (int i =  k - total_cal; min_cost  }  }"], "perturbed_original": ["#include<stdio.h> ><extra_id_3>] + G [<extra_id_4>< F[o|i]<extra_id_5>i] ] - C[y]; if(<extra_id_6>c%d%*c\"%s\",source,target,x); for<extra_id_7>{<extra_id_8>( n=0;o<n*k;o++){<extra_id_9>{ if<extra_id_10>==<extra_id_11>0; break;<extra_id_12>if<extra_id_13>d=   int bellman(void);  int cost,s,t; int i,j; while(scanf(\"%d%*c%d%*c%d%*c%d%*c\",&m,&n,&k,&d) && m ){ N = 2 + n + m;  = INFTY; for(i=0;i<d;i++){ scanf(\"%s%*c%s%*c%d%*c\",source,target,&cost);  = MIN(G[s][t], cost * k);  } int getID(char *str){ char num[16]; if  atoi(num);  int isC(int  && x <= m; } int  int i,o,u,v,b,j; for(i=0;i<N;i++) for(j=0;j<(1<<m);j++)  0; for(o=0;o<N*(1<<m);o++){  == INFTY ) continue; for(b=0;b<(1<<m);b++){ if  ) continue; if (  D[u][b] + G[u][v] - C[v] < D[v][b|(1<<(v-1))] )  G[u][v] - C[v]; change = true;  <   ) break; } minv = INFTY; for(i=0;i<(1<<m);i++) minv  }"], "original_ll": -0.9954560995101929, "sampled_ll": -0.5099862217903137, "all_perturbed_sampled_ll": [-2.3745930194854736], "all_perturbed_original_ll": [-2.8106603622436523], "perturbed_sampled_ll": -2.3745930194854736, "perturbed_original_ll": -2.8106603622436523, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import java.util.*;\nimport java.math.*;\npublic class Main{\n\n\tstatic int INF = 2 << 27;\n\tstatic int m;\n\tstatic int n;\n\tstatic int k;\n\tstatic int d;\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\twhile(true) {\n\t\t\tm = sc.nextInt();\n\t\t\tn = sc.nextInt();\n\t\t\tk = sc.nextInt();\n\t\t\td = sc.nextInt();\n\t\t\tif(m == 0 && n == 0 && k == 0 && d == 0) break;\n\t\t\tint[] c = new int[m];\n\t\t\tfor(int i = 0; i < m; i++) {\n\t\t\t\tc[i] = sc.nextInt();\n\t\t\t}\n\t\t\tNode[] node = new Node[m + n + 2];\n\t\t\tfor(int i = 0; i < m; i++) {\n\t\t\t\tnode[i] = new Node();\n\t\t\t\tnode[i].type = 2;\n\t\t\t}\n\t\t\tfor(int i = m; i < m + n; i++) {\n\t\t\t\tnode[i] = new Node();\n\t\t\t\tnode[i].type = 3;\n\t\t\t}\n\t\t\tnode[m + n    ] = new Node();\n\t\t\tnode[m + n    ].type = 0;\n\t\t\tnode[m + n + 1] = new Node();\n\t\t\tnode[m + n + 1].type = 1;\n\t\t\t\n\t\t\tfor(int i = 0; i < d; i++) {\n\t\t\t\tString a = sc.next();\n\t\t\t\tString b = sc.next();\n\t\t\t\tint cost = sc.nextInt();\n\t\t\t\tint idA = -100;\n\t\t\t\tint idB = -100;\n\t\t\t\tif(a.length() == 1) {\n\t\t\t\t\tif(a.equals(\"H\")) idA = m + n;\n\t\t\t\t\telse \t\t\t  idA = m + n + 1;\n\t\t\t\t}\n\t\t\t\tif(b.length() == 1) {\n\t\t\t\t\tif(b.equals(\"H\")) idB = m + n;\n\t\t\t\t\telse\t\t\t  idB = m + n + 1;\n\t\t\t\t}\n\t\t\t\tif(idA == -100) {\n\t\t\t\t\tif(a.charAt(0) == 'C') {\n\t\t\t\t\t\tidA = Integer.parseInt(a.substring(1)) - 1;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tidA = m + Integer.parseInt(a.substring(1)) - 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif(idB == -100) {\n\t\t\t\t\tif(b.charAt(0) == 'C') {\n\t\t\t\t\t\tidB = Integer.parseInt(b.substring(1)) - 1;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tidB = m + Integer.parseInt(b.substring(1)) - 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tnode[idA].edge_to.add(idB);\n\t\t\t\tnode[idA].edge_cost.add(cost);\n\t\t\t\tnode[idB].edge_to.add(idA);\n\t\t\t\tnode[idB].edge_cost.add(cost);\n\t\t\t}\n\t\t\tint[][] dp = new int[n + m + 2][1 << m];\n\t\t\tfor(int i = 0; i < dp.length; i++) {\n\t\t\t\tfor(int j = 0; j < dp[i].length; j++) {\n\t\t\t\t\tdp[i][j] = INF;\n\t\t\t\t}\n\t\t\t}\n\t\t\tPriorityQueue<Data> queue = new PriorityQueue<Data>();\n\t\t\tqueue.add(new Data(m + n,new boolean[m],0));\n\t\t\twhile(!queue.isEmpty()) {\n\t\t\t\tData tmp = queue.poll();\n\t\t\t\tint V = 0;\n\t\t\t\tfor(int i = 0; i < tmp.v.length; i++) {\n\t\t\t\t\tif(tmp.v[i]) {\n\t\t\t\t\t\tV |= 1 << i;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(dp[tmp.now][V] <= tmp.cost) continue;\n\t\t\t\tdp[tmp.now][V] = tmp.cost;\n\t\t\t\tNode now = node[tmp.now];\n\t\t\t\tfor(int i = 0; i < now.edge_to.size(); i++) {\n\t\t\t\t\tif(node[now.edge_to.get(i)].type == 2 && tmp.v[now.edge_to.get(i)]) continue;\n\t\t\t\t\tif(node[now.edge_to.get(i)].type == 2) {\n\t\t\t\t\t\tboolean[] copy = Arrays.copyOf(tmp.v, tmp.v.length);\n\t\t\t\t\t\tcopy[now.edge_to.get(i)] = true; \n\t\t\t\t\t\tqueue.add(new Data(now.edge_to.get(i),copy, tmp.cost - c[now.edge_to.get(i)] + now.edge_cost.get(i) * k));\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tqueue.add(new Data(now.edge_to.get(i),tmp.v, tmp.cost + now.edge_cost.get(i) * k));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tint MIN = Integer.MAX_VALUE;\n\t\t\tfor(int i = 0; i < dp[m + n + 1].length; i++) {\n\t\t\t\tMIN = Math.min(MIN, dp[m + n + 1][i]);\n\t\t\t}\n\t\t\tSystem.out.println(MIN);\n\t\t}\n\t}\n\tstatic class Data implements Comparable<Data>{\n\t\tint cost;\n\t\tboolean[] v;\n\t\tint now;\n\t\t@Override\n\t\tpublic int compareTo(Data o) {\n\t\t\treturn this.cost - o.cost;\n\t\t}\n\t\tData(int c, boolean[] b, int a) {\n\t\t\tcost = a;\n\t\t\tv    = b;\n\t\t\tnow  = c;\n\t\t}\n\t}\n\tstatic class Node {\n\t\tint type; // 0 H, 1 D, 2 C, 3 L\n\t\tboolean c;\n\t\tArrayList<Integer> edge_to = new ArrayList<Integer>();\n\t\tArrayList<Integer> edge_cost = new ArrayList<Integer>();\n\t}\n}", "sampled": "import java.util.*;\nimport java.io.*;\n\npublic class Main {\n    static class Edge {\n        String to;\n        int dist;\n        Edge(String to, int dist) {\n            this.to = to;\n            this.dist = dist;\n        }\n    }\n    \n    static Map<String, List<Edge>> graph;\n    static int[] cakeCals;\n    static int m, n, k, d;\n    static Map<String, Integer> nodeToIdx;\n    static String[] idxToNode;\n    static int numNodes;\n    static int[][] dist;\n    static final int INF = 1000000000;\n    \n    public static void main(String[] args) throws IOException {\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        String line;\n        \n        while ((line = br.readLine()) != null) {\n            String[] parts = line.trim().split(\"\\\\s+\");\n            m = Integer.parseInt(parts[0]);\n            n = Integer.parseInt(parts[1]);\n            k = Integer.parseInt(parts[2]);\n            d = Integer.parseInt(parts[3]);\n            \n            if (m == 0 && n == 0 && k == 0 && d == 0) break;\n            \n            cakeCals = new int[m + 1];\n            parts = br.readLine().trim().split(\"\\\\s+\");\n            for (int i = 1; i <= m; i++) {\n                cakeCals[i] = Integer.parseInt(parts[i - 1]);\n            }\n            \n            graph = new HashMap<>();\n            Set<String> nodes = new HashSet<>();\n            \n            for (int i = 0; i < d; i++) {\n                parts = br.readLine().trim().split(\"\\\\s+\");\n                String s = parts[0];\n                String t = parts[1];\n                int e = Integer.parseInt(parts[2]);\n                \n                nodes.add(s);\n                nodes.add(t);\n                \n                graph.putIfAbsent(s, new ArrayList<>());\n                graph.putIfAbsent(t, new ArrayList<>());\n                graph.get(s).add(new Edge(t, e));\n                graph.get(t).add(new Edge(s, e));\n            }\n            \n            nodeToIdx = new HashMap<>();\n            idxToNode = new String[nodes.size()];\n            int idx = 0;\n            for (String node : nodes) {\n                nodeToIdx.put(node, idx);\n                idxToNode[idx] = node;\n                idx++;\n            }\n            numNodes = nodes.size();\n            \n            // Floyd-Warshall\n            dist = new int[numNodes][numNodes];\n            for (int i = 0; i < numNodes; i++) {\n                Arrays.fill(dist[i], INF);\n                dist[i][i] = 0;\n            }\n            \n            for (String from : graph.keySet()) {\n                int fromIdx = nodeToIdx.get(from);\n                for (Edge e : graph.get(from)) {\n                    int toIdx = nodeToIdx.get(e.to);\n                    dist[fromIdx][toIdx] = Math.min(dist[fromIdx][toIdx], e.dist);\n                }\n            }\n            \n            for (int kk = 0; kk < numNodes; kk++) {\n                for (int i = 0; i < numNodes; i++) {\n                    for (int j = 0; j < numNodes; j++) {\n                        if (dist[i][kk] != INF && dist[kk][j] != INF) {\n                            dist[i][j] = Math.min(dist[i][j], dist[i][kk] + dist[kk][j]);\n                        }\n                    }\n                }\n            }\n            \n            int minCal = INF;\n            \n            // Try all permutations of visiting cake shops\n            for (int mask = 0; mask < (1 << m); mask++) {\n                List<Integer> cakeShops = new ArrayList<>();\n                for (int i = 0; i < m; i++) {\n                    if ((mask & (1 << i)) != 0) {\n                        cakeShops.add(i + 1);\n                    }\n                }\n                \n                if (cakeShops.isEmpty()) {\n                    int hIdx = nodeToIdx.get(\"H\");\n                    int dIdx = nodeToIdx.get(\"D\");\n                    int totalDist = dist[hIdx][dIdx];\n                    int cal = totalDist * k;\n                    minCal = Math.min(minCal, cal);\n                } else {\n                    int[] perm = new int[cakeShops.size()];\n                    for (int i = 0; i < cakeShops.size(); i++) {\n                        perm[i] = cakeShops.get(i);\n                    }\n                    \n                    permute(perm, 0, minCal);\n                }\n            }\n            \n            System.out.println(minCal);\n        }\n    }\n    \n    static int minCal;\n    \n    static void permute(int[] arr, int start, int currentMin) {\n        if (start == arr.length) {\n            int hIdx = nodeToIdx.get(\"H\");\n            int dIdx = nodeToIdx.get(\"D\");\n            \n            int totalDist = dist[hIdx][nodeToIdx.get(\"C\" + arr[0])];\n            int totalCakeCal = cakeCals[arr[0]];\n            \n            for (int i = 1; i < arr.length; i++) {\n                totalDist += dist[nodeToIdx.get(\"C\" + arr[i - 1])][nodeToIdx.get(\"C\" + arr[i])];\n                totalCakeCal += cakeCals[arr[i]];\n            }\n            \n            totalDist += dist[nodeToIdx.get(\"C\" + arr[arr.length - 1])][dIdx];\n            \n            int cal = totalDist * k - totalCakeCal;\n            minCal = Math.min(minCal, cal);\n            return;\n        }\n        \n        for (int i = start; i < arr.length; i++) {\n            swap(arr, i, start);\n            permute(arr, start + 1, currentMin);\n            swap(arr, i, start);\n        }\n    }\n    \n    static void swap(int[] arr, int i, int j) {\n        int temp = arr[i];\n        arr[i] = arr[j];\n        arr[j] = temp;\n    }\n}\n", "perturbed_sampled": ["import java.util.*; import java.io.*; public class Main { static class Edge { String to; int dist; Edge(String to, int dist) { this.to =   static int[] cakeCals; static int m, n,  static   1000000000; public static  { BufferedReader br = new  ((line =  Integer.parseInt(parts[1]);  0  k == 0 && d == 0)  + 1]; parts = br.readLine().trim().split(\"\\\\s+\"); for (int i = 1; i <= m; i++) { cakeCals[i] = Integer.parseInt(parts[i - 1]); } graph = new HashMap<>();  for  < d; i++) { parts = br.readLine().trim().split(\"\\\\s+\");   e)); graph.get(t).add(new Edge(s, e));  int     (Edge  toIdx =  } }  =  { for (int j = 0; j < numNodes; j++) { if  != INF) { dist[i][j] = Math.min(dist[i][j], dist[i][kk] + dist[kk][j]);  minCal = INF; //  cake shops  mask   ArrayList<>();  i  ((mask & (1 << i))  1); } } if   int cal = totalDist *  } else {   i <  minCal; static void permute(int[] arr, int start, int currentMin) {  int dIdx = nodeToIdx.get(\"D\"); int totalDist = dist[hIdx][nodeToIdx.get(\"C\" + arr[0])]; int  arr[i])]; totalCakeCal +=  int cal = totalDist * k - totalCakeCal; minCal = Math.min(minCal, cal); return;  start; i < arr.length; i++) { swap(arr, i, start); permute(arr, start   int j) {  temp; } }"], "perturbed_original": ["import java.util.*; import java.math.*;  INF = 2  d; public  Scanner(System.in);  sc.nextInt(); if(m  = new int[m]; for(int i = 0; i  = sc.nextInt();  Node[m +  m;  Node(); node[i].type = 2; } for(int i = m; i < m +  new  + 1] = new Node(); node[m + n +   = -100; if(a.length() == 1) { if(a.equals(\"H\")) idA = m  1) { if(b.equals(\"H\")) idB  n + 1; } if(idA == -100) {  = Integer.parseInt(a.substring(1)) - 1; } else { idA =  } } if(idB   - 1; } else { idB =  dp = new int[n + m + 2][1 << m]; for(int i = 0; i < dp.length;  0;  dp[i][j] = INF;  0; i < tmp.v.length; i++) { if(tmp.v[i]) { V |= 1  =   tmp.v[now.edge_to.get(i)]) continue; if(node[now.edge_to.get(i)].type  = true;  + now.edge_cost.get(i) * k)); } else {  * k)); } } } int MIN  + n  =  1][i]); } System.out.println(MIN); } } static class Data implements Comparable<Data>{ int cost; boolean[] v; int now; @Override  return this.cost - o.cost; } Data(int c, boolean[]  = a; v =  } static class Node {  3  = new ArrayList<Integer>(); ArrayList<Integer> edge_cost = new ArrayList<Integer>(); } }"], "original_ll": -0.6346538066864014, "sampled_ll": -0.4915972650051117, "all_perturbed_sampled_ll": [-2.6298539638519287], "all_perturbed_original_ll": [-2.73891544342041], "perturbed_sampled_ll": -2.6298539638519287, "perturbed_original_ll": -2.73891544342041, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "from itertools import combinations\nfrom heapq import heappop, heappush\nimport sys\nsys.setrecursionlimit(1000000)\nINF = 10 ** 20\n\ndef convert(s, m, n):\n  if s == \"H\":\n    return 0\n  if s == \"D\":\n    return 1\n  if s[0] == \"C\":\n    return int(s[1]) + 1\n  if s[0] == \"L\":\n    return int(s[1]) + m + 1\n\ndef get_cost(start, m, n, edges):\n  cost = [INF] * (m + n + 2)\n  cost[start] = 0\n  que = []\n  heappush(que, (0, start))\n  while que:\n    total, node = heappop(que)\n    for dist, to in edges[node]:\n      if cost[to] > total + dist:\n        cost[to] = total + dist\n        if not (2 <= to <= m + 1):\n          heappush(que, (total + dist, to))\n  return cost\n\n\ndef shortest_path(start, goal, rest, cakes_dist, dic):\n  if not rest:\n    return cakes_dist[start][goal]\n  if (start, rest) in dic:\n    return dic[(now, rest)]\n  \n  ret = INF\n  for to in rest:\n    ret = min(ret, shortest_path(to, goal, tuple((i for i in rest if i != to)), cakes_dist, dic) + cakes_dist[start][to])\n  dic[(start, rest)] = ret\n  return ret\n\nwhile True:\n  m, n, k, d = map(int, input().split())\n  if m == 0:\n    break\n  clst = list(map(int, input().split()))\n  \"\"\"\n  Home ... 0\n  D ... 1\n  Cake ... 2, 3, ... m + 1\n  Land ... m + 2, m + 3, ... m + n + 1\n  \"\"\"\n  edges = [[] for _ in range(m + n + 2)]\n  for _ in range(d):\n    s, t, e = input().split()\n    e = int(e)\n    s = convert(s, m, n)\n    t = convert(t, m, n)\n    edges[s].append((e, t))\n    edges[t].append((e, s))\n  \n  cakes_dist = [[INF] * (m + 2) for _ in range(m + 2)]\n  for start in range(m + 2):\n    cost = get_cost(start, m, n, edges)\n    for to in range(m + 2):\n      if to != start:\n        cakes_dist[start][to] = cost[to]\n\n", "sampled": "import sys\nfrom itertools import permutations\nfrom collections import defaultdict\nimport heapq\n\ndef dijkstra(graph, start, end, avoid_set):\n    \"\"\"Find shortest path avoiding nodes in avoid_set\"\"\"\n    dist = defaultdict(lambda: float('inf'))\n    dist[start] = 0\n    pq = [(0, start)]\n    \n    while pq:\n        d, u = heapq.heappop(pq)\n        if d > dist[u]:\n            continue\n        if u == end:\n            return d\n        for v, w in graph[u]:\n            if v in avoid_set:\n                continue\n            if dist[u] + w < dist[v]:\n                dist[v] = dist[u] + w\n                heapq.heappush(pq, (dist[v], v))\n    \n    return float('inf')\n\ndef solve(m, n, k, d, calories, edges):\n    # Build graph\n    graph = defaultdict(list)\n    for s, t, e in edges:\n        graph[s].append((t, e))\n        graph[t].append((s, e))\n    \n    # Get all cake shops\n    cake_shops = [f'C{i+1}' for i in range(m)]\n    \n    min_cost = float('inf')\n    \n    # Try all subsets of cake shops (including empty set)\n    for r in range(m + 1):\n        for perm in permutations(cake_shops, r):\n            # For this permutation, calculate the cost\n            # We need to go from H to each shop in order, then to D\n            # avoiding already visited shops\n            \n            visited_shops = set()\n            current = 'H'\n            total_distance = 0\n            total_calories = 0\n            valid = True\n            \n            for shop in perm:\n                # Find shortest path from current to shop, avoiding visited shops\n                dist = dijkstra(graph, current, shop, visited_shops)\n                if dist == float('inf'):\n                    valid = False\n                    break\n                total_distance += dist\n                visited_shops.add(shop)\n                # Eat cake at this shop\n                shop_idx = int(shop[1:]) - 1\n                total_calories += calories[shop_idx]\n                current = shop\n            \n            if not valid:\n                continue\n            \n            # Go from current to D, avoiding visited shops\n            dist = dijkstra(graph, current, 'D', visited_shops)\n            if dist == float('inf'):\n                continue\n            total_distance += dist\n            \n            # Calculate net calorie consumption\n            net_calories = total_distance * k - total_calories\n            min_cost = min(min_cost, net_calories)\n    \n    return min_cost\n\ndef main():\n    while True:\n        line = sys.stdin.readline().strip()\n        if not line:\n            break\n        m, n, k, d = map(int, line.split())\n        if m == 0 and n == 0 and k == 0 and d == 0:\n            break\n        \n        calories = list(map(int, sys.stdin.readline().split()))\n        \n        edges = []\n        for _ in range(d):\n            parts = sys.stdin.readline().split()\n            s, t, e = parts[0], parts[1], int(parts[2])\n            edges.append((s, t, e))\n        \n        result = solve(m, n, k, d, calories, edges)\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "perturbed_sampled": ["<extra_id_1>(points), v, pq<extra_id_2>x<extra_id_3>for<extra_id_4>sax =<extra_id_5>] = v<extra_id_6>= d.reduce(lambda x,<extra_id_7>, k =<extra_id_8>:<extra_id_9>= min_cost return<extra_id_10>min_cost =<extra_id_11>min_cost, pq[:v]<extra_id_12>: m [<extra_id_13>] , pq [ 3<extra_id_14>, n<extra_id_15>sax = j if<extra_id_16>, k<extra_id_17>] -<extra_id_18>) # Use the<extra_id_19>(m),<extra_id_20>) permutations from collections import defaultdict import heapq def dijkstra(graph, start, end, avoid_set): \"\"\"Find  avoid_set\"\"\" dist = defaultdict(lambda: float('inf')) dist[start] =  = heapq.heappop(pq) if d > dist[u]:  w in  w < dist[v]: dist[v] = dist[u]  return float('inf') def solve(m,  # Build graph  t,  float('inf') # Try all subsets of cake  1): for perm in permutations(cake_shops, r): # For this permutation,  visited shops visited_shops = set() current  shortest   dijkstra(graph, current,  float('inf'): valid =  visited_shops.add(shop) # Eat cake at this shop  total_calories += calories[shop_idx] current = shop if  avoiding visited shops dist  continue total_distance   return min_cost def main():  if not line: break m, n, k, d =  0 and  == 0 and d == 0: break calories = list(map(int,  _ in range(d): parts =   n, k, d, calories,  \"__main__\": main()"], "perturbed_original": ["from itertools import   = 10  n): if s == \"H\": return  return 1 if s[0] == \"C\":  s[0] ==  m, n, edges): cost = [INF] * (m + n + 2) cost[start]  heappop(que) for dist, to in edges[node]: if cost[to] > total + dist: cost[to]  <=  + dist,   if (start, rest)   in rest:  tuple((i for i in rest if i != to)), cakes_dist, dic) + cakes_dist[start][to]) dic[(start, rest)]  True: m, n, k, d = map(int, input().split()) if m == 0: break clst = list(map(int, input().split()))   3, ...  m  ...   _ in range(m  t, e  2): cost = get_cost(start, m, n, edges) for to in  cost[to]"], "original_ll": -0.9437721371650696, "sampled_ll": -0.7794063091278076, "all_perturbed_sampled_ll": [-3.126864433288574], "all_perturbed_original_ll": [-3.1623146533966064], "perturbed_sampled_ll": -3.126864433288574, "perturbed_original_ll": -3.1623146533966064, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "/*\nAizuOnline A0225\nTitle\n@kankichi573\n*/\n#include <stdio.h>\n// Select Below\n//#include <stdlib.h>\n#include <string.h>\n//#include <float.h>\n//#include <math.h>\n//#include <limits.h>\n//Global data section\nint n;\nint dir[26];     // in +1 out -1\nint alpha[26];   // tunagatte iruka\nchar buf[33];\nchar con[26][26];  //char a->b connection\nchar con_flag[26]; \n//\nint count_char()\n{\n        int i,cnt=0;\n\n        for(i=0;i<26;i++)\n        {\n                if (alpha[i])\n                {\n                        cnt ++;\n                        //printf(\"CH %c\\n\",'a'+i);\n                }\n        }\n        return(cnt);\n}\nint find_first()\n{\n        int i,cnt=0;\n\n        for(i=0;i<26;i++)\n                if(alpha[i]>0)\n                        return(i);\n        return(-1);\n}\n\nint connected()\n{\n        int from;\n\n        from=find_first();\n        //printf(\"FF=%c\\n\",'a'+from);\n        con_flag[from]=1;\n        return(connected2(from));\n}\nint connected2(int node)\n{\n        int i;\n        int cnt=1;\n        //printf(\"CN2=%c\\n\",'a'+node);\n\n        for(i=0;i<26;i++)\n        {\n                if(i==node)\n                        continue;\n                if(con[node][i] && !con_flag[i])\n                {\n                        //printf(\"CN2_2=%c\\n\",'a'+i);\n\n                        con_flag[i]=1;\n                        cnt += connected2(i);\n                        con_flag[i]=0;\n                }\n        }\n        return(cnt);\n}\nmain()\n{\n        int i,j;\n        int stt,end,ret,ret1;\n        while(EOF!=scanf(\"%d\",&n) && n)\n        {\n                for(i=0;i<26;i++)\n                {\n                        alpha[i]=0;\n                        dir[i]=0;\n                        con_flag[i]=0;\n                        for(j=0;j<26;j++)\n                                con[i][j]=0;\n                }\n                for(i=0;i<n;i++)\n                {\n                        scanf(\"%s\",buf);\n                        stt=buf[0]-'a';\n                        end=buf[strlen(buf)-1]-'a';\n                        dir[stt]++;\n                        dir[end]--;\n                        alpha[stt]=alpha[end]=1;\n                        con[stt][end]=1;\n                }\n\n                ret=connected();   // saisho ni toujou suru\n                                   //node to tunagatte iru suu\n                ret1=count_char(); // node no kazu\n\n                //printf(\"r=%d %d\\n\",ret,ret1);\n\n                if(ret != ret1)   // subeteno node ga tunagaruka\n                {\n                        printf(\"NG\\n\");\n                        continue;\n                }\n\n                for(i=0;i<26;i++) //zenbu guuten ka siraberu\n                        if(dir[i])\n                        {\n                                printf(\"NG\\n\");\n                                goto NEXT;\n                        }\n                printf(\"OK\\n\");\n        NEXT:\n                ;\n        }\nreturn(0);\n}", "sampled": "#include <stdio.h>\n#include <string.h>\n\nint main() {\n    int n;\n    while (scanf(\"%d\", &n) == 1 && n != 0) {\n        char words[10000][33];\n        int first[10000], last[10000];\n        \n        for (int i = 0; i < n; i++) {\n            scanf(\"%s\", words[i]);\n            first[i] = words[i][0] - 'a';\n            last[i] = words[i][strlen(words[i]) - 1] - 'a';\n        }\n        \n        int in_degree[26] = {0};\n        int out_degree[26] = {0};\n        int char_used[26] = {0};\n        \n        for (int i = 0; i < n; i++) {\n            out_degree[first[i]]++;\n            in_degree[last[i]]++;\n            char_used[first[i]] = 1;\n            char_used[last[i]] = 1;\n        }\n        \n        int start_count = 0;\n        int end_count = 0;\n        int ok = 1;\n        \n        for (int i = 0; i < 26; i++) {\n            if (out_degree[i] - in_degree[i] == 1) {\n                start_count++;\n            } else if (in_degree[i] - out_degree[i] == 1) {\n                end_count++;\n            } else if (in_degree[i] != out_degree[i]) {\n                ok = 0;\n                break;\n            }\n        }\n        \n        if (ok) {\n            if (!((start_count == 0 && end_count == 0) || (start_count == 1 && end_count == 1))) {\n                ok = 0;\n            }\n        }\n        \n        if (ok) {\n            int adj[26][26] = {0};\n            for (int i = 0; i < n; i++) {\n                adj[first[i]][last[i]] = 1;\n            }\n            \n            int visited[26] = {0};\n            int start_node = -1;\n            for (int i = 0; i < 26; i++) {\n                if (char_used[i]) {\n                    start_node = i;\n                    break;\n                }\n            }\n            \n            int stack[26];\n            int top = 0;\n            stack[top++] = start_node;\n            visited[start_node] = 1;\n            \n            while (top > 0) {\n                int node = stack[--top];\n                for (int i = 0; i < 26; i++) {\n                    if ((adj[node][i] || adj[i][node]) && !visited[i]) {\n                        visited[i] = 1;\n                        stack[top++] = i;\n                    }\n                }\n            }\n            \n            for (int i = 0; i < 26; i++) {\n                if (char_used[i] && !visited[i]) {\n                    ok = 0;\n                    break;\n                }\n            }\n        }\n        \n        printf(\"%s\\n\", ok ? \"OK\" : \"NG\");\n    }\n    return 0;\n}\n", "perturbed_sampled": ["#include <stdio.h> #include  n; while (scanf(\"%d\", &n) == 1 && n != 0) { char words[10000][33]; int first[10000], last[10000];  { scanf(\"%s\",  -  char_used[26] = {0}; for  < n; i++) { out_degree[first[i]]++; in_degree[last[i]]++; char_used[first[i]] = 1; char_used[last[i]]  = 1; for (int i = 0;  if (out_degree[i] - in_degree[i] == 1) { start_count++; } else if  == 0) || (start_count == 1 && end_count == 1))) { ok =  = 1; } int visited[26] = {0}; int start_node = -1; for (int i  i++) {   stack[26];  =  i++) { if ((adj[node][i] || adj[i][node]) && !visited[i])  = i; } }   { if (char_used[i]  0; break; } } } printf(\"%s\\n\", ok ?  0; }"], "perturbed_original": [" #include <string.h> //#include <float.h>  data section    if (alpha[i]) { cnt ++; //printf(\"CH  i,cnt=0; for(i=0;i<26;i++) if(alpha[i]>0) return(i); return(-1); } int connected() { int from; from=find_first(); //printf(\"FF=%c\\n\",'a'+from); con_flag[from]=1; return(connected2(from));  int i; int cnt=1; //printf(\"CN2=%c\\n\",'a'+node); for(i=0;i<26;i++) {  { //printf(\"CN2_2=%c\\n\",'a'+i); con_flag[i]=1; cnt += connected2(i); con_flag[i]=0;   while(EOF!=scanf(\"%d\",&n) && n) {  { scanf(\"%s\",buf); stt=buf[0]-'a'; end=buf[strlen(buf)-1]-'a'; dir[stt]++; dir[end]--; alpha[stt]=alpha[end]=1; con[stt][end]=1;  //printf(\"r=%d %d\\n\",ret,ret1); if(ret != ret1) // subeteno  guuten ka siraberu if(dir[i]) { printf(\"NG\\n\");  ; } return(0); }"], "original_ll": -1.6619365215301514, "sampled_ll": -0.42779767513275146, "all_perturbed_sampled_ll": [-2.189462184906006], "all_perturbed_original_ll": [-2.7313830852508545], "perturbed_sampled_ll": -2.189462184906006, "perturbed_original_ll": -2.7313830852508545, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.List;\nimport java.util.Scanner;\n\npublic class Main {\n\t\n\tvoid run() {\n\n\t\tScanner in = new Scanner(System.in);\n\n\t\twhile(true) {\n\n\t\t\tint N = Integer.parseInt(in.next());\n\t\t\t\n\t\t\tif (N == 0) break;\n\t\t\t\n\t\t\tList<String> wordList = new ArrayList<String>();\n\t\t\t\n\t\t\tfor(int i = 0; i < N; i++) {\n\t\t\t\tString word = in.next();\n\t\t\t\twordList.add(word.substring(0, 1));\n\t\t\t\twordList.add(word.substring(word.length() - 1, word.length()));\n\t\t\t}\n\t\t\t\n\t\t\tCollections.sort(wordList);\n\t\t\t\n\t\t\tif(check(wordList)) {\n\t\t\t\tSystem.out.println(\"OK\");\n\t\t\t} else {\n\t\t\t\tSystem.out.println(\"NG\");\n\t\t\t}\n\t\t}\n\t}\n\t\n\tboolean check(List<String> wordList) {\n\t\t\n\t\tint count = 1;\n\t\tString word1 = wordList.get(0);\n\t\tfor(int i = 1; i < wordList.size(); i++) {\n\t\t\tString word2 = wordList.get(i);\n\t\t\tif(word1.equals(word2)) { \n\t\t\t\tcount++; \n\t\t\t} else {\n\t\t\t\tif(count % 2 != 0) return false;\n\t\t\t\tword1 = word2;\n\t\t\t\tcount = 1;\n\t\t\t}\n\t\t}\n\t\tif(count % 2 != 0) { \n\t\t\treturn false;\n\t\t} else {\n\t\t\treturn true;\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n\n}", "sampled": "import java.util.*;\n\npublic class Main {\n    static Map<Character, List<String>> startMap;\n    static Map<Character, List<String>> endMap;\n    static Set<String> used;\n    static List<String> words;\n    static int n;\n    \n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        \n        while (true) {\n            n = sc.nextInt();\n            if (n == 0) break;\n            \n            words = new ArrayList<>();\n            startMap = new HashMap<>();\n            endMap = new HashMap<>();\n            \n            for (int i = 0; i < n; i++) {\n                String word = sc.next();\n                words.add(word);\n                \n                char start = word.charAt(0);\n                char end = word.charAt(word.length() - 1);\n                \n                startMap.putIfAbsent(start, new ArrayList<>());\n                startMap.get(start).add(word);\n                \n                endMap.putIfAbsent(end, new ArrayList<>());\n                endMap.get(end).add(word);\n            }\n            \n            boolean found = false;\n            for (String firstWord : words) {\n                used = new HashSet<>();\n                used.add(firstWord);\n                char startChar = firstWord.charAt(0);\n                char endChar = firstWord.charAt(firstWord.length() - 1);\n                \n                if (dfs(endChar, startChar, 1)) {\n                    found = true;\n                    break;\n                }\n            }\n            \n            System.out.println(found ? \"OK\" : \"NG\");\n        }\n        \n        sc.close();\n    }\n    \n    static boolean dfs(char currentEnd, char targetStart, int count) {\n        if (count == n) {\n            return currentEnd == targetStart;\n        }\n        \n        if (!startMap.containsKey(currentEnd)) {\n            return false;\n        }\n        \n        for (String word : startMap.get(currentEnd)) {\n            if (!used.contains(word)) {\n                used.add(word);\n                char nextEnd = word.charAt(word.length() - 1);\n                if (dfs(nextEnd, targetStart, count + 1)) {\n                    return true;\n                }\n                used.remove(word);\n            }\n        }\n        \n        return false;\n    }\n}\n", "perturbed_sampled": [" startMap; static Map<Character, List<String>>  List<String> words; static int n; public static void  = new Scanner(System.in); while (true)  startMap = new HashMap<>(); endMap =  = 0; i <  endMap.get(end).add(word); } boolean found  : words) { used = new HashSet<>(); used.add(firstWord); char  =  : \"NG\"); } sc.close(); }   return currentEnd == targetStart; }  } for (String word : startMap.get(currentEnd)) { if (!used.contains(word)) {  - 1);  } used.remove(word); } } return false; } }"], "perturbed_original": ["import java.util.ArrayList; import java.util.Collections;   int N = Integer.parseInt(in.next());  List<String> wordList = new  {  1)); wordList.add(word.substring(word.length()  else { System.out.println(\"NG\"); }  { int count  wordList.get(0); for(int i = 1; i < wordList.size();  wordList.get(i); if(word1.equals(word2)) { count++; }  word1   != 0) {  return true; }  args) { new Main().run(); } }"], "original_ll": -0.6098966002464294, "sampled_ll": -0.4669997990131378, "all_perturbed_sampled_ll": [-2.9690539836883545], "all_perturbed_original_ll": [-2.6153180599212646], "perturbed_sampled_ll": -2.9690539836883545, "perturbed_original_ll": -2.6153180599212646, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "from collections import defaultdict\nwhile True:\n    try:\n        n=input()\n    except SyntaxError:\n        pass\n    if n==0:break\n    dic=defaultdict(int)\n    for i in range(n):\n        w=raw_input()\n        dic[w[0]]+=1\n        dic[w[-1]]+=1\n    if len(set(dic.values()))==1:\n        print \"OK\"\n    else:\n        print \"NG\"", "sampled": "import sys\nfrom collections import defaultdict, deque\n\ndef can_form_shiritori(words):\n    if len(words) == 1:\n        return words[0][0] == words[0][-1]\n    \n    # Build graph of first and last characters\n    graph = defaultdict(list)\n    in_degree = defaultdict(int)\n    out_degree = defaultdict(int)\n    \n    for word in words:\n        first = word[0]\n        last = word[-1]\n        graph[first].append(last)\n        out_degree[first] += 1\n        in_degree[last] += 1\n    \n    # Get all vertices\n    vertices = set(in_degree.keys()) | set(out_degree.keys())\n    \n    # Check if Eulerian circuit exists\n    # For Eulerian circuit: in_degree == out_degree for all vertices\n    for v in vertices:\n        if in_degree[v] != out_degree[v]:\n            return False\n    \n    # Check if graph is connected (considering it as undirected for connectivity)\n    # We need to check if all edges form one connected component\n    if not vertices:\n        return True\n    \n    # Build undirected graph for connectivity check\n    undirected = defaultdict(set)\n    for word in words:\n        first = word[0]\n        last = word[-1]\n        undirected[first].add(last)\n        undirected[last].add(first)\n    \n    # BFS to check connectivity\n    start = next(iter(vertices))\n    visited = set()\n    queue = deque([start])\n    visited.add(start)\n    \n    while queue:\n        node = queue.popleft()\n        for neighbor in undirected[node]:\n            if neighbor not in visited:\n                visited.add(neighbor)\n                queue.append(neighbor)\n    \n    # Check if all vertices with non-zero degree are visited\n    return len(visited) == len(vertices)\n\nwhile True:\n    n = int(input())\n    if n == 0:\n        break\n    \n    words = []\n    for _ in range(n):\n        words.append(input().strip())\n    \n    if can_form_shiritori(words):\n        print(\"OK\")\n    else:\n        print(\"NG\")\n", "perturbed_sampled": [" defaultdict, deque def  return words[0][0] == words[0][-1] # Build   last = word[-1]  all  set(out_degree.keys()) # Check if Eulerian circuit exists   for v in vertices: if in_degree[v]  Check if graph is connected  connectivity) # We need to check if all edges form one  return True #  check undirected  last = word[-1]  queue.popleft() for neighbor in undirected[node]: if neighbor not  Check if all  len(vertices) while True:  = [] for _ in range(n): words.append(input().strip()) if can_form_shiritori(words): print(\"OK\") else: print(\"NG\")"], "perturbed_original": ["from collections import defaultdict while True: try: n=input() except SyntaxError: pass  \"OK\" else: print \"NG\""], "original_ll": -1.2103073596954346, "sampled_ll": -0.7851046323776245, "all_perturbed_sampled_ll": [-3.485804319381714], "all_perturbed_original_ll": [-3.24588680267334], "perturbed_sampled_ll": -3.485804319381714, "perturbed_original_ll": -3.24588680267334, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "#include<string.h>\n#include<stdio.h>\nint main()\n{\n\tint h,b,i,j;\n\tchar r[5],a[5];\n\twhile(1){\n\t\tscanf(\"%s %s\",r,a);\n\t\tif(strcmp(r,\"0\")==0&&strcmp(a,\"0\")==0){\n\t\t\tbreak;\n\t\t}\n\t\th=0;\n\t\tb=0;\n\t\tfor(i=0;i<4;i++){\n\t\t\tif(r[i]==a[i]){\n\t\t\t\th++;\n\t\t\t\tr[i]='r';\n\t\t\t\ta[i]='a';\n\t\t\t}\n\t\t}\n\t\tfor(i=0;i<4;i++){\n\t\t\tfor(j=0;j<4;j++){\n\t\t\t\tif(r[i]==a[j]){\n\t\t\t\t\tb++;\n\t\t\t\t\tr[i]='r';\n\t\t\t\t\ta[j]='a';\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d %d\\n\",h,b);\n\t}\n\treturn 0;\n}", "sampled": "#include <stdio.h>\n#include <string.h>\n\nint main() {\n    char r[5], a[5];\n    \n    while (1) {\n        scanf(\"%s %s\", r, a);\n        \n        if (strcmp(r, \"0\") == 0 && strcmp(a, \"0\") == 0) {\n            break;\n        }\n        \n        int hit = 0, blow = 0;\n        \n        // Count hits\n        for (int i = 0; i < 4; i++) {\n            if (r[i] == a[i]) {\n                hit++;\n            }\n        }\n        \n        // Count blows\n        for (int i = 0; i < 4; i++) {\n            for (int j = 0; j < 4; j++) {\n                if (i != j && r[i] == a[j]) {\n                    blow++;\n                }\n            }\n        }\n        \n        printf(\"%d %d\\n\", hit, blow);\n    }\n    \n    return 0;\n}\n", "perturbed_sampled": ["#include <stdio.h> #include )<extra_id_6>{ printf(\"%d [%s.%2d]\\n\", hit,<extra_id_7>d();<extra_id_8>(int i<extra_id_9>%1d.%2d.%2d\\n\",<extra_id_10>d);<extra_id_11>{<extra_id_12>; } //<extra_id_13>//<extra_id_14>#include <stdio.m> <s> int<extra_id_15>( int<extra_id_16>{<extra_id_17>{ printf(\"%s [% r[5], a[5]; while (1) { scanf(\"%s %s\",  break; } int  0; // Count hits for (int i =  for (int i = 0; i < 4; i++)  0;  } printf(\"%d %d\\n\", hit, blow); } return 0; }"], "perturbed_original": ["  scanf(\"%s %s\",r,a); if(strcmp(r,\"0\")==0&&strcmp(a,\"0\")==0){ break; } h=0;  for(j=0;j<4;j++){ if(r[i]==a[j]){ b++; r[i]='r'; a[j]='a'; }  return 0; }"], "original_ll": -0.7700193524360657, "sampled_ll": -0.5035959482192993, "all_perturbed_sampled_ll": [-2.7519564628601074], "all_perturbed_original_ll": [-2.205625057220459], "perturbed_sampled_ll": -2.7519564628601074, "perturbed_original_ll": -2.205625057220459, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import java.util.*;\n\nclass Main{\n\tpublic static void main(String args[]){\n\t\tScanner s=new Scanner (System.in);\n\t\twhile(true){\n\t\t\tString a=s.next();\n\t\t\tString b=s.next();\n\t\t\tif(a.length()==1)System.exit(0);\n\t\t\tint hit=0;\n\t\t\tfor(int i=0;i<4;i++)if(a.charAt(i)==b.charAt(i))hit++;\n\t\t\tint blow=0;\n\t\t\tfor(int i=0;i<4;i++)\n\t\t\t\tfor(int j=0;j<4;j++)\n\t\t\t\t\tif(a.charAt(i)==b.charAt(j)&&i!=j)blow++;\n\t\t\tSystem.out.println(hit+\" \"+blow);\n\t\t}\n\t}\n}", "sampled": "import java.util.Scanner;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        \n        while (true) {\n            String r = sc.next();\n            String a = sc.next();\n            \n            if (r.equals(\"0\") && a.equals(\"0\")) {\n                break;\n            }\n            \n            int hits = 0;\n            int blows = 0;\n            \n            // Count hits\n            for (int i = 0; i < 4; i++) {\n                if (r.charAt(i) == a.charAt(i)) {\n                    hits++;\n                }\n            }\n            \n            // Count blows\n            for (int i = 0; i < 4; i++) {\n                for (int j = 0; j < 4; j++) {\n                    if (i != j && r.charAt(i) == a.charAt(j)) {\n                        blows++;\n                    }\n                }\n            }\n            \n            System.out.println(hits + \" \" + blows);\n        }\n        \n        sc.close();\n    }\n}\n", "perturbed_sampled": ["import java.util.Scanner;  static void main(String[] args) { Scanner sc =  { break; }  blows   i < 4; i++)  // Count blows for (int i = 0; i <   4; j++) { if (i != j && r.charAt(i) == a.charAt(j)) {  }"], "perturbed_original": ["import java.util.*; class Main{ public static void main(String args[]){ Scanner s=new Scanner (System.in);  System.out.println(hit+\" \"+blow); } } }"], "original_ll": -0.9533368945121765, "sampled_ll": -0.4721856713294983, "all_perturbed_sampled_ll": [-2.934582471847534], "all_perturbed_original_ll": [-2.54665470123291], "perturbed_sampled_ll": -2.934582471847534, "perturbed_original_ll": -2.54665470123291, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "while True:\n    a,b=raw_input().split()\n    if a==b==\"0\":break\n    hit,blow=0,0\n    for i,j in zip(a,b):\n        if i==j:\n            hit+=1\n    for i in a:\n        if i in b:\n            blow+=1\n    print hit,blow-hit", "sampled": "import sys\n\nfor line in sys.stdin:\n    parts = line.strip().split()\n    if len(parts) < 2:\n        continue\n    r, a = parts[0], parts[1]\n    if r == '0' and a == '0':\n        break\n    \n    hits = 0\n    blows = 0\n    \n    for i in range(4):\n        if r[i] == a[i]:\n            hits += 1\n    \n    for i in range(4):\n        if r[i] != a[i]:\n            for j in range(4):\n                if i != j and r[i] == a[j] and r[j] != a[j]:\n                    blows += 1\n                    break\n    \n    print(hits, blows)\n", "perturbed_sampled": [" sys.stdin: parts = line.strip().split() if len(parts) < 2: continue  if r == '0' and a  0  in range(4): if r[i] == a[i]:  != j and r[i]   print(hits, blows)"], "perturbed_original": ["while  i in a: if i in b: blow+=1 print hit,blow-hit"], "original_ll": -1.261081337928772, "sampled_ll": -0.9217848181724548, "all_perturbed_sampled_ll": [-3.8071346282958984], "all_perturbed_original_ll": [-4.810972690582275], "perturbed_sampled_ll": -3.8071346282958984, "perturbed_original_ll": -4.810972690582275, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "n,m,i,p[1000],P;\n//M(int*a){return*1[&a]-*a;}\nM(int*a,int*b){return*b-*a;}\nmain(){\n\tfor(;scanf(\"%d%d\",&n,&m),n;){\n\t\tfor(i=0;i<n;i++){\n\t\t\tscanf(\"%d\",p+i);\n\t\t}\n\t\tqsort(p,n,4,M);\n\t\tP=0;\n\t\tfor(i=0;i<n;i++){\n\t\t\tif(i%m!=m-1)\n\t\t\t\tP+=p[i];\n\t\t}\n\t\tprintf(\"%d\\n\",P);\n\t}\n\texit(0);\n}", "sampled": "#include <stdio.h>\n#include <stdlib.h>\n\nint compare(const void *a, const void *b) {\n    return (*(int*)b - *(int*)a);\n}\n\nint main() {\n    int n, m;\n    \n    while(1) {\n        scanf(\"%d %d\", &n, &m);\n        if(n == 0 && m == 0) break;\n        \n        int prices[1000];\n        for(int i = 0; i < n; i++) {\n            scanf(\"%d\", &prices[i]);\n        }\n        \n        qsort(prices, n, sizeof(int), compare);\n        \n        int total = 0;\n        int count = 0;\n        \n        for(int i = 0; i < n; i++) {\n            count++;\n            if(count == m) {\n                count = 0;\n            } else {\n                total += prices[i];\n            }\n        }\n        \n        printf(\"%d\\n\", total);\n    }\n    \n    return 0;\n}\n", "perturbed_sampled": ["#include <stdio.h>  *a,  (*(int*)b - *(int*)a); } int  while(1) { scanf(\"%d  0 && m == 0) break;  0; i < n; i++) { scanf(\"%d\", &prices[i]); }  count++; if(count   printf(\"%d\\n\", total); } return 0; }"], "perturbed_original": ["n,m,i,p[1000],P; //M(int*a){return*1[&a]-*a;} M(int*a,int*b){return*b-*a;} main(){  } printf(\"%d\\n\",P); } exit(0); }"], "original_ll": -1.7378989458084106, "sampled_ll": -0.5420929193496704, "all_perturbed_sampled_ll": [-2.9764974117279053], "all_perturbed_original_ll": [-3.387784719467163], "perturbed_sampled_ll": -2.9764974117279053, "perturbed_original_ll": -3.387784719467163, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "\nimport java.io.IOException;\nimport java.util.Arrays;\nimport java.util.Scanner;\n\npublic class Main {\n\n\tpublic static void main(String[] args) throws IOException {\n\t\tnew Main().run();\n\t}\n\n\tprivate void run() throws IOException {\n\t\tScanner scanner = new Scanner(System.in);\n\t\twhile (true) {\n\t\t\tint n = scanner.nextInt();\n\t\t\tint m = scanner.nextInt();\n\t\t\tif ((n | m) == 0)\n\t\t\t\tbreak;\n\t\t\tint[] num = new int[n];\n\t\t\tint sum = 0;\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tnum[i] = scanner.nextInt();\n\t\t\t\tsum += num[i];\n\t\t\t}\n\t\t\tint mod = n % m;\n\t\t\tArrays.sort(num);\n\n\t\t\tfor (int i = mod; i < n; i += m) {\n\t\t\t\tsum -= num[i];\n\t\t\t}\n\t\t\tSystem.out.println(sum);\n\t\t}\n\t}\n}", "sampled": "import java.util.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        \n        while (true) {\n            int n = sc.nextInt();\n            int m = sc.nextInt();\n            \n            if (n == 0 && m == 0) {\n                break;\n            }\n            \n            Integer[] prices = new Integer[n];\n            for (int i = 0; i < n; i++) {\n                prices[i] = sc.nextInt();\n            }\n            \n            // Sort in descending order to maximize discount\n            Arrays.sort(prices, Collections.reverseOrder());\n            \n            int totalCost = 0;\n            \n            // Process full bags of m items\n            for (int i = 0; i < n; i++) {\n                // Every m-th item (0-indexed: m-1, 2m-1, 3m-1, ...) is free\n                if ((i + 1) % m == 0) {\n                    // This item is free (cheapest in its bag)\n                    continue;\n                }\n                totalCost += prices[i];\n            }\n            \n            System.out.println(totalCost);\n        }\n        \n        sc.close();\n    }\n}\n", "perturbed_sampled": ["import java.util.*; public class Main { public static void main(String[] args) { Scanner sc  0 && m  Integer[n]; for (int i = 0;  prices[i]  maximize discount Arrays.sort(prices, Collections.reverseOrder()); int totalCost = 0;  m items for    0)  free (cheapest in its bag) continue;  System.out.println(totalCost); } sc.close(); } }"], "perturbed_original": ["import java.io.IOException; import java.util.Arrays;  { public static void  new Main().run(); } private void run()  new int[n]; int   n; i++) { num[i] = scanner.nextInt(); sum += num[i];  (int i = mod; i  { sum -= num[i]; } System.out.println(sum); } } }"], "original_ll": -0.7017500996589661, "sampled_ll": -0.8482555150985718, "all_perturbed_sampled_ll": [-3.073187828063965], "all_perturbed_original_ll": [-2.9529306888580322], "perturbed_sampled_ll": -3.073187828063965, "perturbed_original_ll": -2.9529306888580322, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "while True:\n    a = raw_input()\n    print 'a'", "sampled": "import sys\n\ndef solve(n, m, prices):\n    # Sort prices in descending order\n    prices.sort(reverse=True)\n    \n    total = 0\n    i = 0\n    \n    while i < n:\n        # Take up to m items for this bag\n        bag_size = min(m, n - i)\n        \n        if bag_size == m:\n            # Full bag - the cheapest (last) item is free\n            for j in range(bag_size - 1):\n                total += prices[i + j]\n            # prices[i + bag_size - 1] is free (the cheapest in this bag)\n        else:\n            # Incomplete bag - no discount\n            for j in range(bag_size):\n                total += prices[i + j]\n        \n        i += bag_size\n    \n    return total\n\n# Read input\nlines = []\nfor line in sys.stdin:\n    lines.append(line.strip())\n\ni = 0\nwhile i < len(lines):\n    parts = lines[i].split()\n    n, m = int(parts[0]), int(parts[1])\n    \n    if n == 0 and m == 0:\n        break\n    \n    i += 1\n    prices = list(map(int, lines[i].split()))\n    i += 1\n    \n    result = solve(n, m, prices)\n    print(result)\n", "perturbed_sampled": ["import  # Sort prices in descending order prices.sort(reverse=True)  0 while  up to m items for this bag bag_size = min(m, n - i)  Full bag  in range(bag_size - 1):  # prices[i +  (the cheapest in this bag)  no discount for j  +   in sys.stdin:  n   i += 1 result = solve(n, m, prices) print(result)"], "perturbed_original": ["while True: a = raw_input() print 'a'"], "original_ll": -2.5658493041992188, "sampled_ll": -0.9757249355316162, "all_perturbed_sampled_ll": [-4.07014274597168], "all_perturbed_original_ll": [-3.257502794265747], "perturbed_sampled_ll": -4.07014274597168, "perturbed_original_ll": -3.257502794265747, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "#include<stdio.h>\n\nint main(){\n  int i,j,n,num,prev;\n  char segment[]=\"0000000\";\n  char nums[][8]={\"0111111\",\"0000110\",\"1011011\",\"1001111\",\n\t\t  \"1100110\",\"1101101\",\"1111101\",\"0100111\",\n\t\t  \"1111111\",\"1101111\",\"0000000\"};\n  do{\n    scanf(\"%d\",&n);\n    if(n==-1) break;\n    for(prev=10,i=0;i<n;i++,prev=num){\n      scanf(\"%d\",&num);\n      for(j=0;j<7;j++){\n\tif(nums[prev][j]==nums[num][j]){\n\t  segment[j]='0';\n\t}else{\n\t  segment[j]='1';\n\t}\n      }\n      printf(\"%s\\n\",segment);\n    }\n  }while(1);\n  return 0;\n}", "sampled": "#include <stdio.h>\n\nint main() {\n    int segments[10] = {\n        0b0111111,  // 0\n        0b0000110,  // 1\n        0b1011011,  // 2\n        0b1001111,  // 3\n        0b1100110,  // 4\n        0b1101101,  // 5\n        0b1111101,  // 6\n        0b0000111,  // 7\n        0b1111111,  // 8\n        0b1101111   // 9\n    };\n    \n    int n;\n    while (scanf(\"%d\", &n) == 1 && n != -1) {\n        int current = 0;  // Initial state: all segments off\n        \n        for (int i = 0; i < n; i++) {\n            int digit;\n            scanf(\"%d\", &digit);\n            \n            int target = segments[digit];\n            int signal = current ^ target;  // XOR to get the toggle bits\n            \n            // Print signal in binary (7 bits, from bit 6 to bit 0)\n            for (int j = 6; j >= 0; j--) {\n                printf(\"%d\", (signal >> j) & 1);\n            }\n            printf(\"\\n\");\n            \n            current = target;  // Update current state\n        }\n    }\n    \n    return 0;\n}\n", "perturbed_sampled": ["#include <stdio.h> int main() { int segments[10] = { 0b0111111, // 0 0b0000110, DL8 5 <extra_id_2>{<extra_id_3>{ s -=<extra_id_4>*<extra_id_5>\"%d\",<extra_id_6>]<extra_id_7>int<extra_id_8>, & digits<extra_id_9>) return<extra_id_10>; m = sig ;<extra_id_11>( s<extra_id_12>, & digits ) ,<extra_id_13>= 0 ;<extra_id_14>; input ; bit =<extra_id_15>*<extra_id_16>m *<extra_id_17>, & digit ) ,<extra_id_18>,<extra_id_19>; continue } } signal<extra_id_20>;<extra_id_21>&digit ) return n<extra_id_22>} bit<extra_id_23>; 0b1101111 //  (scanf(\"%d\", &n) ==  {  Initial state: all segments off for (int i =  { int digit; scanf(\"%d\", &digit); int target = segments[digit]; int signal = current ^ target;  bits,  = 6; j    }"], "perturbed_original": ["#include<stdio.h> int main(){   if(n==-1) break; for(prev=10,i=0;i<n;i++,prev=num){ scanf(\"%d\",&num);  }while(1); return 0; }"], "original_ll": -1.06485915184021, "sampled_ll": -0.7571138739585876, "all_perturbed_sampled_ll": [-2.6576805114746094], "all_perturbed_original_ll": [-2.640881299972534], "perturbed_sampled_ll": -2.6576805114746094, "perturbed_original_ll": -2.640881299972534, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import java.util.*;\n\npublic class Main {\n\tScanner sc = new Scanner(System.in);\n\tString [] digit = {\"0111111\",\"0000110\",\"1011011\",\"1001111\",\"1100110\",\n\t\t\t\"1101101\",\"1111101\", \"0100111\",\"1111111\",\"1101111\"};\n\t\n\tprivate void doit() {\n\t\twhile (true) {\n\t\t\tint n = sc.nextInt();\n\t\t\tif(n == -1) break;\n\t\t\tStringBuilder nowstate = new StringBuilder(\"0000000\");\n\t\t\twhile(n-- > 0){\n\t\t\t\tint num = sc.nextInt();\n\t\t\t\tString numstr = digit[num];\n\t\t\t\tStringBuilder sb = new StringBuilder();\n\t\t\t\tfor(int i = 0; i < numstr.length(); i++){\n\t\t\t\t\tif(numstr.charAt(i) == nowstate.charAt(i)){\n\t\t\t\t\t\tsb.append(0);\n\t\t\t\t\t}\n\t\t\t\t\telse{\n\t\t\t\t\t\tsb.append(1);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tSystem.out.println(sb.toString());\n\t\t\t\tnowstate = new StringBuilder(numstr);\n\t\t\t}\n\t\t}\n\t}\n\n\n\tprivate void debug(Object... o) {\n\t\tSystem.out.println(\"debug = \" + Arrays.deepToString(o));\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().doit();\n\t}\n}", "sampled": "import java.util.Scanner;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        \n        // Define 7-segment patterns for digits 0-9\n        // Pattern is in order: abcdefg (bits 0-6)\n        int[] patterns = {\n            0b0111111, // 0\n            0b0000110, // 1\n            0b1011011, // 2\n            0b1001111, // 3\n            0b1100110, // 4\n            0b1101101, // 5\n            0b1111101, // 6\n            0b0000111, // 7\n            0b1111111, // 8\n            0b1101111  // 9\n        };\n        \n        while (true) {\n            int n = sc.nextInt();\n            if (n == -1) break;\n            \n            int currentState = 0; // Initially all segments are off\n            \n            for (int i = 0; i < n; i++) {\n                int digit = sc.nextInt();\n                int targetState = patterns[digit];\n                \n                // Calculate XOR to get the signal needed\n                int signal = currentState ^ targetState;\n                \n                // Output the signal in reverse bit order (gfedcba)\n                StringBuilder sb = new StringBuilder();\n                for (int bit = 6; bit >= 0; bit--) {\n                    sb.append((signal >> bit) & 1);\n                }\n                System.out.println(sb.toString());\n                \n                // Update current state\n                currentState = targetState;\n            }\n        }\n        \n        sc.close();\n    }\n}\n", "perturbed_sampled": [" sc = new Scanner(System.in); // Define 7-segment patterns for    0b1001111, // 3   }; while (true) { int n = sc.nextInt(); if (n == -1) break; int currentState =  are off for (int i = 0; i < n; i++) {  Calculate XOR to  signal = currentState  =   bit) & 1); } System.out.println(sb.toString()); // Update current state currentState = targetState; } } sc.close(); } }"], "perturbed_original": ["import java.util.*; public <extra_id_9>return null; }<extra_id_10>return<extra_id_11>i=1; }<extra_id_12>} <s> public int<extra_id_13>if<extra_id_14>int (<extra_id_15>) { for ( [] digit =  { int n = sc.nextInt(); if(n == -1) break; StringBuilder nowstate = new StringBuilder(\"0000000\"); while(n-- >  StringBuilder sb = new StringBuilder(); for(int  nowstate.charAt(i)){  } System.out.println(sb.toString()); nowstate = new StringBuilder(numstr);    }"], "original_ll": -1.080339789390564, "sampled_ll": -0.8338609337806702, "all_perturbed_sampled_ll": [-3.1108741760253906], "all_perturbed_original_ll": [-2.889007329940796], "perturbed_sampled_ll": -3.1108741760253906, "perturbed_original_ll": -2.889007329940796, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "# AOJ 0228: Seven Segments\n# Python3 2018.6.25 bal4u\n \np = [[1,1,1,1,1,1,0], [0,1,1,0,0,0,0], [1,1,0,1,1,0,1], [1,1,1,1,0,0,1], [0,1,1,0,0,1,1], \\\n     [1,0,1,1,0,1,1], [1,0,1,1,1,1,1], [1,1,1,0,0,1,0], [1,1,1,1,1,1,1], [1,1,1,1,0,1,1]]\n \nwhile True:\n    n = int(input())\n    if n < 0: break\n    a = [0]*7\n    for i in range(n):\n        d = int(input())\n        ans = ''\n        for j in range(6,-1,-1):\n            k = (a[j] ^ p[d][j]) & 1\n            ans += '1' if k else '0'\n            if k: a[j] = 1-a[j]\n        print(ans)\n", "sampled": "def get_segments(digit):\n    segments = {\n        0: \"0111111\",\n        1: \"0000110\",\n        2: \"1011011\",\n        3: \"1001111\",\n        4: \"1100110\",\n        5: \"1101101\",\n        6: \"1111101\",\n        7: \"0000111\",\n        8: \"1111111\",\n        9: \"1101111\"\n    }\n    return segments[digit]\n\ndef xor_bits(a, b):\n    result = \"\"\n    for i in range(7):\n        if a[i] != b[i]:\n            result += \"1\"\n        else:\n            result += \"0\"\n    return result\n\nwhile True:\n    n = int(input())\n    if n == -1:\n        break\n    \n    current_state = \"0000000\"\n    \n    for _ in range(n):\n        digit = int(input())\n        target_state = get_segments(digit)\n        signal = xor_bits(current_state, target_state)\n        print(signal)\n        current_state = target_state\n", "perturbed_sampled": ["def get_segments(digit): segments = { 0: \"0111111\", 1: \"0000110\", 2:  5:   return segments[digit] def  for i  b[i]: result += \"1\" else:  int(input()) if n == -1:  = int(input()) target_state  target_state"], "perturbed_original": ["# AOJ 0228: Seven  [1,0,1,1,0,1,1],  if n < 0: break a = [0]*7 for i in  (a[j]  += '1' if k else '0' if k: a[j] = 1-a[j] print(ans)"], "original_ll": -1.0168429613113403, "sampled_ll": -0.7302873134613037, "all_perturbed_sampled_ll": [-3.2328293323516846], "all_perturbed_original_ll": [-3.094649314880371], "perturbed_sampled_ll": -3.2328293323516846, "perturbed_original_ll": -3.094649314880371, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "main(b,r,g,c,s,t){for(;~scanf(\"%d%d%d%d%d%d\",&b,&r,&g,&c,&s,&t)&&t;printf(\"%d\\n\",b*95+r*63+g*7+c*2+s*3-t*3+100));}", "sampled": "#include <stdio.h>\n\nint main() {\n    int b, r, g, c, s, t;\n    \n    while (1) {\n        scanf(\"%d %d %d %d %d %d\", &b, &r, &g, &c, &s, &t);\n        \n        if (b == 0 && r == 0 && g == 0 && c == 0 && s == 0 && t == 0) {\n            break;\n        }\n        \n        int medals = 100;\n        \n        // Big bonus games: 5 games each, 2 medals in, 15 medals out per game\n        int big_bonus_games = b * 5;\n        medals += big_bonus_games * (15 - 2);\n        \n        // Regular bonus games: 3 games each, 2 medals in, 15 medals out per game\n        int regular_bonus_games = r * 3;\n        medals += regular_bonus_games * (15 - 2);\n        \n        // Total bonus games\n        int bonus_games = big_bonus_games + regular_bonus_games;\n        \n        // Normal games\n        int normal_games = t - bonus_games;\n        \n        // For normal games, we need to account for:\n        // - Games that triggered bonuses (b + r games, cost 3 medals each, no payout from trigger itself)\n        // - Games with grapes (g games, cost 3 medals, get 15 medals)\n        // - Games with cherries (c games, cost 3 medals, get 3 medals)\n        // - Games with stars (s games, cost 3 medals first time, get 0 medals but next game is free)\n        // - Games that got nothing\n        \n        // Star games: first star costs 3, gets 0, then next game is free (costs 0)\n        // So s stars means s games cost 3 medals and s games cost 0 medals\n        // But we need to be careful about counting\n        \n        // Actually, let's think differently:\n        // - b games triggered big bonus: cost 3, no payout\n        // - r games triggered regular bonus: cost 3, no payout\n        // - g games got grapes: cost 3, payout 15\n        // - c games got cherries: cost 3, payout 3\n        // - s games got stars: cost 3, payout 0, but next game is free\n        // - remaining games got nothing: cost 3, payout 0\n        \n        // Total normal games played\n        // Some of these are free (after stars)\n        // Games that cost medals: normal_games - s (since s games following a star are free)\n        \n        medals -= (normal_games - s) * 3;  // Cost of normal games (excluding free games after stars)\n        medals += b * 0;  // Big bonus triggers give no payout\n        medals += r * 0;  // Regular bonus triggers give no payout\n        medals += g * 15; // Grape payouts in normal games\n        medals += c * 3;  // Cherry payouts in normal games\n        medals += s * 0;  // Star payouts (none)\n        \n        printf(\"%d\\n\", medals);\n    }\n    \n    return 0;\n}\n", "perturbed_sampled": ["#include  s, t;  %d %d %d %d\", &b,  && r == 0  s == 0  bonus games: 5 games each, 2 medals in, 15 medals out per game int big_bonus_games =  big_bonus_games * (15 -   in, 15 medals out per  2); // Total  Normal games int  we need  Games that triggered bonuses (b  medals each,   (g games, cost  // - Games with cherries (c games, cost 3 medals, get 3 medals) //  first  next game is  (costs 0) // So s stars means s games cost 3 medals and s  be careful about counting  //  bonus: cost 3,  games triggered regular bonus: cost 3,  games got      free  of these are free (after  medals: normal_games - s (since s games following a star are free) medals -= (normal_games - s)  normal    += r *  give  * 15; // Grape payouts in normal games medals += c * 3; // Cherry  printf(\"%d\\n\", medals); } return 0; }"], "perturbed_original": ["main(b,r,g,c,s,t){for(;~scanf(\"%d%d%d%d%d%d\",&b,&r,&g,&c,&s,&t)&&t;printf(\"%d\\n\",b*95+r*63+g*7+c*2+s*3-t*3+100));}"], "original_ll": -2.3237595558166504, "sampled_ll": -1.3557888269424438, "all_perturbed_sampled_ll": [-4.1649675369262695], "all_perturbed_original_ll": [-2.3237595558166504], "perturbed_sampled_ll": -4.1649675369262695, "perturbed_original_ll": -2.3237595558166504, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import java.util.Scanner;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        for(;;) {\n         int b=sc.nextInt()*5,r=sc.nextInt()*3,g=sc.nextInt(),c=sc.nextInt(),s=sc.nextInt(),t=sc.nextInt();\n         if((b|r|g|c|s|t)==0) {\n             break;\n         }\n         System.out.println(100+b+b*18+r+r*20+g*7+c*2-(t-s)*3);\n        }\n    }\n}\n", "sampled": "import java.util.Scanner;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        \n        while (true) {\n            int b = sc.nextInt();\n            int r = sc.nextInt();\n            int g = sc.nextInt();\n            int c = sc.nextInt();\n            int s = sc.nextInt();\n            int t = sc.nextInt();\n            \n            if (b == 0 && r == 0 && g == 0 && c == 0 && s == 0 && t == 0) {\n                break;\n            }\n            \n            int medals = 100;\n            \n            // Big bonus games: 5 games each, spend 2 medals, get 15 medals\n            int bigBonusGames = b * 5;\n            medals += bigBonusGames * (15 - 2);\n            \n            // Regular bonus games: 3 games each, spend 2 medals, get 15 medals\n            int regularBonusGames = r * 3;\n            medals += regularBonusGames * (15 - 2);\n            \n            // Total bonus games\n            int totalBonusGames = bigBonusGames + regularBonusGames;\n            \n            // Normal games\n            int normalGames = t - totalBonusGames;\n            \n            // Calculate medals from normal games\n            // Grape in normal game: spend 3, get 15, net +12\n            medals += g * (15 - 3);\n            \n            // Cherry in normal game: spend 3, get 8, net +5\n            medals += c * (8 - 3);\n            \n            // Star in normal game: spend 3, get 0, but next game is free\n            // Net effect: -3 for star game, +3 for free game = 0\n            // But we need to count that star games are part of normal games\n            \n            // Games that cost 3 medals (normal games minus free games from stars)\n            int paidNormalGames = normalGames - s;\n            \n            // Games where nothing special happened\n            int noWinGames = paidNormalGames - g - c - s;\n            \n            // These games cost 3 medals with no return\n            medals -= noWinGames * 3;\n            \n            System.out.println(medals);\n        }\n        \n        sc.close();\n    }\n}\n", "perturbed_sampled": ["import    Scanner(System.in);  =  int s = sc.nextInt(); int t = sc.nextInt(); if  == 0 && g == 0 && c == 0 && s  0) { break; } int medals   medals int bigBonusGames  +=  // Regular bonus games: 3  get  - 2); // Total  bigBonusGames + regularBonusGames; //  t - totalBonusGames; // Calculate medals from  medals += g * (15 - 3); //   medals += c * (8 - 3); // Star in normal game: spend  // But we need to count that star games are part  (normal games  - s; // Games  g - c - s; // These games cost 3  }"], "perturbed_original": ["import java.util.Scanner;   b=sc.nextInt()*5,r=sc.nextInt()*3,g=sc.nextInt(),c=sc.nextInt(),s=sc.nextInt(),t=sc.nextInt(); if((b|r|g|c|s|t)==0) { break; } System.out.println(100+b+b*18+r+r*20+g*7+c*2-(t-s)*3); } } }"], "original_ll": -1.587196946144104, "sampled_ll": -1.2564232349395752, "all_perturbed_sampled_ll": [-3.5301172733306885], "all_perturbed_original_ll": [-2.498512029647827], "perturbed_sampled_ll": -3.5301172733306885, "perturbed_original_ll": -2.498512029647827, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "while 1:\n    b,r,g,c,s,t=map(int,input().split())\n    if [b,r,g,c,s,t].count(0)==6:break\n    print(100+(b+r)*15+g*7+c*2+(b*5+r*3)*13-(t-(s+b*5+r*3))*3)", "sampled": "while True:\n    line = input().split()\n    b, r, g, c, s, t = map(int, line)\n    \n    if b == 0 and r == 0 and g == 0 and c == 0 and s == 0 and t == 0:\n        break\n    \n    medals = 100\n    \n    # Big bonus games: 5 games each\n    big_bonus_games = b * 5\n    # Regular bonus games: 3 games each\n    regular_bonus_games = r * 3\n    # Total bonus games\n    bonus_games = big_bonus_games + regular_bonus_games\n    # Normal games\n    normal_games = t - bonus_games\n    \n    # Bonus games: spend 2, get 15 (net +13 per game)\n    medals += bonus_games * (15 - 2)\n    \n    # Normal games cost 3 medals each\n    medals -= normal_games * 3\n    \n    # Grape in normal games: get 15\n    medals += g * 15\n    \n    # Cherry in normal games: get 8\n    medals += c * 8\n    \n    # Star games are free (refund 3 medals)\n    medals += s * 3\n    \n    print(medals)\n", "perturbed_sampled": [" s, t =  0 and r   and s == 0 and t == 0:   each big_bonus_games = b * 5  = big_bonus_games + regular_bonus_games # Normal games normal_games = t  (net +13 per game) medals += bonus_games * (15  cost 3 medals each medals -=   medals +=   medals) medals += s * 3 print(medals)"], "perturbed_original": ["while 1: b,r,g,c,s,t=map(int,input().split()) if [b,r,g,c,s,t].count(0)==6:break print(100+(b+r)*15+g*7+c*2+(b*5+r*3)*13-(t-(s+b*5+r*3))*3)"], "original_ll": -2.167511463165283, "sampled_ll": -1.4815173149108887, "all_perturbed_sampled_ll": [-4.305051803588867], "all_perturbed_original_ll": [-2.3913190364837646], "perturbed_sampled_ll": -4.305051803588867, "perturbed_original_ll": -2.3913190364837646, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "short*p,v[][99];main(c,n,m,i,y){for(;m=scanf(\"%d %[^\\n] %[^\\n]\",&n,v,v+1)*n;printf(m>n?\"NA\\n\":\"%d\\n\",m))for(i=2;i--;m=c)for(c=0,y=n;y>1&c<m;y+=y==n|*p&2?2:*p&p[-1]&1?0:!++c-1)p=--y+v[c+i&1];}", "sampled": "#include <stdio.h>\n#include <string.h>\n#include <stdbool.h>\n\n#define MAX_N 101\n#define INF 999999\n\nint n;\nint a[MAX_N], b[MAX_N];\nint ladder_top[2][MAX_N];\nint dist[2][MAX_N];\n\nint process_position(int building, int floor) {\n    if (floor > n) return floor;\n    \n    if (a[floor] == 0 || b[floor] == 0) {\n        int wall = (building == 0) ? a[floor] : b[floor];\n        if (wall == 0) return floor;\n        else if (wall == 1) return ladder_top[building][floor];\n        else return floor;\n    }\n    \n    int wall = (building == 0) ? a[floor] : b[floor];\n    \n    if (wall == 0) {\n        return floor;\n    } else if (wall == 1) {\n        return ladder_top[building][floor];\n    } else {\n        for (int f = floor - 1; f >= 1; f--) {\n            int w = (building == 0) ? a[f] : b[f];\n            if (w == 0) return f;\n            if (w == 1) return ladder_top[building][f];\n        }\n        return 1;\n    }\n}\n\nint main() {\n    while (scanf(\"%d\", &n) && n != 0) {\n        for (int i = 1; i <= n; i++) {\n            scanf(\"%d\", &a[i]);\n        }\n        for (int i = 1; i <= n; i++) {\n            scanf(\"%d\", &b[i]);\n        }\n        \n        for (int building = 0; building < 2; building++) {\n            for (int i = 1; i <= n; i++) {\n                int wall = (building == 0) ? a[i] : b[i];\n                if (wall == 1) {\n                    int top = i;\n                    while (top < n) {\n                        int next_wall = (building == 0) ? a[top + 1] : b[top + 1];\n                        if (next_wall == 1) top++;\n                        else break;\n                    }\n                    ladder_top[building][i] = top;\n                } else {\n                    ladder_top[building][i] = i;\n                }\n            }\n        }\n        \n        for (int i = 0; i < 2; i++) {\n            for (int j = 0; j <= n; j++) {\n                dist[i][j] = INF;\n            }\n        }\n        \n        int queue[MAX_N * 2][2];\n        int front = 0, rear = 0;\n        \n        int pos0 = process_position(0, 1);\n        int pos1 = process_position(1, 1);\n        \n        dist[0][pos0] = 1;\n        queue[rear][0] = 0;\n        queue[rear][1] = pos0;\n        rear++;\n        \n        dist[1][pos1] = 1;\n        queue[rear][0] = 1;\n        queue[rear][1] = pos1;\n        rear++;\n        \n        while (front < rear) {\n            int cur_building = queue[front][0];\n            int cur_floor = queue[front][1];\n            front++;\n            \n            int other_building = 1 - cur_building;\n            \n            for (int delta = 0; delta <= 2; delta++) {\n                int next_floor = cur_floor + delta;\n                int final_floor = process_position(other_building, next_floor);\n                \n                if (final_floor >= 1 && final_floor <= n) {\n                    if (dist[other_building][final_floor] > dist[cur_building][cur_floor] + 1) {\n                        dist[other_building][final_floor] = dist[cur_building][cur_floor] + 1;\n                        queue[rear][0] = other_building;\n                        queue[rear][1] = final_floor;\n                        rear++;\n                    }\n                }\n            }\n        }\n        \n        int result = INF;\n        if (dist[0][n] < result) result = dist[0][n];\n        if (dist[1][n] < result) result = dist[1][n];\n        \n        if (result == INF) {\n            printf(\"NA\\n\");\n        } else {\n            printf(\"%d\\n\", result);\n        }\n    }\n    \n    return 0;\n}\n", "perturbed_sampled": ["#include <stdio.h> #include <string.h> #include <stdbool.h>   (floor > n) return floor; if (a[floor] == 0 || b[floor] == 0) {  0) ? a[floor]  0) return floor; else if (wall == 1) return  ==  else if (wall == 1)  = floor -   == 0) return  return ladder_top[building][f]; } return 1; } } int main() { while  0) { for (int i = 1;  scanf(\"%d\",  = 1; i  &b[i]); } for  < 2; building++) { for (int  wall = (building ==  if (wall == 1)  while (top < n)    top++; else break; } ladder_top[building][i] = top; } else  } } for (int i = 0; i < 2; i++) { for (int j =  = 0, rear = 0;  1);  = pos1; rear++; while (front < rear) {  int other_building = 1 - cur_building;   + delta; int final_floor = process_position(other_building, next_floor); if   {  queue[rear][0]  rear++; }   result = dist[1][n]; if (result ==   return 0; }"], "perturbed_original": ["short*p,v[][99];main(c,n,m,i,y){for(;m=scanf(\"%d %[^\\n] %[^\\n]\",&n,v,v+1)*n;printf(m>n?\"NA\\n\":\"%d\\n\",m))for(i=2;i--;m=c)for(c=0,y=n;y>1&c<m;y+=y==n|*p&2?2:*p&p[-1]&1?0:!++c-1)p=--y+v[c+i&1];}"], "original_ll": -3.7130024433135986, "sampled_ll": -0.5196746587753296, "all_perturbed_sampled_ll": [-2.698331594467163], "all_perturbed_original_ll": [-3.7130024433135986], "perturbed_sampled_ll": -2.698331594467163, "perturbed_original_ll": -3.7130024433135986, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import java.util.HashSet;\nimport java.util.LinkedList;\nimport java.util.Queue;\nimport java.util.Scanner;\nimport java.util.Set;\n\npublic class Main {\n    Scanner sc = new Scanner(System.in);\n\n    void run() {\n        for (;;) {\n            // 1 \u884c\u76ee \u30d3\u30eb\u306e\u968e\u6570 n(\u6574\u6570)\n            // 2 \u884c\u76ee 1 \u3064\u76ee\u306e\u30d3\u30eb a \u306e 1 \u968e\u304b\u3089 n \u968e\u307e\u3067\u306e\u58c1\u306e\u60c5\u5831 a1 a2 ... an(\u3059\u3079\u3066\u6574\u6570;\u534a\u89d2\u7a7a\u767d\u533a\u5207\u308a)\n            // \u5404 ai \u306f\u3001i \u968e\u76ee\u306e\u58c1\u306e\u60c5\u5831\u3092\u8868\u3057\u3001\u610f\u5473\u306f\u4ee5\u4e0b\u306e\u3068\u304a\u308a\u3067\u3059\u3002\n            // 0:\u666e\u901a\u306e\u58c1\n            // 1:\u306f\u3057\u3054(i \u968e\u3068 i+1 \u968e\u306b\u307e\u305f\u304c\u308b)\n            // 2:\u3059\u3079\u308b\u58c1\n            // 3 \u884c\u76ee 2 \u3064\u76ee\u306e\u30d3\u30eb b \u306e 1 \u968e\u304b\u3089 n \u968e\u307e\u3067\u306e\u58c1\u306e\u60c5\u5831 b1 b2 ... bn(\u3059\u3079\u3066\u6574\u6570;\u534a\u89d2\u7a7a\u767d\u533a\u5207\u308a)\n            int n = sc.nextInt();\n            if (n == 0)\n                break;\n            int fs[][] = new int[2][n];\n            for (int i = 0; i < n; i++) {\n                fs[0][i] = sc.nextInt();\n            }\n            for (int i = 0; i < n; i++) {\n                fs[1][i] = sc.nextInt();\n            }\n            Queue<Data> q = new LinkedList<Data>();\n            int sfa = 0;\n            int sfb = 0;\n            if (fs[0][0] == 1)\n                while (sfa + 1 < n && fs[0][sfa + 1] == 1)\n                    sfa++;\n            if (fs[1][0] == 1)\n                while (sfb + 1 < n && fs[1][sfb + 1] == 1)\n                    sfb++;\n            q.add(new Data(0, sfa, 0));\n            q.add(new Data(1, sfb, 0));\n            Set<String> set = new HashSet<String>();\n            boolean na = true;\n            while (!q.isEmpty()) {\n                Data d = q.poll();\n                int b = d.b;\n                int f = d.f;\n                if (set.contains(b + \" \" + f))\n                    continue;\n                set.add(b + \" \" + f);\n                int t = d.t;\n                if (f == n - 1 && fs[b][n - 1] != 2) {\n                    System.out.println(t);\n                    na = false;\n                    break;\n                }\n                int nb = b ^ 1;\n                for (int i = 0; i < 3; i++) {\n                    // \u5411\u304b\u3044\u5074\u306e\u30d3\u30eb\u3078\u30b8\u30e3\u30f3\u30d7\u3059\u308b\u3068\u304d\u306b\u306f\u3001\n                    // \u540c\u3058\u968e\u30fb1\u3064\u4e0a\u306e\u968e\u30fb2 \u3064\u4e0a\u306e\u968e\u306e\u3001\u3044\u305a\u308c\u304b\u306b\u98db\u3073\u79fb\u308b\u3053\u3068\u304c\u3067\u304d\u307e\u3059\u3002\n                    if (i + f >= n)\n                        continue;\n                    int nf = f + i;\n                    switch (fs[nb][i + f]) {\n                    case 0:\n                        q.add(new Data(nb, nf, t + 1));\n                        break;\n                    case 1:\n                        while (nf + 1 < n && fs[nb][nf + 1] == 1)\n                            nf++;\n                        q.add(new Data(nb, nf, t + 1));\n                        break;\n                    case 2:\n                        while (fs[nb][nf] == 2)\n                            nf--;\n                        q.add(new Data(nb, nf, t + 1));\n                        break;\n                    }\n                }\n\n            }\n            if (na)\n                System.out.println(\"NA\");\n        }\n    }\n\n    public static void main(String[] args) {\n        new Main().run();\n    }\n}\n\nclass Data {\n    int b;\n    int f;\n    int t;\n\n    Data(int b, int f, int t) {\n        this.b = b;\n        this.f = f;\n        this.t = t;\n    }\n\n    public String toString() {\n        return b + \" \" + f + \" \" + t;\n    }\n}", "sampled": "import java.util.*;\n\npublic class Main {\n    static class State {\n        int building; // 0 or 1\n        int floor;\n        int jumps;\n        \n        State(int building, int floor, int jumps) {\n            this.building = building;\n            this.floor = floor;\n            this.jumps = jumps;\n        }\n    }\n    \n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        \n        while (true) {\n            int n = sc.nextInt();\n            if (n == 0) break;\n            \n            int[] a = new int[n + 1];\n            int[] b = new int[n + 1];\n            \n            for (int i = 1; i <= n; i++) {\n                a[i] = sc.nextInt();\n            }\n            for (int i = 1; i <= n; i++) {\n                b[i] = sc.nextInt();\n            }\n            \n            int result = solve(n, a, b);\n            if (result == -1) {\n                System.out.println(\"NA\");\n            } else {\n                System.out.println(result);\n            }\n        }\n        sc.close();\n    }\n    \n    static int solve(int n, int[] a, int[] b) {\n        int[][] walls = {a, b};\n        boolean[][] visited = new boolean[2][n + 1];\n        Queue<State> queue = new LinkedList<>();\n        \n        // Start from floor 1 of either building\n        int floor0 = processFloor(0, 1, walls, n);\n        int floor1 = processFloor(1, 1, walls, n);\n        \n        if (floor0 != -1) {\n            queue.add(new State(0, floor0, 0));\n            visited[0][floor0] = true;\n        }\n        if (floor1 != -1) {\n            queue.add(new State(1, floor1, 0));\n            visited[1][floor1] = true;\n        }\n        \n        while (!queue.isEmpty()) {\n            State curr = queue.poll();\n            \n            if (curr.floor == n) {\n                return curr.jumps;\n            }\n            \n            int otherBuilding = 1 - curr.building;\n            \n            // Jump to same floor, +1, or +2\n            for (int delta = 0; delta <= 2; delta++) {\n                int targetFloor = curr.floor + delta;\n                if (targetFloor > n) continue;\n                \n                int finalFloor = processFloor(otherBuilding, targetFloor, walls, n);\n                \n                if (finalFloor != -1 && !visited[otherBuilding][finalFloor]) {\n                    visited[otherBuilding][finalFloor] = true;\n                    queue.add(new State(otherBuilding, finalFloor, curr.jumps + 1));\n                }\n            }\n        }\n        \n        return -1;\n    }\n    \n    static int processFloor(int building, int floor, int[][] walls, int n) {\n        int[] wall = walls[building];\n        \n        if (wall[floor] == 0) {\n            return floor;\n        } else if (wall[floor] == 1) {\n            // Climb ladder to the top\n            int top = floor;\n            while (top < n && wall[top] == 1) {\n                top++;\n            }\n            return top;\n        } else { // wall[floor] == 2\n            // Slide down\n            int slideFloor = floor;\n            while (slideFloor > 1) {\n                slideFloor--;\n                if (wall[slideFloor] == 0) {\n                    return slideFloor;\n                } else if (wall[slideFloor] == 1) {\n                    // Find top of ladder\n                    int top = slideFloor;\n                    while (top < n && wall[top] == 1) {\n                        top++;\n                    }\n                    return top;\n                }\n                // If wall[slideFloor] == 2, continue sliding\n            }\n            // Slid all the way to floor 1 or below, cannot start here\n            return -1;\n        }\n    }\n}\n", "perturbed_sampled": ["  or  = building; this.floor = floor; this.jumps = jumps; } } public static void main(String[] args) { Scanner sc = new Scanner(System.in); while  0) break; int[] a  int[] b = new int[n + 1];   for (int i  sc.nextInt();  a, b); if (result == -1) {  } } sc.close(); } static int solve(int n, int[] a, int[] b) { int[][]   1]; Queue<State> queue = new LinkedList<>(); //  = processFloor(0, 1,  processFloor(1,  State(0, floor0,  if (floor1 != -1) { queue.add(new State(1, floor1, 0));  (!queue.isEmpty())  int otherBuilding = 1  same floor, +1, or  =   = processFloor(otherBuilding, targetFloor, walls, n); if (finalFloor  floor, int[][] walls, int n) { int[] wall = walls[building];  return floor; }  {  1) { top++;  { // wall[floor]  int slideFloor = floor; while (slideFloor  (wall[slideFloor]  }  { // Find top of ladder int top = slideFloor; while (top <  {  2,  floor 1 or  -1; } } }"], "perturbed_original": ["import java.util.HashSet; import java.util.LinkedList; import java.util.Queue; import java.util.Scanner; import java.util.Set; public  run() { for (;;) { // 1 \u884c\u76ee \u30d3\u30eb\u306e\u968e\u6570 n(\u6574\u6570) // 2 \u884c\u76ee 1    \u884c\u76ee 2 \u3064\u76ee\u306e\u30d3\u30eb b   n = sc.nextInt(); if (n == 0) break; int  = 0; i < n; i++) { fs[1][i]    1 < n && fs[0][sfa +  1] == 1) sfb++; q.add(new Data(0, sfa, 0)); q.add(new Data(1, sfb, 0)); Set<String> set = new HashSet<String>(); boolean na = true; while (!q.isEmpty()) { Data d = q.poll(); int  = d.f; if (set.contains(b   = d.t; if (f == n -  != 2) { System.out.println(t); na  nb = b ^ 1;  { // \u5411\u304b\u3044\u5074\u306e\u30d3\u30eb\u3078\u30b8\u30e3\u30f3\u30d7\u3059\u308b\u3068\u304d\u306b\u306f\u3001 // \u540c\u3058\u968e\u30fb1\u3064\u4e0a\u306e\u968e\u30fb2  nf = f  q.add(new Data(nb, nf, t  while   break;  2)   class Data { int b; int  int f, int  this.f = f; this.t = t; } public  + \"  \" + t; } }"], "original_ll": -1.0258238315582275, "sampled_ll": -0.6350730657577515, "all_perturbed_sampled_ll": [-2.8446109294891357], "all_perturbed_original_ll": [-2.716996431350708], "perturbed_sampled_ll": -2.8446109294891357, "perturbed_original_ll": -2.716996431350708, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import Queue\nwhile True:\n    n = input()\n    if n==0:\n        break\n    a = []\n    nxt = [range(n) for i in xrange(2)]\n    for i in xrange(2):\n        a.append(map(int, raw_input().split()))\n    for i in xrange(2):\n        back = 0\n        for j in xrange(n):\n            if a[i][j]==2:\n                nxt[i][j] = back\n            else:\n                back = j\n        forw = n-1\n        for j in xrange(n-1,-1,-1):\n            if a[i][j]==1:\n                nxt[i][j] = forw\n            else:\n                forw = j-1\n    cost = [[10**9] * n for i in xrange(2)]\n    que = Queue.PriorityQueue()\n    que.put((0, 0, 0))\n    que.put((0, 1, 0))\n    ans = -1\n    while not que.empty():\n        co, sd, st = que.get()\n        if st==n-1:\n            ans = co\n            break\n        if cost[sd][st] < co:\n            continue\n        for i in xrange(3 if st+2<n else 2):\n            step = nxt[sd^1][st+i]\n            if co+1 < cost[sd^1][step]:\n                cost[sd^1][step] = co+1\n                que.put((co+1, sd^1, step))\n    print \"NA\" if ans==-1 else ans", "sampled": "from collections import deque\n\ndef solve(n, a, b):\n    # Preprocess ladders - find top of each ladder\n    def find_ladder_top(walls):\n        tops = list(range(n))\n        i = 0\n        while i < n:\n            if walls[i] == 1:\n                j = i\n                while j < n and walls[j] == 1:\n                    j += 1\n                for k in range(i, j):\n                    tops[k] = j - 1\n                i = j\n            else:\n                i += 1\n        return tops\n    \n    ladder_tops_a = find_ladder_top(a)\n    ladder_tops_b = find_ladder_top(b)\n    \n    # Function to find where we end up after landing on floor i of building side\n    def land_on(floor, side):\n        if side == 0:\n            walls = a\n            ladder_tops = ladder_tops_a\n        else:\n            walls = b\n            ladder_tops = ladder_tops_b\n        \n        if walls[floor] == 0:  # Normal wall\n            return floor\n        elif walls[floor] == 1:  # Ladder\n            return ladder_tops[floor]\n        else:  # walls[floor] == 2, sliding wall\n            # Slide down to normal wall or top of ladder\n            for f in range(floor - 1, -1, -1):\n                if walls[f] == 0:\n                    return f\n                elif walls[f] == 1:\n                    return ladder_tops[f]\n            return -1  # Should not happen as floor 0 is not sliding\n    \n    # BFS\n    queue = deque()\n    visited = set()\n    \n    # Start from floor 0 of either building\n    start_a = land_on(0, 0)\n    start_b = land_on(0, 1)\n    \n    if start_a >= 0:\n        queue.append((0, start_a, 0))  # (side, floor, jumps)\n        visited.add((0, start_a))\n    if start_b >= 0:\n        queue.append((1, start_b, 0))\n        visited.add((1, start_b))\n    \n    while queue:\n        side, floor, jumps = queue.popleft()\n        \n        # Check if we can reach rooftop\n        if floor == n - 1:\n            return jumps\n        \n        # Try jumping to other building\n        other_side = 1 - side\n        for delta in [0, 1, 2]:\n            next_floor = floor + delta\n            if next_floor < n:\n                final_floor = land_on(next_floor, other_side)\n                if final_floor >= 0 and (other_side, final_floor) not in visited:\n                    visited.add((other_side, final_floor))\n                    queue.append((other_side, final_floor, jumps + 1))\n    \n    return \"NA\"\n\nwhile True:\n    n = int(input())\n    if n == 0:\n        break\n    \n    a = list(map(int, input().split()))\n    b = list(map(int, input().split()))\n    \n    result = solve(n, a, b)\n    print(result)\n", "perturbed_sampled": ["from collections  -  def find_ladder_top(walls): tops = list(range(n)) i = 0  = i while j < n and walls[j] == 1: j  range(i, j): tops[k]   = find_ladder_top(a)  end up after landing on floor  == 0: walls = a ladder_tops = ladder_tops_a  = ladder_tops_b  Normal wall  1: # Ladder return ladder_tops[floor] else: # walls[floor] == 2, sliding wall # Slide  f in range(floor - 1, -1, -1):  1: return ladder_tops[f]   = set()  of either building start_a =   start_a))  start_b,  side, floor, jumps =  can reach rooftop if floor ==  1 - side for delta in [0, 1,  other_side) if   while True: n = int(input())  b = list(map(int, input().split())) result = solve(n, a, b) print(result)"], "perturbed_original": ["import Queue while <extra_id_2>if defw-forw: forw = forw<extra_id_3>forw-10*np.max(n-i-forw,0) if n-i-forw<n-2:<extra_id_4>if<extra_id_5>dow=0 ans<extra_id_6>)<extra_id_7>( ans): ans = ans<extra_id_8>+= n-i elif<extra_id_9>(t1,<extra_id_10>-1)<extra_id_11>( n-i-1: ans =<extra_id_12>if n-i  nxt  xrange(2)] for i in xrange(2): a.append(map(int, raw_input().split())) for i in xrange(2): back  = j forw = n-1 for  forw =  n  = Queue.PriorityQueue() que.put((0, 0,  = -1 while not que.empty(): co,  st==n-1: ans = co break if cost[sd][st]     else ans"], "original_ll": -1.122815489768982, "sampled_ll": -0.8739228248596191, "all_perturbed_sampled_ll": [-3.457068920135498], "all_perturbed_original_ll": [-3.341468572616577], "perturbed_sampled_ll": -3.457068920135498, "perturbed_original_ll": -3.341468572616577, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "m[100],a[100],b[100],i,j,M,B;main(n){for(;scanf(\"%d\",&n)*n;puts(B?\"NG\":\"OK\")){for(i=n;i--;B=0)scanf(\"%d%d%d\",m+i,a+i,b+i);for(i=n;i--;B|=M>150)for(M=0,j=n;j--;)M+=a[i]>=a[j]&&a[i]<b[j]?m[j]:0;}}\nm[100],a[100],b[100],i,j,M,B;", "sampled": "#include <stdio.h>\n#include <stdlib.h>\n\ntypedef struct {\n    int time;\n    int weight;\n    int type; // 0 for start, 1 for end\n} Event;\n\nint compare(const void *a, const void *b) {\n    Event *ea = (Event *)a;\n    Event *eb = (Event *)b;\n    if (ea->time != eb->time) {\n        return ea->time - eb->time;\n    }\n    // If times are equal, process end events before start events\n    return ea->type - eb->type;\n}\n\nint main() {\n    int n;\n    while (scanf(\"%d\", &n) == 1 && n != 0) {\n        Event events[200];\n        int eventCount = 0;\n        \n        for (int i = 0; i < n; i++) {\n            int m, a, b;\n            scanf(\"%d %d %d\", &m, &a, &b);\n            \n            events[eventCount].time = a;\n            events[eventCount].weight = m;\n            events[eventCount].type = 0;\n            eventCount++;\n            \n            events[eventCount].time = b;\n            events[eventCount].weight = m;\n            events[eventCount].type = 1;\n            eventCount++;\n        }\n        \n        qsort(events, eventCount, sizeof(Event), compare);\n        \n        int currentWeight = 0;\n        int broken = 0;\n        \n        for (int i = 0; i < eventCount; i++) {\n            if (events[i].type == 0) {\n                // Person starts crossing\n                currentWeight += events[i].weight;\n                if (currentWeight > 150) {\n                    broken = 1;\n                    break;\n                }\n            } else {\n                // Person finishes crossing\n                currentWeight -= events[i].weight;\n            }\n        }\n        \n        if (broken) {\n            printf(\"NG\\n\");\n        } else {\n            printf(\"OK\\n\");\n        }\n    }\n    \n    return 0;\n}\n", "perturbed_sampled": ["#include 0;<extra_id_9>0 ; weight; int type; <extra_id_10>{ // Person is<extra_id_11>) )<extra_id_12>e<extra_id_13>}<extra_id_14>+<extra_id_15>[ 1<extra_id_16>{ for end } Event; int <extra_id_17>if<extra_id_18>== 0 *b) { Event *ea  = (Event *)b; if (ea->time != eb->time) {  // If times are equal,  events return   (scanf(\"%d\",  != 0) { Event  0;   %d %d\", &m, &a, &b); events[eventCount].time  events[eventCount].type = 0; eventCount++; events[eventCount].time = b; events[eventCount].weight = m;   { if (events[i].type == 0) { // Person starts  broken  else { // Person  } }  } return 0; }"], "perturbed_original": ["m[100],a[100],b[100],i,j,M,B;main(n){for(;scanf(\"%d\",&n)*n;puts(B?\"NG\":\"OK\")){for(i=n;i--;B=0)scanf(\"%d%d%d\",m+i,a+i,b+i);for(i=n;i--;B|=M>150)for(M=0,j=n;j--;)M+=a[i]>=a[j]&&a[i]<b[j]?m[j]:0;}} m[100],a[100],b[100],i,j,M,B;"], "original_ll": -2.29946231842041, "sampled_ll": -0.5535210967063904, "all_perturbed_sampled_ll": [-3.0394787788391113], "all_perturbed_original_ll": [-2.307041645050049], "perturbed_sampled_ll": -3.0394787788391113, "perturbed_original_ll": -2.307041645050049, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import java.util.Scanner;\n\n//Dangerous Bridge\npublic class Main {\n\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\twhile(true){\n\t\t\tint n = sc.nextInt();\n\t\t\tif(n==0)break;\n\t\t\tboolean[][] map = new boolean[n*2][250];\n\t\t\tint[] w = new int[n];\n\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\tw[i] = sc.nextInt();\n\t\t\t\tint a = sc.nextInt();\n\t\t\t\tint b = sc.nextInt();\n\t\t\t\tfor(int j=a;j<b;j++)map[i][j] = true;\n\t\t\t}\n\t\t\tboolean f = true;\n\t\t\tfor(int i=0;i<231;i++){\n\t\t\t\tint sum = 0;\n\t\t\t\tfor(int j=0;j<n;j++){\n\t\t\t\t\tif(map[j][i])sum+=w[j];\n\t\t\t\t}\n\t\t\t\tif(sum>150){\n\t\t\t\t\tf = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(f?\"OK\":\"NG\");\n\t\t}\n\t}\n}", "sampled": "import java.util.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        \n        while (true) {\n            int n = sc.nextInt();\n            if (n == 0) break;\n            \n            List<Event> events = new ArrayList<>();\n            \n            for (int i = 0; i < n; i++) {\n                int m = sc.nextInt();\n                long a = sc.nextLong();\n                long b = sc.nextLong();\n                \n                events.add(new Event(a, m, true));\n                events.add(new Event(b, m, false));\n            }\n            \n            Collections.sort(events);\n            \n            int currentWeight = 0;\n            boolean broken = false;\n            \n            for (Event e : events) {\n                if (e.isEnter) {\n                    currentWeight += e.weight;\n                    if (currentWeight > 150) {\n                        broken = true;\n                        break;\n                    }\n                } else {\n                    currentWeight -= e.weight;\n                }\n            }\n            \n            System.out.println(broken ? \"NG\" : \"OK\");\n        }\n        \n        sc.close();\n    }\n    \n    static class Event implements Comparable<Event> {\n        long time;\n        int weight;\n        boolean isEnter;\n        \n        Event(long time, int weight, boolean isEnter) {\n            this.time = time;\n            this.weight = weight;\n            this.isEnter = isEnter;\n        }\n        \n        @Override\n        public int compareTo(Event other) {\n            if (this.time != other.time) {\n                return Long.compare(this.time, other.time);\n            }\n            // Exit events should come before enter events at the same time\n            if (this.isEnter != other.isEnter) {\n                return this.isEnter ? 1 : -1;\n            }\n            return 0;\n        }\n    }\n}\n", "perturbed_sampled": ["import java.util.*; public class Main { public static void main(String[] args) { Scanner sc  {  n; i++) { int m =  long b = sc.nextLong(); events.add(new  m, false)); } Collections.sort(events); int currentWeight = 0; boolean broken = false; for (Event e : events) { if (e.isEnter) { currentWeight += e.weight; if   class  weight, boolean isEnter) { this.time = time; this.weight = weight;  public int compareTo(Event other) { if (this.time   events   } } }"], "perturbed_original": ["import java.util.Scanner;  main(String[] args) {  while(true){ int n = sc.nextInt(); if(n==0)break;  int[] w = new int[n]; for(int i=0;i<n;i++){  =  for(int j=a;j<b;j++)map[i][j] = true; }  i=0;i<231;i++){ int sum  System.out.println(f?\"OK\":\"NG\"); } } }"], "original_ll": -0.9265027642250061, "sampled_ll": -0.5284178853034973, "all_perturbed_sampled_ll": [-2.590380907058716], "all_perturbed_original_ll": [-2.367659091949463], "perturbed_sampled_ll": -2.590380907058716, "perturbed_original_ll": -2.367659091949463, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "while 1:\n    n=input()\n    if n==0: break\n    d=[map(int,raw_input().split()) for i in range(n)]\n    w=max([sum([d2[0] for d2 in d if d2[1]<=d1[1]<d2[2]]) for d1 in d])\n    print \"OK\" if w<151 else \"NG\"", "sampled": "while True:\n    n = int(input())\n    if n == 0:\n        break\n    \n    people = []\n    for _ in range(n):\n        m, a, b = map(int, input().split())\n        people.append((m, a, b))\n    \n    # Collect all time points\n    times = set()\n    for m, a, b in people:\n        times.add(a)\n        times.add(b)\n    \n    times = sorted(times)\n    \n    broken = False\n    for t in times:\n        total_weight = 0\n        for m, a, b in people:\n            if a <= t < b:\n                total_weight += m\n        if total_weight > 150:\n            broken = True\n            break\n    \n    if broken:\n        print(\"NG\")\n    else:\n        print(\"OK\")\n", "perturbed_sampled": ["while True: n = int(input()) if n == 0:  _ in   = False for t in times: total_weight = 0 for m, a, b  t < b: total_weight  150:  broken: print(\"NG\") else: print(\"OK\")"], "perturbed_original": [" break  w=max([sum([d2[0] for d2 in d  d]) print \"OK\" if w<151 else \"NG\""], "original_ll": -1.7229571342468262, "sampled_ll": -0.8316839337348938, "all_perturbed_sampled_ll": [-3.757708787918091], "all_perturbed_original_ll": [-4.327982425689697], "perturbed_sampled_ll": -3.757708787918091, "perturbed_original_ll": -4.327982425689697, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "char z[];n,a;main(r){for(;scanf(\"%d\",&a)*a;puts(z+n))for(n=30;a;a=(r-a)/10)r=a%10,z[--n]=r+48;}", "sampled": "#include <stdio.h>\n#include <string.h>\n\nint main() {\n    long long n;\n    \n    while(scanf(\"%lld\", &n) == 1 && n != 0) {\n        if(n == 0) {\n            printf(\"0\\n\");\n            continue;\n        }\n        \n        char result[100];\n        int idx = 0;\n        \n        long long num = n;\n        while(num != 0) {\n            long long remainder = num % (-10);\n            num = num / (-10);\n            \n            if(remainder < 0) {\n                remainder += 10;\n                num += 1;\n            }\n            \n            result[idx++] = '0' + remainder;\n        }\n        \n        for(int i = idx - 1; i >= 0; i--) {\n            printf(\"%c\", result[i]);\n        }\n        printf(\"\\n\");\n    }\n    \n    return 0;\n}\n", "perturbed_sampled": ["#include <stdio.h>  &n)  0) { if(n == 0) { printf(\"0\\n\"); continue; } char  long long  0) { long long remainder = num % (-10); num   }   0; i--) { printf(\"%c\",  0; }"], "perturbed_original": ["char z[];n,a;main(r){for(;scanf(\"%d\",&a)*a;puts(z+n))for(n=30;a;a=(r-a)/10)r=a%10,z[--n]=r+48;}"], "original_ll": -3.2128729820251465, "sampled_ll": -0.6255590319633484, "all_perturbed_sampled_ll": [-3.134246826171875], "all_perturbed_original_ll": [-3.2128729820251465], "perturbed_sampled_ll": -3.134246826171875, "perturbed_original_ll": -3.2128729820251465, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.Scanner;\nimport java.util.*;\nimport java.math.*;\nimport java.io.*;\n\npublic class Main {\n\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\twhile(true) {\n\t\t\tint ss = sc.nextInt();\n\t\t\tif(ss == 0) break;\n\t\t\tboolean minus = false;\n\t\t\tif(ss < 0) minus = true;\n\t\t\tchar[] in = String.valueOf(ss).toCharArray();\n\t\t\tint[] ar0 = new int[32];\n\t\t\tint[] ar1 = new int[32];\n\t\t\tfor(int i = 0; i < in.length; i++) {\n\t\t\t\tif(in[in.length - i - 1] == '-') continue;\n\t\t\t\tar0[i] = in[in.length -1 - i] - '0';\n\t\t\t}\n\t\t\tint max = 0;\n\t\t\tif(!minus)\n\t\t\tfor(int i = 0; i < 32; i++) {\n\t\t\t\tif(ar0[i] == 0) continue;\n\t\t\t\tmax = i;\n\t\t\t\tif(i % 2 == 0) {\n\t\t\t\t\tif(ar0[i] < 10) {\n\t\t\t\t\t\tar1[i] += ar0[i];\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tar0[i+1] += ar0[i]/10;\n\t\t\t\t\t\tar1[i] += ar0[i] % 10;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tif(ar0[i] < 10) {\n\t\t\t\t\t\tar1[i] += 10 - ar0[i] % 10;\n\t\t\t\t\t\tar0[i+1] += 1;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tar0[i+1] += ar0[i] / 10;\n\t\t\t\t\t\tar1[i] += 10 - ar0[i] % 10;\n\t\t\t\t\t\tif(ar0[i] % 10 != 0)\n\t\t\t\t\t\tar0[i+1] += 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tfor(int i = 0; i < 32; i++) {\n\t\t\t\t\tif(ar0[i] == 0) continue;\n\t\t\t\t\tif(i % 2 != 0) {\n\t\t\t\t\t\tif(ar0[i] < 10) {\n\t\t\t\t\t\t\tar1[i] += ar0[i];\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tar0[i+1] += ar0[i]/10;\n\t\t\t\t\t\t\tar1[i] += ar0[i] % 10;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tif(ar0[i] < 10) {\n\t\t\t\t\t\t\tar1[i] += 10 - ar0[i] % 10;\n\t\t\t\t\t\t\tar0[i+1] += 1;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tar0[i+1] += ar0[i] / 10;\n\t\t\t\t\t\t\tar1[i] += 10 - ar0[i] % 10;\n\t\t\t\t\t\t\tif(ar0[i] % 10 != 0)\n\t\t\t\t\t\t\tar0[i+1] += 1;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tint check = 0;\n\t\t\tfor(int i = 0; i < 32; i++) {\n\t\t\t\tif(ar1[i] != 0) {\n\t\t\t\t\tcheck = i;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(int i = check; i >= 0; i--) {\n\t\t\t\tSystem.out.print(ar1[i]);\n\t\t\t}\n\t\t\tSystem.out.println();\n\t\t\t\n\t\t\t\n\t\t\t\n\t\t\t\n\t\t}\n\t}\n\t\n}", "sampled": "import java.util.Scanner;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        \n        while (true) {\n            long A = sc.nextLong();\n            if (A == 0) break;\n            \n            if (A == 0) {\n                System.out.println(\"0\");\n                continue;\n            }\n            \n            StringBuilder result = new StringBuilder();\n            long num = A;\n            \n            while (num != 0) {\n                long remainder = num % (-10);\n                num = num / (-10);\n                \n                if (remainder < 0) {\n                    remainder += 10;\n                    num += 1;\n                }\n                \n                result.append(remainder);\n            }\n            \n            System.out.println(result.reverse().toString());\n        }\n        \n        sc.close();\n    }\n}\n", "perturbed_sampled": ["import java.util.Scanner; public  Scanner sc  { long A = sc.nextLong(); if (A  continue; }  long num = A;  long  (-10);  remainder += 10; num += 1;  sc.close(); } }"], "perturbed_original": ["import  import java.util.*; import java.math.*; import java.io.*; public  Scanner sc  int ss = sc.nextInt();  minus = false; if(ss < 0) minus  new int[32]; int[] ar1 = new int[32]; for(int i = 0; i  == '-') continue; ar0[i] = in[in.length  }  i < 32; i++) { if(ar0[i] == 0) continue; max = i; if(i % 2 ==    { if(ar0[i] < 10) { ar1[i] += 10   10; ar1[i] += 10  for(int i  i++) {   ar1[i] += ar0[i]; } else { ar0[i+1] +=  10; } }  - ar0[i]   ar0[i] / 10; ar1[i] += 10 - ar0[i] %  0)  } } int  = 0; i < 32; i++) { if(ar1[i]  } }"], "original_ll": -0.49065208435058594, "sampled_ll": -0.6365665793418884, "all_perturbed_sampled_ll": [-3.2465968132019043], "all_perturbed_original_ll": [-2.236361265182495], "perturbed_sampled_ll": -3.2465968132019043, "perturbed_original_ll": -2.236361265182495, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "while 1:\n\tn = raw_input()[::-1]\n\tif n == \"0\": break\n\tans = \"\"\n\tm = 1 if n[-1] == \"-\" else 0\n\tfor i in range(0, len(n) - m, 2):\n\t\tif int(n[i]) > 0:\n\t\t\tif i < len(n) - 1 - m:\n\t\t\t\tans += str(10 - int(n[i])) + str(int(n[i + 1]) + 1)\n\t\t\telse:\n\t\t\t\tans += str(10 - int(n[i])) + \"1\"\n\t\telse:\n\t\t\tans += \"0\" + n[i + 1]\n\tif len(n) == 1 or (m == 0 and n[0] == \"0\"):\n\t\tans = int(\"2\"+\"0\"*len(n)) - int(ans[::-1]) \n\telse:\n\t\tans = int(ans[::-1])\n\tprint ans", "sampled": "import sys\n\ndef to_negadecimal(n):\n    if n == 0:\n        return \"0\"\n    \n    result = []\n    while n != 0:\n        if n > 0:\n            remainder = n % (-10)\n            n = n // (-10)\n            if remainder < 0:\n                remainder += 10\n                n += 1\n        else:\n            remainder = n % (-10)\n            n = n // (-10)\n            if remainder < 0:\n                remainder += 10\n                n += 1\n        result.append(str(remainder))\n    \n    return ''.join(reversed(result))\n\nfor line in sys.stdin:\n    a = int(line.strip())\n    if a == 0 and line.strip() == \"0\":\n        # Check if this is the last zero (terminator)\n        break\n    print(to_negadecimal(a))\n```\n\nWait, let me reconsider the termination condition:\n\n```python\nimport sys\n\ndef to_negadecimal(n):\n    if n == 0:\n        return \"0\"\n    \n    result = []\n    while n != 0:\n        remainder = n % (-10)\n        n = n // (-10)\n        if remainder < 0:\n            remainder += 10\n            n += 1\n        result.append(str(remainder))\n    \n    return ''.join(reversed(result))\n\nfor line in sys.stdin:\n    a = int(line.strip())\n    if a == 0:\n        break\n    print(to_negadecimal(a))\n", "perturbed_sampled": ["import  == 0: return \"0\" result = [] while  > 0:   remainder  else: remainder = n % (-10) n = n // (-10) if remainder < 0:  a =  and line.strip() == \"0\": # Check  ``` Wait, let me reconsider the termination  to_negadecimal(n): if  n += 1 result.append(str(remainder)) return ''.join(reversed(result)) for line  if a == 0: break print(to_negadecimal(a))"], "perturbed_original": ["while 1: n = raw_input()[::-1] if n == \"0\": break ans = \"\"  == \"-\" else  len(n)  <  ans += str(10   += str(10 - int(n[i])) + \"1\" else: ans += \"0\"  len(n) ==   print ans"], "original_ll": -1.2315387725830078, "sampled_ll": -0.7549880743026733, "all_perturbed_sampled_ll": [-3.595686912536621], "all_perturbed_original_ll": [-3.102459669113159], "perturbed_sampled_ll": -3.595686912536621, "perturbed_original_ll": -3.102459669113159, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "W,H,m,c[10][10];\nDP[10][10][10][10][51];//\u008ec\u008b\u00e0[y\u008d\u00c0\u0095W][x\u008d\u00c0\u0095W][\u008d\u00b6\u0092[][\u0089E\u0092[][\u008e_\u0091f\u008ec\u0097\u00ca]\n#define Update(d,v) ((v)>(d)?d=(v):0)\nCalcO(o,x,y){//\u008e_\u0091f\u008ec\u0097\u00ca\u0082\u00cc\u008cv\u008eZ\n\tif(c[x][y]>0){\n\t\to+=c[x][y];\n\t\tif(o>m)\n\t\t\to=m;\n\t}\n\treturn o;\n}\nCalcF(f,x,y){//\u008ec\u008b\u00e0\u0082\u00cc\u008cv\u008eZ\n\tif(c[x][y]<0)\n\t\tf+=c[x][y];\n\treturn f;\n}\nmain(){\n\tint x,y,range,d,dx,f,o,xl,xr,fn,on,f0;\n\tfor(;scanf(\"%d%d%d%d%d\",&W,&H,&f0,&m,&o),W;){\n\t\tfor(y=0;y<H;y++)\n\t\t\tfor(x=0;x<W;x++)\n\t\t\t\tscanf(\"%d\",&c[x][y]);\n\t\tf0++;//\u008ec\u008b\u00e00\u0082\u00c5\u0082\u00e0DP\u0082\u00cd1\u0082\u00c6\u0082\u00b5\u0082\u00c4\u0081ANA\u0082\u00c9\u0082\u00c8\u0082\u00e9\u0082\u00cc\u0082\u00f0\u0096h\u0082\u00ae\n\t\tfor(y=0,x=0;x<W;x++)\n\t\t\tDP[y][x][x][x][CalcO(o-1,x,y)]=CalcF(f0,x,y);\n\t\tfor(y=0;y<H-1;y++){\n\t\t\tfor(range=0;range<W;range++){//\u008d\u00b6\u0089E\u0082\u00c9\u008c@\u0082\u00e9\u008dL\u0082\u00b3\n\t\t\t\tfor(d=0;d<2;d++){//\u008c\u00bb\u008d\u00dd\u0088\u00ca\u0092ux\u0082\u00f0\u0089\u009d\u0095\u009c\u0082\u00b3\u0082\u00b9\u0082\u00e9\n\t\t\t\t\tfor(xl=0;xl<W-range;xl++){//\u008d\u00b6\u0092[\n\t\t\t\t\t\tfor(dx=0;dx<=range;dx++){//x\u0095\u00cf\u0088\u00ca\n\t\t\t\t\t\t\txr=xl+range;\n\t\t\t\t\t\t\tx=d?xr-dx:xl+dx;\n\t\t\t\t\t\t\t//printf(\"range=%d, d=%d, xl=%d, dx=%d, xr=%d, x=%d\\n\",range,d,xl,dx,xr,x);\n\t\t\t\t\t\t\tfor(o=m;o>0;o--){\n\t\t\t\t\t\t\t\tif(f=DP[y][x][xl][xr][o]){\n\t\t\t\t\t\t\t\t\tif(x>0){\n\t\t\t\t\t\t\t\t\t\tif(x==xl){//\u008d\u00b6\u0082\u00d6\u008c@\u0082\u00e9\n\t\t\t\t\t\t\t\t\t\t\tfn=CalcF(f,x-1,y);\n\t\t\t\t\t\t\t\t\t\t\ton=CalcO(o-1,x-1,y);\n\t\t\t\t\t\t\t\t\t\t\tUpdate(DP[y][x-1][x-1][xr][on],fn);\n\t\t\t\t\t\t\t\t\t\t}else{//\u008d\u00b6\u0082\u00d6\u0090i\u0082\u00de\n\t\t\t\t\t\t\t\t\t\t\tUpdate(DP[y][x-1][xl][xr][o-1],f);\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tif(x<W-1){\n\t\t\t\t\t\t\t\t\t\tif(x==xr){//\u0089E\u0082\u00d6\u008c@\u0082\u00e9\n\t\t\t\t\t\t\t\t\t\t\tfn=CalcF(f,x+1,y);\n\t\t\t\t\t\t\t\t\t\t\ton=CalcO(o-1,x+1,y);\n\t\t\t\t\t\t\t\t\t\t\tUpdate(DP[y][x+1][xl][x+1][on],fn);\n\t\t\t\t\t\t\t\t\t\t}else{//\u0089E\u0082\u00d6\u0090i\u0082\u00de\n\t\t\t\t\t\t\t\t\t\t\tUpdate(DP[y][x+1][xl][xr][o-1],f);\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t//\u0089\u00ba\u0082\u00d6\u008c@\u0082\u00e9\n\t\t\t\t\t\t\t\t\tfn=CalcF(f,x,y+1);\n\t\t\t\t\t\t\t\t\ton=CalcO(o-1,x,y+1);\n\t\t\t\t\t\t\t\t\tUpdate(DP[y+1][x][x][x][on],fn);\n\t\t\t\t\t\t\t\t\t//break;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}//o\n\t\t\t\t\t\t}//dx\n\t\t\t\t\t}//xl\n\t\t\t\t}//d\n\t\t\t}//range\n\t\t}//y\n#if 0\n\t\tfor(y=0;y<H;y++){\n\t\t\tfor(x=0;x<W;x++){\n\t\t\t\tfor(o=m;o>0;o--){\n\t\t\t\t\tif(f=DP[y][x][x][x][o]){\n\t\t\t\t\t\tprintf(\"%4d \",f-1);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(o==0)\n\t\t\t\t\tprintf(\"---- \");\n\t\t\t}\n\t\t\tputs(\"\");\n\t\t}\n#endif\n\t\tfn=0;\n\t\tfor(x=0;x<W;x++){\n\t\t\tfor(o=m;o>0;o--){\n\t\t\t\tf=DP[H-1][x][x][x][o];\n\t\t\t\tif(f>fn)\n\t\t\t\t\tfn=f;\n\t\t\t}\n\t\t}\n\t\tprintf(fn?\"%d\\n\":\"NA\\n\",f0-fn);\n\t\tmemset(DP,0,sizeof(DP));\n\t}\n\tputs(\"\");\n\texit(0);\n}", "sampled": "#include <stdio.h>\n#include <string.h>\n#include <limits.h>\n\n#define MAX_W 10\n#define MAX_H 10\n#define MAX_O 50\n\nint W, H, f, m, o;\nint grid[MAX_W + 1][MAX_H + 1];\nint visited[MAX_W + 1][MAX_H + 1][MAX_O + 1];\nint cost[MAX_W + 1][MAX_H + 1][MAX_O + 1];\n\ntypedef struct {\n    int x, y, oxygen, c;\n} State;\n\nState queue[1000000];\nint front, rear;\n\nvoid enqueue(int x, int y, int oxygen, int c) {\n    queue[rear].x = x;\n    queue[rear].y = y;\n    queue[rear].oxygen = oxygen;\n    queue[rear].c = c;\n    rear++;\n}\n\nState dequeue() {\n    return queue[front++];\n}\n\nint main() {\n    while (1) {\n        scanf(\"%d %d\", &W, &H);\n        if (W == 0 && H == 0) break;\n        \n        scanf(\"%d %d %d\", &f, &m, &o);\n        \n        for (int j = 1; j <= H; j++) {\n            for (int i = 1; i <= W; i++) {\n                scanf(\"%d\", &grid[i][j]);\n            }\n        }\n        \n        memset(visited, 0, sizeof(visited));\n        for (int i = 0; i <= W; i++) {\n            for (int j = 0; j <= H; j++) {\n                for (int k = 0; k <= m; k++) {\n                    cost[i][j][k] = INT_MAX;\n                }\n            }\n        }\n        \n        front = 0;\n        rear = 0;\n        \n        for (int i = 1; i <= W; i++) {\n            if (grid[i][1] > 0) {\n                int new_o = o - 1 + grid[i][1];\n                if (new_o > m) new_o = m;\n                if (new_o > 0) {\n                    enqueue(i, 1, new_o, 0);\n                    cost[i][1][new_o] = 0;\n                }\n            } else {\n                int dig_cost = -grid[i][1];\n                if (o > 1) {\n                    enqueue(i, 1, o - 1, dig_cost);\n                    cost[i][1][o - 1] = dig_cost;\n                }\n            }\n        }\n        \n        int min_cost = INT_MAX;\n        \n        while (front < rear) {\n            State s = dequeue();\n            int x = s.x;\n            int y = s.y;\n            int oxy = s.oxygen;\n            int c = s.c;\n            \n            if (visited[x][y][oxy]) continue;\n            visited[x][y][oxy] = 1;\n            \n            if (y == H) {\n                if (c < min_cost) {\n                    min_cost = c;\n                }\n                continue;\n            }\n            \n            int dx[] = {-1, 1, 0};\n            int dy[] = {0, 0, 1};\n            \n            for (int d = 0; d < 3; d++) {\n                int nx = x + dx[d];\n                int ny = y + dy[d];\n                \n                if (nx < 1 || nx > W || ny < 1 || ny > H) continue;\n                \n                if (grid[nx][ny] > 0) {\n                    int new_oxy = oxy - 1 + grid[nx][ny];\n                    if (new_oxy > m) new_oxy = m;\n                    if (new_oxy > 0 && !visited[nx][ny][new_oxy]) {\n                        if (cost[nx][ny][new_oxy] > c) {\n                            cost[nx][ny][new_oxy] = c;\n                            enqueue(nx, ny, new_oxy, c);\n                        }\n                    }\n                } else {\n                    int dig_cost = -grid[nx][ny];\n                    int new_cost = c + dig_cost;\n                    int new_oxy = oxy - 1;\n                    if (new_oxy > 0 && !visited[nx][ny][new_oxy]) {\n                        if (cost[nx][ny][new_oxy] > new_cost) {\n                            cost[nx][ny][new_oxy] = new_cost;\n                            enqueue(nx, ny, new_oxy, new_cost);\n                        }\n                    }\n                }\n            }\n        }\n        \n        if (min_cost == INT_MAX || min_cost > f) {\n            printf(\"NA\\n\");\n        } else {\n            printf(\"%d\\n\", min_cost);\n        }\n    }\n    \n    return 0;\n}\n", "perturbed_sampled": ["#include <stdio.h> #include <string.h> #include <limits.h>  10 #define  1][MAX_H + 1][MAX_O +  +  { int  State;   = oxygen; queue[rear].c  dequeue() { return queue[front++]; }   if (W == 0 && H == 0)   (int i  i++) { scanf(\"%d\", &grid[i][j]); } } memset(visited, 0, sizeof(visited)); for (int i = 0; i  (int j = 0; j  (int  m; k++) { cost[i][j][k] = INT_MAX; } } }  if (new_o > m) new_o = m;  enqueue(i, 1, new_o, 0); cost[i][1][new_o] =  int dig_cost = -grid[i][1]; if (o > 1)  1] = dig_cost; } } }  (front < rear) { State s = dequeue();  oxy  s.c; if (visited[x][y][oxy]) continue;  == H) {  min_cost =  0};  = 0; d  y + dy[d]; if (nx < 1 || nx > W || ny < 1 || ny > H) continue; if (grid[nx][ny] > 0)  (new_oxy > 0 &&  c); }   int new_oxy = oxy - 1; if (new_oxy    } } } if (min_cost ==  { printf(\"NA\\n\"); } else { printf(\"%d\\n\", min_cost); } } return 0; }"], "perturbed_original": [" o=m; }  f+=c[x][y]; return f; } main(){ int x,y,range,d,dx,f,o,xl,xr,fn,on,f0; for(;scanf(\"%d%d%d%d%d\",&W,&H,&f0,&m,&o),W;){ for(y=0;y<H;y++) for(x=0;x<W;x++) scanf(\"%d\",&c[x][y]); f0++;//\u008ec\u008b\u00e00\u0082\u00c5\u0082\u00e0DP\u0082\u00cd1\u0082\u00c6\u0082\u00b5\u0082\u00c4\u0081ANA\u0082\u00c9\u0082\u00c8\u0082\u00e9\u0082\u00cc\u0082\u00f0\u0096h\u0082\u00ae for(y=0,x=0;x<W;x++) DP[y][x][x][x][CalcO(o-1,x,y)]=CalcF(f0,x,y); for(y=0;y<H-1;y++){  if(f=DP[y][x][xl][xr][o]){ if(x>0){  }else{//\u0089E\u0082\u00d6\u0090i\u0082\u00de Update(DP[y][x+1][xl][xr][o-1],f); } } //\u0089\u00ba\u0082\u00d6\u008c@\u0082\u00e9  }//o }//dx }//xl }//d }//range }//y #if   if(o==0) printf(\"---- \"); } puts(\"\"); } #endif  fn=f; } }  }"], "original_ll": -1.5926307439804077, "sampled_ll": -0.4563538134098053, "all_perturbed_sampled_ll": [-2.5075039863586426], "all_perturbed_original_ll": [-2.9887266159057617], "perturbed_sampled_ll": -2.5075039863586426, "perturbed_original_ll": -2.9887266159057617, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "import java.util.*;\nimport java.math.*;\nimport java.awt.geom.*;\nimport java.io.*;\n   \n   \npublic class Main {\n\tstatic int INF = 2 << 28;\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\twhile(true) {\n\t\t\tint w = sc.nextInt();\n\t\t\tint h = sc.nextInt();\n\t\t\tif(w == 0 && h == 0) break;\n\t\t\tint f = sc.nextInt();\n\t\t\tint m = sc.nextInt();\n\t\t\tint o = sc.nextInt();\n\t\t\t\n\t\t\tint[][] map = new int[h][w];\n\t\t\tfor(int i = 0; i < h; i++) {\n\t\t\t\tfor(int j = 0; j < w; j++) {\n\t\t\t\t\tmap[i][j] = sc.nextInt();\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tint[][][] memo = new int[h][w][m+1];\n\t\t\tfor(int i = 0; i < h; i++) {\n\t\t\t\tfor(int j = 0; j < w; j++) {\n\t\t\t\t\tArrays.fill(memo[i][j], INF);\n\t\t\t\t}\n\t\t\t}\n\t\t\tPriorityQueue<Data> queue = new PriorityQueue<Data>();\n\t\t\tfor(int i = 0; i < w; i++) {\n\t\t\t\tboolean[] tmp = new boolean[w];\n\t\t\t\tif(map[0][i] > 0) {\n\t\t\t\t\tqueue.add(new Data(0,i,0,Math.min(m, o - 1 + map[0][i]),tmp));\n\t\t\t\t}\n\t\t\t\telse  {\n\t\t\t\t\tqueue.add(new Data(0,i,-map[0][i],o - 1,tmp));\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tint ans = -1;\n\t\t\twhile(!queue.isEmpty()) {\n\t\t\t\tData tmp = queue.poll();\n\t\t\t\t\n\t\t\t\tif(tmp.o <= 0) continue;\n\t\t\t\ttmp.al[tmp.x] = true;\n\t\t\t\t\n\t\t\t\tif(tmp.y == h-1) {\n\t\t\t\t\tans = tmp.c;\n\t\t\t\t\tqueue.clear();\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif(tmp.c >= memo[tmp.y][tmp.x][tmp.o]) continue;\n\t\t\t\tmemo[tmp.y][tmp.x][tmp.o] = tmp.c;\n\t\t\t\t\n\t\t\t\tif(tmp.x != w-1) {\n\t\t\t\t\tif(tmp.al[tmp.x+1]) {\n\t\t\t\t\t\t    queue.add(new Data(tmp.y,tmp.x+1,tmp.c,tmp.o-1,Arrays.copyOf(tmp.al,tmp.al.length)));\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tif(map[tmp.y][tmp.x+1] > 0 && tmp.o != 1) {\n\t\t\t\t\t\t\tqueue.add(new Data(tmp.y,tmp.x+1,tmp.c,Math.min(m, tmp.o - 1 + map[tmp.y][tmp.x+1]),Arrays.copyOf(tmp.al,tmp.al.length)));\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if(map[tmp.y][tmp.x+1] < 0){\n\t\t\t\t\t\t\tqueue.add(new Data(tmp.y,tmp.x+1,tmp.c - map[tmp.y][tmp.x+1],tmp.o-1,Arrays.copyOf(tmp.al,tmp.al.length)));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(tmp.x != 0) {\n\t\t\t\t\tif(tmp.al[tmp.x-1]) {\n\t\t\t\t\t\tqueue.add(new Data(tmp.y,tmp.x-1,tmp.c,tmp.o-1,Arrays.copyOf(tmp.al,tmp.al.length)));\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tif(map[tmp.y][tmp.x-1] > 0 && tmp.o != 1) {\n\t\t\t\t\t\t\tqueue.add(new Data(tmp.y,tmp.x-1,tmp.c,Math.min(m, tmp.o - 1 + map[tmp.y][tmp.x-1]),Arrays.copyOf(tmp.al,tmp.al.length)));\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if(map[tmp.y][tmp.x-1] < 0){\n\t\t\t\t\t\t\tqueue.add(new Data(tmp.y,tmp.x-1,tmp.c - map[tmp.y][tmp.x-1],tmp.o-1,Arrays.copyOf(tmp.al,tmp.al.length)));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(tmp.y != h-1) {\n\t\t\t\t\tif(map[tmp.y+1][tmp.x] > 0 && tmp.o != 1) {\n\t\t\t\t\t\tqueue.add(new Data(tmp.y+1,tmp.x,tmp.c,Math.min(m, tmp.o - 1 + map[tmp.y+1][tmp.x]),new boolean[w]));\n\t\t\t\t\t}\n\t\t\t\t\telse if(map[tmp.y+1][tmp.x] < 0){\n\t\t\t\t\t\tqueue.add(new Data(tmp.y+1,tmp.x,tmp.c - map[tmp.y+1][tmp.x],tmp.o-1,new boolean[w]));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t}\n\t\t\t\n\t\t\tif(ans == -1 || ans >= f) {\n\t\t\t\tSystem.out.println(\"NA\");\n\t\t\t}\n\t\t\telse {\n\t\t\t\tSystem.out.println(ans);\n\t\t\t}\n\t\t}\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t}\n\tstatic class Data implements Comparable<Data> {\n\t\tint y;\n\t\tint x;\n\t\tint c;\n\t\tint o;\n\t\tboolean[] al;\n\t\t\n\t\tData(int y, int x, int c, int o, boolean[] al) {\n\t\t\tthis.y = y;\n\t\t\tthis.x = x;\n\t\t\tthis.c = c;\n\t\t\tthis.o = o;\n\t\t\tthis.al = al;\n\t\t}\n\n\t\t@Override\n\t\tpublic int compareTo(Data o) {\n\t\t\treturn this.c - o.c;\n\t\t}\n\t\t\n\t}\n\t\n\t\n\t\n}", "sampled": "import java.util.*;\nimport java.io.*;\n\npublic class Main {\n    static class State implements Comparable<State> {\n        int x, y, oxygen, cost;\n        \n        State(int x, int y, int oxygen, int cost) {\n            this.x = x;\n            this.y = y;\n            this.oxygen = oxygen;\n            this.cost = cost;\n        }\n        \n        @Override\n        public int compareTo(State other) {\n            return Integer.compare(this.cost, other.cost);\n        }\n    }\n    \n    public static void main(String[] args) throws IOException {\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        String line;\n        \n        while ((line = br.readLine()) != null) {\n            String[] parts = line.trim().split(\"\\\\s+\");\n            int W = Integer.parseInt(parts[0]);\n            int H = Integer.parseInt(parts[1]);\n            \n            if (W == 0 && H == 0) break;\n            \n            parts = br.readLine().trim().split(\"\\\\s+\");\n            int f = Integer.parseInt(parts[0]);\n            int m = Integer.parseInt(parts[1]);\n            int o = Integer.parseInt(parts[2]);\n            \n            int[][] grid = new int[H][W];\n            for (int j = 0; j < H; j++) {\n                parts = br.readLine().trim().split(\"\\\\s+\");\n                for (int i = 0; i < W; i++) {\n                    grid[j][i] = Integer.parseInt(parts[i]);\n                }\n            }\n            \n            int result = solve(W, H, f, m, o, grid);\n            if (result == -1) {\n                System.out.println(\"NA\");\n            } else {\n                System.out.println(result);\n            }\n        }\n    }\n    \n    static int solve(int W, int H, int f, int m, int o, int[][] grid) {\n        int[][][] dist = new int[H][W][m + 1];\n        for (int i = 0; i < H; i++) {\n            for (int j = 0; j < W; j++) {\n                Arrays.fill(dist[i][j], Integer.MAX_VALUE);\n            }\n        }\n        \n        PriorityQueue<State> pq = new PriorityQueue<>();\n        \n        // Start from any cell in the first row\n        for (int x = 0; x < W; x++) {\n            int cost = 0;\n            int oxygen = o;\n            \n            if (grid[0][x] < 0) {\n                cost = -grid[0][x];\n            } else {\n                oxygen = Math.min(m, oxygen + grid[0][x]);\n            }\n            \n            if (cost <= f && oxygen > 0) {\n                pq.offer(new State(x, 0, oxygen, cost));\n                dist[0][x][oxygen] = cost;\n            }\n        }\n        \n        int[] dx = {-1, 1, 0};\n        int[] dy = {0, 0, 1};\n        \n        int minCost = Integer.MAX_VALUE;\n        \n        while (!pq.isEmpty()) {\n            State curr = pq.poll();\n            \n            if (curr.y == H - 1) {\n                minCost = Math.min(minCost, curr.cost);\n                continue;\n            }\n            \n            if (curr.cost > dist[curr.y][curr.x][curr.oxygen]) {\n                continue;\n            }\n            \n            for (int d = 0; d < 3; d++) {\n                int nx = curr.x + dx[d];\n                int ny = curr.y + dy[d];\n                \n                if (nx < 0 || nx >= W || ny < 0 || ny >= H) continue;\n                \n                int newOxygen = curr.oxygen - 1;\n                if (newOxygen <= 0) continue;\n                \n                int newCost = curr.cost;\n                \n                if (grid[ny][nx] < 0) {\n                    newCost += -grid[ny][nx];\n                } else {\n                    newOxygen = Math.min(m, newOxygen + grid[ny][nx]);\n                }\n                \n                if (newCost > f) continue;\n                \n                if (newCost < dist[ny][nx][newOxygen]) {\n                    dist[ny][nx][newOxygen] = newCost;\n                    pq.offer(new State(nx, ny, newOxygen, newCost));\n                }\n            }\n        }\n        \n        return minCost == Integer.MAX_VALUE ? -1 : minCost;\n    }\n}\n", "perturbed_sampled": [" class Main { static class State implements Comparable<State> { int x, y, oxygen,  int oxygen, int  this.y = y;  int compareTo(State other) { return Integer.compare(this.cost, other.cost); }    Integer.parseInt(parts[1]); if  == 0) break; parts  Integer.parseInt(parts[0]); int m = Integer.parseInt(parts[1]); int o  new   0;  } int result = solve(W, H, f,  ==  { System.out.println(result); } } }  H, int f, int m, int o,  = new int[H][W][m + 1]; for (int i  i++)  } } PriorityQueue<State> pq = new PriorityQueue<>(); // Start  first row for (int  W; x++) { int cost = 0; int  < 0) { cost = -grid[0][x];  Math.min(m, oxygen +   { pq.offer(new State(x, 0, oxygen, cost));   {0, 0, 1}; int minCost  State curr = pq.poll(); if (curr.y == H - 1) { minCost = Math.min(minCost,  > dist[curr.y][curr.x][curr.oxygen]) { continue; } for (int  3;    newCost +=  = Math.min(m, newOxygen + grid[ny][nx]); } if  (newCost <  newCost)); } } } return minCost == Integer.MAX_VALUE  }"], "perturbed_original": ["import java.util.*; import java.math.*; import java.awt.geom.*; import java.io.*;   28; public static void main(String[] args) { Scanner sc = new Scanner(System.in); while(true) {  h = sc.nextInt(); if(w == 0 && h == 0)  int   = 0;   < w; j++) { map[i][j] = sc.nextInt(); } } int[][][] memo =  0; i  < w;   PriorityQueue<Data>(); for(int i = 0; i < w; i++) { boolean[]  > 0) { queue.add(new Data(0,i,0,Math.min(m, o -  1,tmp)); } }  { Data tmp = queue.poll(); if(tmp.o <= 0) continue; tmp.al[tmp.x] = true; if(tmp.y == h-1) { ans =  = tmp.c; if(tmp.x  {  + map[tmp.y][tmp.x+1]),Arrays.copyOf(tmp.al,tmp.al.length))); } else if(map[tmp.y][tmp.x+1]  map[tmp.y][tmp.x+1],tmp.o-1,Arrays.copyOf(tmp.al,tmp.al.length))); } }  != 1) { queue.add(new Data(tmp.y,tmp.x-1,tmp.c,Math.min(m,  }     ans >= f) { System.out.println(\"NA\"); } else  static class Data implements Comparable<Data> { int  int o; boolean[] al; Data(int  int   al; } @Override public  } }"], "original_ll": -0.5341481566429138, "sampled_ll": -0.4243590831756592, "all_perturbed_sampled_ll": [-2.700467586517334], "all_perturbed_original_ll": [-2.410027503967285], "perturbed_sampled_ll": -2.700467586517334, "perturbed_original_ll": -2.410027503967285, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}, {"original": "INF = 10 ** 20\n\ndef update_state(state, newx):\n  tmp = list(state)\n  tmp[newx] = 1\n  return tuple(tmp)\n\ndef get_co(x, y):\n  dc = do = 0\n  score = mp[y][x]\n  if score < 0:\n    dc = -score\n  else:\n    do = score\n  return dc, do\n\ndef minimum_cost(nowx, nowy, state, ox, goal, dic, w, m):\n  if (nowx, nowy, state, ox) in dic:\n    return dic[(nowx, nowy, state, ox)]\n  if nowy == goal:\n    return 0\n  if ox <= 1:\n    return INF\n  \n  ret = INF\n  \n  left = right = None\n  for i in range(nowx + 1, w):\n    if state[i] == 0:\n      right = i\n      break\n\n  for i in range(nowx - 1, -1, -1):\n    if state[i] == 0:\n      left = i\n      break\n\n  if left != None:\n    dc, do = get_co(left, nowy)\n    ret = min(ret, minimum_cost(left, nowy, update_state(state, left), min(ox + do - 1, m), goal, dic, w, m) + dc)\n    for i in range(left + 1, nowx):\n      ret = min(ret, minimum_cost(i, nowy, state, ox - 1, goal, dic, w, m))\n  \n  if right != None:\n    dc, do = get_co(right, nowy)\n    ret = min(ret, minimum_cost(right, nowy, update_state(state, right), min(ox + do - 1, m), goal, dic, w, m) + dc)\n    for i in range(nowx + 1, right):\n      ret = min(ret, minimum_cost(i, nowy, state, ox - 1, goal, dic, w, m))\n  \n  dc, do = get_co(nowx, nowy + 1)\n  ret = min(ret, minimum_cost(nowx, nowy + 1, tuple((1 if i == nowx else 0 for i in range(w))), min(ox + do - 1, m), goal, dic, w, m) + dc)\n  dic[(nowx, nowy, state, ox)] = ret\n  return ret\n\nwhile True:\n  w, h = map(int, input().split())\n  if w == 0:\n    break\n  f, m, o = map(int, input().split())\n  if o <= 1:\n    print(\"NA\")\n    continue\n  mp = [list(map(int, input().split())) for _ in range(h)]\n  dic = {}\n  ans = INF\n  for i in range(w):\n    dc, do = get_co(i, 0)\n    ans = min(ans, minimum_cost(i, 0, tuple(1 if i == j else 0 for j in range(w)), min(o + do - 1, m), h - 1, dic, w, m) + dc)\n  if ans > f:\n    print(\"NA\")\n  else:\n    print(ans)\n", "sampled": "import heapq\nfrom collections import defaultdict\n\ndef solve(W, H, f, m, o, grid):\n    # State: (x, y, oxygen, used_oxygen_cells)\n    # used_oxygen_cells is a frozenset of (x, y) tuples\n    \n    # Priority queue: (cost, x, y, oxygen, used_oxygen_cells)\n    pq = []\n    \n    # Start from any cell in the first row (y=0)\n    for x in range(W):\n        cell_value = grid[0][x]\n        if cell_value < 0:  #\u571f\n            cost = -cell_value\n            new_oxygen = o - 1\n            if new_oxygen >= 0 and cost <= f:\n                heapq.heappush(pq, (cost, x, 0, new_oxygen, frozenset()))\n        else:  # \u9178\u7d20\n            new_oxygen = min(m, o + cell_value) - 1\n            if new_oxygen >= 0:\n                heapq.heappush(pq, (0, x, 0, new_oxygen, frozenset([(x, 0)])))\n    \n    # Best cost for each state (x, y, oxygen, used_oxygen_cells)\n    visited = {}\n    \n    while pq:\n        cost, x, y, oxygen, used = heapq.heappop(pq)\n        \n        # Check if we reached the bottom\n        if y == H - 1 and oxygen > 0:\n            return cost\n        \n        # Skip if we've seen this state with better or equal cost\n        state = (x, y, oxygen, used)\n        if state in visited:\n            continue\n        visited[state] = cost\n        \n        # Try moving to adjacent cells: left, right, down\n        directions = []\n        if x > 0:\n            directions.append((x - 1, y))\n        if x < W - 1:\n            directions.append((x + 1, y))\n        if y < H - 1:\n            directions.append((x, y + 1))\n        \n        for nx, ny in directions:\n            cell_value = grid[ny][nx]\n            \n            if cell_value < 0:  # \u571f\n                dig_cost = -cell_value\n                new_cost = cost + dig_cost\n                new_oxygen = oxygen - 1\n                \n                if new_oxygen >= 0 and new_cost <= f:\n                    new_state = (nx, ny, new_oxygen, used)\n                    if new_state not in visited:\n                        heapq.heappush(pq, (new_cost, nx, ny, new_oxygen, used))\n            else:  # \u9178\u7d20\n                if (nx, ny) in used:\n                    # Already used this oxygen cell\n                    new_oxygen = oxygen - 1\n                    if new_oxygen >= 0:\n                        new_state = (nx, ny, new_oxygen, used)\n                        if new_state not in visited:\n                            heapq.heappush(pq, (cost, nx, ny, new_oxygen, used))\n                else:\n                    # Use oxygen from this cell\n                    new_oxygen = min(m, oxygen + cell_value) - 1\n                    if new_oxygen >= 0:\n                        new_used = used | frozenset([(nx, ny)])\n                        new_state = (nx, ny, new_oxygen, new_used)\n                        if new_state not in visited:\n                            heapq.heappush(pq, (cost, nx, ny, new_oxygen, new_used))\n    \n    return None\n\nwhile True:\n    line = input().split()\n    W, H = int(line[0]), int(line[1])\n    if W == 0 and H == 0:\n        break\n    \n    line = input().split()\n    f, m, o = int(line[0]), int(line[1]), int(line[2])\n    \n    grid = []\n    for _ in range(H):\n        row = list(map(int, input().split()))\n        grid.append(row)\n    \n    result = solve(W, H, f, m, o, grid)\n    if result is None:\n        print(\"NA\")\n    else:\n        print(result)\n", "perturbed_sampled": ["import heapq  solve(W, H, f,  (x, y,  y) tuples # Priority queue:  pq  x  if  new_oxygen >= 0 and cost <= f: heapq.heappush(pq, (cost, x, 0, new_oxygen, frozenset())) else: # \u9178\u7d20 new_oxygen = min(m, o + cell_value) - 1 if new_oxygen >= 0: heapq.heappush(pq, (0, x, 0, new_oxygen, frozenset([(x, 0)])))  state (x,  =  y == H - 1 and oxygen > 0: return cost # Skip if we've seen this state with  = (x, y,   down  1, y))  H - 1: directions.append((x, y + 1)) for nx, ny in directions:  < 0: # \u571f  cost  - 1 if new_oxygen >=  not in visited: heapq.heappush(pq, (new_cost, nx, ny, new_oxygen, used)) else: #  used:  cell  if new_oxygen >= 0: new_state  if new_state not in visited: heapq.heappush(pq, (cost,   0: new_used = used | frozenset([(nx, ny)]) new_state  if new_state not in visited:  new_used))  =  = int(line[0]),  row = list(map(int, input().split()))  print(\"NA\") else: print(result)"], "perturbed_original": ["INF = 10 **  = list(state)   =  nowy, state, ox, goal, dic, w, m): if (nowx, nowy, state, ox) in dic: return dic[(nowx, nowy,  goal:   INF left = right = None for  range(nowx  = i break if left != None: dc,    for i in range(left +  minimum_cost(i, nowy, state, ox - 1,  right != None: dc, do = get_co(right, nowy) ret = min(ret,  + do - 1, m), goal, dic, w, m) + dc) for i  ret =  - 1,    if i == nowx  - 1, m), goal, dic, w,  state, ox)] = ret return ret while True: w, h = map(int,  o <= 1:  range(h)] dic = {}   do - 1, m), h -  dc) if ans > f: print(\"NA\") else: print(ans)"], "original_ll": -0.8410813808441162, "sampled_ll": -0.740057647228241, "all_perturbed_sampled_ll": [-2.607189178466797], "all_perturbed_original_ll": [-3.525029420852661], "perturbed_sampled_ll": -2.607189178466797, "perturbed_original_ll": -3.525029420852661, "perturbed_sampled_ll_std": 1, "perturbed_original_ll_std": 1}], "metrics": {"roc_auc": 0.7365, "fpr": [0.0, 0.0, 0.0, 0.0033333333333333335, 0.0033333333333333335, 0.005, 0.005, 0.008333333333333333, 0.008333333333333333, 0.01, 0.01, 0.016666666666666666, 0.016666666666666666, 0.018333333333333333, 0.018333333333333333, 0.02, 0.02, 0.021666666666666667, 0.021666666666666667, 0.023333333333333334, 0.023333333333333334, 0.025, 0.025, 0.028333333333333332, 0.028333333333333332, 0.035, 0.035, 0.03833333333333333, 0.03833333333333333, 0.04, 0.04, 0.041666666666666664, 0.041666666666666664, 0.043333333333333335, 0.043333333333333335, 0.045, 0.045, 0.04833333333333333, 0.04833333333333333, 0.05, 0.05, 0.051666666666666666, 0.051666666666666666, 0.05333333333333334, 0.05333333333333334, 0.055, 0.055, 0.056666666666666664, 0.056666666666666664, 0.058333333333333334, 0.058333333333333334, 0.06166666666666667, 0.06166666666666667, 0.06333333333333334, 0.06333333333333334, 0.06833333333333333, 0.06833333333333333, 0.07, 0.07, 0.07166666666666667, 0.07166666666666667, 0.07333333333333333, 0.07333333333333333, 0.07666666666666666, 0.07666666666666666, 0.08166666666666667, 0.08166666666666667, 0.08333333333333333, 0.08333333333333333, 0.085, 0.085, 0.08666666666666667, 0.08666666666666667, 0.09, 0.09, 0.09166666666666666, 0.09166666666666666, 0.09333333333333334, 0.09333333333333334, 0.095, 0.095, 0.09666666666666666, 0.09666666666666666, 0.1, 0.1, 0.10166666666666667, 0.10166666666666667, 0.10333333333333333, 0.10333333333333333, 0.105, 0.105, 0.10666666666666667, 0.10666666666666667, 0.10833333333333334, 0.10833333333333334, 0.11166666666666666, 0.11166666666666666, 0.115, 0.115, 0.12166666666666667, 0.12166666666666667, 0.12333333333333334, 0.12333333333333334, 0.125, 0.125, 0.12666666666666668, 0.12666666666666668, 0.12833333333333333, 0.12833333333333333, 0.13, 0.13, 0.13166666666666665, 0.13166666666666665, 0.135, 0.135, 0.13666666666666666, 0.13666666666666666, 0.13833333333333334, 0.13833333333333334, 0.14, 0.14, 0.14333333333333334, 0.14333333333333334, 0.145, 0.145, 0.14666666666666667, 0.14666666666666667, 0.14833333333333334, 0.14833333333333334, 0.15, 0.15, 0.15166666666666667, 0.15166666666666667, 0.15333333333333332, 0.15333333333333332, 0.155, 0.155, 0.15666666666666668, 0.15666666666666668, 0.15833333333333333, 0.15833333333333333, 0.16, 0.16, 0.16166666666666665, 0.16166666666666665, 0.16333333333333333, 0.16333333333333333, 0.165, 0.165, 0.16666666666666666, 0.16666666666666666, 0.16833333333333333, 0.16833333333333333, 0.17, 0.17, 0.17166666666666666, 0.17166666666666666, 0.17333333333333334, 0.17333333333333334, 0.175, 0.175, 0.17666666666666667, 0.17666666666666667, 0.17833333333333334, 0.17833333333333334, 0.18, 0.18, 0.18333333333333332, 0.18333333333333332, 0.185, 0.185, 0.18666666666666668, 0.18666666666666668, 0.18833333333333332, 0.18833333333333332, 0.19, 0.19, 0.19666666666666666, 0.19666666666666666, 0.19833333333333333, 0.19833333333333333, 0.2, 0.2, 0.20833333333333334, 0.20833333333333334, 0.21, 0.21, 0.21333333333333335, 0.21333333333333335, 0.215, 0.215, 0.22166666666666668, 0.22166666666666668, 0.22333333333333333, 0.22333333333333333, 0.225, 0.225, 0.22666666666666666, 0.22666666666666666, 0.22833333333333333, 0.22833333333333333, 0.23, 0.23, 0.23166666666666666, 0.23166666666666666, 0.23666666666666666, 0.23666666666666666, 0.23833333333333334, 0.23833333333333334, 0.24, 0.24, 0.24166666666666667, 0.24166666666666667, 0.24333333333333335, 0.24333333333333335, 0.245, 0.245, 0.24833333333333332, 0.24833333333333332, 0.25166666666666665, 0.25166666666666665, 0.26, 0.26, 0.26166666666666666, 0.26166666666666666, 0.2633333333333333, 0.2633333333333333, 0.26666666666666666, 0.26666666666666666, 0.27, 0.27, 0.275, 0.275, 0.27666666666666667, 0.27666666666666667, 0.2783333333333333, 0.2783333333333333, 0.2816666666666667, 0.2816666666666667, 0.2833333333333333, 0.2833333333333333, 0.285, 0.285, 0.28833333333333333, 0.28833333333333333, 0.2966666666666667, 0.2966666666666667, 0.29833333333333334, 0.29833333333333334, 0.30833333333333335, 0.30833333333333335, 0.31, 0.31, 0.31333333333333335, 0.31333333333333335, 0.31666666666666665, 0.31666666666666665, 0.31833333333333336, 0.31833333333333336, 0.32166666666666666, 0.32166666666666666, 0.3233333333333333, 0.3233333333333333, 0.3283333333333333, 0.3283333333333333, 0.33, 0.33, 0.3333333333333333, 0.3333333333333333, 0.335, 0.335, 0.33666666666666667, 0.33666666666666667, 0.3383333333333333, 0.3383333333333333, 0.34, 0.34, 0.35, 0.35, 0.3516666666666667, 0.3516666666666667, 0.355, 0.355, 0.3566666666666667, 0.3566666666666667, 0.35833333333333334, 0.35833333333333334, 0.3616666666666667, 0.3616666666666667, 0.36333333333333334, 0.36333333333333334, 0.36666666666666664, 0.36666666666666664, 0.37166666666666665, 0.37166666666666665, 0.375, 0.375, 0.37833333333333335, 0.37833333333333335, 0.38, 0.38, 0.39166666666666666, 0.39166666666666666, 0.3983333333333333, 0.3983333333333333, 0.4, 0.4, 0.40166666666666667, 0.40166666666666667, 0.4083333333333333, 0.4083333333333333, 0.41, 0.41, 0.4116666666666667, 0.4116666666666667, 0.41333333333333333, 0.41333333333333333, 0.415, 0.415, 0.42, 0.42, 0.43833333333333335, 0.43833333333333335, 0.44166666666666665, 0.44166666666666665, 0.44333333333333336, 0.44333333333333336, 0.445, 0.445, 0.45166666666666666, 0.45166666666666666, 0.4533333333333333, 0.4533333333333333, 0.455, 0.455, 0.4583333333333333, 0.4583333333333333, 0.46, 0.46, 0.4633333333333333, 0.4633333333333333, 0.4683333333333333, 0.4683333333333333, 0.4716666666666667, 0.4716666666666667, 0.47333333333333333, 0.47333333333333333, 0.4766666666666667, 0.4766666666666667, 0.47833333333333333, 0.47833333333333333, 0.49166666666666664, 0.49166666666666664, 0.49333333333333335, 0.49333333333333335, 0.49666666666666665, 0.49666666666666665, 0.5066666666666667, 0.5066666666666667, 0.5116666666666667, 0.5116666666666667, 0.5133333333333333, 0.5133333333333333, 0.5183333333333333, 0.5183333333333333, 0.52, 0.52, 0.525, 0.525, 0.5266666666666666, 0.5266666666666666, 0.5316666666666666, 0.5316666666666666, 0.5333333333333333, 0.5333333333333333, 0.535, 0.535, 0.5366666666666666, 0.5366666666666666, 0.5416666666666666, 0.5416666666666666, 0.545, 0.545, 0.5483333333333333, 0.5483333333333333, 0.5566666666666666, 0.5566666666666666, 0.56, 0.56, 0.57, 0.57, 0.5716666666666667, 0.5716666666666667, 0.575, 0.575, 0.58, 0.58, 0.5883333333333334, 0.5883333333333334, 0.5916666666666667, 0.5916666666666667, 0.5983333333333334, 0.5983333333333334, 0.605, 0.605, 0.6066666666666667, 0.6066666666666667, 0.615, 0.615, 0.6266666666666667, 0.6266666666666667, 0.635, 0.635, 0.6483333333333333, 0.6483333333333333, 0.6533333333333333, 0.6533333333333333, 0.655, 0.655, 0.6616666666666666, 0.6616666666666666, 0.6683333333333333, 0.6683333333333333, 0.6716666666666666, 0.6716666666666666, 0.6766666666666666, 0.6766666666666666, 0.685, 0.685, 0.6966666666666667, 0.6966666666666667, 0.715, 0.715, 0.72, 0.72, 0.7533333333333333, 0.7533333333333333, 0.7583333333333333, 0.7583333333333333, 0.76, 0.76, 0.7666666666666667, 0.7666666666666667, 0.79, 0.79, 0.7966666666666666, 0.7966666666666666, 0.805, 0.805, 0.82, 0.82, 0.8283333333333334, 0.8283333333333334, 0.83, 0.83, 0.845, 0.845, 0.865, 0.865, 0.88, 0.88, 0.8866666666666667, 0.8866666666666667, 0.9133333333333333, 0.9133333333333333, 0.965, 0.9983333333333333, 0.9983333333333333, 1.0], "tpr": [0.0, 0.0016666666666666668, 0.0033333333333333335, 0.0033333333333333335, 0.005, 0.005, 0.011666666666666667, 0.011666666666666667, 0.015, 0.015, 0.016666666666666666, 0.016666666666666666, 0.018333333333333333, 0.018333333333333333, 0.021666666666666667, 0.021666666666666667, 0.028333333333333332, 0.028333333333333332, 0.03166666666666667, 0.03166666666666667, 0.045, 0.045, 0.04666666666666667, 0.04666666666666667, 0.05, 0.05, 0.05333333333333334, 0.05333333333333334, 0.055, 0.055, 0.056666666666666664, 0.056666666666666664, 0.058333333333333334, 0.058333333333333334, 0.06, 0.06, 0.065, 0.065, 0.07333333333333333, 0.07333333333333333, 0.07833333333333334, 0.07833333333333334, 0.08, 0.08, 0.09166666666666666, 0.09166666666666666, 0.10333333333333333, 0.10333333333333333, 0.11166666666666666, 0.11166666666666666, 0.115, 0.115, 0.11833333333333333, 0.11833333333333333, 0.12, 0.12, 0.12166666666666667, 0.12166666666666667, 0.125, 0.125, 0.13166666666666665, 0.13166666666666665, 0.135, 0.135, 0.13833333333333334, 0.13833333333333334, 0.15, 0.15, 0.16166666666666665, 0.16166666666666665, 0.16333333333333333, 0.16333333333333333, 0.165, 0.165, 0.18, 0.18, 0.18833333333333332, 0.18833333333333332, 0.20166666666666666, 0.20166666666666666, 0.21166666666666667, 0.21166666666666667, 0.215, 0.215, 0.22, 0.22, 0.22833333333333333, 0.22833333333333333, 0.23833333333333334, 0.23833333333333334, 0.24166666666666667, 0.24166666666666667, 0.24666666666666667, 0.24666666666666667, 0.255, 0.255, 0.25833333333333336, 0.25833333333333336, 0.2633333333333333, 0.2633333333333333, 0.265, 0.265, 0.26666666666666666, 0.26666666666666666, 0.2683333333333333, 0.2683333333333333, 0.27666666666666667, 0.27666666666666667, 0.2866666666666667, 0.2866666666666667, 0.2916666666666667, 0.2916666666666667, 0.29333333333333333, 0.29333333333333333, 0.295, 0.295, 0.3016666666666667, 0.3016666666666667, 0.31333333333333335, 0.31333333333333335, 0.3383333333333333, 0.3383333333333333, 0.3466666666666667, 0.3466666666666667, 0.35, 0.35, 0.3516666666666667, 0.3516666666666667, 0.3566666666666667, 0.3566666666666667, 0.365, 0.365, 0.36833333333333335, 0.36833333333333335, 0.37166666666666665, 0.37166666666666665, 0.37333333333333335, 0.37333333333333335, 0.375, 0.375, 0.37833333333333335, 0.37833333333333335, 0.38166666666666665, 0.38166666666666665, 0.3933333333333333, 0.3933333333333333, 0.395, 0.395, 0.405, 0.405, 0.4083333333333333, 0.4083333333333333, 0.41333333333333333, 0.41333333333333333, 0.415, 0.415, 0.4166666666666667, 0.4166666666666667, 0.4216666666666667, 0.4216666666666667, 0.42333333333333334, 0.42333333333333334, 0.43, 0.43, 0.445, 0.445, 0.4483333333333333, 0.4483333333333333, 0.45166666666666666, 0.45166666666666666, 0.45666666666666667, 0.45666666666666667, 0.4583333333333333, 0.4583333333333333, 0.46166666666666667, 0.46166666666666667, 0.47, 0.47, 0.47333333333333333, 0.47333333333333333, 0.4766666666666667, 0.4766666666666667, 0.485, 0.485, 0.4866666666666667, 0.4866666666666667, 0.48833333333333334, 0.48833333333333334, 0.49166666666666664, 0.49166666666666664, 0.5083333333333333, 0.5083333333333333, 0.51, 0.51, 0.5133333333333333, 0.5133333333333333, 0.515, 0.515, 0.5166666666666667, 0.5166666666666667, 0.5333333333333333, 0.5333333333333333, 0.5383333333333333, 0.5383333333333333, 0.5483333333333333, 0.5483333333333333, 0.55, 0.55, 0.5583333333333333, 0.5583333333333333, 0.56, 0.56, 0.5616666666666666, 0.5616666666666666, 0.5683333333333334, 0.5683333333333334, 0.5733333333333334, 0.5733333333333334, 0.5816666666666667, 0.5816666666666667, 0.5866666666666667, 0.5866666666666667, 0.5883333333333334, 0.5883333333333334, 0.5966666666666667, 0.5966666666666667, 0.5983333333333334, 0.5983333333333334, 0.6033333333333334, 0.6033333333333334, 0.605, 0.605, 0.6083333333333333, 0.6083333333333333, 0.6166666666666667, 0.6166666666666667, 0.6183333333333333, 0.6183333333333333, 0.6216666666666667, 0.6216666666666667, 0.6316666666666667, 0.6316666666666667, 0.6366666666666667, 0.6366666666666667, 0.6416666666666667, 0.6416666666666667, 0.65, 0.65, 0.66, 0.66, 0.6616666666666666, 0.6616666666666666, 0.6666666666666666, 0.6666666666666666, 0.67, 0.67, 0.6716666666666666, 0.6716666666666666, 0.675, 0.675, 0.6783333333333333, 0.6783333333333333, 0.6866666666666666, 0.6866666666666666, 0.69, 0.69, 0.6916666666666667, 0.6916666666666667, 0.6933333333333334, 0.6933333333333334, 0.6966666666666667, 0.6966666666666667, 0.7, 0.7, 0.7083333333333334, 0.7083333333333334, 0.715, 0.715, 0.72, 0.72, 0.7266666666666667, 0.7266666666666667, 0.73, 0.73, 0.7333333333333333, 0.7333333333333333, 0.735, 0.735, 0.7366666666666667, 0.7366666666666667, 0.7383333333333333, 0.7383333333333333, 0.745, 0.745, 0.7483333333333333, 0.7483333333333333, 0.7516666666666667, 0.7516666666666667, 0.7566666666666667, 0.7566666666666667, 0.7583333333333333, 0.7583333333333333, 0.7633333333333333, 0.7633333333333333, 0.7683333333333333, 0.7683333333333333, 0.7733333333333333, 0.7733333333333333, 0.7766666666666666, 0.7766666666666666, 0.7816666666666666, 0.7816666666666666, 0.785, 0.785, 0.7933333333333333, 0.7933333333333333, 0.795, 0.795, 0.7966666666666666, 0.7966666666666666, 0.8033333333333333, 0.8033333333333333, 0.805, 0.805, 0.8083333333333333, 0.8083333333333333, 0.81, 0.81, 0.8116666666666666, 0.8116666666666666, 0.8183333333333334, 0.8183333333333334, 0.8266666666666667, 0.8266666666666667, 0.83, 0.83, 0.8316666666666667, 0.8316666666666667, 0.835, 0.835, 0.8383333333333334, 0.8383333333333334, 0.845, 0.845, 0.8483333333333334, 0.8483333333333334, 0.85, 0.85, 0.8533333333333334, 0.8533333333333334, 0.8583333333333333, 0.8583333333333333, 0.8616666666666667, 0.8616666666666667, 0.8666666666666667, 0.8666666666666667, 0.8683333333333333, 0.8683333333333333, 0.8716666666666667, 0.8716666666666667, 0.8733333333333333, 0.8733333333333333, 0.875, 0.875, 0.8816666666666667, 0.8816666666666667, 0.8833333333333333, 0.8833333333333333, 0.885, 0.885, 0.8866666666666667, 0.8866666666666667, 0.8883333333333333, 0.8883333333333333, 0.89, 0.89, 0.8933333333333333, 0.8933333333333333, 0.9016666666666666, 0.9016666666666666, 0.905, 0.905, 0.9066666666666666, 0.9066666666666666, 0.9083333333333333, 0.9083333333333333, 0.91, 0.91, 0.9133333333333333, 0.9133333333333333, 0.9183333333333333, 0.9183333333333333, 0.92, 0.92, 0.9216666666666666, 0.9216666666666666, 0.9266666666666666, 0.9266666666666666, 0.93, 0.93, 0.9316666666666666, 0.9316666666666666, 0.9383333333333334, 0.9383333333333334, 0.94, 0.94, 0.9433333333333334, 0.9433333333333334, 0.945, 0.945, 0.9466666666666667, 0.9466666666666667, 0.9483333333333334, 0.9483333333333334, 0.95, 0.95, 0.9516666666666667, 0.9516666666666667, 0.9533333333333334, 0.9533333333333334, 0.955, 0.955, 0.9566666666666667, 0.9566666666666667, 0.9583333333333334, 0.9583333333333334, 0.96, 0.96, 0.9616666666666667, 0.9616666666666667, 0.965, 0.965, 0.9666666666666667, 0.9666666666666667, 0.9683333333333334, 0.9683333333333334, 0.97, 0.97, 0.9716666666666667, 0.9716666666666667, 0.9733333333333334, 0.9733333333333334, 0.9766666666666667, 0.9766666666666667, 0.9783333333333334, 0.9783333333333334, 0.98, 0.98, 0.9833333333333333, 0.9833333333333333, 0.985, 0.985, 0.9866666666666667, 0.9866666666666667, 0.99, 0.99, 0.9916666666666667, 0.9916666666666667, 0.9933333333333333, 0.9933333333333333, 0.995, 0.995, 0.9966666666666667, 0.9966666666666667, 0.9983333333333333, 0.9983333333333333, 0.9983333333333333, 1.0, 1.0]}, "pr_metrics": {"pr_auc": 0.6637687973993442, "precision": [0.5, 0.5004170141784821, 0.5, 0.5084889643463497, 0.5089209855564996, 0.5093537414965986, 0.5097872340425532, 0.510221465076661, 0.5106564364876386, 0.5110921501706485, 0.511528608027327, 0.5119658119658119, 0.5124037639007699, 0.5128424657534246, 0.5132819194515853, 0.5137221269296741, 0.5141630901287554, 0.5146048109965635, 0.5150472914875323, 0.5154905335628227, 0.5159345391903531, 0.5163793103448275, 0.5168248490077653, 0.5172711571675302, 0.5177182368193605, 0.5181660899653979, 0.5186147186147186, 0.5190641247833622, 0.5195143104943626, 0.5199652777777778, 0.5204170286707211, 0.5208695652173913, 0.5213228894691035, 0.5217770034843205, 0.5222319093286836, 0.5218150087260035, 0.5222707423580786, 0.5227272727272727, 0.5231846019247594, 0.5236427320490368, 0.5241016652059597, 0.5245614035087719, 0.5250219490781387, 0.5254833040421792, 0.5259454705364995, 0.5264084507042254, 0.5268722466960353, 0.527336860670194, 0.527802294792586, 0.5282685512367491, 0.5287356321839081, 0.5292035398230088, 0.5287865367581931, 0.5292553191489362, 0.5297249334516415, 0.5301953818827708, 0.5306666666666666, 0.5302491103202847, 0.5307212822796082, 0.5311942959001783, 0.5316681534344335, 0.5321428571428571, 0.5326184092940125, 0.5330948121645797, 0.5335720680393913, 0.5340501792114696, 0.5345291479820627, 0.5341113105924596, 0.5345911949685535, 0.5350719424460432, 0.5355535553555355, 0.536036036036036, 0.5365193868349865, 0.5370036101083032, 0.5374887082204155, 0.5379746835443038, 0.5384615384615384, 0.5389492753623188, 0.5394378966455122, 0.5399274047186933, 0.5395095367847411, 0.54, 0.54049135577798, 0.5409836065573771, 0.5414767547857794, 0.541970802919708, 0.5424657534246575, 0.5429616087751371, 0.5434583714547118, 0.5439560439560439, 0.5435380384967919, 0.5431192660550459, 0.5436179981634527, 0.5431985294117647, 0.5436982520699172, 0.5441988950276243, 0.5447004608294931, 0.5452029520295203, 0.5457063711911357, 0.5452865064695009, 0.545790934320074, 0.5462962962962963, 0.5468025949953661, 0.5473098330241187, 0.5478180129990715, 0.5483271375464684, 0.5488372093023256, 0.5493482309124768, 0.5498602050326188, 0.5494402985074627, 0.5490196078431373, 0.5495327102803739, 0.5500467726847521, 0.550561797752809, 0.5510777881911902, 0.551594746716698, 0.5511737089201878, 0.5516917293233082, 0.5522107243650047, 0.5527306967984934, 0.5532516493873704, 0.5528301886792453, 0.5533522190745986, 0.553875236294896, 0.554399243140965, 0.5549242424242424, 0.5554502369668246, 0.5559772296015181, 0.5565052231718899, 0.5570342205323194, 0.5575642245480494, 0.5580952380952381, 0.5586272640610105, 0.5591603053435115, 0.559694364851958, 0.5602294455066922, 0.5598086124401914, 0.5593869731800766, 0.5599232981783318, 0.5604606525911708, 0.5609990393852066, 0.5615384615384615, 0.5611164581328201, 0.5616570327552987, 0.5612343297974928, 0.5617760617760618, 0.5623188405797102, 0.562862669245648, 0.5624394966118103, 0.562984496124031, 0.5635305528612997, 0.5640776699029126, 0.564625850340136, 0.5651750972762646, 0.5657254138266796, 0.5662768031189084, 0.5668292682926829, 0.5673828125, 0.5679374389051809, 0.5684931506849316, 0.5690499510284035, 0.5696078431372549, 0.5701668302257115, 0.5707269155206287, 0.5712881022615536, 0.5718503937007874, 0.5724137931034483, 0.5729783037475346, 0.5735439289239882, 0.5731225296442688, 0.5736894164193868, 0.5742574257425742, 0.574826560951437, 0.5744047619047619, 0.5749751737835154, 0.5755467196819085, 0.5761194029850746, 0.5766932270916335, 0.5772681954137587, 0.5778443113772455, 0.5784215784215784, 0.579, 0.5795795795795796, 0.5801603206412825, 0.5807422266800402, 0.5803212851405622, 0.5798994974874372, 0.5804828973843058, 0.581067472306143, 0.5816532258064516, 0.5822401614530777, 0.5828282828282828, 0.583417593528817, 0.5840080971659919, 0.5835866261398176, 0.5841784989858012, 0.584771573604061, 0.5853658536585366, 0.5859613428280773, 0.5865580448065173, 0.5861365953109072, 0.5867346938775511, 0.5873340143003064, 0.5879345603271984, 0.5875127942681678, 0.5881147540983607, 0.5887179487179487, 0.5882956878850103, 0.5889003083247688, 0.5895061728395061, 0.5901132852729145, 0.5907216494845361, 0.5902992776057792, 0.5909090909090909, 0.5915201654601862, 0.5921325051759835, 0.5927461139896373, 0.5923236514522822, 0.592938733125649, 0.5925155925155925, 0.5931321540062435, 0.59375, 0.59436913451512, 0.593945720250522, 0.5945663531870429, 0.5951882845188284, 0.5958115183246073, 0.5964360587002097, 0.5970619097586569, 0.5976890756302521, 0.5983175604626709, 0.5989473684210527, 0.5985247629083246, 0.5991561181434599, 0.5997888067581837, 0.6004228329809725, 0.6010582010582011, 0.6016949152542372, 0.601272534464475, 0.6019108280254777, 0.6025504782146652, 0.6031914893617021, 0.6038338658146964, 0.6044776119402985, 0.6051227321237994, 0.6057692307692307, 0.6053475935828877, 0.6059957173447538, 0.6066452304394426, 0.6072961373390557, 0.6079484425349087, 0.6086021505376344, 0.6081808396124866, 0.6077586206896551, 0.6084142394822006, 0.6079913606911447, 0.6086486486486486, 0.6093073593073594, 0.609967497291441, 0.6106290672451193, 0.6102062975027145, 0.6097826086956522, 0.6093579978237215, 0.6089324618736384, 0.6095965103598692, 0.6102620087336245, 0.6109289617486339, 0.611597374179431, 0.6111719605695509, 0.6118421052631579, 0.6125137211855104, 0.6120879120879121, 0.6116611661166117, 0.6123348017621145, 0.6130099228224918, 0.6136865342163356, 0.6143646408839779, 0.6150442477876106, 0.6146179401993356, 0.614190687361419, 0.6137624861265261, 0.6144444444444445, 0.6151279199110122, 0.6158129175946548, 0.6153846153846154, 0.6160714285714286, 0.6167597765363129, 0.616331096196868, 0.6170212765957447, 0.6165919282511211, 0.6161616161616161, 0.6157303370786517, 0.6164229471316085, 0.6171171171171171, 0.6178128523111612, 0.618510158013544, 0.6192090395480226, 0.6199095022624435, 0.6194790486976217, 0.6190476190476191, 0.619750283768445, 0.6204545454545455, 0.6200227531285551, 0.6207289293849658, 0.621436716077537, 0.6221461187214612, 0.6228571428571429, 0.6235697940503433, 0.6231386025200458, 0.6238532110091743, 0.6245694603903559, 0.6241379310344828, 0.6248561565017261, 0.6255760368663594, 0.6251441753171857, 0.6247113163972287, 0.6254335260115607, 0.6261574074074074, 0.626882966396292, 0.6264501160092807, 0.6260162601626016, 0.6255813953488372, 0.6251455180442375, 0.6247086247086248, 0.6254375729288215, 0.625, 0.624561403508772, 0.6252927400468384, 0.6248534583821805, 0.6255868544600939, 0.6251468860164512, 0.6258823529411764, 0.6266195524146054, 0.6273584905660378, 0.6269185360094451, 0.6276595744680851, 0.6272189349112426, 0.6279620853080569, 0.6287069988137604, 0.6294536817102138, 0.629013079667063, 0.6297619047619047, 0.6293206197854588, 0.6288782816229117, 0.6284348864994026, 0.6279904306220095, 0.6287425149700598, 0.6294964028776978, 0.6302521008403361, 0.6298076923076923, 0.6305655836341757, 0.6301204819277109, 0.6308805790108565, 0.6316425120772947, 0.6324062877871826, 0.6319612590799032, 0.6315151515151515, 0.6322815533980582, 0.6330498177399757, 0.6338199513381995, 0.6345919610231425, 0.6353658536585366, 0.6361416361416361, 0.6356968215158925, 0.6364749082007344, 0.6372549019607843, 0.6368098159509202, 0.6363636363636364, 0.6359163591635917, 0.6366995073891626, 0.6362515413070283, 0.6358024691358025, 0.6365883807169345, 0.6373762376237624, 0.6381660470879802, 0.6389578163771712, 0.639751552795031, 0.6405472636815921, 0.6413449564134496, 0.64214463840399, 0.6416978776529338, 0.64125, 0.6408010012515645, 0.6416040100250626, 0.6411543287327478, 0.6407035175879398, 0.6415094339622641, 0.6423173803526449, 0.6418663303909206, 0.6426767676767676, 0.6422250316055625, 0.6417721518987342, 0.6425855513307985, 0.6434010152284264, 0.6429479034307497, 0.6424936386768448, 0.6420382165605095, 0.6415816326530612, 0.6424010217113666, 0.6432225063938619, 0.6440460947503202, 0.6435897435897436, 0.6431322207958922, 0.6439588688946015, 0.6447876447876448, 0.6443298969072165, 0.6438709677419355, 0.6447028423772609, 0.6442432082794308, 0.6450777202072538, 0.6459143968871596, 0.6454545454545455, 0.6449934980494149, 0.6458333333333334, 0.6453715775749674, 0.6449086161879896, 0.6444444444444445, 0.643979057591623, 0.6435124508519003, 0.6443569553805775, 0.6438896189224704, 0.6434210526315789, 0.6429512516469038, 0.6424802110817942, 0.6433289299867899, 0.6441798941798942, 0.6450331125827815, 0.6458885941644562, 0.6454183266932271, 0.6462765957446809, 0.6458055925432756, 0.6466666666666666, 0.6461949265687583, 0.6457219251336899, 0.6465863453815262, 0.6474530831099196, 0.6469798657718121, 0.6478494623655914, 0.648721399730821, 0.6495956873315364, 0.650472334682861, 0.6513513513513514, 0.652232746955345, 0.6531165311653117, 0.6540027137042063, 0.654891304347826, 0.6557823129251701, 0.6566757493188011, 0.6562073669849932, 0.6557377049180327, 0.655266757865937, 0.6547945205479452, 0.6556927297668038, 0.6565934065934066, 0.657496561210454, 0.6570247933884298, 0.6579310344827586, 0.6574585635359116, 0.6583679114799447, 0.6578947368421053, 0.6574202496532594, 0.6569444444444444, 0.6564673157162726, 0.6559888579387186, 0.6569037656903766, 0.6564245810055865, 0.6559440559440559, 0.6568627450980392, 0.6563814866760168, 0.6558988764044944, 0.6554149085794655, 0.6563380281690141, 0.6572637517630465, 0.6581920903954802, 0.6591230551626591, 0.6586402266288952, 0.6581560283687943, 0.6590909090909091, 0.6586059743954481, 0.6581196581196581, 0.6576319543509273, 0.6585714285714286, 0.6580829756795422, 0.6575931232091691, 0.6571018651362984, 0.6580459770114943, 0.6589928057553956, 0.659942363112392, 0.6608946608946609, 0.6604046242774566, 0.6599131693198264, 0.6594202898550725, 0.660377358490566, 0.6613372093023255, 0.6622998544395924, 0.6632653061224489, 0.6642335766423357, 0.6652046783625731, 0.6661786237188873, 0.6656891495601173, 0.6666666666666666, 0.6661764705882353, 0.6656848306332842, 0.6651917404129793, 0.6661742983751846, 0.6671597633136095, 0.6666666666666666, 0.6661721068249258, 0.6671619613670133, 0.6681547619047619, 0.6676602086438153, 0.6671641791044776, 0.6681614349775785, 0.6691616766467066, 0.6701649175412294, 0.6696696696696697, 0.6691729323308271, 0.6686746987951807, 0.6681749622926093, 0.6691842900302115, 0.670196671709531, 0.6696969696969697, 0.6707132018209409, 0.6702127659574468, 0.6712328767123288, 0.6722560975609756, 0.6717557251908397, 0.672782874617737, 0.6722817764165391, 0.6717791411042945, 0.6728110599078341, 0.6723076923076923, 0.6718027734976888, 0.6728395061728395, 0.6738794435857806, 0.673374613003096, 0.6728682170542636, 0.672360248447205, 0.671850699844479, 0.6728971962616822, 0.672386895475819, 0.671875, 0.6713615023474179, 0.6724137931034483, 0.673469387755102, 0.6745283018867925, 0.6755905511811023, 0.6766561514195584, 0.6777251184834123, 0.6772151898734177, 0.6767036450079239, 0.6761904761904762, 0.6756756756756757, 0.6767515923566879, 0.6762360446570973, 0.6757188498402555, 0.6752, 0.6746794871794872, 0.6741573033707865, 0.6752411575562701, 0.6747181964573269, 0.6741935483870968, 0.6752827140549273, 0.6747572815533981, 0.6742301458670988, 0.6753246753246753, 0.6747967479674797, 0.6758957654723127, 0.6769983686786297, 0.6764705882352942, 0.6775777414075287, 0.6770491803278689, 0.6765188834154351, 0.6776315789473685, 0.6787479406919276, 0.6798679867986799, 0.6793388429752066, 0.6788079470198676, 0.6782752902155887, 0.6777408637873754, 0.6772046589018302, 0.6783333333333333, 0.67779632721202, 0.677257525083612, 0.678391959798995, 0.6795302013422819, 0.6789915966386555, 0.6784511784511784, 0.6795952782462057, 0.6790540540540541, 0.6802030456852792, 0.6813559322033899, 0.6808149405772496, 0.6802721088435374, 0.6814310051107325, 0.6825938566552902, 0.6820512820512821, 0.6815068493150684, 0.6809605488850772, 0.6821305841924399, 0.6815834767641996, 0.6827586206896552, 0.6839378238341969, 0.6851211072664359, 0.6863084922010398, 0.6875, 0.688695652173913, 0.6881533101045296, 0.68760907504363, 0.6870629370629371, 0.6865148861646234, 0.6859649122807018, 0.6854130052724078, 0.6866197183098591, 0.6860670194003528, 0.6855123674911661, 0.6849557522123894, 0.6843971631205674, 0.6838365896980462, 0.6850533807829181, 0.6862745098039216, 0.6875, 0.6887298747763864, 0.6899641577060932, 0.6894075403949731, 0.6888489208633094, 0.6882882882882883, 0.6895306859205776, 0.6907775768535263, 0.6902173913043478, 0.6896551724137931, 0.6890909090909091, 0.6903460837887068, 0.6897810218978102, 0.6892138939670932, 0.6886446886446886, 0.6880733944954128, 0.6875, 0.6869244935543278, 0.6881918819188192, 0.6876155268022182, 0.687037037037037, 0.6883116883116883, 0.6895910780669146, 0.6890130353817505, 0.6902985074626866, 0.6897196261682244, 0.6891385767790262, 0.6885553470919324, 0.6879699248120301, 0.687382297551789, 0.6886792452830188, 0.6880907372400756, 0.6875, 0.6888045540796964, 0.6901140684410646, 0.6914285714285714, 0.6908396946564885, 0.6921606118546845, 0.6934865900383141, 0.6928982725527831, 0.6923076923076923, 0.6917148362235067, 0.693050193050193, 0.6943907156673114, 0.6937984496124031, 0.6951456310679611, 0.6945525291828794, 0.6939571150097466, 0.693359375, 0.6927592954990215, 0.692156862745098, 0.693516699410609, 0.6929133858267716, 0.6942800788954635, 0.6956521739130435, 0.697029702970297, 0.6984126984126984, 0.6998011928429424, 0.6992031872509961, 0.6986027944111777, 0.698, 0.6993987975951904, 0.7008032128514057, 0.7002012072434608, 0.6995967741935484, 0.6989898989898989, 0.6983805668016194, 0.6977687626774848, 0.6991869918699187, 0.7006109979633401, 0.7, 0.6993865030674846, 0.6987704918032787, 0.7002053388090349, 0.6995884773662552, 0.6989690721649484, 0.6983471074380165, 0.6977225672877847, 0.6991701244813278, 0.6985446985446986, 0.7, 0.6993736951983298, 0.700836820083682, 0.70020964360587, 0.6995798319327731, 0.6989473684210527, 0.6983122362869199, 0.6976744186046512, 0.6991525423728814, 0.6985138004246284, 0.7, 0.7014925373134329, 0.7029914529914529, 0.702355460385439, 0.7017167381974249, 0.7010752688172043, 0.7004310344827587, 0.6997840172786177, 0.6991341991341992, 0.7006507592190889, 0.7, 0.6993464052287581, 0.6986899563318777, 0.700218818380744, 0.6995614035087719, 0.6989010989010989, 0.698237885462555, 0.6975717439293598, 0.6969026548672567, 0.6962305986696231, 0.6955555555555556, 0.6948775055679287, 0.6941964285714286, 0.6935123042505593, 0.695067264573991, 0.6943820224719102, 0.6959459459459459, 0.6952595936794582, 0.6968325791855203, 0.6961451247165533, 0.6954545454545454, 0.6970387243735763, 0.6963470319634704, 0.6979405034324943, 0.6995412844036697, 0.7011494252873564, 0.7027649769585254, 0.7020785219399538, 0.7013888888888888, 0.7006960556844548, 0.7, 0.6993006993006993, 0.6985981308411215, 0.6978922716627635, 0.6971830985915493, 0.6964705882352941, 0.6957547169811321, 0.6973995271867612, 0.6966824644549763, 0.6959619952494062, 0.6976190476190476, 0.6992840095465394, 0.6985645933014354, 0.7002398081534772, 0.6995192307692307, 0.7012048192771084, 0.7028985507246377, 0.7046004842615012, 0.7063106796116505, 0.708029197080292, 0.7073170731707317, 0.706601466992665, 0.7058823529411765, 0.7051597051597052, 0.7044334975369458, 0.7061728395061728, 0.7054455445544554, 0.7047146401985112, 0.7064676616915423, 0.7057356608478803, 0.705, 0.706766917293233, 0.7085427135678392, 0.7103274559193955, 0.7121212121212122, 0.7113924050632912, 0.7106598984771574, 0.7099236641221374, 0.7091836734693877, 0.7084398976982097, 0.7102564102564103, 0.7095115681233933, 0.7087628865979382, 0.710594315245478, 0.7098445595854922, 0.7116883116883117, 0.7109375, 0.7101827676240209, 0.7094240837696335, 0.7112860892388452, 0.7105263157894737, 0.7097625329815304, 0.7116402116402116, 0.713527851458886, 0.7127659574468085, 0.712, 0.713903743315508, 0.7131367292225201, 0.7123655913978495, 0.7115902964959568, 0.7108108108108108, 0.7100271002710027, 0.7092391304347826, 0.7084468664850136, 0.7076502732240437, 0.7068493150684931, 0.7087912087912088, 0.7079889807162535, 0.7071823204419889, 0.7063711911357341, 0.7055555555555556, 0.7075208913649025, 0.7067039106145251, 0.7086834733893558, 0.7078651685393258, 0.7070422535211267, 0.7062146892655368, 0.7082152974504249, 0.7073863636363636, 0.7094017094017094, 0.7085714285714285, 0.7106017191977078, 0.7097701149425287, 0.7089337175792507, 0.708092485549133, 0.7101449275362319, 0.7093023255813954, 0.7084548104956269, 0.7105263157894737, 0.7096774193548387, 0.7088235294117647, 0.7079646017699115, 0.7071005917159763, 0.7062314540059347, 0.7053571428571429, 0.7074626865671642, 0.7065868263473054, 0.7087087087087087, 0.7078313253012049, 0.7069486404833837, 0.706060606060606, 0.7051671732522796, 0.7042682926829268, 0.7033639143730887, 0.7024539877300614, 0.7046153846153846, 0.7037037037037037, 0.7027863777089783, 0.7049689440993789, 0.7040498442367601, 0.703125, 0.7053291536050157, 0.7044025157232704, 0.7066246056782335, 0.7056962025316456, 0.707936507936508, 0.7070063694267515, 0.7060702875399361, 0.7083333333333334, 0.707395498392283, 0.7064516129032258, 0.7087378640776699, 0.7077922077922078, 0.7068403908794788, 0.7058823529411765, 0.7049180327868853, 0.7039473684210527, 0.7062706270627063, 0.7052980132450332, 0.7043189368770764, 0.7033333333333334, 0.705685618729097, 0.7046979865771812, 0.7070707070707071, 0.706081081081081, 0.7050847457627119, 0.7074829931972789, 0.7064846416382252, 0.7054794520547946, 0.7044673539518901, 0.7034482758620689, 0.7024221453287197, 0.7048611111111112, 0.7073170731707317, 0.7062937062937062, 0.7052631578947368, 0.704225352112676, 0.7031802120141343, 0.7021276595744681, 0.701067615658363, 0.7, 0.6989247311827957, 0.697841726618705, 0.6967509025270758, 0.6956521739130435, 0.6945454545454546, 0.6934306569343066, 0.6923076923076923, 0.6911764705882353, 0.6937269372693727, 0.6925925925925925, 0.6914498141263941, 0.6902985074626866, 0.6891385767790262, 0.6879699248120301, 0.6867924528301886, 0.6856060606060606, 0.688212927756654, 0.6870229007633588, 0.685823754789272, 0.6846153846153846, 0.6833976833976834, 0.686046511627907, 0.6848249027237354, 0.6875, 0.6901960784313725, 0.6889763779527559, 0.691699604743083, 0.6904761904761905, 0.6892430278884463, 0.688, 0.6907630522088354, 0.6895161290322581, 0.6882591093117408, 0.6869918699186992, 0.6857142857142857, 0.6844262295081968, 0.6831275720164609, 0.6859504132231405, 0.6846473029045643, 0.6833333333333333, 0.6820083682008368, 0.680672268907563, 0.679324894514768, 0.6822033898305084, 0.6808510638297872, 0.6837606837606838, 0.6824034334763949, 0.6853448275862069, 0.683982683982684, 0.6869565217391305, 0.6899563318777293, 0.6929824561403509, 0.6960352422907489, 0.6946902654867256, 0.6933333333333334, 0.6919642857142857, 0.695067264573991, 0.6981981981981982, 0.6968325791855203, 0.6954545454545454, 0.6986301369863014, 0.7018348623853211, 0.7004608294930875, 0.6990740740740741, 0.6976744186046512, 0.6962616822429907, 0.6948356807511737, 0.6981132075471698, 0.6966824644549763, 0.6952380952380952, 0.69377990430622, 0.6971153846153846, 0.6956521739130435, 0.6941747572815534, 0.697560975609756, 0.696078431372549, 0.6945812807881774, 0.693069306930693, 0.6915422885572139, 0.69, 0.6884422110552764, 0.6919191919191919, 0.6903553299492385, 0.6887755102040817, 0.6871794871794872, 0.6855670103092784, 0.6839378238341969, 0.6875, 0.6858638743455497, 0.6842105263157895, 0.6825396825396826, 0.6861702127659575, 0.6898395721925134, 0.6881720430107527, 0.6864864864864865, 0.6902173913043478, 0.6885245901639344, 0.6868131868131868, 0.6850828729281768, 0.6833333333333333, 0.6815642458100558, 0.6797752808988764, 0.6836158192090396, 0.6818181818181818, 0.68, 0.6781609195402298, 0.6763005780346821, 0.6744186046511628, 0.672514619883041, 0.6705882352941176, 0.6686390532544378, 0.6726190476190477, 0.6706586826347305, 0.6686746987951807, 0.6666666666666666, 0.6646341463414634, 0.6625766871165644, 0.6666666666666666, 0.6645962732919255, 0.6625, 0.660377358490566, 0.6582278481012658, 0.6560509554140127, 0.6538461538461539, 0.6516129032258065, 0.6493506493506493, 0.6470588235294118, 0.6513157894736842, 0.6556291390728477, 0.6533333333333333, 0.6577181208053692, 0.6554054054054054, 0.6598639455782312, 0.6575342465753424, 0.6551724137931034, 0.6527777777777778, 0.6503496503496503, 0.647887323943662, 0.6453900709219859, 0.6428571428571429, 0.6474820143884892, 0.644927536231884, 0.6423357664233577, 0.6397058823529411, 0.6370370370370371, 0.6343283582089553, 0.631578947368421, 0.6287878787878788, 0.6335877862595419, 0.6384615384615384, 0.6434108527131783, 0.640625, 0.6377952755905512, 0.6428571428571429, 0.648, 0.6451612903225806, 0.6422764227642277, 0.6475409836065574, 0.6446280991735537, 0.6416666666666667, 0.6386554621848739, 0.635593220338983, 0.6410256410256411, 0.6379310344827587, 0.6347826086956522, 0.6403508771929824, 0.6371681415929203, 0.6428571428571429, 0.6486486486486487, 0.6545454545454545, 0.6513761467889908, 0.6574074074074074, 0.6542056074766355, 0.6509433962264151, 0.6571428571428571, 0.6634615384615384, 0.6601941747572816, 0.6568627450980392, 0.6633663366336634, 0.66, 0.6565656565656566, 0.6530612244897959, 0.6494845360824743, 0.6458333333333334, 0.6526315789473685, 0.648936170212766, 0.6451612903225806, 0.6413043478260869, 0.6373626373626373, 0.6333333333333333, 0.6292134831460674, 0.625, 0.632183908045977, 0.627906976744186, 0.6235294117647059, 0.6190476190476191, 0.6144578313253012, 0.6097560975609756, 0.6049382716049383, 0.6, 0.6075949367088608, 0.6025641025641025, 0.6103896103896104, 0.6052631578947368, 0.6, 0.5945945945945946, 0.6027397260273972, 0.5972222222222222, 0.5915492957746479, 0.5857142857142857, 0.5797101449275363, 0.5735294117647058, 0.582089552238806, 0.5909090909090909, 0.5846153846153846, 0.578125, 0.5714285714285714, 0.5806451612903226, 0.5737704918032787, 0.5833333333333334, 0.576271186440678, 0.5862068965517241, 0.5789473684210527, 0.5892857142857143, 0.5818181818181818, 0.5925925925925926, 0.6037735849056604, 0.5961538461538461, 0.5882352941176471, 0.6, 0.6122448979591837, 0.625, 0.6382978723404256, 0.6304347826086957, 0.6222222222222222, 0.6363636363636364, 0.6511627906976745, 0.6428571428571429, 0.6585365853658537, 0.65, 0.6410256410256411, 0.631578947368421, 0.6216216216216216, 0.6111111111111112, 0.6, 0.5882352941176471, 0.5757575757575758, 0.59375, 0.5806451612903226, 0.5666666666666667, 0.5862068965517241, 0.5714285714285714, 0.5555555555555556, 0.5384615384615384, 0.52, 0.5416666666666666, 0.5217391304347826, 0.5, 0.5238095238095238, 0.5, 0.5263157894736842, 0.5555555555555556, 0.5882352941176471, 0.625, 0.6, 0.6428571428571429, 0.6153846153846154, 0.5833333333333334, 0.6363636363636364, 0.7, 0.6666666666666666, 0.625, 0.5714285714285714, 0.5, 0.6, 0.5, 0.6666666666666666, 1.0, 1.0, 1.0], "recall": [1.0, 1.0, 0.9983333333333333, 0.9983333333333333, 0.9983333333333333, 0.9983333333333333, 0.9983333333333333, 0.9983333333333333, 0.9983333333333333, 0.9983333333333333, 0.9983333333333333, 0.9983333333333333, 0.9983333333333333, 0.9983333333333333, 0.9983333333333333, 0.9983333333333333, 0.9983333333333333, 0.9983333333333333, 0.9983333333333333, 0.9983333333333333, 0.9983333333333333, 0.9983333333333333, 0.9983333333333333, 0.9983333333333333, 0.9983333333333333, 0.9983333333333333, 0.9983333333333333, 0.9983333333333333, 0.9983333333333333, 0.9983333333333333, 0.9983333333333333, 0.9983333333333333, 0.9983333333333333, 0.9983333333333333, 0.9983333333333333, 0.9966666666666667, 0.9966666666666667, 0.9966666666666667, 0.9966666666666667, 0.9966666666666667, 0.9966666666666667, 0.9966666666666667, 0.9966666666666667, 0.9966666666666667, 0.9966666666666667, 0.9966666666666667, 0.9966666666666667, 0.9966666666666667, 0.9966666666666667, 0.9966666666666667, 0.9966666666666667, 0.9966666666666667, 0.995, 0.995, 0.995, 0.995, 0.995, 0.9933333333333333, 0.9933333333333333, 0.9933333333333333, 0.9933333333333333, 0.9933333333333333, 0.9933333333333333, 0.9933333333333333, 0.9933333333333333, 0.9933333333333333, 0.9933333333333333, 0.9916666666666667, 0.9916666666666667, 0.9916666666666667, 0.9916666666666667, 0.9916666666666667, 0.9916666666666667, 0.9916666666666667, 0.9916666666666667, 0.9916666666666667, 0.9916666666666667, 0.9916666666666667, 0.9916666666666667, 0.9916666666666667, 0.99, 0.99, 0.99, 0.99, 0.99, 0.99, 0.99, 0.99, 0.99, 0.99, 0.9883333333333333, 0.9866666666666667, 0.9866666666666667, 0.985, 0.985, 0.985, 0.985, 0.985, 0.985, 0.9833333333333333, 0.9833333333333333, 0.9833333333333333, 0.9833333333333333, 0.9833333333333333, 0.9833333333333333, 0.9833333333333333, 0.9833333333333333, 0.9833333333333333, 0.9833333333333333, 0.9816666666666667, 0.98, 0.98, 0.98, 0.98, 0.98, 0.98, 0.9783333333333334, 0.9783333333333334, 0.9783333333333334, 0.9783333333333334, 0.9783333333333334, 0.9766666666666667, 0.9766666666666667, 0.9766666666666667, 0.9766666666666667, 0.9766666666666667, 0.9766666666666667, 0.9766666666666667, 0.9766666666666667, 0.9766666666666667, 0.9766666666666667, 0.9766666666666667, 0.9766666666666667, 0.9766666666666667, 0.9766666666666667, 0.9766666666666667, 0.975, 0.9733333333333334, 0.9733333333333334, 0.9733333333333334, 0.9733333333333334, 0.9733333333333334, 0.9716666666666667, 0.9716666666666667, 0.97, 0.97, 0.97, 0.97, 0.9683333333333334, 0.9683333333333334, 0.9683333333333334, 0.9683333333333334, 0.9683333333333334, 0.9683333333333334, 0.9683333333333334, 0.9683333333333334, 0.9683333333333334, 0.9683333333333334, 0.9683333333333334, 0.9683333333333334, 0.9683333333333334, 0.9683333333333334, 0.9683333333333334, 0.9683333333333334, 0.9683333333333334, 0.9683333333333334, 0.9683333333333334, 0.9683333333333334, 0.9683333333333334, 0.9666666666666667, 0.9666666666666667, 0.9666666666666667, 0.9666666666666667, 0.965, 0.965, 0.965, 0.965, 0.965, 0.965, 0.965, 0.965, 0.965, 0.965, 0.965, 0.965, 0.9633333333333334, 0.9616666666666667, 0.9616666666666667, 0.9616666666666667, 0.9616666666666667, 0.9616666666666667, 0.9616666666666667, 0.9616666666666667, 0.9616666666666667, 0.96, 0.96, 0.96, 0.96, 0.96, 0.96, 0.9583333333333334, 0.9583333333333334, 0.9583333333333334, 0.9583333333333334, 0.9566666666666667, 0.9566666666666667, 0.9566666666666667, 0.955, 0.955, 0.955, 0.955, 0.955, 0.9533333333333334, 0.9533333333333334, 0.9533333333333334, 0.9533333333333334, 0.9533333333333334, 0.9516666666666667, 0.9516666666666667, 0.95, 0.95, 0.95, 0.95, 0.9483333333333334, 0.9483333333333334, 0.9483333333333334, 0.9483333333333334, 0.9483333333333334, 0.9483333333333334, 0.9483333333333334, 0.9483333333333334, 0.9483333333333334, 0.9466666666666667, 0.9466666666666667, 0.9466666666666667, 0.9466666666666667, 0.9466666666666667, 0.9466666666666667, 0.945, 0.945, 0.945, 0.945, 0.945, 0.945, 0.945, 0.945, 0.9433333333333334, 0.9433333333333334, 0.9433333333333334, 0.9433333333333334, 0.9433333333333334, 0.9433333333333334, 0.9416666666666667, 0.94, 0.94, 0.9383333333333334, 0.9383333333333334, 0.9383333333333334, 0.9383333333333334, 0.9383333333333334, 0.9366666666666666, 0.935, 0.9333333333333333, 0.9316666666666666, 0.9316666666666666, 0.9316666666666666, 0.9316666666666666, 0.9316666666666666, 0.93, 0.93, 0.93, 0.9283333333333333, 0.9266666666666666, 0.9266666666666666, 0.9266666666666666, 0.9266666666666666, 0.9266666666666666, 0.9266666666666666, 0.925, 0.9233333333333333, 0.9216666666666666, 0.9216666666666666, 0.9216666666666666, 0.9216666666666666, 0.92, 0.92, 0.92, 0.9183333333333333, 0.9183333333333333, 0.9166666666666666, 0.915, 0.9133333333333333, 0.9133333333333333, 0.9133333333333333, 0.9133333333333333, 0.9133333333333333, 0.9133333333333333, 0.9133333333333333, 0.9116666666666666, 0.91, 0.91, 0.91, 0.9083333333333333, 0.9083333333333333, 0.9083333333333333, 0.9083333333333333, 0.9083333333333333, 0.9083333333333333, 0.9066666666666666, 0.9066666666666666, 0.9066666666666666, 0.905, 0.905, 0.905, 0.9033333333333333, 0.9016666666666666, 0.9016666666666666, 0.9016666666666666, 0.9016666666666666, 0.9, 0.8983333333333333, 0.8966666666666666, 0.895, 0.8933333333333333, 0.8933333333333333, 0.8916666666666667, 0.89, 0.89, 0.8883333333333333, 0.8883333333333333, 0.8866666666666667, 0.8866666666666667, 0.8866666666666667, 0.8866666666666667, 0.885, 0.885, 0.8833333333333333, 0.8833333333333333, 0.8833333333333333, 0.8833333333333333, 0.8816666666666667, 0.8816666666666667, 0.88, 0.8783333333333333, 0.8766666666666667, 0.875, 0.875, 0.875, 0.875, 0.8733333333333333, 0.8733333333333333, 0.8716666666666667, 0.8716666666666667, 0.8716666666666667, 0.8716666666666667, 0.87, 0.8683333333333333, 0.8683333333333333, 0.8683333333333333, 0.8683333333333333, 0.8683333333333333, 0.8683333333333333, 0.8683333333333333, 0.8666666666666667, 0.8666666666666667, 0.8666666666666667, 0.865, 0.8633333333333333, 0.8616666666666667, 0.8616666666666667, 0.86, 0.8583333333333333, 0.8583333333333333, 0.8583333333333333, 0.8583333333333333, 0.8583333333333333, 0.8583333333333333, 0.8583333333333333, 0.8583333333333333, 0.8583333333333333, 0.8566666666666667, 0.855, 0.8533333333333334, 0.8533333333333334, 0.8516666666666667, 0.85, 0.85, 0.85, 0.8483333333333334, 0.8483333333333334, 0.8466666666666667, 0.845, 0.845, 0.845, 0.8433333333333334, 0.8416666666666667, 0.84, 0.8383333333333334, 0.8383333333333334, 0.8383333333333334, 0.8383333333333334, 0.8366666666666667, 0.835, 0.835, 0.835, 0.8333333333333334, 0.8316666666666667, 0.8316666666666667, 0.83, 0.83, 0.83, 0.8283333333333334, 0.8266666666666667, 0.8266666666666667, 0.825, 0.8233333333333334, 0.8216666666666667, 0.82, 0.8183333333333334, 0.8183333333333334, 0.8166666666666667, 0.815, 0.8133333333333334, 0.8116666666666666, 0.8116666666666666, 0.8116666666666666, 0.8116666666666666, 0.8116666666666666, 0.81, 0.81, 0.8083333333333333, 0.8083333333333333, 0.8066666666666666, 0.805, 0.805, 0.805, 0.8033333333333333, 0.8033333333333333, 0.8033333333333333, 0.8033333333333333, 0.8033333333333333, 0.8033333333333333, 0.8033333333333333, 0.8033333333333333, 0.8033333333333333, 0.8033333333333333, 0.8033333333333333, 0.8033333333333333, 0.8016666666666666, 0.8, 0.7983333333333333, 0.7966666666666666, 0.7966666666666666, 0.7966666666666666, 0.7966666666666666, 0.795, 0.795, 0.7933333333333333, 0.7933333333333333, 0.7916666666666666, 0.79, 0.7883333333333333, 0.7866666666666666, 0.785, 0.785, 0.7833333333333333, 0.7816666666666666, 0.7816666666666666, 0.78, 0.7783333333333333, 0.7766666666666666, 0.7766666666666666, 0.7766666666666666, 0.7766666666666666, 0.7766666666666666, 0.775, 0.7733333333333333, 0.7733333333333333, 0.7716666666666666, 0.77, 0.7683333333333333, 0.7683333333333333, 0.7666666666666667, 0.765, 0.7633333333333333, 0.7633333333333333, 0.7633333333333333, 0.7633333333333333, 0.7633333333333333, 0.7616666666666667, 0.76, 0.7583333333333333, 0.7583333333333333, 0.7583333333333333, 0.7583333333333333, 0.7583333333333333, 0.7583333333333333, 0.7583333333333333, 0.7583333333333333, 0.7566666666666667, 0.7566666666666667, 0.755, 0.7533333333333333, 0.7516666666666667, 0.7516666666666667, 0.7516666666666667, 0.75, 0.7483333333333333, 0.7483333333333333, 0.7483333333333333, 0.7466666666666667, 0.745, 0.745, 0.745, 0.745, 0.7433333333333333, 0.7416666666666667, 0.74, 0.7383333333333333, 0.7383333333333333, 0.7383333333333333, 0.7366666666666667, 0.7366666666666667, 0.735, 0.735, 0.735, 0.7333333333333333, 0.7333333333333333, 0.7316666666666667, 0.73, 0.73, 0.7283333333333334, 0.7266666666666667, 0.7266666666666667, 0.7266666666666667, 0.725, 0.7233333333333334, 0.7216666666666667, 0.72, 0.72, 0.7183333333333334, 0.7166666666666667, 0.715, 0.715, 0.715, 0.715, 0.715, 0.715, 0.715, 0.7133333333333334, 0.7116666666666667, 0.71, 0.7083333333333334, 0.7083333333333334, 0.7066666666666667, 0.705, 0.7033333333333334, 0.7016666666666667, 0.7, 0.7, 0.6983333333333334, 0.6966666666666667, 0.6966666666666667, 0.695, 0.6933333333333334, 0.6933333333333334, 0.6916666666666667, 0.6916666666666667, 0.6916666666666667, 0.69, 0.69, 0.6883333333333334, 0.6866666666666666, 0.6866666666666666, 0.6866666666666666, 0.6866666666666666, 0.685, 0.6833333333333333, 0.6816666666666666, 0.68, 0.6783333333333333, 0.6783333333333333, 0.6766666666666666, 0.675, 0.675, 0.675, 0.6733333333333333, 0.6716666666666666, 0.6716666666666666, 0.67, 0.67, 0.67, 0.6683333333333333, 0.6666666666666666, 0.6666666666666666, 0.6666666666666666, 0.665, 0.6633333333333333, 0.6616666666666666, 0.6616666666666666, 0.66, 0.66, 0.66, 0.66, 0.66, 0.66, 0.66, 0.6583333333333333, 0.6566666666666666, 0.655, 0.6533333333333333, 0.6516666666666666, 0.65, 0.65, 0.6483333333333333, 0.6466666666666666, 0.645, 0.6433333333333333, 0.6416666666666667, 0.6416666666666667, 0.6416666666666667, 0.6416666666666667, 0.6416666666666667, 0.6416666666666667, 0.64, 0.6383333333333333, 0.6366666666666667, 0.6366666666666667, 0.6366666666666667, 0.635, 0.6333333333333333, 0.6316666666666667, 0.6316666666666667, 0.63, 0.6283333333333333, 0.6266666666666667, 0.625, 0.6233333333333333, 0.6216666666666667, 0.6216666666666667, 0.62, 0.6183333333333333, 0.6183333333333333, 0.6183333333333333, 0.6166666666666667, 0.6166666666666667, 0.615, 0.6133333333333333, 0.6116666666666667, 0.61, 0.6083333333333333, 0.6083333333333333, 0.6066666666666667, 0.605, 0.605, 0.605, 0.605, 0.6033333333333334, 0.6033333333333334, 0.6033333333333334, 0.6016666666666667, 0.6, 0.5983333333333334, 0.5983333333333334, 0.5983333333333334, 0.5966666666666667, 0.5966666666666667, 0.595, 0.5933333333333334, 0.5916666666666667, 0.59, 0.5883333333333334, 0.5883333333333334, 0.5866666666666667, 0.5866666666666667, 0.5866666666666667, 0.5866666666666667, 0.5866666666666667, 0.5866666666666667, 0.585, 0.5833333333333334, 0.5816666666666667, 0.5816666666666667, 0.5816666666666667, 0.58, 0.5783333333333334, 0.5766666666666667, 0.575, 0.5733333333333334, 0.5733333333333334, 0.5733333333333334, 0.5716666666666667, 0.57, 0.5683333333333334, 0.5683333333333334, 0.5666666666666667, 0.565, 0.5633333333333334, 0.5616666666666666, 0.5616666666666666, 0.56, 0.56, 0.5583333333333333, 0.5583333333333333, 0.5566666666666666, 0.555, 0.5533333333333333, 0.5516666666666666, 0.55, 0.55, 0.5483333333333333, 0.5483333333333333, 0.5483333333333333, 0.5483333333333333, 0.5466666666666666, 0.545, 0.5433333333333333, 0.5416666666666666, 0.54, 0.5383333333333333, 0.5383333333333333, 0.5366666666666666, 0.535, 0.5333333333333333, 0.5333333333333333, 0.5316666666666666, 0.53, 0.5283333333333333, 0.5266666666666666, 0.525, 0.5233333333333333, 0.5216666666666666, 0.52, 0.5183333333333333, 0.5166666666666667, 0.5166666666666667, 0.515, 0.515, 0.5133333333333333, 0.5133333333333333, 0.5116666666666667, 0.51, 0.51, 0.5083333333333333, 0.5083333333333333, 0.5083333333333333, 0.5083333333333333, 0.5083333333333333, 0.5066666666666667, 0.505, 0.5033333333333333, 0.5016666666666667, 0.5, 0.49833333333333335, 0.49666666666666665, 0.495, 0.49333333333333335, 0.49166666666666664, 0.49166666666666664, 0.49, 0.48833333333333334, 0.48833333333333334, 0.48833333333333334, 0.4866666666666667, 0.4866666666666667, 0.485, 0.485, 0.485, 0.485, 0.485, 0.485, 0.48333333333333334, 0.4816666666666667, 0.48, 0.47833333333333333, 0.4766666666666667, 0.4766666666666667, 0.475, 0.47333333333333333, 0.47333333333333333, 0.4716666666666667, 0.47, 0.47, 0.47, 0.47, 0.47, 0.4683333333333333, 0.4666666666666667, 0.465, 0.4633333333333333, 0.46166666666666667, 0.46166666666666667, 0.46, 0.4583333333333333, 0.4583333333333333, 0.45666666666666667, 0.45666666666666667, 0.455, 0.4533333333333333, 0.45166666666666666, 0.45166666666666666, 0.45, 0.4483333333333333, 0.4483333333333333, 0.4483333333333333, 0.44666666666666666, 0.445, 0.445, 0.44333333333333336, 0.44166666666666665, 0.44, 0.43833333333333335, 0.43666666666666665, 0.435, 0.43333333333333335, 0.43166666666666664, 0.43, 0.43, 0.42833333333333334, 0.4266666666666667, 0.425, 0.42333333333333334, 0.42333333333333334, 0.4216666666666667, 0.4216666666666667, 0.42, 0.41833333333333333, 0.4166666666666667, 0.4166666666666667, 0.415, 0.415, 0.41333333333333333, 0.41333333333333333, 0.4116666666666667, 0.41, 0.4083333333333333, 0.4083333333333333, 0.4066666666666667, 0.405, 0.405, 0.4033333333333333, 0.40166666666666667, 0.4, 0.3983333333333333, 0.39666666666666667, 0.395, 0.395, 0.3933333333333333, 0.3933333333333333, 0.39166666666666666, 0.39, 0.3883333333333333, 0.38666666666666666, 0.385, 0.38333333333333336, 0.38166666666666665, 0.38166666666666665, 0.38, 0.37833333333333335, 0.37833333333333335, 0.37666666666666665, 0.375, 0.375, 0.37333333333333335, 0.37333333333333335, 0.37166666666666665, 0.37166666666666665, 0.37, 0.36833333333333335, 0.36833333333333335, 0.36666666666666664, 0.365, 0.365, 0.36333333333333334, 0.3616666666666667, 0.36, 0.35833333333333334, 0.3566666666666667, 0.3566666666666667, 0.355, 0.35333333333333333, 0.3516666666666667, 0.3516666666666667, 0.35, 0.35, 0.34833333333333333, 0.3466666666666667, 0.3466666666666667, 0.345, 0.3433333333333333, 0.3416666666666667, 0.34, 0.3383333333333333, 0.3383333333333333, 0.3383333333333333, 0.33666666666666667, 0.335, 0.3333333333333333, 0.33166666666666667, 0.33, 0.3283333333333333, 0.32666666666666666, 0.325, 0.3233333333333333, 0.32166666666666666, 0.32, 0.31833333333333336, 0.31666666666666665, 0.315, 0.31333333333333335, 0.31333333333333335, 0.31166666666666665, 0.31, 0.30833333333333335, 0.30666666666666664, 0.305, 0.30333333333333334, 0.3016666666666667, 0.3016666666666667, 0.3, 0.29833333333333334, 0.2966666666666667, 0.295, 0.295, 0.29333333333333333, 0.29333333333333333, 0.29333333333333333, 0.2916666666666667, 0.2916666666666667, 0.29, 0.28833333333333333, 0.2866666666666667, 0.2866666666666667, 0.285, 0.2833333333333333, 0.2816666666666667, 0.28, 0.2783333333333333, 0.27666666666666667, 0.27666666666666667, 0.275, 0.2733333333333333, 0.27166666666666667, 0.27, 0.2683333333333333, 0.2683333333333333, 0.26666666666666666, 0.26666666666666666, 0.265, 0.265, 0.2633333333333333, 0.2633333333333333, 0.2633333333333333, 0.2633333333333333, 0.2633333333333333, 0.26166666666666666, 0.26, 0.25833333333333336, 0.25833333333333336, 0.25833333333333336, 0.25666666666666665, 0.255, 0.255, 0.255, 0.25333333333333335, 0.25166666666666665, 0.25, 0.24833333333333332, 0.24666666666666667, 0.24666666666666667, 0.245, 0.24333333333333335, 0.24166666666666667, 0.24166666666666667, 0.24, 0.23833333333333334, 0.23833333333333334, 0.23666666666666666, 0.235, 0.23333333333333334, 0.23166666666666666, 0.23, 0.22833333333333333, 0.22833333333333333, 0.22666666666666666, 0.225, 0.22333333333333333, 0.22166666666666668, 0.22, 0.22, 0.21833333333333332, 0.21666666666666667, 0.215, 0.215, 0.215, 0.21333333333333335, 0.21166666666666667, 0.21166666666666667, 0.21, 0.20833333333333334, 0.20666666666666667, 0.205, 0.20333333333333334, 0.20166666666666666, 0.20166666666666666, 0.2, 0.19833333333333333, 0.19666666666666666, 0.195, 0.19333333333333333, 0.19166666666666668, 0.19, 0.18833333333333332, 0.18833333333333332, 0.18666666666666668, 0.185, 0.18333333333333332, 0.18166666666666667, 0.18, 0.18, 0.17833333333333334, 0.17666666666666667, 0.175, 0.17333333333333334, 0.17166666666666666, 0.17, 0.16833333333333333, 0.16666666666666666, 0.165, 0.165, 0.165, 0.16333333333333333, 0.16333333333333333, 0.16166666666666665, 0.16166666666666665, 0.16, 0.15833333333333333, 0.15666666666666668, 0.155, 0.15333333333333332, 0.15166666666666667, 0.15, 0.15, 0.14833333333333334, 0.14666666666666667, 0.145, 0.14333333333333334, 0.14166666666666666, 0.14, 0.13833333333333334, 0.13833333333333334, 0.13833333333333334, 0.13833333333333334, 0.13666666666666666, 0.135, 0.135, 0.135, 0.13333333333333333, 0.13166666666666665, 0.13166666666666665, 0.13, 0.12833333333333333, 0.12666666666666668, 0.125, 0.125, 0.12333333333333334, 0.12166666666666667, 0.12166666666666667, 0.12, 0.12, 0.12, 0.12, 0.11833333333333333, 0.11833333333333333, 0.11666666666666667, 0.115, 0.115, 0.115, 0.11333333333333333, 0.11166666666666666, 0.11166666666666666, 0.11, 0.10833333333333334, 0.10666666666666667, 0.105, 0.10333333333333333, 0.10333333333333333, 0.10166666666666667, 0.1, 0.09833333333333333, 0.09666666666666666, 0.095, 0.09333333333333334, 0.09166666666666666, 0.09166666666666666, 0.09, 0.08833333333333333, 0.08666666666666667, 0.085, 0.08333333333333333, 0.08166666666666667, 0.08, 0.08, 0.07833333333333334, 0.07833333333333334, 0.07666666666666666, 0.075, 0.07333333333333333, 0.07333333333333333, 0.07166666666666667, 0.07, 0.06833333333333333, 0.06666666666666667, 0.065, 0.065, 0.065, 0.06333333333333334, 0.06166666666666667, 0.06, 0.06, 0.058333333333333334, 0.058333333333333334, 0.056666666666666664, 0.056666666666666664, 0.055, 0.055, 0.05333333333333334, 0.05333333333333334, 0.05333333333333334, 0.051666666666666666, 0.05, 0.05, 0.05, 0.05, 0.05, 0.04833333333333333, 0.04666666666666667, 0.04666666666666667, 0.04666666666666667, 0.045, 0.045, 0.043333333333333335, 0.041666666666666664, 0.04, 0.03833333333333333, 0.03666666666666667, 0.035, 0.03333333333333333, 0.03166666666666667, 0.03166666666666667, 0.03, 0.028333333333333332, 0.028333333333333332, 0.02666666666666667, 0.025, 0.023333333333333334, 0.021666666666666667, 0.021666666666666667, 0.02, 0.018333333333333333, 0.018333333333333333, 0.016666666666666666, 0.016666666666666666, 0.016666666666666666, 0.016666666666666666, 0.016666666666666666, 0.015, 0.015, 0.013333333333333334, 0.011666666666666667, 0.011666666666666667, 0.011666666666666667, 0.01, 0.008333333333333333, 0.006666666666666667, 0.005, 0.005, 0.0033333333333333335, 0.0033333333333333335, 0.0033333333333333335, 0.0016666666666666668, 0.0]}, "loss": 0.33623120260065575}